
/Users/mitchellscott/Desktop/rufous/src/firmware/build/examples/system_graph/graph_tests.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001400:	4288      	cmp	r0, r1
60001402:	d007      	beq.n	60001414 <memory_copy+0x14>
	while (dest < dest_end) {
60001404:	4290      	cmp	r0, r2
60001406:	d205      	bcs.n	60001414 <memory_copy+0x14>
		*dest++ = *src++;
60001408:	f851 3b04 	ldr.w	r3, [r1], #4
6000140c:	f840 3b04 	str.w	r3, [r0], #4

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001410:	4282      	cmp	r2, r0
60001412:	d8f9      	bhi.n	60001408 <memory_copy+0x8>
60001414:	4770      	bx	lr
60001416:	bf00      	nop

60001418 <memory_clear>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001418:	4288      	cmp	r0, r1
6000141a:	d204      	bcs.n	60001426 <memory_clear+0xe>
		*dest++ = 0;
6000141c:	2300      	movs	r3, #0
6000141e:	f840 3b04 	str.w	r3, [r0], #4
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001422:	4281      	cmp	r1, r0
60001424:	d8fb      	bhi.n	6000141e <memory_clear+0x6>
60001426:	4770      	bx	lr

60001428 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001428:	4b66      	ldr	r3, [pc, #408]	; (600015c4 <ResetHandler+0x19c>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000142a:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000142e:	4a66      	ldr	r2, [pc, #408]	; (600015c8 <ResetHandler+0x1a0>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001430:	4866      	ldr	r0, [pc, #408]	; (600015cc <ResetHandler+0x1a4>)
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
void startup_late_hook(void)	__attribute__ ((weak, alias("startup_default_late_hook")));
__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
void ResetHandler(void)
{
60001432:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001436:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001438:	6418      	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143a:	4a65      	ldr	r2, [pc, #404]	; (600015d0 <ResetHandler+0x1a8>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000143c:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143e:	4695      	mov	sp, r2
	__asm__ volatile("dsb":::"memory");
60001440:	f3bf 8f4f 	dsb	sy
	__asm__ volatile("isb":::"memory");
60001444:	f3bf 8f6f 	isb	sy
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
60001448:	f000 f930 	bl	600016ac <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000144c:	4b61      	ldr	r3, [pc, #388]	; (600015d4 <ResetHandler+0x1ac>)
6000144e:	2008      	movs	r0, #8
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001450:	4a61      	ldr	r2, [pc, #388]	; (600015d8 <ResetHandler+0x1b0>)
60001452:	4962      	ldr	r1, [pc, #392]	; (600015dc <ResetHandler+0x1b4>)
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
	__asm__ volatile("dsb":::"memory");
	__asm__ volatile("isb":::"memory");
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001454:	f8c3 0154 	str.w	r0, [r3, #340]	; 0x154
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001458:	4861      	ldr	r0, [pc, #388]	; (600015e0 <ResetHandler+0x1b8>)
6000145a:	f7ff ffd1 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
6000145e:	4a61      	ldr	r2, [pc, #388]	; (600015e4 <ResetHandler+0x1bc>)
60001460:	4961      	ldr	r1, [pc, #388]	; (600015e8 <ResetHandler+0x1c0>)
60001462:	4862      	ldr	r0, [pc, #392]	; (600015ec <ResetHandler+0x1c4>)
60001464:	f7ff ffcc 	bl	60001400 <memory_copy>
	memory_clear(&_sbss, &_ebss);
60001468:	4961      	ldr	r1, [pc, #388]	; (600015f0 <ResetHandler+0x1c8>)
6000146a:	4862      	ldr	r0, [pc, #392]	; (600015f4 <ResetHandler+0x1cc>)
6000146c:	f7ff ffd4 	bl	60001418 <memory_clear>
60001470:	4c61      	ldr	r4, [pc, #388]	; (600015f8 <ResetHandler+0x1d0>)

	// enable FPU
	SCB_CPACR = 0x00F00000;
60001472:	4962      	ldr	r1, [pc, #392]	; (600015fc <ResetHandler+0x1d4>)
60001474:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001478:	2300      	movs	r3, #0
6000147a:	4a61      	ldr	r2, [pc, #388]	; (60001600 <ResetHandler+0x1d8>)
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
6000147c:	6008      	str	r0, [r1, #0]

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000147e:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
60001482:	3301      	adds	r3, #1
60001484:	2bb0      	cmp	r3, #176	; 0xb0
60001486:	d1fa      	bne.n	6000147e <ResetHandler+0x56>
60001488:	4b5e      	ldr	r3, [pc, #376]	; (60001604 <ResetHandler+0x1dc>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
6000148a:	2180      	movs	r1, #128	; 0x80
6000148c:	4a5e      	ldr	r2, [pc, #376]	; (60001608 <ResetHandler+0x1e0>)
6000148e:	f803 1b01 	strb.w	r1, [r3], #1
60001492:	4293      	cmp	r3, r2
60001494:	d1fb      	bne.n	6000148e <ResetHandler+0x66>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001496:	4d4f      	ldr	r5, [pc, #316]	; (600015d4 <ResetHandler+0x1ac>)
60001498:	f04f 3880 	mov.w	r8, #2155905152	; 0x80808080
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
6000149c:	495b      	ldr	r1, [pc, #364]	; (6000160c <ResetHandler+0x1e4>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
6000149e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014a2:	4b5b      	ldr	r3, [pc, #364]	; (60001610 <ResetHandler+0x1e8>)
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600014a4:	2600      	movs	r6, #0

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014a6:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 6000164c <ResetHandler+0x224>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014aa:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 60001650 <ResetHandler+0x228>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014ae:	601c      	str	r4, [r3, #0]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014b0:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014b4:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014b8:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014bc:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c0:	680b      	ldr	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014c2:	4f54      	ldr	r7, [pc, #336]	; (60001614 <ResetHandler+0x1ec>)
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c4:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
600014c8:	600b      	str	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ca:	69fb      	ldr	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014cc:	493d      	ldr	r1, [pc, #244]	; (600015c4 <ResetHandler+0x19c>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ce:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014d6:	61fb      	str	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
600014da:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014e2:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014e4:	668a      	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
600014e6:	66ca      	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
600014e8:	670a      	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
600014ea:	674a      	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
600014ec:	f000 f8e4 	bl	600016b8 <configure_cache>
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f0:	4a49      	ldr	r2, [pc, #292]	; (60001618 <ResetHandler+0x1f0>)
	_VectorsRam[15] = systick_isr;
600014f2:	4b4a      	ldr	r3, [pc, #296]	; (6000161c <ResetHandler+0x1f4>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014f4:	2063      	movs	r0, #99	; 0x63
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f6:	63a2      	str	r2, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
600014f8:	2103      	movs	r1, #3

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
600014fa:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014fc:	4a48      	ldr	r2, [pc, #288]	; (60001620 <ResetHandler+0x1f8>)
	SYST_CVR = 0;
600014fe:	4b49      	ldr	r3, [pc, #292]	; (60001624 <ResetHandler+0x1fc>)
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001500:	6010      	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001502:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
60001506:	601e      	str	r6, [r3, #0]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001508:	f842 1c04 	str.w	r1, [r2, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000150c:	f600 70a1 	addw	r0, r0, #4001	; 0xfa1
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001510:	4945      	ldr	r1, [pc, #276]	; (60001628 <ResetHandler+0x200>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001512:	4a46      	ldr	r2, [pc, #280]	; (6000162c <ResetHandler+0x204>)
60001514:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001518:	680b      	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000151a:	4a45      	ldr	r2, [pc, #276]	; (60001630 <ResetHandler+0x208>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000151c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
60001520:	600b      	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001522:	6813      	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001524:	4943      	ldr	r1, [pc, #268]	; (60001634 <ResetHandler+0x20c>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001526:	f043 0301 	orr.w	r3, r3, #1
6000152a:	6013      	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000152c:	6803      	ldr	r3, [r0, #0]
6000152e:	600b      	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
60001530:	f000 fb12 	bl	60001b58 <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001534:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001538:	483f      	ldr	r0, [pc, #252]	; (60001638 <ResetHandler+0x210>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000153a:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000153e:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001542:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001546:	f000 fd8f 	bl	60002068 <__set_arm_clock_veneer>
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154a:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
6000154c:	4a3b      	ldr	r2, [pc, #236]	; (6000163c <ResetHandler+0x214>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154e:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001552:	4b3b      	ldr	r3, [pc, #236]	; (60001640 <ResetHandler+0x218>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001554:	66f9      	str	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
60001556:	6016      	str	r6, [r2, #0]
	PIT_TCTRL0 = 0;
60001558:	f8c2 6108 	str.w	r6, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000155c:	f8c2 6118 	str.w	r6, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001560:	f8c2 6128 	str.w	r6, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001564:	f8c2 6138 	str.w	r6, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001568:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000156a:	07d2      	lsls	r2, r2, #31
6000156c:	d408      	bmi.n	60001580 <ResetHandler+0x158>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000156e:	f642 6215 	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
60001572:	4934      	ldr	r1, [pc, #208]	; (60001644 <ResetHandler+0x21c>)
60001574:	6559      	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001576:	651a      	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001578:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000157a:	f042 0201 	orr.w	r2, r2, #1
6000157e:	639a      	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
60001580:	4a2f      	ldr	r2, [pc, #188]	; (60001640 <ResetHandler+0x218>)
60001582:	4c31      	ldr	r4, [pc, #196]	; (60001648 <ResetHandler+0x220>)
60001584:	6893      	ldr	r3, [r2, #8]
60001586:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
6000158a:	6093      	str	r3, [r2, #8]

#ifdef ARDUINO_TEENSY41
	configure_external_ram();
6000158c:	f000 f906 	bl	6000179c <configure_external_ram>
#endif
	analog_init();
60001590:	f000 f860 	bl	60001654 <analog_init>
	pwm_init();
60001594:	f000 fd7c 	bl	60002090 <__pwm_init_veneer>
	tempmon_init();
60001598:	f000 fb10 	bl	60001bbc <tempmon_init>
	startup_middle_hook();
6000159c:	f000 f888 	bl	600016b0 <startup_default_middle_hook>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
600015a0:	6823      	ldr	r3, [r4, #0]
#endif
	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290?p=87273&viewfull=1#post87273

	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015a2:	2b13      	cmp	r3, #19
600015a4:	d9fc      	bls.n	600015a0 <ResetHandler+0x178>
	usb_init();
600015a6:	f000 fb97 	bl	60001cd8 <usb_init>
600015aa:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015ac:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
600015b0:	d3fb      	bcc.n	600015aa <ResetHandler+0x182>
	//printf("before C++ constructors\n");
	startup_late_hook();
600015b2:	f000 f87f 	bl	600016b4 <startup_default_late_hook>
	__libc_init_array();
600015b6:	f000 fd5f 	bl	60002078 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
600015ba:	f000 fd4d 	bl	60002058 <__main_veneer>
	
	while (1) asm("WFI");
600015be:	bf30      	wfi
600015c0:	e7fd      	b.n	600015be <ResetHandler+0x196>
600015c2:	bf00      	nop
600015c4:	400ac000 	.word	0x400ac000
600015c8:	aaaaaaaf 	.word	0xaaaaaaaf
600015cc:	00200007 	.word	0x00200007
600015d0:	20070000 	.word	0x20070000
600015d4:	400d8000 	.word	0x400d8000
600015d8:	0000a188 	.word	0x0000a188
600015dc:	60002278 	.word	0x60002278
600015e0:	00000000 	.word	0x00000000
600015e4:	200022c0 	.word	0x200022c0
600015e8:	6000c404 	.word	0x6000c404
600015ec:	20000000 	.word	0x20000000
600015f0:	200027e0 	.word	0x200027e0
600015f4:	200022c0 	.word	0x200022c0
600015f8:	20002000 	.word	0x20002000
600015fc:	e000ed88 	.word	0xe000ed88
60001600:	000016d9 	.word	0x000016d9
60001604:	e000e400 	.word	0xe000e400
60001608:	e000e4a0 	.word	0xe000e4a0
6000160c:	e000ed24 	.word	0xe000ed24
60001610:	e000ed08 	.word	0xe000ed08
60001614:	400fc000 	.word	0x400fc000
60001618:	00002839 	.word	0x00002839
6000161c:	0000283d 	.word	0x0000283d
60001620:	e000e014 	.word	0xe000e014
60001624:	e000e018 	.word	0xe000e018
60001628:	e000edfc 	.word	0xe000edfc
6000162c:	20200000 	.word	0x20200000
60001630:	e0001000 	.word	0xe0001000
60001634:	2000273c 	.word	0x2000273c
60001638:	23c34600 	.word	0x23c34600
6000163c:	40084000 	.word	0x40084000
60001640:	400d4000 	.word	0x400d4000
60001644:	56c00000 	.word	0x56c00000
60001648:	20002740 	.word	0x20002740
6000164c:	2018101b 	.word	0x2018101b
60001650:	13110d0c 	.word	0x13110d0c

60001654 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001654:	4b11      	ldr	r3, [pc, #68]	; (6000169c <analog_init+0x48>)
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001656:	4912      	ldr	r1, [pc, #72]	; (600016a0 <analog_init+0x4c>)
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001658:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
6000165a:	460a      	mov	r2, r1
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
6000165c:	f440 3040 	orr.w	r0, r0, #196608	; 0x30000
}

#define MAX_ADC_CLOCK 20000000

FLASHMEM void analog_init(void)
{
60001660:	b430      	push	{r4, r5}
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001662:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001664:	f240 6537 	movw	r5, #1591	; 0x637
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001668:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
6000166a:	24a0      	movs	r4, #160	; 0xa0
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
6000166c:	f440 7040 	orr.w	r0, r0, #768	; 0x300
60001670:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001672:	644d      	str	r5, [r1, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001674:	648c      	str	r4, [r1, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
60001676:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001678:	061b      	lsls	r3, r3, #24
6000167a:	d4fc      	bmi.n	60001676 <analog_init+0x22>
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
6000167c:	4b09      	ldr	r3, [pc, #36]	; (600016a4 <analog_init+0x50>)
6000167e:	f240 6037 	movw	r0, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001682:	21a0      	movs	r1, #160	; 0xa0
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
60001684:	461a      	mov	r2, r3
	while (ADC1_GC & ADC_GC_CAL) {
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001686:	6458      	str	r0, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001688:	6499      	str	r1, [r3, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
6000168a:	6c93      	ldr	r3, [r2, #72]	; 0x48
6000168c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
60001690:	d1fb      	bne.n	6000168a <analog_init+0x36>
		//yield();
	}
	calibrating = 0;
60001692:	4a05      	ldr	r2, [pc, #20]	; (600016a8 <analog_init+0x54>)
60001694:	7013      	strb	r3, [r2, #0]
}
60001696:	bc30      	pop	{r4, r5}
60001698:	4770      	bx	lr
6000169a:	bf00      	nop
6000169c:	400fc000 	.word	0x400fc000
600016a0:	400c4000 	.word	0x400c4000
600016a4:	400c8000 	.word	0x400c8000
600016a8:	20002751 	.word	0x20002751

600016ac <startup_default_early_hook>:
600016ac:	4770      	bx	lr
600016ae:	bf00      	nop

600016b0 <startup_default_middle_hook>:
600016b0:	4770      	bx	lr
600016b2:	bf00      	nop

600016b4 <startup_default_late_hook>:
extern int main (void);
FLASHMEM void startup_default_early_hook(void) {}
void startup_early_hook(void)	__attribute__ ((weak, alias("startup_default_early_hook")));
FLASHMEM void startup_default_middle_hook(void) {}
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
600016b4:	4770      	bx	lr
600016b6:	bf00      	nop

600016b8 <configure_cache>:
#define SIZE_2G		(SCB_MPU_RASR_SIZE(30) | SCB_MPU_RASR_ENABLE)
#define SIZE_4G		(SCB_MPU_RASR_SIZE(31) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
600016b8:	b5f0      	push	{r4, r5, r6, r7, lr}
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016ba:	4a24      	ldr	r2, [pc, #144]	; (6000174c <configure_cache+0x94>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016bc:	2000      	movs	r0, #0

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016be:	4b24      	ldr	r3, [pc, #144]	; (60001750 <configure_cache+0x98>)
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016c0:	f04f 0c10 	mov.w	ip, #16
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016c4:	4c23      	ldr	r4, [pc, #140]	; (60001754 <configure_cache+0x9c>)

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016c6:	2611      	movs	r6, #17

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016c8:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 60001794 <configure_cache+0xdc>
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016cc:	2712      	movs	r7, #18
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016ce:	6020      	str	r0, [r4, #0]
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600016d0:	2501      	movs	r5, #1
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016d2:	f8c2 c000 	str.w	ip, [r2]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016d6:	f8c3 e000 	str.w	lr, [r3]
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016da:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016dc:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 60001798 <configure_cache+0xe0>

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016e0:	4e1d      	ldr	r6, [pc, #116]	; (60001758 <configure_cache+0xa0>)
	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016e2:	f8c3 e000 	str.w	lr, [r3]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016e6:	491d      	ldr	r1, [pc, #116]	; (6000175c <configure_cache+0xa4>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016e8:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016ea:	601e      	str	r6, [r3, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016ec:	f041 0115 	orr.w	r1, r1, #21
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f0:	4f1b      	ldr	r7, [pc, #108]	; (60001760 <configure_cache+0xa8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f2:	4e1c      	ldr	r6, [pc, #112]	; (60001764 <configure_cache+0xac>)
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f4:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f6:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016f8:	4f1b      	ldr	r7, [pc, #108]	; (60001768 <configure_cache+0xb0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fa:	4e1c      	ldr	r6, [pc, #112]	; (6000176c <configure_cache+0xb4>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016fc:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fe:	601e      	str	r6, [r3, #0]
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001700:	4f1b      	ldr	r7, [pc, #108]	; (60001770 <configure_cache+0xb8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
60001702:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
60001704:	4e1b      	ldr	r6, [pc, #108]	; (60001774 <configure_cache+0xbc>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
60001706:	491c      	ldr	r1, [pc, #112]	; (60001778 <configure_cache+0xc0>)

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001708:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
6000170a:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
6000170c:	4f1b      	ldr	r7, [pc, #108]	; (6000177c <configure_cache+0xc4>)
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
6000170e:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001710:	4e1b      	ldr	r6, [pc, #108]	; (60001780 <configure_cache+0xc8>)

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
60001712:	491c      	ldr	r1, [pc, #112]	; (60001784 <configure_cache+0xcc>)
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
60001714:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001716:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001718:	4f1b      	ldr	r7, [pc, #108]	; (60001788 <configure_cache+0xd0>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
6000171a:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
6000171c:	4e1b      	ldr	r6, [pc, #108]	; (6000178c <configure_cache+0xd4>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
6000171e:	491c      	ldr	r1, [pc, #112]	; (60001790 <configure_cache+0xd8>)

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001720:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
60001722:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
60001724:	6019      	str	r1, [r3, #0]

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
60001726:	6025      	str	r5, [r4, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
60001728:	f3bf 8f4f 	dsb	sy
	asm("isb");
6000172c:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
60001730:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0

	asm("dsb");
60001734:	f3bf 8f4f 	dsb	sy
	asm("isb");
60001738:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000173c:	f852 3c88 	ldr.w	r3, [r2, #-136]
60001740:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
60001744:	f842 3c88 	str.w	r3, [r2, #-136]
60001748:	bdf0      	pop	{r4, r5, r6, r7, pc}
6000174a:	bf00      	nop
6000174c:	e000ed9c 	.word	0xe000ed9c
60001750:	e000eda0 	.word	0xe000eda0
60001754:	e000ed94 	.word	0xe000ed94
60001758:	00100009 	.word	0x00100009
6000175c:	200027e0 	.word	0x200027e0
60001760:	00200013 	.word	0x00200013
60001764:	07020021 	.word	0x07020021
60001768:	20000014 	.word	0x20000014
6000176c:	13080025 	.word	0x13080025
60001770:	10000009 	.word	0x10000009
60001774:	20200016 	.word	0x20200016
60001778:	130b0027 	.word	0x130b0027
6000177c:	40000017 	.word	0x40000017
60001780:	13100033 	.word	0x13100033
60001784:	60000018 	.word	0x60000018
60001788:	070b002f 	.word	0x070b002f
6000178c:	70000019 	.word	0x70000019
60001790:	130b002f 	.word	0x130b002f
60001794:	1000003f 	.word	0x1000003f
60001798:	03080025 	.word	0x03080025

6000179c <configure_external_ram>:
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
6000179c:	b5f0      	push	{r4, r5, r6, r7, lr}
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
6000179e:	4b8d      	ldr	r3, [pc, #564]	; (600019d4 <configure_external_ram+0x238>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017a0:	2218      	movs	r2, #24
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017a2:	4e8d      	ldr	r6, [pc, #564]	; (600019d8 <configure_external_ram+0x23c>)
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017a4:	2001      	movs	r0, #1
}

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017a6:	498d      	ldr	r1, [pc, #564]	; (600019dc <configure_external_ram+0x240>)
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
600017a8:	f248 7e0c 	movw	lr, #34572	; 0x870c

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ac:	4d8c      	ldr	r5, [pc, #560]	; (600019e0 <configure_external_ram+0x244>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
600017ae:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017b2:	4c8c      	ldr	r4, [pc, #560]	; (600019e4 <configure_external_ram+0x248>)
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
600017b4:	b083      	sub	sp, #12
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017b6:	f8c3 125c 	str.w	r1, [r3, #604]	; 0x25c
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ba:	f8c3 5260 	str.w	r5, [r3, #608]	; 0x260
	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
600017be:	2500      	movs	r5, #0
FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017c0:	f8c3 1264 	str.w	r1, [r3, #612]	; 0x264
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017c4:	f8c3 4268 	str.w	r4, [r3, #616]	; 0x268
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600017c8:	f44f 5400 	mov.w	r4, #8192	; 0x2000
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017cc:	f8c3 626c 	str.w	r6, [r3, #620]	; 0x26c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017d0:	4985      	ldr	r1, [pc, #532]	; (600019e8 <configure_external_ram+0x24c>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d2:	f8c3 6270 	str.w	r6, [r3, #624]	; 0x270
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d6:	f8c3 6274 	str.w	r6, [r3, #628]	; 0x274
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017da:	f8c3 6278 	str.w	r6, [r3, #632]	; 0x278
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
600017de:	4e83      	ldr	r6, [pc, #524]	; (600019ec <configure_external_ram+0x250>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017e0:	66da      	str	r2, [r3, #108]	; 0x6c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DQS
600017e2:	671a      	str	r2, [r3, #112]	; 0x70
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS0_B (RAM)
600017e4:	675a      	str	r2, [r3, #116]	; 0x74
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SCLK
600017e6:	679a      	str	r2, [r3, #120]	; 0x78
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
600017e8:	67da      	str	r2, [r3, #124]	; 0x7c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
600017ea:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
600017ee:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3
600017f2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600017f6:	f240 6205 	movw	r2, #1541	; 0x605
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017fa:	f8c1 032c 	str.w	r0, [r1, #812]	; 0x32c
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT = 1; // GPIO_EMC_26 for Mode: ALT8
600017fe:	f8c1 0330 	str.w	r0, [r1, #816]	; 0x330
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT = 1; // GPIO_EMC_27 for Mode: ALT8
60001802:	f8c1 0334 	str.w	r0, [r1, #820]	; 0x334
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
60001806:	f8c1 0338 	str.w	r0, [r1, #824]	; 0x338
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
6000180a:	f8c1 033c 	str.w	r0, [r1, #828]	; 0x33c
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8
6000180e:	f8c1 0350 	str.w	r0, [r1, #848]	; 0x350
	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
60001812:	4629      	mov	r1, r5
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001814:	69b3      	ldr	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
60001816:	4876      	ldr	r0, [pc, #472]	; (600019f0 <configure_external_ram+0x254>)
60001818:	4018      	ands	r0, r3
6000181a:	4b76      	ldr	r3, [pc, #472]	; (600019f4 <configure_external_ram+0x258>)
6000181c:	4303      	orrs	r3, r0
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
6000181e:	4876      	ldr	r0, [pc, #472]	; (600019f8 <configure_external_ram+0x25c>)
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001820:	61b3      	str	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);
60001822:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
60001826:	f043 030c 	orr.w	r3, r3, #12
6000182a:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
6000182e:	2602      	movs	r6, #2
	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
60001830:	6803      	ldr	r3, [r0, #0]
60001832:	4333      	orrs	r3, r6
60001834:	6003      	str	r3, [r0, #0]
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001836:	6803      	ldr	r3, [r0, #0]
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
60001838:	ea03 0e0e 	and.w	lr, r3, lr
6000183c:	4b6f      	ldr	r3, [pc, #444]	; (600019fc <configure_external_ram+0x260>)
6000183e:	ea4e 0303 	orr.w	r3, lr, r3
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001842:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 60001a34 <configure_external_ram+0x298>
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001846:	6003      	str	r3, [r0, #0]
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001848:	4b6d      	ldr	r3, [pc, #436]	; (60001a00 <configure_external_ram+0x264>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
6000184a:	6047      	str	r7, [r0, #4]
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
6000184c:	f8de 7008 	ldr.w	r7, [lr, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001850:	403b      	ands	r3, r7
	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001852:	4f6c      	ldr	r7, [pc, #432]	; (60001a04 <configure_external_ram+0x268>)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001854:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001858:	6083      	str	r3, [r0, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
6000185a:	68c3      	ldr	r3, [r0, #12]
6000185c:	f023 0378 	bic.w	r3, r3, #120	; 0x78
60001860:	60c3      	str	r3, [r0, #12]
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001862:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001864:	401f      	ands	r7, r3
60001866:	4b68      	ldr	r3, [pc, #416]	; (60001a08 <configure_external_ram+0x26c>)
60001868:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
6000186a:	4f66      	ldr	r7, [pc, #408]	; (60001a04 <configure_external_ram+0x268>)

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186c:	6203      	str	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186e:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001870:	401f      	ands	r7, r3
60001872:	4b65      	ldr	r3, [pc, #404]	; (60001a08 <configure_external_ram+0x26c>)
60001874:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF2CR0 = mask;
60001876:	4f65      	ldr	r7, [pc, #404]	; (60001a0c <configure_external_ram+0x270>)
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001878:	6243      	str	r3, [r0, #36]	; 0x24
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
6000187a:	6287      	str	r7, [r0, #40]	; 0x28
	FLEXSPI2_AHBRXBUF3CR0 = mask;
6000187c:	62c7      	str	r7, [r0, #44]	; 0x2c

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
6000187e:	f8de 30b8 	ldr.w	r3, [lr, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
60001882:	4f63      	ldr	r7, [pc, #396]	; (60001a10 <configure_external_ram+0x274>)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
60001884:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
60001888:	f043 0301 	orr.w	r3, r3, #1
6000188c:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001890:	f8de 30bc 	ldr.w	r3, [lr, #188]	; 0xbc
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
60001894:	f8df e184 	ldr.w	lr, [pc, #388]	; 60001a1c <configure_external_ram+0x280>
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001898:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
6000189c:	f043 0301 	orr.w	r3, r3, #1
600018a0:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc

	FLEXSPI2_INTEN = 0;
600018a4:	6105      	str	r5, [r0, #16]
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600018a6:	6604      	str	r4, [r0, #96]	; 0x60
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018a8:	6707      	str	r7, [r0, #112]	; 0x70
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018aa:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_FLSHA2CR0 = 0x2000; // 8 MByte
600018ae:	6644      	str	r4, [r0, #100]	; 0x64
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018b0:	6747      	str	r7, [r0, #116]	; 0x74
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018b2:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018b6:	6804      	ldr	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018b8:	4b56      	ldr	r3, [pc, #344]	; (60001a14 <configure_external_ram+0x278>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018ba:	f024 0402 	bic.w	r4, r4, #2

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018be:	4a56      	ldr	r2, [pc, #344]	; (60001a18 <configure_external_ram+0x27c>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018c0:	6004      	str	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018c2:	f8c0 e018 	str.w	lr, [r0, #24]
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018c6:	61c6      	str	r6, [r0, #28]
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018c8:	f843 1b04 	str.w	r1, [r3], #4
600018cc:	4293      	cmp	r3, r2
600018ce:	d1fb      	bne.n	600018c8 <configure_external_ram+0x12c>
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d0:	4b49      	ldr	r3, [pc, #292]	; (600019f8 <configure_external_ram+0x25c>)
600018d2:	681a      	ldr	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018d4:	4619      	mov	r1, r3

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d6:	f042 0201 	orr.w	r2, r2, #1
600018da:	601a      	str	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018dc:	680b      	ldr	r3, [r1, #0]
600018de:	4a46      	ldr	r2, [pc, #280]	; (600019f8 <configure_external_ram+0x25c>)
600018e0:	f013 0301 	ands.w	r3, r3, #1
600018e4:	d1fa      	bne.n	600018dc <configure_external_ram+0x140>

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018e6:	4e4d      	ldr	r6, [pc, #308]	; (60001a1c <configure_external_ram+0x280>)
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018e8:	2502      	movs	r5, #2

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
600018ea:	f240 64f5 	movw	r4, #1781	; 0x6f5
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
600018ee:	f240 4066 	movw	r0, #1126	; 0x466
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
600018f2:	f240 4199 	movw	r1, #1177	; 0x499
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
600018f6:	4f4a      	ldr	r7, [pc, #296]	; (60001a20 <configure_external_ram+0x284>)
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018f8:	6196      	str	r6, [r2, #24]
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
600018fa:	f242 4601 	movw	r6, #9217	; 0x2401
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018fe:	61d5      	str	r5, [r2, #28]
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001900:	f240 4535 	movw	r5, #1077	; 0x435

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
60001904:	f8c2 4200 	str.w	r4, [r2, #512]	; 0x200
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
60001908:	f242 2401 	movw	r4, #8705	; 0x2201
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
6000190c:	f8c2 0210 	str.w	r0, [r2, #528]	; 0x210

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001910:	2001      	movs	r0, #1
	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
60001912:	f8c2 1220 	str.w	r1, [r2, #544]	; 0x220
FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001916:	4611      	mov	r1, r2
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
60001918:	f8c2 7230 	str.w	r7, [r2, #560]	; 0x230
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
6000191c:	f107 475a 	add.w	r7, r7, #3657433088	; 0xda000000
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
60001920:	f8c2 6234 	str.w	r6, [r2, #564]	; 0x234
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001924:	f507 7713 	add.w	r7, r7, #588	; 0x24c
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001928:	f8c2 5240 	str.w	r5, [r2, #576]	; 0x240
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
6000192c:	4e3d      	ldr	r6, [pc, #244]	; (60001a24 <configure_external_ram+0x288>)
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
6000192e:	4d3e      	ldr	r5, [pc, #248]	; (60001a28 <configure_external_ram+0x28c>)
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001930:	f8c2 7250 	str.w	r7, [r2, #592]	; 0x250
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
60001934:	f8c2 6254 	str.w	r6, [r2, #596]	; 0x254
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
60001938:	f8c2 5260 	str.w	r5, [r2, #608]	; 0x260
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
6000193c:	f8c2 4264 	str.w	r4, [r2, #612]	; 0x264
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001940:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001944:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001948:	f8c2 00b0 	str.w	r0, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000194c:	694b      	ldr	r3, [r1, #20]
6000194e:	4a2a      	ldr	r2, [pc, #168]	; (600019f8 <configure_external_ram+0x25c>)
60001950:	07dd      	lsls	r5, r3, #31
60001952:	d5fb      	bpl.n	6000194c <configure_external_ram+0x1b0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001954:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001956:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001958:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000195c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000195e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001960:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001964:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001968:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000196c:	694b      	ldr	r3, [r1, #20]
6000196e:	4a22      	ldr	r2, [pc, #136]	; (600019f8 <configure_external_ram+0x25c>)
60001970:	07dc      	lsls	r4, r3, #31
60001972:	d5fb      	bpl.n	6000196c <configure_external_ram+0x1d0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001974:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001976:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001978:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000197c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000197e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001980:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001984:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001988:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000198c:	694b      	ldr	r3, [r1, #20]
6000198e:	4a1a      	ldr	r2, [pc, #104]	; (600019f8 <configure_external_ram+0x25c>)
60001990:	07d8      	lsls	r0, r3, #31
60001992:	d5fb      	bpl.n	6000198c <configure_external_ram+0x1f0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001994:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001996:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001998:	4824      	ldr	r0, [pc, #144]	; (60001a2c <configure_external_ram+0x290>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000199a:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000199c:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000199e:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
600019a2:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
600019a6:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
600019aa:	694b      	ldr	r3, [r1, #20]
600019ac:	4a12      	ldr	r2, [pc, #72]	; (600019f8 <configure_external_ram+0x25c>)
600019ae:	07db      	lsls	r3, r3, #31
600019b0:	d5fb      	bpl.n	600019aa <configure_external_ram+0x20e>
	uint32_t id = FLEXSPI2_RFDR0;
600019b2:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019b6:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019ba:	2021      	movs	r0, #33	; 0x21

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019bc:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019be:	6150      	str	r0, [r2, #20]

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019c0:	428b      	cmp	r3, r1
600019c2:	d039      	beq.n	60001a38 <configure_external_ram+0x29c>
			external_psram_size * 0x100000 -
			((uint32_t)&_extram_end - (uint32_t)&_extram_start),
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
600019c4:	4b1a      	ldr	r3, [pc, #104]	; (60001a30 <configure_external_ram+0x294>)
600019c6:	2200      	movs	r2, #0
600019c8:	601a      	str	r2, [r3, #0]
600019ca:	605a      	str	r2, [r3, #4]
600019cc:	609a      	str	r2, [r3, #8]
600019ce:	60da      	str	r2, [r3, #12]
	}
}
600019d0:	b003      	add	sp, #12
600019d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
600019d4:	401f8000 	.word	0x401f8000
600019d8:	000170f9 	.word	0x000170f9
600019dc:	0001b0f9 	.word	0x0001b0f9
600019e0:	000110f9 	.word	0x000110f9
600019e4:	000100f9 	.word	0x000100f9
600019e8:	401f8400 	.word	0x401f8400
600019ec:	400fc000 	.word	0x400fc000
600019f0:	1ffffcff 	.word	0x1ffffcff
600019f4:	a0000300 	.word	0xa0000300
600019f8:	402a4000 	.word	0x402a4000
600019fc:	ffff0012 	.word	0xffff0012
60001a00:	00f737ff 	.word	0x00f737ff
60001a04:	7cf0ff00 	.word	0x7cf0ff00
60001a08:	80000040 	.word	0x80000040
60001a0c:	830f00ff 	.word	0x830f00ff
60001a10:	00020063 	.word	0x00020063
60001a14:	402a4200 	.word	0x402a4200
60001a18:	402a4300 	.word	0x402a4300
60001a1c:	5af05af0 	.word	0x5af05af0
60001a20:	3018049f 	.word	0x3018049f
60001a24:	26013206 	.word	0x26013206
60001a28:	0a180638 	.word	0x0a180638
60001a2c:	00030004 	.word	0x00030004
60001a30:	200027a4 	.word	0x200027a4
60001a34:	402a8000 	.word	0x402a8000
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a38:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a3a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a3e:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a40:	4611      	mov	r1, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a42:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a46:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a4a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a4e:	694b      	ldr	r3, [r1, #20]
60001a50:	4a3b      	ldr	r2, [pc, #236]	; (60001b40 <configure_external_ram+0x3a4>)
60001a52:	07df      	lsls	r7, r3, #31
60001a54:	d5fb      	bpl.n	60001a4e <configure_external_ram+0x2b2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a56:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a58:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a5c:	2000      	movs	r0, #0
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a5e:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a60:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a62:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a66:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a6a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a6e:	694b      	ldr	r3, [r1, #20]
60001a70:	4a33      	ldr	r2, [pc, #204]	; (60001b40 <configure_external_ram+0x3a4>)
60001a72:	07de      	lsls	r6, r3, #31
60001a74:	d5fb      	bpl.n	60001a6e <configure_external_ram+0x2d2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a76:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a78:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a7c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a80:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a82:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a84:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a88:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a8c:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a90:	694b      	ldr	r3, [r1, #20]
60001a92:	4a2b      	ldr	r2, [pc, #172]	; (60001b40 <configure_external_ram+0x3a4>)
60001a94:	07dd      	lsls	r5, r3, #31
60001a96:	d5fb      	bpl.n	60001a90 <configure_external_ram+0x2f4>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a98:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a9a:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a9e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001aa2:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aa4:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001aa6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001aaa:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001aae:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ab2:	694b      	ldr	r3, [r1, #20]
60001ab4:	4a22      	ldr	r2, [pc, #136]	; (60001b40 <configure_external_ram+0x3a4>)
60001ab6:	07dc      	lsls	r4, r3, #31
60001ab8:	d5fb      	bpl.n	60001ab2 <configure_external_ram+0x316>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aba:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001abc:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001ac0:	4820      	ldr	r0, [pc, #128]	; (60001b44 <configure_external_ram+0x3a8>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ac2:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001ac4:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001ac6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001aca:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001ace:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ad2:	694b      	ldr	r3, [r1, #20]
60001ad4:	4a1a      	ldr	r2, [pc, #104]	; (60001b40 <configure_external_ram+0x3a4>)
60001ad6:	07d8      	lsls	r0, r3, #31
60001ad8:	d5fb      	bpl.n	60001ad2 <configure_external_ram+0x336>
	uint32_t id = FLEXSPI2_RFDR0;
60001ada:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ade:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae2:	2021      	movs	r0, #33	; 0x21
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae4:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae6:	6150      	str	r0, [r2, #20]
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae8:	428b      	cmp	r3, r1
60001aea:	d010      	beq.n	60001b0e <configure_external_ram+0x372>
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
		} else {
			// One PSRAM chip is present, 8 MByte
			external_psram_size = 8;
60001aec:	4b16      	ldr	r3, [pc, #88]	; (60001b48 <configure_external_ram+0x3ac>)
60001aee:	2208      	movs	r2, #8
60001af0:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
60001af4:	701a      	strb	r2, [r3, #0]
		}
		// TODO: zero uninitialized EXTMEM variables
		// TODO: copy from flash to initialize EXTMEM variables
		sm_set_pool(&extmem_smalloc_pool, &_extram_end,
60001af6:	4915      	ldr	r1, [pc, #84]	; (60001b4c <configure_external_ram+0x3b0>)
60001af8:	2000      	movs	r0, #0
60001afa:	4a15      	ldr	r2, [pc, #84]	; (60001b50 <configure_external_ram+0x3b4>)
60001afc:	2301      	movs	r3, #1
60001afe:	9000      	str	r0, [sp, #0]
60001b00:	1a52      	subs	r2, r2, r1
60001b02:	4814      	ldr	r0, [pc, #80]	; (60001b54 <configure_external_ram+0x3b8>)
60001b04:	4422      	add	r2, r4
60001b06:	f000 faab 	bl	60002060 <__sm_set_pool_veneer>
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
	}
}
60001b0a:	b003      	add	sp, #12
60001b0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b0e:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b12:	f44f 2180 	mov.w	r1, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b16:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b18:	4610      	mov	r0, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b1a:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b1e:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b22:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b26:	6943      	ldr	r3, [r0, #20]
60001b28:	4905      	ldr	r1, [pc, #20]	; (60001b40 <configure_external_ram+0x3a4>)
60001b2a:	07db      	lsls	r3, r3, #31
60001b2c:	d5fb      	bpl.n	60001b26 <configure_external_ram+0x38a>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b2e:	2001      	movs	r0, #1
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b30:	4b05      	ldr	r3, [pc, #20]	; (60001b48 <configure_external_ram+0x3ac>)
60001b32:	2210      	movs	r2, #16
60001b34:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b38:	6148      	str	r0, [r1, #20]
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b3a:	701a      	strb	r2, [r3, #0]
60001b3c:	e7db      	b.n	60001af6 <configure_external_ram+0x35a>
60001b3e:	bf00      	nop
60001b40:	402a4000 	.word	0x402a4000
60001b44:	00030004 	.word	0x00030004
60001b48:	20002752 	.word	0x20002752
60001b4c:	70000000 	.word	0x70000000
60001b50:	70000000 	.word	0x70000000
60001b54:	200027a4 	.word	0x200027a4

60001b58 <usb_pll_start>:

#endif // ARDUINO_TEENSY41


FLASHMEM void usb_pll_start()
{
60001b58:	b4f0      	push	{r4, r5, r6, r7}
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b5a:	4a17      	ldr	r2, [pc, #92]	; (60001bb8 <usb_pll_start+0x60>)
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001b5c:	2740      	movs	r7, #64	; 0x40
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001b5e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b62:	f44f 5680 	mov.w	r6, #4096	; 0x1000
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b66:	f44f 5500 	mov.w	r5, #8192	; 0x2000
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b6a:	f44f 4440 	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b6e:	f243 0042 	movw	r0, #12354	; 0x3042


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b72:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b74:	f013 0f02 	tst.w	r3, #2
60001b78:	d006      	beq.n	60001b88 <usb_pll_start+0x30>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b7a:	6194      	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001b7c:	6151      	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b7e:	6190      	str	r0, [r2, #24]


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b80:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b82:	f013 0f02 	tst.w	r3, #2
60001b86:	d1f8      	bne.n	60001b7a <usb_pll_start+0x22>
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
60001b88:	f413 5f00 	tst.w	r3, #8192	; 0x2000
60001b8c:	d101      	bne.n	60001b92 <usb_pll_start+0x3a>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b8e:	6155      	str	r5, [r2, #20]
			continue;
60001b90:	e7ef      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001b92:	f413 5f80 	tst.w	r3, #4096	; 0x1000
60001b96:	d101      	bne.n	60001b9c <usb_pll_start+0x44>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b98:	6156      	str	r6, [r2, #20]
			continue;
60001b9a:	e7ea      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
60001b9c:	2b00      	cmp	r3, #0
60001b9e:	dae8      	bge.n	60001b72 <usb_pll_start+0x1a>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
60001ba0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
60001ba4:	d001      	beq.n	60001baa <usb_pll_start+0x52>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001ba6:	6191      	str	r1, [r2, #24]
			continue;
60001ba8:	e7e3      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
60001baa:	065b      	lsls	r3, r3, #25
60001bac:	d401      	bmi.n	60001bb2 <usb_pll_start+0x5a>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001bae:	6157      	str	r7, [r2, #20]
			continue;
60001bb0:	e7df      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		return; // everything is as it should be  :-)
	}
}
60001bb2:	bcf0      	pop	{r4, r5, r6, r7}
60001bb4:	4770      	bx	lr
60001bb6:	bf00      	nop
60001bb8:	400d8000 	.word	0x400d8000

60001bbc <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bbc:	4a39      	ldr	r2, [pc, #228]	; (60001ca4 <tempmon_init+0xe8>)

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bbe:	2003      	movs	r0, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bc0:	4939      	ldr	r1, [pc, #228]	; (60001ca8 <tempmon_init+0xec>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bc2:	eef3 5a09 	vmov.f32	s11, #57	; 0x41c80000  25.0
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bc6:	6813      	ldr	r3, [r2, #0]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001bc8:	ed9f 6a38 	vldr	s12, [pc, #224]	; 60001cac <tempmon_init+0xf0>
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bcc:	f023 0301 	bic.w	r3, r3, #1
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001bd0:	eddf 6a37 	vldr	s13, [pc, #220]	; 60001cb0 <tempmon_init+0xf4>
  //asm volatile ("dsb":::"memory");
  //while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
60001bd4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bd6:	6013      	str	r3, [r2, #0]
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001bd8:	2400      	movs	r4, #0
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bda:	6110      	str	r0, [r2, #16]
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bdc:	f8d1 30e0 	ldr.w	r3, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be0:	4f34      	ldr	r7, [pc, #208]	; (60001cb4 <tempmon_init+0xf8>)
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001be2:	b2d8      	uxtb	r0, r3
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001be4:	f3c3 210b 	ubfx	r1, r3, #8, #12
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be8:	0d1b      	lsrs	r3, r3, #20
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001bea:	4e33      	ldr	r6, [pc, #204]	; (60001cb8 <tempmon_init+0xfc>)
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bec:	ee07 0a10 	vmov	s14, r0
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bf0:	ee05 1a10 	vmov	s10, r1
60001bf4:	ee07 3a90 	vmov	s15, r3
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bf8:	4b30      	ldr	r3, [pc, #192]	; (60001cbc <tempmon_init+0x100>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bfa:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001bfe:	4d30      	ldr	r5, [pc, #192]	; (60001cc0 <tempmon_init+0x104>)
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c00:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001c04:	6030      	str	r0, [r6, #0]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001c0a:	6029      	str	r1, [r5, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c0c:	492d      	ldr	r1, [pc, #180]	; (60001cc4 <tempmon_init+0x108>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c0e:	ee37 6a46 	vsub.f32	s12, s14, s12
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c12:	4e2d      	ldr	r6, [pc, #180]	; (60001cc8 <tempmon_init+0x10c>)
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c14:	ee77 7ac5 	vsub.f32	s15, s15, s10
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
60001c18:	482c      	ldr	r0, [pc, #176]	; (60001ccc <tempmon_init+0x110>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c1a:	ee77 6a66 	vsub.f32	s13, s14, s13
60001c1e:	4d2c      	ldr	r5, [pc, #176]	; (60001cd0 <tempmon_init+0x114>)
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c20:	ee37 7a65 	vsub.f32	s14, s14, s11
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c24:	ee26 6a27 	vmul.f32	s12, s12, s15
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c28:	edc7 7a00 	vstr	s15, [r7]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c2c:	ee66 6aa7 	vmul.f32	s13, s13, s15
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c30:	6817      	ldr	r7, [r2, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c32:	ee67 7a27 	vmul.f32	s15, s14, s15
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c36:	ed83 7a00 	vstr	s14, [r3]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c3a:	eec6 5a07 	vdiv.f32	s11, s12, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c3e:	ee86 6a87 	vdiv.f32	s12, s13, s14
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c42:	eec7 6a87 	vdiv.f32	s13, s15, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c46:	ee35 7a85 	vadd.f32	s14, s11, s10
60001c4a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c4e:	ee36 7a05 	vadd.f32	s14, s12, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c52:	ee17 3a90 	vmov	r3, s15
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c56:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c5a:	ea47 5303 	orr.w	r3, r7, r3, lsl #20
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c5e:	ee76 7a85 	vadd.f32	s15, s13, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c62:	6013      	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c64:	ee17 3a10 	vmov	r3, s14
60001c68:	f8d2 7110 	ldr.w	r7, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c6c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c70:	ea01 4103 	and.w	r1, r1, r3, lsl #16
60001c74:	4339      	orrs	r1, r7
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c76:	ee17 3a90 	vmov	r3, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c7a:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c7e:	f3c3 030b 	ubfx	r3, r3, #0, #12
60001c82:	f8d2 1110 	ldr.w	r1, [r2, #272]	; 0x110
60001c86:	430b      	orrs	r3, r1
60001c88:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
60001c8c:	6813      	ldr	r3, [r2, #0]
60001c8e:	f043 0302 	orr.w	r3, r3, #2
60001c92:	6013      	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c94:	7034      	strb	r4, [r6, #0]
60001c96:	f8c0 5140 	str.w	r5, [r0, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001c9a:	4b0e      	ldr	r3, [pc, #56]	; (60001cd4 <tempmon_init+0x118>)
60001c9c:	2201      	movs	r2, #1
}
60001c9e:	bcf0      	pop	{r4, r5, r6, r7}
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001ca0:	601a      	str	r2, [r3, #0]
}
60001ca2:	4770      	bx	lr
60001ca4:	400d8180 	.word	0x400d8180
60001ca8:	401f4400 	.word	0x401f4400
60001cac:	42aa0000 	.word	0x42aa0000
60001cb0:	42b40000 	.word	0x42b40000
60001cb4:	20002734 	.word	0x20002734
60001cb8:	2000272c 	.word	0x2000272c
60001cbc:	20002730 	.word	0x20002730
60001cc0:	20002728 	.word	0x20002728
60001cc4:	0fff0000 	.word	0x0fff0000
60001cc8:	e000e440 	.word	0xe000e440
60001ccc:	20002000 	.word	0x20002000
60001cd0:	0000189d 	.word	0x0000189d
60001cd4:	e000e108 	.word	0xe000e108

60001cd8 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001cd8:	4b30      	ldr	r3, [pc, #192]	; (60001d9c <usb_init+0xc4>)
60001cda:	f640 7261 	movw	r2, #3937	; 0xf61

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
60001cde:	b570      	push	{r4, r5, r6, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001ce0:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001ce4:	f240 4504 	movw	r5, #1028	; 0x404
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
60001ce8:	f000 f9ca 	bl	60002080 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cec:	492c      	ldr	r1, [pc, #176]	; (60001da0 <usb_init+0xc8>)
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001cee:	482d      	ldr	r0, [pc, #180]	; (60001da4 <usb_init+0xcc>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf0:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cf4:	4c2c      	ldr	r4, [pc, #176]	; (60001da8 <usb_init+0xd0>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf6:	f042 0203 	orr.w	r2, r2, #3
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cfa:	4b2c      	ldr	r3, [pc, #176]	; (60001dac <usb_init+0xd4>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cfc:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001d00:	f8c0 5160 	str.w	r5, [r0, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001d04:	6822      	ldr	r2, [r4, #0]
60001d06:	4013      	ands	r3, r2
60001d08:	b91b      	cbnz	r3, 60001d12 <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
60001d0a:	f8d0 31a8 	ldr.w	r3, [r0, #424]	; 0x1a8
60001d0e:	079a      	lsls	r2, r3, #30
60001d10:	d01a      	beq.n	60001d48 <usb_init+0x70>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d12:	4b24      	ldr	r3, [pc, #144]	; (60001da4 <usb_init+0xcc>)
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001d14:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
60001d18:	4a23      	ldr	r2, [pc, #140]	; (60001da8 <usb_init+0xd0>)
60001d1a:	6351      	str	r1, [r2, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d1c:	461a      	mov	r2, r3
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d1e:	f8d3 1140 	ldr.w	r1, [r3, #320]	; 0x140
60001d22:	f041 0102 	orr.w	r1, r1, #2
60001d26:	f8c3 1140 	str.w	r1, [r3, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d2a:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001d2e:	079b      	lsls	r3, r3, #30
60001d30:	d4fb      	bmi.n	60001d2a <usb_init+0x52>
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d32:	f44f 3000 	mov.w	r0, #131072	; 0x20000
60001d36:	491e      	ldr	r1, [pc, #120]	; (60001db0 <usb_init+0xd8>)
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d38:	4b1b      	ldr	r3, [pc, #108]	; (60001da8 <usb_init+0xd0>)
60001d3a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d3e:	6008      	str	r0, [r1, #0]
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d40:	2019      	movs	r0, #25
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d42:	639a      	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d44:	f000 f994 	bl	60002070 <__delay_veneer>
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d48:	4d1a      	ldr	r5, [pc, #104]	; (60001db4 <usb_init+0xdc>)
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d4a:	2200      	movs	r2, #0
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d4c:	4b16      	ldr	r3, [pc, #88]	; (60001da8 <usb_init+0xd0>)
60001d4e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d52:	4c14      	ldr	r4, [pc, #80]	; (60001da4 <usb_init+0xcc>)
60001d54:	260a      	movs	r6, #10
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d56:	6399      	str	r1, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d58:	4628      	mov	r0, r5
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d5a:	601a      	str	r2, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d5c:	4611      	mov	r1, r2
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d5e:	f8c4 61a8 	str.w	r6, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d62:	f44f 7220 	mov.w	r2, #640	; 0x280
60001d66:	f000 f98f 	bl	60002088 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d6a:	f44f 0681 	mov.w	r6, #4227072	; 0x408000
	endpoint_queue_head[1].config = (64 << 16);
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d6e:	f240 1143 	movw	r1, #323	; 0x143
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
	endpoint_queue_head[1].config = (64 << 16);
60001d72:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
60001d76:	4b10      	ldr	r3, [pc, #64]	; (60001db8 <usb_init+0xe0>)
60001d78:	4a10      	ldr	r2, [pc, #64]	; (60001dbc <usb_init+0xe4>)
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d7a:	602e      	str	r6, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
60001d7c:	6428      	str	r0, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001d7e:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d82:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
60001d86:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d8a:	4a0d      	ldr	r2, [pc, #52]	; (60001dc0 <usb_init+0xe8>)
60001d8c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d90:	2301      	movs	r3, #1
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d92:	6011      	str	r1, [r2, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d94:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
60001d98:	bd70      	pop	{r4, r5, r6, pc}
60001d9a:	bf00      	nop
60001d9c:	400d8000 	.word	0x400d8000
60001da0:	400fc000 	.word	0x400fc000
60001da4:	402e0000 	.word	0x402e0000
60001da8:	400d9000 	.word	0x400d9000
60001dac:	001e1c00 	.word	0x001e1c00
60001db0:	e000e28c 	.word	0xe000e28c
60001db4:	20000000 	.word	0x20000000
60001db8:	20002000 	.word	0x20002000
60001dbc:	00001a69 	.word	0x00001a69
60001dc0:	e000e10c 	.word	0xe000e10c

60001dc4 <_reboot_Teensyduino_>:
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


FLASHMEM void _reboot_Teensyduino_(void)
{
60001dc4:	b508      	push	{r3, lr}
	if (!(HW_OCOTP_CFG5 & 0x02)) {
60001dc6:	4b0e      	ldr	r3, [pc, #56]	; (60001e00 <_reboot_Teensyduino_+0x3c>)
60001dc8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
60001dca:	079b      	lsls	r3, r3, #30
60001dcc:	d400      	bmi.n	60001dd0 <_reboot_Teensyduino_+0xc>
		asm("bkpt #251"); // run bootloader
60001dce:	befb      	bkpt	0x00fb
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
60001dd0:	b672      	cpsid	i
		USB1_USBCMD = 0;
60001dd2:	4b0c      	ldr	r3, [pc, #48]	; (60001e04 <_reboot_Teensyduino_+0x40>)
60001dd4:	2000      	movs	r0, #0
		IOMUXC_GPR_GPR16 = 0x00200003;
60001dd6:	4a0c      	ldr	r2, [pc, #48]	; (60001e08 <_reboot_Teensyduino_+0x44>)
{
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
60001dd8:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001ddc:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de0:	490a      	ldr	r1, [pc, #40]	; (60001e0c <_reboot_Teensyduino_+0x48>)
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de2:	f5a3 235f 	sub.w	r3, r3, #913408	; 0xdf000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de6:	6411      	str	r1, [r2, #64]	; 0x40
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de8:	469d      	mov	sp, r3
		__asm__ volatile("dsb":::"memory");
60001dea:	f3bf 8f4f 	dsb	sy
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dee:	4a08      	ldr	r2, [pc, #32]	; (60001e10 <_reboot_Teensyduino_+0x4c>)
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001df0:	f503 43e0 	add.w	r3, r3, #28672	; 0x7000
60001df4:	4907      	ldr	r1, [pc, #28]	; (60001e14 <_reboot_Teensyduino_+0x50>)
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001df6:	6812      	ldr	r2, [r2, #0]
60001df8:	4618      	mov	r0, r3
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001dfa:	6019      	str	r1, [r3, #0]
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dfc:	6893      	ldr	r3, [r2, #8]
60001dfe:	4798      	blx	r3
60001e00:	401f4400 	.word	0x401f4400
60001e04:	402e0000 	.word	0x402e0000
60001e08:	400ac000 	.word	0x400ac000
60001e0c:	00200003 	.word	0x00200003
60001e10:	0020001c 	.word	0x0020001c
60001e14:	eb120000 	.word	0xeb120000

60001e18 <TwoWire::begin()>:
//***************************************************
//  Master Mode
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
60001e18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e1c:	4f29      	ldr	r7, [pc, #164]	; (60001ec4 <TwoWire::begin()+0xac>)
#define CLOCK_STRETCH_TIMEOUT 15000


void TwoWire::setClock(uint32_t frequency)
{
	port->MCR = 0;
60001e1e:	2500      	movs	r5, #0

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e20:	6942      	ldr	r2, [r0, #20]
	port->MCR = 0;
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
60001e22:	2401      	movs	r4, #1
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e24:	6bb9      	ldr	r1, [r7, #56]	; 0x38
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e26:	f04f 0e02 	mov.w	lr, #2

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e2a:	6816      	ldr	r6, [r2, #0]
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1);
60001e2c:	f44f 3830 	mov.w	r8, #180224	; 0x2c000
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e30:	f421 017c 	bic.w	r1, r1, #16515072	; 0xfc0000
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e34:	6903      	ldr	r3, [r0, #16]
{
	port->MCR = 0;
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
60001e36:	f8df c09c 	ldr.w	ip, [pc, #156]	; 60001ed4 <TwoWire::begin()+0xbc>
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e3a:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
60001e3e:	63b9      	str	r1, [r7, #56]	; 0x38
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e40:	6831      	ldr	r1, [r6, #0]
60001e42:	6857      	ldr	r7, [r2, #4]
60001e44:	4339      	orrs	r1, r7
60001e46:	6031      	str	r1, [r6, #0]
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
	port->MCFGR0 = 0;
	port->MFCR = LPI2C_MFCR_RXWATER(1) | LPI2C_MFCR_TXWATER(1);
60001e48:	f04f 1601 	mov.w	r6, #65537	; 0x10001
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
60001e4c:	491e      	ldr	r1, [pc, #120]	; (60001ec8 <TwoWire::begin()+0xb0>)
FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e4e:	f8c3 e010 	str.w	lr, [r3, #16]
#define CLOCK_STRETCH_TIMEOUT 15000


void TwoWire::setClock(uint32_t frequency)
{
	port->MCR = 0;
60001e52:	611d      	str	r5, [r3, #16]
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
60001e54:	f8c3 c048 	str.w	ip, [r3, #72]	; 0x48
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
60001e58:	625c      	str	r4, [r3, #36]	; 0x24
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
60001e5a:	6299      	str	r1, [r3, #40]	; 0x28
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1);
60001e5c:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | LPI2C_MCFGR2_FILTSCL(1) |
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
60001e60:	6c9f      	ldr	r7, [r3, #72]	; 0x48
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001e62:	491a      	ldr	r1, [pc, #104]	; (60001ecc <TwoWire::begin()+0xb4>)
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | LPI2C_MCFGR2_FILTSCL(1) |
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
60001e64:	651f      	str	r7, [r3, #80]	; 0x50
	port->MCFGR0 = 0;
60001e66:	621d      	str	r5, [r3, #32]
	port->MFCR = LPI2C_MFCR_RXWATER(1) | LPI2C_MFCR_TXWATER(1);
60001e68:	659e      	str	r6, [r3, #88]	; 0x58
	port->MCR = LPI2C_MCR_MEN;
60001e6a:	611c      	str	r4, [r3, #16]
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
	setClock(100000);
	// setSDA() & setSCL() may be called before or after begin()
	configSDApin(sda_pin_index_); // Setup SDA register
60001e6c:	7e03      	ldrb	r3, [r0, #24]
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001e6e:	4e18      	ldr	r6, [pc, #96]	; (60001ed0 <TwoWire::begin()+0xb8>)
60001e70:	eb02 1503 	add.w	r5, r2, r3, lsl #4
60001e74:	7a2c      	ldrb	r4, [r5, #8]
60001e76:	462b      	mov	r3, r5
60001e78:	eb01 1404 	add.w	r4, r1, r4, lsl #4
60001e7c:	68a4      	ldr	r4, [r4, #8]
60001e7e:	6026      	str	r6, [r4, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001e80:	7a2c      	ldrb	r4, [r5, #8]
60001e82:	68ed      	ldr	r5, [r5, #12]
60001e84:	eb01 1404 	add.w	r4, r1, r4, lsl #4
60001e88:	6864      	ldr	r4, [r4, #4]
60001e8a:	6025      	str	r5, [r4, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001e8c:	691c      	ldr	r4, [r3, #16]
60001e8e:	b10c      	cbz	r4, 60001e94 <TwoWire::begin()+0x7c>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001e90:	695b      	ldr	r3, [r3, #20]
60001e92:	6023      	str	r3, [r4, #0]
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
	setClock(100000);
	// setSDA() & setSCL() may be called before or after begin()
	configSDApin(sda_pin_index_); // Setup SDA register
	configSCLpin(scl_pin_index_); // setup SCL register
60001e94:	7e40      	ldrb	r0, [r0, #25]
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001e96:	4c0e      	ldr	r4, [pc, #56]	; (60001ed0 <TwoWire::begin()+0xb8>)
60001e98:	eb02 1300 	add.w	r3, r2, r0, lsl #4
60001e9c:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
60001ea0:	461a      	mov	r2, r3
60001ea2:	eb01 1000 	add.w	r0, r1, r0, lsl #4
60001ea6:	6880      	ldr	r0, [r0, #8]
60001ea8:	6004      	str	r4, [r0, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60001eaa:	f893 4028 	ldrb.w	r4, [r3, #40]	; 0x28
60001eae:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
60001eb0:	eb01 1104 	add.w	r1, r1, r4, lsl #4
60001eb4:	684b      	ldr	r3, [r1, #4]
60001eb6:	6018      	str	r0, [r3, #0]
	if (hardware.scl_pins[i].select_input_register) {
60001eb8:	6b13      	ldr	r3, [r2, #48]	; 0x30
60001eba:	b10b      	cbz	r3, 60001ec0 <TwoWire::begin()+0xa8>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
60001ebc:	6b52      	ldr	r2, [r2, #52]	; 0x34
60001ebe:	601a      	str	r2, [r3, #0]
60001ec0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
60001ec4:	400fc000 	.word	0x400fc000
60001ec8:	05050bb8 	.word	0x05050bb8
60001ecc:	200006dc 	.word	0x200006dc
60001ed0:	0001f861 	.word	0x0001f861
60001ed4:	1928373b 	.word	0x1928373b

60001ed8 <TwoWire::setSDA(unsigned char)>:
//  Pins Configuration
//***************************************************


FLASHMEM void TwoWire::setSDA(uint8_t pin) {
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
60001ed8:	6943      	ldr	r3, [r0, #20]
60001eda:	7e02      	ldrb	r2, [r0, #24]
60001edc:	eb03 1202 	add.w	r2, r3, r2, lsl #4
//***************************************************
//  Pins Configuration
//***************************************************


FLASHMEM void TwoWire::setSDA(uint8_t pin) {
60001ee0:	b4f0      	push	{r4, r5, r6, r7}
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
60001ee2:	7a14      	ldrb	r4, [r2, #8]
60001ee4:	428c      	cmp	r4, r1
60001ee6:	d009      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
60001ee8:	7a1a      	ldrb	r2, [r3, #8]
		if (sda_pin == 255) return;
60001eea:	2aff      	cmp	r2, #255	; 0xff
60001eec:	d006      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
		if (sda_pin == pin) break;
60001eee:	428a      	cmp	r2, r1
60001ef0:	d028      	beq.n	60001f44 <TwoWire::setSDA(unsigned char)+0x6c>

FLASHMEM void TwoWire::setSDA(uint8_t pin) {
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
60001ef2:	7e1a      	ldrb	r2, [r3, #24]
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
60001ef4:	2aff      	cmp	r2, #255	; 0xff
60001ef6:	d001      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
60001ef8:	428a      	cmp	r2, r1
60001efa:	d001      	beq.n	60001f00 <TwoWire::setSDA(unsigned char)+0x28>
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
		// setup new one...
		configSDApin(newindex);
	}
	sda_pin_index_ = newindex;
}
60001efc:	bcf0      	pop	{r4, r5, r6, r7}
60001efe:	4770      	bx	lr
60001f00:	2501      	movs	r5, #1
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
60001f02:	462e      	mov	r6, r5
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
60001f04:	e893 0006 	ldmia.w	r3, {r1, r2}
60001f08:	6809      	ldr	r1, [r1, #0]
60001f0a:	4211      	tst	r1, r2
60001f0c:	d017      	beq.n	60001f3e <TwoWire::setSDA(unsigned char)+0x66>
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f0e:	4a0f      	ldr	r2, [pc, #60]	; (60001f4c <TwoWire::setSDA(unsigned char)+0x74>)
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f10:	eb03 1306 	add.w	r3, r3, r6, lsl #4
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f14:	2705      	movs	r7, #5
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f16:	4e0e      	ldr	r6, [pc, #56]	; (60001f50 <TwoWire::setSDA(unsigned char)+0x78>)
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f18:	eb02 1404 	add.w	r4, r2, r4, lsl #4
60001f1c:	6861      	ldr	r1, [r4, #4]
60001f1e:	600f      	str	r7, [r1, #0]
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f20:	7a19      	ldrb	r1, [r3, #8]
60001f22:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001f26:	6889      	ldr	r1, [r1, #8]
60001f28:	600e      	str	r6, [r1, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001f2a:	7a1c      	ldrb	r4, [r3, #8]
60001f2c:	68d9      	ldr	r1, [r3, #12]
60001f2e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001f32:	6852      	ldr	r2, [r2, #4]
60001f34:	6011      	str	r1, [r2, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001f36:	691a      	ldr	r2, [r3, #16]
60001f38:	b10a      	cbz	r2, 60001f3e <TwoWire::setSDA(unsigned char)+0x66>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001f3a:	695b      	ldr	r3, [r3, #20]
60001f3c:	6013      	str	r3, [r2, #0]
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
		// setup new one...
		configSDApin(newindex);
	}
	sda_pin_index_ = newindex;
60001f3e:	7605      	strb	r5, [r0, #24]
}
60001f40:	bcf0      	pop	{r4, r5, r6, r7}
60001f42:	4770      	bx	lr
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
60001f44:	2500      	movs	r5, #0
60001f46:	462e      	mov	r6, r5
60001f48:	e7dc      	b.n	60001f04 <TwoWire::setSDA(unsigned char)+0x2c>
60001f4a:	bf00      	nop
60001f4c:	200006dc 	.word	0x200006dc
60001f50:	0001f861 	.word	0x0001f861

60001f54 <TwoWire::configSDApin(unsigned char)>:
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f54:	6943      	ldr	r3, [r0, #20]
60001f56:	4a0b      	ldr	r2, [pc, #44]	; (60001f84 <TwoWire::configSDApin(unsigned char)+0x30>)
60001f58:	eb03 1001 	add.w	r0, r3, r1, lsl #4
	}
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
60001f5c:	b410      	push	{r4}
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f5e:	7a01      	ldrb	r1, [r0, #8]
60001f60:	4c09      	ldr	r4, [pc, #36]	; (60001f88 <TwoWire::configSDApin(unsigned char)+0x34>)
60001f62:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001f66:	6889      	ldr	r1, [r1, #8]
60001f68:	600c      	str	r4, [r1, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001f6a:	7a04      	ldrb	r4, [r0, #8]
60001f6c:	68c1      	ldr	r1, [r0, #12]
60001f6e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001f72:	6852      	ldr	r2, [r2, #4]
60001f74:	6011      	str	r1, [r2, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001f76:	6902      	ldr	r2, [r0, #16]
60001f78:	b10a      	cbz	r2, 60001f7e <TwoWire::configSDApin(unsigned char)+0x2a>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001f7a:	6943      	ldr	r3, [r0, #20]
60001f7c:	6013      	str	r3, [r2, #0]
	}
}
60001f7e:	f85d 4b04 	ldr.w	r4, [sp], #4
60001f82:	4770      	bx	lr
60001f84:	200006dc 	.word	0x200006dc
60001f88:	0001f861 	.word	0x0001f861

60001f8c <TwoWire::setSCL(unsigned char)>:

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
60001f8c:	6943      	ldr	r3, [r0, #20]
60001f8e:	7e42      	ldrb	r2, [r0, #25]
60001f90:	eb03 1202 	add.w	r2, r3, r2, lsl #4
	if (hardware.sda_pins[i].select_input_register) {
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
	}
}

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
60001f94:	b4f0      	push	{r4, r5, r6, r7}
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
60001f96:	f892 4028 	ldrb.w	r4, [r2, #40]	; 0x28
60001f9a:	428c      	cmp	r4, r1
60001f9c:	d00b      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
60001f9e:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
		if (scl_pin == 255) return;
60001fa2:	2aff      	cmp	r2, #255	; 0xff
60001fa4:	d007      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
		if (scl_pin == pin) break;
60001fa6:	428a      	cmp	r2, r1
60001fa8:	d02b      	beq.n	60002002 <TwoWire::setSCL(unsigned char)+0x76>

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
60001faa:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
60001fae:	2aff      	cmp	r2, #255	; 0xff
60001fb0:	d001      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
60001fb2:	428a      	cmp	r2, r1
60001fb4:	d001      	beq.n	60001fba <TwoWire::setSCL(unsigned char)+0x2e>
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
		// setup new one...
		configSCLpin(newindex);
	}
	scl_pin_index_ = newindex;
}
60001fb6:	bcf0      	pop	{r4, r5, r6, r7}
60001fb8:	4770      	bx	lr
60001fba:	2501      	movs	r5, #1
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
60001fbc:	462e      	mov	r6, r5
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
60001fbe:	e893 0006 	ldmia.w	r3, {r1, r2}
60001fc2:	6809      	ldr	r1, [r1, #0]
60001fc4:	4211      	tst	r1, r2
60001fc6:	d019      	beq.n	60001ffc <TwoWire::setSCL(unsigned char)+0x70>
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fc8:	4a0f      	ldr	r2, [pc, #60]	; (60002008 <TwoWire::setSCL(unsigned char)+0x7c>)
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fca:	eb03 1306 	add.w	r3, r3, r6, lsl #4
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fce:	2705      	movs	r7, #5
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fd0:	4e0e      	ldr	r6, [pc, #56]	; (6000200c <TwoWire::setSCL(unsigned char)+0x80>)
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fd2:	eb02 1404 	add.w	r4, r2, r4, lsl #4
60001fd6:	6861      	ldr	r1, [r4, #4]
60001fd8:	600f      	str	r7, [r1, #0]
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fda:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
60001fde:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001fe2:	6889      	ldr	r1, [r1, #8]
60001fe4:	600e      	str	r6, [r1, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60001fe6:	f893 4028 	ldrb.w	r4, [r3, #40]	; 0x28
60001fea:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
60001fec:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001ff0:	6852      	ldr	r2, [r2, #4]
60001ff2:	6011      	str	r1, [r2, #0]
	if (hardware.scl_pins[i].select_input_register) {
60001ff4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
60001ff6:	b10a      	cbz	r2, 60001ffc <TwoWire::setSCL(unsigned char)+0x70>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
60001ff8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
60001ffa:	6013      	str	r3, [r2, #0]
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
		// setup new one...
		configSCLpin(newindex);
	}
	scl_pin_index_ = newindex;
60001ffc:	7645      	strb	r5, [r0, #25]
}
60001ffe:	bcf0      	pop	{r4, r5, r6, r7}
60002000:	4770      	bx	lr
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
60002002:	2500      	movs	r5, #0
60002004:	462e      	mov	r6, r5
60002006:	e7da      	b.n	60001fbe <TwoWire::setSCL(unsigned char)+0x32>
60002008:	200006dc 	.word	0x200006dc
6000200c:	0001f861 	.word	0x0001f861

60002010 <TwoWire::configSCLpin(unsigned char)>:
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60002010:	6943      	ldr	r3, [r0, #20]
60002012:	4a0c      	ldr	r2, [pc, #48]	; (60002044 <TwoWire::configSCLpin(unsigned char)+0x34>)
60002014:	eb03 1001 	add.w	r0, r3, r1, lsl #4
	}
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
60002018:	b410      	push	{r4}
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
6000201a:	f890 1028 	ldrb.w	r1, [r0, #40]	; 0x28
6000201e:	4c0a      	ldr	r4, [pc, #40]	; (60002048 <TwoWire::configSCLpin(unsigned char)+0x38>)
60002020:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60002024:	6889      	ldr	r1, [r1, #8]
60002026:	600c      	str	r4, [r1, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60002028:	f890 4028 	ldrb.w	r4, [r0, #40]	; 0x28
6000202c:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
6000202e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60002032:	6852      	ldr	r2, [r2, #4]
60002034:	6011      	str	r1, [r2, #0]
	if (hardware.scl_pins[i].select_input_register) {
60002036:	6b02      	ldr	r2, [r0, #48]	; 0x30
60002038:	b10a      	cbz	r2, 6000203e <TwoWire::configSCLpin(unsigned char)+0x2e>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
6000203a:	6b43      	ldr	r3, [r0, #52]	; 0x34
6000203c:	6013      	str	r3, [r2, #0]
	}
}
6000203e:	f85d 4b04 	ldr.w	r4, [sp], #4
60002042:	4770      	bx	lr
60002044:	200006dc 	.word	0x200006dc
60002048:	0001f861 	.word	0x0001f861

6000204c <_init>:
6000204c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000204e:	bf00      	nop
60002050:	bcf8      	pop	{r3, r4, r5, r6, r7}
60002052:	bc08      	pop	{r3}
60002054:	469e      	mov	lr, r3
60002056:	4770      	bx	lr

60002058 <__main_veneer>:
60002058:	f85f f000 	ldr.w	pc, [pc]	; 6000205c <__main_veneer+0x4>
6000205c:	00000479 	.word	0x00000479

60002060 <__sm_set_pool_veneer>:
60002060:	f85f f000 	ldr.w	pc, [pc]	; 60002064 <__sm_set_pool_veneer+0x4>
60002064:	00001649 	.word	0x00001649

60002068 <__set_arm_clock_veneer>:
60002068:	f85f f000 	ldr.w	pc, [pc]	; 6000206c <__set_arm_clock_veneer+0x4>
6000206c:	00000eb1 	.word	0x00000eb1

60002070 <__delay_veneer>:
60002070:	f85f f000 	ldr.w	pc, [pc]	; 60002074 <__delay_veneer+0x4>
60002074:	00001175 	.word	0x00001175

60002078 <____libc_init_array_veneer>:
60002078:	f85f f000 	ldr.w	pc, [pc]	; 6000207c <____libc_init_array_veneer+0x4>
6000207c:	00005f55 	.word	0x00005f55

60002080 <__usb_init_serialnumber_veneer>:
60002080:	f85f f000 	ldr.w	pc, [pc]	; 60002084 <__usb_init_serialnumber_veneer+0x4>
60002084:	000021cd 	.word	0x000021cd

60002088 <__memset_veneer>:
60002088:	f85f f000 	ldr.w	pc, [pc]	; 6000208c <__memset_veneer+0x4>
6000208c:	0000675d 	.word	0x0000675d

60002090 <__pwm_init_veneer>:
60002090:	f85f f000 	ldr.w	pc, [pc]	; 60002094 <__pwm_init_veneer+0x4>
60002094:	00001311 	.word	0x00001311

60002098 <__init_array_start>:
60002098:	00000045 	.word	0x00000045
6000209c:	00002919 	.word	0x00002919

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      20:	4c05b510 	.word	0x4c05b510
      24:	7823      	ldrb	r3, [r4, #0]
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      26:	b933      	.short	0xb933
      28:	4b04      	ldr	r3, [pc, #16]	; (3c <_teensy_model_identifier+0x17>)
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      2a:	b113      	.short	0xb113
      2c:	4804      	ldr	r0, [pc, #16]	; (40 <_teensy_model_identifier+0x1b>)
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      2e:	f3af 8000 	nop.w
      32:	2301      	.short	0x2301
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      34:	7023      	strb	r3, [r4, #0]
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
      36:	bd10      	.short	0xbd10
      38:	2668      	movs	r6, #104	; 0x68
      3a:	2000      	.short	0x2000
      3c:	0000      	movs	r0, r0
      3e:	0000      	.short	0x0000
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
      40:	a184      	add	r1, pc, #528	; (adr r1, 254 <ComplimentaryFilter::context(Vector<float>*)+0x10>)
	...

00000044 <frame_dummy>:

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      44:	b5104b08 	.word	0xb5104b08
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      48:	b11b      	cbz	r3, 52 <frame_dummy+0xe>
      4a:	4908      	.short	0x4908
      4c:	4808      	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	f3af      	.short	0xf3af
      50:	8000      	strh	r0, [r0, #0]
      52:	4808      	.short	0x4808
      54:	6803      	ldr	r3, [r0, #0]
      56:	b903      	.short	0xb903
      58:	bd10      	pop	{r4, pc}
      5a:	4b07      	.short	0x4b07
      5c:	2b00      	cmp	r3, #0
      5e:	d0fb      	.short	0xd0fb
      60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      64:	4718      	bx	r3
      66:	bf00      	nop
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      68:	0000      	movs	r0, r0
      6a:	0000      	movs	r0, r0
			yield(); // TODO: what happens if yield-called code uses analogRead()
      6c:	266c      	movs	r6, #108	; 0x6c
      6e:	2000      	movs	r0, #0
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      70:	a184      	add	r1, pc, #528	; (adr r1, 284 <ComplimentaryFilter::setup(Vector<float>*)+0x8>)
      72:	0000      	.short	0x0000
      74:	22c0      	movs	r2, #192	; 0xc0
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC2_R0;
      76:	2000      	movs	r0, #0
      78:	0000      	movs	r0, r0
	...

0000007c <ComplimentaryFilter::clear()>:
			K = DEFAULT_GAIN;
			clear();
		}

		void clear() {
			axz_norm = 0;
      7c:	2300      	movs	r3, #0
      7e:	6343      	str	r3, [r0, #52]	; 0x34
			ayz_norm = 0;
      80:	6383      	str	r3, [r0, #56]	; 0x38
			mag_norm = 0;
      82:	63c3      	str	r3, [r0, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
      84:	6443      	str	r3, [r0, #68]	; 0x44
				q_accel[i] = 0;
      86:	6503      	str	r3, [r0, #80]	; 0x50
				bias_accel[i] = 0;
      88:	648365c3 	.word	0x648365c3
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
				q_accel[i] = 0;
      8c:	6543      	str	r3, [r0, #84]	; 0x54
				bias_accel[i] = 0;
      8e:	6603      	.short	0x6603
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
      90:	64c3      	str	r3, [r0, #76]	; 0x4c
				q_accel[i] = 0;
      92:	6583      	.short	0x6583
				bias_accel[i] = 0;
      94:	6643      	str	r3, [r0, #100]	; 0x64
      96:	4770      	.short	0x4770

00000098 <ComplimentaryFilter::run(Vector<float>*, Vector<float>*)>:
	configSDApin(sda_pin_index_); // Setup SDA register
	configSCLpin(scl_pin_index_); // setup SCL register
	port->SCR = LPI2C_SCR_RST;
	port->SCR = 0;
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
      98:	b5f0      	push	{r4, r5, r6, r7, lr}
	port->SAMR = LPI2C_SAMR_ADDR0(address);
      9a:	f100      	.short	0xf100
      9c:	060c      	lsls	r4, r1, #24


#ifdef __cplusplus
extern "C" void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
      9e:	4604      	.short	0x4604
      a0:	460d      	mov	r5, r1
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
      a2:	2100      	movs	r1, #0
      a4:	46174630 	.word	0x46174630
	NVIC_ENABLE_IRQ(hardware.irq_number);
      a8:	ed2d 8b0e 	vpush	{d8-d14}
	port->SCR = 0;
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
      ac:	b091      	sub	sp, #68	; 0x44
	NVIC_ENABLE_IRQ(hardware.irq_number);
	port->SIER = LPI2C_SIER_TDIE |  LPI2C_SIER_RDIE | LPI2C_SIER_SDIE;
      ae:	f000 fd97 	bl	be0 <FTYK::micros(int)>
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
	NVIC_ENABLE_IRQ(hardware.irq_number);
      b2:	4630      	mov	r0, r6
	port->SCR = 0;
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
      b4:	2100      	movs	r1, #0
	NVIC_ENABLE_IRQ(hardware.irq_number);
      b6:	eeb0 ea40 	vmov.f32	s28, s0
      ba:	f000      	.short	0xf000
      bc:	fd89 4628 	stc2	6, cr4, [r9, #160]	; 0xa0
      c0:	a904      	add	r1, sp, #16
      c2:	2303      	.short	0x2303
      c4:	2200      	movs	r2, #0
      c6:	f000      	.short	0xf000
      c8:	fecf 4628 	cdp2	6, 12, cr4, cr15, cr8, {1}
	port->SIER = LPI2C_SIER_TDIE |  LPI2C_SIER_RDIE | LPI2C_SIER_SDIE;
      cc:	2306      	movs	r3, #6
      ce:	2203      	movs	r2, #3
	transmitting = 0;
      d0:	a907      	add	r1, sp, #28
      d2:	f000 fec9 	bl	e68 <Vector<float>::slice(float*, int, int)>
	slave_mode = 1;
      d6:	4628      	mov	r0, r5
	port->SCR = LPI2C_SCR_SEN;
      d8:	a90a      	add	r1, sp, #40	; 0x28
      da:	2309      	.short	0x2309
      dc:	2206      	movs	r2, #6
      de:	f000      	.short	0xf000
      e0:	fec3 4628 	cdp2	6, 12, cr4, cr3, cr8, {1}
      e4:	230ca90d 	.word	0x230ca90d
      e8:	2209      	movs	r2, #9
      ea:	f000      	.short	0xf000
      ec:	febd 9b09 	cdp2	11, 11, cr9, cr13, cr9, {0}
      f0:	21029a08 	.word	0x21029a08
      f4:	9d07      	ldr	r5, [sp, #28]
      f6:	4668      	.short	0x4668
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
      f8:	9301      	str	r3, [sp, #4]
			float ayz[2] = {accel[1], accel[2]};
      fa:	9303      	.short	0x9303
      fc:	9202      	str	r2, [sp, #8]
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
      fe:	9500      	str	r5, [sp, #0]
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     100:	f000 fa96 	bl	630 <nd_norm(float*, int)>
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     104:	2102      	movs	r1, #2
     106:	a802      	add	r0, sp, #8
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     108:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     10c:	f000 fa90 	bl	630 <nd_norm(float*, int)>
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     110:	2103a80d 	.word	0x2103a80d

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     114:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     118:	f000 fa8a 	bl	630 <nd_norm(float*, int)>

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     11c:	7a08eddd 	.word	0x7a08eddd
     120:	ed94 1a0d 	vldr	s2, [r4, #52]	; 0x34
		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     124:	ed84 0a0f 	vstr	s0, [r4, #60]	; 0x3c

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     128:	0ae7eeb7 	.word	0x0ae7eeb7
     12c:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
     130:	fbaaf004 	.word	0xfbaaf004
			q_accel[1] = atan2(-accel[0], ayz_norm);
     134:	eddd 7a07 	vldr	s15, [sp, #28]
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     138:	0bc0eeb7 	.word	0x0bc0eeb7
			q_accel[1] = atan2(-accel[0], ayz_norm);
     13c:	ed94 1a0e 	vldr	s2, [r4, #56]	; 0x38
     140:	7a67eef1 	.word	0x7a67eef1
     144:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     148:	0a14ed84 	.word	0x0a14ed84
			q_accel[1] = atan2(-accel[0], ayz_norm);
     14c:	eeb7 0ae7 	vcvt.f64.f32	d0, s15
     150:	fb9af004 	.word	0xfb9af004

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     154:	ed94 8a14 	vldr	s16, [r4, #80]	; 0x50
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
			q_accel[1] = atan2(-accel[0], ayz_norm);
     158:	0bc0eeb7 	.word	0x0bc0eeb7

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     15c:	ed9d ba0f 	vldr	s22, [sp, #60]	; 0x3c
     160:	8ac8eeb7 	.word	0x8ac8eeb7
     164:	eeb7 bacb 	vcvt.f64.f32	d11, s22
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;
     168:	9ac0eeb7 	.word	0x9ac0eeb7
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
			q_accel[1] = atan2(-accel[0], ayz_norm);
     16c:	ed84 0a15 	vstr	s0, [r4, #84]	; 0x54

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     170:	0b48eeb0 	.word	0x0b48eeb0
     174:	f004 fb38 	bl	47e8 <sin>
     178:	db40eeb0 	.word	0xdb40eeb0
     17c:	eeb0 0b48 	vmov.f64	d0, d8
     180:	f004 fae2 	bl	4748 <cos>
     184:	8a0eed9d 	.word	0x8a0eed9d
     188:	ed94 aa0f 	vldr	s20, [r4, #60]	; 0x3c
     18c:	8ac8eeb7 	.word	0x8ac8eeb7
     190:	eeb7 aaca 	vcvt.f64.f32	d10, s20
     194:	8b00ee28 	.word	0x8b00ee28
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;
     198:	eeb0 0b49 	vmov.f64	d0, d9
     19c:	fad4f004 	.word	0xfad4f004
     1a0:	eeb0 cb40 	vmov.f64	d12, d0
     1a4:	0b49eeb0 	.word	0x0b49eeb0
     1a8:	f004 fb1e 	bl	47e8 <sin>

			q_accel[2] = atan2(opposite, adjacent);
     1ac:	ee28 0b00 	vmul.f64	d0, d8, d0
     1b0:	6a0ded9d 	.word	0x6a0ded9d
     1b4:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     1b8:	8b0dee9b 	.word	0x8b0dee9b
     1bc:	eeab 0b0d 	vfma.f64	d0, d11, d13
     1c0:	7b0aee88 	.word	0x7b0aee88
     1c4:	eea6 0b0c 	vfma.f64	d0, d6, d12
     1c8:	1b0aee80 	.word	0x1b0aee80
     1cc:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
     1d0:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
     1d4:	eeb7 1bc1 	vcvt.f32.f64	s2, d1
     1d8:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
     1dc:	f004 fb54 	bl	4888 <atan2>
     1e0:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
			if (isnan(q_accel[2])) {
     1e4:	eeb4 0a40 	vcmp.f32	s0, s0
			q_accel[1] = atan2(-accel[0], ayz_norm);

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;

			q_accel[2] = atan2(opposite, adjacent);
     1e8:	ed84 0a16 	vstr	s0, [r4, #88]	; 0x58
			if (isnan(q_accel[2])) {
     1ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     1f0:	f104d625 	.word	0xf104d625
				q_accel[2] = 0;
			}

			// integrate gyro measurements over time
			weighted_vector_addition(estimate, gyro, 1, dt, 3, q_gyro);
     1f4:	0544      	lsls	r4, r0, #21
     1f6:	eef0      	.short	0xeef0
     1f8:	0a4e      	lsrs	r6, r1, #9
     1fa:	a90a      	.short	0xa90a
     1fc:	a804      	add	r0, sp, #16
     1fe:	462b      	.short	0x462b
     200:	2203      	movs	r2, #3
     202:	eeb7      	.short	0xeeb7
     204:	0a00      	lsrs	r0, r0, #8
     206:	f000 fa3d 	bl	684 <weighted_vector_addition(float*, float*, float, float, int, float*)>

			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
     20a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
     20e:	ed94 0a10 	vldr	s0, [r4, #64]	; 0x40
     212:	ab04      	.short	0xab04
     214:	4629      	mov	r1, r5
     216:	2203      	movs	r2, #3
     218:	ee70 0ac0 	vsub.f32	s1, s1, s0
     21c:	f104 0050 	add.w	r0, r4, #80	; 0x50
     220:	f000 fa30 	bl	684 <weighted_vector_addition(float*, float*, float, float, int, float*)>
			inputs->slice(gyro, 6, 9);
			inputs->slice(mag, 9, 12);
			
			filter(accel, gyro, mag, dt, estimate);

			outputs->from_array(estimate, dimensions[OUTPUT_DIMENSION]);
     224:	1d20      	adds	r0, r4, #4
     226:	2102      	movs	r1, #2
     228:	fd52f000 	.word	0xfd52f000
     22c:	a904      	add	r1, sp, #16
     22e:	6802      	.short	0x6802
     230:	4638      	mov	r0, r7
     232:	f000      	.short	0xf000
     234:	fd95 b011 	ldc2	0, cr11, [r5, #68]	; 0x44
		}
     238:	8b0eecbd 	.word	0x8b0eecbd
     23c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;

			q_accel[2] = atan2(opposite, adjacent);
			if (isnan(q_accel[2])) {
				q_accel[2] = 0;
     23e:	2300      	.short	0x2300
     240:	65a3      	str	r3, [r4, #88]	; 0x58
     242:	e7d6      	.short	0xe7d6

00000244 <ComplimentaryFilter::context(Vector<float>*)>:
				q_accel[i] = 0;
				q_gyro[i] = 0;
			}
		}

		void context(Vector<float>* context) {
     244:	b570      	push	{r4, r5, r6, lr}
     246:	460c      	.short	0x460c
     248:	4605      	mov	r5, r0
			context->reset(dimensions[CONTEXT_DIMENSION]);
     24a:	2101      	.short	0x2101
     24c:	3004      	adds	r0, #4
     24e:	f000 fd3f 	bl	cd0 <Vector<int>::operator[](int)>
     252:	6801      	ldr	r1, [r0, #0]
     254:	4620      	mov	r0, r4
     256:	f000      	.short	0xf000
     258:	fd6d f105 	stc2l	1, cr15, [sp, #-20]!	; 0xffffffec
			context->insert(q_gyro, 0, ATTITUDE_DIM);
     25c:	0144      	lsls	r4, r0, #5
     25e:	4620      	mov	r0, r4
     260:	2303      	movs	r3, #3
     262:	2200      	.short	0x2200
     264:	f000 fdda 	bl	e1c <Vector<float>::insert(float*, int, int)>
			context->insert(q_accel, 3, ATTITUDE_DIM);
     268:	f1052303 	.word	0xf1052303
     26c:	0150      	lsls	r0, r2, #5
     26e:	4620      	mov	r0, r4
     270:	461a      	mov	r2, r3
		}
     272:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		}

		void context(Vector<float>* context) {
			context->reset(dimensions[CONTEXT_DIMENSION]);
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
     276:	f000 bdd1 	b.w	e1c <Vector<float>::insert(float*, int, int)>
	uint32_t ctrl = CTRL_TX_INACTIVE;

	// Now process the bits in the Format value passed in
	// Bits 0-2 - Parity plus 9  bit. 
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
     27a:	bf00      	nop

0000027c <ComplimentaryFilter::setup(Vector<float>*)>:
			watches.set(0);
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
     27c:	460b      	mov	r3, r1
			K = (*config)[0];
     27e:	2100      	movs	r1, #0
			watches.set(0);
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
     280:	b510      	push	{r4, lr}
     282:	4604      	mov	r4, r0
			K = (*config)[0];
     284:	f0004618 	.word	0xf0004618
     288:	fe05 6803 	cdp2	8, 0, cr6, cr5, cr3, {0}
			watches.set(0);
     28c:	f1042100 	.word	0xf1042100
     290:	000c      	movs	r4, r1
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
			K = (*config)[0];
     292:	6423      	.short	0x6423
			watches.set(0);
     294:	f000 fc9c 	bl	bd0 <FTYK::set(int)>
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     298:	2300      	movs	r3, #0
     29a:	6523      	.short	0x6523
				q_gyro[i] = 0;
     29c:	6463      	str	r3, [r4, #68]	; 0x44

		void setup(Vector<float>* config) {
			K = (*config)[0];
			watches.set(0);
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     29e:	6563      	str	r3, [r4, #84]	; 0x54
				q_gyro[i] = 0;
     2a0:	64a3      	str	r3, [r4, #72]	; 0x48

		void setup(Vector<float>* config) {
			K = (*config)[0];
			watches.set(0);
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     2a2:	65a3      	str	r3, [r4, #88]	; 0x58
				q_gyro[i] = 0;
     2a4:	64e3      	str	r3, [r4, #76]	; 0x4c
     2a6:	bd10      	pop	{r4, pc}

000002a8 <ComplimentaryFilter::reset()>:
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
     2a8:	490d6802 	.word	0x490d6802
     2ac:	6912      	ldr	r2, [r2, #16]

			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
     2ae:	b410      	.short	0xb410
     2b0:	428a      	cmp	r2, r1
			K = DEFAULT_GAIN;
     2b2:	4c0c      	.short	0x4c0c
     2b4:	6404      	str	r4, [r0, #64]	; 0x40
     2b6:	d10f      	bne.n	2d8 <ComplimentaryFilter::reset()+0x30>
			clear();
		}

		void clear() {
			axz_norm = 0;
     2b8:	2200      	movs	r2, #0
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
		}
     2ba:	f85d      	.short	0xf85d
     2bc:	4b04      	ldr	r3, [pc, #16]	; (2d0 <ComplimentaryFilter::reset()+0x28>)

		void clear() {
			axz_norm = 0;
     2be:	6342      	str	r2, [r0, #52]	; 0x34
			ayz_norm = 0;
     2c0:	6382      	str	r2, [r0, #56]	; 0x38
			mag_norm = 0;
     2c2:	63c2      	str	r2, [r0, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     2c4:	6442      	str	r2, [r0, #68]	; 0x44
				q_accel[i] = 0;
     2c6:	6502      	str	r2, [r0, #80]	; 0x50
				bias_accel[i] = 0;
     2c8:	65c2      	str	r2, [r0, #92]	; 0x5c
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     2ca:	6482      	str	r2, [r0, #72]	; 0x48
				q_accel[i] = 0;
     2cc:	6542      	str	r2, [r0, #84]	; 0x54
				bias_accel[i] = 0;
     2ce:	6602      	str	r2, [r0, #96]	; 0x60
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     2d0:	64c2      	str	r2, [r0, #76]	; 0x4c
				q_accel[i] = 0;
     2d2:	6582      	str	r2, [r0, #88]	; 0x58
				bias_accel[i] = 0;
     2d4:	6642      	str	r2, [r0, #100]	; 0x64
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
		}
     2d6:	4770      	bx	lr
     2d8:	4b04f85d 	.word	0x4b04f85d
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
     2dc:	4710      	bx	r2
     2de:	bf00      	nop
     2e0:	007d      	lsls	r5, r7, #1
     2e2:	0000      	movs	r0, r0
     2e4:	cccd      	ldmia	r4!, {r0, r2, r3, r6, r7}
     2e6:	3ecc      	subs	r6, #204	; 0xcc

000002e8 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]>:
*/
class Process_Factory {
	// private:
		
	public:
		Process* new_proc(String index) {
     2e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
     2ec:	492d      	ldr	r1, [pc, #180]	; (3a4 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xbc>)
     2ee:	4604      	mov	r4, r0
     2f0:	f002 fb72 	bl	29d8 <String::equals(char const*) const>
			if (index == LSM6DSOX_ID) {
     2f4:	2800      	cmp	r0, #0
     2f6:	d14b      	bne.n	390 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xa8>
     2f8:	4607      	mov	r7, r0
     2fa:	492b      	ldr	r1, [pc, #172]	; (3a8 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xc0>)
     2fc:	4620      	mov	r0, r4
     2fe:	f002 fb6b 	bl	29d8 <String::equals(char const*) const>
				return new LSM6DSOX();
			}
			else if (index == COMPLIMENTARYFILTER_ID) {
     302:	2800      	cmp	r0, #0
     304:	2068d042 	.word	0x2068d042
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     308:	2500      	movs	r5, #0
				return new ComplimentaryFilter();
     30a:	f002 fb7b 	bl	2a04 <operator new(unsigned int)>
	Base class for all user defined processes.
	Must override the functions below, constructor
	optional... I think.
*/

class Process {	
     30e:	4b27      	ldr	r3, [pc, #156]	; (3ac <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xc4>)
     310:	4606      	mov	r6, r0
     312:	4604      	.short	0x4604
     314:	4680      	mov	r8, r0
     316:	f8df 909c 	ldr.w	r9, [pc, #156]	; 3b4 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xcc>
     31a:	f846      	.short	0xf846
     31c:	3b04      	subs	r3, #4
     31e:	4630      	.short	0x4630
     320:	f000 fca8 	bl	c74 <Vector<int>::Vector()>
     324:	4b22      	ldr	r3, [pc, #136]	; (3b0 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xc8>)
     326:	f848      	.short	0xf848
     328:	3b0c      	subs	r3, #12
     32a:	4640      	.short	0x4640
     32c:	f000 fc40 	bl	bb0 <FTYK::FTYK()>
			dimensions.reset(PROCESS_DIMENSIONS);
     330:	4630      	mov	r0, r6
     332:	2103      	.short	0x2103
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     334:	6365      	str	r5, [r4, #52]	; 0x34
     336:	63a5      	.short	0x63a5
     338:	63e5      	str	r5, [r4, #60]	; 0x3c
     33a:	f8c4      	.short	0xf8c4
     33c:	9040      	str	r0, [sp, #256]	; 0x100
			dimensions.reset(PROCESS_DIMENSIONS);
     33e:	f000      	.short	0xf000
     340:	fca3 4639 	stc2	6, cr4, [r3], #228	; 0xe4
			dimensions[INPUT_DIMENSION] = CMF_INPUT_DIMS;
     344:	f0004630 	.word	0xf0004630
     348:	fcc3 230c 	stc2l	3, cr2, [r3], {12}
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
     34c:	60032101 	.word	0x60032101
     350:	4630      	mov	r0, r6
     352:	f000      	.short	0xf000
     354:	fcbd 2306 	ldc2	3, cr2, [sp], #24
			dimensions[OUTPUT_DIMENSION] = ATTITUDE_DIM;
     358:	60032102 	.word	0x60032102
     35c:	4630      	mov	r0, r6
     35e:	f000      	.short	0xf000
     360:	fcb7 2303 	ldc2	3, cr2, [r7], #12
			watches.set(0);
     364:	60034639 	.word	0x60034639
     368:	4640      	mov	r0, r8
     36a:	f000      	.short	0xf000
     36c:	fc31 4620 	ldc2	6, cr4, [r1], #-128	; 0xffffff80
			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
     370:	9040f8c4 	.word	0x9040f8c4
			clear();
		}

		void clear() {
			axz_norm = 0;
     374:	6365      	str	r5, [r4, #52]	; 0x34
			ayz_norm = 0;
     376:	63a5      	.short	0x63a5
			mag_norm = 0;
     378:	63e5      	str	r5, [r4, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     37a:	6465      	.short	0x6465
				q_accel[i] = 0;
     37c:	6525      	str	r5, [r4, #80]	; 0x50
				bias_accel[i] = 0;
     37e:	65e5      	.short	0x65e5
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     380:	64a5      	str	r5, [r4, #72]	; 0x48
				q_accel[i] = 0;
     382:	6565      	.short	0x6565
				bias_accel[i] = 0;
     384:	6625      	str	r5, [r4, #96]	; 0x60
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     386:	64e5      	str	r5, [r4, #76]	; 0x4c
				q_accel[i] = 0;
     388:	666565a5 	.word	0x666565a5
			}
			else {
				return nullptr;
			}
		}
     38c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	// private:
		
	public:
		Process* new_proc(String index) {
			if (index == LSM6DSOX_ID) {
				return new LSM6DSOX();
     390:	f00220b0 	.word	0xf00220b0
     394:	fb37 4604 	smlawb	r6, r7, r4, r4
     398:	f000 fa78 	bl	88c <LSM6DSOX::LSM6DSOX()>
     39c:	e8bd4620 	.word	0xe8bd4620
     3a0:	83f8      	strh	r0, [r7, #30]
     3a2:	bf00      	.short	0xbf00
     3a4:	0ae8      	lsrs	r0, r5, #11
     3a6:	2000      	.short	0x2000
     3a8:	0aec      	lsrs	r4, r5, #11
     3aa:	2000      	.short	0x2000
     3ac:	0540      	lsls	r0, r0, #21
     3ae:	2000      	.short	0x2000
     3b0:	04c0      	lsls	r0, r0, #19
     3b2:	2000      	movs	r0, #0
     3b4:	3ecccccd 	.word	0x3ecccccd

000003b8 <ComplimentaryFilter::print()>:
			filter(accel, gyro, mag, dt, estimate);

			outputs->from_array(estimate, dimensions[OUTPUT_DIMENSION]);
		}

		void print() {
     3b8:	b530      	push	{r4, r5, lr}
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     3ba:	4d21      	.short	0x4d21
     3bc:	b085      	sub	sp, #20
     3be:	4604      	mov	r4, r0
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
     3c0:	2113      	movs	r1, #19
     3c2:	4820      	.short	0x4820
     3c4:	f002 f9ea 	bl	279c <usb_seremu_write>
     3c8:	f0024628 	.word	0xf0024628
     3cc:	fa77 edd4 			; <UNDEFINED> instruction: 0xfa77edd4
			Serial.println("ComplimentaryFilter");
			Serial.printf("\tgain: [%f]\n", K);
     3d0:	46287a10 	.word	0x46287a10
     3d4:	491c      	ldr	r1, [pc, #112]	; (448 <ComplimentaryFilter::print()+0x90>)
     3d6:	eeb7      	.short	0xeeb7
     3d8:	7ae7      	ldrb	r7, [r4, #11]
     3da:	ec53      	.short	0xec53
     3dc:	2b17      	cmp	r3, #23
     3de:	f002      	.short	0xf002
     3e0:	fa85 ed94 			; <UNDEFINED> instruction: 0xfa85ed94
			Serial.printf("\tq_accel: [%f, %f, %f]\n", q_accel[0], q_accel[1], q_accel[2]);
     3e4:	6a16      	ldr	r6, [r2, #32]
     3e6:	ed94 7a15 	vldr	s14, [r4, #84]	; 0x54
     3ea:	4628      	mov	r0, r5
     3ec:	5a14edd4 	.word	0x5a14edd4
     3f0:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     3f4:	7ac7eeb7 	.word	0x7ac7eeb7
     3f8:	4914      	ldr	r1, [pc, #80]	; (44c <ComplimentaryFilter::print()+0x94>)
     3fa:	eeb7      	.short	0xeeb7
     3fc:	5ae5      	ldrh	r5, [r4, r3]
     3fe:	ed8d      	.short	0xed8d
     400:	6b02      	ldr	r2, [r0, #48]	; 0x30
     402:	ec53 2b15 	vmov	r2, r3, d5
     406:	ed8d 7b00 	vstr	d7, [sp]
     40a:	f002 fa6f 	bl	28ec <Print::printf(char const*, ...)>
			Serial.printf("\tq_gyro: [%f, %f, %f]\n", q_gyro[0], q_gyro[1], q_gyro[2]);
     40e:	ed94 6a13 	vldr	s12, [r4, #76]	; 0x4c
     412:	ed94 7a12 	vldr	s14, [r4, #72]	; 0x48
     416:	4628      	mov	r0, r5
     418:	edd4 5a11 	vldr	s11, [r4, #68]	; 0x44
     41c:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     420:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     424:	490a      	ldr	r1, [pc, #40]	; (450 <ComplimentaryFilter::print()+0x98>)
     426:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     42a:	ed8d 6b02 	vstr	d6, [sp, #8]
     42e:	ec53 2b15 	vmov	r2, r3, d5
     432:	ed8d 7b00 	vstr	d7, [sp]
     436:	f002 fa59 	bl	28ec <Print::printf(char const*, ...)>
		}
     43a:	b005      	add	sp, #20
     43c:	bd30      	pop	{r4, r5, pc}
     43e:	bf00      	nop
     440:	20001434 	.word	0x20001434
     444:	0af0      	lsrs	r0, r6, #11
     446:	2000      	.short	0x2000
     448:	0b04      	lsrs	r4, r0, #12
     44a:	2000      	.short	0x2000
     44c:	0b14      	lsrs	r4, r2, #12
     44e:	2000      	.short	0x2000
     450:	0b2c      	lsrs	r4, r5, #12
     452:	2000      	.short	0x2000

00000454 <Print::println(char const*)>:
     454:	b538      	push	{r3, r4, r5, lr}
     456:	4604      	.short	0x4604
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     458:	4608      	mov	r0, r1
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     45a:	460d      	.short	0x460d
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     45c:	f006 fdb0 	bl	6fc0 <strlen>
     460:	46026823 	.word	0x46026823
     464:	4629      	mov	r1, r5
     466:	4620      	.short	0x4620
     468:	685b      	ldr	r3, [r3, #4]
     46a:	4798      	.short	0x4798
     46c:	4605      	mov	r5, r0
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     46e:	4620      	mov	r0, r4
     470:	f002 fa24 	bl	28bc <Print::println()>
     474:	4428      	add	r0, r5
     476:	bd38      	.short	0xbd38

00000478 <main>:
#include "system_graph/graph_node.h"
#include "system_graph/process_factory.h"

#include "sensors/lsm6dsox.h"

int main() {
     478:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     47c:	4c59      	ldr	r4, [pc, #356]	; (5e4 <main+0x16c>)
     47e:	b08b      	sub	sp, #44	; 0x2c
     480:	4d59      	ldr	r5, [pc, #356]	; (5e8 <main+0x170>)
        uint8_t stopbits(void) { return 1; }
        uint8_t paritytype(void) { return 0; }
        uint8_t numbits(void) { return 8; }
        uint8_t dtr(void) { return 1; }
        uint8_t rts(void) { return 1; }
        operator bool() { yield(); return usb_configuration && usb_seremu_online; }
     482:	f002 fad9 	bl	2a38 <yield>
     486:	7823      	ldrb	r3, [r4, #0]
     488:	2b00      	cmp	r3, #0
     48a:	d0fa      	.short	0xd0fa
     48c:	782b      	ldrb	r3, [r5, #0]
     48e:	2b00      	.short	0x2b00
     490:	d0f7      	beq.n	482 <main+0xa>
	while(!Serial){}

	Serial.println("=== Starting Graph Node tests ===");
     492:	4956      	ldr	r1, [pc, #344]	; (5ec <main+0x174>)

	float tmp[1] = {0.6};
	int cmf_inputs[2] = {1, 0};
     494:	f04f 0801 	mov.w	r8, #1
#include "sensors/lsm6dsox.h"

int main() {
	while(!Serial){}

	Serial.println("=== Starting Graph Node tests ===");
     498:	4855      	ldr	r0, [pc, #340]	; (5f0 <main+0x178>)

	float tmp[1] = {0.6};
	int cmf_inputs[2] = {1, 0};
     49a:	2600      	movs	r6, #0
#include "sensors/lsm6dsox.h"

int main() {
	while(!Serial){}

	Serial.println("=== Starting Graph Node tests ===");
     49c:	f7ff ffda 	bl	454 <Print::println(char const*)>

	float tmp[1] = {0.6};
     4a0:	4b54      	ldr	r3, [pc, #336]	; (5f4 <main+0x17c>)
	int cmf_inputs[2] = {1, 0};


	Serial.println("=== Init Process Factory ===");
     4a2:	4955      	.short	0x4955

	Serial.println("=== Init Graph Node ===");
	GraphNode* nodelist[2];

	Serial.println("=== Add LSM6DSOX ===");
	nodelist[0] = new GraphNode(p_fact.new_proc("LSM"), 0, 1, cmf_inputs);
     4a4:	af04      	add	r7, sp, #16

	float tmp[1] = {0.6};
	int cmf_inputs[2] = {1, 0};


	Serial.println("=== Init Process Factory ===");
     4a6:	4852      	.short	0x4852
int main() {
	while(!Serial){}

	Serial.println("=== Starting Graph Node tests ===");

	float tmp[1] = {0.6};
     4a8:	9303      	str	r3, [sp, #12]
	int cmf_inputs[2] = {1, 0};
     4aa:	f8cd 8010 	str.w	r8, [sp, #16]
     4ae:	9605      	str	r6, [sp, #20]


	Serial.println("=== Init Process Factory ===");
     4b0:	f7ff ffd0 	bl	454 <Print::println(char const*)>
	Process_Factory p_fact;

	Serial.println("=== Init Graph Node ===");
     4b4:	4951      	ldr	r1, [pc, #324]	; (5fc <main+0x184>)
     4b6:	484e      	ldr	r0, [pc, #312]	; (5f0 <main+0x178>)
     4b8:	f7ff ffcc 	bl	454 <Print::println(char const*)>
	GraphNode* nodelist[2];

	Serial.println("=== Add LSM6DSOX ===");
     4bc:	4950      	ldr	r1, [pc, #320]	; (600 <main+0x188>)
     4be:	484c      	ldr	r0, [pc, #304]	; (5f0 <main+0x178>)
     4c0:	f7ff ffc8 	bl	454 <Print::println(char const*)>
	nodelist[0] = new GraphNode(p_fact.new_proc("LSM"), 0, 1, cmf_inputs);
     4c4:	494f      	ldr	r1, [pc, #316]	; (604 <main+0x18c>)
     4c6:	a806      	add	r0, sp, #24
     4c8:	f002 fa72 	bl	29b0 <String::String(char const*)>
     4cc:	a806      	add	r0, sp, #24
     4ce:	f7ff ff0b 	bl	2e8 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]>
     4d2:	4604      	mov	r4, r0
     4d4:	2028      	movs	r0, #40	; 0x28
     4d6:	f002 fa95 	bl	2a04 <operator new(unsigned int)>
     4da:	4643      	mov	r3, r8
     4dc:	4632      	mov	r2, r6
     4de:	4621      	mov	r1, r4
     4e0:	9700      	str	r7, [sp, #0]
     4e2:	4605      	mov	r5, r0
     4e4:	f000 fa6c 	bl	9c0 <GraphNode::GraphNode(Process*, int, int, int*)>
     4e8:	a806      	add	r0, sp, #24
     4ea:	f002 fa21 	bl	2930 <String::~String()>

	Serial.println("=== Add Complimentary Filter ===");
     4ee:	4946      	ldr	r1, [pc, #280]	; (608 <main+0x190>)
     4f0:	483f      	ldr	r0, [pc, #252]	; (5f0 <main+0x178>)
     4f2:	f7ff ffaf 	bl	454 <Print::println(char const*)>
	nodelist[1] = new GraphNode(p_fact.new_proc("CMF"), 1, 2, cmf_inputs);
     4f6:	4945      	ldr	r1, [pc, #276]	; (60c <main+0x194>)
     4f8:	a806      	add	r0, sp, #24
     4fa:	f002 fa59 	bl	29b0 <String::String(char const*)>
     4fe:	a806      	add	r0, sp, #24
     500:	f7ff fef2 	bl	2e8 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]>
     504:	4681      	mov	r9, r0
     506:	2028      	movs	r0, #40	; 0x28
     508:	f002 fa7c 	bl	2a04 <operator new(unsigned int)>
     50c:	2302      	movs	r3, #2
     50e:	4642      	mov	r2, r8
     510:	4649      	mov	r1, r9
     512:	9700      	str	r7, [sp, #0]
     514:	4604      	mov	r4, r0
     516:	f000 fa53 	bl	9c0 <GraphNode::GraphNode(Process*, int, int, int*)>
     51a:	a806      	add	r0, sp, #24
     51c:	f002 fa08 	bl	2930 <String::~String()>

	Serial.println("=== Init input Vector ===");
     520:	493b      	ldr	r1, [pc, #236]	; (610 <main+0x198>)
     522:	4833      	ldr	r0, [pc, #204]	; (5f0 <main+0x178>)
     524:	f7ff ff96 	bl	454 <Print::println(char const*)>
	Vector<float> input(0);
     528:	4631      	mov	r1, r6
     52a:	a806      	add	r0, sp, #24
     52c:	f000 fbf0 	bl	d10 <Vector<float>::Vector(int)>

	Serial.println("=== Run Process 0 ===");
     530:	4938      	ldr	r1, [pc, #224]	; (614 <main+0x19c>)
     532:	482f      	ldr	r0, [pc, #188]	; (5f0 <main+0x178>)
     534:	f7ff ff8e 	bl	454 <Print::println(char const*)>
	nodelist[0]->run_proc(&input);
     538:	a906      	add	r1, sp, #24
     53a:	4628      	mov	r0, r5
     53c:	f000 fa88 	bl	a50 <GraphNode::run_proc(Vector<float>*)>
	nodelist[0]->run_proc(&input);
     540:	a906      	add	r1, sp, #24
     542:	4628      	mov	r0, r5
     544:	f000 fa84 	bl	a50 <GraphNode::run_proc(Vector<float>*)>
	nodelist[0]->run_proc(&input);
     548:	a906      	add	r1, sp, #24
     54a:	4628      	mov	r0, r5
     54c:	f000 fa80 	bl	a50 <GraphNode::run_proc(Vector<float>*)>
	nodelist[0]->print_proc();
     550:	4628      	mov	r0, r5
     552:	f000 fa9f 	bl	a94 <GraphNode::print_proc()>
	nodelist[0]->print_output();
     556:	4628      	mov	r0, r5
     558:	f000 faa0 	bl	a9c <GraphNode::print_output()>

	Serial.println("=== Setup Process 1 ===");
     55c:	492e      	ldr	r1, [pc, #184]	; (618 <main+0x1a0>)
     55e:	4824      	ldr	r0, [pc, #144]	; (5f0 <main+0x178>)
     560:	f7ff ff78 	bl	454 <Print::println(char const*)>
	input.reset(3);
     564:	a806      	add	r0, sp, #24
     566:	2103      	movs	r1, #3
     568:	f000 fbe4 	bl	d34 <Vector<float>::reset(int)>
	input.append(nodelist[0]->output());
     56c:	4628      	mov	r0, r5
     56e:	f000 fa8d 	bl	a8c <GraphNode::output()>
     572:	4601      	mov	r1, r0
     574:	a806      	add	r0, sp, #24
     576:	f000 fc27 	bl	dc8 <Vector<float>::append(Vector<float>*)>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     57a:	220b      	movs	r2, #11
     57c:	4927      	ldr	r1, [pc, #156]	; (61c <main+0x1a4>)
     57e:	481c      	ldr	r0, [pc, #112]	; (5f0 <main+0x178>)
     580:	f002 fa52 	bl	2a28 <usb_seremu_class::write(unsigned char const*, unsigned int)>
	Serial.print("CMF inputs\t"); input.print();
     584:	a806      	add	r0, sp, #24
     586:	f000 fb41 	bl	c0c <Vector<float>::print()>
	bool status = nodelist[1]->run_proc(&input);
     58a:	a906      	add	r1, sp, #24
     58c:	4620      	mov	r0, r4
     58e:	f000 fa5f 	bl	a50 <GraphNode::run_proc(Vector<float>*)>
	Serial.printf("No setup Run status %i\n", status);
     592:	4923      	ldr	r1, [pc, #140]	; (620 <main+0x1a8>)
     594:	4602      	mov	r2, r0
     596:	4816      	ldr	r0, [pc, #88]	; (5f0 <main+0x178>)
     598:	f002 f9a8 	bl	28ec <Print::printf(char const*, ...)>
	Vector<float>* config = nodelist[1]->config();
     59c:	4620      	mov	r0, r4
     59e:	f000 fa77 	bl	a90 <GraphNode::config()>
	config->from_array(tmp, 1);
     5a2:	4642      	mov	r2, r8
     5a4:	a903      	add	r1, sp, #12
     5a6:	f000 fbdb 	bl	d60 <Vector<float>::from_array(float*, int)>
	nodelist[1]->setup_proc();
     5aa:	4620      	mov	r0, r4
     5ac:	f000 fa3c 	bl	a28 <GraphNode::setup_proc()>
	status = nodelist[1]->run_proc(&input);
     5b0:	a906      	add	r1, sp, #24
     5b2:	4620      	mov	r0, r4
     5b4:	f000 fa4c 	bl	a50 <GraphNode::run_proc(Vector<float>*)>
	Serial.printf("Setup Run status %i\n", status);
     5b8:	491a      	ldr	r1, [pc, #104]	; (624 <main+0x1ac>)
     5ba:	4602      	mov	r2, r0
     5bc:	480c      	ldr	r0, [pc, #48]	; (5f0 <main+0x178>)
     5be:	f002 f995 	bl	28ec <Print::printf(char const*, ...)>
	nodelist[1]->print_proc();
     5c2:	4620      	mov	r0, r4
     5c4:	f000 fa66 	bl	a94 <GraphNode::print_proc()>
	nodelist[1]->print_output();
     5c8:	4620      	mov	r0, r4
     5ca:	f000 fa67 	bl	a9c <GraphNode::print_output()>

	Serial.println("=== Finished Graph Node tests ===");
     5ce:	4916      	ldr	r1, [pc, #88]	; (628 <main+0x1b0>)
     5d0:	4807      	ldr	r0, [pc, #28]	; (5f0 <main+0x178>)
     5d2:	f7ff ff3f 	bl	454 <Print::println(char const*)>

	Serial.println("=== Add Complimentary Filter ===");
	nodelist[1] = new GraphNode(p_fact.new_proc("CMF"), 1, 2, cmf_inputs);

	Serial.println("=== Init input Vector ===");
	Vector<float> input(0);
     5d6:	a806      	add	r0, sp, #24
     5d8:	f000 fb8c 	bl	cf4 <Vector<float>::~Vector()>
	Serial.printf("Setup Run status %i\n", status);
	nodelist[1]->print_proc();
	nodelist[1]->print_output();

	Serial.println("=== Finished Graph Node tests ===");
     5dc:	4630      	mov	r0, r6
     5de:	b00b      	add	sp, #44	; 0x2c
     5e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     5e4:	2000275c 	.word	0x2000275c
     5e8:	2000275f 	.word	0x2000275f
     5ec:	20000b44 	.word	0x20000b44
     5f0:	20001434 	.word	0x20001434
     5f4:	3f19999a 	.word	0x3f19999a
     5f8:	20000b68 	.word	0x20000b68
     5fc:	20000b88 	.word	0x20000b88
     600:	20000ba0 	.word	0x20000ba0
     604:	20000ae8 	.word	0x20000ae8
     608:	20000bb8 	.word	0x20000bb8
     60c:	20000aec 	.word	0x20000aec
     610:	20000bdc 	.word	0x20000bdc
     614:	20000bf8 	.word	0x20000bf8
     618:	20000c10 	.word	0x20000c10
     61c:	20000c28 	.word	0x20000c28
     620:	20000c34 	.word	0x20000c34
     624:	20000c4c 	.word	0x20000c4c
     628:	20000c64 	.word	0x20000c64
     62c:	00000000 	.word	0x00000000

00000630 <nd_norm(float*, int)>:
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     630:	2900      	cmp	r1, #0
     632:	dd15      	ble.n	660 <nd_norm(float*, int)+0x30>
     634:	ed9f 7a12 	vldr	s14, [pc, #72]	; 680 <nd_norm(float*, int)+0x50>
     638:	eb00 0181 	add.w	r1, r0, r1, lsl #2
		sum += v[i] * v[i];
     63c:	ecf0 7a01 	vldmia	r0!, {s15}
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     640:	4281      	cmp	r1, r0
		sum += v[i] * v[i];
     642:	eea7 7aa7 	vfma.f32	s14, s15, s15
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     646:	d1f9      	bne.n	63c <nd_norm(float*, int)+0xc>
     648:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
		sum += v[i] * v[i];
	}
	return sqrt(sum);
     64c:	eeb1 0bc7 	vsqrt.f64	d0, d7
     650:	eeb4 0b40 	vcmp.f64	d0, d0
     654:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     658:	d105      	bne.n	666 <nd_norm(float*, int)+0x36>
}
     65a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     65e:	4770      	bx	lr
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     660:	ed9f 7b05 	vldr	d7, [pc, #20]	; 678 <nd_norm(float*, int)+0x48>
     664:	e7f2      	b.n	64c <nd_norm(float*, int)+0x1c>

/*
	Vector ops
*/

float nd_norm(float* v, int n) {
     666:	b508      	push	{r3, lr}
	float sum = 0;
	for (int i = 0; i < n; i++) {
		sum += v[i] * v[i];
	}
	return sqrt(sum);
     668:	eeb0 0b47 	vmov.f64	d0, d7
     66c:	f004 f910 	bl	4890 <sqrt>
}
     670:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     674:	bd08      	pop	{r3, pc}
     676:	bf00      	nop
	...

00000684 <weighted_vector_addition(float*, float*, float, float, int, float*)>:

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     684:	2a00      	cmp	r2, #0
     686:	dd0d      	ble.n	6a4 <weighted_vector_addition(float*, float*, float, float, int, float*)+0x20>
     688:	eb00 0282 	add.w	r2, r0, r2, lsl #2
		output[i] = (k1 * a[i]) + (k2 * b[i]);
     68c:	ecf1 7a01 	vldmia	r1!, {s15}
     690:	ecb0 7a01 	vldmia	r0!, {s14}
     694:	ee67 7aa0 	vmul.f32	s15, s15, s1

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     698:	4290      	cmp	r0, r2
		output[i] = (k1 * a[i]) + (k2 * b[i]);
     69a:	eee7 7a00 	vfma.f32	s15, s14, s0
     69e:	ece3 7a01 	vstmia	r3!, {s15}

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     6a2:	d1f3      	bne.n	68c <weighted_vector_addition(float*, float*, float, float, int, float*)+0x8>
     6a4:	4770      	bx	lr
     6a6:	bf00      	nop

000006a8 <LSM6DSOX::reset()>:
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     6a8:	2300      	movs	r3, #0
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     6aa:	2200      	movs	r2, #0
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     6ac:	6103      	str	r3, [r0, #16]
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     6ae:	60c2      	str	r2, [r0, #12]
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
     6b0:	61c3      	str	r3, [r0, #28]
		mag[i] = 0;
     6b2:	6283      	str	r3, [r0, #40]	; 0x28
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     6b4:	6143      	str	r3, [r0, #20]
		gyro[i] = 0;
     6b6:	6203      	str	r3, [r0, #32]
		mag[i] = 0;
     6b8:	62c3      	str	r3, [r0, #44]	; 0x2c
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     6ba:	6183      	str	r3, [r0, #24]
		gyro[i] = 0;
     6bc:	6243      	str	r3, [r0, #36]	; 0x24
		mag[i] = 0;
     6be:	6303      	str	r3, [r0, #48]	; 0x30
     6c0:	4770      	bx	lr
     6c2:	bf00      	nop

000006c4 <LSM6DSOX::clear()>:
	}
}

void LSM6DSOX::clear() {
	reset();
     6c4:	6803      	ldr	r3, [r0, #0]
     6c6:	68db      	ldr	r3, [r3, #12]
     6c8:	4718      	bx	r3
     6ca:	bf00      	nop

000006cc <LSM6DSOX::setup(Vector<float>*)>:
}

void LSM6DSOX::setup(Vector<float>* config) {
	reset();
     6cc:	6803      	ldr	r3, [r0, #0]
     6ce:	68db      	ldr	r3, [r3, #12]
     6d0:	4718      	bx	r3
     6d2:	bf00      	nop

000006d4 <LSM6DSOX::context(Vector<float>*)>:
}

void LSM6DSOX::context(Vector<float>* context) {
     6d4:	b538      	push	{r3, r4, r5, lr}
     6d6:	460c      	mov	r4, r1
     6d8:	4605      	mov	r5, r0
	context->reset(dimensions[2]);
     6da:	2102      	movs	r1, #2
     6dc:	3004      	adds	r0, #4
     6de:	f000 faf7 	bl	cd0 <Vector<int>::operator[](int)>
     6e2:	6801      	ldr	r1, [r0, #0]
     6e4:	4620      	mov	r0, r4
     6e6:	f000 fb25 	bl	d34 <Vector<float>::reset(int)>
	context->push(sensor_index);
     6ea:	ed95 0a03 	vldr	s0, [r5, #12]
     6ee:	4620      	mov	r0, r4
     6f0:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
}
     6f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	reset();
}

void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
     6f8:	f000 bb40 	b.w	d7c <Vector<float>::push(float)>

000006fc <LSM6DSOX::run(Vector<float>*, Vector<float>*)>:
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
	switch (sensor_index) {
     6fc:	68c3      	ldr	r3, [r0, #12]
     6fe:	2b01      	cmp	r3, #1
void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
     700:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     704:	4604      	mov	r4, r0
     706:	b08a      	sub	sp, #40	; 0x28
     708:	4617      	mov	r7, r2
	switch (sensor_index) {
     70a:	d04c      	beq.n	7a6 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0xaa>
     70c:	2b02      	cmp	r3, #2
     70e:	d039      	beq.n	784 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x88>
     710:	b333      	cbz	r3, 760 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x64>
			read_lis3mdl();
			sensor_index = 0;
			break;

		default:
			sensor_index = 0;
     712:	2300      	movs	r3, #0
     714:	f100 0810 	add.w	r8, r0, #16
     718:	f100 061c 	add.w	r6, r0, #28
     71c:	f100 0528 	add.w	r5, r0, #40	; 0x28
     720:	60c3      	str	r3, [r0, #12]
     722:	46c6      	mov	lr, r8
     724:	4631      	mov	r1, r6
     726:	4628      	mov	r0, r5
     728:	ab01      	add	r3, sp, #4
void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
     72a:	2203      	movs	r2, #3
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		tmp[i] = accel[i];
     72c:	f85e cb04 	ldr.w	ip, [lr], #4
			sensor_index = 0;
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
     730:	3a01      	subs	r2, #1
		tmp[i] = accel[i];
		tmp[i+3] = gyro[i];
     732:	f851 6b04 	ldr.w	r6, [r1], #4
     736:	f103 0304 	add.w	r3, r3, #4
		tmp[i+6] = mag[i];
     73a:	f850 5b04 	ldr.w	r5, [r0], #4
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		tmp[i] = accel[i];
     73e:	f843 cc04 	str.w	ip, [r3, #-4]
		tmp[i+3] = gyro[i];
     742:	609e      	str	r6, [r3, #8]
		tmp[i+6] = mag[i];
     744:	615d      	str	r5, [r3, #20]
			sensor_index = 0;
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
     746:	d1f1      	bne.n	72c <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x30>
		tmp[i] = accel[i];
		tmp[i+3] = gyro[i];
		tmp[i+6] = mag[i];
	}

	output->from_array(tmp, dimensions[OUTPUT_DIMENSION]);
     748:	1d20      	adds	r0, r4, #4
     74a:	2102      	movs	r1, #2
     74c:	f000 fac0 	bl	cd0 <Vector<int>::operator[](int)>
     750:	a901      	add	r1, sp, #4
     752:	6802      	ldr	r2, [r0, #0]
     754:	4638      	mov	r0, r7
     756:	f000 fb03 	bl	d60 <Vector<float>::from_array(float*, int)>
}
     75a:	b00a      	add	sp, #40	; 0x28
     75c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

void LSM6DSOX::read_lsm6dsox_accel(){
	/*
		Get the jawns from the jimmys
	*/
	lsm6dsox.readAcceleration(accel[0], accel[1], accel[2]);
     760:	f100 0810 	add.w	r8, r0, #16
     764:	f100 0318 	add.w	r3, r0, #24
     768:	f100 0214 	add.w	r2, r0, #20
     76c:	305c      	adds	r0, #92	; 0x5c
     76e:	4641      	mov	r1, r8
     770:	f104 061c 	add.w	r6, r4, #28
     774:	f003 fc10 	bl	3f98 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)>

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
	switch (sensor_index) {
		case 0:
			read_lsm6dsox_accel();
			sensor_index ++;
     778:	68e3      	ldr	r3, [r4, #12]
     77a:	f104 0528 	add.w	r5, r4, #40	; 0x28
     77e:	3301      	adds	r3, #1
     780:	60e3      	str	r3, [r4, #12]
			break;
     782:	e7ce      	b.n	722 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>

void LSM6DSOX::read_lis3mdl(){
	/*
		Get the jawns from the jimmys
	*/
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
     784:	f100 0528 	add.w	r5, r0, #40	; 0x28
     788:	f100 0330 	add.w	r3, r0, #48	; 0x30
     78c:	f100 022c 	add.w	r2, r0, #44	; 0x2c
     790:	3034      	adds	r0, #52	; 0x34
     792:	4629      	mov	r1, r5
     794:	f104 0810 	add.w	r8, r4, #16
     798:	f003 f806 	bl	37a8 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)>
			sensor_index ++;
			break;

		case 2:
			read_lis3mdl();
			sensor_index = 0;
     79c:	2300      	movs	r3, #0
     79e:	f104 061c 	add.w	r6, r4, #28
     7a2:	60e3      	str	r3, [r4, #12]
			break;
     7a4:	e7bd      	b.n	722 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>

void LSM6DSOX::read_lsm6dsox_gyro(){
	/*
		Get the jawns from the jimmys
	*/
	lsm6dsox.readGyroscope(gyro[0], gyro[1], gyro[2]);
     7a6:	f100 061c 	add.w	r6, r0, #28
     7aa:	f100 0324 	add.w	r3, r0, #36	; 0x24
     7ae:	f100 0220 	add.w	r2, r0, #32
     7b2:	305c      	adds	r0, #92	; 0x5c
     7b4:	4631      	mov	r1, r6
     7b6:	f104 0810 	add.w	r8, r4, #16
     7ba:	f003 fc51 	bl	4060 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)>
			sensor_index ++;
			break;

		case 1:
			read_lsm6dsox_gyro();
			sensor_index ++;
     7be:	68e3      	ldr	r3, [r4, #12]
     7c0:	f104 0528 	add.w	r5, r4, #40	; 0x28
     7c4:	3301      	adds	r3, #1
     7c6:	60e3      	str	r3, [r4, #12]
			break;
     7c8:	e7ab      	b.n	722 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>
     7ca:	bf00      	nop

000007cc <LSM6DSOX::print()>:

	output->from_array(tmp, dimensions[OUTPUT_DIMENSION]);
}


void LSM6DSOX::print() {
     7cc:	b530      	push	{r4, r5, lr}
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     7ce:	4d29      	ldr	r5, [pc, #164]	; (874 <LSM6DSOX::print()+0xa8>)
     7d0:	b085      	sub	sp, #20
     7d2:	4604      	mov	r4, r0
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
     7d4:	2108      	movs	r1, #8
     7d6:	4828      	ldr	r0, [pc, #160]	; (878 <LSM6DSOX::print()+0xac>)
     7d8:	f001 ffe0 	bl	279c <usb_seremu_write>
     7dc:	4628      	mov	r0, r5
     7de:	f002 f86d 	bl	28bc <Print::println()>
	Serial.println("LSM6DSOX");
	Serial.printf("\tsensor_index: %i\n", sensor_index);
     7e2:	68e2      	ldr	r2, [r4, #12]
     7e4:	4628      	mov	r0, r5
     7e6:	4925      	ldr	r1, [pc, #148]	; (87c <LSM6DSOX::print()+0xb0>)
     7e8:	f002 f880 	bl	28ec <Print::printf(char const*, ...)>
	Serial.printf("\taccel: [%f, %f, %f]\n", accel[0], accel[1], accel[2]);
     7ec:	ed94 6a06 	vldr	s12, [r4, #24]
     7f0:	ed94 7a05 	vldr	s14, [r4, #20]
     7f4:	4628      	mov	r0, r5
     7f6:	edd4 5a04 	vldr	s11, [r4, #16]
     7fa:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     7fe:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     802:	491f      	ldr	r1, [pc, #124]	; (880 <LSM6DSOX::print()+0xb4>)
     804:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     808:	ed8d 6b02 	vstr	d6, [sp, #8]
     80c:	ec53 2b15 	vmov	r2, r3, d5
     810:	ed8d 7b00 	vstr	d7, [sp]
     814:	f002 f86a 	bl	28ec <Print::printf(char const*, ...)>
	Serial.printf("\tgyro: [%f, %f, %f]\n", gyro[0], gyro[1], gyro[2]);
     818:	ed94 6a09 	vldr	s12, [r4, #36]	; 0x24
     81c:	ed94 7a08 	vldr	s14, [r4, #32]
     820:	4628      	mov	r0, r5
     822:	edd4 5a07 	vldr	s11, [r4, #28]
     826:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     82a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     82e:	4915      	ldr	r1, [pc, #84]	; (884 <LSM6DSOX::print()+0xb8>)
     830:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     834:	ed8d 6b02 	vstr	d6, [sp, #8]
     838:	ec53 2b15 	vmov	r2, r3, d5
     83c:	ed8d 7b00 	vstr	d7, [sp]
     840:	f002 f854 	bl	28ec <Print::printf(char const*, ...)>
	Serial.printf("\tmag: [%f, %f, %f]\n", mag[0], mag[1], mag[2]);
     844:	ed94 6a0c 	vldr	s12, [r4, #48]	; 0x30
     848:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
     84c:	4628      	mov	r0, r5
     84e:	edd4 5a0a 	vldr	s11, [r4, #40]	; 0x28
     852:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     856:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     85a:	490b      	ldr	r1, [pc, #44]	; (888 <LSM6DSOX::print()+0xbc>)
     85c:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     860:	ed8d 6b02 	vstr	d6, [sp, #8]
     864:	ec53 2b15 	vmov	r2, r3, d5
     868:	ed8d 7b00 	vstr	d7, [sp]
     86c:	f002 f83e 	bl	28ec <Print::printf(char const*, ...)>
	// data.print();
}
     870:	b005      	add	sp, #20
     872:	bd30      	pop	{r4, r5, pc}
     874:	20001434 	.word	0x20001434
     878:	20000c88 	.word	0x20000c88
     87c:	20000c94 	.word	0x20000c94
     880:	20000ca8 	.word	0x20000ca8
     884:	20000cc0 	.word	0x20000cc0
     888:	20000cd8 	.word	0x20000cd8

0000088c <LSM6DSOX::LSM6DSOX()>:
#include "lsm6dsox.h"

LSM6DSOX::LSM6DSOX() {
     88c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     890:	4b48      	ldr	r3, [pc, #288]	; (9b4 <LSM6DSOX::LSM6DSOX()+0x128>)
     892:	4680      	mov	r8, r0
     894:	b084      	sub	sp, #16
     896:	4605      	mov	r5, r0
     898:	f100 075c 	add.w	r7, r0, #92	; 0x5c
     89c:	4606      	mov	r6, r0
     89e:	f848 3b04 	str.w	r3, [r8], #4
     8a2:	4640      	mov	r0, r8
     8a4:	f000 f9e6 	bl	c74 <Vector<int>::Vector()>
     8a8:	4b43      	ldr	r3, [pc, #268]	; (9b8 <LSM6DSOX::LSM6DSOX()+0x12c>)
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     8aa:	2400      	movs	r4, #0
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     8ac:	f8df a10c 	ldr.w	sl, [pc, #268]	; 9bc <LSM6DSOX::LSM6DSOX()+0x130>
#include "lsm6dsox.h"

LSM6DSOX::LSM6DSOX() {
     8b0:	f846 3b34 	str.w	r3, [r6], #52
     8b4:	4630      	mov	r0, r6
     8b6:	f002 fd8b 	bl	33d0 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()>
     8ba:	4638      	mov	r0, r7
     8bc:	f003 fc4e 	bl	415c <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()>
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     8c0:	f04f 0e00 	mov.w	lr, #0
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     8c4:	4623      	mov	r3, r4
     8c6:	4652      	mov	r2, sl
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     8c8:	f8c5 e010 	str.w	lr, [r5, #16]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     8cc:	4638      	mov	r0, r7

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
     8ce:	f8c5 e01c 	str.w	lr, [r5, #28]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     8d2:	216a      	movs	r1, #106	; 0x6a
void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
		mag[i] = 0;
     8d4:	f8c5 e028 	str.w	lr, [r5, #40]	; 0x28
	lis3mdl.setOperationMode(IMU_M_OP_MODE);
	
	lis3mdl.configInterrupt(false, false, false,   // enable z axis
											true,  // polarity
											false, // don't latch
											true); // enabled!
     8d8:	f04f 0901 	mov.w	r9, #1
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     8dc:	f8c5 e014 	str.w	lr, [r5, #20]
		gyro[i] = 0;
     8e0:	f8c5 e020 	str.w	lr, [r5, #32]
		mag[i] = 0;
     8e4:	f8c5 e02c 	str.w	lr, [r5, #44]	; 0x2c
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     8e8:	f8c5 e018 	str.w	lr, [r5, #24]
		gyro[i] = 0;
     8ec:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
		mag[i] = 0;
     8f0:	f8c5 e030 	str.w	lr, [r5, #48]	; 0x30
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     8f4:	60ec      	str	r4, [r5, #12]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     8f6:	f003 f9b5 	bl	3c64 <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)>
	lsm6dsox.setAccelRange(IMU_A_RANGE);
     8fa:	4638      	mov	r0, r7
     8fc:	2102      	movs	r1, #2
     8fe:	f003 fa17 	bl	3d30 <Adafruit_LSM6DS::setAccelRange(accel_range)>
	lsm6dsox.setGyroRange(IMU_G_RANGE);
     902:	4638      	mov	r0, r7
     904:	2108      	movs	r1, #8
     906:	f003 fa53 	bl	3db0 <Adafruit_LSM6DS::setGyroRange(gyro_range)>
	lsm6dsox.setAccelDataRate(IMU_A_DATA_RATE);
     90a:	4638      	mov	r0, r7
     90c:	2108      	movs	r1, #8
     90e:	f003 f9ef 	bl	3cf0 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>
	lsm6dsox.setGyroDataRate(IMU_G_DATA_RATE);
     912:	4638      	mov	r0, r7
     914:	2108      	movs	r1, #8
     916:	f003 fa2d 	bl	3d74 <Adafruit_LSM6DS::setGyroDataRate(data_rate)>
		@param active_low true to set the pins  as active high, false to set the
		mode to active low
		@param open_drain true to set the pin mode as open-drain, false to set the
		mode to push-pull
	*/
	lsm6dsox.configIntOutputs(false, true);
     91a:	4638      	mov	r0, r7
     91c:	4621      	mov	r1, r4
     91e:	464a      	mov	r2, r9
     920:	f003 fab2 	bl	3e88 <Adafruit_LSM6DS::configIntOutputs(bool, bool)>
		@param drdy_g true to output the data ready gyro interrupt
		@param drdy_xl true to output the data ready accelerometer interrupt
		@param step_detect true to output the step detection interrupt (default off)
		@param wakeup true to output the wake up interrupt (default off)
	*/
	lsm6dsox.configInt1(false, false, false, false, false);
     924:	4638      	mov	r0, r7
     926:	4623      	mov	r3, r4
     928:	4622      	mov	r2, r4
     92a:	4621      	mov	r1, r4
     92c:	9401      	str	r4, [sp, #4]
     92e:	9400      	str	r4, [sp, #0]
     930:	f003 facc 	bl	3ecc <Adafruit_LSM6DS::configInt1(bool, bool, bool, bool, bool)>
		@brief Enables and disables the data ready interrupt on INT 2.
		@param drdy_temp true to output the data ready temperature interrupt
		@param drdy_g true to output the data ready gyro interrupt
		@param drdy_xl true to output the data ready accelerometer interrupt
	*/
	lsm6dsox.configInt2(false, false, false);
     934:	4623      	mov	r3, r4
     936:	4622      	mov	r2, r4
     938:	4621      	mov	r1, r4
     93a:	4638      	mov	r0, r7
     93c:	f003 fb04 	bl	3f48 <Adafruit_LSM6DS::configInt2(bool, bool, bool)>

	// LIS3MDL Setup
	lis3mdl.begin_I2C();
     940:	4652      	mov	r2, sl
     942:	4630      	mov	r0, r6
     944:	211c      	movs	r1, #28
     946:	f002 fee3 	bl	3710 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)>
	lis3mdl.setRange(IMU_M_RANGE);
     94a:	4630      	mov	r0, r6
     94c:	4649      	mov	r1, r9
     94e:	f002 fe55 	bl	35fc <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>
	lis3mdl.setDataRate(IMU_M_DATA_RATE);
     952:	4630      	mov	r0, r6
     954:	2107      	movs	r1, #7
     956:	f002 fdfd 	bl	3554 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>
	lis3mdl.setPerformanceMode(IMU_M_PERFORMANCE);
     95a:	4630      	mov	r0, r6
     95c:	2103      	movs	r1, #3
     95e:	f002 fdc3 	bl	34e8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
	lis3mdl.setOperationMode(IMU_M_OP_MODE);
     962:	4621      	mov	r1, r4
     964:	4630      	mov	r0, r6
     966:	f002 fe2d 	bl	35c4 <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>
	
	lis3mdl.configInterrupt(false, false, false,   // enable z axis
											true,  // polarity
											false, // don't latch
											true); // enabled!
     96a:	4622      	mov	r2, r4
     96c:	4623      	mov	r3, r4
     96e:	4630      	mov	r0, r6
     970:	4621      	mov	r1, r4
     972:	9401      	str	r4, [sp, #4]
     974:	f8cd 9008 	str.w	r9, [sp, #8]
     978:	f8cd 9000 	str.w	r9, [sp]
     97c:	f002 fee8 	bl	3750 <Adafruit_LIS3MDL::configInterrupt(bool, bool, bool, bool, bool, bool)>

	dimensions.reset(PROCESS_DIMENSIONS);
     980:	4640      	mov	r0, r8
     982:	2103      	movs	r1, #3
     984:	f000 f980 	bl	c88 <Vector<int>::reset(int)>
	dimensions[INPUT_DIMENSION] = 0;
     988:	4621      	mov	r1, r4
     98a:	4640      	mov	r0, r8
     98c:	f000 f9a0 	bl	cd0 <Vector<int>::operator[](int)>
     990:	4603      	mov	r3, r0
	dimensions[CONTEXT_DIMENSION] = 1;
     992:	4649      	mov	r1, r9
     994:	4640      	mov	r0, r8
											true,  // polarity
											false, // don't latch
											true); // enabled!

	dimensions.reset(PROCESS_DIMENSIONS);
	dimensions[INPUT_DIMENSION] = 0;
     996:	601c      	str	r4, [r3, #0]
	dimensions[CONTEXT_DIMENSION] = 1;
     998:	f000 f99a 	bl	cd0 <Vector<int>::operator[](int)>
	dimensions[OUTPUT_DIMENSION] = LSM6DSOX_DOF;
     99c:	2102      	movs	r1, #2
											false, // don't latch
											true); // enabled!

	dimensions.reset(PROCESS_DIMENSIONS);
	dimensions[INPUT_DIMENSION] = 0;
	dimensions[CONTEXT_DIMENSION] = 1;
     99e:	f8c0 9000 	str.w	r9, [r0]
	dimensions[OUTPUT_DIMENSION] = LSM6DSOX_DOF;
     9a2:	4640      	mov	r0, r8
     9a4:	f000 f994 	bl	cd0 <Vector<int>::operator[](int)>
     9a8:	2309      	movs	r3, #9
     9aa:	6003      	str	r3, [r0, #0]
}
     9ac:	4628      	mov	r0, r5
     9ae:	b004      	add	sp, #16
     9b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     9b4:	20000540 	.word	0x20000540
     9b8:	20000590 	.word	0x20000590
     9bc:	20001444 	.word	0x20001444

000009c0 <GraphNode::GraphNode(Process*, int, int, int*)>:
	inputs.reset(0);
	output_buffer.reset(0);
	config_buffer.reset(0);
}

GraphNode::GraphNode(Process* p, int configs, int n_inputs, int* input_ids) {
     9c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     9c4:	f100 0808 	add.w	r8, r0, #8
     9c8:	f100 0610 	add.w	r6, r0, #16
     9cc:	4604      	mov	r4, r0
     9ce:	f100 0718 	add.w	r7, r0, #24
     9d2:	4640      	mov	r0, r8
     9d4:	460d      	mov	r5, r1
     9d6:	4692      	mov	sl, r2
     9d8:	4699      	mov	r9, r3
     9da:	f000 f94b 	bl	c74 <Vector<int>::Vector()>
     9de:	4630      	mov	r0, r6
     9e0:	f000 f984 	bl	cec <Vector<float>::Vector()>
     9e4:	4638      	mov	r0, r7
     9e6:	f000 f981 	bl	cec <Vector<float>::Vector()>
     9ea:	f104 0020 	add.w	r0, r4, #32
     9ee:	f000 f97d 	bl	cec <Vector<float>::Vector()>
			n_inputs: (int) number of input nodes
			input_ids: (int*) the identifiers of input nodes (in order of concatenation),
				does not specify the process index but a unique process id associated with each process
	*/
	proc = p;
	proc->reset();
     9f2:	682b      	ldr	r3, [r5, #0]
     9f4:	4628      	mov	r0, r5
			configs: (int) number of config values, size of buffer (always floats)
			n_inputs: (int) number of input nodes
			input_ids: (int*) the identifiers of input nodes (in order of concatenation),
				does not specify the process index but a unique process id associated with each process
	*/
	proc = p;
     9f6:	6065      	str	r5, [r4, #4]
	proc->reset();
     9f8:	68db      	ldr	r3, [r3, #12]
     9fa:	4798      	blx	r3
	config_shape = configs;

	inputs.from_array(input_ids, n_inputs);
     9fc:	464a      	mov	r2, r9
     9fe:	4640      	mov	r0, r8
     a00:	9908      	ldr	r1, [sp, #32]
			input_ids: (int*) the identifiers of input nodes (in order of concatenation),
				does not specify the process index but a unique process id associated with each process
	*/
	proc = p;
	proc->reset();
	config_shape = configs;
     a02:	f8c4 a000 	str.w	sl, [r4]

	inputs.from_array(input_ids, n_inputs);
     a06:	f000 f955 	bl	cb4 <Vector<int>::from_array(int*, int)>

	config_buffer.reset(0);
     a0a:	4638      	mov	r0, r7
     a0c:	2100      	movs	r1, #0
     a0e:	f000 f991 	bl	d34 <Vector<float>::reset(int)>
	output_buffer.reset(proc->output_dim());
     a12:	6860      	ldr	r0, [r4, #4]
     a14:	6803      	ldr	r3, [r0, #0]
     a16:	689b      	ldr	r3, [r3, #8]
     a18:	4798      	blx	r3
     a1a:	4601      	mov	r1, r0
     a1c:	4630      	mov	r0, r6
     a1e:	f000 f989 	bl	d34 <Vector<float>::reset(int)>
}
     a22:	4620      	mov	r0, r4
     a24:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00000a28 <GraphNode::setup_proc()>:

void GraphNode::set_process(Process* process) {
	proc = process;
}

bool GraphNode::setup_proc() {
     a28:	b570      	push	{r4, r5, r6, lr}
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     a2a:	4604      	mov	r4, r0

void GraphNode::set_process(Process* process) {
	proc = process;
}

bool GraphNode::setup_proc() {
     a2c:	4605      	mov	r5, r0
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     a2e:	f854 6b18 	ldr.w	r6, [r4], #24
     a32:	4620      	mov	r0, r4
     a34:	f000 f9c4 	bl	dc0 <Vector<float>::size()>
		Call the processes setup function with the config buffer
		Does nothing when not configured.
		@return
			status: (bool) if setup was called.
	*/
	if (is_configured()) {
     a38:	4286      	cmp	r6, r0
     a3a:	d001      	beq.n	a40 <GraphNode::setup_proc()+0x18>
		proc->setup(&config_buffer);
		return true;		
	}
	return false;
     a3c:	2000      	movs	r0, #0
}
     a3e:	bd70      	pop	{r4, r5, r6, pc}
		Does nothing when not configured.
		@return
			status: (bool) if setup was called.
	*/
	if (is_configured()) {
		proc->setup(&config_buffer);
     a40:	6868      	ldr	r0, [r5, #4]
     a42:	4621      	mov	r1, r4
     a44:	6803      	ldr	r3, [r0, #0]
     a46:	699b      	ldr	r3, [r3, #24]
     a48:	4798      	blx	r3
		return true;		
     a4a:	2001      	movs	r0, #1
     a4c:	bd70      	pop	{r4, r5, r6, pc}
     a4e:	bf00      	nop

00000a50 <GraphNode::run_proc(Vector<float>*)>:
	}
	return false;
}

bool GraphNode::run_proc(Vector<float>* input_buffer) {
     a50:	b570      	push	{r4, r5, r6, lr}
     a52:	4604      	mov	r4, r0
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     a54:	f850 5b18 	ldr.w	r5, [r0], #24
		return true;		
	}
	return false;
}

bool GraphNode::run_proc(Vector<float>* input_buffer) {
     a58:	460e      	mov	r6, r1
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     a5a:	f000 f9b1 	bl	dc0 <Vector<float>::size()>
			input_buffer: (Vector<float>*) concatenated outputs of processes
				listed in input_ids
		@return
			status: (bool) if run was called.
	*/
	if (is_configured() && input_buffer->size() == proc->input_dim()) {
     a5e:	4285      	cmp	r5, r0
     a60:	d001      	beq.n	a66 <GraphNode::run_proc(Vector<float>*)+0x16>
		proc->run(input_buffer, &output_buffer);
		return true;		
	}
	return false;
     a62:	2000      	movs	r0, #0
     a64:	bd70      	pop	{r4, r5, r6, pc}
			input_buffer: (Vector<float>*) concatenated outputs of processes
				listed in input_ids
		@return
			status: (bool) if run was called.
	*/
	if (is_configured() && input_buffer->size() == proc->input_dim()) {
     a66:	4630      	mov	r0, r6
     a68:	f000 f9aa 	bl	dc0 <Vector<float>::size()>
     a6c:	4605      	mov	r5, r0
     a6e:	6860      	ldr	r0, [r4, #4]
     a70:	6803      	ldr	r3, [r0, #0]
     a72:	681b      	ldr	r3, [r3, #0]
     a74:	4798      	blx	r3
     a76:	4285      	cmp	r5, r0
     a78:	d1f3      	bne.n	a62 <GraphNode::run_proc(Vector<float>*)+0x12>
		proc->run(input_buffer, &output_buffer);
     a7a:	6860      	ldr	r0, [r4, #4]
     a7c:	4631      	mov	r1, r6
     a7e:	f104 0210 	add.w	r2, r4, #16
     a82:	6803      	ldr	r3, [r0, #0]
     a84:	6a1b      	ldr	r3, [r3, #32]
     a86:	4798      	blx	r3
		return true;		
     a88:	2001      	movs	r0, #1
	}
	return false;
}
     a8a:	bd70      	pop	{r4, r5, r6, pc}

00000a8c <GraphNode::output()>:
		Get a pointer to the output buffer
		@return
			output: (Vector<float>*) buffer of output data
	*/
	return &output_buffer;
}
     a8c:	3010      	adds	r0, #16
     a8e:	4770      	bx	lr

00000a90 <GraphNode::config()>:
		Get a pointer to the setup buffer
		@return
			config: (Vector<float>*) buffer of setup data
	*/
	return &config_buffer;
}
     a90:	3018      	adds	r0, #24
     a92:	4770      	bx	lr

00000a94 <GraphNode::print_proc()>:
	*/
	return config_shape == config_buffer.size();
}

void GraphNode::print_proc() {
	proc->print();
     a94:	6840      	ldr	r0, [r0, #4]
     a96:	6803      	ldr	r3, [r0, #0]
     a98:	695b      	ldr	r3, [r3, #20]
     a9a:	4718      	bx	r3

00000a9c <GraphNode::print_output()>:
}

void GraphNode::print_output() {
     a9c:	b510      	push	{r4, lr}
     a9e:	4604      	mov	r4, r0
     aa0:	2101      	movs	r1, #1
     aa2:	4804      	ldr	r0, [pc, #16]	; (ab4 <GraphNode::print_output()+0x18>)
     aa4:	f001 fe7a 	bl	279c <usb_seremu_write>
	Serial.print("\t");
	output_buffer.print();
     aa8:	f104 0010 	add.w	r0, r4, #16
}
     aac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	proc->print();
}

void GraphNode::print_output() {
	Serial.print("\t");
	output_buffer.print();
     ab0:	f000 b8ac 	b.w	c0c <Vector<float>::print()>
     ab4:	20000cec 	.word	0x20000cec

00000ab8 <Process::input_dim()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Print");
}

int Process::input_dim() {
     ab8:	b508      	push	{r3, lr}
		Base implementation of process functions.
		returns dimensions of the input.
		@return
			dimension: (int) size of input
	*/
	return dimensions[0];
     aba:	2100      	movs	r1, #0
     abc:	3004      	adds	r0, #4
     abe:	f000 f907 	bl	cd0 <Vector<int>::operator[](int)>
}
     ac2:	6800      	ldr	r0, [r0, #0]
     ac4:	bd08      	pop	{r3, pc}
     ac6:	bf00      	nop

00000ac8 <Process::context_dim()>:

int Process::context_dim() {
     ac8:	b508      	push	{r3, lr}
		Base implementation of process functions.
		returns dimensions of the context.
		@return
			dimension: (int) size of input
	*/
	return dimensions[1];
     aca:	2101      	movs	r1, #1
     acc:	3004      	adds	r0, #4
     ace:	f000 f8ff 	bl	cd0 <Vector<int>::operator[](int)>
}
     ad2:	6800      	ldr	r0, [r0, #0]
     ad4:	bd08      	pop	{r3, pc}
     ad6:	bf00      	nop

00000ad8 <Process::output_dim()>:

int Process::output_dim() {
     ad8:	b508      	push	{r3, lr}
		Base implementation of process functions.
		returns dimensions of the output.
		@return
			dimension: (int) size of input
	*/
	return dimensions[2];
     ada:	2102      	movs	r1, #2
     adc:	3004      	adds	r0, #4
     ade:	f000 f8f7 	bl	cd0 <Vector<int>::operator[](int)>
}
     ae2:	6800      	ldr	r0, [r0, #0]
     ae4:	bd08      	pop	{r3, pc}
     ae6:	bf00      	nop

00000ae8 <Process::reset()>:
#include "system_graph/process.h"

// Drivers
#include "sensors/lsm6dsox.h"

void Process::reset() {
     ae8:	b508      	push	{r3, lr}
     aea:	2109      	movs	r1, #9
     aec:	4803      	ldr	r0, [pc, #12]	; (afc <Process::reset()+0x14>)
     aee:	f001 fe55 	bl	279c <usb_seremu_write>
     af2:	4803      	ldr	r0, [pc, #12]	; (b00 <Process::reset()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Reset");
}
     af4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     af8:	f001 bee0 	b.w	28bc <Print::println()>
     afc:	20000cf0 	.word	0x20000cf0
     b00:	20001434 	.word	0x20001434

00000b04 <Process::print()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Clear");
}

void Process::print() {
     b04:	b508      	push	{r3, lr}
     b06:	2109      	movs	r1, #9
     b08:	4803      	ldr	r0, [pc, #12]	; (b18 <Process::print()+0x14>)
     b0a:	f001 fe47 	bl	279c <usb_seremu_write>
     b0e:	4803      	ldr	r0, [pc, #12]	; (b1c <Process::print()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Print");
}
     b10:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     b14:	f001 bed2 	b.w	28bc <Print::println()>
     b18:	20000cfc 	.word	0x20000cfc
     b1c:	20001434 	.word	0x20001434

00000b20 <Process::clear()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Reset");
}

void Process::clear() {
     b20:	b508      	push	{r3, lr}
     b22:	2109      	movs	r1, #9
     b24:	4803      	ldr	r0, [pc, #12]	; (b34 <Process::clear()+0x14>)
     b26:	f001 fe39 	bl	279c <usb_seremu_write>
     b2a:	4803      	ldr	r0, [pc, #12]	; (b38 <Process::clear()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Clear");
}
     b2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     b30:	f001 bec4 	b.w	28bc <Print::println()>
     b34:	20000d08 	.word	0x20000d08
     b38:	20001434 	.word	0x20001434

00000b3c <Process::setup(Vector<float>*)>:
			dimension: (int) size of input
	*/
	return dimensions[2];
}

void Process::setup(Vector<float>* config) {
     b3c:	b510      	push	{r4, lr}
     b3e:	4806      	ldr	r0, [pc, #24]	; (b58 <Process::setup(Vector<float>*)+0x1c>)
     b40:	460c      	mov	r4, r1
     b42:	2109      	movs	r1, #9
     b44:	f001 fe2a 	bl	279c <usb_seremu_write>
     b48:	4804      	ldr	r0, [pc, #16]	; (b5c <Process::setup(Vector<float>*)+0x20>)
     b4a:	f001 feb7 	bl	28bc <Print::println()>
		@param
			config: (Vector<float>) Vector of configuration data, 
				organization is handled by user
	*/
	Serial.println("PBO Setup");
	config->print();
     b4e:	4620      	mov	r0, r4
}
     b50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		@param
			config: (Vector<float>) Vector of configuration data, 
				organization is handled by user
	*/
	Serial.println("PBO Setup");
	config->print();
     b54:	f000 b85a 	b.w	c0c <Vector<float>::print()>
     b58:	20000d14 	.word	0x20000d14
     b5c:	20001434 	.word	0x20001434

00000b60 <Process::context(Vector<float>*)>:
}

void Process::context(Vector<float>* context) {
     b60:	b510      	push	{r4, lr}
     b62:	4807      	ldr	r0, [pc, #28]	; (b80 <Process::context(Vector<float>*)+0x20>)
     b64:	460c      	mov	r4, r1
     b66:	2115      	movs	r1, #21
     b68:	f001 fe18 	bl	279c <usb_seremu_write>
     b6c:	4805      	ldr	r0, [pc, #20]	; (b84 <Process::context(Vector<float>*)+0x24>)
     b6e:	f001 fea5 	bl	28bc <Print::println()>
		Only defined to show user when inheritance has issues.
		@param
			context: (Vector<float>*) empty vector to fill with the context
	*/
	Serial.println("Requested PBO context");
	context->reset(0);
     b72:	4620      	mov	r0, r4
     b74:	2100      	movs	r1, #0
}
     b76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		Only defined to show user when inheritance has issues.
		@param
			context: (Vector<float>*) empty vector to fill with the context
	*/
	Serial.println("Requested PBO context");
	context->reset(0);
     b7a:	f000 b8db 	b.w	d34 <Vector<float>::reset(int)>
     b7e:	bf00      	nop
     b80:	20000d20 	.word	0x20000d20
     b84:	20001434 	.word	0x20001434

00000b88 <Process::run(Vector<float>*, Vector<float>*)>:
}

void Process::run(Vector<float>* input, Vector<float>* output) {
     b88:	b510      	push	{r4, lr}
     b8a:	2107      	movs	r1, #7
     b8c:	4614      	mov	r4, r2
     b8e:	4806      	ldr	r0, [pc, #24]	; (ba8 <Process::run(Vector<float>*, Vector<float>*)+0x20>)
     b90:	f001 fe04 	bl	279c <usb_seremu_write>
     b94:	4805      	ldr	r0, [pc, #20]	; (bac <Process::run(Vector<float>*, Vector<float>*)+0x24>)
     b96:	f001 fe91 	bl	28bc <Print::println()>
		@param
			input: (Vector<float>*) flattened Vector of input data for process
			output: (Vector<float>*) flattened Vector of output data from process
	*/
	Serial.println("PBO Run");
	output->reset(0);
     b9a:	4620      	mov	r0, r4
     b9c:	2100      	movs	r1, #0
}
     b9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		@param
			input: (Vector<float>*) flattened Vector of input data for process
			output: (Vector<float>*) flattened Vector of output data from process
	*/
	Serial.println("PBO Run");
	output->reset(0);
     ba2:	f000 b8c7 	b.w	d34 <Vector<float>::reset(int)>
     ba6:	bf00      	nop
     ba8:	20000d38 	.word	0x20000d38
     bac:	20001434 	.word	0x20001434

00000bb0 <FTYK::FTYK()>:
	uint32_t delta_ns = CYCLES_2_NS(delta_cycles); 
	Serial.printf( "\t%1lu cycles, %1lu ns\n", delta_cycles, delta_ns);
	return delta_ns;
}

FTYK::FTYK() {
     bb0:	b410      	push	{r4}
     bb2:	1f03      	subs	r3, r0, #4
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
		timers[i] = ARM_DWT_CYCCNT;
     bb4:	4c05      	ldr	r4, [pc, #20]	; (bcc <FTYK::FTYK()+0x1c>)
     bb6:	f100 0124 	add.w	r1, r0, #36	; 0x24
     bba:	6822      	ldr	r2, [r4, #0]
     bbc:	f843 2f04 	str.w	r2, [r3, #4]!
			- add rollover support: ARM_DWT_CYCCNT is a cycle count that resets every 8
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
     bc0:	428b      	cmp	r3, r1
     bc2:	d1fa      	bne.n	bba <FTYK::FTYK()+0xa>
		timers[i] = ARM_DWT_CYCCNT;
	}
}
     bc4:	f85d 4b04 	ldr.w	r4, [sp], #4
     bc8:	4770      	bx	lr
     bca:	bf00      	nop
     bcc:	e0001004 	.word	0xe0001004

00000bd0 <FTYK::set(int)>:
	/*
		  Set the timer at idx to the current cycle count.
		@param:
			idx: (int) index of the timer to set.
	*/
	timers[idx] = ARM_DWT_CYCCNT;
     bd0:	4b02      	ldr	r3, [pc, #8]	; (bdc <FTYK::set(int)+0xc>)
     bd2:	681b      	ldr	r3, [r3, #0]
     bd4:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
     bd8:	4770      	bx	lr
     bda:	bf00      	nop
     bdc:	e0001004 	.word	0xe0001004

00000be0 <FTYK::micros(int)>:
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     be0:	4b09      	ldr	r3, [pc, #36]	; (c08 <FTYK::micros(int)+0x28>)
	/*
		  Get the number of microseconds since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return CYCLES_2_US(cycles(idx)); 
     be2:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     be6:	681b      	ldr	r3, [r3, #0]
	/*
		  Get the number of microseconds since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return CYCLES_2_US(cycles(idx)); 
     be8:	1a9b      	subs	r3, r3, r2
     bea:	ee00 3a10 	vmov	s0, r3
     bee:	ed9f 7b04 	vldr	d7, [pc, #16]	; c00 <FTYK::micros(int)+0x20>
     bf2:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
     bf6:	ee20 0b07 	vmul.f64	d0, d0, d7
}
     bfa:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     bfe:	4770      	bx	lr
     c00:	b4e81b4f 	.word	0xb4e81b4f
     c04:	3f5b4e81 	.word	0x3f5b4e81
     c08:	e0001004 	.word	0xe0001004

00000c0c <Vector<float>::print()>:
		Serial.printf("%i, ", buffer[i]);
	}
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
     c0c:	b570      	push	{r4, r5, r6, lr}
     c0e:	4605      	mov	r5, r0
	Serial.printf("Vectorf [%i]: [", length);
     c10:	4914      	ldr	r1, [pc, #80]	; (c64 <Vector<float>::print()+0x58>)
     c12:	4815      	ldr	r0, [pc, #84]	; (c68 <Vector<float>::print()+0x5c>)
     c14:	682a      	ldr	r2, [r5, #0]
     c16:	f001 fe69 	bl	28ec <Print::printf(char const*, ...)>
	for (int i = 0; i < length-1; i++) {
     c1a:	682b      	ldr	r3, [r5, #0]
     c1c:	2b01      	cmp	r3, #1
     c1e:	dd12      	ble.n	c46 <Vector<float>::print()+0x3a>
     c20:	2400      	movs	r4, #0
		Serial.printf("%f, ", buffer[i]);
     c22:	686b      	ldr	r3, [r5, #4]
     c24:	4911      	ldr	r1, [pc, #68]	; (c6c <Vector<float>::print()+0x60>)
     c26:	eb03 0384 	add.w	r3, r3, r4, lsl #2
     c2a:	480f      	ldr	r0, [pc, #60]	; (c68 <Vector<float>::print()+0x5c>)
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
     c2c:	3401      	adds	r4, #1
		Serial.printf("%f, ", buffer[i]);
     c2e:	edd3 7a00 	vldr	s15, [r3]
     c32:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
     c36:	ec53 2b17 	vmov	r2, r3, d7
     c3a:	f001 fe57 	bl	28ec <Print::printf(char const*, ...)>
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
     c3e:	682b      	ldr	r3, [r5, #0]
     c40:	1e5a      	subs	r2, r3, #1
     c42:	42a2      	cmp	r2, r4
     c44:	dced      	bgt.n	c22 <Vector<float>::print()+0x16>
		Serial.printf("%f, ", buffer[i]);
	}
	Serial.printf("%f]\n", buffer[length-1]);
     c46:	686a      	ldr	r2, [r5, #4]
     c48:	4909      	ldr	r1, [pc, #36]	; (c70 <Vector<float>::print()+0x64>)
     c4a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
     c4e:	4806      	ldr	r0, [pc, #24]	; (c68 <Vector<float>::print()+0x5c>)
     c50:	ed53 7a01 	vldr	s15, [r3, #-4]
     c54:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
}
     c58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
template <> void Vector<float>::print() {
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
		Serial.printf("%f, ", buffer[i]);
	}
	Serial.printf("%f]\n", buffer[length-1]);
     c5c:	ec53 2b17 	vmov	r2, r3, d7
     c60:	f001 be44 	b.w	28ec <Print::printf(char const*, ...)>
     c64:	20000d70 	.word	0x20000d70
     c68:	20001434 	.word	0x20001434
     c6c:	20000d80 	.word	0x20000d80
     c70:	20000cd0 	.word	0x20000cd0

00000c74 <Vector<int>::Vector()>:
#include "utilities/vector.h"
#include "system_graph/process.h"
#include "system_graph/graph_node.h"

template <typename T> Vector<T>::Vector() {
	length = 0;
     c74:	2200      	movs	r2, #0
     c76:	6002      	str	r2, [r0, #0]
	buffer = NULL;
     c78:	6042      	str	r2, [r0, #4]
}
     c7a:	4770      	bx	lr

00000c7c <Vector<int>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
     c7c:	6802      	ldr	r2, [r0, #0]
     c7e:	2100      	movs	r1, #0
     c80:	6840      	ldr	r0, [r0, #4]
     c82:	0092      	lsls	r2, r2, #2
     c84:	f005 bd6a 	b.w	675c <memset>

00000c88 <Vector<int>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
     c88:	b538      	push	{r3, r4, r5, lr}
     c8a:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
     c8c:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
     c8e:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
     c90:	b110      	cbz	r0, c98 <Vector<int>::reset(int)+0x10>
		delete buffer;
     c92:	2104      	movs	r1, #4
     c94:	f001 feba 	bl	2a0c <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
     c98:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
     c9c:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
     c9e:	bf94      	ite	ls
     ca0:	00a0      	lslls	r0, r4, #2
     ca2:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
     ca6:	f001 feaf 	bl	2a08 <operator new[](unsigned int)>
     caa:	6068      	str	r0, [r5, #4]
	clear();
     cac:	4628      	mov	r0, r5
     cae:	f7ff ffe5 	bl	c7c <Vector<int>::clear()>
     cb2:	bd38      	pop	{r3, r4, r5, pc}

00000cb4 <Vector<int>::from_array(int*, int)>:
}

template <typename T> void Vector<T>::from_array(T* data, int size) {
     cb4:	b570      	push	{r4, r5, r6, lr}
     cb6:	4614      	mov	r4, r2
     cb8:	460e      	mov	r6, r1
     cba:	4605      	mov	r5, r0
		  reset the buffer to size n with data T*.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
     cbc:	4611      	mov	r1, r2
     cbe:	f7ff ffe3 	bl	c88 <Vector<int>::reset(int)>
	memcpy(buffer, data, size * sizeof(T));
     cc2:	4631      	mov	r1, r6
     cc4:	00a2      	lsls	r2, r4, #2
     cc6:	6868      	ldr	r0, [r5, #4]
}
     cc8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
	memcpy(buffer, data, size * sizeof(T));
     ccc:	f005 bc48 	b.w	6560 <memcpy>

00000cd0 <Vector<int>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
     cd0:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
     cd2:	6803      	ldr	r3, [r0, #0]
     cd4:	428b      	cmp	r3, r1
     cd6:	dd05      	ble.n	ce4 <Vector<int>::operator[](int)+0x14>
     cd8:	2900      	cmp	r1, #0
     cda:	db03      	blt.n	ce4 <Vector<int>::operator[](int)+0x14>
		return buffer[index];
     cdc:	6840      	ldr	r0, [r0, #4]
     cde:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
     ce2:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
     ce4:	2000      	movs	r0, #0
     ce6:	f005 f925 	bl	5f34 <exit>
     cea:	bf00      	nop

00000cec <Vector<float>::Vector()>:
#include "utilities/vector.h"
#include "system_graph/process.h"
#include "system_graph/graph_node.h"

template <typename T> Vector<T>::Vector() {
	length = 0;
     cec:	2200      	movs	r2, #0
     cee:	6002      	str	r2, [r0, #0]
	buffer = NULL;
     cf0:	6042      	str	r2, [r0, #4]
}
     cf2:	4770      	bx	lr

00000cf4 <Vector<float>::~Vector()>:

template <typename T> Vector<T>::~Vector() {
     cf4:	b510      	push	{r4, lr}
     cf6:	4604      	mov	r4, r0
	delete buffer;
     cf8:	2104      	movs	r1, #4
     cfa:	6840      	ldr	r0, [r0, #4]
     cfc:	f001 fe86 	bl	2a0c <operator delete(void*, unsigned int)>
}
     d00:	4620      	mov	r0, r4
     d02:	bd10      	pop	{r4, pc}

00000d04 <Vector<float>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
     d04:	6802      	ldr	r2, [r0, #0]
     d06:	2100      	movs	r1, #0
     d08:	6840      	ldr	r0, [r0, #4]
     d0a:	0092      	lsls	r2, r2, #2
     d0c:	f005 bd26 	b.w	675c <memset>

00000d10 <Vector<float>::Vector(int)>:
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
	buffer = new T[size];
     d10:	f1b1 5ffe 	cmp.w	r1, #532676608	; 0x1fc00000

template <typename T> Vector<T>::~Vector() {
	delete buffer;
}

template <typename T> Vector<T>::Vector(int size) {
     d14:	b510      	push	{r4, lr}
     d16:	4604      	mov	r4, r0
	/*
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
     d18:	6001      	str	r1, [r0, #0]
	buffer = new T[size];
     d1a:	bf94      	ite	ls
     d1c:	0088      	lslls	r0, r1, #2
     d1e:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
     d22:	f001 fe71 	bl	2a08 <operator new[](unsigned int)>
     d26:	6060      	str	r0, [r4, #4]
	clear();
     d28:	4620      	mov	r0, r4
     d2a:	f7ff ffeb 	bl	d04 <Vector<float>::clear()>
}
     d2e:	4620      	mov	r0, r4
     d30:	bd10      	pop	{r4, pc}
     d32:	bf00      	nop

00000d34 <Vector<float>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
     d34:	b538      	push	{r3, r4, r5, lr}
     d36:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
     d38:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
     d3a:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
     d3c:	b110      	cbz	r0, d44 <Vector<float>::reset(int)+0x10>
		delete buffer;
     d3e:	2104      	movs	r1, #4
     d40:	f001 fe64 	bl	2a0c <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
     d44:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
     d48:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
     d4a:	bf94      	ite	ls
     d4c:	00a0      	lslls	r0, r4, #2
     d4e:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
     d52:	f001 fe59 	bl	2a08 <operator new[](unsigned int)>
     d56:	6068      	str	r0, [r5, #4]
	clear();
     d58:	4628      	mov	r0, r5
     d5a:	f7ff ffd3 	bl	d04 <Vector<float>::clear()>
     d5e:	bd38      	pop	{r3, r4, r5, pc}

00000d60 <Vector<float>::from_array(float*, int)>:
}

template <typename T> void Vector<T>::from_array(T* data, int size) {
     d60:	b570      	push	{r4, r5, r6, lr}
     d62:	4614      	mov	r4, r2
     d64:	460e      	mov	r6, r1
     d66:	4605      	mov	r5, r0
		  reset the buffer to size n with data T*.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
     d68:	4611      	mov	r1, r2
     d6a:	f7ff ffe3 	bl	d34 <Vector<float>::reset(int)>
	memcpy(buffer, data, size * sizeof(T));
     d6e:	4631      	mov	r1, r6
     d70:	00a2      	lsls	r2, r4, #2
     d72:	6868      	ldr	r0, [r5, #4]
}
     d74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
	memcpy(buffer, data, size * sizeof(T));
     d78:	f005 bbf2 	b.w	6560 <memcpy>

00000d7c <Vector<float>::push(float)>:
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
     d7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
     d7e:	6806      	ldr	r6, [r0, #0]
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
     d80:	4604      	mov	r4, r0
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
     d82:	6841      	ldr	r1, [r0, #4]
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
     d84:	1c75      	adds	r5, r6, #1
     d86:	00aa      	lsls	r2, r5, #2
     d88:	f102 000a 	add.w	r0, r2, #10
	memcpy(tmp, buffer, length * sizeof(T));
     d8c:	3a04      	subs	r2, #4
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
     d8e:	f020 0007 	bic.w	r0, r0, #7
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
     d92:	ed2d 8b02 	vpush	{d8}
     d96:	af00      	add	r7, sp, #0
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
     d98:	ebad 0d00 	sub.w	sp, sp, r0
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
     d9c:	eeb0 8a40 	vmov.f32	s16, s0
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
     da0:	4668      	mov	r0, sp
     da2:	f005 fbdd 	bl	6560 <memcpy>
	tmp[length] = item;
	from_array(tmp, length+1);
     da6:	462a      	mov	r2, r5
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
     da8:	eb00 0386 	add.w	r3, r0, r6, lsl #2
	from_array(tmp, length+1);
     dac:	4601      	mov	r1, r0
     dae:	4620      	mov	r0, r4
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
     db0:	ed83 8a00 	vstr	s16, [r3]
	from_array(tmp, length+1);
     db4:	f7ff ffd4 	bl	d60 <Vector<float>::from_array(float*, int)>
}
     db8:	46bd      	mov	sp, r7
     dba:	ecbd 8b02 	vpop	{d8}
     dbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00000dc0 <Vector<float>::size()>:
		  Get the size of buffer (not necessarily elements available)
		@return
			length: (int) size of buffer
	*/
	return length;
}
     dc0:	6800      	ldr	r0, [r0, #0]
     dc2:	4770      	bx	lr

00000dc4 <Vector<float>::as_array()>:
	return -1;
}

template <typename T> T* Vector<T>::as_array() {
	return buffer;
}
     dc4:	6840      	ldr	r0, [r0, #4]
     dc6:	4770      	bx	lr

00000dc8 <Vector<float>::append(Vector<float>*)>:
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
     dc8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		  Add n values to the buffer. Stores the current buffer and
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
     dcc:	f8d0 8000 	ldr.w	r8, [r0]
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
     dd0:	af00      	add	r7, sp, #0
     dd2:	4604      	mov	r4, r0
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();
     dd4:	4608      	mov	r0, r1

	T tmp1[n];
     dd6:	ea4f 0588 	mov.w	r5, r8, lsl #2
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
     dda:	4689      	mov	r9, r1
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();
     ddc:	f7ff fff0 	bl	dc0 <Vector<float>::size()>
     de0:	4606      	mov	r6, r0

	T tmp1[n];
     de2:	f105 030a 	add.w	r3, r5, #10
	T* tmp2 = data->as_array();
     de6:	4648      	mov	r0, r9
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();

	T tmp1[n];
     de8:	f023 0307 	bic.w	r3, r3, #7
     dec:	ebad 0d03 	sub.w	sp, sp, r3
	T* tmp2 = data->as_array();
     df0:	f7ff ffe8 	bl	dc4 <Vector<float>::as_array()>

	reset(n + m);
     df4:	eb08 0106 	add.w	r1, r8, r6
	*/
	int n = length;
	int m = data->size();

	T tmp1[n];
	T* tmp2 = data->as_array();
     df8:	4681      	mov	r9, r0

	reset(n + m);
     dfa:	4620      	mov	r0, r4
     dfc:	f7ff ff9a 	bl	d34 <Vector<float>::reset(int)>
	memcpy(buffer, tmp1, n * sizeof(T));
     e00:	462a      	mov	r2, r5
     e02:	4669      	mov	r1, sp
     e04:	6860      	ldr	r0, [r4, #4]
     e06:	f005 fbab 	bl	6560 <memcpy>
	memcpy(&buffer[n], tmp2, m * sizeof(T));
     e0a:	6860      	ldr	r0, [r4, #4]
     e0c:	00b2      	lsls	r2, r6, #2
     e0e:	4649      	mov	r1, r9
     e10:	4428      	add	r0, r5
     e12:	f005 fba5 	bl	6560 <memcpy>
}
     e16:	46bd      	mov	sp, r7
     e18:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00000e1c <Vector<float>::insert(float*, int, int)>:

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
     e1c:	b5f0      	push	{r4, r5, r6, r7, lr}
     e1e:	461d      	mov	r5, r3
     e20:	460c      	mov	r4, r1
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
     e22:	6803      	ldr	r3, [r0, #0]
	reset(n + m);
	memcpy(buffer, tmp1, n * sizeof(T));
	memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
     e24:	b083      	sub	sp, #12
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
     e26:	1951      	adds	r1, r2, r5
	reset(n + m);
	memcpy(buffer, tmp1, n * sizeof(T));
	memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
     e28:	4606      	mov	r6, r0
     e2a:	4617      	mov	r7, r2
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
     e2c:	4299      	cmp	r1, r3
     e2e:	dc0f      	bgt.n	e50 <Vector<float>::insert(float*, int, int)+0x34>
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
     e30:	2d00      	cmp	r5, #0
     e32:	dd0b      	ble.n	e4c <Vector<float>::insert(float*, int, int)+0x30>
     e34:	6870      	ldr	r0, [r6, #4]
     e36:	4621      	mov	r1, r4
     e38:	eb04 0385 	add.w	r3, r4, r5, lsl #2
     e3c:	eb00 0287 	add.w	r2, r0, r7, lsl #2
		buffer[i + index] = data[i];
     e40:	f851 0b04 	ldr.w	r0, [r1], #4
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
     e44:	428b      	cmp	r3, r1
		buffer[i + index] = data[i];
     e46:	f842 0b04 	str.w	r0, [r2], #4
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
     e4a:	d1f9      	bne.n	e40 <Vector<float>::insert(float*, int, int)+0x24>
		buffer[i + index] = data[i];
	}
}
     e4c:	b003      	add	sp, #12
     e4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
     e50:	1ac9      	subs	r1, r1, r3
     e52:	4668      	mov	r0, sp
     e54:	f7ff ff5c 	bl	d10 <Vector<float>::Vector(int)>
		append(&empty);
     e58:	4630      	mov	r0, r6
     e5a:	4669      	mov	r1, sp
     e5c:	f7ff ffb4 	bl	dc8 <Vector<float>::append(Vector<float>*)>
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
     e60:	4668      	mov	r0, sp
     e62:	f7ff ff47 	bl	cf4 <Vector<float>::~Vector()>
     e66:	e7e3      	b.n	e30 <Vector<float>::insert(float*, int, int)+0x14>

00000e68 <Vector<float>::slice(float*, int, int)>:

template <typename T> T* Vector<T>::as_array() {
	return buffer;
}

template <typename T> void Vector<T>::slice(T* data, int start, int n) {
     e68:	b430      	push	{r4, r5}
		@return
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
     e6a:	1e14      	subs	r4, r2, #0
     e6c:	db03      	blt.n	e76 <Vector<float>::slice(float*, int, int)+0xe>
     e6e:	18e2      	adds	r2, r4, r3
     e70:	6805      	ldr	r5, [r0, #0]
     e72:	42aa      	cmp	r2, r5
     e74:	dd05      	ble.n	e82 <Vector<float>::slice(float*, int, int)+0x1a>
		memcpy(data, &buffer[start], n * sizeof(T));
	}
	else {
		memset(data, 0, n * sizeof(T));
     e76:	4608      	mov	r0, r1
     e78:	009a      	lsls	r2, r3, #2
     e7a:	2100      	movs	r1, #0
	}
}
     e7c:	bc30      	pop	{r4, r5}
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
	}
	else {
		memset(data, 0, n * sizeof(T));
     e7e:	f005 bc6d 	b.w	675c <memset>
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
     e82:	6845      	ldr	r5, [r0, #4]
     e84:	009a      	lsls	r2, r3, #2
     e86:	4608      	mov	r0, r1
     e88:	eb05 0184 	add.w	r1, r5, r4, lsl #2
	}
	else {
		memset(data, 0, n * sizeof(T));
	}
}
     e8c:	bc30      	pop	{r4, r5}
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
     e8e:	f005 bb67 	b.w	6560 <memcpy>
     e92:	bf00      	nop

00000e94 <Vector<float>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
     e94:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
     e96:	6803      	ldr	r3, [r0, #0]
     e98:	428b      	cmp	r3, r1
     e9a:	dd05      	ble.n	ea8 <Vector<float>::operator[](int)+0x14>
     e9c:	2900      	cmp	r1, #0
     e9e:	db03      	blt.n	ea8 <Vector<float>::operator[](int)+0x14>
		return buffer[index];
     ea0:	6840      	ldr	r0, [r0, #4]
     ea2:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
     ea6:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
     ea8:	2000      	movs	r0, #0
     eaa:	f005 f843 	bl	5f34 <exit>
     eae:	bf00      	nop

00000eb0 <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
     eb0:	4a96      	ldr	r2, [pc, #600]	; (110c <set_arm_clock+0x25c>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
     eb2:	4b97      	ldr	r3, [pc, #604]	; (1110 <set_arm_clock+0x260>)
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
     eb4:	4290      	cmp	r0, r2
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
     eb6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;
     eba:	4c96      	ldr	r4, [pc, #600]	; (1114 <set_arm_clock+0x264>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
     ebc:	f8d3 e014 	ldr.w	lr, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
     ec0:	6999      	ldr	r1, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
     ec2:	68e6      	ldr	r6, [r4, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
     ec4:	d91c      	bls.n	f00 <set_arm_clock+0x50>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
     ec6:	4b94      	ldr	r3, [pc, #592]	; (1118 <set_arm_clock+0x268>)
     ec8:	4298      	cmp	r0, r3
     eca:	f240 8115 	bls.w	10f8 <set_arm_clock+0x248>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
     ece:	4b93      	ldr	r3, [pc, #588]	; (111c <set_arm_clock+0x26c>)
     ed0:	f240 6527 	movw	r5, #1575	; 0x627
     ed4:	4f92      	ldr	r7, [pc, #584]	; (1120 <set_arm_clock+0x270>)
     ed6:	4403      	add	r3, r0
     ed8:	4c92      	ldr	r4, [pc, #584]	; (1124 <set_arm_clock+0x274>)
     eda:	0a1a      	lsrs	r2, r3, #8
     edc:	fba7 3202 	umull	r3, r2, r7, r2
     ee0:	09d3      	lsrs	r3, r2, #7
     ee2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
     ee6:	eb03 0283 	add.w	r2, r3, r3, lsl #2
     eea:	f202 43e2 	addw	r3, r2, #1250	; 0x4e2
     eee:	42ab      	cmp	r3, r5
     ef0:	bf28      	it	cs
     ef2:	462b      	movcs	r3, r5
     ef4:	f5a3 7348 	sub.w	r3, r3, #800	; 0x320
     ef8:	fba4 3503 	umull	r3, r5, r4, r3
     efc:	08ed      	lsrs	r5, r5, #3
     efe:	e004      	b.n	f0a <set_arm_clock+0x5a>
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
		}
#endif
	} else if (frequency <= 24000000) {
     f00:	4d89      	ldr	r5, [pc, #548]	; (1128 <set_arm_clock+0x278>)
     f02:	42a8      	cmp	r0, r5
     f04:	bf94      	ite	ls
     f06:	2506      	movls	r5, #6
     f08:	250e      	movhi	r5, #14
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
     f0a:	4a81      	ldr	r2, [pc, #516]	; (1110 <set_arm_clock+0x260>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
     f0c:	f006 071f 	and.w	r7, r6, #31
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
     f10:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
     f14:	42af      	cmp	r7, r5
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
     f16:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
     f1a:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
     f1e:	d20a      	bcs.n	f36 <set_arm_clock+0x86>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
     f20:	4b7c      	ldr	r3, [pc, #496]	; (1114 <set_arm_clock+0x264>)

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
     f22:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
     f26:	461a      	mov	r2, r3
	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
     f28:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
     f2a:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
     f2c:	6813      	ldr	r3, [r2, #0]
     f2e:	2b00      	cmp	r3, #0
     f30:	dafc      	bge.n	f2c <set_arm_clock+0x7c>
     f32:	f006 071f 	and.w	r7, r6, #31
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
     f36:	f01e 7300 	ands.w	r3, lr, #33554432	; 0x2000000
     f3a:	d131      	bne.n	fa0 <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
     f3c:	4c7b      	ldr	r4, [pc, #492]	; (112c <set_arm_clock+0x27c>)
     f3e:	4a7c      	ldr	r2, [pc, #496]	; (1130 <set_arm_clock+0x280>)
     f40:	f8d4 c010 	ldr.w	ip, [r4, #16]
     f44:	4614      	mov	r4, r2
     f46:	ea0c 0202 	and.w	r2, ip, r2
     f4a:	42a2      	cmp	r2, r4
     f4c:	bf0a      	itet	eq
     f4e:	f04f 53c0 	moveq.w	r3, #402653184	; 0x18000000
     f52:	f44f 5280 	movne.w	r2, #4096	; 0x1000
     f56:	2200      	moveq	r2, #0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
     f58:	ea8e 0403 	eor.w	r4, lr, r3
     f5c:	f014 5f60 	tst.w	r4, #939524096	; 0x38000000
     f60:	d008      	beq.n	f74 <set_arm_clock+0xc4>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
     f62:	f02e 5e60 	bic.w	lr, lr, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
     f66:	f003 5360 	and.w	r3, r3, #939524096	; 0x38000000
			CCM_CBCDR = cbcdr;
     f6a:	4c69      	ldr	r4, [pc, #420]	; (1110 <set_arm_clock+0x260>)
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
     f6c:	ea43 0e0e 	orr.w	lr, r3, lr
			CCM_CBCDR = cbcdr;
     f70:	f8c4 e014 	str.w	lr, [r4, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
     f74:	ea81 0302 	eor.w	r3, r1, r2
     f78:	f413 5f40 	tst.w	r3, #12288	; 0x3000
     f7c:	d008      	beq.n	f90 <set_arm_clock+0xe0>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
     f7e:	4b64      	ldr	r3, [pc, #400]	; (1110 <set_arm_clock+0x260>)
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
			CCM_CBCDR = cbcdr;
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
     f80:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
     f84:	4311      	orrs	r1, r2
			CCM_CBCMR = cbcmr;
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
     f86:	461a      	mov	r2, r3
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
     f88:	6199      	str	r1, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
     f8a:	6c93      	ldr	r3, [r2, #72]	; 0x48
     f8c:	071c      	lsls	r4, r3, #28
     f8e:	d4fc      	bmi.n	f8a <set_arm_clock+0xda>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
     f90:	f04e 7e00 	orr.w	lr, lr, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
     f94:	4a5e      	ldr	r2, [pc, #376]	; (1110 <set_arm_clock+0x260>)
     f96:	f8c2 e014 	str.w	lr, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
     f9a:	6c93      	ldr	r3, [r2, #72]	; 0x48
     f9c:	0699      	lsls	r1, r3, #26
     f9e:	d4fc      	bmi.n	f9a <set_arm_clock+0xea>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
     fa0:	2101      	movs	r1, #1
	while (frequency * div_arm * div_ahb < 648000000) {
     fa2:	4c64      	ldr	r4, [pc, #400]	; (1134 <set_arm_clock+0x284>)
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
     fa4:	460a      	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
     fa6:	fb01 f302 	mul.w	r3, r1, r2
     faa:	fb00 f303 	mul.w	r3, r0, r3
     fae:	42a3      	cmp	r3, r4
     fb0:	d809      	bhi.n	fc6 <set_arm_clock+0x116>
		if (div_arm < 8) {
     fb2:	2a07      	cmp	r2, #7
     fb4:	f200 8095 	bhi.w	10e2 <set_arm_clock+0x232>
			div_arm = div_arm + 1;
     fb8:	3201      	adds	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
     fba:	fb01 f302 	mul.w	r3, r1, r2
     fbe:	fb00 f303 	mul.w	r3, r0, r3
     fc2:	42a3      	cmp	r3, r4
     fc4:	d9f5      	bls.n	fb2 <set_arm_clock+0x102>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
     fc6:	485c      	ldr	r0, [pc, #368]	; (1138 <set_arm_clock+0x288>)
     fc8:	4c5c      	ldr	r4, [pc, #368]	; (113c <set_arm_clock+0x28c>)
     fca:	4418      	add	r0, r3
     fcc:	fba4 0300 	umull	r0, r3, r4, r0
     fd0:	0d1b      	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
     fd2:	2b6c      	cmp	r3, #108	; 0x6c
     fd4:	f200 808b 	bhi.w	10ee <set_arm_clock+0x23e>
	if (mult < 54) mult = 54;
     fd8:	2b35      	cmp	r3, #53	; 0x35
     fda:	f200 808f 	bhi.w	10fc <set_arm_clock+0x24c>
     fde:	f8df 8188 	ldr.w	r8, [pc, #392]	; 1168 <set_arm_clock+0x2b8>
     fe2:	2336      	movs	r3, #54	; 0x36
     fe4:	4856      	ldr	r0, [pc, #344]	; (1140 <set_arm_clock+0x290>)

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
     fe6:	f8df c144 	ldr.w	ip, [pc, #324]	; 112c <set_arm_clock+0x27c>
     fea:	4c56      	ldr	r4, [pc, #344]	; (1144 <set_arm_clock+0x294>)
     fec:	f8dc 9000 	ldr.w	r9, [ip]
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
     ff0:	fbb0 f0f2 	udiv	r0, r0, r2

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
     ff4:	ea09 0404 	and.w	r4, r9, r4
     ff8:	4544      	cmp	r4, r8
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
     ffa:	fbb0 f0f1 	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
     ffe:	d00b      	beq.n	1018 <set_arm_clock+0x168>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    1000:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    1004:	f44f 5880 	mov.w	r8, #4096	; 0x1000
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    1008:	4664      	mov	r4, ip
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    100a:	f8cc 8000 	str.w	r8, [ip]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    100e:	f8cc 3000 	str.w	r3, [ip]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    1012:	6823      	ldr	r3, [r4, #0]
    1014:	2b00      	cmp	r3, #0
    1016:	dafc      	bge.n	1012 <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    1018:	f8df c0f4 	ldr.w	ip, [pc, #244]	; 1110 <set_arm_clock+0x260>
    101c:	3a01      	subs	r2, #1
    101e:	f8dc 3010 	ldr.w	r3, [ip, #16]
    1022:	f003 0307 	and.w	r3, r3, #7
    1026:	4293      	cmp	r3, r2
    1028:	d007      	beq.n	103a <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    102a:	f002 0207 	and.w	r2, r2, #7
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    102e:	4664      	mov	r4, ip
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    1030:	f8cc 2010 	str.w	r2, [ip, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    1034:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1036:	03db      	lsls	r3, r3, #15
    1038:	d4fc      	bmi.n	1034 <set_arm_clock+0x184>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    103a:	3901      	subs	r1, #1
    103c:	0289      	lsls	r1, r1, #10
    103e:	ea8e 0301 	eor.w	r3, lr, r1
    1042:	f413 5fe0 	tst.w	r3, #7168	; 0x1c00
    1046:	d00c      	beq.n	1062 <set_arm_clock+0x1b2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
		CCM_CBCDR = cbcdr;
    1048:	4b31      	ldr	r3, [pc, #196]	; (1110 <set_arm_clock+0x260>)
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    104a:	f42e 5ee0 	bic.w	lr, lr, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    104e:	f401 51e0 	and.w	r1, r1, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    1052:	461a      	mov	r2, r3
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    1054:	ea41 0e0e 	orr.w	lr, r1, lr
		CCM_CBCDR = cbcdr;
    1058:	f8c3 e014 	str.w	lr, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    105c:	6c93      	ldr	r3, [r2, #72]	; 0x48
    105e:	0799      	lsls	r1, r3, #30
    1060:	d4fc      	bmi.n	105c <set_arm_clock+0x1ac>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    1062:	4b39      	ldr	r3, [pc, #228]	; (1148 <set_arm_clock+0x298>)
    1064:	4939      	ldr	r1, [pc, #228]	; (114c <set_arm_clock+0x29c>)
    1066:	4403      	add	r3, r0
    1068:	09db      	lsrs	r3, r3, #7
    106a:	fba1 3103 	umull	r3, r1, r1, r3
    106e:	0b09      	lsrs	r1, r1, #12
    1070:	2904      	cmp	r1, #4
    1072:	bf28      	it	cs
    1074:	2104      	movcs	r1, #4
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    1076:	1e4b      	subs	r3, r1, #1
    1078:	021b      	lsls	r3, r3, #8
    107a:	ea8e 0203 	eor.w	r2, lr, r3
    107e:	f412 7f40 	tst.w	r2, #768	; 0x300
    1082:	d007      	beq.n	1094 <set_arm_clock+0x1e4>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    1084:	f42e 7e40 	bic.w	lr, lr, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    1088:	f403 7340 	and.w	r3, r3, #768	; 0x300
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    108c:	4a20      	ldr	r2, [pc, #128]	; (1110 <set_arm_clock+0x260>)

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    108e:	ea43 030e 	orr.w	r3, r3, lr
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    1092:	6153      	str	r3, [r2, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    1094:	4b1e      	ldr	r3, [pc, #120]	; (1110 <set_arm_clock+0x260>)
    1096:	695c      	ldr	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    1098:	461a      	mov	r2, r3
		CCM_CBCDR = cbcdr;
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    109a:	f024 7400 	bic.w	r4, r4, #33554432	; 0x2000000
    109e:	615c      	str	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    10a0:	6c93      	ldr	r3, [r2, #72]	; 0x48
    10a2:	069b      	lsls	r3, r3, #26
    10a4:	d4fc      	bmi.n	10a0 <set_arm_clock+0x1f0>

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    10a6:	4b2a      	ldr	r3, [pc, #168]	; (1150 <set_arm_clock+0x2a0>)
    10a8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    10ac:	4c29      	ldr	r4, [pc, #164]	; (1154 <set_arm_clock+0x2a4>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    10ae:	42bd      	cmp	r5, r7
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    10b0:	fba3 e300 	umull	lr, r3, r3, r0
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    10b4:	6020      	str	r0, [r4, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    10b6:	ea4f 4393 	mov.w	r3, r3, lsr #18
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    10ba:	4c27      	ldr	r4, [pc, #156]	; (1158 <set_arm_clock+0x2a8>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    10bc:	fbb2 f3f3 	udiv	r3, r2, r3
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    10c0:	fbb0 f1f1 	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    10c4:	4a25      	ldr	r2, [pc, #148]	; (115c <set_arm_clock+0x2ac>)
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    10c6:	6021      	str	r1, [r4, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    10c8:	6013      	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    10ca:	d208      	bcs.n	10de <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    10cc:	4b11      	ldr	r3, [pc, #68]	; (1114 <set_arm_clock+0x264>)
	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    10ce:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    10d2:	461a      	mov	r2, r3

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    10d4:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
    10d6:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    10d8:	6813      	ldr	r3, [r2, #0]
    10da:	2b00      	cmp	r3, #0
    10dc:	dafc      	bge.n	10d8 <set_arm_clock+0x228>
	}

	return frequency;
}
    10de:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
		if (div_arm < 8) {
			div_arm = div_arm + 1;
		} else {
			if (div_ahb < 5) {
    10e2:	2904      	cmp	r1, #4
    10e4:	f63f af6f 	bhi.w	fc6 <set_arm_clock+0x116>
				div_ahb = div_ahb + 1;
    10e8:	3101      	adds	r1, #1
				div_arm = 1;
    10ea:	2201      	movs	r2, #1
    10ec:	e75b      	b.n	fa6 <set_arm_clock+0xf6>
    10ee:	f8df 807c 	ldr.w	r8, [pc, #124]	; 116c <set_arm_clock+0x2bc>
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
    10f2:	236c      	movs	r3, #108	; 0x6c
    10f4:	481a      	ldr	r0, [pc, #104]	; (1160 <set_arm_clock+0x2b0>)
    10f6:	e776      	b.n	fe6 <set_arm_clock+0x136>
    10f8:	2512      	movs	r5, #18
    10fa:	e706      	b.n	f0a <set_arm_clock+0x5a>
    10fc:	4819      	ldr	r0, [pc, #100]	; (1164 <set_arm_clock+0x2b4>)
    10fe:	f8df 8070 	ldr.w	r8, [pc, #112]	; 1170 <set_arm_clock+0x2c0>
    1102:	fb00 f003 	mul.w	r0, r0, r3
    1106:	ea43 0808 	orr.w	r8, r3, r8
    110a:	e76c      	b.n	fe6 <set_arm_clock+0x136>
    110c:	1f78a400 	.word	0x1f78a400
    1110:	400fc000 	.word	0x400fc000
    1114:	40080000 	.word	0x40080000
    1118:	23c34600 	.word	0x23c34600
    111c:	dc3cba00 	.word	0xdc3cba00
    1120:	004cb223 	.word	0x004cb223
    1124:	51eb851f 	.word	0x51eb851f
    1128:	016e3600 	.word	0x016e3600
    112c:	400d8000 	.word	0x400d8000
    1130:	80003040 	.word	0x80003040
    1134:	269fb1ff 	.word	0x269fb1ff
    1138:	005b8d80 	.word	0x005b8d80
    113c:	165e9f81 	.word	0x165e9f81
    1140:	269fb200 	.word	0x269fb200
    1144:	8001307f 	.word	0x8001307f
    1148:	08f0d17f 	.word	0x08f0d17f
    114c:	00e5109f 	.word	0x00e5109f
    1150:	431bde83 	.word	0x431bde83
    1154:	20001430 	.word	0x20001430
    1158:	2000142c 	.word	0x2000142c
    115c:	20002738 	.word	0x20002738
    1160:	4d3f6400 	.word	0x4d3f6400
    1164:	00b71b00 	.word	0x00b71b00
    1168:	80002036 	.word	0x80002036
    116c:	8000206c 	.word	0x8000206c
    1170:	80002000 	.word	0x80002000

00001174 <delay>:
// or delayNanoseconds().
void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
    1174:	2800      	cmp	r0, #0
    1176:	d057      	beq.n	1228 <delay+0xb4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    1178:	2201      	movs	r2, #1
// active, but the rest of your program becomes effectively stalled.  Usually
// delay() is used in very simple programs.  To achieve delay without waiting
// use millis() or elapsedMillis.  For shorter delay, use delayMicroseconds()
// or delayNanoseconds().
void delay(uint32_t msec)
{
    117a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    117e:	b085      	sub	sp, #20
    1180:	4683      	mov	fp, r0
    1182:	4c2a      	ldr	r4, [pc, #168]	; (122c <delay+0xb8>)
    1184:	4d2a      	ldr	r5, [pc, #168]	; (1230 <delay+0xbc>)
    1186:	4e2b      	ldr	r6, [pc, #172]	; (1234 <delay+0xc0>)
    1188:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    118c:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    1190:	6828      	ldr	r0, [r5, #0]
		scc = systick_cycle_count;
    1192:	6833      	ldr	r3, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    1194:	e844 2100 	strex	r1, r2, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    1198:	2900      	cmp	r1, #0
    119a:	d1f7      	bne.n	118c <delay+0x18>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    119c:	4f26      	ldr	r7, [pc, #152]	; (1238 <delay+0xc4>)
    119e:	e9cd 8902 	strd	r8, r9, [sp, #8]
    11a2:	683a      	ldr	r2, [r7, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    11a4:	1ad3      	subs	r3, r2, r3
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    11a6:	4a25      	ldr	r2, [pc, #148]	; (123c <delay+0xc8>)
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    11a8:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    11ac:	9701      	str	r7, [sp, #4]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    11ae:	6812      	ldr	r2, [r2, #0]
    11b0:	2701      	movs	r7, #1
    11b2:	fba3 2302 	umull	r2, r3, r3, r2
	if (frac > 1000) frac = 1000;
    11b6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    11ba:	4698      	mov	r8, r3
	if (frac > 1000) frac = 1000;
    11bc:	2300      	movs	r3, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    11be:	428b      	cmp	r3, r1
    11c0:	bf08      	it	eq
    11c2:	4542      	cmpeq	r2, r8
    11c4:	bf2c      	ite	cs
    11c6:	46c2      	movcs	sl, r8
    11c8:	46f2      	movcc	sl, lr
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    11ca:	fb0e aa00 	mla	sl, lr, r0, sl
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    11ce:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    11d2:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    11d4:	6831      	ldr	r1, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    11d6:	e844 7300 	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    11da:	2b00      	cmp	r3, #0
    11dc:	d1f7      	bne.n	11ce <delay+0x5a>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    11de:	9801      	ldr	r0, [sp, #4]
    11e0:	6800      	ldr	r0, [r0, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    11e2:	1a41      	subs	r1, r0, r1
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    11e4:	4815      	ldr	r0, [pc, #84]	; (123c <delay+0xc8>)
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    11e6:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    11ea:	6800      	ldr	r0, [r0, #0]
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    11ec:	fb0e f202 	mul.w	r2, lr, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    11f0:	fba1 0100 	umull	r0, r1, r1, r0
	if (frac > 1000) frac = 1000;
    11f4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    11f8:	ebca 0202 	rsb	r2, sl, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    11fc:	4688      	mov	r8, r1
	if (frac > 1000) frac = 1000;
    11fe:	2100      	movs	r1, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1200:	4299      	cmp	r1, r3
    1202:	bf08      	it	eq
    1204:	4540      	cmpeq	r0, r8
    1206:	bf2c      	ite	cs
    1208:	4643      	movcs	r3, r8
    120a:	4673      	movcc	r3, lr
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    120c:	441a      	add	r2, r3
    120e:	4572      	cmp	r2, lr
    1210:	d307      	bcc.n	1222 <delay+0xae>
			if (--msec == 0) return;
    1212:	f1bb 0b01 	subs.w	fp, fp, #1
			start += 1000;
    1216:	f50a 7a7a 	add.w	sl, sl, #1000	; 0x3e8

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
    121a:	d1d8      	bne.n	11ce <delay+0x5a>
			start += 1000;
		}
		yield();
	}
	// TODO...
}
    121c:	b005      	add	sp, #20
    121e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
    1222:	f001 fc09 	bl	2a38 <yield>
	}
    1226:	e7d2      	b.n	11ce <delay+0x5a>
    1228:	4770      	bx	lr
    122a:	bf00      	nop
    122c:	200027a0 	.word	0x200027a0
    1230:	20002740 	.word	0x20002740
    1234:	2000273c 	.word	0x2000273c
    1238:	e0001004 	.word	0xe0001004
    123c:	20002738 	.word	0x20002738

00001240 <digitalWrite.part.0>:
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    1240:	0100      	lsls	r0, r0, #4
    1242:	4b0f      	ldr	r3, [pc, #60]	; (1280 <digitalWrite.part.0+0x40>)
    1244:	181a      	adds	r2, r3, r0
	pinmode = *(p->reg + 1);
    1246:	581b      	ldr	r3, [r3, r0]
	{&CORE_PIN53_PORTREG, &CORE_PIN53_CONFIG, &CORE_PIN53_PADCONFIG, CORE_PIN53_BITMASK},
	{&CORE_PIN54_PORTREG, &CORE_PIN54_CONFIG, &CORE_PIN54_PADCONFIG, CORE_PIN54_BITMASK},
#endif
};

void digitalWrite(uint8_t pin, uint8_t val)
    1248:	b410      	push	{r4}
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
	mask = p->mask;
    124a:	68d0      	ldr	r0, [r2, #12]
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
    124c:	685c      	ldr	r4, [r3, #4]
	mask = p->mask;
	if (pinmode & mask) {
    124e:	4204      	tst	r4, r0
    1250:	d005      	beq.n	125e <digitalWrite.part.0+0x1e>
		// pin is configured for output mode
		if (val) {
    1252:	b159      	cbz	r1, 126c <digitalWrite.part.0+0x2c>
			*(p->reg + 0x21) = mask; // set register
    1254:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    1258:	f85d 4b04 	ldr.w	r4, [sp], #4
    125c:	4770      	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    125e:	6893      	ldr	r3, [r2, #8]
			*(p->reg + 0x22) = mask; // clear register
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
    1260:	b949      	cbnz	r1, 1276 <digitalWrite.part.0+0x36>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    1262:	4a08      	ldr	r2, [pc, #32]	; (1284 <digitalWrite.part.0+0x44>)
		}
	}
}
    1264:	f85d 4b04 	ldr.w	r4, [sp], #4
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    1268:	601a      	str	r2, [r3, #0]
		}
	}
}
    126a:	4770      	bx	lr
	if (pinmode & mask) {
		// pin is configured for output mode
		if (val) {
			*(p->reg + 0x21) = mask; // set register
		} else {
			*(p->reg + 0x22) = mask; // clear register
    126c:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    1270:	f85d 4b04 	ldr.w	r4, [sp], #4
    1274:	4770      	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    1276:	4a04      	ldr	r2, [pc, #16]	; (1288 <digitalWrite.part.0+0x48>)
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    1278:	f85d 4b04 	ldr.w	r4, [sp], #4
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    127c:	601a      	str	r2, [r3, #0]
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    127e:	4770      	bx	lr
    1280:	200006dc 	.word	0x200006dc
    1284:	00013038 	.word	0x00013038
    1288:	0001f038 	.word	0x0001f038

0000128c <digitalRead.part.1>:
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    128c:	0100      	lsls	r0, r0, #4
    128e:	4b05      	ldr	r3, [pc, #20]	; (12a4 <digitalRead.part.1+0x18>)
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    1290:	581a      	ldr	r2, [r3, r0]
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    1292:	1819      	adds	r1, r3, r0
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    1294:	6892      	ldr	r2, [r2, #8]
    1296:	68cb      	ldr	r3, [r1, #12]
    1298:	421a      	tst	r2, r3
}
    129a:	bf14      	ite	ne
    129c:	2001      	movne	r0, #1
    129e:	2000      	moveq	r0, #0
    12a0:	4770      	bx	lr
    12a2:	bf00      	nop
    12a4:	200006dc 	.word	0x200006dc

000012a8 <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    12a8:	2836      	cmp	r0, #54	; 0x36
    12aa:	d801      	bhi.n	12b0 <digitalWrite+0x8>
    12ac:	f7ff bfc8 	b.w	1240 <digitalWrite.part.0>
    12b0:	4770      	bx	lr
    12b2:	bf00      	nop

000012b4 <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    12b4:	2836      	cmp	r0, #54	; 0x36
    12b6:	d801      	bhi.n	12bc <digitalRead+0x8>
    12b8:	f7ff bfe8 	b.w	128c <digitalRead.part.1>
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}
    12bc:	2000      	movs	r0, #0
    12be:	4770      	bx	lr

000012c0 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    12c0:	b4f0      	push	{r4, r5, r6, r7}
    12c2:	1e4e      	subs	r6, r1, #1
	unsigned digit;
	int i=0, j;
    12c4:	2500      	movs	r5, #0
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    12c6:	4637      	mov	r7, r6
    12c8:	e000      	b.n	12cc <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    12ca:	3501      	adds	r5, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    12cc:	fbb0 f3f2 	udiv	r3, r0, r2
    12d0:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    12d4:	f100 0437 	add.w	r4, r0, #55	; 0x37
    12d8:	2809      	cmp	r0, #9
    12da:	f100 0030 	add.w	r0, r0, #48	; 0x30
    12de:	b2e4      	uxtb	r4, r4
    12e0:	bf98      	it	ls
    12e2:	b2c4      	uxtbls	r4, r0
		val /= radix;
		if (val == 0) break;
    12e4:	4618      	mov	r0, r3
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    12e6:	f807 4f01 	strb.w	r4, [r7, #1]!
		val /= radix;
		if (val == 0) break;
    12ea:	2b00      	cmp	r3, #0
    12ec:	d1ed      	bne.n	12ca <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    12ee:	194a      	adds	r2, r1, r5
    12f0:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    12f2:	b14d      	cbz	r5, 1308 <ultoa+0x48>
    12f4:	3301      	adds	r3, #1
		t = buf[j];
    12f6:	f816 4f01 	ldrb.w	r4, [r6, #1]!
		buf[j] = buf[i];
    12fa:	7817      	ldrb	r7, [r2, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    12fc:	1ae8      	subs	r0, r5, r3
		t = buf[j];
		buf[j] = buf[i];
    12fe:	7037      	strb	r7, [r6, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    1300:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    1302:	f802 4901 	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    1306:	dbf5      	blt.n	12f4 <ultoa+0x34>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    1308:	4608      	mov	r0, r1
    130a:	bcf0      	pop	{r4, r5, r6, r7}
    130c:	4770      	bx	lr
    130e:	bf00      	nop

00001310 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    1310:	48a4      	ldr	r0, [pc, #656]	; (15a4 <pwm_init+0x294>)
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1312:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1316:	4ba4      	ldr	r3, [pc, #656]	; (15a8 <pwm_init+0x298>)
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    1318:	6f82      	ldr	r2, [r0, #120]	; 0x78
    131a:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}

void pwm_init(void)
{
    131e:	b5f0      	push	{r4, r5, r6, r7, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    1320:	6782      	str	r2, [r0, #120]	; 0x78
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    1322:	2500      	movs	r5, #0
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    1324:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1328:	f44f 4670 	mov.w	r6, #61440	; 0xf000
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    132c:	4c9f      	ldr	r4, [pc, #636]	; (15ac <pwm_init+0x29c>)
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    132e:	f44f 4e60 	mov.w	lr, #57344	; 0xe000

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1332:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1334:	f44f 6780 	mov.w	r7, #1024	; 0x400
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    1338:	4314      	orrs	r4, r2
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    133a:	462a      	mov	r2, r5
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    133c:	f8c0 4080 	str.w	r4, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1340:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    1344:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1348:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    134c:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1350:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    1354:	b280      	uxth	r0, r0
    1356:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    135a:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    135e:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    1362:	4b91      	ldr	r3, [pc, #580]	; (15a8 <pwm_init+0x298>)
	for (i=0; i < 4; i++) {
    1364:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1366:	2500      	movs	r5, #0
    1368:	0140      	lsls	r0, r0, #5
    136a:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    136c:	2904      	cmp	r1, #4
    136e:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1370:	f8a3 e004 	strh.w	lr, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1374:	80df      	strh	r7, [r3, #6]
		p->SM[i].OCTRL = 0;
    1376:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1378:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    137a:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    137c:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    137e:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    1380:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    1382:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1384:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    1386:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1388:	d1e9      	bne.n	135e <pwm_init+0x4e>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    138a:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    138e:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1392:	4b87      	ldr	r3, [pc, #540]	; (15b0 <pwm_init+0x2a0>)
    1394:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1398:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    139a:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    139c:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    13a0:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    13a2:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    13a6:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    13aa:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    13ae:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    13b2:	b280      	uxth	r0, r0
    13b4:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    13b8:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    13bc:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    13c0:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    13c4:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    13c8:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    13cc:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    13d0:	b280      	uxth	r0, r0
    13d2:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    13d6:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    13da:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    13de:	4b74      	ldr	r3, [pc, #464]	; (15b0 <pwm_init+0x2a0>)
	for (i=0; i < 4; i++) {
    13e0:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    13e2:	2500      	movs	r5, #0
    13e4:	0140      	lsls	r0, r0, #5
    13e6:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    13e8:	2904      	cmp	r1, #4
    13ea:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    13ec:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    13ee:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    13f2:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    13f4:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    13f6:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    13f8:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    13fa:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    13fc:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    13fe:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1400:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    1402:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1404:	d1e9      	bne.n	13da <pwm_init+0xca>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1406:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    140a:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    140e:	4b69      	ldr	r3, [pc, #420]	; (15b4 <pwm_init+0x2a4>)
    1410:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1414:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1416:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1418:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    141c:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    141e:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1422:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1426:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    142a:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    142e:	b280      	uxth	r0, r0
    1430:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    1434:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1438:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    143c:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1440:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    1444:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1448:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    144c:	b280      	uxth	r0, r0
    144e:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1452:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    1456:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    145a:	4b56      	ldr	r3, [pc, #344]	; (15b4 <pwm_init+0x2a4>)
	for (i=0; i < 4; i++) {
    145c:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    145e:	2500      	movs	r5, #0
    1460:	0140      	lsls	r0, r0, #5
    1462:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1464:	2904      	cmp	r1, #4
    1466:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1468:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    146a:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    146e:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1470:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    1472:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    1474:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    1476:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    1478:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    147a:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    147c:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    147e:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1480:	d1e9      	bne.n	1456 <pwm_init+0x146>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1482:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1486:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    148a:	4b4b      	ldr	r3, [pc, #300]	; (15b8 <pwm_init+0x2a8>)
    148c:	f44f 4770 	mov.w	r7, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1490:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1492:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1494:	f44f 4660 	mov.w	r6, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1498:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    149a:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    149e:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    14a2:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    14a6:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    14aa:	b280      	uxth	r0, r0
    14ac:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    14b0:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    14b4:	f8a3 718c 	strh.w	r7, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    14b8:	f248 27b8 	movw	r7, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    14bc:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    14c0:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    14c4:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    14c8:	b280      	uxth	r0, r0
    14ca:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    14ce:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    14d2:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    14d6:	4b38      	ldr	r3, [pc, #224]	; (15b8 <pwm_init+0x2a8>)
	for (i=0; i < 4; i++) {
    14d8:	3101      	adds	r1, #1
    14da:	0140      	lsls	r0, r0, #5
    14dc:	461c      	mov	r4, r3
    14de:	2904      	cmp	r1, #4
    14e0:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    14e2:	809e      	strh	r6, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    14e4:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    14e8:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    14ea:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    14ec:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    14ee:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    14f0:	81df      	strh	r7, [r3, #14]
		p->SM[i].VAL2 = 0;
    14f2:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    14f4:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    14f6:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    14f8:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    14fa:	d1ea      	bne.n	14d2 <pwm_init+0x1c2>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    14fc:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1500:	270f      	movs	r7, #15

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1502:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1504:	f241 0601 	movw	r6, #4097	; 0x1001
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1508:	b29b      	uxth	r3, r3
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    150a:	f645 5ec0 	movw	lr, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    150e:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1510:	f243 0526 	movw	r5, #12326	; 0x3026
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1514:	433b      	orrs	r3, r7
    1516:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    151a:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
    151e:	b29b      	uxth	r3, r3
    1520:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
    1524:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1528:	0150      	lsls	r0, r2, #5
    152a:	4b24      	ldr	r3, [pc, #144]	; (15bc <pwm_init+0x2ac>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    152c:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    152e:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1530:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    1532:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    1534:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1536:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1538:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    153a:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    153e:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    1540:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1542:	819d      	strh	r5, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1544:	d1f0      	bne.n	1528 <pwm_init+0x218>
    1546:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1548:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    154a:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    154e:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1552:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1554:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1558:	0150      	lsls	r0, r2, #5
    155a:	4b19      	ldr	r3, [pc, #100]	; (15c0 <pwm_init+0x2b0>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    155c:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    155e:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1560:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    1562:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    1564:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1566:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1568:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    156a:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    156c:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    156e:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1570:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1572:	d1f1      	bne.n	1558 <pwm_init+0x248>
    1574:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1576:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1578:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    157c:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1580:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1582:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1586:	0150      	lsls	r0, r2, #5
    1588:	4b0e      	ldr	r3, [pc, #56]	; (15c4 <pwm_init+0x2b4>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    158a:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    158c:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    158e:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    1590:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    1592:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1594:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1596:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1598:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    159a:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    159c:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    159e:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    15a0:	d1f1      	bne.n	1586 <pwm_init+0x276>
	flexpwm_init(&IMXRT_FLEXPWM3);
	flexpwm_init(&IMXRT_FLEXPWM4);
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    15a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    15a4:	400fc000 	.word	0x400fc000
    15a8:	403dc000 	.word	0x403dc000
    15ac:	fc030000 	.word	0xfc030000
    15b0:	403e0000 	.word	0x403e0000
    15b4:	403e4000 	.word	0x403e4000
    15b8:	403e8000 	.word	0x403e8000
    15bc:	401dc000 	.word	0x401dc000
    15c0:	401e0000 	.word	0x401e0000
    15c4:	401e4000 	.word	0x401e4000

000015c8 <rtc_get>:
#include "debug/printf.h"


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
    15c8:	4b0a      	ldr	r3, [pc, #40]	; (15f4 <rtc_get+0x2c>)
#include "imxrt.h"
#include "debug/printf.h"


unsigned long rtc_get(void)
{
    15ca:	b430      	push	{r4, r5}
	uint32_t hi1 = SNVS_HPRTCMR;
    15cc:	6a58      	ldr	r0, [r3, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    15ce:	461c      	mov	r4, r3


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
    15d0:	6a99      	ldr	r1, [r3, #40]	; 0x28
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    15d2:	6a62      	ldr	r2, [r4, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
    15d4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
    15d6:	4299      	cmp	r1, r3
    15d8:	bf08      	it	eq
    15da:	4290      	cmpeq	r0, r2
unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    15dc:	4610      	mov	r0, r2
		uint32_t lo2 = SNVS_HPRTCLR;
    15de:	4619      	mov	r1, r3
		if (lo1 == lo2 && hi1 == hi2) {
    15e0:	bf0c      	ite	eq
    15e2:	2501      	moveq	r5, #1
    15e4:	2500      	movne	r5, #0
    15e6:	2d00      	cmp	r5, #0
    15e8:	d0f3      	beq.n	15d2 <rtc_get+0xa>
			return (hi2 << 17) | (lo2 >> 15);
    15ea:	0bd9      	lsrs	r1, r3, #15
		}
		hi1 = hi2;
		lo1 = lo2;
	}
}
    15ec:	bc30      	pop	{r4, r5}
    15ee:	ea41 4042 	orr.w	r0, r1, r2, lsl #17
    15f2:	4770      	bx	lr
    15f4:	400d4000 	.word	0x400d4000

000015f8 <sm_align_pool>:
	if (spool->pool_size % HEADER_SZ) return 0;
	return 1;
}

int sm_align_pool(struct smalloc_pool *spool)
{
    15f8:	b508      	push	{r3, lr}

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    15fa:	6803      	ldr	r3, [r0, #0]
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    15fc:	6842      	ldr	r2, [r0, #4]

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    15fe:	b1bb      	cbz	r3, 1630 <sm_align_pool+0x38>
    1600:	b17a      	cbz	r2, 1622 <sm_align_pool+0x2a>
	if (spool->pool_size % HEADER_SZ) return 0;
    1602:	4b10      	ldr	r3, [pc, #64]	; (1644 <sm_align_pool+0x4c>)
    1604:	fba3 1302 	umull	r1, r3, r3, r2
    1608:	08db      	lsrs	r3, r3, #3
    160a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    160e:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
    1612:	d003      	beq.n	161c <sm_align_pool+0x24>
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
    1614:	1ad2      	subs	r2, r2, r3
    1616:	6042      	str	r2, [r0, #4]
	if (spool->pool_size <= MIN_POOL_SZ) {
    1618:	2af0      	cmp	r2, #240	; 0xf0
    161a:	d902      	bls.n	1622 <sm_align_pool+0x2a>

int sm_align_pool(struct smalloc_pool *spool)
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;
    161c:	2301      	movs	r3, #1
		errno = ENOSPC;
		return 0;
	}

	return 1;
}
    161e:	4618      	mov	r0, r3
    1620:	bd08      	pop	{r3, pc}
	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
	if (spool->pool_size <= MIN_POOL_SZ) {
		errno = ENOSPC;
    1622:	f004 fc81 	bl	5f28 <__errno>
    1626:	221c      	movs	r2, #28
    1628:	2300      	movs	r3, #0
    162a:	6002      	str	r2, [r0, #0]
		return 0;
	}

	return 1;
}
    162c:	4618      	mov	r0, r3
    162e:	bd08      	pop	{r3, pc}
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    1630:	4b04      	ldr	r3, [pc, #16]	; (1644 <sm_align_pool+0x4c>)
    1632:	fba3 1302 	umull	r1, r3, r3, r2
    1636:	08db      	lsrs	r3, r3, #3
    1638:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (x) spool->pool_size -= x;
    163c:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
    1640:	d1e8      	bne.n	1614 <sm_align_pool+0x1c>
    1642:	e7e9      	b.n	1618 <sm_align_pool+0x20>
    1644:	aaaaaaab 	.word	0xaaaaaaab

00001648 <sm_set_pool>:

	return 1;
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
    1648:	b570      	push	{r4, r5, r6, lr}
	if (!spool) {
    164a:	4604      	mov	r4, r0
    164c:	2800      	cmp	r0, #0
    164e:	d03a      	beq.n	16c6 <sm_set_pool+0x7e>
		errno = EINVAL;
		return 0;
	}

	if (!new_pool || !new_pool_size) {
    1650:	b119      	cbz	r1, 165a <sm_set_pool+0x12>
    1652:	fab2 f582 	clz	r5, r2
    1656:	096d      	lsrs	r5, r5, #5
    1658:	b1fd      	cbz	r5, 169a <sm_set_pool+0x52>

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    165a:	6820      	ldr	r0, [r4, #0]
    165c:	b108      	cbz	r0, 1662 <sm_set_pool+0x1a>
    165e:	6862      	ldr	r2, [r4, #4]
    1660:	b932      	cbnz	r2, 1670 <sm_set_pool+0x28>
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    1662:	f004 fc61 	bl	5f28 <__errno>
    1666:	2316      	movs	r3, #22
		return 0;
    1668:	2200      	movs	r2, #0
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    166a:	6003      	str	r3, [r0, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    166c:	4610      	mov	r0, r2
    166e:	bd70      	pop	{r4, r5, r6, pc}
struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
	if (spool->pool_size % HEADER_SZ) return 0;
    1670:	4918      	ldr	r1, [pc, #96]	; (16d4 <sm_set_pool+0x8c>)
    1672:	fba1 3102 	umull	r3, r1, r1, r2
    1676:	08c9      	lsrs	r1, r1, #3
    1678:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    167c:	ebb2 0181 	subs.w	r1, r2, r1, lsl #2
    1680:	d1ef      	bne.n	1662 <sm_set_pool+0x1a>
		return 0;
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
    1682:	68a3      	ldr	r3, [r4, #8]
    1684:	b10b      	cbz	r3, 168a <sm_set_pool+0x42>
    1686:	f005 f869 	bl	675c <memset>
			memset(spool, 0, sizeof(struct smalloc_pool));
    168a:	2300      	movs	r3, #0
			return 1;
    168c:	2201      	movs	r2, #1
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    168e:	6023      	str	r3, [r4, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1690:	4610      	mov	r0, r2
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    1692:	6063      	str	r3, [r4, #4]
    1694:	60a3      	str	r3, [r4, #8]
    1696:	60e3      	str	r3, [r4, #12]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1698:	bd70      	pop	{r4, r5, r6, pc}
    169a:	461e      	mov	r6, r3
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
    169c:	9b04      	ldr	r3, [sp, #16]
		errno = EINVAL;
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
    169e:	e880 0006 	stmia.w	r0, {r1, r2}
	spool->oomfn = oom_handler;
    16a2:	60c3      	str	r3, [r0, #12]
	if (!sm_align_pool(spool)) return 0;
    16a4:	f7ff ffa8 	bl	15f8 <sm_align_pool>
    16a8:	4602      	mov	r2, r0
    16aa:	2800      	cmp	r0, #0
    16ac:	d0de      	beq.n	166c <sm_set_pool+0x24>

	if (do_zero) {
    16ae:	b916      	cbnz	r6, 16b6 <sm_set_pool+0x6e>
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
    16b0:	2201      	movs	r2, #1
}
    16b2:	4610      	mov	r0, r2
    16b4:	bd70      	pop	{r4, r5, r6, pc}
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
    16b6:	e894 0005 	ldmia.w	r4, {r0, r2}
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
    16ba:	60a6      	str	r6, [r4, #8]
		memset(spool->pool, 0, spool->pool_size);
    16bc:	4629      	mov	r1, r5
    16be:	f005 f84d 	bl	675c <memset>
	}

	return 1;
    16c2:	2201      	movs	r2, #1
    16c4:	e7d2      	b.n	166c <sm_set_pool+0x24>
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    16c6:	f004 fc2f 	bl	5f28 <__errno>
    16ca:	2316      	movs	r3, #22
		return 0;
    16cc:	4622      	mov	r2, r4
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    16ce:	6003      	str	r3, [r0, #0]
		return 0;
    16d0:	e7cc      	b.n	166c <sm_set_pool+0x24>
    16d2:	bf00      	nop
    16d4:	aaaaaaab 	.word	0xaaaaaaab

000016d8 <unused_interrupt_vector>:
	const uint32_t *stack;
	struct arm_fault_info_struct *info;
	const uint32_t *p, *end;

	// disallow any nested interrupts
	__disable_irq();
    16d8:	b672      	cpsid	i
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
    16da:	f3ef 8305 	mrs	r3, IPSR
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
    16de:	4d49      	ldr	r5, [pc, #292]	; (1804 <unused_interrupt_vector+0x12c>)
    16e0:	606b      	str	r3, [r5, #4]
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
    16e2:	f3ef 8308 	mrs	r3, MSP
	info->cfsr = SCB_CFSR;
    16e6:	4c48      	ldr	r4, [pc, #288]	; (1808 <unused_interrupt_vector+0x130>)
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
	info->len = sizeof(*info) / 4;
    16e8:	462e      	mov	r6, r5
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
    16ea:	4848      	ldr	r0, [pc, #288]	; (180c <unused_interrupt_vector+0x134>)
	info->mmfar = SCB_MMFAR;
    16ec:	4948      	ldr	r1, [pc, #288]	; (1810 <unused_interrupt_vector+0x138>)
	info->bfar = SCB_BFAR;
    16ee:	4a49      	ldr	r2, [pc, #292]	; (1814 <unused_interrupt_vector+0x13c>)
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    16f0:	6824      	ldr	r4, [r4, #0]
	info->hfsr = SCB_HFSR;
    16f2:	6800      	ldr	r0, [r0, #0]
	info->mmfar = SCB_MMFAR;
    16f4:	6809      	ldr	r1, [r1, #0]
	info->bfar = SCB_BFAR;
    16f6:	6812      	ldr	r2, [r2, #0]
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
    16f8:	6129      	str	r1, [r5, #16]
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    16fa:	60ac      	str	r4, [r5, #8]
	info->hfsr = SCB_HFSR;
    16fc:	60e8      	str	r0, [r5, #12]
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
    16fe:	616a      	str	r2, [r5, #20]
	info->ret = stack[6];
    1700:	699a      	ldr	r2, [r3, #24]
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    1702:	4c45      	ldr	r4, [pc, #276]	; (1818 <unused_interrupt_vector+0x140>)
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
    1704:	61aa      	str	r2, [r5, #24]
	info->xpsr = stack[7];
    1706:	69db      	ldr	r3, [r3, #28]
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    1708:	4f44      	ldr	r7, [pc, #272]	; (181c <unused_interrupt_vector+0x144>)
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
    170a:	61eb      	str	r3, [r5, #28]
	info->temp = tempmonGetTemp();
    170c:	f000 f8c8 	bl	18a0 <tempmonGetTemp>
    1710:	ed85 0a08 	vstr	s0, [r5, #32]
	info->time = rtc_get();
    1714:	f7ff ff58 	bl	15c8 <rtc_get>
	info->len = sizeof(*info) / 4;
    1718:	230b      	movs	r3, #11
	// add CRC to crash report
	crc = 0xFFFFFFFF;
    171a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
    171e:	6268      	str	r0, [r5, #36]	; 0x24
	info->len = sizeof(*info) / 4;
    1720:	4619      	mov	r1, r3
    1722:	602b      	str	r3, [r5, #0]
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
    1724:	404a      	eors	r2, r1
    1726:	2120      	movs	r1, #32
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    1728:	f002 0301 	and.w	r3, r2, #1
    172c:	3901      	subs	r1, #1
    172e:	fb04 f303 	mul.w	r3, r4, r3
    1732:	ea83 0252 	eor.w	r2, r3, r2, lsr #1
    1736:	d1f7      	bne.n	1728 <unused_interrupt_vector+0x50>
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    1738:	42be      	cmp	r6, r7
    173a:	d002      	beq.n	1742 <unused_interrupt_vector+0x6a>
    173c:	f856 1f04 	ldr.w	r1, [r6, #4]!
    1740:	e7f0      	b.n	1724 <unused_interrupt_vector+0x4c>
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
	}
	info->crc = crc;
    1742:	4930      	ldr	r1, [pc, #192]	; (1804 <unused_interrupt_vector+0x12c>)
    1744:	628a      	str	r2, [r1, #40]	; 0x28
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    1746:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    174a:	4b35      	ldr	r3, [pc, #212]	; (1820 <unused_interrupt_vector+0x148>)
    174c:	4a35      	ldr	r2, [pc, #212]	; (1824 <unused_interrupt_vector+0x14c>)
    174e:	6019      	str	r1, [r3, #0]
    1750:	601a      	str	r2, [r3, #0]
		location += 32;
	} while (location < end_addr);
	asm("dsb");
    1752:	f3bf 8f4f 	dsb	sy
	asm("isb");
    1756:	f3bf 8f6f 	isb	sy
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    175a:	4a33      	ldr	r2, [pc, #204]	; (1828 <unused_interrupt_vector+0x150>)
	PIT_MCR = PIT_MCR_MDIS;
    175c:	2502      	movs	r5, #2
    175e:	4c33      	ldr	r4, [pc, #204]	; (182c <unused_interrupt_vector+0x154>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1760:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1762:	4933      	ldr	r1, [pc, #204]	; (1830 <unused_interrupt_vector+0x158>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1764:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1768:	4832      	ldr	r0, [pc, #200]	; (1834 <unused_interrupt_vector+0x15c>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    176a:	66d3      	str	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
    176c:	6025      	str	r5, [r4, #0]
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    176e:	69d3      	ldr	r3, [r2, #28]
    1770:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    1774:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1778:	61d3      	str	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    177a:	680b      	ldr	r3, [r1, #0]
    177c:	4283      	cmp	r3, r0
    177e:	d83e      	bhi.n	17fe <unused_interrupt_vector+0x126>
	PIT_MCR = 0;
    1780:	4a2a      	ldr	r2, [pc, #168]	; (182c <unused_interrupt_vector+0x154>)
    1782:	2100      	movs	r1, #0
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    1784:	2001      	movs	r0, #1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    1786:	4e2c      	ldr	r6, [pc, #176]	; (1838 <unused_interrupt_vector+0x160>)
	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
    1788:	6011      	str	r1, [r2, #0]
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    178a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
    178e:	f8c2 1108 	str.w	r1, [r2, #264]	; 0x108
	NVIC_ICER4 = 0xFFFFFFFF;

	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
    1792:	460c      	mov	r4, r1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    1794:	f8c2 6100 	str.w	r6, [r2, #256]	; 0x100
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    1798:	4615      	mov	r5, r2
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    179a:	f8c2 0108 	str.w	r0, [r2, #264]	; 0x108
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    179e:	4607      	mov	r7, r0
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    17a0:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 1864 <unused_interrupt_vector+0x18c>
	NVIC_ICER1 = 0xFFFFFFFF;
    17a4:	4e25      	ldr	r6, [pc, #148]	; (183c <unused_interrupt_vector+0x164>)
	NVIC_ICER2 = 0xFFFFFFFF;
    17a6:	4826      	ldr	r0, [pc, #152]	; (1840 <unused_interrupt_vector+0x168>)
	NVIC_ICER3 = 0xFFFFFFFF;
    17a8:	4926      	ldr	r1, [pc, #152]	; (1844 <unused_interrupt_vector+0x16c>)
	NVIC_ICER4 = 0xFFFFFFFF;
    17aa:	4a27      	ldr	r2, [pc, #156]	; (1848 <unused_interrupt_vector+0x170>)
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    17ac:	f8ce 3000 	str.w	r3, [lr]
	NVIC_ICER1 = 0xFFFFFFFF;
    17b0:	6033      	str	r3, [r6, #0]
	NVIC_ICER2 = 0xFFFFFFFF;
    17b2:	6003      	str	r3, [r0, #0]
	NVIC_ICER3 = 0xFFFFFFFF;
    17b4:	600b      	str	r3, [r1, #0]
	NVIC_ICER4 = 0xFFFFFFFF;
    17b6:	6013      	str	r3, [r2, #0]
    17b8:	e001      	b.n	17be <unused_interrupt_vector+0xe6>
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
		}
		usb_isr();
    17ba:	f000 f955 	bl	1a68 <usb_isr>
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    17be:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
    17c2:	4b1a      	ldr	r3, [pc, #104]	; (182c <unused_interrupt_vector+0x154>)
    17c4:	2a00      	cmp	r2, #0
    17c6:	d0f8      	beq.n	17ba <unused_interrupt_vector+0xe2>
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
    17c8:	3401      	adds	r4, #1
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    17ca:	f8c5 710c 	str.w	r7, [r5, #268]	; 0x10c
			if (++count >= 80) break;  // reboot after 8 seconds
    17ce:	2c4f      	cmp	r4, #79	; 0x4f
    17d0:	d9f3      	bls.n	17ba <unused_interrupt_vector+0xe2>
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    17d2:	4a1e      	ldr	r2, [pc, #120]	; (184c <unused_interrupt_vector+0x174>)
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    17d4:	2402      	movs	r4, #2
    17d6:	481e      	ldr	r0, [pc, #120]	; (1850 <unused_interrupt_vector+0x178>)
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    17d8:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    17dc:	f8c0 4140 	str.w	r4, [r0, #320]	; 0x140
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    17e0:	6351      	str	r1, [r2, #52]	; 0x34
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    17e2:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    17e6:	b932      	cbnz	r2, 17f6 <unused_interrupt_vector+0x11e>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
    17e8:	491a      	ldr	r1, [pc, #104]	; (1854 <unused_interrupt_vector+0x17c>)
    17ea:	4a1b      	ldr	r2, [pc, #108]	; (1858 <unused_interrupt_vector+0x180>)
    17ec:	630a      	str	r2, [r1, #48]	; 0x30
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    17ee:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    17f2:	2800      	cmp	r0, #0
    17f4:	d0fa      	beq.n	17ec <unused_interrupt_vector+0x114>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
	SCB_AIRCR = 0x05FA0004;
    17f6:	4b19      	ldr	r3, [pc, #100]	; (185c <unused_interrupt_vector+0x184>)
    17f8:	4a19      	ldr	r2, [pc, #100]	; (1860 <unused_interrupt_vector+0x188>)
    17fa:	601a      	str	r2, [r3, #0]
    17fc:	e7fe      	b.n	17fc <unused_interrupt_vector+0x124>

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    17fe:	f7ff fb57 	bl	eb0 <set_arm_clock>
    1802:	e7bd      	b.n	1780 <unused_interrupt_vector+0xa8>
    1804:	2027ff80 	.word	0x2027ff80
    1808:	e000ed28 	.word	0xe000ed28
    180c:	e000ed2c 	.word	0xe000ed2c
    1810:	e000ed34 	.word	0xe000ed34
    1814:	e000ed38 	.word	0xe000ed38
    1818:	edb88320 	.word	0xedb88320
    181c:	2027ffa4 	.word	0x2027ffa4
    1820:	e000ef70 	.word	0xe000ef70
    1824:	2027ffa0 	.word	0x2027ffa0
    1828:	400fc000 	.word	0x400fc000
    182c:	40084000 	.word	0x40084000
    1830:	20001430 	.word	0x20001430
    1834:	0bcd3d80 	.word	0x0bcd3d80
    1838:	00249f00 	.word	0x00249f00
    183c:	e000e184 	.word	0xe000e184
    1840:	e000e188 	.word	0xe000e188
    1844:	e000e18c 	.word	0xe000e18c
    1848:	e000e190 	.word	0xe000e190
    184c:	400d9000 	.word	0x400d9000
    1850:	402e0000 	.word	0x402e0000
    1854:	400f8000 	.word	0x400f8000
    1858:	0bad00f1 	.word	0x0bad00f1
    185c:	e000ed0c 	.word	0xe000ed0c
    1860:	05fa0004 	.word	0x05fa0004
    1864:	e000e180 	.word	0xe000e180

00001868 <_sbrk>:

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
        char *prev = __brkval;
    1868:	4a09      	ldr	r2, [pc, #36]	; (1890 <_sbrk+0x28>)
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
    186a:	b508      	push	{r3, lr}
        char *prev = __brkval;
    186c:	6813      	ldr	r3, [r2, #0]
        if (incr != 0) {
    186e:	b120      	cbz	r0, 187a <_sbrk+0x12>
                if (prev + incr > (char *)&_heap_end) {
    1870:	4418      	add	r0, r3
    1872:	4908      	ldr	r1, [pc, #32]	; (1894 <_sbrk+0x2c>)
    1874:	4288      	cmp	r0, r1
    1876:	d802      	bhi.n	187e <_sbrk+0x16>
                        errno = ENOMEM;
                        return (void *)-1;
                }
                __brkval = prev + incr;
    1878:	6010      	str	r0, [r2, #0]
        }
        return prev;
}
    187a:	4618      	mov	r0, r3
    187c:	bd08      	pop	{r3, pc}
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    187e:	f004 fb53 	bl	5f28 <__errno>
    1882:	220c      	movs	r2, #12
                        return (void *)-1;
    1884:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    1888:	6002      	str	r2, [r0, #0]
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    188a:	4618      	mov	r0, r3
    188c:	bd08      	pop	{r3, pc}
    188e:	bf00      	nop
    1890:	20001810 	.word	0x20001810
    1894:	20280000 	.word	0x20280000

00001898 <_exit>:
}

__attribute__((weak))
void _exit(int status)
{
	while (1) asm ("WFI");
    1898:	bf30      	wfi
    189a:	e7fd      	b.n	1898 <_exit>

0000189c <Panic_Temp_isr>:
static float s_hot_ROOM, s_roomC_hotC;

extern void unused_interrupt_vector(void); // startup.c

void Panic_Temp_isr(void) {
  unused_interrupt_vector();
    189c:	f7ff bf1c 	b.w	16d8 <unused_interrupt_vector>

000018a0 <tempmonGetTemp>:
float tempmonGetTemp(void)
{
    uint32_t nmeas;
    float tmeas;

    while (!(TEMPMON_TEMPSENSE0 & 0x4U))
    18a0:	4912      	ldr	r1, [pc, #72]	; (18ec <tempmonGetTemp+0x4c>)
    18a2:	680b      	ldr	r3, [r1, #0]
    18a4:	4a11      	ldr	r2, [pc, #68]	; (18ec <tempmonGetTemp+0x4c>)
    18a6:	075b      	lsls	r3, r3, #29
    18a8:	d5fb      	bpl.n	18a2 <tempmonGetTemp+0x2>
    {
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    18aa:	6813      	ldr	r3, [r2, #0]
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    18ac:	4910      	ldr	r1, [pc, #64]	; (18f0 <tempmonGetTemp+0x50>)

    return tmeas;
    18ae:	f3c3 230b 	ubfx	r3, r3, #8, #12
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    18b2:	4a10      	ldr	r2, [pc, #64]	; (18f4 <tempmonGetTemp+0x54>)

    return tmeas;
    18b4:	ee07 3a90 	vmov	s15, r3
    18b8:	680b      	ldr	r3, [r1, #0]
    18ba:	ed92 6a00 	vldr	s12, [r2]
    18be:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    18c2:	ee07 3a90 	vmov	s15, r3
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    18c6:	4a0c      	ldr	r2, [pc, #48]	; (18f8 <tempmonGetTemp+0x58>)

    return tmeas;
    18c8:	eef8 7a67 	vcvt.f32.u32	s15, s15
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    18cc:	4b0b      	ldr	r3, [pc, #44]	; (18fc <tempmonGetTemp+0x5c>)

    return tmeas;
    18ce:	edd2 6a00 	vldr	s13, [r2]
    18d2:	ee77 7a67 	vsub.f32	s15, s14, s15
    18d6:	ed93 7a00 	vldr	s14, [r3]
    18da:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    18de:	ee67 7a86 	vmul.f32	s15, s15, s12
    18e2:	ee87 0aa6 	vdiv.f32	s0, s15, s13
}
    18e6:	ee37 0a40 	vsub.f32	s0, s14, s0
    18ea:	4770      	bx	lr
    18ec:	400d8180 	.word	0x400d8180
    18f0:	20002728 	.word	0x20002728
    18f4:	20002730 	.word	0x20002730
    18f8:	20002734 	.word	0x20002734
    18fc:	2000272c 	.word	0x2000272c

00001900 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    1900:	6b83      	ldr	r3, [r0, #56]	; 0x38
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
    1902:	b4f0      	push	{r4, r5, r6, r7}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    1904:	b11b      	cbz	r3, 190e <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    1906:	6853      	ldr	r3, [r2, #4]
    1908:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    190c:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    190e:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    1910:	6b44      	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    1912:	b35c      	cbz	r4, 196c <schedule_transfer+0x6c>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    1914:	4b1c      	ldr	r3, [pc, #112]	; (1988 <schedule_transfer+0x88>)
	__disable_irq();
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
	if (last) {
		last->next = (uint32_t)transfer;
    1916:	6022      	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    1918:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    191c:	420c      	tst	r4, r1
    191e:	d115      	bne.n	194c <schedule_transfer+0x4c>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    1920:	4e1a      	ldr	r6, [pc, #104]	; (198c <schedule_transfer+0x8c>)
    1922:	6837      	ldr	r7, [r6, #0]
    1924:	e004      	b.n	1930 <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    1926:	6834      	ldr	r4, [r6, #0]
    1928:	1be4      	subs	r4, r4, r7
    192a:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
    192e:	d20b      	bcs.n	1948 <schedule_transfer+0x48>
		if (USB1_ENDPTPRIME & epmask) goto end;
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    1930:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    1934:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    1938:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    193c:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    1940:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    1944:	0464      	lsls	r4, r4, #17
    1946:	d5ee      	bpl.n	1926 <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    1948:	400d      	ands	r5, r1
    194a:	d003      	beq.n	1954 <schedule_transfer+0x54>
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    194c:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    194e:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1950:	bcf0      	pop	{r4, r5, r6, r7}
    1952:	4770      	bx	lr
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
    1954:	4c0c      	ldr	r4, [pc, #48]	; (1988 <schedule_transfer+0x88>)
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
    1956:	6082      	str	r2, [r0, #8]
		endpoint->status = 0;
    1958:	60c5      	str	r5, [r0, #12]
		USB1_ENDPTPRIME |= epmask;
    195a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    195e:	4319      	orrs	r1, r3
    1960:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    1964:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    1966:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1968:	bcf0      	pop	{r4, r5, r6, r7}
    196a:	4770      	bx	lr
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
    196c:	4d06      	ldr	r5, [pc, #24]	; (1988 <schedule_transfer+0x88>)
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
    196e:	6082      	str	r2, [r0, #8]
	endpoint->status = 0;
    1970:	60c4      	str	r4, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
    1972:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
    1976:	4319      	orrs	r1, r3
    1978:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    197c:	6302      	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
    197e:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    1980:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1982:	bcf0      	pop	{r4, r5, r6, r7}
    1984:	4770      	bx	lr
    1986:	bf00      	nop
    1988:	402e0000 	.word	0x402e0000
    198c:	e0001004 	.word	0xe0001004

00001990 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    1990:	b570      	push	{r4, r5, r6, lr}
    1992:	4606      	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    1994:	6b00      	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
    1996:	b190      	cbz	r0, 19be <run_callbacks+0x2e>
    1998:	4602      	mov	r2, r0
    199a:	2400      	movs	r4, #0
    199c:	e003      	b.n	19a6 <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    199e:	6812      	ldr	r2, [r2, #0]
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
    19a0:	3401      	adds	r4, #1
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
    19a2:	2a01      	cmp	r2, #1
    19a4:	d00c      	beq.n	19c0 <run_callbacks+0x30>

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
    19a6:	6853      	ldr	r3, [r2, #4]
    19a8:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    19ac:	d0f7      	beq.n	199e <run_callbacks+0xe>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
    19ae:	6332      	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    19b0:	b12c      	cbz	r4, 19be <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
    19b2:	6bb3      	ldr	r3, [r6, #56]	; 0x38
			break;
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
    19b4:	6805      	ldr	r5, [r0, #0]
		ep->callback_function(first);
    19b6:	4798      	blx	r3
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    19b8:	3c01      	subs	r4, #1
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
    19ba:	4628      	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    19bc:	d1f9      	bne.n	19b2 <run_callbacks+0x22>
    19be:	bd70      	pop	{r4, r5, r6, pc}
		count++;
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
    19c0:	6333      	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
    19c2:	6373      	str	r3, [r6, #52]	; 0x34
			break;
    19c4:	e7f4      	b.n	19b0 <run_callbacks+0x20>
    19c6:	bf00      	nop

000019c8 <endpoint0_transmit.constprop.1>:
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    19c8:	b5f0      	push	{r4, r5, r6, r7, lr}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
    19ca:	b9e1      	cbnz	r1, 1a06 <endpoint0_transmit.constprop.1+0x3e>
    19cc:	4c21      	ldr	r4, [pc, #132]	; (1a54 <endpoint0_transmit.constprop.1+0x8c>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    19ce:	4922      	ldr	r1, [pc, #136]	; (1a58 <endpoint0_transmit.constprop.1+0x90>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    19d0:	2000      	movs	r0, #0
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    19d2:	4b22      	ldr	r3, [pc, #136]	; (1a5c <endpoint0_transmit.constprop.1+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    19d4:	2201      	movs	r2, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    19d6:	f04f 1501 	mov.w	r5, #65537	; 0x10001
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    19da:	2680      	movs	r6, #128	; 0x80
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    19dc:	600a      	str	r2, [r1, #0]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
	while (USB1_ENDPTPRIME) ;
    19de:	461a      	mov	r2, r3
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
    19e0:	60a1      	str	r1, [r4, #8]
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    19e2:	604e      	str	r6, [r1, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
    19e4:	60e0      	str	r0, [r4, #12]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    19e6:	f8c3 51bc 	str.w	r5, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    19ea:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    19ee:	4d1c      	ldr	r5, [pc, #112]	; (1a60 <endpoint0_transmit.constprop.1+0x98>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    19f0:	f044 0401 	orr.w	r4, r4, #1
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    19f4:	6088      	str	r0, [r1, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    19f6:	f8c3 41b0 	str.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    19fa:	6028      	str	r0, [r5, #0]
	while (USB1_ENDPTPRIME) ;
    19fc:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    1a00:	2b00      	cmp	r3, #0
    1a02:	d1fb      	bne.n	19fc <endpoint0_transmit.constprop.1+0x34>
}
    1a04:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1a06:	0409      	lsls	r1, r1, #16
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1a08:	4b16      	ldr	r3, [pc, #88]	; (1a64 <endpoint0_transmit.constprop.1+0x9c>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1a0a:	4d14      	ldr	r5, [pc, #80]	; (1a5c <endpoint0_transmit.constprop.1+0x94>)
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1a0c:	2601      	movs	r6, #1
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    1a0e:	4c11      	ldr	r4, [pc, #68]	; (1a54 <endpoint0_transmit.constprop.1+0x8c>)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1a10:	f041 0180 	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    1a14:	2200      	movs	r2, #0
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1a16:	601e      	str	r6, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1a18:	6059      	str	r1, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1a1a:	f500 5c80 	add.w	ip, r0, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    1a1e:	64e2      	str	r2, [r4, #76]	; 0x4c
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1a20:	f500 5e00 	add.w	lr, r0, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    1a24:	64a3      	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1a26:	f500 5740 	add.w	r7, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1a2a:	f8d5 11b0 	ldr.w	r1, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1a2e:	f500 4680 	add.w	r6, r0, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
    1a32:	462a      	mov	r2, r5
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    1a34:	6098      	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1a36:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1a3a:	f8c3 c00c 	str.w	ip, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1a3e:	f8c3 e010 	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1a42:	615f      	str	r7, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1a44:	619e      	str	r6, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1a46:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    1a4a:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    1a4e:	2b00      	cmp	r3, #0
    1a50:	d1fb      	bne.n	1a4a <endpoint0_transmit.constprop.1+0x82>
    1a52:	e7bc      	b.n	19ce <endpoint0_transmit.constprop.1+0x6>
    1a54:	20000000 	.word	0x20000000
    1a58:	20002780 	.word	0x20002780
    1a5c:	402e0000 	.word	0x402e0000
    1a60:	200026f0 	.word	0x200026f0
    1a64:	20002760 	.word	0x20002760

00001a68 <usb_isr>:
	__builtin_unreachable();
}


void usb_isr(void)
{
    1a68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    1a6c:	4cb0      	ldr	r4, [pc, #704]	; (1d30 <usb_isr+0x2c8>)
	__builtin_unreachable();
}


void usb_isr(void)
{
    1a6e:	b083      	sub	sp, #12
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    1a70:	f8d4 8144 	ldr.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    1a74:	f018 0f01 	tst.w	r8, #1
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
	USB1_USBSTS = status;
    1a78:	f8c4 8144 	str.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    1a7c:	d06f      	beq.n	1b5e <usb_isr+0xf6>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    1a7e:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1a82:	2b00      	cmp	r3, #0
    1a84:	d066      	beq.n	1b54 <usb_isr+0xec>
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    1a86:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
    1a8a:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 1d54 <usb_isr+0x2ec>
    1a8e:	4fa9      	ldr	r7, [pc, #676]	; (1d34 <usb_isr+0x2cc>)
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    1a90:	4626      	mov	r6, r4
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    1a92:	46da      	mov	sl, fp
	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
    1a94:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
    1a98:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    1a9a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    1a9c:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    1aa0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    1aa4:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    1aa8:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    1aac:	049d      	lsls	r5, r3, #18
    1aae:	d5f5      	bpl.n	1a9c <usb_isr+0x34>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    1ab0:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
    1ab4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    1ab8:	f8c6 3140 	str.w	r3, [r6, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    1abc:	f8c6 a1b4 	str.w	sl, [r6, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    1ac0:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
    1ac4:	f013 1301 	ands.w	r3, r3, #65537	; 0x10001
    1ac8:	d1fa      	bne.n	1ac0 <usb_isr+0x58>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1aca:	b281      	uxth	r1, r0
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
    1acc:	f8c9 3000 	str.w	r3, [r9]
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1ad0:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    1ad4:	f000 8148 	beq.w	1d68 <usb_isr+0x300>
    1ad8:	f200 80bb 	bhi.w	1c52 <usb_isr+0x1ea>
    1adc:	2982      	cmp	r1, #130	; 0x82
    1ade:	f000 8193 	beq.w	1e08 <usb_isr+0x3a0>
    1ae2:	f240 80cf 	bls.w	1c84 <usb_isr+0x21c>
    1ae6:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    1aea:	f000 815d 	beq.w	1da8 <usb_isr+0x340>
    1aee:	f240 3302 	movw	r3, #770	; 0x302
    1af2:	4299      	cmp	r1, r3
    1af4:	f040 80be 	bne.w	1c74 <usb_isr+0x20c>
			reply_buffer[0] = 1;
		}
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    1af8:	b292      	uxth	r2, r2
    1afa:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    1afe:	2b07      	cmp	r3, #7
    1b00:	f200 80b8 	bhi.w	1c74 <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    1b04:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    1b08:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1b0c:	4a8a      	ldr	r2, [pc, #552]	; (1d38 <usb_isr+0x2d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1b0e:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1b12:	f04f 0001 	mov.w	r0, #1
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    1b16:	441a      	add	r2, r3
    1b18:	6813      	ldr	r3, [r2, #0]
    1b1a:	bf14      	ite	ne
    1b1c:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    1b20:	f043 0301 	orreq.w	r3, r3, #1
    1b24:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1b26:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1b28:	4b84      	ldr	r3, [pc, #528]	; (1d3c <usb_isr+0x2d4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1b2a:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1b2c:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1b2e:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1b30:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1b32:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1b36:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1b3a:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1b3c:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    1b40:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    1b44:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1b48:	2b00      	cmp	r3, #0
    1b4a:	d1fb      	bne.n	1b44 <usb_isr+0xdc>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1b4c:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1b50:	2b00      	cmp	r3, #0
    1b52:	d19f      	bne.n	1a94 <usb_isr+0x2c>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    1b54:	4a76      	ldr	r2, [pc, #472]	; (1d30 <usb_isr+0x2c8>)
    1b56:	f8d2 31bc 	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    1b5a:	2b00      	cmp	r3, #0
    1b5c:	d147      	bne.n	1bee <usb_isr+0x186>
			}
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
    1b5e:	f018 0f40 	tst.w	r8, #64	; 0x40
    1b62:	d016      	beq.n	1b92 <usb_isr+0x12a>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    1b64:	4b72      	ldr	r3, [pc, #456]	; (1d30 <usb_isr+0x2c8>)
    1b66:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    1b6a:	4619      	mov	r1, r3
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    1b6c:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    1b70:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    1b74:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    1b78:	f8d1 31b0 	ldr.w	r3, [r1, #432]	; 0x1b0
    1b7c:	4a6c      	ldr	r2, [pc, #432]	; (1d30 <usb_isr+0x2c8>)
    1b7e:	2b00      	cmp	r3, #0
    1b80:	d1fa      	bne.n	1b78 <usb_isr+0x110>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    1b82:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    1b86:	496e      	ldr	r1, [pc, #440]	; (1d40 <usb_isr+0x2d8>)
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    1b88:	f8c2 01b4 	str.w	r0, [r2, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    1b8c:	f8d2 2184 	ldr.w	r2, [r2, #388]	; 0x184
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    1b90:	600b      	str	r3, [r1, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
    1b92:	f018 7f80 	tst.w	r8, #16777216	; 0x1000000
    1b96:	d003      	beq.n	1ba0 <usb_isr+0x138>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    1b98:	4b6a      	ldr	r3, [pc, #424]	; (1d44 <usb_isr+0x2dc>)
    1b9a:	681b      	ldr	r3, [r3, #0]
    1b9c:	b103      	cbz	r3, 1ba0 <usb_isr+0x138>
    1b9e:	4798      	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
    1ba0:	f018 7f00 	tst.w	r8, #33554432	; 0x2000000
    1ba4:	d003      	beq.n	1bae <usb_isr+0x146>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    1ba6:	4b68      	ldr	r3, [pc, #416]	; (1d48 <usb_isr+0x2e0>)
    1ba8:	681b      	ldr	r3, [r3, #0]
    1baa:	b103      	cbz	r3, 1bae <usb_isr+0x146>
    1bac:	4798      	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
    1bae:	f018 0f04 	tst.w	r8, #4
    1bb2:	d008      	beq.n	1bc6 <usb_isr+0x15e>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    1bb4:	4b5e      	ldr	r3, [pc, #376]	; (1d30 <usb_isr+0x2c8>)
    1bb6:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    1bba:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    1bbe:	d045      	beq.n	1c4c <usb_isr+0x1e4>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
    1bc0:	4b62      	ldr	r3, [pc, #392]	; (1d4c <usb_isr+0x2e4>)
    1bc2:	2201      	movs	r2, #1
    1bc4:	701a      	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    1bc6:	4b5a      	ldr	r3, [pc, #360]	; (1d30 <usb_isr+0x2c8>)
    1bc8:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    1bcc:	0612      	lsls	r2, r2, #24
    1bce:	d50b      	bpl.n	1be8 <usb_isr+0x180>
    1bd0:	f018 0f80 	tst.w	r8, #128	; 0x80
    1bd4:	d008      	beq.n	1be8 <usb_isr+0x180>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
    1bd6:	495e      	ldr	r1, [pc, #376]	; (1d50 <usb_isr+0x2e8>)
    1bd8:	780a      	ldrb	r2, [r1, #0]
    1bda:	b12a      	cbz	r2, 1be8 <usb_isr+0x180>
			if (--usb_reboot_timer == 0) {
    1bdc:	3a01      	subs	r2, #1
    1bde:	b2d2      	uxtb	r2, r2
    1be0:	700a      	strb	r2, [r1, #0]
    1be2:	2a00      	cmp	r2, #0
    1be4:	f000 8217 	beq.w	2016 <usb_isr+0x5ae>
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
    1be8:	b003      	add	sp, #12
    1bea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    1bee:	4959      	ldr	r1, [pc, #356]	; (1d54 <usb_isr+0x2ec>)
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
    1bf0:	f8c2 31bc 	str.w	r3, [r2, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    1bf4:	6808      	ldr	r0, [r1, #0]
    1bf6:	4203      	tst	r3, r0
    1bf8:	f040 81b1 	bne.w	1f5e <usb_isr+0x4f6>
				endpoint0_notify_mask = 0;
				endpoint0_complete();
			}
			completestatus &= endpointN_notify_mask;
    1bfc:	4a50      	ldr	r2, [pc, #320]	; (1d40 <usb_isr+0x2d8>)
    1bfe:	6815      	ldr	r5, [r2, #0]
#if 1
			if (completestatus) {
    1c00:	401d      	ands	r5, r3
    1c02:	d0ac      	beq.n	1b5e <usb_isr+0xf6>

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    1c04:	0c2e      	lsrs	r6, r5, #16
    1c06:	d00f      	beq.n	1c28 <usb_isr+0x1c0>
    1c08:	4f4a      	ldr	r7, [pc, #296]	; (1d34 <usb_isr+0x2cc>)
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
    1c0a:	f04f 0901 	mov.w	r9, #1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
    1c0e:	fa96 f4a6 	rbit	r4, r6
    1c12:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    1c16:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					tx &= ~(1<<p);
    1c1a:	fa09 f404 	lsl.w	r4, r9, r4

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    1c1e:	3040      	adds	r0, #64	; 0x40
    1c20:	f7ff feb6 	bl	1990 <run_callbacks>
#if 1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    1c24:	43a6      	bics	r6, r4
    1c26:	d1f2      	bne.n	1c0e <usb_isr+0x1a6>
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
    1c28:	b2ad      	uxth	r5, r5
				while(rx) {
    1c2a:	2d00      	cmp	r5, #0
    1c2c:	d097      	beq.n	1b5e <usb_isr+0xf6>
    1c2e:	4f41      	ldr	r7, [pc, #260]	; (1d34 <usb_isr+0x2cc>)
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
					rx &= ~(1<<p);
    1c30:	2601      	movs	r6, #1
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
    1c32:	fa95 f4a5 	rbit	r4, r5
    1c36:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2);
    1c3a:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					rx &= ~(1<<p);
    1c3e:	fa06 f404 	lsl.w	r4, r6, r4

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
    1c42:	f7ff fea5 	bl	1990 <run_callbacks>
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
    1c46:	43a5      	bics	r5, r4
    1c48:	d1f3      	bne.n	1c32 <usb_isr+0x1ca>
    1c4a:	e788      	b.n	1b5e <usb_isr+0xf6>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
    1c4c:	4a3f      	ldr	r2, [pc, #252]	; (1d4c <usb_isr+0x2e4>)
    1c4e:	7013      	strb	r3, [r2, #0]
    1c50:	e7b9      	b.n	1bc6 <usb_isr+0x15e>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1c52:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    1c56:	f000 80f5 	beq.w	1e44 <usb_isr+0x3dc>
    1c5a:	d922      	bls.n	1ca2 <usb_isr+0x23a>
    1c5c:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    1c60:	f000 80fe 	beq.w	1e60 <usb_isr+0x3f8>
    1c64:	f640 1521 	movw	r5, #2337	; 0x921
    1c68:	42a9      	cmp	r1, r5
    1c6a:	d103      	bne.n	1c74 <usb_isr+0x20c>
		endpoint0_receive(endpoint0_buffer, 7, 1);
		return;
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
    1c6c:	0c11      	lsrs	r1, r2, #16
    1c6e:	2908      	cmp	r1, #8
    1c70:	f240 8126 	bls.w	1ec0 <usb_isr+0x458>
		}
		break;
#endif
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    1c74:	f8c4 b1c0 	str.w	fp, [r4, #448]	; 0x1c0
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1c78:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1c7c:	2b00      	cmp	r3, #0
    1c7e:	f47f af09 	bne.w	1a94 <usb_isr+0x2c>
    1c82:	e767      	b.n	1b54 <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1c84:	2980      	cmp	r1, #128	; 0x80
    1c86:	d1f5      	bne.n	1c74 <usb_isr+0x20c>
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    1c88:	4a33      	ldr	r2, [pc, #204]	; (1d58 <usb_isr+0x2f0>)
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
    1c8a:	2102      	movs	r1, #2
    1c8c:	4610      	mov	r0, r2
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    1c8e:	7013      	strb	r3, [r2, #0]
		reply_buffer[1] = 0;
    1c90:	7053      	strb	r3, [r2, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
    1c92:	f7ff fe99 	bl	19c8 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1c96:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1c9a:	2b00      	cmp	r3, #0
    1c9c:	f47f aefa 	bne.w	1a94 <usb_isr+0x2c>
    1ca0:	e758      	b.n	1b54 <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1ca2:	f5a1 61d0 	sub.w	r1, r1, #1664	; 0x680
    1ca6:	2901      	cmp	r1, #1
    1ca8:	d8e4      	bhi.n	1c74 <usb_isr+0x20c>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    1caa:	4b2c      	ldr	r3, [pc, #176]	; (1d5c <usb_isr+0x2f4>)
    1cac:	6859      	ldr	r1, [r3, #4]
    1cae:	2900      	cmp	r1, #0
    1cb0:	d0e0      	beq.n	1c74 <usb_isr+0x20c>
    1cb2:	0c00      	lsrs	r0, r0, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    1cb4:	fa1f fe82 	uxth.w	lr, r2
    1cb8:	e003      	b.n	1cc2 <usb_isr+0x25a>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    1cba:	330c      	adds	r3, #12
    1cbc:	6859      	ldr	r1, [r3, #4]
    1cbe:	2900      	cmp	r1, #0
    1cc0:	d0d8      	beq.n	1c74 <usb_isr+0x20c>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    1cc2:	881d      	ldrh	r5, [r3, #0]
    1cc4:	4285      	cmp	r5, r0
    1cc6:	d1f8      	bne.n	1cba <usb_isr+0x252>
    1cc8:	885d      	ldrh	r5, [r3, #2]
    1cca:	4575      	cmp	r5, lr
    1ccc:	d1f5      	bne.n	1cba <usb_isr+0x252>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
    1cce:	0a05      	lsrs	r5, r0, #8
    1cd0:	2d03      	cmp	r5, #3
    1cd2:	f000 817b 	beq.w	1fcc <usb_isr+0x564>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
    1cd6:	891b      	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    1cd8:	0c12      	lsrs	r2, r2, #16
    1cda:	4293      	cmp	r3, r2
    1cdc:	bf28      	it	cs
    1cde:	4613      	movcs	r3, r2

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
    1ce0:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    1ce4:	f000 8163 	beq.w	1fae <usb_isr+0x546>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
    1ce8:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    1cec:	f000 814c 	beq.w	1f88 <usb_isr+0x520>
    1cf0:	4d1b      	ldr	r5, [pc, #108]	; (1d60 <usb_isr+0x2f8>)
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
					usb_descriptor_buffer[1] = 7;
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    1cf2:	461a      	mov	r2, r3
    1cf4:	9301      	str	r3, [sp, #4]
    1cf6:	4628      	mov	r0, r5
    1cf8:	f004 fc32 	bl	6560 <memcpy>
    1cfc:	9b01      	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    1cfe:	f025 021f 	bic.w	r2, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    1d02:	441d      	add	r5, r3
	asm volatile("": : :"memory");
	asm("dsb");
    1d04:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    1d08:	4916      	ldr	r1, [pc, #88]	; (1d64 <usb_isr+0x2fc>)
    1d0a:	600a      	str	r2, [r1, #0]
		location += 32;
    1d0c:	3220      	adds	r2, #32
	} while (location < end_addr);
    1d0e:	4295      	cmp	r5, r2
    1d10:	d8fa      	bhi.n	1d08 <usb_isr+0x2a0>
	asm("dsb");
    1d12:	f3bf 8f4f 	dsb	sy
	asm("isb");
    1d16:	f3bf 8f6f 	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    1d1a:	4811      	ldr	r0, [pc, #68]	; (1d60 <usb_isr+0x2f8>)
    1d1c:	4619      	mov	r1, r3
    1d1e:	f7ff fe53 	bl	19c8 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1d22:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1d26:	2b00      	cmp	r3, #0
    1d28:	f47f aeb4 	bne.w	1a94 <usb_isr+0x2c>
    1d2c:	e712      	b.n	1b54 <usb_isr+0xec>
    1d2e:	bf00      	nop
    1d30:	402e0000 	.word	0x402e0000
    1d34:	20000000 	.word	0x20000000
    1d38:	402e01c0 	.word	0x402e01c0
    1d3c:	20002780 	.word	0x20002780
    1d40:	200026f4 	.word	0x200026f4
    1d44:	20002744 	.word	0x20002744
    1d48:	20002748 	.word	0x20002748
    1d4c:	2000275d 	.word	0x2000275d
    1d50:	2000275e 	.word	0x2000275e
    1d54:	200026f0 	.word	0x200026f0
    1d58:	200026f8 	.word	0x200026f8
    1d5c:	20000f50 	.word	0x20000f50
    1d60:	20200000 	.word	0x20200000
    1d64:	e000ef70 	.word	0xe000ef70
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1d68:	4ab2      	ldr	r2, [pc, #712]	; (2034 <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1d6a:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1d6c:	2501      	movs	r5, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1d6e:	64fb      	str	r3, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1d70:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1d72:	6015      	str	r5, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1d74:	6051      	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1d76:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1d7a:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1d7e:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1d80:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
    1d84:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    1d88:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1d8c:	2b00      	cmp	r3, #0
    1d8e:	d1fb      	bne.n	1d88 <usb_isr+0x320>

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    1d90:	0c03      	lsrs	r3, r0, #16
    1d92:	065b      	lsls	r3, r3, #25
    1d94:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    1d98:	f8c6 3154 	str.w	r3, [r6, #340]	; 0x154
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1d9c:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1da0:	2b00      	cmp	r3, #0
    1da2:	f47f ae77 	bne.w	1a94 <usb_isr+0x2c>
    1da6:	e6d5      	b.n	1b54 <usb_isr+0xec>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    1da8:	b292      	uxth	r2, r2
    1daa:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    1dae:	2b07      	cmp	r3, #7
    1db0:	f63f af60 	bhi.w	1c74 <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    1db4:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    1db8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1dbc:	4a9e      	ldr	r2, [pc, #632]	; (2038 <usb_isr+0x5d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1dbe:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1dc2:	f04f 0001 	mov.w	r0, #1
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    1dc6:	441a      	add	r2, r3
    1dc8:	6813      	ldr	r3, [r2, #0]
    1dca:	bf14      	ite	ne
    1dcc:	f423 3380 	bicne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    1dd0:	f023 0301 	biceq.w	r3, r3, #1
    1dd4:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1dd6:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1dd8:	4b96      	ldr	r3, [pc, #600]	; (2034 <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1dda:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1ddc:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1dde:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1de0:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1de2:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1de6:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1dea:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1dec:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    1df0:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    1df4:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1df8:	2b00      	cmp	r3, #0
    1dfa:	d1fb      	bne.n	1df4 <usb_isr+0x38c>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1dfc:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1e00:	2b00      	cmp	r3, #0
    1e02:	f47f ae47 	bne.w	1a94 <usb_isr+0x2c>
    1e06:	e6a5      	b.n	1b54 <usb_isr+0xec>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
    1e08:	b292      	uxth	r2, r2
    1e0a:	f002 017f 	and.w	r1, r2, #127	; 0x7f
		if (endpoint > 7) break;
    1e0e:	2907      	cmp	r1, #7
    1e10:	f63f af30 	bhi.w	1c74 <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    1e14:	0089      	lsls	r1, r1, #2
    1e16:	4888      	ldr	r0, [pc, #544]	; (2038 <usb_isr+0x5d0>)
		reply_buffer[0] = 0;
    1e18:	4d88      	ldr	r5, [pc, #544]	; (203c <usb_isr+0x5d4>)
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    1e1a:	4408      	add	r0, r1
    1e1c:	6801      	ldr	r1, [r0, #0]
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    1e1e:	0610      	lsls	r0, r2, #24
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
    1e20:	702b      	strb	r3, [r5, #0]
		reply_buffer[1] = 0;
    1e22:	706b      	strb	r3, [r5, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    1e24:	f140 8097 	bpl.w	1f56 <usb_isr+0x4ee>
    1e28:	03ca      	lsls	r2, r1, #15
    1e2a:	d501      	bpl.n	1e30 <usb_isr+0x3c8>
			reply_buffer[0] = 1;
    1e2c:	2301      	movs	r3, #1
    1e2e:	702b      	strb	r3, [r5, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
    1e30:	2102      	movs	r1, #2
    1e32:	4882      	ldr	r0, [pc, #520]	; (203c <usb_isr+0x5d4>)
    1e34:	f7ff fdc8 	bl	19c8 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1e38:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1e3c:	2b00      	cmp	r3, #0
    1e3e:	f47f ae29 	bne.w	1a94 <usb_isr+0x2c>
    1e42:	e687      	b.n	1b54 <usb_isr+0xec>
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    1e44:	4a7e      	ldr	r2, [pc, #504]	; (2040 <usb_isr+0x5d8>)
		endpoint0_transmit(reply_buffer, 1, 0);
    1e46:	2101      	movs	r1, #1
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    1e48:	4b7c      	ldr	r3, [pc, #496]	; (203c <usb_isr+0x5d4>)
    1e4a:	7812      	ldrb	r2, [r2, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    1e4c:	4618      	mov	r0, r3
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    1e4e:	701a      	strb	r2, [r3, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    1e50:	f7ff fdba 	bl	19c8 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1e54:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1e58:	2b00      	cmp	r3, #0
    1e5a:	f47f ae1b 	bne.w	1a94 <usb_isr+0x2c>
    1e5e:	e679      	b.n	1b54 <usb_isr+0xec>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    1e60:	f3c0 4007 	ubfx	r0, r0, #16, #8
    1e64:	4a76      	ldr	r2, [pc, #472]	; (2040 <usb_isr+0x5d8>)
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    1e66:	4977      	ldr	r1, [pc, #476]	; (2044 <usb_isr+0x5dc>)
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    1e68:	f04f 15cc 	mov.w	r5, #13369548	; 0xcc00cc
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    1e6c:	7010      	strb	r0, [r2, #0]
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    1e6e:	4a76      	ldr	r2, [pc, #472]	; (2048 <usb_isr+0x5e0>)
    1e70:	9301      	str	r3, [sp, #4]
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    1e72:	f8c6 51c8 	str.w	r5, [r6, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    1e76:	f8c6 11cc 	str.w	r1, [r6, #460]	; 0x1cc
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    1e7a:	f8c6 21d0 	str.w	r2, [r6, #464]	; 0x1d0
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
		#elif defined(SEREMU_INTERFACE)
		usb_seremu_configure();
    1e7e:	f000 fab3 	bl	23e8 <usb_seremu_configure>
		#endif
		#if defined(CDC3_STATUS_INTERFACE) && defined(CDC3_DATA_INTERFACE)
		usb_serial3_configure();
		#endif
		#if defined(RAWHID_INTERFACE)
		usb_rawhid_configure();
    1e82:	f000 fa19 	bl	22b8 <usb_rawhid_configure>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e86:	4a6b      	ldr	r2, [pc, #428]	; (2034 <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1e88:	9b01      	ldr	r3, [sp, #4]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1e8a:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e8c:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1e8e:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1e90:	6051      	str	r1, [r2, #4]
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e92:	6010      	str	r0, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1e94:	64fb      	str	r3, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1e96:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1e9a:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1e9e:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1ea0:	f441 3280 	orr.w	r2, r1, #65536	; 0x10000
    1ea4:	f8c6 21b0 	str.w	r2, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    1ea8:	4a68      	ldr	r2, [pc, #416]	; (204c <usb_isr+0x5e4>)
    1eaa:	6013      	str	r3, [r2, #0]
	while (USB1_ENDPTPRIME) ;
    1eac:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1eb0:	2b00      	cmp	r3, #0
    1eb2:	d1fb      	bne.n	1eac <usb_isr+0x444>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1eb4:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1eb8:	2b00      	cmp	r3, #0
    1eba:	f47f adeb 	bne.w	1a94 <usb_isr+0x2c>
    1ebe:	e649      	b.n	1b54 <usb_isr+0xec>
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    1ec0:	f8df e194 	ldr.w	lr, [pc, #404]	; 2058 <usb_isr+0x5f0>
			endpoint0_buffer[0] = 0xE9;
    1ec4:	f04f 0ce9 	mov.w	ip, #233	; 0xe9
    1ec8:	4d61      	ldr	r5, [pc, #388]	; (2050 <usb_isr+0x5e8>)
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    1eca:	e88e 0005 	stmia.w	lr, {r0, r2}
			endpoint0_buffer[0] = 0xE9;
    1ece:	f885 c000 	strb.w	ip, [r5]
}

static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
    1ed2:	b301      	cbz	r1, 1f16 <usb_isr+0x4ae>
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1ed4:	0409      	lsls	r1, r1, #16
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1ed6:	4a5f      	ldr	r2, [pc, #380]	; (2054 <usb_isr+0x5ec>)
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
    1ed8:	60fb      	str	r3, [r7, #12]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1eda:	2001      	movs	r0, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1edc:	f041 0380 	orr.w	r3, r1, #128	; 0x80
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    1ee0:	60ba      	str	r2, [r7, #8]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1ee2:	6010      	str	r0, [r2, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1ee4:	f505 5e00 	add.w	lr, r5, #8192	; 0x2000
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1ee8:	6053      	str	r3, [r2, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1eea:	f505 5080 	add.w	r0, r5, #4096	; 0x1000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    1eee:	f8d6 31b0 	ldr.w	r3, [r6, #432]	; 0x1b0
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1ef2:	f505 5140 	add.w	r1, r5, #12288	; 0x3000
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    1ef6:	6095      	str	r5, [r2, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1ef8:	f505 4580 	add.w	r5, r5, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    1efc:	f043 0301 	orr.w	r3, r3, #1
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1f00:	60d0      	str	r0, [r2, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1f02:	f8c2 e010 	str.w	lr, [r2, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1f06:	6151      	str	r1, [r2, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1f08:	6195      	str	r5, [r2, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    1f0a:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    1f0e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1f12:	2b00      	cmp	r3, #0
    1f14:	d1fb      	bne.n	1f0e <usb_isr+0x4a6>
	}
	endpoint0_transfer_ack.next = 1;
    1f16:	4b47      	ldr	r3, [pc, #284]	; (2034 <usb_isr+0x5cc>)
    1f18:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1f1a:	f248 0280 	movw	r2, #32896	; 0x8080
	endpoint0_transfer_ack.pointer0 = 0;
    1f1e:	2100      	movs	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1f20:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    1f22:	f44f 3080 	mov.w	r0, #65536	; 0x10000
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1f26:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1f28:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1f2a:	64f9      	str	r1, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1f2c:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1f30:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1f34:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1f36:	ea42 0300 	orr.w	r3, r2, r0
    1f3a:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    1f3e:	f8c9 0000 	str.w	r0, [r9]
	while (USB1_ENDPTPRIME) ;
    1f42:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1f46:	2b00      	cmp	r3, #0
    1f48:	d1fb      	bne.n	1f42 <usb_isr+0x4da>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1f4a:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1f4e:	2b00      	cmp	r3, #0
    1f50:	f47f ada0 	bne.w	1a94 <usb_isr+0x2c>
    1f54:	e5fe      	b.n	1b54 <usb_isr+0xec>
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    1f56:	07cb      	lsls	r3, r1, #31
    1f58:	f57f af6a 	bpl.w	1e30 <usb_isr+0x3c8>
    1f5c:	e766      	b.n	1e2c <usb_isr+0x3c4>

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    1f5e:	483e      	ldr	r0, [pc, #248]	; (2058 <usb_isr+0x5f0>)
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    1f60:	2600      	movs	r6, #0
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    1f62:	4c3e      	ldr	r4, [pc, #248]	; (205c <usb_isr+0x5f4>)

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    1f64:	6805      	ldr	r5, [r0, #0]
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    1f66:	600e      	str	r6, [r1, #0]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    1f68:	42a5      	cmp	r5, r4

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    1f6a:	6840      	ldr	r0, [r0, #4]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    1f6c:	f47f ae46 	bne.w	1bfc <usb_isr+0x194>
    1f70:	493b      	ldr	r1, [pc, #236]	; (2060 <usb_isr+0x5f8>)
    1f72:	4288      	cmp	r0, r1
    1f74:	f47f ae42 	bne.w	1bfc <usb_isr+0x194>
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    1f78:	4935      	ldr	r1, [pc, #212]	; (2050 <usb_isr+0x5e8>)
    1f7a:	7808      	ldrb	r0, [r1, #0]
    1f7c:	28a9      	cmp	r0, #169	; 0xa9
    1f7e:	d02b      	beq.n	1fd8 <usb_isr+0x570>
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
		} else {
			// any other feature report means Arduino Serial Monitor is open
			usb_seremu_online = 1;
    1f80:	4a38      	ldr	r2, [pc, #224]	; (2064 <usb_isr+0x5fc>)
    1f82:	2101      	movs	r1, #1
    1f84:	7011      	strb	r1, [r2, #0]
    1f86:	e639      	b.n	1bfc <usb_isr+0x194>
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    1f88:	4837      	ldr	r0, [pc, #220]	; (2068 <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    1f8a:	461a      	mov	r2, r3
    1f8c:	4d37      	ldr	r5, [pc, #220]	; (206c <usb_isr+0x604>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    1f8e:	f890 e000 	ldrb.w	lr, [r0]
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
    1f92:	4937      	ldr	r1, [pc, #220]	; (2070 <usb_isr+0x608>)
    1f94:	4837      	ldr	r0, [pc, #220]	; (2074 <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
    1f96:	9301      	str	r3, [sp, #4]
    1f98:	f1be 0f00 	cmp.w	lr, #0
    1f9c:	bf08      	it	eq
    1f9e:	4601      	moveq	r1, r0
    1fa0:	4628      	mov	r0, r5
    1fa2:	f004 fadd 	bl	6560 <memcpy>
					usb_descriptor_buffer[1] = 7;
    1fa6:	2207      	movs	r2, #7
    1fa8:	9b01      	ldr	r3, [sp, #4]
    1faa:	706a      	strb	r2, [r5, #1]
    1fac:	e6a7      	b.n	1cfe <usb_isr+0x296>

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
    1fae:	482e      	ldr	r0, [pc, #184]	; (2068 <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    1fb0:	461a      	mov	r2, r3
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    1fb2:	4930      	ldr	r1, [pc, #192]	; (2074 <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_480;
    1fb4:	7805      	ldrb	r5, [r0, #0]
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    1fb6:	482e      	ldr	r0, [pc, #184]	; (2070 <usb_isr+0x608>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
    1fb8:	9301      	str	r3, [sp, #4]
    1fba:	2d00      	cmp	r5, #0
    1fbc:	bf08      	it	eq
    1fbe:	4601      	moveq	r1, r0
    1fc0:	482a      	ldr	r0, [pc, #168]	; (206c <usb_isr+0x604>)
    1fc2:	f004 facd 	bl	6560 <memcpy>
    1fc6:	4d29      	ldr	r5, [pc, #164]	; (206c <usb_isr+0x604>)
    1fc8:	9b01      	ldr	r3, [sp, #4]
    1fca:	e698      	b.n	1cfe <usb_isr+0x296>
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    1fcc:	0c12      	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
    1fce:	780b      	ldrb	r3, [r1, #0]
    1fd0:	4293      	cmp	r3, r2
    1fd2:	bf28      	it	cs
    1fd4:	4613      	movcs	r3, r2
    1fd6:	e687      	b.n	1ce8 <usb_isr+0x280>
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    1fd8:	7848      	ldrb	r0, [r1, #1]
    1fda:	2845      	cmp	r0, #69	; 0x45
    1fdc:	d1d0      	bne.n	1f80 <usb_isr+0x518>
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
    1fde:	7888      	ldrb	r0, [r1, #2]
    1fe0:	28c2      	cmp	r0, #194	; 0xc2
    1fe2:	d1cd      	bne.n	1f80 <usb_isr+0x518>
    1fe4:	78c9      	ldrb	r1, [r1, #3]
    1fe6:	296b      	cmp	r1, #107	; 0x6b
    1fe8:	d1ca      	bne.n	1f80 <usb_isr+0x518>
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
    1fea:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    1fec:	4822      	ldr	r0, [pc, #136]	; (2078 <usb_isr+0x610>)
    1fee:	7801      	ldrb	r1, [r0, #0]
    1ff0:	f041 0104 	orr.w	r1, r1, #4
    1ff4:	7001      	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    1ff6:	f8d2 1148 	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    1ffa:	0608      	lsls	r0, r1, #24
    1ffc:	d406      	bmi.n	200c <usb_isr+0x5a4>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    1ffe:	f041 0180 	orr.w	r1, r1, #128	; 0x80
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    2002:	2080      	movs	r0, #128	; 0x80
    2004:	f8c2 0144 	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    2008:	f8c2 1148 	str.w	r1, [r2, #328]	; 0x148
	}
	__enable_irq();
    200c:	b662      	cpsie	i
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    200e:	4a1b      	ldr	r2, [pc, #108]	; (207c <usb_isr+0x614>)
    2010:	2150      	movs	r1, #80	; 0x50
    2012:	7011      	strb	r1, [r2, #0]
    2014:	e5f2      	b.n	1bfc <usb_isr+0x194>
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
    2016:	4918      	ldr	r1, [pc, #96]	; (2078 <usb_isr+0x610>)
    2018:	780a      	ldrb	r2, [r1, #0]
    201a:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    201e:	700a      	strb	r2, [r1, #0]
	if (sof_usage == 0) {
    2020:	b92a      	cbnz	r2, 202e <usb_isr+0x5c6>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    2022:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    2026:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    202a:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
			if (--usb_reboot_timer == 0) {
				usb_stop_sof_interrupts(NUM_INTERFACE);
				_reboot_Teensyduino_();
    202e:	f008 f89f 	bl	a170 <___reboot_Teensyduino__veneer>
    2032:	bf00      	nop
    2034:	20002780 	.word	0x20002780
    2038:	402e01c0 	.word	0x402e01c0
    203c:	200026f8 	.word	0x200026f8
    2040:	2000275c 	.word	0x2000275c
    2044:	00cc0002 	.word	0x00cc0002
    2048:	000200cc 	.word	0x000200cc
    204c:	200026f0 	.word	0x200026f0
    2050:	200026e8 	.word	0x200026e8
    2054:	20002760 	.word	0x20002760
    2058:	20002660 	.word	0x20002660
    205c:	03000921 	.word	0x03000921
    2060:	00040001 	.word	0x00040001
    2064:	2000275f 	.word	0x2000275f
    2068:	2000275d 	.word	0x2000275d
    206c:	20200000 	.word	0x20200000
    2070:	600020e4 	.word	0x600020e4
    2074:	60002130 	.word	0x60002130
    2078:	20002757 	.word	0x20002757
    207c:	2000275e 	.word	0x2000275e

00002080 <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    2080:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    2082:	f1a0 0202 	sub.w	r2, r0, #2
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    2086:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    208a:	bf14      	ite	ne
    208c:	2700      	movne	r7, #0
    208e:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    2092:	2a02      	cmp	r2, #2
    2094:	d901      	bls.n	209a <usb_config_rx+0x1a>
    2096:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    209a:	ea4f 19c0 	mov.w	r9, r0, lsl #7
    209e:	f8df a040 	ldr.w	sl, [pc, #64]	; 20e0 <usb_config_rx+0x60>
    20a2:	460d      	mov	r5, r1
    20a4:	4604      	mov	r4, r0
    20a6:	eb0a 0609 	add.w	r6, sl, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    20aa:	2100      	movs	r1, #0
    20ac:	2240      	movs	r2, #64	; 0x40
    20ae:	4698      	mov	r8, r3
    20b0:	4630      	mov	r0, r6
    20b2:	f004 fb53 	bl	675c <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    20b6:	2001      	movs	r0, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    20b8:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
    20bc:	f84a 1009 	str.w	r1, [sl, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    20c0:	f8c6 8038 	str.w	r8, [r6, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    20c4:	60b0      	str	r0, [r6, #8]
void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
    20c6:	f1b8 0f00 	cmp.w	r8, #0
    20ca:	d0e4      	beq.n	2096 <usb_config_rx+0x16>
    20cc:	4b03      	ldr	r3, [pc, #12]	; (20dc <usb_config_rx+0x5c>)
    20ce:	40a0      	lsls	r0, r4
    20d0:	681c      	ldr	r4, [r3, #0]
    20d2:	4320      	orrs	r0, r4
    20d4:	6018      	str	r0, [r3, #0]
    20d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    20da:	bf00      	nop
    20dc:	200026f4 	.word	0x200026f4
    20e0:	20000000 	.word	0x20000000

000020e4 <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    20e4:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    20e6:	f1a0 0202 	sub.w	r2, r0, #2
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    20ea:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    20ee:	bf14      	ite	ne
    20f0:	2700      	movne	r7, #0
    20f2:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    20f6:	2a02      	cmp	r2, #2
    20f8:	d901      	bls.n	20fe <usb_config_tx+0x1a>
    20fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    20fe:	2240      	movs	r2, #64	; 0x40

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    2100:	01c5      	lsls	r5, r0, #7
    2102:	f8df 9044 	ldr.w	r9, [pc, #68]	; 2148 <usb_config_tx+0x64>
    2106:	4688      	mov	r8, r1
    2108:	4415      	add	r5, r2
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    210a:	2100      	movs	r1, #0
    210c:	4604      	mov	r4, r0
    210e:	461e      	mov	r6, r3

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    2110:	eb09 0a05 	add.w	sl, r9, r5
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    2114:	4650      	mov	r0, sl
    2116:	f004 fb21 	bl	675c <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    211a:	2201      	movs	r2, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    211c:	ea47 4108 	orr.w	r1, r7, r8, lsl #16
    2120:	f849 1005 	str.w	r1, [r9, r5]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    2124:	f8ca 6038 	str.w	r6, [sl, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    2128:	f8ca 2008 	str.w	r2, [sl, #8]
void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    212c:	2e00      	cmp	r6, #0
    212e:	d0e4      	beq.n	20fa <usb_config_tx+0x16>
    2130:	f104 0010 	add.w	r0, r4, #16
    2134:	4b03      	ldr	r3, [pc, #12]	; (2144 <usb_config_tx+0x60>)
    2136:	4082      	lsls	r2, r0
    2138:	6818      	ldr	r0, [r3, #0]
    213a:	4302      	orrs	r2, r0
    213c:	601a      	str	r2, [r3, #0]
    213e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2142:	bf00      	nop
    2144:	200026f4 	.word	0x200026f4
    2148:	20000000 	.word	0x20000000

0000214c <usb_prepare_transfer>:


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    214c:	0412      	lsls	r2, r2, #16
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
    214e:	6081      	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
	transfer->pointer2 = addr + 8192;
	transfer->pointer3 = addr + 12288;
	transfer->pointer4 = addr + 16384;
	transfer->callback_param = param;
    2150:	61c3      	str	r3, [r0, #28]


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    2152:	f042 0280 	orr.w	r2, r2, #128	; 0x80
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
    2156:	b4f0      	push	{r4, r5, r6, r7}
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    2158:	6042      	str	r2, [r0, #4]



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    215a:	2701      	movs	r7, #1
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    215c:	f501 5680 	add.w	r6, r1, #4096	; 0x1000
	transfer->pointer2 = addr + 8192;
    2160:	f501 5500 	add.w	r5, r1, #8192	; 0x2000
	transfer->pointer3 = addr + 12288;
    2164:	f501 5440 	add.w	r4, r1, #12288	; 0x3000
	transfer->pointer4 = addr + 16384;
    2168:	f501 4280 	add.w	r2, r1, #16384	; 0x4000



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    216c:	6007      	str	r7, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    216e:	60c6      	str	r6, [r0, #12]
	transfer->pointer2 = addr + 8192;
    2170:	6105      	str	r5, [r0, #16]
	transfer->pointer3 = addr + 12288;
    2172:	6144      	str	r4, [r0, #20]
	transfer->pointer4 = addr + 16384;
    2174:	6182      	str	r2, [r0, #24]
	transfer->callback_param = param;
}
    2176:	bcf0      	pop	{r4, r5, r6, r7}
    2178:	4770      	bx	lr
    217a:	bf00      	nop

0000217c <usb_transmit>:
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    217c:	1e83      	subs	r3, r0, #2
    217e:	2b02      	cmp	r3, #2
    2180:	d900      	bls.n	2184 <usb_transmit+0x8>
    2182:	4770      	bx	lr
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    2184:	4b06      	ldr	r3, [pc, #24]	; (21a0 <usb_transmit+0x24>)
    2186:	460a      	mov	r2, r1
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
    2188:	b430      	push	{r4, r5}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    218a:	f100 0410 	add.w	r4, r0, #16
    218e:	2501      	movs	r5, #1
    2190:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    2194:	fa05 f104 	lsl.w	r1, r5, r4
    2198:	3040      	adds	r0, #64	; 0x40
}
    219a:	bc30      	pop	{r4, r5}
void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    219c:	f7ff bbb0 	b.w	1900 <schedule_transfer>
    21a0:	20000000 	.word	0x20000000

000021a4 <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    21a4:	1e83      	subs	r3, r0, #2
    21a6:	2b02      	cmp	r3, #2
    21a8:	d900      	bls.n	21ac <usb_receive+0x8>
    21aa:	4770      	bx	lr
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
    21ac:	b410      	push	{r4}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    21ae:	4b05      	ldr	r3, [pc, #20]	; (21c4 <usb_receive+0x20>)
    21b0:	2401      	movs	r4, #1
    21b2:	460a      	mov	r2, r1
    21b4:	fa04 f100 	lsl.w	r1, r4, r0
    21b8:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
}
    21bc:	f85d 4b04 	ldr.w	r4, [sp], #4
void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    21c0:	f7ff bb9e 	b.w	1900 <schedule_transfer>
    21c4:	20000000 	.word	0x20000000

000021c8 <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    21c8:	6840      	ldr	r0, [r0, #4]
#endif
}
    21ca:	4770      	bx	lr

000021cc <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    21cc:	4a12      	ldr	r2, [pc, #72]	; (2218 <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    21ce:	4b13      	ldr	r3, [pc, #76]	; (221c <usb_init_serialnumber+0x50>)
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    21d0:	f8d2 0220 	ldr.w	r0, [r2, #544]	; 0x220
    21d4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    21d8:	4298      	cmp	r0, r3
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    21da:	b510      	push	{r4, lr}
    21dc:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    21de:	d802      	bhi.n	21e6 <usb_init_serialnumber+0x1a>
    21e0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    21e4:	0040      	lsls	r0, r0, #1
    21e6:	4c0e      	ldr	r4, [pc, #56]	; (2220 <usb_init_serialnumber+0x54>)
	ultoa(num, buf, 10);
    21e8:	a901      	add	r1, sp, #4
    21ea:	220a      	movs	r2, #10
    21ec:	f7ff f868 	bl	12c0 <ultoa>
    21f0:	a901      	add	r1, sp, #4
	for (i=0; i<10; i++) {
    21f2:	2300      	movs	r3, #0
    21f4:	4620      	mov	r0, r4
		char c = buf[i];
    21f6:	f811 2b01 	ldrb.w	r2, [r1], #1
    21fa:	3301      	adds	r3, #1
		if (!c) break;
    21fc:	b13a      	cbz	r2, 220e <usb_init_serialnumber+0x42>

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    21fe:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    2200:	f820 2f02 	strh.w	r2, [r0, #2]!

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    2204:	d1f7      	bne.n	21f6 <usb_init_serialnumber+0x2a>
    2206:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    2208:	7023      	strb	r3, [r4, #0]
}
    220a:	b004      	add	sp, #16
    220c:	bd10      	pop	{r4, pc}
    220e:	005b      	lsls	r3, r3, #1
    2210:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    2212:	7023      	strb	r3, [r4, #0]
}
    2214:	b004      	add	sp, #16
    2216:	bd10      	pop	{r4, pc}
    2218:	401f4400 	.word	0x401f4400
    221c:	0098967f 	.word	0x0098967f
    2220:	20001de8 	.word	0x20001de8

00002224 <rx_event>:
static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    2224:	4a0a      	ldr	r2, [pc, #40]	; (2250 <rx_event+0x2c>)
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
    2226:	b410      	push	{r4}
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    2228:	7813      	ldrb	r3, [r2, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
    222a:	69c4      	ldr	r4, [r0, #28]
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    222c:	3301      	adds	r3, #1
    222e:	2b04      	cmp	r3, #4
    2230:	d907      	bls.n	2242 <rx_event+0x1e>
    2232:	2100      	movs	r1, #0
	rx_list[head] = i;
    2234:	4807      	ldr	r0, [pc, #28]	; (2254 <rx_event+0x30>)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    2236:	460b      	mov	r3, r1
	rx_list[head] = i;
	rx_head = head;
    2238:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    223a:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    223c:	f85d 4b04 	ldr.w	r4, [sp], #4
    2240:	4770      	bx	lr
    2242:	b2d9      	uxtb	r1, r3
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    2244:	4803      	ldr	r0, [pc, #12]	; (2254 <rx_event+0x30>)
	rx_head = head;
    2246:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    2248:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    224a:	f85d 4b04 	ldr.w	r4, [sp], #4
    224e:	4770      	bx	lr
    2250:	20002753 	.word	0x20002753
    2254:	20002714 	.word	0x20002714

00002258 <rx_queue_transfer>:
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
    2258:	4912      	ldr	r1, [pc, #72]	; (22a4 <rx_queue_transfer+0x4c>)
    225a:	eb01 1180 	add.w	r1, r1, r0, lsl #6
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    225e:	b538      	push	{r3, r4, r5, lr}
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    2260:	f021 021f 	bic.w	r2, r1, #31
    2264:	4603      	mov	r3, r0
	uint32_t end_addr = (uint32_t)addr + size;
    2266:	f101 0540 	add.w	r5, r1, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    226a:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    226e:	4c0e      	ldr	r4, [pc, #56]	; (22a8 <rx_queue_transfer+0x50>)
    2270:	6022      	str	r2, [r4, #0]
		location += 32;
    2272:	3220      	adds	r2, #32
	} while (location < end_addr);
    2274:	4295      	cmp	r5, r2
    2276:	d8fb      	bhi.n	2270 <rx_queue_transfer+0x18>
	asm("dsb");
    2278:	f3bf 8f4f 	dsb	sy
	asm("isb");
    227c:	f3bf 8f6f 	isb	sy
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    2280:	4c0a      	ldr	r4, [pc, #40]	; (22ac <rx_queue_transfer+0x54>)
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    2282:	f44f 3500 	mov.w	r5, #131072	; 0x20000
    2286:	4a0a      	ldr	r2, [pc, #40]	; (22b0 <rx_queue_transfer+0x58>)
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    2288:	eb04 1443 	add.w	r4, r4, r3, lsl #5
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    228c:	6015      	str	r5, [r2, #0]
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    228e:	2240      	movs	r2, #64	; 0x40
    2290:	4620      	mov	r0, r4
    2292:	f7ff ff5b 	bl	214c <usb_prepare_transfer>
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
    2296:	4621      	mov	r1, r4
    2298:	2004      	movs	r0, #4
    229a:	f7ff ff83 	bl	21a4 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    229e:	4b05      	ldr	r3, [pc, #20]	; (22b4 <rx_queue_transfer+0x5c>)
    22a0:	601d      	str	r5, [r3, #0]
    22a2:	bd38      	pop	{r3, r4, r5, pc}
    22a4:	20200060 	.word	0x20200060
    22a8:	e000ef5c 	.word	0xe000ef5c
    22ac:	200022e0 	.word	0x200022e0
    22b0:	e000e18c 	.word	0xe000e18c
    22b4:	e000e10c 	.word	0xe000e10c

000022b8 <usb_rawhid_configure>:


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    22b8:	2100      	movs	r1, #0
    22ba:	4816      	ldr	r0, [pc, #88]	; (2314 <usb_rawhid_configure+0x5c>)
static void rx_event(transfer_t *t);
extern volatile uint8_t usb_configuration;


void usb_rawhid_configure(void)
{
    22bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    22be:	2580      	movs	r5, #128	; 0x80
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    22c0:	460c      	mov	r4, r1
	rx_head = 0;
    22c2:	4f15      	ldr	r7, [pc, #84]	; (2318 <usb_rawhid_configure+0x60>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    22c4:	462a      	mov	r2, r5
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    22c6:	4e15      	ldr	r6, [pc, #84]	; (231c <usb_rawhid_configure+0x64>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    22c8:	f004 fa48 	bl	675c <memset>
	memset(rx_transfer, 0, sizeof(rx_transfer));
    22cc:	462a      	mov	r2, r5
    22ce:	4621      	mov	r1, r4
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
    22d0:	4d13      	ldr	r5, [pc, #76]	; (2320 <usb_rawhid_configure+0x68>)

void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
    22d2:	4814      	ldr	r0, [pc, #80]	; (2324 <usb_rawhid_configure+0x6c>)
    22d4:	f004 fa42 	bl	675c <memset>
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    22d8:	4623      	mov	r3, r4
    22da:	4622      	mov	r2, r4
    22dc:	2140      	movs	r1, #64	; 0x40
    22de:	2003      	movs	r0, #3
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
	rx_head = 0;
    22e0:	703c      	strb	r4, [r7, #0]
void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    22e2:	7034      	strb	r4, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
    22e4:	702c      	strb	r4, [r5, #0]
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    22e6:	f7ff fefd 	bl	20e4 <usb_config_tx>
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
    22ea:	4622      	mov	r2, r4
    22ec:	4b0e      	ldr	r3, [pc, #56]	; (2328 <usb_rawhid_configure+0x70>)
    22ee:	2140      	movs	r1, #64	; 0x40
    22f0:	2004      	movs	r0, #4
    22f2:	f7ff fec5 	bl	2080 <usb_config_rx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    22f6:	4620      	mov	r0, r4
    22f8:	f7ff ffae 	bl	2258 <rx_queue_transfer>
    22fc:	2001      	movs	r0, #1
    22fe:	f7ff ffab 	bl	2258 <rx_queue_transfer>
    2302:	2002      	movs	r0, #2
    2304:	f7ff ffa8 	bl	2258 <rx_queue_transfer>
    2308:	2003      	movs	r0, #3
}
    230a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    230e:	f7ff bfa3 	b.w	2258 <rx_queue_transfer>
    2312:	bf00      	nop
    2314:	20002460 	.word	0x20002460
    2318:	20002753 	.word	0x20002753
    231c:	20002759 	.word	0x20002759
    2320:	20002755 	.word	0x20002755
    2324:	200022e0 	.word	0x200022e0
    2328:	00002225 	.word	0x00002225

0000232c <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    232c:	b570      	push	{r4, r5, r6, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    232e:	0141      	lsls	r1, r0, #5
    2330:	4c12      	ldr	r4, [pc, #72]	; (237c <rx_queue_transfer+0x50>)
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    2332:	4d13      	ldr	r5, [pc, #76]	; (2380 <rx_queue_transfer+0x54>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    2334:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    2336:	440c      	add	r4, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    2338:	f44f 3600 	mov.w	r6, #131072	; 0x20000
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    233c:	440d      	add	r5, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    233e:	4811      	ldr	r0, [pc, #68]	; (2384 <rx_queue_transfer+0x58>)
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    2340:	4621      	mov	r1, r4
    2342:	2220      	movs	r2, #32
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    2344:	6006      	str	r6, [r0, #0]
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    2346:	4628      	mov	r0, r5
    2348:	f7ff ff00 	bl	214c <usb_prepare_transfer>
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    234c:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    2350:	f104 0120 	add.w	r1, r4, #32
	asm volatile("": : :"memory");
	asm("dsb");
    2354:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    2358:	4a0b      	ldr	r2, [pc, #44]	; (2388 <rx_queue_transfer+0x5c>)
    235a:	6013      	str	r3, [r2, #0]
		location += 32;
    235c:	3320      	adds	r3, #32
	} while (location < end_addr);
    235e:	4299      	cmp	r1, r3
    2360:	d8fb      	bhi.n	235a <rx_queue_transfer+0x2e>
	asm("dsb");
    2362:	f3bf 8f4f 	dsb	sy
	asm("isb");
    2366:	f3bf 8f6f 	isb	sy
	arm_dcache_delete(buffer, SEREMU_RX_SIZE);
	usb_receive(SEREMU_RX_ENDPOINT, rx_transfer + i);
    236a:	2002      	movs	r0, #2
    236c:	4629      	mov	r1, r5
    236e:	f7ff ff19 	bl	21a4 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    2372:	4b06      	ldr	r3, [pc, #24]	; (238c <rx_queue_transfer+0x60>)
    2374:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    2378:	601a      	str	r2, [r3, #0]
    237a:	bd70      	pop	{r4, r5, r6, pc}
    237c:	20200260 	.word	0x20200260
    2380:	20002360 	.word	0x20002360
    2384:	e000e18c 	.word	0xe000e18c
    2388:	e000ef5c 	.word	0xe000ef5c
    238c:	e000e10c 	.word	0xe000e10c

00002390 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
    2390:	6843      	ldr	r3, [r0, #4]
	int i = t->callback_param;
    2392:	69c0      	ldr	r0, [r0, #28]
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    2394:	f3c3 430e 	ubfx	r3, r3, #16, #15
    2398:	b10b      	cbz	r3, 239e <rx_event+0xe>
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
    239a:	f7ff bfc7 	b.w	232c <rx_queue_transfer>
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    239e:	490d      	ldr	r1, [pc, #52]	; (23d4 <rx_event+0x44>)
    23a0:	0142      	lsls	r2, r0, #5
    23a2:	5c8a      	ldrb	r2, [r1, r2]
    23a4:	2a00      	cmp	r2, #0
    23a6:	d0f8      	beq.n	239a <rx_event+0xa>
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
    23a8:	490b      	ldr	r1, [pc, #44]	; (23d8 <rx_event+0x48>)
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
    23aa:	b410      	push	{r4}
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    23ac:	4c0b      	ldr	r4, [pc, #44]	; (23dc <rx_event+0x4c>)
		rx_index[i] = 0;
    23ae:	f821 3010 	strh.w	r3, [r1, r0, lsl #1]
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    23b2:	7822      	ldrb	r2, [r4, #0]
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
    23b4:	490a      	ldr	r1, [pc, #40]	; (23e0 <rx_event+0x50>)
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    23b6:	3201      	adds	r2, #1
    23b8:	2a08      	cmp	r2, #8
    23ba:	bf94      	ite	ls
    23bc:	b2d3      	uxtbls	r3, r2
    23be:	461a      	movhi	r2, r3
		rx_list[head] = i;
		rx_head = head;
    23c0:	7023      	strb	r3, [r4, #0]
		rx_available += len;
    23c2:	680b      	ldr	r3, [r1, #0]
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    23c4:	4c07      	ldr	r4, [pc, #28]	; (23e4 <rx_event+0x54>)
		rx_head = head;
		rx_available += len;
    23c6:	3320      	adds	r3, #32
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    23c8:	54a0      	strb	r0, [r4, r2]
		rx_head = head;
		rx_available += len;
    23ca:	600b      	str	r3, [r1, #0]
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
	}
}
    23cc:	f85d 4b04 	ldr.w	r4, [sp], #4
    23d0:	4770      	bx	lr
    23d2:	bf00      	nop
    23d4:	20200260 	.word	0x20200260
    23d8:	20002704 	.word	0x20002704
    23dc:	20002754 	.word	0x20002754
    23e0:	20002700 	.word	0x20002700
    23e4:	2000271c 	.word	0x2000271c

000023e8 <usb_seremu_configure>:


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    23e8:	2100      	movs	r1, #0
    23ea:	f44f 72c0 	mov.w	r2, #384	; 0x180
    23ee:	481f      	ldr	r0, [pc, #124]	; (246c <usb_seremu_configure+0x84>)
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_seremu_configure(void)
{
    23f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    23f2:	460d      	mov	r5, r1
    23f4:	4c1e      	ldr	r4, [pc, #120]	; (2470 <usb_seremu_configure+0x88>)


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    23f6:	f004 f9b1 	bl	675c <memset>
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    23fa:	4e1e      	ldr	r6, [pc, #120]	; (2474 <usb_seremu_configure+0x8c>)
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    23fc:	4b1e      	ldr	r3, [pc, #120]	; (2478 <usb_seremu_configure+0x90>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    23fe:	4629      	mov	r1, r5
    2400:	f44f 7280 	mov.w	r2, #256	; 0x100
    2404:	481d      	ldr	r0, [pc, #116]	; (247c <usb_seremu_configure+0x94>)

void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    2406:	7025      	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    2408:	462c      	mov	r4, r5
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    240a:	801d      	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    240c:	f004 f9a6 	bl	675c <memset>
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    2410:	7035      	strb	r5, [r6, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    2412:	462a      	mov	r2, r5
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    2414:	4e1a      	ldr	r6, [pc, #104]	; (2480 <usb_seremu_configure+0x98>)
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    2416:	2120      	movs	r1, #32
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    2418:	4b1a      	ldr	r3, [pc, #104]	; (2484 <usb_seremu_configure+0x9c>)
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    241a:	2002      	movs	r0, #2
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    241c:	4f1a      	ldr	r7, [pc, #104]	; (2488 <usb_seremu_configure+0xa0>)
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    241e:	701d      	strb	r5, [r3, #0]
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    2420:	6035      	str	r5, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    2422:	4b1a      	ldr	r3, [pc, #104]	; (248c <usb_seremu_configure+0xa4>)
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    2424:	6075      	str	r5, [r6, #4]
    2426:	60b5      	str	r5, [r6, #8]
    2428:	60f5      	str	r5, [r6, #12]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    242a:	603d      	str	r5, [r7, #0]
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    242c:	f7ff fe28 	bl	2080 <usb_config_rx>
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
    2430:	462b      	mov	r3, r5
    2432:	462a      	mov	r2, r5
    2434:	2140      	movs	r1, #64	; 0x40
    2436:	2002      	movs	r0, #2
    2438:	f7ff fe54 	bl	20e4 <usb_config_tx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    243c:	4620      	mov	r0, r4
    243e:	3401      	adds	r4, #1
    2440:	f7ff ff74 	bl	232c <rx_queue_transfer>
    2444:	2c08      	cmp	r4, #8
    2446:	d1f9      	bne.n	243c <usb_seremu_configure+0x54>
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
	USB1_GPTIMER0CTRL = 0;
    2448:	4b11      	ldr	r3, [pc, #68]	; (2490 <usb_seremu_configure+0xa8>)
	USB1_GPTIMER0LD = microseconds - 1;
    244a:	224a      	movs	r2, #74	; 0x4a
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    244c:	4811      	ldr	r0, [pc, #68]	; (2494 <usb_seremu_configure+0xac>)
	USB1_GPTIMER0CTRL = 0;
    244e:	2100      	movs	r1, #0
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    2450:	4c11      	ldr	r4, [pc, #68]	; (2498 <usb_seremu_configure+0xb0>)
    2452:	6004      	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    2454:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    2458:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    245c:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    2460:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    2464:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    2468:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    246a:	bf00      	nop
    246c:	200024e0 	.word	0x200024e0
    2470:	2000275a 	.word	0x2000275a
    2474:	20002754 	.word	0x20002754
    2478:	2000274c 	.word	0x2000274c
    247c:	20002360 	.word	0x20002360
    2480:	20002704 	.word	0x20002704
    2484:	20002756 	.word	0x20002756
    2488:	20002700 	.word	0x20002700
    248c:	00002391 	.word	0x00002391
    2490:	402e0000 	.word	0x402e0000
    2494:	20002744 	.word	0x20002744
    2498:	00002605 	.word	0x00002605

0000249c <usb_seremu_getchar>:
	}
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
    249c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t tail = rx_tail;
    249e:	4d14      	ldr	r5, [pc, #80]	; (24f0 <usb_seremu_getchar+0x54>)

	if (tail == rx_head) return -1;
    24a0:	4a14      	ldr	r2, [pc, #80]	; (24f4 <usb_seremu_getchar+0x58>)
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    24a2:	782b      	ldrb	r3, [r5, #0]

	if (tail == rx_head) return -1;
    24a4:	7812      	ldrb	r2, [r2, #0]
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    24a6:	b2db      	uxtb	r3, r3

	if (tail == rx_head) return -1;
    24a8:	4293      	cmp	r3, r2
    24aa:	d01d      	beq.n	24e8 <usb_seremu_getchar+0x4c>
	if (++tail > RX_NUM) tail = 0;
    24ac:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    24ae:	4a12      	ldr	r2, [pc, #72]	; (24f8 <usb_seremu_getchar+0x5c>)
	uint32_t index = rx_index[i];
    24b0:	4e12      	ldr	r6, [pc, #72]	; (24fc <usb_seremu_getchar+0x60>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    24b2:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    24b4:	4c12      	ldr	r4, [pc, #72]	; (2500 <usb_seremu_getchar+0x64>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    24b6:	bf28      	it	cs
    24b8:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    24ba:	5cd0      	ldrb	r0, [r2, r3]
	uint32_t index = rx_index[i];
    24bc:	f836 2010 	ldrh.w	r2, [r6, r0, lsl #1]
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    24c0:	eb02 1140 	add.w	r1, r2, r0, lsl #5
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    24c4:	3201      	adds	r2, #1
    24c6:	2a1f      	cmp	r2, #31

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    24c8:	eb04 0701 	add.w	r7, r4, r1
	int c = *p;
    24cc:	5c64      	ldrb	r4, [r4, r1]
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    24ce:	d805      	bhi.n	24dc <usb_seremu_getchar+0x40>
    24d0:	7879      	ldrb	r1, [r7, #1]
    24d2:	b119      	cbz	r1, 24dc <usb_seremu_getchar+0x40>
		rx_tail = tail;
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
    24d4:	f826 2010 	strh.w	r2, [r6, r0, lsl #1]
	}
	return c;
    24d8:	4620      	mov	r0, r4
    24da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
    24dc:	b2db      	uxtb	r3, r3
    24de:	702b      	strb	r3, [r5, #0]
		rx_queue_transfer(i);
    24e0:	f7ff ff24 	bl	232c <rx_queue_transfer>
	} else {
		rx_index[i] = index;
	}
	return c;
    24e4:	4620      	mov	r0, r4
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
		rx_queue_transfer(i);
    24e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
    24e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
	}
	return c;
}
    24ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    24ee:	bf00      	nop
    24f0:	20002756 	.word	0x20002756
    24f4:	20002754 	.word	0x20002754
    24f8:	2000271c 	.word	0x2000271c
    24fc:	20002704 	.word	0x20002704
    2500:	20200260 	.word	0x20200260

00002504 <usb_seremu_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    2504:	4b0b      	ldr	r3, [pc, #44]	; (2534 <usb_seremu_peekchar+0x30>)
	if (tail == rx_head) return -1;
    2506:	4a0c      	ldr	r2, [pc, #48]	; (2538 <usb_seremu_peekchar+0x34>)
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    2508:	781b      	ldrb	r3, [r3, #0]
	if (tail == rx_head) return -1;
    250a:	7812      	ldrb	r2, [r2, #0]
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    250c:	b2db      	uxtb	r3, r3
	if (tail == rx_head) return -1;
    250e:	4293      	cmp	r3, r2
    2510:	d00d      	beq.n	252e <usb_seremu_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    2512:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    2514:	4a09      	ldr	r2, [pc, #36]	; (253c <usb_seremu_peekchar+0x38>)
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    2516:	480a      	ldr	r0, [pc, #40]	; (2540 <usb_seremu_peekchar+0x3c>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    2518:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    251a:	490a      	ldr	r1, [pc, #40]	; (2544 <usb_seremu_peekchar+0x40>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    251c:	bf28      	it	cs
    251e:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    2520:	5cd2      	ldrb	r2, [r2, r3]
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    2522:	f830 3012 	ldrh.w	r3, [r0, r2, lsl #1]
    2526:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    252a:	5cc8      	ldrb	r0, [r1, r3]
    252c:	4770      	bx	lr

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
    252e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
}
    2532:	4770      	bx	lr
    2534:	20002756 	.word	0x20002756
    2538:	20002754 	.word	0x20002754
    253c:	2000271c 	.word	0x2000271c
    2540:	20002704 	.word	0x20002704
    2544:	20200260 	.word	0x20200260

00002548 <usb_seremu_available>:

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
    2548:	b508      	push	{r3, lr}
	uint32_t tail = rx_tail;
    254a:	4a06      	ldr	r2, [pc, #24]	; (2564 <usb_seremu_available+0x1c>)
	if (tail == rx_head) {
    254c:	4b06      	ldr	r3, [pc, #24]	; (2568 <usb_seremu_available+0x20>)
}

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
    254e:	7812      	ldrb	r2, [r2, #0]
	if (tail == rx_head) {
    2550:	781b      	ldrb	r3, [r3, #0]
    2552:	429a      	cmp	r2, r3
    2554:	d001      	beq.n	255a <usb_seremu_available+0x12>
		yield();
		return 0;
	}
	// TODO: how much is actually available?
	return 1;
    2556:	2001      	movs	r0, #1
}
    2558:	bd08      	pop	{r3, pc}
// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) {
		yield();
    255a:	f000 fa6d 	bl	2a38 <yield>
		return 0;
    255e:	2000      	movs	r0, #0
    2560:	bd08      	pop	{r3, pc}
    2562:	bf00      	nop
    2564:	20002756 	.word	0x20002756
    2568:	20002754 	.word	0x20002754

0000256c <tx_zero_pad>:
	USB1_GPTIMER0CTRL = 0;
}


void tx_zero_pad(void)
{
    256c:	b538      	push	{r3, r4, r5, lr}
	if (!tx_available) return;
    256e:	4c08      	ldr	r4, [pc, #32]	; (2590 <tx_zero_pad+0x24>)
    2570:	8822      	ldrh	r2, [r4, #0]
    2572:	b162      	cbz	r2, 258e <tx_zero_pad+0x22>
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    2574:	4907      	ldr	r1, [pc, #28]	; (2594 <tx_zero_pad+0x28>)
	memset(txdata, 0, tx_available);
    2576:	f1c2 0340 	rsb	r3, r2, #64	; 0x40
    257a:	4807      	ldr	r0, [pc, #28]	; (2598 <tx_zero_pad+0x2c>)


void tx_zero_pad(void)
{
	if (!tx_available) return;
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    257c:	780d      	ldrb	r5, [r1, #0]
	memset(txdata, 0, tx_available);
    257e:	2100      	movs	r1, #0
    2580:	eb03 1385 	add.w	r3, r3, r5, lsl #6
    2584:	4418      	add	r0, r3
    2586:	f004 f8e9 	bl	675c <memset>
	tx_available = 0;
    258a:	2300      	movs	r3, #0
    258c:	8023      	strh	r3, [r4, #0]
    258e:	bd38      	pop	{r3, r4, r5, pc}
    2590:	2000274c 	.word	0x2000274c
    2594:	2000275a 	.word	0x2000275a
    2598:	20200360 	.word	0x20200360

0000259c <tx_queue_transfer>:
}

void tx_queue_transfer(void)
{
    259c:	b570      	push	{r4, r5, r6, lr}
	transfer_t *xfer = tx_transfer + tx_head;
    259e:	4e15      	ldr	r6, [pc, #84]	; (25f4 <tx_queue_transfer+0x58>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    25a0:	2300      	movs	r3, #0
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    25a2:	4d15      	ldr	r5, [pc, #84]	; (25f8 <tx_queue_transfer+0x5c>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    25a4:	2240      	movs	r2, #64	; 0x40
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    25a6:	7831      	ldrb	r1, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    25a8:	4c14      	ldr	r4, [pc, #80]	; (25fc <tx_queue_transfer+0x60>)
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    25aa:	eb05 1541 	add.w	r5, r5, r1, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    25ae:	eb04 1481 	add.w	r4, r4, r1, lsl #6
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    25b2:	4628      	mov	r0, r5
    25b4:	4621      	mov	r1, r4
    25b6:	f7ff fdc9 	bl	214c <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    25ba:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    25be:	f104 0140 	add.w	r1, r4, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    25c2:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    25c6:	4a0e      	ldr	r2, [pc, #56]	; (2600 <tx_queue_transfer+0x64>)
    25c8:	6013      	str	r3, [r2, #0]
		location += 32;
    25ca:	3320      	adds	r3, #32
	} while (location < end_addr);
    25cc:	4299      	cmp	r1, r3
    25ce:	d8fb      	bhi.n	25c8 <tx_queue_transfer+0x2c>
	asm("dsb");
    25d0:	f3bf 8f4f 	dsb	sy
	asm("isb");
    25d4:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
    25d8:	2002      	movs	r0, #2
    25da:	4629      	mov	r1, r5
    25dc:	f7ff fdce 	bl	217c <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    25e0:	7833      	ldrb	r3, [r6, #0]
    25e2:	4a04      	ldr	r2, [pc, #16]	; (25f4 <tx_queue_transfer+0x58>)
    25e4:	3301      	adds	r3, #1
    25e6:	b2db      	uxtb	r3, r3
    25e8:	2b0b      	cmp	r3, #11
    25ea:	bf88      	it	hi
    25ec:	2300      	movhi	r3, #0
    25ee:	7013      	strb	r3, [r2, #0]
    25f0:	bd70      	pop	{r4, r5, r6, pc}
    25f2:	bf00      	nop
    25f4:	2000275a 	.word	0x2000275a
    25f8:	200024e0 	.word	0x200024e0
    25fc:	20200360 	.word	0x20200360
    2600:	e000ef70 	.word	0xe000ef70

00002604 <usb_seremu_flush_callback>:
	timer_stop();
	tx_noautoflush = 0;
}

static void usb_seremu_flush_callback(void)
{
    2604:	b508      	push	{r3, lr}
	if (tx_noautoflush) return;
    2606:	4b08      	ldr	r3, [pc, #32]	; (2628 <usb_seremu_flush_callback+0x24>)
    2608:	781b      	ldrb	r3, [r3, #0]
    260a:	b92b      	cbnz	r3, 2618 <usb_seremu_flush_callback+0x14>
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
    260c:	4b07      	ldr	r3, [pc, #28]	; (262c <usb_seremu_flush_callback+0x28>)
    260e:	881b      	ldrh	r3, [r3, #0]
    2610:	3b01      	subs	r3, #1
    2612:	b29b      	uxth	r3, r3
    2614:	2b3e      	cmp	r3, #62	; 0x3e
    2616:	d900      	bls.n	261a <usb_seremu_flush_callback+0x16>
    2618:	bd08      	pop	{r3, pc}
	tx_zero_pad();
    261a:	f7ff ffa7 	bl	256c <tx_zero_pad>
	tx_queue_transfer();
}
    261e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
static void usb_seremu_flush_callback(void)
{
	if (tx_noautoflush) return;
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
	tx_zero_pad();
	tx_queue_transfer();
    2622:	f7ff bfbb 	b.w	259c <tx_queue_transfer>
    2626:	bf00      	nop
    2628:	2000275b 	.word	0x2000275b
    262c:	2000274c 	.word	0x2000274c

00002630 <usb_seremu_write.part.1>:
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
	if (++tx_head >= TX_NUM) tx_head = 0;
}

int usb_seremu_write(const void *buffer, uint32_t size)
    2630:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2634:	b085      	sub	sp, #20
    2636:	9002      	str	r0, [sp, #8]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2638:	9100      	str	r1, [sp, #0]
    263a:	2900      	cmp	r1, #0
    263c:	f000 8084 	beq.w	2748 <usb_seremu_write.part.1+0x118>
    2640:	2300      	movs	r3, #0
    2642:	4f42      	ldr	r7, [pc, #264]	; (274c <usb_seremu_write.part.1+0x11c>)
    2644:	f8df 8120 	ldr.w	r8, [pc, #288]	; 2768 <usb_seremu_write.part.1+0x138>
    2648:	f8df a110 	ldr.w	sl, [pc, #272]	; 275c <usb_seremu_write.part.1+0x12c>
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
    264c:	4e40      	ldr	r6, [pc, #256]	; (2750 <usb_seremu_write.part.1+0x120>)
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    264e:	f8df b11c 	ldr.w	fp, [pc, #284]	; 276c <usb_seremu_write.part.1+0x13c>
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2652:	9301      	str	r3, [sp, #4]
		tx_noautoflush = 1;
    2654:	2101      	movs	r1, #1
		transfer_t *xfer = tx_transfer + tx_head;
    2656:	4b3f      	ldr	r3, [pc, #252]	; (2754 <usb_seremu_write.part.1+0x124>)
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
    2658:	7039      	strb	r1, [r7, #0]
		transfer_t *xfer = tx_transfer + tx_head;
    265a:	781a      	ldrb	r2, [r3, #0]
    265c:	493e      	ldr	r1, [pc, #248]	; (2758 <usb_seremu_write.part.1+0x128>)
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    265e:	f8b8 3000 	ldrh.w	r3, [r8]
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
    2662:	eb01 1942 	add.w	r9, r1, r2, lsl #5
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    2666:	bb0b      	cbnz	r3, 26ac <usb_seremu_write.part.1+0x7c>
    2668:	461d      	mov	r5, r3
    266a:	461c      	mov	r4, r3
			uint32_t status = usb_transfer_status(xfer);
    266c:	4648      	mov	r0, r9
    266e:	f7ff fdab 	bl	21c8 <usb_transfer_status>
			if (!(status & 0x80)) {
    2672:	f010 0080 	ands.w	r0, r0, #128	; 0x80
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    2676:	f04f 0300 	mov.w	r3, #0
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    267a:	4938      	ldr	r1, [pc, #224]	; (275c <usb_seremu_write.part.1+0x12c>)
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
			uint32_t status = usb_transfer_status(xfer);
			if (!(status & 0x80)) {
    267c:	d056      	beq.n	272c <usb_seremu_write.part.1+0xfc>
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    267e:	f89a 2000 	ldrb.w	r2, [sl]
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    2682:	703b      	strb	r3, [r7, #0]
			if (!waiting) {
    2684:	b904      	cbnz	r4, 2688 <usb_seremu_write.part.1+0x58>
				wait_begin_at = systick_millis_count;
    2686:	6835      	ldr	r5, [r6, #0]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2688:	2a00      	cmp	r2, #0
    268a:	d134      	bne.n	26f6 <usb_seremu_write.part.1+0xc6>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    268c:	6833      	ldr	r3, [r6, #0]
    268e:	2401      	movs	r4, #1
    2690:	1b5b      	subs	r3, r3, r5
    2692:	2b32      	cmp	r3, #50	; 0x32
    2694:	d853      	bhi.n	273e <usb_seremu_write.part.1+0x10e>
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    2696:	f89b 3000 	ldrb.w	r3, [fp]
    269a:	b363      	cbz	r3, 26f6 <usb_seremu_write.part.1+0xc6>
			yield();
    269c:	f000 f9cc 	bl	2a38 <yield>
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    26a0:	f8b8 3000 	ldrh.w	r3, [r8]
    26a4:	2b00      	cmp	r3, #0
    26a6:	d0e1      	beq.n	266c <usb_seremu_write.part.1+0x3c>
    26a8:	4a2a      	ldr	r2, [pc, #168]	; (2754 <usb_seremu_write.part.1+0x124>)
    26aa:	7812      	ldrb	r2, [r2, #0]
    26ac:	461c      	mov	r4, r3
    26ae:	f1c3 0040 	rsb	r0, r3, #64	; 0x40
				return sent;
			}
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    26b2:	eb00 1082 	add.w	r0, r0, r2, lsl #6
    26b6:	4a2a      	ldr	r2, [pc, #168]	; (2760 <usb_seremu_write.part.1+0x130>)
    26b8:	4410      	add	r0, r2
		if (size >= tx_available) {
    26ba:	9a00      	ldr	r2, [sp, #0]
    26bc:	42a2      	cmp	r2, r4
    26be:	d31e      	bcc.n	26fe <usb_seremu_write.part.1+0xce>
			memcpy(txdata, data, tx_available);
			size -= tx_available;
    26c0:	9b00      	ldr	r3, [sp, #0]
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    26c2:	2500      	movs	r5, #0
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    26c4:	f8dd 9008 	ldr.w	r9, [sp, #8]
    26c8:	4622      	mov	r2, r4
			size -= tx_available;
    26ca:	1b1b      	subs	r3, r3, r4
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    26cc:	4649      	mov	r1, r9
			size -= tx_available;
    26ce:	9300      	str	r3, [sp, #0]
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    26d0:	f003 ff46 	bl	6560 <memcpy>
			size -= tx_available;
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    26d4:	f8a8 5000 	strh.w	r5, [r8]
			tx_queue_transfer();
    26d8:	f7ff ff60 	bl	259c <tx_queue_transfer>
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    26dc:	9a01      	ldr	r2, [sp, #4]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    26de:	4b21      	ldr	r3, [pc, #132]	; (2764 <usb_seremu_write.part.1+0x134>)
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    26e0:	4422      	add	r2, r4
    26e2:	9201      	str	r2, [sp, #4]
			data += tx_available;
    26e4:	464a      	mov	r2, r9
    26e6:	4422      	add	r2, r4
    26e8:	9202      	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    26ea:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    26ee:	9b00      	ldr	r3, [sp, #0]
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    26f0:	703d      	strb	r5, [r7, #0]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    26f2:	2b00      	cmp	r3, #0
    26f4:	d1ae      	bne.n	2654 <usb_seremu_write.part.1+0x24>
    26f6:	9801      	ldr	r0, [sp, #4]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    26f8:	b005      	add	sp, #20
    26fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    26fe:	9d00      	ldr	r5, [sp, #0]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2700:	f04f 4440 	mov.w	r4, #3221225472	; 0xc0000000
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    2704:	9902      	ldr	r1, [sp, #8]
    2706:	462a      	mov	r2, r5
    2708:	9303      	str	r3, [sp, #12]
    270a:	f003 ff29 	bl	6560 <memcpy>
			tx_available -= size;
    270e:	9b03      	ldr	r3, [sp, #12]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2710:	4914      	ldr	r1, [pc, #80]	; (2764 <usb_seremu_write.part.1+0x134>)
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    2712:	2200      	movs	r2, #0
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
			tx_available -= size;
    2714:	1b5b      	subs	r3, r3, r5
    2716:	f8a8 3000 	strh.w	r3, [r8]
    271a:	9b01      	ldr	r3, [sp, #4]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    271c:	f8c1 4084 	str.w	r4, [r1, #132]	; 0x84
    2720:	4618      	mov	r0, r3
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    2722:	703a      	strb	r2, [r7, #0]
    2724:	4428      	add	r0, r5
	}
	return sent;
}
    2726:	b005      	add	sp, #20
    2728:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    272c:	2340      	movs	r3, #64	; 0x40
    272e:	4a09      	ldr	r2, [pc, #36]	; (2754 <usb_seremu_write.part.1+0x124>)
				transmit_previous_timeout = 0;
    2730:	f88a 0000 	strb.w	r0, [sl]
    2734:	7812      	ldrb	r2, [r2, #0]
    2736:	461c      	mov	r4, r3
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    2738:	f8a8 3000 	strh.w	r3, [r8]
    273c:	e7b9      	b.n	26b2 <usb_seremu_write.part.1+0x82>
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
    273e:	9801      	ldr	r0, [sp, #4]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    2740:	700c      	strb	r4, [r1, #0]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    2742:	b005      	add	sp, #20
    2744:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2748:	9800      	ldr	r0, [sp, #0]
    274a:	e7d5      	b.n	26f8 <usb_seremu_write.part.1+0xc8>
    274c:	2000275b 	.word	0x2000275b
    2750:	20002740 	.word	0x20002740
    2754:	2000275a 	.word	0x2000275a
    2758:	200024e0 	.word	0x200024e0
    275c:	20002758 	.word	0x20002758
    2760:	20200360 	.word	0x20200360
    2764:	402e0000 	.word	0x402e0000
    2768:	2000274c 	.word	0x2000274c
    276c:	2000275c 	.word	0x2000275c

00002770 <usb_seremu_putchar>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2770:	4b09      	ldr	r3, [pc, #36]	; (2798 <usb_seremu_putchar+0x28>)
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    2772:	b500      	push	{lr}
    2774:	b083      	sub	sp, #12
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2776:	781b      	ldrb	r3, [r3, #0]
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    2778:	f88d 0007 	strb.w	r0, [sp, #7]
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    277c:	b923      	cbnz	r3, 2788 <usb_seremu_putchar+0x18>
    277e:	f003 00ff 	and.w	r0, r3, #255	; 0xff

// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
	return usb_seremu_write(&c, 1);
}
    2782:	b003      	add	sp, #12
    2784:	f85d fb04 	ldr.w	pc, [sp], #4
    2788:	2101      	movs	r1, #1
    278a:	f10d 0007 	add.w	r0, sp, #7
    278e:	f7ff ff4f 	bl	2630 <usb_seremu_write.part.1>
    2792:	b003      	add	sp, #12
    2794:	f85d fb04 	ldr.w	pc, [sp], #4
    2798:	2000275c 	.word	0x2000275c

0000279c <usb_seremu_write>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    279c:	4b04      	ldr	r3, [pc, #16]	; (27b0 <usb_seremu_write+0x14>)
    279e:	781b      	ldrb	r3, [r3, #0]
    27a0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    27a4:	b10b      	cbz	r3, 27aa <usb_seremu_write+0xe>
    27a6:	f7ff bf43 	b.w	2630 <usb_seremu_write.part.1>
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    27aa:	4610      	mov	r0, r2
    27ac:	4770      	bx	lr
    27ae:	bf00      	nop
    27b0:	2000275c 	.word	0x2000275c

000027b4 <usb_seremu_write_buffer_free>:

int usb_seremu_write_buffer_free(void)
{
	return 1;
}
    27b4:	2001      	movs	r0, #1
    27b6:	4770      	bx	lr

000027b8 <usb_seremu_flush_output>:

void usb_seremu_flush_output(void)
{
	if (!usb_configuration) return;
    27b8:	4b0a      	ldr	r3, [pc, #40]	; (27e4 <usb_seremu_flush_output+0x2c>)
    27ba:	781b      	ldrb	r3, [r3, #0]
    27bc:	b113      	cbz	r3, 27c4 <usb_seremu_flush_output+0xc>
	if (tx_available == 0) return;
    27be:	4b0a      	ldr	r3, [pc, #40]	; (27e8 <usb_seremu_flush_output+0x30>)
    27c0:	881b      	ldrh	r3, [r3, #0]
    27c2:	b903      	cbnz	r3, 27c6 <usb_seremu_flush_output+0xe>
    27c4:	4770      	bx	lr
{
	return 1;
}

void usb_seremu_flush_output(void)
{
    27c6:	b510      	push	{r4, lr}
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    27c8:	2301      	movs	r3, #1
    27ca:	4c08      	ldr	r4, [pc, #32]	; (27ec <usb_seremu_flush_output+0x34>)
    27cc:	7023      	strb	r3, [r4, #0]
	tx_zero_pad();
    27ce:	f7ff fecd 	bl	256c <tx_zero_pad>
	tx_queue_transfer();
    27d2:	f7ff fee3 	bl	259c <tx_queue_transfer>
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    27d6:	2300      	movs	r3, #0
    27d8:	4a05      	ldr	r2, [pc, #20]	; (27f0 <usb_seremu_flush_output+0x38>)
    27da:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	tx_zero_pad();
	tx_queue_transfer();
	timer_stop();
	tx_noautoflush = 0;
    27de:	7023      	strb	r3, [r4, #0]
    27e0:	bd10      	pop	{r4, pc}
    27e2:	bf00      	nop
    27e4:	2000275c 	.word	0x2000275c
    27e8:	2000274c 	.word	0x2000274c
    27ec:	2000275b 	.word	0x2000275b
    27f0:	402e0000 	.word	0x402e0000

000027f4 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    27f4:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    27f6:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    27fa:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    27fc:	4c0c      	ldr	r4, [pc, #48]	; (2830 <EventResponder::runFromInterrupt()+0x3c>)
    27fe:	6823      	ldr	r3, [r4, #0]
		if (first) {
    2800:	b18b      	cbz	r3, 2826 <EventResponder::runFromInterrupt()+0x32>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    2802:	4e0c      	ldr	r6, [pc, #48]	; (2834 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    2804:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    2806:	695a      	ldr	r2, [r3, #20]
    2808:	6022      	str	r2, [r4, #0]
			if (firstInterrupt) {
    280a:	b17a      	cbz	r2, 282c <EventResponder::runFromInterrupt()+0x38>
				firstInterrupt->_prev = nullptr;
    280c:	6195      	str	r5, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    280e:	b901      	cbnz	r1, 2812 <EventResponder::runFromInterrupt()+0x1e>
    2810:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    2812:	775d      	strb	r5, [r3, #29]
			(*(first->_function))(*first);
    2814:	4618      	mov	r0, r3
    2816:	689b      	ldr	r3, [r3, #8]
    2818:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    281a:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    281e:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2820:	6823      	ldr	r3, [r4, #0]
		if (first) {
    2822:	2b00      	cmp	r3, #0
    2824:	d1ef      	bne.n	2806 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2826:	b901      	cbnz	r1, 282a <EventResponder::runFromInterrupt()+0x36>
    2828:	b662      	cpsie	i
    282a:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    282c:	6032      	str	r2, [r6, #0]
    282e:	e7ee      	b.n	280e <EventResponder::runFromInterrupt()+0x1a>
    2830:	2000268c 	.word	0x2000268c
    2834:	20002688 	.word	0x20002688

00002838 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    2838:	f7ff bfdc 	b.w	27f4 <EventResponder::runFromInterrupt()>

0000283c <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    283c:	4a04      	ldr	r2, [pc, #16]	; (2850 <systick_isr+0x14>)
    283e:	4b05      	ldr	r3, [pc, #20]	; (2854 <systick_isr+0x18>)
    2840:	6811      	ldr	r1, [r2, #0]
	systick_millis_count++;
    2842:	4a05      	ldr	r2, [pc, #20]	; (2858 <systick_isr+0x1c>)
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    2844:	6019      	str	r1, [r3, #0]
	systick_millis_count++;
    2846:	6813      	ldr	r3, [r2, #0]
    2848:	3301      	adds	r3, #1
    284a:	6013      	str	r3, [r2, #0]
    284c:	4770      	bx	lr
    284e:	bf00      	nop
    2850:	e0001004 	.word	0xe0001004
    2854:	2000273c 	.word	0x2000273c
    2858:	20002740 	.word	0x20002740

0000285c <IntervalTimer::end()>:
}


void IntervalTimer::end() {
#if 1
	if (channel) {
    285c:	6802      	ldr	r2, [r0, #0]
    285e:	b30a      	cbz	r2, 28a4 <IntervalTimer::end()+0x48>
		int index = channel - IMXRT_PIT_CHANNELS;
    2860:	4b11      	ldr	r3, [pc, #68]	; (28a8 <IntervalTimer::end()+0x4c>)
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2862:	4912      	ldr	r1, [pc, #72]	; (28ac <IntervalTimer::end()+0x50>)


void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    2864:	4413      	add	r3, r2
	NVIC_ENABLE_IRQ(IRQ_PIT);
	return true;
}


void IntervalTimer::end() {
    2866:	b5f0      	push	{r4, r5, r6, r7, lr}
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    2868:	111b      	asrs	r3, r3, #4
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    286a:	25ff      	movs	r5, #255	; 0xff
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    286c:	2400      	movs	r4, #0
    286e:	f8df e044 	ldr.w	lr, [pc, #68]	; 28b4 <IntervalTimer::end()+0x58>
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2872:	54cd      	strb	r5, [r1, r3]
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    2874:	780e      	ldrb	r6, [r1, #0]
    2876:	784d      	ldrb	r5, [r1, #1]
    2878:	2eff      	cmp	r6, #255	; 0xff
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
    287a:	6094      	str	r4, [r2, #8]
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    287c:	f84e 4023 	str.w	r4, [lr, r3, lsl #2]
    2880:	bf28      	it	cs
    2882:	26ff      	movcs	r6, #255	; 0xff
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    2884:	788a      	ldrb	r2, [r1, #2]
    2886:	78c9      	ldrb	r1, [r1, #3]
    2888:	42ae      	cmp	r6, r5
    288a:	4633      	mov	r3, r6
		}
		NVIC_SET_PRIORITY(IRQ_PIT, top_priority);
    288c:	4f08      	ldr	r7, [pc, #32]	; (28b0 <IntervalTimer::end()+0x54>)
    288e:	bf28      	it	cs
    2890:	462b      	movcs	r3, r5
    2892:	4293      	cmp	r3, r2
    2894:	bf28      	it	cs
    2896:	4613      	movcs	r3, r2
    2898:	428b      	cmp	r3, r1
    289a:	bf28      	it	cs
    289c:	460b      	movcs	r3, r1
    289e:	703b      	strb	r3, [r7, #0]
		channel = 0;
    28a0:	6004      	str	r4, [r0, #0]
    28a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    28a4:	4770      	bx	lr
    28a6:	bf00      	nop
    28a8:	bff7bf00 	.word	0xbff7bf00
    28ac:	2000180c 	.word	0x2000180c
    28b0:	e000e47a 	.word	0xe000e47a
    28b4:	200022c0 	.word	0x200022c0

000028b8 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
    28b8:	2000      	movs	r0, #0
    28ba:	4770      	bx	lr

000028bc <Print::println()>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    28bc:	b510      	push	{r4, lr}
	uint8_t buf[2]={'\r', '\n'};
    28be:	4c06      	ldr	r4, [pc, #24]	; (28d8 <Print::println()+0x1c>)
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    28c0:	b082      	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    28c2:	6803      	ldr	r3, [r0, #0]
    28c4:	2202      	movs	r2, #2
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    28c6:	8824      	ldrh	r4, [r4, #0]
	return write(buf, 2);
    28c8:	a901      	add	r1, sp, #4
    28ca:	685b      	ldr	r3, [r3, #4]
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    28cc:	f8ad 4004 	strh.w	r4, [sp, #4]
	return write(buf, 2);
    28d0:	4798      	blx	r3
}
    28d2:	b002      	add	sp, #8
    28d4:	bd10      	pop	{r4, pc}
    28d6:	bf00      	nop
    28d8:	200003f0 	.word	0x200003f0

000028dc <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
	((class Print *)file)->write((uint8_t *)ptr, len);
    28dc:	6803      	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    28de:	b510      	push	{r4, lr}
    28e0:	4614      	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    28e2:	685b      	ldr	r3, [r3, #4]
    28e4:	4798      	blx	r3
	return len;
}
    28e6:	4620      	mov	r0, r4
    28e8:	bd10      	pop	{r4, pc}
    28ea:	bf00      	nop

000028ec <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    28ec:	b40e      	push	{r1, r2, r3}
    28ee:	b500      	push	{lr}
    28f0:	b082      	sub	sp, #8
    28f2:	ab03      	add	r3, sp, #12
    28f4:	f853 1b04 	ldr.w	r1, [r3], #4
	va_start(ap, format);
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    28f8:	461a      	mov	r2, r3
}

int Print::printf(const char *format, ...)
{
	va_list ap;
	va_start(ap, format);
    28fa:	9301      	str	r3, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    28fc:	f004 fc28 	bl	7150 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    2900:	b002      	add	sp, #8
    2902:	f85d eb04 	ldr.w	lr, [sp], #4
    2906:	b003      	add	sp, #12
    2908:	4770      	bx	lr
    290a:	bf00      	nop

0000290c <IntervalTimer::~IntervalTimer()>:
private:
	static const uint32_t MAX_PERIOD = UINT32_MAX / (24000000 / 1000000);
public:
	constexpr IntervalTimer() {
	}
	~IntervalTimer() {
    290c:	b510      	push	{r4, lr}
    290e:	4604      	mov	r4, r0
		end();
    2910:	f7ff ffa4 	bl	285c <IntervalTimer::end()>
	}
    2914:	4620      	mov	r0, r4
    2916:	bd10      	pop	{r4, pc}

00002918 <_GLOBAL__sub_I__Z4tonehtm>:
static uint32_t tone_toggle_count;
static volatile uint32_t *tone_reg;
static uint32_t tone_mask;
static float tone_usec=0.0;
static uint32_t tone_new_count=0;
static IntervalTimer tone_timer;
    2918:	4a02      	ldr	r2, [pc, #8]	; (2924 <_GLOBAL__sub_I__Z4tonehtm+0xc>)
    291a:	4903      	ldr	r1, [pc, #12]	; (2928 <_GLOBAL__sub_I__Z4tonehtm+0x10>)
    291c:	4803      	ldr	r0, [pc, #12]	; (292c <_GLOBAL__sub_I__Z4tonehtm+0x14>)
    291e:	f003 b96b 	b.w	5bf8 <__aeabi_atexit>
    2922:	bf00      	nop
    2924:	20001428 	.word	0x20001428
    2928:	0000290d 	.word	0x0000290d
    292c:	20001804 	.word	0x20001804

00002930 <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    2930:	b510      	push	{r4, lr}
    2932:	4604      	mov	r4, r0
{
	free(buffer);
    2934:	6800      	ldr	r0, [r0, #0]
    2936:	f003 fb3d 	bl	5fb4 <free>
}
    293a:	4620      	mov	r0, r4
    293c:	bd10      	pop	{r4, pc}
    293e:	bf00      	nop

00002940 <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    2940:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    2942:	6843      	ldr	r3, [r0, #4]
    2944:	428b      	cmp	r3, r1
    2946:	d301      	bcc.n	294c <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2948:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    294a:	bd38      	pop	{r3, r4, r5, pc}
    294c:	460d      	mov	r5, r1
    294e:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    2950:	3101      	adds	r1, #1
    2952:	6800      	ldr	r0, [r0, #0]
    2954:	f003 ff54 	bl	6800 <realloc>
	if (newbuffer) {
    2958:	2800      	cmp	r0, #0
    295a:	d0f6      	beq.n	294a <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    295c:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    295e:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2962:	2b00      	cmp	r3, #0
    2964:	d1f0      	bne.n	2948 <String::reserve(unsigned int)+0x8>
    2966:	7003      	strb	r3, [r0, #0]
    2968:	e7ee      	b.n	2948 <String::reserve(unsigned int)+0x8>
    296a:	bf00      	nop

0000296c <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    296c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    296e:	4604      	mov	r4, r0
	if (length == 0) {
    2970:	4615      	mov	r5, r2
    2972:	b932      	cbnz	r2, 2982 <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    2974:	6803      	ldr	r3, [r0, #0]
    2976:	b103      	cbz	r3, 297a <String::copy(char const*, unsigned int)+0xe>
    2978:	701a      	strb	r2, [r3, #0]
		len = 0;
    297a:	2300      	movs	r3, #0
    297c:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    297e:	4620      	mov	r0, r4
    2980:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2982:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    2984:	4611      	mov	r1, r2
    2986:	f7ff ffdb 	bl	2940 <String::reserve(unsigned int)>
    298a:	4607      	mov	r7, r0
    298c:	b948      	cbnz	r0, 29a2 <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    298e:	6820      	ldr	r0, [r4, #0]
    2990:	b110      	cbz	r0, 2998 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    2992:	f003 fb0f 	bl	5fb4 <free>
			buffer = NULL;
    2996:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    2998:	2300      	movs	r3, #0
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    299a:	4620      	mov	r0, r4
	if (!reserve(length)) {
		if (buffer) {
			free(buffer);
			buffer = NULL;
		}
		len = capacity = 0;
    299c:	6063      	str	r3, [r4, #4]
    299e:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    29a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    29a2:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    29a4:	4631      	mov	r1, r6
    29a6:	6820      	ldr	r0, [r4, #0]
    29a8:	f004 faa8 	bl	6efc <strcpy>
	return *this;
    29ac:	e7e7      	b.n	297e <String::copy(char const*, unsigned int)+0x12>
    29ae:	bf00      	nop

000029b0 <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    29b0:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    29b2:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    29b4:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    29b6:	6003      	str	r3, [r0, #0]
	capacity = 0;
    29b8:	6043      	str	r3, [r0, #4]
	len = 0;
    29ba:	6083      	str	r3, [r0, #8]
	flags = 0;
    29bc:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    29be:	b141      	cbz	r1, 29d2 <String::String(char const*)+0x22>
    29c0:	460d      	mov	r5, r1
    29c2:	4608      	mov	r0, r1
    29c4:	f004 fafc 	bl	6fc0 <strlen>
    29c8:	4602      	mov	r2, r0
    29ca:	4629      	mov	r1, r5
    29cc:	4620      	mov	r0, r4
    29ce:	f7ff ffcd 	bl	296c <String::copy(char const*, unsigned int)>
}
    29d2:	4620      	mov	r0, r4
    29d4:	bd38      	pop	{r3, r4, r5, pc}
    29d6:	bf00      	nop

000029d8 <String::equals(char const*) const>:
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    29d8:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    29da:	b508      	push	{r3, lr}
    29dc:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    29de:	b92a      	cbnz	r2, 29ec <String::equals(char const*) const+0x14>
    29e0:	b171      	cbz	r1, 2a00 <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    29e2:	7818      	ldrb	r0, [r3, #0]
    29e4:	fab0 f080 	clz	r0, r0
    29e8:	0940      	lsrs	r0, r0, #5
    29ea:	bd08      	pop	{r3, pc}
    29ec:	b131      	cbz	r1, 29fc <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    29ee:	6800      	ldr	r0, [r0, #0]
    29f0:	f004 f91a 	bl	6c28 <strcmp>
    29f4:	fab0 f080 	clz	r0, r0
    29f8:	0940      	lsrs	r0, r0, #5
}
    29fa:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    29fc:	6803      	ldr	r3, [r0, #0]
    29fe:	e7f0      	b.n	29e2 <String::equals(char const*) const+0xa>
    2a00:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    2a02:	bd08      	pop	{r3, pc}

00002a04 <operator new(unsigned int)>:
    2a04:	f003 bace 	b.w	5fa4 <malloc>

00002a08 <operator new[](unsigned int)>:
	return malloc(size);
}

void * operator new[](size_t size)
{
	return malloc(size);
    2a08:	f003 bacc 	b.w	5fa4 <malloc>

00002a0c <operator delete(void*, unsigned int)>:
    2a0c:	f003 bad2 	b.w	5fb4 <free>

00002a10 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    2a10:	4770      	bx	lr
    2a12:	bf00      	nop

00002a14 <usb_seremu_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
    2a14:	f7ff bd76 	b.w	2504 <usb_seremu_peekchar>

00002a18 <usb_seremu_class::read()>:
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
    2a18:	f7ff bd40 	b.w	249c <usb_seremu_getchar>

00002a1c <usb_seremu_class::available()>:
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    2a1c:	f7ff bd94 	b.w	2548 <usb_seremu_available>

00002a20 <usb_seremu_class::flush()>:
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
    2a20:	f7ff beca 	b.w	27b8 <usb_seremu_flush_output>

00002a24 <usb_seremu_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
        size_t write(unsigned long n) { return write((uint8_t)n); }
        size_t write(long n) { return write((uint8_t)n); }
        size_t write(unsigned int n) { return write((uint8_t)n); }
        size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_seremu_write_buffer_free(); }
    2a24:	f7ff bec6 	b.w	27b4 <usb_seremu_write_buffer_free>

00002a28 <usb_seremu_class::write(unsigned char const*, unsigned int)>:
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
    2a28:	4608      	mov	r0, r1
    2a2a:	4611      	mov	r1, r2
    2a2c:	f7ff beb6 	b.w	279c <usb_seremu_write>

00002a30 <usb_seremu_class::write(unsigned char)>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
    2a30:	4608      	mov	r0, r1
    2a32:	f7ff be9d 	b.w	2770 <usb_seremu_putchar>
    2a36:	bf00      	nop

00002a38 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    2a38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    2a3c:	4e32      	ldr	r6, [pc, #200]	; (2b08 <yield+0xd0>)
    2a3e:	7833      	ldrb	r3, [r6, #0]
    2a40:	b193      	cbz	r3, 2a68 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    2a42:	4f32      	ldr	r7, [pc, #200]	; (2b0c <yield+0xd4>)
    2a44:	783a      	ldrb	r2, [r7, #0]
    2a46:	b97a      	cbnz	r2, 2a68 <yield+0x30>
	running = 1;
    2a48:	2201      	movs	r2, #1


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    2a4a:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    2a4c:	703a      	strb	r2, [r7, #0]


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    2a4e:	d437      	bmi.n	2ac0 <yield+0x88>
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
    2a50:	079a      	lsls	r2, r3, #30
    2a52:	d419      	bmi.n	2a88 <yield+0x50>

	running = 0;
    2a54:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    2a56:	075b      	lsls	r3, r3, #29
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();

	running = 0;
    2a58:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    2a5a:	d505      	bpl.n	2a68 <yield+0x30>
	// Wait for event(s) to occur.  These are most likely to be useful when
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);
	static void runFromYield() {
		if (!firstYield) return;  
    2a5c:	4b2c      	ldr	r3, [pc, #176]	; (2b10 <yield+0xd8>)
    2a5e:	681a      	ldr	r2, [r3, #0]
    2a60:	b112      	cbz	r2, 2a68 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    2a62:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    2a66:	b10a      	cbz	r2, 2a6c <yield+0x34>
    2a68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2a6c:	f3ef 8010 	mrs	r0, PRIMASK
		__disable_irq();
    2a70:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    2a72:	681a      	ldr	r2, [r3, #0]
		if (first == nullptr) {
    2a74:	b11a      	cbz	r2, 2a7e <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    2a76:	4c27      	ldr	r4, [pc, #156]	; (2b14 <yield+0xdc>)
    2a78:	7821      	ldrb	r1, [r4, #0]
    2a7a:	2900      	cmp	r1, #0
    2a7c:	d02f      	beq.n	2ade <yield+0xa6>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2a7e:	2800      	cmp	r0, #0
    2a80:	d1f2      	bne.n	2a68 <yield+0x30>
    2a82:	b662      	cpsie	i
    2a84:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    2a88:	f8df 8094 	ldr.w	r8, [pc, #148]	; 2b20 <yield+0xe8>
    2a8c:	f898 2000 	ldrb.w	r2, [r8]
    2a90:	2a00      	cmp	r2, #0
    2a92:	d0df      	beq.n	2a54 <yield+0x1c>
    2a94:	2400      	movs	r4, #0
    2a96:	f8df 908c 	ldr.w	r9, [pc, #140]	; 2b24 <yield+0xec>
    2a9a:	e005      	b.n	2aa8 <yield+0x70>
    2a9c:	3401      	adds	r4, #1
    2a9e:	f898 3000 	ldrb.w	r3, [r8]
    2aa2:	b2e4      	uxtb	r4, r4
    2aa4:	42a3      	cmp	r3, r4
    2aa6:	d913      	bls.n	2ad0 <yield+0x98>
			s_serials_with_serial_events[i]->doYieldCode();
    2aa8:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    2aac:	682b      	ldr	r3, [r5, #0]
    2aae:	4628      	mov	r0, r5
    2ab0:	691b      	ldr	r3, [r3, #16]
    2ab2:	4798      	blx	r3
    2ab4:	2800      	cmp	r0, #0
    2ab6:	d0f1      	beq.n	2a9c <yield+0x64>
    2ab8:	696b      	ldr	r3, [r5, #20]
    2aba:	689b      	ldr	r3, [r3, #8]
    2abc:	4798      	blx	r3
    2abe:	e7ed      	b.n	2a9c <yield+0x64>
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    2ac0:	f7ff fd42 	bl	2548 <usb_seremu_available>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    2ac4:	b9d0      	cbnz	r0, 2afc <yield+0xc4>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    2ac6:	4b14      	ldr	r3, [pc, #80]	; (2b18 <yield+0xe0>)
    2ac8:	781b      	ldrb	r3, [r3, #0]
    2aca:	b91b      	cbnz	r3, 2ad4 <yield+0x9c>
    2acc:	7833      	ldrb	r3, [r6, #0]
    2ace:	e7bf      	b.n	2a50 <yield+0x18>
    2ad0:	7833      	ldrb	r3, [r6, #0]
    2ad2:	e7bf      	b.n	2a54 <yield+0x1c>
    2ad4:	7833      	ldrb	r3, [r6, #0]
    2ad6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    2ada:	7033      	strb	r3, [r6, #0]
    2adc:	e7b8      	b.n	2a50 <yield+0x18>
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    2ade:	2601      	movs	r6, #1
		firstYield = first->_next;
    2ae0:	6955      	ldr	r5, [r2, #20]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    2ae2:	7026      	strb	r6, [r4, #0]
		firstYield = first->_next;
    2ae4:	601d      	str	r5, [r3, #0]
		if (firstYield) {
    2ae6:	b165      	cbz	r5, 2b02 <yield+0xca>
			firstYield->_prev = nullptr;
    2ae8:	61a9      	str	r1, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2aea:	b900      	cbnz	r0, 2aee <yield+0xb6>
    2aec:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    2aee:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    2af0:	6893      	ldr	r3, [r2, #8]
    2af2:	4610      	mov	r0, r2
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    2af4:	7755      	strb	r5, [r2, #29]
		(*(first->_function))(*first);
    2af6:	4798      	blx	r3
		runningFromYield = false;
    2af8:	7025      	strb	r5, [r4, #0]
    2afa:	e7b5      	b.n	2a68 <yield+0x30>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    2afc:	f7ff ff88 	bl	2a10 <serialEvent()>
    2b00:	e7e1      	b.n	2ac6 <yield+0x8e>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    2b02:	4b06      	ldr	r3, [pc, #24]	; (2b1c <yield+0xe4>)
    2b04:	601d      	str	r5, [r3, #0]
    2b06:	e7f0      	b.n	2aea <yield+0xb2>
    2b08:	20001dff 	.word	0x20001dff
    2b0c:	20002750 	.word	0x20002750
    2b10:	20002684 	.word	0x20002684
    2b14:	2000274e 	.word	0x2000274e
    2b18:	60002186 	.word	0x60002186
    2b1c:	20002690 	.word	0x20002690
    2b20:	2000274f 	.word	0x2000274f
    2b24:	20002694 	.word	0x20002694

00002b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>:
 *    @param  byteorder The byte order of the register (used when width is > 1),
 * defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    2b28:	b5f0      	push	{r4, r5, r6, r7, lr}
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
  _spidevice = spidevice;
    2b2a:	6042      	str	r2, [r0, #4]
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
    2b2c:	f04f 0e00 	mov.w	lr, #0
 *    @param  byteorder The byte order of the register (used when width is > 1),
 * defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    2b30:	f89d 7020 	ldrb.w	r7, [sp, #32]
    2b34:	f8bd 6014 	ldrh.w	r6, [sp, #20]
    2b38:	f89d 501c 	ldrb.w	r5, [sp, #28]
    2b3c:	f89d 2018 	ldrb.w	r2, [sp, #24]
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
  _spidevice = spidevice;
  _i2cdevice = i2cdevice;
    2b40:	6001      	str	r1, [r0, #0]
  _spiregtype = type;
    2b42:	7203      	strb	r3, [r0, #8]
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
    2b44:	f8c0 e014 	str.w	lr, [r0, #20]
  _spidevice = spidevice;
  _i2cdevice = i2cdevice;
  _spiregtype = type;
  _addrwidth = address_width;
    2b48:	7347      	strb	r7, [r0, #13]
  _address = reg_addr;
    2b4a:	8146      	strh	r6, [r0, #10]
  _byteorder = byteorder;
    2b4c:	7385      	strb	r5, [r0, #14]
  _width = width;
    2b4e:	7302      	strb	r2, [r0, #12]
}
    2b50:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2b52:	bf00      	nop

00002b54 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>:
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
    2b54:	8943      	ldrh	r3, [r0, #10]
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    2b56:	b5f0      	push	{r4, r5, r6, r7, lr}

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2b58:	b2dd      	uxtb	r5, r3
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    2b5a:	b085      	sub	sp, #20

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2b5c:	0a1b      	lsrs	r3, r3, #8

  if (_i2cdevice) {
    2b5e:	6804      	ldr	r4, [r0, #0]
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2b60:	f88d 500c 	strb.w	r5, [sp, #12]
    2b64:	f88d 300d 	strb.w	r3, [sp, #13]

  if (_i2cdevice) {
    2b68:	b14c      	cbz	r4, 2b7e <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x2a>
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
    2b6a:	7b46      	ldrb	r6, [r0, #13]
    2b6c:	ad03      	add	r5, sp, #12
    2b6e:	4620      	mov	r0, r4
    2b70:	2301      	movs	r3, #1
    2b72:	e88d 0060 	stmia.w	sp, {r5, r6}
    2b76:	f000 f949 	bl	2e0c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>
      addrbuffer[0] |= 0x40;
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
  }
  return false;
}
    2b7a:	b005      	add	sp, #20
    2b7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
  }
  if (_spidevice) {
    2b7e:	f8d0 e004 	ldr.w	lr, [r0, #4]
    2b82:	f1be 0f00 	cmp.w	lr, #0
    2b86:	d023      	beq.n	2bd0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x7c>
    if (_spiregtype == ADDRESSED_OPCODE_BIT0_LOW_TO_WRITE) {
    2b88:	7a04      	ldrb	r4, [r0, #8]
    2b8a:	2c03      	cmp	r4, #3
    2b8c:	d022      	beq.n	2bd4 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x80>
    2b8e:	460e      	mov	r6, r1
    2b90:	4617      	mov	r7, r2
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    }

    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    2b92:	b96c      	cbnz	r4, 2bb0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x5c>
      addrbuffer[0] &= ~0x80;
    2b94:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    2b98:	f88d 500c 	strb.w	r5, [sp, #12]
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
      addrbuffer[0] &= ~0x80;
      addrbuffer[0] |= 0x40;
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
    2b9c:	7b43      	ldrb	r3, [r0, #13]
    2b9e:	463a      	mov	r2, r7
    2ba0:	4631      	mov	r1, r6
    2ba2:	4670      	mov	r0, lr
    2ba4:	9300      	str	r3, [sp, #0]
    2ba6:	ab03      	add	r3, sp, #12
    2ba8:	f000 fb72 	bl	3290 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>
  }
  return false;
}
    2bac:	b005      	add	sp, #20
    2bae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }

    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] &= ~0x80;
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOWRITE) {
    2bb0:	2c02      	cmp	r4, #2
    2bb2:	d104      	bne.n	2bbe <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x6a>
      addrbuffer[0] |= 0x80;
    2bb4:	f065 057f 	orn	r5, r5, #127	; 0x7f
    2bb8:	f88d 500c 	strb.w	r5, [sp, #12]
    2bbc:	e7ee      	b.n	2b9c <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
    2bbe:	2c01      	cmp	r4, #1
    2bc0:	d1ec      	bne.n	2b9c <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
      addrbuffer[0] &= ~0x80;
      addrbuffer[0] |= 0x40;
    2bc2:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    2bc6:	f045 0540 	orr.w	r5, r5, #64	; 0x40
    2bca:	f88d 500c 	strb.w	r5, [sp, #12]
    2bce:	e7e5      	b.n	2b9c <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
  }
  return false;
    2bd0:	4670      	mov	r0, lr
    2bd2:	e7d2      	b.n	2b7a <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x26>
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    2bd4:	7b46      	ldrb	r6, [r0, #13]
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
    2bd6:	f023 0401 	bic.w	r4, r3, #1
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    2bda:	4670      	mov	r0, lr
    2bdc:	ab03      	add	r3, sp, #12
    2bde:	3601      	adds	r6, #1
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
    2be0:	f88d 400c 	strb.w	r4, [sp, #12]
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
    2be4:	f88d 500d 	strb.w	r5, [sp, #13]
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    2be8:	9600      	str	r6, [sp, #0]
    2bea:	f000 fb51 	bl	3290 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>
    2bee:	e7c4      	b.n	2b7a <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x26>

00002bf0 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>:
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
  if (numbytes == 0) {
    2bf0:	b902      	cbnz	r2, 2bf4 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x4>
    numbytes = _width;
    2bf2:	7b02      	ldrb	r2, [r0, #12]
  }
  if (numbytes > 4) {
    2bf4:	2a04      	cmp	r2, #4
    2bf6:	d818      	bhi.n	2c2a <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x3a>
 *    @param  value Data to write
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
    2bf8:	b4f0      	push	{r4, r5, r6, r7}
  if (numbytes > 4) {
    return false;
  }

  // store a copy
  _cached = value;
    2bfa:	6141      	str	r1, [r0, #20]
    2bfc:	f100 070f 	add.w	r7, r0, #15

  for (int i = 0; i < numbytes; i++) {
    2c00:	b16a      	cbz	r2, 2c1e <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x2e>
    2c02:	f102 030e 	add.w	r3, r2, #14
    2c06:	7b86      	ldrb	r6, [r0, #14]
    2c08:	f100 050e 	add.w	r5, r0, #14
    2c0c:	463c      	mov	r4, r7
    2c0e:	4403      	add	r3, r0
    if (_byteorder == LSBFIRST) {
    2c10:	b94e      	cbnz	r6, 2c26 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x36>
      _buffer[i] = value & 0xFF;
    2c12:	7021      	strb	r1, [r4, #0]
    2c14:	3b01      	subs	r3, #1
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
    2c16:	0a09      	lsrs	r1, r1, #8
    2c18:	3401      	adds	r4, #1
  }

  // store a copy
  _cached = value;

  for (int i = 0; i < numbytes; i++) {
    2c1a:	42ab      	cmp	r3, r5
    2c1c:	d1f8      	bne.n	2c10 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x20>
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    2c1e:	4639      	mov	r1, r7
}
    2c20:	bcf0      	pop	{r4, r5, r6, r7}
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    2c22:	f7ff bf97 	b.w	2b54 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>

  for (int i = 0; i < numbytes; i++) {
    if (_byteorder == LSBFIRST) {
      _buffer[i] = value & 0xFF;
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    2c26:	7019      	strb	r1, [r3, #0]
    2c28:	e7f4      	b.n	2c14 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x24>
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
}
    2c2a:	2000      	movs	r0, #0
    2c2c:	4770      	bx	lr
    2c2e:	bf00      	nop

00002c30 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>:
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    2c30:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
    2c32:	8944      	ldrh	r4, [r0, #10]
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    2c34:	b085      	sub	sp, #20
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    2c36:	6805      	ldr	r5, [r0, #0]
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2c38:	b2e6      	uxtb	r6, r4
    2c3a:	0a24      	lsrs	r4, r4, #8
    2c3c:	f88d 600c 	strb.w	r6, [sp, #12]
    2c40:	f88d 400d 	strb.w	r4, [sp, #13]

  if (_i2cdevice) {
    2c44:	b15d      	cbz	r5, 2c5e <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2e>
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    2c46:	7b40      	ldrb	r0, [r0, #13]
    2c48:	2400      	movs	r4, #0
    2c4a:	9200      	str	r2, [sp, #0]
    2c4c:	460b      	mov	r3, r1
    2c4e:	4602      	mov	r2, r0
    2c50:	9401      	str	r4, [sp, #4]
    2c52:	4628      	mov	r0, r5
    2c54:	a903      	add	r1, sp, #12
    2c56:	f000 f96b 	bl	2f30 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>
      addrbuffer[0] |= 0x80 | 0x40;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
}
    2c5a:	b005      	add	sp, #20
    2c5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  if (_spidevice) {
    2c5e:	6845      	ldr	r5, [r0, #4]
    2c60:	b30d      	cbz	r5, 2ca6 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x76>
    if (_spiregtype == ADDRESSED_OPCODE_BIT0_LOW_TO_WRITE) {
    2c62:	7a03      	ldrb	r3, [r0, #8]
    2c64:	2b03      	cmp	r3, #3
    2c66:	d020      	beq.n	2caa <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x7a>
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    2c68:	b97b      	cbnz	r3, 2c8a <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x5a>
      addrbuffer[0] |= 0x80;
    2c6a:	f066 067f 	orn	r6, r6, #127	; 0x7f
    2c6e:	f88d 600c 	strb.w	r6, [sp, #12]
      addrbuffer[0] &= ~0x80;
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
      addrbuffer[0] |= 0x80 | 0x40;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    2c72:	7b40      	ldrb	r0, [r0, #13]
    2c74:	24ff      	movs	r4, #255	; 0xff
    2c76:	9200      	str	r2, [sp, #0]
    2c78:	460b      	mov	r3, r1
    2c7a:	4602      	mov	r2, r0
    2c7c:	a903      	add	r1, sp, #12
    2c7e:	4628      	mov	r0, r5
    2c80:	9401      	str	r4, [sp, #4]
    2c82:	f000 fb3b 	bl	32fc <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>
  }
  return false;
}
    2c86:	b005      	add	sp, #20
    2c88:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         len);
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] |= 0x80;
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOWRITE) {
    2c8a:	2b02      	cmp	r3, #2
    2c8c:	d104      	bne.n	2c98 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x68>
      addrbuffer[0] &= ~0x80;
    2c8e:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    2c92:	f88d 600c 	strb.w	r6, [sp, #12]
    2c96:	e7ec      	b.n	2c72 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
    2c98:	2b01      	cmp	r3, #1
    2c9a:	d1ea      	bne.n	2c72 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
      addrbuffer[0] |= 0x80 | 0x40;
    2c9c:	f066 063f 	orn	r6, r6, #63	; 0x3f
    2ca0:	f88d 600c 	strb.w	r6, [sp, #12]
    2ca4:	e7e5      	b.n	2c72 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
    2ca6:	4628      	mov	r0, r5
    2ca8:	e7d7      	b.n	2c5a <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2a>
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    2caa:	7b43      	ldrb	r3, [r0, #13]
    2cac:	27ff      	movs	r7, #255	; 0xff
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
    2cae:	f044 0401 	orr.w	r4, r4, #1
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    2cb2:	9200      	str	r2, [sp, #0]
    2cb4:	4628      	mov	r0, r5
    2cb6:	1c5a      	adds	r2, r3, #1
    2cb8:	9701      	str	r7, [sp, #4]
    2cba:	460b      	mov	r3, r1
    2cbc:	a903      	add	r1, sp, #12
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
    2cbe:	f88d 400c 	strb.w	r4, [sp, #12]
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
    2cc2:	f88d 600d 	strb.w	r6, [sp, #13]
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    2cc6:	f000 fb19 	bl	32fc <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>
    2cca:	e7c6      	b.n	2c5a <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2a>

00002ccc <Adafruit_BusIO_Register::read()>:
/*!
 *    @brief  Read data from the register location. This does not do any error
 * checking!
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    2ccc:	b538      	push	{r3, r4, r5, lr}
  if (!read(_buffer, _width)) {
    2cce:	f100 040f 	add.w	r4, r0, #15
    2cd2:	7b02      	ldrb	r2, [r0, #12]
/*!
 *    @brief  Read data from the register location. This does not do any error
 * checking!
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    2cd4:	4605      	mov	r5, r0
  if (!read(_buffer, _width)) {
    2cd6:	4621      	mov	r1, r4
    2cd8:	f7ff ffaa 	bl	2c30 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    2cdc:	b910      	cbnz	r0, 2ce4 <Adafruit_BusIO_Register::read()+0x18>
    return -1;
    2cde:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
      value |= _buffer[i];
    }
  }

  return value;
}
    2ce2:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2ce4:	7b28      	ldrb	r0, [r5, #12]
    2ce6:	2800      	cmp	r0, #0
    2ce8:	d0fb      	beq.n	2ce2 <Adafruit_BusIO_Register::read()+0x16>
    2cea:	300e      	adds	r0, #14
    2cec:	4621      	mov	r1, r4
    2cee:	f105 020e 	add.w	r2, r5, #14
    2cf2:	7bac      	ldrb	r4, [r5, #14]
    2cf4:	182b      	adds	r3, r5, r0
    2cf6:	2000      	movs	r0, #0
    2cf8:	e006      	b.n	2d08 <Adafruit_BusIO_Register::read()+0x3c>
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    2cfa:	781d      	ldrb	r5, [r3, #0]
    2cfc:	3b01      	subs	r3, #1
    2cfe:	3101      	adds	r1, #1
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2d00:	4293      	cmp	r3, r2
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    2d02:	ea40 0005 	orr.w	r0, r0, r5
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2d06:	d009      	beq.n	2d1c <Adafruit_BusIO_Register::read()+0x50>
    value <<= 8;
    2d08:	0200      	lsls	r0, r0, #8
    if (_byteorder == LSBFIRST) {
    2d0a:	2c00      	cmp	r4, #0
    2d0c:	d0f5      	beq.n	2cfa <Adafruit_BusIO_Register::read()+0x2e>
    2d0e:	3b01      	subs	r3, #1
      value |= _buffer[_width - i - 1];
    } else {
      value |= _buffer[i];
    2d10:	780d      	ldrb	r5, [r1, #0]
    2d12:	3101      	adds	r1, #1
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2d14:	4293      	cmp	r3, r2
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    } else {
      value |= _buffer[i];
    2d16:	ea40 0005 	orr.w	r0, r0, r5
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2d1a:	d1f5      	bne.n	2d08 <Adafruit_BusIO_Register::read()+0x3c>
    2d1c:	bd38      	pop	{r3, r4, r5, pc}
    2d1e:	bf00      	nop

00002d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>:
 * touching other bits
 *    @param  reg The Adafruit_BusIO_Register which defines the bus/register
 *    @param  bits The number of bits wide we are slicing
 *    @param  shift The number of bits that our bit-slice is shifted from LSB
 */
Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(
    2d20:	b410      	push	{r4}
    Adafruit_BusIO_Register *reg, uint8_t bits, uint8_t shift) {
  _register = reg;
    2d22:	6001      	str	r1, [r0, #0]
  _bits = bits;
    2d24:	7102      	strb	r2, [r0, #4]
  _shift = shift;
    2d26:	7143      	strb	r3, [r0, #5]
}
    2d28:	f85d 4b04 	ldr.w	r4, [sp], #4
    2d2c:	4770      	bx	lr
    2d2e:	bf00      	nop

00002d30 <Adafruit_BusIO_RegisterBits::read()>:

/*!
 *    @brief  Read 4 bytes of data from the register
 *    @return  data The 4 bytes to read
 */
uint32_t Adafruit_BusIO_RegisterBits::read(void) {
    2d30:	b510      	push	{r4, lr}
    2d32:	4604      	mov	r4, r0
  uint32_t val = _register->read();
    2d34:	6800      	ldr	r0, [r0, #0]
    2d36:	f7ff ffc9 	bl	2ccc <Adafruit_BusIO_Register::read()>
  val >>= _shift;
  return val & ((1 << (_bits)) - 1);
    2d3a:	2301      	movs	r3, #1
    2d3c:	7921      	ldrb	r1, [r4, #4]
    2d3e:	7962      	ldrb	r2, [r4, #5]
    2d40:	408b      	lsls	r3, r1
    2d42:	40d0      	lsrs	r0, r2
    2d44:	3b01      	subs	r3, #1
}
    2d46:	4018      	ands	r0, r3
    2d48:	bd10      	pop	{r4, pc}
    2d4a:	bf00      	nop

00002d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>:
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    2d4c:	b538      	push	{r3, r4, r5, lr}
    2d4e:	4605      	mov	r5, r0
  uint32_t val = _register->read();
    2d50:	6800      	ldr	r0, [r0, #0]
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    2d52:	460c      	mov	r4, r1
  uint32_t val = _register->read();
    2d54:	f7ff ffba 	bl	2ccc <Adafruit_BusIO_Register::read()>

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    2d58:	792a      	ldrb	r2, [r5, #4]
    2d5a:	2301      	movs	r3, #1
  data &= mask;

  mask <<= _shift;
    2d5c:	7969      	ldrb	r1, [r5, #5]
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
  uint32_t val = _register->read();

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    2d5e:	4093      	lsls	r3, r2

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2d60:	682d      	ldr	r5, [r5, #0]
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
  uint32_t val = _register->read();

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    2d62:	3b01      	subs	r3, #1

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2d64:	7b2a      	ldrb	r2, [r5, #12]
    2d66:	401c      	ands	r4, r3
  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
  data &= mask;

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
    2d68:	408b      	lsls	r3, r1
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2d6a:	fa04 f101 	lsl.w	r1, r4, r1
  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
  data &= mask;

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
    2d6e:	ea20 0303 	bic.w	r3, r0, r3
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2d72:	4628      	mov	r0, r5
    2d74:	4319      	orrs	r1, r3
}
    2d76:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2d7a:	f7ff bf39 	b.w	2bf0 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>
    2d7e:	bf00      	nop

00002d80 <TwoWire::read()>:
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2d80:	f890 30a2 	ldrb.w	r3, [r0, #162]	; 0xa2
    2d84:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    2d88:	429a      	cmp	r2, r3
    2d8a:	d905      	bls.n	2d98 <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    2d8c:	1c5a      	adds	r2, r3, #1
    2d8e:	4403      	add	r3, r0
    2d90:	f880 20a2 	strb.w	r2, [r0, #162]	; 0xa2
    2d94:	7e98      	ldrb	r0, [r3, #26]
    2d96:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2d98:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    2d9c:	4770      	bx	lr
    2d9e:	bf00      	nop

00002da0 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>:
/*!
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
    2da0:	b430      	push	{r4, r5}
  _addr = addr;
  _wire = theWire;
  _begun = false;
    2da2:	2500      	movs	r5, #0
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
    2da4:	2420      	movs	r4, #32
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
    2da6:	7001      	strb	r1, [r0, #0]
  _wire = theWire;
  _begun = false;
    2da8:	7205      	strb	r5, [r0, #8]
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
    2daa:	60c4      	str	r4, [r0, #12]
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
  _wire = theWire;
    2dac:	6042      	str	r2, [r0, #4]
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
#endif
}
    2dae:	bc30      	pop	{r4, r5}
    2db0:	4770      	bx	lr
    2db2:	bf00      	nop

00002db4 <Adafruit_I2CDevice::detected()>:
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    2db4:	7a03      	ldrb	r3, [r0, #8]
/*!
 *    @brief  Scans I2C for the address - note will give a false-positive
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
    2db6:	b510      	push	{r4, lr}
    2db8:	4604      	mov	r4, r0
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    2dba:	b18b      	cbz	r3, 2de0 <Adafruit_I2CDevice::detected()+0x2c>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2dbc:	7820      	ldrb	r0, [r4, #0]
		transmitting = 1;
    2dbe:	2201      	movs	r2, #1
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
    2dc0:	6863      	ldr	r3, [r4, #4]
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2dc2:	4090      	lsls	r0, r2
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    2dc4:	4611      	mov	r1, r2
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    2dc6:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2dca:	f883 00a5 	strb.w	r0, [r3, #165]	; 0xa5
		transmitting = 1;
		txBufferLength = 1;
    2dce:	f883 212f 	strb.w	r2, [r3, #303]	; 0x12f
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    2dd2:	6860      	ldr	r0, [r4, #4]
    2dd4:	f001 fb4a 	bl	446c <TwoWire::endTransmission(unsigned char)>
  if (_wire->endTransmission() == 0) {
    2dd8:	fab0 f080 	clz	r0, r0
    2ddc:	0940      	lsrs	r0, r0, #5
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    2dde:	bd10      	pop	{r4, pc}
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    2de0:	2101      	movs	r1, #1
    2de2:	f000 f803 	bl	2dec <Adafruit_I2CDevice::begin(bool)>
    2de6:	2800      	cmp	r0, #0
    2de8:	d1e8      	bne.n	2dbc <Adafruit_I2CDevice::detected()+0x8>
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    2dea:	bd10      	pop	{r4, pc}

00002dec <Adafruit_I2CDevice::begin(bool)>:
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    2dec:	b538      	push	{r3, r4, r5, lr}
    2dee:	4604      	mov	r4, r0
  _wire->begin();
    2df0:	6840      	ldr	r0, [r0, #4]
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    2df2:	460d      	mov	r5, r1
  _wire->begin();
    2df4:	f007 f9c0 	bl	a178 <___ZN7TwoWire5beginEv_veneer>
  _begun = true;
    2df8:	2001      	movs	r0, #1
    2dfa:	7220      	strb	r0, [r4, #8]

  if (addr_detect) {
    2dfc:	b905      	cbnz	r5, 2e00 <Adafruit_I2CDevice::begin(bool)+0x14>
    return detected();
  }
  return true;
}
    2dfe:	bd38      	pop	{r3, r4, r5, pc}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    2e00:	4620      	mov	r0, r4
  }
  return true;
}
    2e02:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    2e06:	f7ff bfd5 	b.w	2db4 <Adafruit_I2CDevice::detected()>
    2e0a:	bf00      	nop

00002e0c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>:
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    2e0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2e10:	9e07      	ldr	r6, [sp, #28]
  if ((len + prefix_len) > maxBufferSize()) {
    2e12:	68c4      	ldr	r4, [r0, #12]
    2e14:	1995      	adds	r5, r2, r6
    2e16:	42a5      	cmp	r5, r4
    2e18:	d818      	bhi.n	2e4c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x40>
    2e1a:	4698      	mov	r8, r3
    2e1c:	460f      	mov	r7, r1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2e1e:	7803      	ldrb	r3, [r0, #0]
		transmitting = 1;
    2e20:	2101      	movs	r1, #1
    2e22:	4615      	mov	r5, r2
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    2e24:	6842      	ldr	r2, [r0, #4]
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2e26:	408b      	lsls	r3, r1
    2e28:	4604      	mov	r4, r0
		transmitting = 1;
    2e2a:	f882 1130 	strb.w	r1, [r2, #304]	; 0x130
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2e2e:	f882 30a5 	strb.w	r3, [r2, #165]	; 0xa5
		transmitting = 1;
		txBufferLength = 1;
    2e32:	f882 112f 	strb.w	r1, [r2, #303]	; 0x12f

  // Write the prefix data (usually an address)
  if ((prefix_len != 0) && (prefix_buffer != nullptr)) {
    2e36:	b166      	cbz	r6, 2e52 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    2e38:	9b06      	ldr	r3, [sp, #24]
    2e3a:	b153      	cbz	r3, 2e52 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {
    2e3c:	6840      	ldr	r0, [r0, #4]
    2e3e:	4632      	mov	r2, r6
    2e40:	9906      	ldr	r1, [sp, #24]
    2e42:	6803      	ldr	r3, [r0, #0]
    2e44:	685b      	ldr	r3, [r3, #4]
    2e46:	4798      	blx	r3
    2e48:	4286      	cmp	r6, r0
    2e4a:	d002      	beq.n	2e52 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    // we will need to find out if some platforms have larger
    // I2C buffer sizes :/
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
    2e4c:	2000      	movs	r0, #0
    2e4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    2e52:	6860      	ldr	r0, [r4, #4]
    2e54:	4639      	mov	r1, r7
    2e56:	462a      	mov	r2, r5
    2e58:	6803      	ldr	r3, [r0, #0]
    2e5a:	685b      	ldr	r3, [r3, #4]
    2e5c:	4798      	blx	r3
    2e5e:	4285      	cmp	r5, r0
    2e60:	d1f4      	bne.n	2e4c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x40>
  if (stop) {
    DEBUG_SERIAL.print("\tSTOP");
  }
#endif

  if (_wire->endTransmission(stop) == 0) {
    2e62:	4641      	mov	r1, r8
    2e64:	6860      	ldr	r0, [r4, #4]
    2e66:	f001 fb01 	bl	446c <TwoWire::endTransmission(unsigned char)>
    2e6a:	fab0 f080 	clz	r0, r0
    2e6e:	0940      	lsrs	r0, r0, #5
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("\tFailed to send!");
#endif
    return false;
  }
}
    2e70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00002e74 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>:
    pos += read_len;
  }
  return true;
}

bool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {
    2e74:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2e78:	4615      	mov	r5, r2
    2e7a:	4606      	mov	r6, r0
    2e7c:	460f      	mov	r7, r1
#if defined(TinyWireM_h)
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#elif defined(ARDUINO_ARCH_MEGAAVR)
  size_t recv = _wire->requestFrom(_addr, len, stop);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
    2e7e:	b2d2      	uxtb	r2, r2
    2e80:	7801      	ldrb	r1, [r0, #0]
    2e82:	6840      	ldr	r0, [r0, #4]
    2e84:	f001 fb62 	bl	454c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
#endif

  if (recv != len) {
    2e88:	4285      	cmp	r5, r0
    2e8a:	d002      	beq.n	2e92 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x1e>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    2e8c:	2000      	movs	r0, #0
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    2e8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    2e92:	b30d      	cbz	r5, 2ed8 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x64>
    2e94:	2300      	movs	r3, #0
    2e96:	f8df 904c 	ldr.w	r9, [pc, #76]	; 2ee4 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x70>
    2e9a:	461c      	mov	r4, r3
    2e9c:	e012      	b.n	2ec4 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x50>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2e9e:	f890 20a2 	ldrb.w	r2, [r0, #162]	; 0xa2
    2ea2:	f890 30a3 	ldrb.w	r3, [r0, #163]	; 0xa3
		return rxBuffer[rxBufferIndex++];
    2ea6:	f102 0e01 	add.w	lr, r2, #1
    2eaa:	1881      	adds	r1, r0, r2
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2eac:	4293      	cmp	r3, r2
    2eae:	d916      	bls.n	2ede <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x6a>
		return rxBuffer[rxBufferIndex++];
    2eb0:	f880 e0a2 	strb.w	lr, [r0, #162]	; 0xa2
    2eb4:	7e88      	ldrb	r0, [r1, #26]
    2eb6:	3401      	adds	r4, #1
    buffer[i] = _wire->read();
    2eb8:	f888 0000 	strb.w	r0, [r8]
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    2ebc:	b2a4      	uxth	r4, r4
    2ebe:	42a5      	cmp	r5, r4
    2ec0:	4623      	mov	r3, r4
    2ec2:	d909      	bls.n	2ed8 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x64>
    buffer[i] = _wire->read();
    2ec4:	6870      	ldr	r0, [r6, #4]
    2ec6:	eb07 0803 	add.w	r8, r7, r3
    2eca:	6803      	ldr	r3, [r0, #0]
    2ecc:	695a      	ldr	r2, [r3, #20]
    2ece:	454a      	cmp	r2, r9
    2ed0:	d0e5      	beq.n	2e9e <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x2a>
    2ed2:	4790      	blx	r2
    2ed4:	b2c0      	uxtb	r0, r0
    2ed6:	e7ee      	b.n	2eb6 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x42>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    2ed8:	2001      	movs	r0, #1
    2eda:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2ede:	20ff      	movs	r0, #255	; 0xff
    2ee0:	e7e9      	b.n	2eb6 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x42>
    2ee2:	bf00      	nop
    2ee4:	00002d81 	.word	0x00002d81

00002ee8 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    2ee8:	b302      	cbz	r2, 2f2c <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x44>
 *    @param  buffer Pointer to buffer of data to read into
 *    @param  len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
    2eea:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2eee:	4616      	mov	r6, r2
    2ef0:	4699      	mov	r9, r3
    2ef2:	4688      	mov	r8, r1
    2ef4:	4607      	mov	r7, r0
  size_t pos = 0;
  while (pos < len) {
    2ef6:	2400      	movs	r4, #0
    2ef8:	e001      	b.n	2efe <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x16>
    2efa:	42a6      	cmp	r6, r4
    2efc:	d913      	bls.n	2f26 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x3e>
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    2efe:	1b32      	subs	r2, r6, r4
    2f00:	68fd      	ldr	r5, [r7, #12]
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
    2f02:	eb08 0104 	add.w	r1, r8, r4
    2f06:	4638      	mov	r0, r7
    2f08:	42aa      	cmp	r2, r5
    2f0a:	bf28      	it	cs
    2f0c:	462a      	movcs	r2, r5
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    2f0e:	1ab3      	subs	r3, r6, r2
    if (!_read(buffer + pos, read_len, read_stop))
    2f10:	42a3      	cmp	r3, r4
    2f12:	bf94      	ite	ls
    2f14:	464b      	movls	r3, r9
    2f16:	2300      	movhi	r3, #0
      return false;
    pos += read_len;
    2f18:	4414      	add	r4, r2
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
    2f1a:	f7ff ffab 	bl	2e74 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>
    2f1e:	2800      	cmp	r0, #0
    2f20:	d1eb      	bne.n	2efa <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x12>
      return false;
    pos += read_len;
  }
  return true;
}
    2f22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
      return false;
    pos += read_len;
  }
  return true;
    2f26:	2001      	movs	r0, #1
    2f28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2f2c:	2001      	movs	r0, #1
}
    2f2e:	4770      	bx	lr

00002f30 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    2f30:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f32:	b083      	sub	sp, #12
  if (!write(write_buffer, write_len, stop)) {
    2f34:	2400      	movs	r4, #0
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    2f36:	461f      	mov	r7, r3
    2f38:	4606      	mov	r6, r0
    2f3a:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  if (!write(write_buffer, write_len, stop)) {
    2f3e:	9401      	str	r4, [sp, #4]
    2f40:	9400      	str	r4, [sp, #0]
    2f42:	462b      	mov	r3, r5
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    2f44:	9c08      	ldr	r4, [sp, #32]
  if (!write(write_buffer, write_len, stop)) {
    2f46:	f7ff ff61 	bl	2e0c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>
    2f4a:	b908      	cbnz	r0, 2f50 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)+0x20>
    return false;
  }

  return read(read_buffer, read_len);
}
    2f4c:	b003      	add	sp, #12
    2f4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
    2f50:	4622      	mov	r2, r4
    2f52:	4639      	mov	r1, r7
    2f54:	4630      	mov	r0, r6
    2f56:	2301      	movs	r3, #1
}
    2f58:	b003      	add	sp, #12
    2f5a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
    2f5e:	f7ff bfc3 	b.w	2ee8 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>
    2f62:	bf00      	nop

00002f64 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>:
 *    @brief  Transfer (send/receive) a buffer over hard/soft SPI, without
 * transaction management
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    2f64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // HARDWARE SPI
  //
  if (_spi) {
    2f68:	6804      	ldr	r4, [r0, #0]
 *    @brief  Transfer (send/receive) a buffer over hard/soft SPI, without
 * transaction management
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    2f6a:	4613      	mov	r3, r2
    2f6c:	b085      	sub	sp, #20
    2f6e:	460a      	mov	r2, r1
  //
  // HARDWARE SPI
  //
  if (_spi) {
    2f70:	b12c      	cbz	r4, 2f7e <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x1a>
				transfer16(buf, buf, count >> 1);
				return;
			}
		}
#endif
		transfer(buf, buf, count);
    2f72:	4620      	mov	r0, r4
        buffer[i] = reply;
      }
    }
  }
  return;
}
    2f74:	b005      	add	sp, #20
    2f76:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2f7a:	f001 b97f 	b.w	427c <SPIClass::transfer(void const*, void*, unsigned int)>

  //
  // SOFTWARE SPI
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    2f7e:	7b04      	ldrb	r4, [r0, #12]
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    2f80:	4959      	ldr	r1, [pc, #356]	; (30e8 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x184>)
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    2f82:	2c00      	cmp	r4, #0
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    2f84:	6886      	ldr	r6, [r0, #8]
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    2f86:	7814      	ldrb	r4, [r2, #0]
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    2f88:	bf0c      	ite	eq
    2f8a:	2501      	moveq	r5, #1
    2f8c:	2580      	movne	r5, #128	; 0x80
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    2f8e:	fbb1 f6f6 	udiv	r6, r1, r6
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    2f92:	4225      	tst	r5, r4
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    2f94:	9502      	str	r5, [sp, #8]
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    2f96:	b2f6      	uxtb	r6, r6
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    2f98:	bf0c      	ite	eq
    2f9a:	2101      	moveq	r1, #1
    2f9c:	2100      	movne	r1, #0
    2f9e:	9100      	str	r1, [sp, #0]
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    2fa0:	2b00      	cmp	r3, #0
    2fa2:	d063      	beq.n	306c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x108>
    2fa4:	4690      	mov	r8, r2
    2fa6:	4683      	mov	fp, r0
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2fa8:	4c50      	ldr	r4, [pc, #320]	; (30ec <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x188>)
    2faa:	4443      	add	r3, r8
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2fac:	f8df 9144 	ldr.w	r9, [pc, #324]	; 30f4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x190>
    2fb0:	9303      	str	r3, [sp, #12]
    uint8_t reply = 0;
    uint8_t send = buffer[i];
    2fb2:	f818 ab01 	ldrb.w	sl, [r8], #1
    2fb6:	465b      	mov	r3, fp
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    2fb8:	9d02      	ldr	r5, [sp, #8]

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    uint8_t reply = 0;
    2fba:	2700      	movs	r7, #0
    2fbc:	46c3      	mov	fp, r8
    2fbe:	4698      	mov	r8, r3

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
    2fc0:	2e00      	cmp	r6, #0
    2fc2:	d05a      	beq.n	307a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x116>
    2fc4:	4a4a      	ldr	r2, [pc, #296]	; (30f0 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x18c>)
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2fc6:	6823      	ldr	r3, [r4, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    2fc8:	6810      	ldr	r0, [r2, #0]
    2fca:	fba9 1000 	umull	r1, r0, r9, r0
    2fce:	0c80      	lsrs	r0, r0, #18
    2fd0:	fb00 f006 	mul.w	r0, r0, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    2fd4:	6821      	ldr	r1, [r4, #0]
    2fd6:	1ac9      	subs	r1, r1, r3
    2fd8:	4288      	cmp	r0, r1
    2fda:	d8fb      	bhi.n	2fd4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x70>
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    2fdc:	f898 100d 	ldrb.w	r1, [r8, #13]
    2fe0:	f011 0ff7 	tst.w	r1, #247	; 0xf7
    2fe4:	d16c      	bne.n	30c0 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x15c>
        towrite = send & b;
    2fe6:	ea1a 0f05 	tst.w	sl, r5
        if ((_mosi != -1) && (lastmosi != towrite)) {
    2fea:	f998 0010 	ldrsb.w	r0, [r8, #16]
      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
        towrite = send & b;
    2fee:	bf14      	ite	ne
    2ff0:	2101      	movne	r1, #1
    2ff2:	2100      	moveq	r1, #0
        if ((_mosi != -1) && (lastmosi != towrite)) {
    2ff4:	1c43      	adds	r3, r0, #1
    2ff6:	d006      	beq.n	3006 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xa2>
    2ff8:	9b00      	ldr	r3, [sp, #0]
    2ffa:	4299      	cmp	r1, r3
    2ffc:	d003      	beq.n	3006 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xa2>
          if (towrite)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
#else
          digitalWrite(_mosi, towrite);
    2ffe:	b2c0      	uxtb	r0, r0
    3000:	9100      	str	r1, [sp, #0]
    3002:	f7fe f951 	bl	12a8 <digitalWrite>
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    3006:	2101      	movs	r1, #1
    3008:	f898 000f 	ldrb.w	r0, [r8, #15]
    300c:	f7fe f94c 	bl	12a8 <digitalWrite>
#endif

        if (bitdelay_us) {
    3010:	b15e      	cbz	r6, 302a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xc6>
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3012:	4a37      	ldr	r2, [pc, #220]	; (30f0 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x18c>)
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3014:	6820      	ldr	r0, [r4, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3016:	6811      	ldr	r1, [r2, #0]
    3018:	fba9 3101 	umull	r3, r1, r9, r1
    301c:	0c89      	lsrs	r1, r1, #18
    301e:	fb01 f106 	mul.w	r1, r1, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    3022:	6823      	ldr	r3, [r4, #0]
    3024:	1a1b      	subs	r3, r3, r0
    3026:	4299      	cmp	r1, r3
    3028:	d8fb      	bhi.n	3022 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xbe>
          delayMicroseconds(bitdelay_us);
        }

        if (_miso != -1) {
    302a:	f998 0011 	ldrsb.w	r0, [r8, #17]
    302e:	1c41      	adds	r1, r0, #1
    3030:	d004      	beq.n	303c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xd8>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
#else
          if (digitalRead(_miso)) {
    3032:	b2c0      	uxtb	r0, r0
    3034:	f7fe f93e 	bl	12b4 <digitalRead>
    3038:	b100      	cbz	r0, 303c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xd8>
#endif
            reply |= b;
    303a:	432f      	orrs	r7, r5
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
#else
        digitalWrite(_sck, LOW);
    303c:	2100      	movs	r1, #0
    303e:	f898 000f 	ldrb.w	r0, [r8, #15]
    3042:	f7fe f931 	bl	12a8 <digitalWrite>
#endif
            reply |= b;
          }
        }
      }
      if (_miso != -1) {
    3046:	f998 2011 	ldrsb.w	r2, [r8, #17]
    304a:	3201      	adds	r2, #1
        buffer[i] = reply;
    304c:	bf18      	it	ne
    304e:	f80b 7c01 	strbne.w	r7, [fp, #-1]
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    3052:	f898 200c 	ldrb.w	r2, [r8, #12]
    3056:	b962      	cbnz	r2, 3072 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x10e>
    3058:	006d      	lsls	r5, r5, #1
    305a:	b2ed      	uxtb	r5, r5
    305c:	2d00      	cmp	r5, #0
    305e:	d1af      	bne.n	2fc0 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
    3060:	4643      	mov	r3, r8
    3062:	46d8      	mov	r8, fp
    3064:	469b      	mov	fp, r3
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    3066:	9b03      	ldr	r3, [sp, #12]
    3068:	4543      	cmp	r3, r8
    306a:	d1a2      	bne.n	2fb2 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x4e>
        buffer[i] = reply;
      }
    }
  }
  return;
}
    306c:	b005      	add	sp, #20
    306e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    3072:	086d      	lsrs	r5, r5, #1
    3074:	2d00      	cmp	r5, #0
    3076:	d1a3      	bne.n	2fc0 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
    3078:	e7f2      	b.n	3060 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xfc>

      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    307a:	f898 200d 	ldrb.w	r2, [r8, #13]
    307e:	f012 0ff7 	tst.w	r2, #247	; 0xf7
    3082:	d0b0      	beq.n	2fe6 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x82>
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    3084:	2101      	movs	r1, #1
    3086:	f898 000f 	ldrb.w	r0, [r8, #15]
    308a:	f7fe f90d 	bl	12a8 <digitalWrite>

        if (bitdelay_us) {
          delayMicroseconds(bitdelay_us);
        }

        if (_mosi != -1) {
    308e:	f998 0010 	ldrsb.w	r0, [r8, #16]
    3092:	1c42      	adds	r2, r0, #1
    3094:	d004      	beq.n	30a0 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x13c>
          if (send & b)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
#else
          digitalWrite(_mosi, send & b);
    3096:	b2c0      	uxtb	r0, r0
    3098:	ea0a 0105 	and.w	r1, sl, r5
    309c:	f7fe f904 	bl	12a8 <digitalWrite>
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
#else
        digitalWrite(_sck, LOW);
    30a0:	f898 000f 	ldrb.w	r0, [r8, #15]
    30a4:	2100      	movs	r1, #0
    30a6:	f7fe f8ff 	bl	12a8 <digitalWrite>
#endif

        if (_miso != -1) {
    30aa:	f998 0011 	ldrsb.w	r0, [r8, #17]
    30ae:	1c43      	adds	r3, r0, #1
    30b0:	d0cf      	beq.n	3052 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xee>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
#else
          if (digitalRead(_miso)) {
    30b2:	b2c0      	uxtb	r0, r0
    30b4:	f7fe f8fe 	bl	12b4 <digitalRead>
    30b8:	2800      	cmp	r0, #0
    30ba:	d0c4      	beq.n	3046 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xe2>
#endif
            reply |= b;
    30bc:	432f      	orrs	r7, r5
    30be:	e7c2      	b.n	3046 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xe2>
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    30c0:	2101      	movs	r1, #1
    30c2:	f898 000f 	ldrb.w	r0, [r8, #15]
    30c6:	9201      	str	r2, [sp, #4]
    30c8:	f7fe f8ee 	bl	12a8 <digitalWrite>
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    30cc:	4b07      	ldr	r3, [pc, #28]	; (30ec <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x188>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    30ce:	9a01      	ldr	r2, [sp, #4]
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    30d0:	6818      	ldr	r0, [r3, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    30d2:	6811      	ldr	r1, [r2, #0]
    30d4:	fba9 3101 	umull	r3, r1, r9, r1
    30d8:	0c89      	lsrs	r1, r1, #18
    30da:	fb01 f106 	mul.w	r1, r1, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    30de:	6823      	ldr	r3, [r4, #0]
    30e0:	1a1b      	subs	r3, r3, r0
    30e2:	4299      	cmp	r1, r3
    30e4:	d8fb      	bhi.n	30de <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x17a>
    30e6:	e7d2      	b.n	308e <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x12a>
    30e8:	0007a120 	.word	0x0007a120
    30ec:	e0001004 	.word	0xe0001004
    30f0:	20001430 	.word	0x20001430
    30f4:	431bde83 	.word	0x431bde83

000030f8 <Adafruit_SPIDevice::endTransaction()>:

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 */
void Adafruit_SPIDevice::endTransaction(void) {
  if (_spi) {
    30f8:	6802      	ldr	r2, [r0, #0]
    30fa:	b1f2      	cbz	r2, 313a <Adafruit_SPIDevice::endTransaction()+0x42>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    30fc:	7cd3      	ldrb	r3, [r2, #19]
    30fe:	b1e3      	cbz	r3, 313a <Adafruit_SPIDevice::endTransaction()+0x42>
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
    3100:	07d8      	lsls	r0, r3, #31
    3102:	d503      	bpl.n	310c <Adafruit_SPIDevice::endTransaction()+0x14>
    3104:	4b0d      	ldr	r3, [pc, #52]	; (313c <Adafruit_SPIDevice::endTransaction()+0x44>)
    3106:	6a91      	ldr	r1, [r2, #40]	; 0x28
    3108:	6019      	str	r1, [r3, #0]
    310a:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
    310c:	0799      	lsls	r1, r3, #30
    310e:	d503      	bpl.n	3118 <Adafruit_SPIDevice::endTransaction()+0x20>
    3110:	4b0b      	ldr	r3, [pc, #44]	; (3140 <Adafruit_SPIDevice::endTransaction()+0x48>)
    3112:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    3114:	6019      	str	r1, [r3, #0]
    3116:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
    3118:	0758      	lsls	r0, r3, #29
    311a:	d503      	bpl.n	3124 <Adafruit_SPIDevice::endTransaction()+0x2c>
    311c:	4b09      	ldr	r3, [pc, #36]	; (3144 <Adafruit_SPIDevice::endTransaction()+0x4c>)
    311e:	6b11      	ldr	r1, [r2, #48]	; 0x30
    3120:	6019      	str	r1, [r3, #0]
    3122:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
    3124:	0719      	lsls	r1, r3, #28
    3126:	d503      	bpl.n	3130 <Adafruit_SPIDevice::endTransaction()+0x38>
    3128:	4b07      	ldr	r3, [pc, #28]	; (3148 <Adafruit_SPIDevice::endTransaction()+0x50>)
    312a:	6b51      	ldr	r1, [r2, #52]	; 0x34
    312c:	6019      	str	r1, [r3, #0]
    312e:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
    3130:	06db      	lsls	r3, r3, #27
    3132:	d502      	bpl.n	313a <Adafruit_SPIDevice::endTransaction()+0x42>
    3134:	6b92      	ldr	r2, [r2, #56]	; 0x38
    3136:	4b05      	ldr	r3, [pc, #20]	; (314c <Adafruit_SPIDevice::endTransaction()+0x54>)
    3138:	601a      	str	r2, [r3, #0]
    313a:	4770      	bx	lr
    313c:	e000e100 	.word	0xe000e100
    3140:	e000e104 	.word	0xe000e104
    3144:	e000e108 	.word	0xe000e108
    3148:	e000e10c 	.word	0xe000e10c
    314c:	e000e110 	.word	0xe000e110

00003150 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>:
/*!
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 * SPI)
 */
void Adafruit_SPIDevice::beginTransaction(void) {
  if (_spi) {
    3150:	6803      	ldr	r3, [r0, #0]
 *    @brief  Write a buffer or two to the SPI device, with transaction
 * management.
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
    3152:	b470      	push	{r4, r5, r6}
/*!
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 * SPI)
 */
void Adafruit_SPIDevice::beginTransaction(void) {
  if (_spi) {
    3154:	2b00      	cmp	r3, #0
    3156:	d02d      	beq.n	31b4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x64>
#ifdef BUSIO_HAS_HW_SPI
    _spi->beginTransaction(*_spiSetting);
    3158:	6842      	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    315a:	7cdc      	ldrb	r4, [r3, #19]
    315c:	e892 0022 	ldmia.w	r2, {r1, r5}
    3160:	2c00      	cmp	r4, #0
    3162:	d130      	bne.n	31c6 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x76>
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
    3164:	689a      	ldr	r2, [r3, #8]
    3166:	428a      	cmp	r2, r1
    3168:	d05f      	beq.n	322a <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xda>
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
    316a:	4a39      	ldr	r2, [pc, #228]	; (3250 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x100>)
						     720000000,  // PLL3 PFD0
						     528000000,  // PLL2
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();
    316c:	6099      	str	r1, [r3, #8]

			uint32_t cbcmr = CCM_CBCMR;
    316e:	6992      	ldr	r2, [r2, #24]
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
    3170:	4c38      	ldr	r4, [pc, #224]	; (3254 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x104>)
    3172:	f3c2 1601 	ubfx	r6, r2, #4, #2
    3176:	f3c2 6282 	ubfx	r2, r2, #26, #3
    317a:	f854 4026 	ldr.w	r4, [r4, r6, lsl #2]
    317e:	3201      	adds	r2, #1
    3180:	fbb4 f4f2 	udiv	r4, r4, r2
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
    3184:	2900      	cmp	r1, #0
    3186:	d052      	beq.n	322e <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xde>
    3188:	fbb4 f2f1 	udiv	r2, r4, r1

			if (d && clkhz/d > _clock) d++;
    318c:	b142      	cbz	r2, 31a0 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    318e:	fbb4 f4f2 	udiv	r4, r4, r2
    3192:	428c      	cmp	r4, r1
    3194:	bf88      	it	hi
    3196:	3201      	addhi	r2, #1
			if (d > 257) d= 257;  // max div
    3198:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
    319c:	d34b      	bcc.n	3236 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xe6>
    319e:	4a2e      	ldr	r2, [pc, #184]	; (3258 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x108>)
				div = d-2;
			} else {
				div =0;
			}
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);
    31a0:	60da      	str	r2, [r3, #12]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    31a2:	681b      	ldr	r3, [r3, #0]
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
    31a4:	2600      	movs	r6, #0
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
    31a6:	2403      	movs	r4, #3
		port().CCR = _ccr;
		port().TCR = settings.tcr;
		port().CR = LPSPI_CR_MEN;
    31a8:	2101      	movs	r1, #1
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
    31aa:	611e      	str	r6, [r3, #16]
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
    31ac:	625c      	str	r4, [r3, #36]	; 0x24
		port().CCR = _ccr;
    31ae:	641a      	str	r2, [r3, #64]	; 0x40
		port().TCR = settings.tcr;
    31b0:	661d      	str	r5, [r3, #96]	; 0x60
		port().CR = LPSPI_CR_MEN;
    31b2:	6119      	str	r1, [r3, #16]
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    31b4:	f990 000e 	ldrsb.w	r0, [r0, #14]
    31b8:	1c43      	adds	r3, r0, #1
    31ba:	d03a      	beq.n	3232 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xe2>
    digitalWrite(_cs, value);
    31bc:	b2c0      	uxtb	r0, r0
    31be:	2100      	movs	r1, #0
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    31c0:	bc70      	pop	{r4, r5, r6}
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    digitalWrite(_cs, value);
    31c2:	f7fe b871 	b.w	12a8 <digitalWrite>
	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
			__disable_irq();
    31c6:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    31c8:	7cda      	ldrb	r2, [r3, #19]
    31ca:	07d6      	lsls	r6, r2, #31
    31cc:	d506      	bpl.n	31dc <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x8c>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    31ce:	4c23      	ldr	r4, [pc, #140]	; (325c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x10c>)
    31d0:	695a      	ldr	r2, [r3, #20]
    31d2:	6826      	ldr	r6, [r4, #0]
    31d4:	4032      	ands	r2, r6
    31d6:	629a      	str	r2, [r3, #40]	; 0x28
				NVIC_ICER0 = interruptSave[0];
    31d8:	6022      	str	r2, [r4, #0]
    31da:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x02) {
    31dc:	0794      	lsls	r4, r2, #30
    31de:	d506      	bpl.n	31ee <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x9e>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    31e0:	4c1f      	ldr	r4, [pc, #124]	; (3260 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x110>)
    31e2:	699a      	ldr	r2, [r3, #24]
    31e4:	6826      	ldr	r6, [r4, #0]
    31e6:	4032      	ands	r2, r6
    31e8:	62da      	str	r2, [r3, #44]	; 0x2c
				NVIC_ICER1 = interruptSave[1];
    31ea:	6022      	str	r2, [r4, #0]
    31ec:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x04) {
    31ee:	0756      	lsls	r6, r2, #29
    31f0:	d506      	bpl.n	3200 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xb0>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    31f2:	4c1c      	ldr	r4, [pc, #112]	; (3264 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x114>)
    31f4:	69da      	ldr	r2, [r3, #28]
    31f6:	6826      	ldr	r6, [r4, #0]
    31f8:	4032      	ands	r2, r6
    31fa:	631a      	str	r2, [r3, #48]	; 0x30
				NVIC_ICER2 = interruptSave[2];
    31fc:	6022      	str	r2, [r4, #0]
    31fe:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x08) {
    3200:	0714      	lsls	r4, r2, #28
    3202:	d506      	bpl.n	3212 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xc2>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    3204:	4c18      	ldr	r4, [pc, #96]	; (3268 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x118>)
    3206:	6a1a      	ldr	r2, [r3, #32]
    3208:	6826      	ldr	r6, [r4, #0]
    320a:	4032      	ands	r2, r6
    320c:	635a      	str	r2, [r3, #52]	; 0x34
				NVIC_ICER3 = interruptSave[3];
    320e:	6022      	str	r2, [r4, #0]
    3210:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x10) {
    3212:	06d2      	lsls	r2, r2, #27
    3214:	d505      	bpl.n	3222 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xd2>
				interruptSave[4] = NVIC_ICER4 & interruptMask[4];
    3216:	4c15      	ldr	r4, [pc, #84]	; (326c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x11c>)
    3218:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    321a:	6826      	ldr	r6, [r4, #0]
    321c:	4032      	ands	r2, r6
    321e:	639a      	str	r2, [r3, #56]	; 0x38
				NVIC_ICER4 = interruptSave[4];
    3220:	6022      	str	r2, [r4, #0]
			}
			__enable_irq();
    3222:	b662      	cpsie	i
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
    3224:	689a      	ldr	r2, [r3, #8]
    3226:	428a      	cmp	r2, r1
    3228:	d19f      	bne.n	316a <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x1a>
    322a:	68da      	ldr	r2, [r3, #12]
    322c:	e7b9      	b.n	31a2 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x52>

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
    322e:	4622      	mov	r2, r4
    3230:	e7ac      	b.n	318c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x3c>
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    3232:	bc70      	pop	{r4, r5, r6}
    3234:	4770      	bx	lr

			if (d && clkhz/d > _clock) d++;
			if (d > 257) d= 257;  // max div
			if (d > 2) {
    3236:	2a02      	cmp	r2, #2
    3238:	d908      	bls.n	324c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xfc>
    323a:	3a02      	subs	r2, #2
    323c:	0854      	lsrs	r4, r2, #1
    323e:	0421      	lsls	r1, r4, #16
    3240:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
    3244:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    3248:	430a      	orrs	r2, r1
    324a:	e7a9      	b.n	31a0 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    324c:	2200      	movs	r2, #0
    324e:	e7a7      	b.n	31a0 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    3250:	400fc000 	.word	0x400fc000
    3254:	200005b4 	.word	0x200005b4
    3258:	007f7fff 	.word	0x007f7fff
    325c:	e000e180 	.word	0xe000e180
    3260:	e000e184 	.word	0xe000e184
    3264:	e000e188 	.word	0xe000e188
    3268:	e000e18c 	.word	0xe000e18c
    326c:	e000e190 	.word	0xe000e190

00003270 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>:

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
    3270:	b510      	push	{r4, lr}
    3272:	4604      	mov	r4, r0
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    3274:	f990 000e 	ldrsb.w	r0, [r0, #14]
    3278:	1c43      	adds	r3, r0, #1
    327a:	d003      	beq.n	3284 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()+0x14>
    digitalWrite(_cs, value);
    327c:	b2c0      	uxtb	r0, r0
    327e:	2101      	movs	r1, #1
    3280:	f7fe f812 	bl	12a8 <digitalWrite>
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
    3284:	4620      	mov	r0, r4
}
    3286:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
    328a:	f7ff bf35 	b.w	30f8 <Adafruit_SPIDevice::endTransaction()>
    328e:	bf00      	nop

00003290 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>:
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(const uint8_t *buffer, size_t len,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    3290:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3294:	b083      	sub	sp, #12
    3296:	460c      	mov	r4, r1
    3298:	4690      	mov	r8, r2
    329a:	461d      	mov	r5, r3
    329c:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    32a0:	4606      	mov	r6, r0
  beginTransactionWithAssertingCS();
    32a2:	f7ff ff55 	bl	3150 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
      _spi->transferBytes(buffer, nullptr, len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
    32a6:	f1b9 0f00 	cmp.w	r9, #0
    32aa:	d00d      	beq.n	32c8 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x38>
    32ac:	f10d 0707 	add.w	r7, sp, #7
    32b0:	44a9      	add	r9, r5
      transfer(prefix_buffer[i]);
    32b2:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    32b6:	2201      	movs	r2, #1
    32b8:	4639      	mov	r1, r7
    32ba:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    32bc:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    32c0:	f7ff fe50 	bl	2f64 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
      _spi->transferBytes(buffer, nullptr, len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
    32c4:	454d      	cmp	r5, r9
    32c6:	d1f4      	bne.n	32b2 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x22>
      transfer(prefix_buffer[i]);
    }
    for (size_t i = 0; i < len; i++) {
    32c8:	f1b8 0f00 	cmp.w	r8, #0
    32cc:	d00e      	beq.n	32ec <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x5c>
    32ce:	f10d 0707 	add.w	r7, sp, #7
    32d2:	eb04 0508 	add.w	r5, r4, r8
      transfer(buffer[i]);
    32d6:	f814 3b01 	ldrb.w	r3, [r4], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    32da:	2201      	movs	r2, #1
    32dc:	4639      	mov	r1, r7
    32de:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    32e0:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    32e4:	f7ff fe3e 	bl	2f64 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
      transfer(prefix_buffer[i]);
    }
    for (size_t i = 0; i < len; i++) {
    32e8:	42ac      	cmp	r4, r5
    32ea:	d1f4      	bne.n	32d6 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x46>
      transfer(buffer[i]);
    }
  }
  endTransactionWithDeassertingCS();
    32ec:	4630      	mov	r0, r6
    32ee:	f7ff ffbf 	bl	3270 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    32f2:	2001      	movs	r0, #1
    32f4:	b003      	add	sp, #12
    32f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    32fa:	bf00      	nop

000032fc <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>:
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
    32fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3300:	4692      	mov	sl, r2
    3302:	b082      	sub	sp, #8
    3304:	460d      	mov	r5, r1
    3306:	461c      	mov	r4, r3
    3308:	4606      	mov	r6, r0
    330a:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    330e:	f89d 802c 	ldrb.w	r8, [sp, #44]	; 0x2c
  beginTransactionWithAssertingCS();
    3312:	f7ff ff1d 	bl	3150 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
      _spi->transferBytes(write_buffer, nullptr, write_len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
    3316:	f1ba 0f00 	cmp.w	sl, #0
    331a:	d00d      	beq.n	3338 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x3c>
    331c:	f10d 0707 	add.w	r7, sp, #7
    3320:	44aa      	add	sl, r5
      transfer(write_buffer[i]);
    3322:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    3326:	2201      	movs	r2, #1
    3328:	4639      	mov	r1, r7
    332a:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    332c:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    3330:	f7ff fe18 	bl	2f64 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
      _spi->transferBytes(write_buffer, nullptr, write_len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
    3334:	4555      	cmp	r5, sl
    3336:	d1f4      	bne.n	3322 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x26>
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    3338:	f1b9 0f00 	cmp.w	r9, #0
    333c:	d00f      	beq.n	335e <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x62>
    333e:	f10d 0707 	add.w	r7, sp, #7
    3342:	44a1      	add	r9, r4
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    3344:	2201      	movs	r2, #1
    3346:	4639      	mov	r1, r7
    3348:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    334a:	f88d 8007 	strb.w	r8, [sp, #7]
  transfer(&data, 1);
    334e:	f7ff fe09 	bl	2f64 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
  return data;
    3352:	f89d 3007 	ldrb.w	r3, [sp, #7]
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    read_buffer[i] = transfer(sendvalue);
    3356:	f804 3b01 	strb.w	r3, [r4], #1
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    335a:	454c      	cmp	r4, r9
    335c:	d1f2      	bne.n	3344 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x48>
    }
  }
  DEBUG_SERIAL.println();
#endif

  endTransactionWithDeassertingCS();
    335e:	4630      	mov	r0, r6
    3360:	f7ff ff86 	bl	3270 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>

  return true;
}
    3364:	2001      	movs	r0, #1
    3366:	b002      	add	sp, #8
    3368:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000336c <Adafruit_Sensor::enableAutoRange(bool)>:
  // These must be defined by the subclass

  /*! @brief Whether we should automatically change the range (if possible) for
     higher precision
      @param enabled True if we will try to autorange */
  virtual void enableAutoRange(bool enabled) {
    336c:	4770      	bx	lr
    336e:	bf00      	nop

00003370 <Adafruit_LIS3MDL::~Adafruit_LIS3MDL()>:
  LIS3MDL_SINGLEMODE = 0b01,     ///< Single-shot conversion
  LIS3MDL_POWERDOWNMODE = 0b11,  ///< Powered-down mode
} lis3mdl_operationmode_t;

/** Class for hardware interfacing with an LIS3MDL magnetometer */
class Adafruit_LIS3MDL : public Adafruit_Sensor {
    3370:	4770      	bx	lr
    3372:	bf00      	nop

00003374 <Adafruit_LIS3MDL::getSensor(sensor_t*)>:
    @brief  Gets the sensor_t device data, Adafruit Unified Sensor format
    @param  sensor Pointer to an Adafruit Unified sensor_t object that we'll
   fill in
*/
/**************************************************************************/
void Adafruit_LIS3MDL::getSensor(sensor_t *sensor) {
    3374:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3376:	460c      	mov	r4, r1
    3378:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    337a:	2228      	movs	r2, #40	; 0x28
    337c:	2100      	movs	r1, #0
    337e:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3380:	2701      	movs	r7, #1
   fill in
*/
/**************************************************************************/
void Adafruit_LIS3MDL::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3382:	f003 f9eb 	bl	675c <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
    3386:	220b      	movs	r2, #11
    3388:	4909      	ldr	r1, [pc, #36]	; (33b0 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x3c>)
    338a:	4620      	mov	r0, r4
    338c:	f003 fe86 	bl	709c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3390:	2300      	movs	r3, #0
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
    3392:	2502      	movs	r5, #2
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
    3394:	4807      	ldr	r0, [pc, #28]	; (33b4 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3396:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
  sensor->max_value = 1600;   // +16 gauss in uTesla
    3398:	4907      	ldr	r1, [pc, #28]	; (33b8 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    339a:	6a76      	ldr	r6, [r6, #36]	; 0x24
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
  sensor->max_value = 1600;   // +16 gauss in uTesla
  sensor->resolution = 0.015; // 100/6842 uTesla per LSB at +-4 gauss range
    339c:	4a07      	ldr	r2, [pc, #28]	; (33bc <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x48>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    339e:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    33a0:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
    33a2:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
    33a4:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
    33a6:	61e0      	str	r0, [r4, #28]
  sensor->max_value = 1600;   // +16 gauss in uTesla
    33a8:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 0.015; // 100/6842 uTesla per LSB at +-4 gauss range
    33aa:	6222      	str	r2, [r4, #32]
    33ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    33ae:	bf00      	nop
    33b0:	20000db0 	.word	0x20000db0
    33b4:	c4c80000 	.word	0xc4c80000
    33b8:	44c80000 	.word	0x44c80000
    33bc:	3c75c28f 	.word	0x3c75c28f

000033c0 <Adafruit_LIS3MDL::~Adafruit_LIS3MDL()>:
    33c0:	b510      	push	{r4, lr}
    33c2:	4604      	mov	r4, r0
    33c4:	2128      	movs	r1, #40	; 0x28
    33c6:	f7ff fb21 	bl	2a0c <operator delete(void*, unsigned int)>
    33ca:	4620      	mov	r0, r4
    33cc:	bd10      	pop	{r4, pc}
    33ce:	bf00      	nop

000033d0 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()>:
/**************************************************************************/
/*!
    @brief  Instantiates a new LIS3MDL class
*/
/**************************************************************************/
Adafruit_LIS3MDL::Adafruit_LIS3MDL() {}
    33d0:	2200      	movs	r2, #0
    33d2:	4903      	ldr	r1, [pc, #12]	; (33e0 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()+0x10>)
    33d4:	7602      	strb	r2, [r0, #24]
    33d6:	6001      	str	r1, [r0, #0]
    33d8:	61c2      	str	r2, [r0, #28]
    33da:	6202      	str	r2, [r0, #32]
    33dc:	4770      	bx	lr
    33de:	bf00      	nop
    33e0:	20000468 	.word	0x20000468

000033e4 <Adafruit_LIS3MDL::read()>:
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    33e4:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    33e6:	2301      	movs	r3, #1
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    33e8:	b08d      	sub	sp, #52	; 0x34
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    33ea:	2506      	movs	r5, #6
    33ec:	2700      	movs	r7, #0
    33ee:	2628      	movs	r6, #40	; 0x28
    33f0:	6a02      	ldr	r2, [r0, #32]
    33f2:	69c1      	ldr	r1, [r0, #28]
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    33f4:	4604      	mov	r4, r0
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    33f6:	9303      	str	r3, [sp, #12]
    33f8:	a806      	add	r0, sp, #24
    33fa:	9501      	str	r5, [sp, #4]
    33fc:	9702      	str	r7, [sp, #8]
    33fe:	9600      	str	r6, [sp, #0]
    3400:	f7ff fb92 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  XYZDataReg.read(buffer, 6);
    3404:	462a      	mov	r2, r5
    3406:	a904      	add	r1, sp, #16
    3408:	a806      	add	r0, sp, #24
    340a:	f7ff fc11 	bl	2c30 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
  x = buffer[0];
  x |= buffer[1] << 8;
    340e:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3412:	f89d 1011 	ldrb.w	r1, [sp, #17]
  y = buffer[2];
  y |= buffer[3] << 8;
    3416:	f89d 0013 	ldrb.w	r0, [sp, #19]

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    341a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
  y = buffer[2];
  y |= buffer[3] << 8;
    341e:	f89d 2012 	ldrb.w	r2, [sp, #18]
  z = buffer[4];
  z |= buffer[5] << 8;
    3422:	f89d 5015 	ldrb.w	r5, [sp, #21]
    3426:	f89d 3014 	ldrb.w	r3, [sp, #20]
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
  y = buffer[2];
  y |= buffer[3] << 8;
    342a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  z = buffer[4];
  z |= buffer[5] << 8;

  float scale = 1; // LSB per gauss
  switch (rangeBuffered) {
    342e:	7e20      	ldrb	r0, [r4, #24]

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    3430:	b209      	sxth	r1, r1
  y = buffer[2];
  y |= buffer[3] << 8;
  z = buffer[4];
  z |= buffer[5] << 8;
    3432:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
  y = buffer[2];
  y |= buffer[3] << 8;
    3436:	b212      	sxth	r2, r2
    3438:	2803      	cmp	r0, #3
  z = buffer[4];
  z |= buffer[5] << 8;
    343a:	b21b      	sxth	r3, r3

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    343c:	80e1      	strh	r1, [r4, #6]
  y = buffer[2];
  y |= buffer[3] << 8;
    343e:	8122      	strh	r2, [r4, #8]
  z = buffer[4];
  z |= buffer[5] << 8;
    3440:	8163      	strh	r3, [r4, #10]
    3442:	d81e      	bhi.n	3482 <Adafruit_LIS3MDL::read()+0x9e>
    3444:	4d10      	ldr	r5, [pc, #64]	; (3488 <Adafruit_LIS3MDL::read()+0xa4>)
    3446:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    344a:	ed90 6a00 	vldr	s12, [r0]
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    344e:	ee07 1a90 	vmov	s15, r1
    3452:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  y_gauss = (float)y / scale;
    3456:	ee07 2a90 	vmov	s15, r2
    345a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  z_gauss = (float)z / scale;
    345e:	ee07 3a90 	vmov	s15, r3
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    3462:	eec6 5a86 	vdiv.f32	s11, s13, s12
  y_gauss = (float)y / scale;
  z_gauss = (float)z / scale;
    3466:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
  y_gauss = (float)y / scale;
    346a:	eec7 6a06 	vdiv.f32	s13, s14, s12
  z_gauss = (float)z / scale;
    346e:	ee87 7a86 	vdiv.f32	s14, s15, s12
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    3472:	edc4 5a03 	vstr	s11, [r4, #12]
  y_gauss = (float)y / scale;
    3476:	edc4 6a04 	vstr	s13, [r4, #16]
  z_gauss = (float)z / scale;
    347a:	ed84 7a05 	vstr	s14, [r4, #20]
}
    347e:	b00d      	add	sp, #52	; 0x34
    3480:	bdf0      	pop	{r4, r5, r6, r7, pc}
  y |= buffer[3] << 8;
  z = buffer[4];
  z |= buffer[5] << 8;

  float scale = 1; // LSB per gauss
  switch (rangeBuffered) {
    3482:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    3486:	e7e2      	b.n	344e <Adafruit_LIS3MDL::read()+0x6a>
    3488:	20000428 	.word	0x20000428

0000348c <Adafruit_LIS3MDL::getEvent(sensors_event_t*)>:
    @param  event Pointer to an Adafruit Unified sensor_event_t object that
   we'll fill in
    @returns True on successful read
*/
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
    348c:	b570      	push	{r4, r5, r6, lr}
    348e:	460c      	mov	r4, r1
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    3490:	2624      	movs	r6, #36	; 0x24
    @param  event Pointer to an Adafruit Unified sensor_event_t object that
   we'll fill in
    @returns True on successful read
*/
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
    3492:	4605      	mov	r5, r0
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    3494:	2100      	movs	r1, #0
    3496:	4632      	mov	r2, r6
    3498:	4620      	mov	r0, r4
    349a:	f003 f95f 	bl	675c <memset>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
    349e:	4b10      	ldr	r3, [pc, #64]	; (34e0 <Adafruit_LIS3MDL::getEvent(sensors_event_t*)+0x54>)

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
    34a0:	6a69      	ldr	r1, [r5, #36]	; 0x24
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
    34a2:	2202      	movs	r2, #2
    34a4:	681b      	ldr	r3, [r3, #0]
  event->timestamp = millis();

  read();
    34a6:	4628      	mov	r0, r5
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));

  event->version = sizeof(sensors_event_t);
    34a8:	6026      	str	r6, [r4, #0]
  event->sensor_id = _sensorID;
    34aa:	6061      	str	r1, [r4, #4]
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
    34ac:	60a2      	str	r2, [r4, #8]
  event->timestamp = millis();
    34ae:	6123      	str	r3, [r4, #16]

  read();
    34b0:	f7ff ff98 	bl	33e4 <Adafruit_LIS3MDL::read()>

  event->magnetic.x = x_gauss * 100; // microTesla per gauss
    34b4:	edd5 7a03 	vldr	s15, [r5, #12]
    34b8:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 34e4 <Adafruit_LIS3MDL::getEvent(sensors_event_t*)+0x58>
  event->magnetic.y = y_gauss * 100; // microTesla per gauss
  event->magnetic.z = z_gauss * 100; // microTesla per gauss

  return true;
}
    34bc:	2001      	movs	r0, #1
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
  event->timestamp = millis();

  read();

  event->magnetic.x = x_gauss * 100; // microTesla per gauss
    34be:	ee67 7a87 	vmul.f32	s15, s15, s14
    34c2:	edc4 7a05 	vstr	s15, [r4, #20]
  event->magnetic.y = y_gauss * 100; // microTesla per gauss
    34c6:	edd5 7a04 	vldr	s15, [r5, #16]
    34ca:	ee67 7a87 	vmul.f32	s15, s15, s14
    34ce:	edc4 7a06 	vstr	s15, [r4, #24]
  event->magnetic.z = z_gauss * 100; // microTesla per gauss
    34d2:	edd5 7a05 	vldr	s15, [r5, #20]
    34d6:	ee67 7a87 	vmul.f32	s15, s15, s14
    34da:	edc4 7a07 	vstr	s15, [r4, #28]

  return true;
}
    34de:	bd70      	pop	{r4, r5, r6, pc}
    34e0:	20002740 	.word	0x20002740
    34e4:	42c80000 	.word	0x42c80000

000034e8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>:
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    34e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    34ea:	69c3      	ldr	r3, [r0, #28]
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    34ec:	b095      	sub	sp, #84	; 0x54
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    34ee:	f04f 0e20 	mov.w	lr, #32
    34f2:	2401      	movs	r4, #1
    34f4:	2700      	movs	r7, #0
    34f6:	6a02      	ldr	r2, [r0, #32]
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    34f8:	4605      	mov	r5, r0
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    34fa:	f8cd e000 	str.w	lr, [sp]
    34fe:	eb0d 000e 	add.w	r0, sp, lr
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    3502:	460e      	mov	r6, r1
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3504:	9403      	str	r4, [sp, #12]
    3506:	4619      	mov	r1, r3
    3508:	9401      	str	r4, [sp, #4]
    350a:	4623      	mov	r3, r4
    350c:	9702      	str	r7, [sp, #8]
    350e:	f7ff fb0b 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits performancemodebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG1, 2, 5);
    3512:	a908      	add	r1, sp, #32
    3514:	2305      	movs	r3, #5
    3516:	2202      	movs	r2, #2
    3518:	a804      	add	r0, sp, #16
    351a:	f7ff fc01 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  performancemodebits.write((uint8_t)mode);
    351e:	4631      	mov	r1, r6
    3520:	a804      	add	r0, sp, #16
    3522:	f7ff fc13 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // write z
  Adafruit_BusIO_Register CTRL_REG4 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG4, 1);
    3526:	6a2a      	ldr	r2, [r5, #32]
    3528:	69e9      	ldr	r1, [r5, #28]
    352a:	2523      	movs	r5, #35	; 0x23
    352c:	4623      	mov	r3, r4
    352e:	9702      	str	r7, [sp, #8]
    3530:	9403      	str	r4, [sp, #12]
    3532:	a80e      	add	r0, sp, #56	; 0x38
    3534:	9401      	str	r4, [sp, #4]
    3536:	9500      	str	r5, [sp, #0]
    3538:	f7ff faf6 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits performancemodezbits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG4, 2, 2);
    353c:	2302      	movs	r3, #2
    353e:	a90e      	add	r1, sp, #56	; 0x38
    3540:	a806      	add	r0, sp, #24
    3542:	461a      	mov	r2, r3
    3544:	f7ff fbec 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  performancemodezbits.write((uint8_t)mode);
    3548:	4631      	mov	r1, r6
    354a:	a806      	add	r0, sp, #24
    354c:	f7ff fbfe 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3550:	b015      	add	sp, #84	; 0x54
    3552:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003554 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>:
    from 0.625 Hz to 80Hz
    @param dataRate Enumerated lis3mdl_dataRate_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    3554:	2901      	cmp	r1, #1
    @brief  Sets the data rate for the LIS3MDL (controls power consumption)
    from 0.625 Hz to 80Hz
    @param dataRate Enumerated lis3mdl_dataRate_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
    3556:	b5f0      	push	{r4, r5, r6, r7, lr}
    3558:	460c      	mov	r4, r1
    355a:	b08d      	sub	sp, #52	; 0x34
    355c:	4606      	mov	r6, r0
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    355e:	d025      	beq.n	35ac <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x58>
    // set OP to UHP
    setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_300_HZ) {
    3560:	2903      	cmp	r1, #3
    3562:	d027      	beq.n	35b4 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x60>
    // set OP to HP
    setPerformanceMode(LIS3MDL_HIGHMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_560_HZ) {
    3564:	2905      	cmp	r1, #5
    3566:	d029      	beq.n	35bc <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x68>
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    3568:	2907      	cmp	r1, #7
    356a:	d01b      	beq.n	35a4 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x50>
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
  }
  delay(10);
    356c:	200a      	movs	r0, #10
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    356e:	2501      	movs	r5, #1
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
  }
  delay(10);
    3570:	f7fd fe00 	bl	1174 <delay>
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3574:	2700      	movs	r7, #0
    3576:	6a32      	ldr	r2, [r6, #32]
    3578:	462b      	mov	r3, r5
    357a:	69f1      	ldr	r1, [r6, #28]
    357c:	2620      	movs	r6, #32
    357e:	a806      	add	r0, sp, #24
    3580:	9503      	str	r5, [sp, #12]
    3582:	9501      	str	r5, [sp, #4]
    3584:	9702      	str	r7, [sp, #8]
    3586:	9600      	str	r6, [sp, #0]
    3588:	f7ff face 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits dataratebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG1, 4, 1); // includes FAST_ODR
    358c:	462b      	mov	r3, r5
    358e:	a906      	add	r1, sp, #24
    3590:	2204      	movs	r2, #4
    3592:	a804      	add	r0, sp, #16
    3594:	f7ff fbc4 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  dataratebits.write((uint8_t)dataRate);
    3598:	4621      	mov	r1, r4
    359a:	a804      	add	r0, sp, #16
    359c:	f7ff fbd6 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    35a0:	b00d      	add	sp, #52	; 0x34
    35a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
    35a4:	2100      	movs	r1, #0
    35a6:	f7ff ff9f 	bl	34e8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    35aa:	e7df      	b.n	356c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    // set OP to UHP
    setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
    35ac:	2103      	movs	r1, #3
    35ae:	f7ff ff9b 	bl	34e8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    35b2:	e7db      	b.n	356c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
  }
  if (dataRate == LIS3MDL_DATARATE_300_HZ) {
    // set OP to HP
    setPerformanceMode(LIS3MDL_HIGHMODE);
    35b4:	2102      	movs	r1, #2
    35b6:	f7ff ff97 	bl	34e8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    35ba:	e7d7      	b.n	356c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
  }
  if (dataRate == LIS3MDL_DATARATE_560_HZ) {
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
    35bc:	2101      	movs	r1, #1
    35be:	f7ff ff93 	bl	34e8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    35c2:	e7d3      	b.n	356c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>

000035c4 <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>:
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    35c4:	b570      	push	{r4, r5, r6, lr}
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    35c6:	6a02      	ldr	r2, [r0, #32]
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    35c8:	b08c      	sub	sp, #48	; 0x30
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    35ca:	69c0      	ldr	r0, [r0, #28]
    35cc:	2301      	movs	r3, #1
    35ce:	2400      	movs	r4, #0
    35d0:	2622      	movs	r6, #34	; 0x22
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    35d2:	460d      	mov	r5, r1
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    35d4:	9303      	str	r3, [sp, #12]
    35d6:	4601      	mov	r1, r0
    35d8:	9301      	str	r3, [sp, #4]
    35da:	a806      	add	r0, sp, #24
    35dc:	9402      	str	r4, [sp, #8]
    35de:	9600      	str	r6, [sp, #0]
    35e0:	f7ff faa2 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits opmodebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG3, 2, 0);
    35e4:	4623      	mov	r3, r4
    35e6:	a906      	add	r1, sp, #24
    35e8:	2202      	movs	r2, #2
    35ea:	a804      	add	r0, sp, #16
    35ec:	f7ff fb98 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  opmodebits.write((uint8_t)mode);
    35f0:	4629      	mov	r1, r5
    35f2:	a804      	add	r0, sp, #16
    35f4:	f7ff fbaa 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    35f8:	b00c      	add	sp, #48	; 0x30
    35fa:	bd70      	pop	{r4, r5, r6, pc}

000035fc <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>:
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    35fc:	b5f0      	push	{r4, r5, r6, r7, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    35fe:	2301      	movs	r3, #1
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    3600:	b08d      	sub	sp, #52	; 0x34
    3602:	4604      	mov	r4, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3604:	2700      	movs	r7, #0
    3606:	2621      	movs	r6, #33	; 0x21
    3608:	6a02      	ldr	r2, [r0, #32]
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    360a:	460d      	mov	r5, r1
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    360c:	a806      	add	r0, sp, #24
    360e:	69e1      	ldr	r1, [r4, #28]
    3610:	9303      	str	r3, [sp, #12]
    3612:	9301      	str	r3, [sp, #4]
    3614:	9702      	str	r7, [sp, #8]
    3616:	9600      	str	r6, [sp, #0]
    3618:	f7ff fa86 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits rangebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 2, 5);
    361c:	a906      	add	r1, sp, #24
    361e:	2305      	movs	r3, #5
    3620:	2202      	movs	r2, #2
    3622:	a804      	add	r0, sp, #16
    3624:	f7ff fb7c 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  rangebits.write((uint8_t)range);
    3628:	4629      	mov	r1, r5
    362a:	a804      	add	r0, sp, #16
    362c:	f7ff fb8e 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  rangeBuffered = range;
    3630:	7625      	strb	r5, [r4, #24]
}
    3632:	b00d      	add	sp, #52	; 0x34
    3634:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3636:	bf00      	nop

00003638 <Adafruit_LIS3MDL::getRange()>:
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    3638:	b570      	push	{r4, r5, r6, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    363a:	2301      	movs	r3, #1
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    363c:	b08c      	sub	sp, #48	; 0x30
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    363e:	2600      	movs	r6, #0
    3640:	2521      	movs	r5, #33	; 0x21
    3642:	6a02      	ldr	r2, [r0, #32]
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    3644:	4604      	mov	r4, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3646:	69c1      	ldr	r1, [r0, #28]
    3648:	a806      	add	r0, sp, #24
    364a:	9303      	str	r3, [sp, #12]
    364c:	9301      	str	r3, [sp, #4]
    364e:	9602      	str	r6, [sp, #8]
    3650:	9500      	str	r5, [sp, #0]
    3652:	f7ff fa69 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits rangebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 2, 5);
    3656:	a906      	add	r1, sp, #24
    3658:	2305      	movs	r3, #5
    365a:	2202      	movs	r2, #2
    365c:	a804      	add	r0, sp, #16
    365e:	f7ff fb5f 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  rangeBuffered = (lis3mdl_range_t)rangebits.read();
    3662:	a804      	add	r0, sp, #16
    3664:	f7ff fb64 	bl	2d30 <Adafruit_BusIO_RegisterBits::read()>
    3668:	b2c0      	uxtb	r0, r0
    366a:	7620      	strb	r0, [r4, #24]

  return rangeBuffered;
}
    366c:	b00c      	add	sp, #48	; 0x30
    366e:	bd70      	pop	{r4, r5, r6, pc}

00003670 <Adafruit_LIS3MDL::reset()>:
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3670:	b5f0      	push	{r4, r5, r6, r7, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3672:	2401      	movs	r4, #1
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3674:	b08d      	sub	sp, #52	; 0x34
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3676:	2700      	movs	r7, #0
    3678:	2621      	movs	r6, #33	; 0x21
    367a:	6a02      	ldr	r2, [r0, #32]
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    367c:	4605      	mov	r5, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    367e:	69c1      	ldr	r1, [r0, #28]
    3680:	4623      	mov	r3, r4
    3682:	a806      	add	r0, sp, #24
    3684:	9403      	str	r4, [sp, #12]
    3686:	9401      	str	r4, [sp, #4]
    3688:	9702      	str	r7, [sp, #8]
    368a:	9600      	str	r6, [sp, #0]
    368c:	f7ff fa4c 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits resetbits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 1, 2);
    3690:	4622      	mov	r2, r4
    3692:	2302      	movs	r3, #2
    3694:	a906      	add	r1, sp, #24
    3696:	a804      	add	r0, sp, #16
    3698:	f7ff fb42 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  resetbits.write(0x1);
    369c:	4621      	mov	r1, r4
    369e:	a804      	add	r0, sp, #16
    36a0:	f7ff fb54 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
  delay(10);
    36a4:	200a      	movs	r0, #10
    36a6:	f7fd fd65 	bl	1174 <delay>

  getRange();
    36aa:	4628      	mov	r0, r5
    36ac:	f7ff ffc4 	bl	3638 <Adafruit_LIS3MDL::getRange()>
}
    36b0:	b00d      	add	sp, #52	; 0x34
    36b2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000036b4 <Adafruit_LIS3MDL::_init()>:

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    36b4:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    36b6:	2501      	movs	r5, #1

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    36b8:	b08b      	sub	sp, #44	; 0x2c
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    36ba:	2400      	movs	r4, #0
    36bc:	270f      	movs	r7, #15
    36be:	6a02      	ldr	r2, [r0, #32]
    36c0:	462b      	mov	r3, r5
    36c2:	69c1      	ldr	r1, [r0, #28]

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    36c4:	4606      	mov	r6, r0
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    36c6:	9503      	str	r5, [sp, #12]
    36c8:	a804      	add	r0, sp, #16
    36ca:	9501      	str	r5, [sp, #4]
    36cc:	9402      	str	r4, [sp, #8]
    36ce:	9700      	str	r7, [sp, #0]
    36d0:	f7ff fa2a 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  // make sure we're talking to the right chip
  if (chip_id.read() != 0x3D) {
    36d4:	a804      	add	r0, sp, #16
    36d6:	f7ff faf9 	bl	2ccc <Adafruit_BusIO_Register::read()>
    36da:	283d      	cmp	r0, #61	; 0x3d
    36dc:	d002      	beq.n	36e4 <Adafruit_LIS3MDL::_init()+0x30>
    // No LIS3MDL detected ... return false
    return false;
    36de:	4620      	mov	r0, r4
  setRange(LIS3MDL_RANGE_4_GAUSS);

  setOperationMode(LIS3MDL_CONTINUOUSMODE);

  return true;
}
    36e0:	b00b      	add	sp, #44	; 0x2c
    36e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (chip_id.read() != 0x3D) {
    // No LIS3MDL detected ... return false
    return false;
  }

  reset();
    36e4:	4630      	mov	r0, r6
    36e6:	f7ff ffc3 	bl	3670 <Adafruit_LIS3MDL::reset()>

  // set high quality performance mode
  setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
    36ea:	4630      	mov	r0, r6
    36ec:	2103      	movs	r1, #3
    36ee:	f7ff fefb 	bl	34e8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>

  // 155Hz default rate
  setDataRate(LIS3MDL_DATARATE_155_HZ);
    36f2:	4629      	mov	r1, r5
    36f4:	4630      	mov	r0, r6
    36f6:	f7ff ff2d 	bl	3554 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>

  // lowest range
  setRange(LIS3MDL_RANGE_4_GAUSS);
    36fa:	4621      	mov	r1, r4
    36fc:	4630      	mov	r0, r6
    36fe:	f7ff ff7d 	bl	35fc <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>

  setOperationMode(LIS3MDL_CONTINUOUSMODE);
    3702:	4630      	mov	r0, r6
    3704:	4621      	mov	r1, r4
    3706:	f7ff ff5d 	bl	35c4 <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>
    370a:	4628      	mov	r0, r5

  return true;
}
    370c:	b00b      	add	sp, #44	; 0x2c
    370e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003710 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)>:
 *            The I2C address to be used.
 *    @param  wire
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
    3710:	b530      	push	{r4, r5, lr}
    3712:	4604      	mov	r4, r0
  if (!i2c_dev) {
    3714:	69c0      	ldr	r0, [r0, #28]
 *            The I2C address to be used.
 *    @param  wire
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
    3716:	b083      	sub	sp, #12
  if (!i2c_dev) {
    3718:	b168      	cbz	r0, 3736 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0x26>
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
  }
  spi_dev = NULL;
    371a:	2300      	movs	r3, #0

  if (!i2c_dev->begin()) {
    371c:	2101      	movs	r1, #1
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
  if (!i2c_dev) {
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
  }
  spi_dev = NULL;
    371e:	6223      	str	r3, [r4, #32]

  if (!i2c_dev->begin()) {
    3720:	f7ff fb64 	bl	2dec <Adafruit_I2CDevice::begin(bool)>
    3724:	b908      	cbnz	r0, 372a <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0x1a>
    return false;
  }
  return _init();
}
    3726:	b003      	add	sp, #12
    3728:	bd30      	pop	{r4, r5, pc}
  spi_dev = NULL;

  if (!i2c_dev->begin()) {
    return false;
  }
  return _init();
    372a:	4620      	mov	r0, r4
}
    372c:	b003      	add	sp, #12
    372e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  spi_dev = NULL;

  if (!i2c_dev->begin()) {
    return false;
  }
  return _init();
    3732:	f7ff bfbf 	b.w	36b4 <Adafruit_LIS3MDL::_init()>
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
  if (!i2c_dev) {
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
    3736:	2010      	movs	r0, #16
    3738:	e88d 0006 	stmia.w	sp, {r1, r2}
    373c:	f7ff f962 	bl	2a04 <operator new(unsigned int)>
    3740:	4605      	mov	r5, r0
    3742:	e89d 0006 	ldmia.w	sp, {r1, r2}
    3746:	f7ff fb2b 	bl	2da0 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    374a:	4628      	mov	r0, r5
    374c:	61e5      	str	r5, [r4, #28]
    374e:	e7e4      	b.n	371a <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0xa>

00003750 <Adafruit_LIS3MDL::configInterrupt(bool, bool, bool, bool, bool, bool)>:
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3750:	b5f0      	push	{r4, r5, r6, r7, lr}
    3752:	b08b      	sub	sp, #44	; 0x2c
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3754:	f8d0 e020 	ldr.w	lr, [r0, #32]
    3758:	69c7      	ldr	r7, [r0, #28]
    375a:	2001      	movs	r0, #1
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    375c:	f89d 4044 	ldrb.w	r4, [sp, #68]	; 0x44
    3760:	f89d c040 	ldrb.w	ip, [sp, #64]	; 0x40
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3764:	0065      	lsls	r5, r4, #1
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3766:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    376a:	9003      	str	r0, [sp, #12]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    376c:	f045 0508 	orr.w	r5, r5, #8
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3770:	9001      	str	r0, [sp, #4]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3772:	ea45 048c 	orr.w	r4, r5, ip, lsl #2
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3776:	2500      	movs	r5, #0
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3778:	ea44 1443 	orr.w	r4, r4, r3, lsl #5
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    377c:	4603      	mov	r3, r0
    377e:	2030      	movs	r0, #48	; 0x30
    3780:	9502      	str	r5, [sp, #8]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3782:	ea44 1482 	orr.w	r4, r4, r2, lsl #6
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3786:	4672      	mov	r2, lr
    3788:	9000      	str	r0, [sp, #0]
    378a:	a804      	add	r0, sp, #16
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    378c:	ea44 14c1 	orr.w	r4, r4, r1, lsl #7
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3790:	4639      	mov	r1, r7
    3792:	f7ff f9c9 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  INT_CFG.write(value);
    3796:	462a      	mov	r2, r5
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3798:	b2e4      	uxtb	r4, r4
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
  INT_CFG.write(value);
    379a:	a804      	add	r0, sp, #16
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;
    379c:	4334      	orrs	r4, r6

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
  INT_CFG.write(value);
    379e:	4621      	mov	r1, r4
    37a0:	f7ff fa26 	bl	2bf0 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>
}
    37a4:	b00b      	add	sp, #44	; 0x2c
    37a6:	bdf0      	pop	{r4, r5, r6, r7, pc}

000037a8 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    37a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    37ac:	f04f 0c00 	mov.w	ip, #0
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    37b0:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    37b2:	f8d0 9020 	ldr.w	r9, [r0, #32]
    37b6:	2401      	movs	r4, #1
    37b8:	69c0      	ldr	r0, [r0, #28]
    37ba:	f04f 0806 	mov.w	r8, #6
    37be:	f04f 0e28 	mov.w	lr, #40	; 0x28
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    37c2:	460f      	mov	r7, r1
    37c4:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    37c6:	4601      	mov	r1, r0
    37c8:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    37ca:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    37cc:	a806      	add	r0, sp, #24
    37ce:	9403      	str	r4, [sp, #12]
    37d0:	4623      	mov	r3, r4
    37d2:	f8cd c008 	str.w	ip, [sp, #8]
    37d6:	f8cd 8004 	str.w	r8, [sp, #4]
    37da:	f8cd e000 	str.w	lr, [sp]
    37de:	f7ff f9a3 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    37e2:	4642      	mov	r2, r8
    37e4:	a806      	add	r0, sp, #24
    37e6:	a904      	add	r1, sp, #16
    37e8:	f7ff fa22 	bl	2c30 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    37ec:	b3c8      	cbz	r0, 3862 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xba>
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    37ee:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    37f2:	eeb1 6b00 	vmov.f64	d6, #16	; 0x40800000  4.0
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;

  return 1;
    37f6:	4620      	mov	r0, r4
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    37f8:	ee04 3a10 	vmov	s8, r3
  y = data[1] * 4.0 * 100.0 / 32768.0;
    37fc:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    3800:	ee05 3a10 	vmov	s10, r3
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3804:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3808:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;
    380c:	ee07 3a10 	vmov	s14, r3
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3810:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3814:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3818:	ee24 4b06 	vmul.f64	d4, d4, d6
  y = data[1] * 4.0 * 100.0 / 32768.0;
    381c:	ee25 5b06 	vmul.f64	d5, d5, d6
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3820:	ee27 6b06 	vmul.f64	d6, d7, d6
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3824:	ed9f 7b12 	vldr	d7, [pc, #72]	; 3870 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xc8>
    3828:	ed9f 3b13 	vldr	d3, [pc, #76]	; 3878 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xd0>
  y = data[1] * 4.0 * 100.0 / 32768.0;
    382c:	ee25 5b07 	vmul.f64	d5, d5, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3830:	ee24 4b07 	vmul.f64	d4, d4, d7
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3834:	ee26 7b07 	vmul.f64	d7, d6, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3838:	ee24 4b03 	vmul.f64	d4, d4, d3
  y = data[1] * 4.0 * 100.0 / 32768.0;
    383c:	ee25 6b03 	vmul.f64	d6, d5, d3
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3840:	ee27 7b03 	vmul.f64	d7, d7, d3
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3844:	eeb7 4bc4 	vcvt.f32.f64	s8, d4
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3848:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 4.0 * 100.0 / 32768.0;
    384c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3850:	ed87 4a00 	vstr	s8, [r7]
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3854:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3858:	ed85 7a00 	vstr	s14, [r5]

  return 1;
    385c:	b00d      	add	sp, #52	; 0x34
    385e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);

  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    3862:	4b07      	ldr	r3, [pc, #28]	; (3880 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xd8>)
    3864:	602b      	str	r3, [r5, #0]
    3866:	6033      	str	r3, [r6, #0]
    3868:	603b      	str	r3, [r7, #0]
  x = data[0] * 4.0 * 100.0 / 32768.0;
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;

  return 1;
    386a:	b00d      	add	sp, #52	; 0x34
    386c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    3870:	00000000 	.word	0x00000000
    3874:	40590000 	.word	0x40590000
    3878:	00000000 	.word	0x00000000
    387c:	3f000000 	.word	0x3f000000
    3880:	7fc00000 	.word	0x7fc00000

00003884 <Adafruit_LSM6DS::~Adafruit_LSM6DS()>:
Adafruit_LSM6DS::Adafruit_LSM6DS(void) {}

/*!
 *    @brief  Cleans up the LSM6DS
 */
Adafruit_LSM6DS::~Adafruit_LSM6DS(void) { delete temp_sensor; }
    3884:	b510      	push	{r4, lr}
    3886:	4b05      	ldr	r3, [pc, #20]	; (389c <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x18>)
    3888:	4604      	mov	r4, r0
    388a:	6c40      	ldr	r0, [r0, #68]	; 0x44
    388c:	6023      	str	r3, [r4, #0]
    388e:	b110      	cbz	r0, 3896 <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x12>
    3890:	6803      	ldr	r3, [r0, #0]
    3892:	685b      	ldr	r3, [r3, #4]
    3894:	4798      	blx	r3
    3896:	4620      	mov	r0, r4
    3898:	bd10      	pop	{r4, pc}
    389a:	bf00      	nop
    389c:	20000450 	.word	0x20000450

000038a0 <Adafruit_LSM6DS_Gyro::~Adafruit_LSM6DS_Gyro()>:
  int _sensorID = 0x6D1;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
    38a0:	4770      	bx	lr
    38a2:	bf00      	nop

000038a4 <Adafruit_LSM6DS_Accelerometer::~Adafruit_LSM6DS_Accelerometer()>:
  int _sensorID = 0x6D0;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for accelerometer component of LSM6DS */
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
    38a4:	4770      	bx	lr
    38a6:	bf00      	nop

000038a8 <Adafruit_LSM6DS_Temp::~Adafruit_LSM6DS_Temp()>:
} lsm6ds_hp_filter_t;

class Adafruit_LSM6DS;

/** Adafruit Unified Sensor interface for temperature component of LSM6DS */
class Adafruit_LSM6DS_Temp : public Adafruit_Sensor {
    38a8:	4770      	bx	lr
    38aa:	bf00      	nop

000038ac <Adafruit_LSM6DS::~Adafruit_LSM6DS()>:
    38ac:	b510      	push	{r4, lr}
    38ae:	4b07      	ldr	r3, [pc, #28]	; (38cc <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x20>)
    38b0:	4604      	mov	r4, r0
    38b2:	6c40      	ldr	r0, [r0, #68]	; 0x44
    38b4:	6023      	str	r3, [r4, #0]
    38b6:	b110      	cbz	r0, 38be <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x12>
    38b8:	6803      	ldr	r3, [r0, #0]
    38ba:	685b      	ldr	r3, [r3, #4]
    38bc:	4798      	blx	r3
    38be:	4620      	mov	r0, r4
    38c0:	2154      	movs	r1, #84	; 0x54
    38c2:	f7ff f8a3 	bl	2a0c <operator delete(void*, unsigned int)>
    38c6:	4620      	mov	r0, r4
    38c8:	bd10      	pop	{r4, pc}
    38ca:	bf00      	nop
    38cc:	20000450 	.word	0x20000450

000038d0 <Adafruit_LSM6DS_Temp::~Adafruit_LSM6DS_Temp()>:
    38d0:	b510      	push	{r4, lr}
    38d2:	4604      	mov	r4, r0
    38d4:	2110      	movs	r1, #16
    38d6:	f7ff f899 	bl	2a0c <operator delete(void*, unsigned int)>
    38da:	4620      	mov	r0, r4
    38dc:	bd10      	pop	{r4, pc}
    38de:	bf00      	nop

000038e0 <Adafruit_LSM6DS_Accelerometer::~Adafruit_LSM6DS_Accelerometer()>:
  int _sensorID = 0x6D0;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for accelerometer component of LSM6DS */
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
    38e0:	b510      	push	{r4, lr}
    38e2:	4604      	mov	r4, r0
    38e4:	2110      	movs	r1, #16
    38e6:	f7ff f891 	bl	2a0c <operator delete(void*, unsigned int)>
    38ea:	4620      	mov	r0, r4
    38ec:	bd10      	pop	{r4, pc}
    38ee:	bf00      	nop

000038f0 <Adafruit_LSM6DS_Gyro::~Adafruit_LSM6DS_Gyro()>:
  int _sensorID = 0x6D1;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
    38f0:	b510      	push	{r4, lr}
    38f2:	4604      	mov	r4, r0
    38f4:	2110      	movs	r1, #16
    38f6:	f7ff f889 	bl	2a0c <operator delete(void*, unsigned int)>
    38fa:	4620      	mov	r0, r4
    38fc:	bd10      	pop	{r4, pc}
    38fe:	bf00      	nop

00003900 <Adafruit_LSM6DS_Temp::getEvent(sensors_event_t*)>:
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
    3900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3902:	4606      	mov	r6, r0
  _theLSM6DS->_read();
    3904:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
    3906:	460c      	mov	r4, r1
  fillTempEvent(temp, t);
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
    3908:	2524      	movs	r5, #36	; 0x24
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
    390a:	6803      	ldr	r3, [r0, #0]
    390c:	689b      	ldr	r3, [r3, #8]
    390e:	4798      	blx	r3
  _theLSM6DS->fillTempEvent(event, millis());
    3910:	68f6      	ldr	r6, [r6, #12]
    3912:	4b08      	ldr	r3, [pc, #32]	; (3934 <Adafruit_LSM6DS_Temp::getEvent(sensors_event_t*)+0x34>)
  fillTempEvent(temp, t);
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
    3914:	462a      	mov	r2, r5
    3916:	4620      	mov	r0, r4
    3918:	2100      	movs	r1, #0
    391a:	681f      	ldr	r7, [r3, #0]
    391c:	f002 ff1e 	bl	675c <memset>
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
    3920:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    3922:	230d      	movs	r3, #13
  temp->timestamp = timestamp;
  temp->temperature = temperature;
    3924:	6972      	ldr	r2, [r6, #20]
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillTempEvent(event, millis());

  return true;
}
    3926:	2001      	movs	r0, #1
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
    3928:	6025      	str	r5, [r4, #0]
  temp->sensor_id = _sensorid_temp;
    392a:	6061      	str	r1, [r4, #4]
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  temp->timestamp = timestamp;
  temp->temperature = temperature;
    392c:	6162      	str	r2, [r4, #20]
void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  temp->timestamp = timestamp;
    392e:	6127      	str	r7, [r4, #16]

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    3930:	60a3      	str	r3, [r4, #8]
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillTempEvent(event, millis());

  return true;
}
    3932:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3934:	20002740 	.word	0x20002740

00003938 <Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t*)>:
    @brief  Gets the gyroscope as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
    3938:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    393a:	4605      	mov	r5, r0
  _theLSM6DS->_read();
    393c:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the gyroscope as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
    393e:	460c      	mov	r4, r1
  _theLSM6DS->_read();
    3940:	6803      	ldr	r3, [r0, #0]
    3942:	689b      	ldr	r3, [r3, #8]
    3944:	4798      	blx	r3
  _theLSM6DS->fillGyroEvent(event, millis());
    3946:	68ed      	ldr	r5, [r5, #12]
    3948:	4b0a      	ldr	r3, [pc, #40]	; (3974 <Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t*)+0x3c>)
  temp->timestamp = timestamp;
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
    394a:	4620      	mov	r0, r4
    394c:	2224      	movs	r2, #36	; 0x24
    394e:	2100      	movs	r1, #0
    3950:	681e      	ldr	r6, [r3, #0]
    3952:	f002 ff03 	bl	675c <memset>
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
    3956:	6a69      	ldr	r1, [r5, #36]	; 0x24
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
    3958:	2301      	movs	r3, #1
  gyro->sensor_id = _sensorid_gyro;
    395a:	8e6f      	ldrh	r7, [r5, #50]	; 0x32
  gyro->type = SENSOR_TYPE_GYROSCOPE;
    395c:	2204      	movs	r2, #4
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
    395e:	6161      	str	r1, [r4, #20]
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillGyroEvent(event, millis());

  return true;
}
    3960:	4618      	mov	r0, r3
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
    3962:	6aa9      	ldr	r1, [r5, #40]	; 0x28
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
    3964:	6067      	str	r7, [r4, #4]
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
    3966:	61a1      	str	r1, [r4, #24]
  gyro->gyro.z = gyroZ;
    3968:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
    396a:	6126      	str	r6, [r4, #16]
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
  gyro->gyro.z = gyroZ;
    396c:	61e1      	str	r1, [r4, #28]

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
    396e:	60a2      	str	r2, [r4, #8]
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
    3970:	6023      	str	r3, [r4, #0]
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillGyroEvent(event, millis());

  return true;
}
    3972:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3974:	20002740 	.word	0x20002740

00003978 <Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t*)>:
    @brief  Gets the accelerometer as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
    3978:	b570      	push	{r4, r5, r6, lr}
    397a:	4605      	mov	r5, r0
  _theLSM6DS->_read();
    397c:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the accelerometer as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
    397e:	460c      	mov	r4, r1
  _theLSM6DS->_read();
    3980:	6803      	ldr	r3, [r0, #0]
    3982:	689b      	ldr	r3, [r3, #8]
    3984:	4798      	blx	r3
  _theLSM6DS->fillAccelEvent(event, millis());
    3986:	68ed      	ldr	r5, [r5, #12]
    3988:	4b0a      	ldr	r3, [pc, #40]	; (39b4 <Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t*)+0x3c>)
  gyro->gyro.z = gyroZ;
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
    398a:	4620      	mov	r0, r4
    398c:	2224      	movs	r2, #36	; 0x24
    398e:	2100      	movs	r1, #0
    3990:	681e      	ldr	r6, [r3, #0]
    3992:	f002 fee3 	bl	675c <memset>
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
    3996:	69aa      	ldr	r2, [r5, #24]
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
    3998:	2301      	movs	r3, #1
  accel->sensor_id = _sensorid_accel;
    399a:	8e29      	ldrh	r1, [r5, #48]	; 0x30
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
    399c:	6162      	str	r2, [r4, #20]
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillAccelEvent(event, millis());

  return true;
}
    399e:	4618      	mov	r0, r3
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
    39a0:	69ea      	ldr	r2, [r5, #28]

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
    39a2:	6061      	str	r1, [r4, #4]
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
    39a4:	61a2      	str	r2, [r4, #24]
  accel->acceleration.z = accZ;
    39a6:	6a2a      	ldr	r2, [r5, #32]
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
    39a8:	6126      	str	r6, [r4, #16]
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
  accel->acceleration.z = accZ;
    39aa:	61e2      	str	r2, [r4, #28]
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
    39ac:	6023      	str	r3, [r4, #0]
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
    39ae:	60a3      	str	r3, [r4, #8]
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillAccelEvent(event, millis());

  return true;
}
    39b0:	bd70      	pop	{r4, r5, r6, pc}
    39b2:	bf00      	nop
    39b4:	20002740 	.word	0x20002740

000039b8 <Adafruit_LSM6DS::_read()>:
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    39b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    39ba:	2300      	movs	r3, #0
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    39bc:	b08f      	sub	sp, #60	; 0x3c
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    39be:	2620      	movs	r6, #32
    39c0:	250e      	movs	r5, #14
    39c2:	2701      	movs	r7, #1
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    39c4:	4604      	mov	r4, r0
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    39c6:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    39c8:	6b81      	ldr	r1, [r0, #56]	; 0x38
    39ca:	eb0d 0006 	add.w	r0, sp, r6
    39ce:	9302      	str	r3, [sp, #8]
    39d0:	9703      	str	r7, [sp, #12]
    39d2:	9501      	str	r5, [sp, #4]
    39d4:	9600      	str	r6, [sp, #0]
    39d6:	f7ff f8a7 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  uint8_t buffer[14];
  data_reg.read(buffer, 14);
    39da:	462a      	mov	r2, r5
    39dc:	eb0d 0006 	add.w	r0, sp, r6
    39e0:	a904      	add	r1, sp, #16
    39e2:	f7ff f925 	bl	2c30 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>

  rawTemp = buffer[1] << 8 | buffer[0];
    39e6:	f89d 3010 	ldrb.w	r3, [sp, #16]
    39ea:	f89d 7011 	ldrb.w	r7, [sp, #17]
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    39ee:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
    39f2:	edd4 6a10 	vldr	s13, [r4, #64]	; 0x40
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    39f6:	ea43 2707 	orr.w	r7, r3, r7, lsl #8
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    39fa:	f89d 6013 	ldrb.w	r6, [sp, #19]
    39fe:	f89d 3012 	ldrb.w	r3, [sp, #18]
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    3a02:	b23f      	sxth	r7, r7
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3a04:	f89d 2014 	ldrb.w	r2, [sp, #20]
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    3a08:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    3a0c:	f89d e019 	ldrb.w	lr, [sp, #25]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3a10:	ee07 7a90 	vmov	s15, r7

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3a14:	f89d 3016 	ldrb.w	r3, [sp, #22]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3a18:	f89d 5015 	ldrb.w	r5, [sp, #21]
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    3a1c:	b236      	sxth	r6, r6

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3a1e:	eeb8 6ae7 	vcvt.f32.s32	s12, s15

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3a22:	f89d 0017 	ldrb.w	r0, [sp, #23]

  rawAccX = buffer[9] << 8 | buffer[8];
    3a26:	f89d 1018 	ldrb.w	r1, [sp, #24]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3a2a:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3a2e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    3a32:	f89d c01b 	ldrb.w	ip, [sp, #27]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3a36:	eec6 7a26 	vdiv.f32	s15, s12, s13

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    3a3a:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
  rawAccY = buffer[11] << 8 | buffer[10];
    3a3e:	f89d 201a 	ldrb.w	r2, [sp, #26]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3a42:	b22d      	sxth	r5, r5
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    3a44:	f89d e01d 	ldrb.w	lr, [sp, #29]
  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3a48:	b200      	sxth	r0, r0

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    3a4a:	f89d 301c 	ldrb.w	r3, [sp, #28]
  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    3a4e:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    3a52:	8167      	strh	r7, [r4, #10]

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    3a54:	b209      	sxth	r1, r1
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    3a56:	ea43 230e 	orr.w	r3, r3, lr, lsl #8

  float gyro_scale = 1; // range is in milli-dps per bit!
  switch (gyroRangeBuffered) {
    3a5a:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    3a5e:	b212      	sxth	r2, r2
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    3a60:	81a6      	strh	r6, [r4, #12]
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    3a62:	b21b      	sxth	r3, r3
    3a64:	2f0c      	cmp	r7, #12

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3a66:	81e5      	strh	r5, [r4, #14]
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3a68:	8220      	strh	r0, [r4, #16]

  rawAccX = buffer[9] << 8 | buffer[8];
    3a6a:	80a1      	strh	r1, [r4, #4]
  rawAccY = buffer[11] << 8 | buffer[10];
    3a6c:	80e2      	strh	r2, [r4, #6]
  rawAccZ = buffer[13] << 8 | buffer[12];
    3a6e:	8123      	strh	r3, [r4, #8]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3a70:	ee77 7a87 	vadd.f32	s15, s15, s14
    3a74:	edc4 7a05 	vstr	s15, [r4, #20]
    3a78:	d860      	bhi.n	3b3c <Adafruit_LSM6DS::_read()+0x184>
    3a7a:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 3b58 <Adafruit_LSM6DS::_read()+0x1a0>
    3a7e:	eb0e 0787 	add.w	r7, lr, r7, lsl #2
    3a82:	edd7 7a00 	vldr	s15, [r7]
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3a86:	ee07 6a10 	vmov	s14, r6
    3a8a:	ed9f 5a2f 	vldr	s10, [pc, #188]	; 3b48 <Adafruit_LSM6DS::_read()+0x190>
    3a8e:	eddf 5a2f 	vldr	s11, [pc, #188]	; 3b4c <Adafruit_LSM6DS::_read()+0x194>
    3a92:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3a96:	ee07 5a10 	vmov	s14, r5
    3a9a:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3a9e:	ee07 0a10 	vmov	s14, r0
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3aa2:	ee26 6a27 	vmul.f32	s12, s12, s15
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;

  float accel_scale = 1; // range is in milli-g per bit!
  switch (accelRangeBuffered) {
    3aa6:	f894 0050 	ldrb.w	r0, [r4, #80]	; 0x50
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3aaa:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3aae:	ee66 6aa7 	vmul.f32	s13, s13, s15
    3ab2:	2803      	cmp	r0, #3
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3ab4:	ee26 6a05 	vmul.f32	s12, s12, s10
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3ab8:	ee67 7a27 	vmul.f32	s15, s14, s15
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3abc:	ee26 7a85 	vmul.f32	s14, s13, s10
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3ac0:	ee67 7a85 	vmul.f32	s15, s15, s10
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3ac4:	eec7 6a25 	vdiv.f32	s13, s14, s11
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3ac8:	ee86 5a25 	vdiv.f32	s10, s12, s11
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3acc:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3ad0:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3ad4:	ed84 5a09 	vstr	s10, [r4, #36]	; 0x24
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3ad8:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
    3adc:	d831      	bhi.n	3b42 <Adafruit_LSM6DS::_read()+0x18a>
    3ade:	4d1c      	ldr	r5, [pc, #112]	; (3b50 <Adafruit_LSM6DS::_read()+0x198>)
    3ae0:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    3ae4:	edd0 7a00 	vldr	s15, [r0]
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3ae8:	ee07 1a10 	vmov	s14, r1
    3aec:	ed9f 5a19 	vldr	s10, [pc, #100]	; 3b54 <Adafruit_LSM6DS::_read()+0x19c>
    3af0:	eddf 5a16 	vldr	s11, [pc, #88]	; 3b4c <Adafruit_LSM6DS::_read()+0x194>
    3af4:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3af8:	ee07 2a10 	vmov	s14, r2
    3afc:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b00:	ee07 3a10 	vmov	s14, r3
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b04:	ee26 6a27 	vmul.f32	s12, s12, s15
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b08:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b0c:	ee66 6aa7 	vmul.f32	s13, s13, s15
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b10:	ee26 6a05 	vmul.f32	s12, s12, s10
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b14:	ee67 7a27 	vmul.f32	s15, s14, s15
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b18:	ee26 7a85 	vmul.f32	s14, s13, s10
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b1c:	ee67 7a85 	vmul.f32	s15, s15, s10
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b20:	eec7 6a25 	vdiv.f32	s13, s14, s11
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b24:	ee86 5a25 	vdiv.f32	s10, s12, s11
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b28:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b2c:	edc4 6a07 	vstr	s13, [r4, #28]
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b30:	ed84 5a06 	vstr	s10, [r4, #24]
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3b34:	ed84 7a08 	vstr	s14, [r4, #32]
}
    3b38:	b00f      	add	sp, #60	; 0x3c
    3b3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];

  float gyro_scale = 1; // range is in milli-dps per bit!
  switch (gyroRangeBuffered) {
    3b3c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    3b40:	e7a1      	b.n	3a86 <Adafruit_LSM6DS::_read()+0xce>
  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;

  float accel_scale = 1; // range is in milli-g per bit!
  switch (accelRangeBuffered) {
    3b42:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    3b46:	e7cf      	b.n	3ae8 <Adafruit_LSM6DS::_read()+0x130>
    3b48:	3c8efa35 	.word	0x3c8efa35
    3b4c:	447a0000 	.word	0x447a0000
    3b50:	20000438 	.word	0x20000438
    3b54:	411ce80a 	.word	0x411ce80a
    3b58:	200003f4 	.word	0x200003f4

00003b5c <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's gyroscope sensor
*/
/**************************************************************************/
void Adafruit_LSM6DS_Gyro::getSensor(sensor_t *sensor) {
    3b5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3b5e:	460c      	mov	r4, r1
    3b60:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3b62:	2228      	movs	r2, #40	; 0x28
    3b64:	2100      	movs	r1, #0
    3b66:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3b68:	2701      	movs	r7, #1
    @brief  Gets the sensor_t data for the LSM6DS's gyroscope sensor
*/
/**************************************************************************/
void Adafruit_LSM6DS_Gyro::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3b6a:	f002 fdf7 	bl	675c <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
    3b6e:	220b      	movs	r2, #11
    3b70:	4909      	ldr	r1, [pc, #36]	; (3b98 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x3c>)
    3b72:	4620      	mov	r0, r4
    3b74:	f003 fa92 	bl	709c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3b78:	2300      	movs	r3, #0
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
    3b7a:	2504      	movs	r5, #4
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
    3b7c:	4807      	ldr	r0, [pc, #28]	; (3b9c <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3b7e:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
  sensor->max_value = +34.91;
    3b80:	4907      	ldr	r1, [pc, #28]	; (3ba0 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3b82:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
  sensor->max_value = +34.91;
  sensor->resolution = 7.6358e-5; /* 4.375 mdps -> rad/s */
    3b84:	4a07      	ldr	r2, [pc, #28]	; (3ba4 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x48>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3b86:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    3b88:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
    3b8a:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
    3b8c:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
    3b8e:	61e0      	str	r0, [r4, #28]
  sensor->max_value = +34.91;
    3b90:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 7.6358e-5; /* 4.375 mdps -> rad/s */
    3b92:	6222      	str	r2, [r4, #32]
    3b94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3b96:	bf00      	nop
    3b98:	20000db8 	.word	0x20000db8
    3b9c:	c20ba3d7 	.word	0xc20ba3d7
    3ba0:	420ba3d7 	.word	0x420ba3d7
    3ba4:	38a02264 	.word	0x38a02264

00003ba8 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's accelerometer
*/
/**************************************************************************/
void Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t *sensor) {
    3ba8:	b570      	push	{r4, r5, r6, lr}
    3baa:	460c      	mov	r4, r1
    3bac:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3bae:	2228      	movs	r2, #40	; 0x28
    3bb0:	2100      	movs	r1, #0
    3bb2:	4620      	mov	r0, r4
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
    3bb4:	4d0a      	ldr	r5, [pc, #40]	; (3be0 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x38>)
    @brief  Gets the sensor_t data for the LSM6DS's accelerometer
*/
/**************************************************************************/
void Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3bb6:	f002 fdd1 	bl	675c <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
    3bba:	220b      	movs	r2, #11
    3bbc:	4909      	ldr	r1, [pc, #36]	; (3be4 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x3c>)
    3bbe:	4620      	mov	r0, r4
    3bc0:	f003 fa6c 	bl	709c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3bc4:	2200      	movs	r2, #0
  sensor->version = 1;
    3bc6:	2301      	movs	r3, #1
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
    3bc8:	4807      	ldr	r0, [pc, #28]	; (3be8 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3bca:	72e2      	strb	r2, [r4, #11]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
  sensor->resolution = 0.061;     /* 0.061 mg/LSB at +-2g */
    3bcc:	4907      	ldr	r1, [pc, #28]	; (3bec <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3bce:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
    3bd0:	6262      	str	r2, [r4, #36]	; 0x24

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3bd2:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
    3bd4:	61e5      	str	r5, [r4, #28]
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
    3bd6:	61a0      	str	r0, [r4, #24]
  sensor->resolution = 0.061;     /* 0.061 mg/LSB at +-2g */
    3bd8:	6221      	str	r1, [r4, #32]
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3bda:	60e3      	str	r3, [r4, #12]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
    3bdc:	6163      	str	r3, [r4, #20]
    3bde:	bd70      	pop	{r4, r5, r6, pc}
    3be0:	c31ce80a 	.word	0xc31ce80a
    3be4:	20000dc4 	.word	0x20000dc4
    3be8:	431ce80a 	.word	0x431ce80a
    3bec:	3d79db23 	.word	0x3d79db23

00003bf0 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's tenperature
*/
/**************************************************************************/
void Adafruit_LSM6DS_Temp::getSensor(sensor_t *sensor) {
    3bf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3bf2:	460c      	mov	r4, r1
    3bf4:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3bf6:	2228      	movs	r2, #40	; 0x28
    3bf8:	2100      	movs	r1, #0
    3bfa:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3bfc:	2701      	movs	r7, #1
    @brief  Gets the sensor_t data for the LSM6DS's tenperature
*/
/**************************************************************************/
void Adafruit_LSM6DS_Temp::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3bfe:	f002 fdad 	bl	675c <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
    3c02:	220b      	movs	r2, #11
    3c04:	4909      	ldr	r1, [pc, #36]	; (3c2c <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x3c>)
    3c06:	4620      	mov	r0, r4
    3c08:	f003 fa48 	bl	709c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3c0c:	2300      	movs	r3, #0
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
  sensor->max_value = 85;
  sensor->resolution = 1; /* not a great sensor */
    3c0e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    3c12:	250d      	movs	r5, #13
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3c14:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
    3c16:	4806      	ldr	r0, [pc, #24]	; (3c30 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x40>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3c18:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
  sensor->max_value = 85;
    3c1a:	4906      	ldr	r1, [pc, #24]	; (3c34 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x44>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3c1c:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    3c1e:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
    3c20:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    3c22:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -40;
    3c24:	61e0      	str	r0, [r4, #28]
  sensor->max_value = 85;
    3c26:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 1; /* not a great sensor */
    3c28:	6222      	str	r2, [r4, #32]
    3c2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3c2c:	20000dd0 	.word	0x20000dd0
    3c30:	c2200000 	.word	0xc2200000
    3c34:	42aa0000 	.word	0x42aa0000

00003c38 <Adafruit_LSM6DS::Adafruit_LSM6DS()>:
};

/*!
 *    @brief  Instantiates a new LSM6DS class
 */
Adafruit_LSM6DS::Adafruit_LSM6DS(void) {}
    3c38:	2200      	movs	r2, #0
    3c3a:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
    3c3e:	b410      	push	{r4}
    3c40:	4c07      	ldr	r4, [pc, #28]	; (3c60 <Adafruit_LSM6DS::Adafruit_LSM6DS()+0x28>)
    3c42:	6401      	str	r1, [r0, #64]	; 0x40
    3c44:	6004      	str	r4, [r0, #0]
    3c46:	6382      	str	r2, [r0, #56]	; 0x38
    3c48:	63c2      	str	r2, [r0, #60]	; 0x3c
    3c4a:	6442      	str	r2, [r0, #68]	; 0x44
    3c4c:	6482      	str	r2, [r0, #72]	; 0x48
    3c4e:	64c2      	str	r2, [r0, #76]	; 0x4c
    3c50:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
    3c54:	f880 2051 	strb.w	r2, [r0, #81]	; 0x51
    3c58:	f85d 4b04 	ldr.w	r4, [sp], #4
    3c5c:	4770      	bx	lr
    3c5e:	bf00      	nop
    3c60:	20000450 	.word	0x20000450

00003c64 <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)>:
 *    @param  sensor_id
 *            The user-defined ID to differentiate different sensors
 *    @return True if initialization was successful, otherwise false.
 */
boolean Adafruit_LSM6DS::begin_I2C(uint8_t i2c_address, TwoWire *wire,
                                   int32_t sensor_id) {
    3c64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3c68:	4604      	mov	r4, r0
    3c6a:	460e      	mov	r6, r1
  delete i2c_dev; // remove old interface
    3c6c:	6b80      	ldr	r0, [r0, #56]	; 0x38
    3c6e:	2110      	movs	r1, #16
 *    @param  sensor_id
 *            The user-defined ID to differentiate different sensors
 *    @return True if initialization was successful, otherwise false.
 */
boolean Adafruit_LSM6DS::begin_I2C(uint8_t i2c_address, TwoWire *wire,
                                   int32_t sensor_id) {
    3c70:	4617      	mov	r7, r2
    3c72:	4698      	mov	r8, r3
  delete i2c_dev; // remove old interface
    3c74:	f7fe feca 	bl	2a0c <operator delete(void*, unsigned int)>

  i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
    3c78:	2010      	movs	r0, #16
    3c7a:	f7fe fec3 	bl	2a04 <operator new(unsigned int)>
    3c7e:	4605      	mov	r5, r0
    3c80:	4631      	mov	r1, r6
    3c82:	463a      	mov	r2, r7
    3c84:	f7ff f88c 	bl	2da0 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    3c88:	63a5      	str	r5, [r4, #56]	; 0x38

  if (!i2c_dev->begin()) {
    3c8a:	4628      	mov	r0, r5
    3c8c:	2101      	movs	r1, #1
    3c8e:	f7ff f8ad 	bl	2dec <Adafruit_I2CDevice::begin(bool)>
    3c92:	b908      	cbnz	r0, 3c98 <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)+0x34>
    return false;
  }

  return _init(sensor_id);
}
    3c94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if (!i2c_dev->begin()) {
    return false;
  }

  return _init(sensor_id);
    3c98:	6823      	ldr	r3, [r4, #0]
    3c9a:	4641      	mov	r1, r8
    3c9c:	4620      	mov	r0, r4
    3c9e:	68db      	ldr	r3, [r3, #12]
}
    3ca0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  if (!i2c_dev->begin()) {
    return false;
  }

  return _init(sensor_id);
    3ca4:	4718      	bx	r3
    3ca6:	bf00      	nop

00003ca8 <Adafruit_LSM6DS::reset()>:
/**************************************************************************/
/*!
    @brief Resets the sensor to its power-on state, clearing all registers and
   memory
*/
void Adafruit_LSM6DS::reset(void) {
    3ca8:	b570      	push	{r4, r5, r6, lr}

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3caa:	2401      	movs	r4, #1
/**************************************************************************/
/*!
    @brief Resets the sensor to its power-on state, clearing all registers and
   memory
*/
void Adafruit_LSM6DS::reset(void) {
    3cac:	b08c      	sub	sp, #48	; 0x30

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3cae:	2500      	movs	r5, #0
    3cb0:	2612      	movs	r6, #18
    3cb2:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    3cb4:	6b81      	ldr	r1, [r0, #56]	; 0x38
    3cb6:	462b      	mov	r3, r5
    3cb8:	a806      	add	r0, sp, #24
    3cba:	9403      	str	r4, [sp, #12]
    3cbc:	9401      	str	r4, [sp, #4]
    3cbe:	9502      	str	r5, [sp, #8]
    3cc0:	9600      	str	r6, [sp, #0]
    3cc2:	f7fe ff31 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits sw_reset =
      Adafruit_BusIO_RegisterBits(&ctrl3, 1, 0);
    3cc6:	a906      	add	r1, sp, #24
    3cc8:	462b      	mov	r3, r5
    3cca:	4622      	mov	r2, r4
    3ccc:	a804      	add	r0, sp, #16
    3cce:	f7ff f827 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  // Adafruit_BusIO_RegisterBits boot = Adafruit_BusIO_RegisterBits(&ctrl3, 1,
  // 7);

  sw_reset.write(true);
    3cd2:	4621      	mov	r1, r4
    3cd4:	a804      	add	r0, sp, #16
    3cd6:	f7ff f839 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
    3cda:	e002      	b.n	3ce2 <Adafruit_LSM6DS::reset()+0x3a>

  while (sw_reset.read()) {
    delay(1);
    3cdc:	2001      	movs	r0, #1
    3cde:	f7fd fa49 	bl	1174 <delay>
  // Adafruit_BusIO_RegisterBits boot = Adafruit_BusIO_RegisterBits(&ctrl3, 1,
  // 7);

  sw_reset.write(true);

  while (sw_reset.read()) {
    3ce2:	a804      	add	r0, sp, #16
    3ce4:	f7ff f824 	bl	2d30 <Adafruit_BusIO_RegisterBits::read()>
    3ce8:	2800      	cmp	r0, #0
    3cea:	d1f7      	bne.n	3cdc <Adafruit_LSM6DS::reset()+0x34>
    delay(1);
  }
}
    3cec:	b00c      	add	sp, #48	; 0x30
    3cee:	bd70      	pop	{r4, r5, r6, pc}

00003cf0 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>:
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    3cf0:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3cf2:	2301      	movs	r3, #1
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    3cf4:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3cf6:	6b87      	ldr	r7, [r0, #56]	; 0x38
    3cf8:	2610      	movs	r6, #16
    3cfa:	2400      	movs	r4, #0
    3cfc:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    3cfe:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3d00:	9303      	str	r3, [sp, #12]
    3d02:	4639      	mov	r1, r7
    3d04:	9301      	str	r3, [sp, #4]
    3d06:	a806      	add	r0, sp, #24
    3d08:	4623      	mov	r3, r4
    3d0a:	9402      	str	r4, [sp, #8]
    3d0c:	9600      	str	r6, [sp, #0]
    3d0e:	f7fe ff0b 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits accel_data_rate =
      Adafruit_BusIO_RegisterBits(&ctrl1, 4, 4);
    3d12:	2304      	movs	r3, #4
    3d14:	a906      	add	r1, sp, #24
    3d16:	eb0d 0006 	add.w	r0, sp, r6
    3d1a:	461a      	mov	r2, r3
    3d1c:	f7ff f800 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  accel_data_rate.write(data_rate);
    3d20:	4629      	mov	r1, r5
    3d22:	eb0d 0006 	add.w	r0, sp, r6
    3d26:	f7ff f811 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3d2a:	b00d      	add	sp, #52	; 0x34
    3d2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3d2e:	bf00      	nop

00003d30 <Adafruit_LSM6DS::setAccelRange(accel_range)>:
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    3d30:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3d32:	2301      	movs	r3, #1
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    3d34:	b08d      	sub	sp, #52	; 0x34
    3d36:	4604      	mov	r4, r0

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3d38:	2710      	movs	r7, #16
    3d3a:	2600      	movs	r6, #0
    3d3c:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    3d3e:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3d40:	a806      	add	r0, sp, #24
    3d42:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    3d44:	9303      	str	r3, [sp, #12]
    3d46:	9301      	str	r3, [sp, #4]
    3d48:	4633      	mov	r3, r6
    3d4a:	9602      	str	r6, [sp, #8]
    3d4c:	9700      	str	r7, [sp, #0]
    3d4e:	f7fe feeb 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits accel_range =
      Adafruit_BusIO_RegisterBits(&ctrl1, 2, 2);
    3d52:	2302      	movs	r3, #2
    3d54:	a906      	add	r1, sp, #24
    3d56:	eb0d 0007 	add.w	r0, sp, r7
    3d5a:	461a      	mov	r2, r3
    3d5c:	f7fe ffe0 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  accel_range.write(new_range);
    3d60:	4629      	mov	r1, r5
    3d62:	eb0d 0007 	add.w	r0, sp, r7
    3d66:	f7fe fff1 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  accelRangeBuffered = new_range;
    3d6a:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
}
    3d6e:	b00d      	add	sp, #52	; 0x34
    3d70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3d72:	bf00      	nop

00003d74 <Adafruit_LSM6DS::setGyroDataRate(data_rate)>:
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    3d74:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3d76:	2301      	movs	r3, #1
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    3d78:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3d7a:	6b87      	ldr	r7, [r0, #56]	; 0x38
    3d7c:	2400      	movs	r4, #0
    3d7e:	2611      	movs	r6, #17
    3d80:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    3d82:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3d84:	9303      	str	r3, [sp, #12]
    3d86:	4639      	mov	r1, r7
    3d88:	9301      	str	r3, [sp, #4]
    3d8a:	a806      	add	r0, sp, #24
    3d8c:	4623      	mov	r3, r4
    3d8e:	9402      	str	r4, [sp, #8]
    3d90:	9600      	str	r6, [sp, #0]
    3d92:	f7fe fec9 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits gyro_data_rate =
      Adafruit_BusIO_RegisterBits(&ctrl2, 4, 4);
    3d96:	2304      	movs	r3, #4
    3d98:	a906      	add	r1, sp, #24
    3d9a:	a804      	add	r0, sp, #16
    3d9c:	461a      	mov	r2, r3
    3d9e:	f7fe ffbf 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  gyro_data_rate.write(data_rate);
    3da2:	4629      	mov	r1, r5
    3da4:	a804      	add	r0, sp, #16
    3da6:	f7fe ffd1 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3daa:	b00d      	add	sp, #52	; 0x34
    3dac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3dae:	bf00      	nop

00003db0 <Adafruit_LSM6DS::setGyroRange(gyro_range)>:
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    3db0:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3db2:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    3db4:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3db6:	2500      	movs	r5, #0
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    3db8:	4604      	mov	r4, r0

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3dba:	2301      	movs	r3, #1
    3dbc:	6b80      	ldr	r0, [r0, #56]	; 0x38
    3dbe:	2711      	movs	r7, #17
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    3dc0:	460e      	mov	r6, r1

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3dc2:	9303      	str	r3, [sp, #12]
    3dc4:	4601      	mov	r1, r0
    3dc6:	9301      	str	r3, [sp, #4]
    3dc8:	a806      	add	r0, sp, #24
    3dca:	462b      	mov	r3, r5
    3dcc:	9502      	str	r5, [sp, #8]
    3dce:	9700      	str	r7, [sp, #0]
    3dd0:	f7fe feaa 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits gyro_range =
      Adafruit_BusIO_RegisterBits(&ctrl2, 4, 0);
    3dd4:	462b      	mov	r3, r5
    3dd6:	a906      	add	r1, sp, #24
    3dd8:	2204      	movs	r2, #4
    3dda:	a804      	add	r0, sp, #16
    3ddc:	f7fe ffa0 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  gyro_range.write(new_range);
    3de0:	4631      	mov	r1, r6
    3de2:	a804      	add	r0, sp, #16
    3de4:	f7fe ffb2 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  gyroRangeBuffered = new_range;
    3de8:	f884 6051 	strb.w	r6, [r4, #81]	; 0x51
}
    3dec:	b00d      	add	sp, #52	; 0x34
    3dee:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003df0 <Adafruit_LSM6DS::_init(long)>:

/*!  @brief  Unique subclass initializer post i2c/spi init
 *   @param sensor_id Optional unique ID for the sensor set
 *   @returns True if chip identified and initialized
 */
bool Adafruit_LSM6DS::_init(int32_t sensor_id) {
    3df0:	b510      	push	{r4, lr}
    3df2:	4604      	mov	r4, r0
  (void)sensor_id;

  // Enable accelerometer with 104 Hz data rate, 4G
  setAccelDataRate(LSM6DS_RATE_104_HZ);
    3df4:	2104      	movs	r1, #4
    3df6:	f7ff ff7b 	bl	3cf0 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>
  setAccelRange(LSM6DS_ACCEL_RANGE_4_G);
    3dfa:	2102      	movs	r1, #2
    3dfc:	4620      	mov	r0, r4
    3dfe:	f7ff ff97 	bl	3d30 <Adafruit_LSM6DS::setAccelRange(accel_range)>

  // Enable gyro with 104 Hz data rate, 2000 dps
  setGyroDataRate(LSM6DS_RATE_104_HZ);
    3e02:	4620      	mov	r0, r4
    3e04:	2104      	movs	r1, #4
    3e06:	f7ff ffb5 	bl	3d74 <Adafruit_LSM6DS::setGyroDataRate(data_rate)>
  setGyroRange(LSM6DS_GYRO_RANGE_2000_DPS);
    3e0a:	4620      	mov	r0, r4
    3e0c:	210c      	movs	r1, #12
    3e0e:	f7ff ffcf 	bl	3db0 <Adafruit_LSM6DS::setGyroRange(gyro_range)>

  delay(10);
    3e12:	200a      	movs	r0, #10
    3e14:	f7fd f9ae 	bl	1174 <delay>

  // delete objects if sensor is reinitialized
  delete temp_sensor;
    3e18:	6c60      	ldr	r0, [r4, #68]	; 0x44
    3e1a:	b110      	cbz	r0, 3e22 <Adafruit_LSM6DS::_init(long)+0x32>
    3e1c:	6803      	ldr	r3, [r0, #0]
    3e1e:	685b      	ldr	r3, [r3, #4]
    3e20:	4798      	blx	r3
  delete accel_sensor;
    3e22:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    3e24:	b110      	cbz	r0, 3e2c <Adafruit_LSM6DS::_init(long)+0x3c>
    3e26:	6803      	ldr	r3, [r0, #0]
    3e28:	685b      	ldr	r3, [r3, #4]
    3e2a:	4798      	blx	r3
  delete gyro_sensor;
    3e2c:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    3e2e:	b110      	cbz	r0, 3e36 <Adafruit_LSM6DS::_init(long)+0x46>
    3e30:	6803      	ldr	r3, [r0, #0]
    3e32:	685b      	ldr	r3, [r3, #4]
    3e34:	4798      	blx	r3

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
    3e36:	2010      	movs	r0, #16
    3e38:	f7fe fde4 	bl	2a04 <operator new(unsigned int)>
/** Adafruit Unified Sensor interface for temperature component of LSM6DS */
class Adafruit_LSM6DS_Temp : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the temp sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Temp(Adafruit_LSM6DS *parent) { _theLSM6DS = parent; }
    3e3c:	490f      	ldr	r1, [pc, #60]	; (3e7c <Adafruit_LSM6DS::_init(long)+0x8c>)
    3e3e:	4603      	mov	r3, r0
    3e40:	f44f 62da 	mov.w	r2, #1744	; 0x6d0
    3e44:	6460      	str	r0, [r4, #68]	; 0x44
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
    3e46:	2010      	movs	r0, #16
    3e48:	60dc      	str	r4, [r3, #12]
    3e4a:	6019      	str	r1, [r3, #0]
    3e4c:	609a      	str	r2, [r3, #8]
    3e4e:	f7fe fdd9 	bl	2a04 <operator new(unsigned int)>
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the accelerometer
     sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Accelerometer(Adafruit_LSM6DS *parent) {
    3e52:	490b      	ldr	r1, [pc, #44]	; (3e80 <Adafruit_LSM6DS::_init(long)+0x90>)
    3e54:	4603      	mov	r3, r0
    3e56:	f240 62d1 	movw	r2, #1745	; 0x6d1
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    3e5a:	2010      	movs	r0, #16
  delete temp_sensor;
  delete accel_sensor;
  delete gyro_sensor;

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
    3e5c:	64a3      	str	r3, [r4, #72]	; 0x48
    _theLSM6DS = parent;
    3e5e:	60dc      	str	r4, [r3, #12]
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the accelerometer
     sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Accelerometer(Adafruit_LSM6DS *parent) {
    3e60:	6019      	str	r1, [r3, #0]
    3e62:	609a      	str	r2, [r3, #8]
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    3e64:	f7fe fdce 	bl	2a04 <operator new(unsigned int)>
/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the gyro sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Gyro(Adafruit_LSM6DS *parent) { _theLSM6DS = parent; }
    3e68:	4906      	ldr	r1, [pc, #24]	; (3e84 <Adafruit_LSM6DS::_init(long)+0x94>)
    3e6a:	4603      	mov	r3, r0
    3e6c:	f240 62d2 	movw	r2, #1746	; 0x6d2

  return false;
};
    3e70:	2000      	movs	r0, #0
    3e72:	60dc      	str	r4, [r3, #12]
  delete accel_sensor;
  delete gyro_sensor;

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    3e74:	64e3      	str	r3, [r4, #76]	; 0x4c
    3e76:	6019      	str	r1, [r3, #0]
    3e78:	609a      	str	r2, [r3, #8]

  return false;
};
    3e7a:	bd10      	pop	{r4, pc}
    3e7c:	20000508 	.word	0x20000508
    3e80:	20000524 	.word	0x20000524
    3e84:	200004ec 	.word	0x200004ec

00003e88 <Adafruit_LSM6DS::configIntOutputs(bool, bool)>:
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    3e88:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3e8a:	f8d0 c03c 	ldr.w	ip, [r0, #60]	; 0x3c
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    3e8e:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3e90:	f8d0 e038 	ldr.w	lr, [r0, #56]	; 0x38
    3e94:	2401      	movs	r4, #1
    3e96:	2300      	movs	r3, #0
    3e98:	2712      	movs	r7, #18
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    3e9a:	460e      	mov	r6, r1
    3e9c:	4615      	mov	r5, r2

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3e9e:	4671      	mov	r1, lr
    3ea0:	4662      	mov	r2, ip
    3ea2:	9302      	str	r3, [sp, #8]
    3ea4:	a806      	add	r0, sp, #24
    3ea6:	9403      	str	r4, [sp, #12]
    3ea8:	9401      	str	r4, [sp, #4]
    3eaa:	9700      	str	r7, [sp, #0]
    3eac:	f7fe fe3c 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits ppod_bits =
      Adafruit_BusIO_RegisterBits(&ctrl3, 2, 4);
    3eb0:	a906      	add	r1, sp, #24
    3eb2:	2304      	movs	r3, #4
    3eb4:	2202      	movs	r2, #2
    3eb6:	a804      	add	r0, sp, #16
    3eb8:	f7fe ff32 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  ppod_bits.write((active_low << 1) | open_drain);
    3ebc:	a804      	add	r0, sp, #16
    3ebe:	ea45 0146 	orr.w	r1, r5, r6, lsl #1
    3ec2:	f7fe ff43 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3ec6:	b00d      	add	sp, #52	; 0x34
    3ec8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3eca:	bf00      	nop

00003ecc <Adafruit_LSM6DS::configInt1(bool, bool, bool, bool, bool)>:
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    3ecc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3ed0:	4692      	mov	sl, r2
    3ed2:	461e      	mov	r6, r3
    3ed4:	b093      	sub	sp, #76	; 0x4c

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    3ed6:	2401      	movs	r4, #1
    3ed8:	2500      	movs	r5, #0
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    3eda:	4680      	mov	r8, r0

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    3edc:	270d      	movs	r7, #13
    3ede:	6b80      	ldr	r0, [r0, #56]	; 0x38
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    3ee0:	4689      	mov	r9, r1

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    3ee2:	ea46 064a 	orr.w	r6, r6, sl, lsl #1
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    3ee6:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
    3eea:	462b      	mov	r3, r5
    3eec:	4601      	mov	r1, r0
    3eee:	9700      	str	r7, [sp, #0]
    3ef0:	a806      	add	r0, sp, #24
    3ef2:	9403      	str	r4, [sp, #12]
    3ef4:	9401      	str	r4, [sp, #4]
    3ef6:	9502      	str	r5, [sp, #8]
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    3ef8:	f89d b070 	ldrb.w	fp, [sp, #112]	; 0x70
    3efc:	f89d 7074 	ldrb.w	r7, [sp, #116]	; 0x74

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    3f00:	f7fe fe12 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    3f04:	ea46 0189 	orr.w	r1, r6, r9, lsl #2

  Adafruit_BusIO_Register md1cfg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_MD1_CFG);
    3f08:	265e      	movs	r6, #94	; 0x5e

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    3f0a:	462a      	mov	r2, r5
    3f0c:	a806      	add	r0, sp, #24
    3f0e:	ea41 11cb 	orr.w	r1, r1, fp, lsl #7
    3f12:	f7fe fe6d 	bl	2bf0 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>

  Adafruit_BusIO_Register md1cfg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_MD1_CFG);
    3f16:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
    3f1a:	f8d8 1038 	ldr.w	r1, [r8, #56]	; 0x38
    3f1e:	462b      	mov	r3, r5
    3f20:	9403      	str	r4, [sp, #12]
    3f22:	a80c      	add	r0, sp, #48	; 0x30
    3f24:	9502      	str	r5, [sp, #8]
    3f26:	9401      	str	r4, [sp, #4]
    3f28:	9600      	str	r6, [sp, #0]
    3f2a:	f7fe fdfd 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits wu = Adafruit_BusIO_RegisterBits(&md1cfg, 1, 5);
    3f2e:	4622      	mov	r2, r4
    3f30:	a90c      	add	r1, sp, #48	; 0x30
    3f32:	2305      	movs	r3, #5
    3f34:	a804      	add	r0, sp, #16
    3f36:	f7fe fef3 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  wu.write(wakeup);
    3f3a:	4639      	mov	r1, r7
    3f3c:	a804      	add	r0, sp, #16
    3f3e:	f7fe ff05 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3f42:	b013      	add	sp, #76	; 0x4c
    3f44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00003f48 <Adafruit_LSM6DS::configInt2(bool, bool, bool)>:
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    3f48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    3f4c:	f8d0 c03c 	ldr.w	ip, [r0, #60]	; 0x3c
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    3f50:	b08c      	sub	sp, #48	; 0x30

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    3f52:	6b80      	ldr	r0, [r0, #56]	; 0x38
    3f54:	f04f 0e0e 	mov.w	lr, #14
    3f58:	2500      	movs	r5, #0
    3f5a:	2601      	movs	r6, #1
    3f5c:	f8cd e000 	str.w	lr, [sp]
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    3f60:	460f      	mov	r7, r1
    3f62:	4690      	mov	r8, r2
    3f64:	461c      	mov	r4, r3

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    3f66:	4662      	mov	r2, ip
    3f68:	4601      	mov	r1, r0
    3f6a:	462b      	mov	r3, r5
    3f6c:	a806      	add	r0, sp, #24
    3f6e:	9603      	str	r6, [sp, #12]
    3f70:	9601      	str	r6, [sp, #4]
    3f72:	9502      	str	r5, [sp, #8]
    3f74:	f7fe fdd8 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits int2_drdy_bits =
      Adafruit_BusIO_RegisterBits(&int2_ctrl, 3, 0);
    3f78:	462b      	mov	r3, r5
    3f7a:	a906      	add	r1, sp, #24
    3f7c:	2203      	movs	r2, #3
    3f7e:	a804      	add	r0, sp, #16
    3f80:	f7fe fece 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  int2_drdy_bits.write((drdy_temp << 2) | (drdy_g << 1) | drdy_xl);
    3f84:	a804      	add	r0, sp, #16
    3f86:	ea44 0148 	orr.w	r1, r4, r8, lsl #1
    3f8a:	ea41 0187 	orr.w	r1, r1, r7, lsl #2
    3f8e:	f7fe fedd 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3f92:	b00c      	add	sp, #48	; 0x30
    3f94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003f98 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    3f98:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    3f9c:	f04f 0c28 	mov.w	ip, #40	; 0x28
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    3fa0:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    3fa2:	f8d0 903c 	ldr.w	r9, [r0, #60]	; 0x3c
    3fa6:	f04f 0e00 	mov.w	lr, #0
    3faa:	6b80      	ldr	r0, [r0, #56]	; 0x38
    3fac:	f04f 0806 	mov.w	r8, #6
    3fb0:	2401      	movs	r4, #1
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    3fb2:	460f      	mov	r7, r1
    3fb4:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    3fb6:	4601      	mov	r1, r0
    3fb8:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    3fba:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    3fbc:	a806      	add	r0, sp, #24
    3fbe:	9403      	str	r4, [sp, #12]
    3fc0:	4673      	mov	r3, lr
    3fc2:	f8cd e008 	str.w	lr, [sp, #8]
    3fc6:	f8cd 8004 	str.w	r8, [sp, #4]
    3fca:	f8cd c000 	str.w	ip, [sp]
    3fce:	f7fe fdab 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!accel_data.read((uint8_t *)data, sizeof(data))) {
    3fd2:	4642      	mov	r2, r8
    3fd4:	a806      	add	r0, sp, #24
    3fd6:	a904      	add	r1, sp, #16
    3fd8:	f7fe fe2a 	bl	2c30 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    3fdc:	b388      	cbz	r0, 4042 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xaa>
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    3fde:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    3fe2:	eeb1 4b00 	vmov.f64	d4, #16	; 0x40800000  4.0
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;

  return 1;
    3fe6:	4620      	mov	r0, r4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    3fe8:	ee05 3a10 	vmov	s10, r3
  y = data[1] * 4.0 / 32768.0;
    3fec:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    3ff0:	ee06 3a10 	vmov	s12, r3
  z = data[2] * 4.0 / 32768.0;
    3ff4:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    3ff8:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;
    3ffc:	ee07 3a10 	vmov	s14, r3
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
  y = data[1] * 4.0 / 32768.0;
    4000:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
  z = data[2] * 4.0 / 32768.0;
    4004:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    4008:	ee25 5b04 	vmul.f64	d5, d5, d4
  y = data[1] * 4.0 / 32768.0;
    400c:	ee26 6b04 	vmul.f64	d6, d6, d4
  z = data[2] * 4.0 / 32768.0;
    4010:	ee27 7b04 	vmul.f64	d7, d7, d4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    4014:	ed9f 4b0e 	vldr	d4, [pc, #56]	; 4050 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xb8>
    4018:	ee25 5b04 	vmul.f64	d5, d5, d4
  y = data[1] * 4.0 / 32768.0;
    401c:	ee26 6b04 	vmul.f64	d6, d6, d4
  z = data[2] * 4.0 / 32768.0;
    4020:	ee27 7b04 	vmul.f64	d7, d7, d4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    4024:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
  y = data[1] * 4.0 / 32768.0;
    4028:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 4.0 / 32768.0;
    402c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    4030:	ed87 5a00 	vstr	s10, [r7]
  y = data[1] * 4.0 / 32768.0;
    4034:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 4.0 / 32768.0;
    4038:	ed85 7a00 	vstr	s14, [r5]

  return 1;
}
    403c:	b00d      	add	sp, #52	; 0x34
    403e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);

  if (!accel_data.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    4042:	4b05      	ldr	r3, [pc, #20]	; (4058 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xc0>)
    4044:	602b      	str	r3, [r5, #0]
    4046:	6033      	str	r3, [r6, #0]
    4048:	603b      	str	r3, [r7, #0]
  x = data[0] * 4.0 / 32768.0;
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;

  return 1;
}
    404a:	b00d      	add	sp, #52	; 0x34
    404c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4050:	00000000 	.word	0x00000000
    4054:	3f000000 	.word	0x3f000000
    4058:	7fc00000 	.word	0x7fc00000
    405c:	00000000 	.word	0x00000000

00004060 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    4060:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    4064:	f04f 0c22 	mov.w	ip, #34	; 0x22
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    4068:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    406a:	f8d0 903c 	ldr.w	r9, [r0, #60]	; 0x3c
    406e:	f04f 0e00 	mov.w	lr, #0
    4072:	6b80      	ldr	r0, [r0, #56]	; 0x38
    4074:	f04f 0806 	mov.w	r8, #6
    4078:	2401      	movs	r4, #1
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    407a:	460f      	mov	r7, r1
    407c:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    407e:	4601      	mov	r1, r0
    4080:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    4082:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    4084:	a806      	add	r0, sp, #24
    4086:	9403      	str	r4, [sp, #12]
    4088:	4673      	mov	r3, lr
    408a:	f8cd e008 	str.w	lr, [sp, #8]
    408e:	f8cd 8004 	str.w	r8, [sp, #4]
    4092:	f8cd c000 	str.w	ip, [sp]
    4096:	f7fe fd47 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!gyro_data.read((uint8_t *)data, sizeof(data))) {
    409a:	4642      	mov	r2, r8
    409c:	a806      	add	r0, sp, #24
    409e:	a904      	add	r1, sp, #16
    40a0:	f7fe fdc6 	bl	2c30 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    40a4:	b388      	cbz	r0, 410a <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xaa>
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    40a6:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;

  return 1;
    40aa:	4620      	mov	r0, r4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    40ac:	ee04 3a10 	vmov	s8, r3
  y = data[1] * 2000.0 / 32768.0;
    40b0:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    40b4:	ee05 3a10 	vmov	s10, r3
  z = data[2] * 2000.0 / 32768.0;
    40b8:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    40bc:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;
    40c0:	ee07 3a10 	vmov	s14, r3
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
  y = data[1] * 2000.0 / 32768.0;
    40c4:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  z = data[2] * 2000.0 / 32768.0;
    40c8:	eeb8 6bc7 	vcvt.f64.s32	d6, s14
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    40cc:	ed9f 7b12 	vldr	d7, [pc, #72]	; 4118 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xb8>
    40d0:	ed9f 3b13 	vldr	d3, [pc, #76]	; 4120 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xc0>
  y = data[1] * 2000.0 / 32768.0;
    40d4:	ee25 5b07 	vmul.f64	d5, d5, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    40d8:	ee24 4b07 	vmul.f64	d4, d4, d7
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;
    40dc:	ee26 7b07 	vmul.f64	d7, d6, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    40e0:	ee24 4b03 	vmul.f64	d4, d4, d3
  y = data[1] * 2000.0 / 32768.0;
    40e4:	ee25 6b03 	vmul.f64	d6, d5, d3
  z = data[2] * 2000.0 / 32768.0;
    40e8:	ee27 7b03 	vmul.f64	d7, d7, d3
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    40ec:	eeb7 4bc4 	vcvt.f32.f64	s8, d4
  y = data[1] * 2000.0 / 32768.0;
    40f0:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 2000.0 / 32768.0;
    40f4:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    40f8:	ed87 4a00 	vstr	s8, [r7]
  y = data[1] * 2000.0 / 32768.0;
    40fc:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 2000.0 / 32768.0;
    4100:	ed85 7a00 	vstr	s14, [r5]

  return 1;
}
    4104:	b00d      	add	sp, #52	; 0x34
    4106:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);

  if (!gyro_data.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    410a:	4b07      	ldr	r3, [pc, #28]	; (4128 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xc8>)
    410c:	602b      	str	r3, [r5, #0]
    410e:	6033      	str	r3, [r6, #0]
    4110:	603b      	str	r3, [r7, #0]
  x = data[0] * 2000.0 / 32768.0;
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;

  return 1;
}
    4112:	b00d      	add	sp, #52	; 0x34
    4114:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4118:	00000000 	.word	0x00000000
    411c:	409f4000 	.word	0x409f4000
    4120:	00000000 	.word	0x00000000
    4124:	3f000000 	.word	0x3f000000
    4128:	7fc00000 	.word	0x7fc00000

0000412c <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()>:

/*!
 *    @brief  Class that stores state and functions for interacting with
 *            the LSM6DSOX I2C Digital Potentiometer
 */
class Adafruit_LSM6DSOX : public Adafruit_LSM6DS {
    412c:	4b03      	ldr	r3, [pc, #12]	; (413c <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()+0x10>)
    412e:	b510      	push	{r4, lr}
    4130:	4604      	mov	r4, r0
    4132:	6003      	str	r3, [r0, #0]
    4134:	f7ff fba6 	bl	3884 <Adafruit_LSM6DS::~Adafruit_LSM6DS()>
    4138:	4620      	mov	r0, r4
    413a:	bd10      	pop	{r4, pc}
    413c:	200004a8 	.word	0x200004a8

00004140 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()>:
    4140:	4b05      	ldr	r3, [pc, #20]	; (4158 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()+0x18>)
    4142:	b510      	push	{r4, lr}
    4144:	4604      	mov	r4, r0
    4146:	6003      	str	r3, [r0, #0]
    4148:	f7ff fb9c 	bl	3884 <Adafruit_LSM6DS::~Adafruit_LSM6DS()>
    414c:	2154      	movs	r1, #84	; 0x54
    414e:	4620      	mov	r0, r4
    4150:	f7fe fc5c 	bl	2a0c <operator delete(void*, unsigned int)>
    4154:	4620      	mov	r0, r4
    4156:	bd10      	pop	{r4, pc}
    4158:	200004a8 	.word	0x200004a8

0000415c <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()>:
#include "Adafruit_LSM6DSOX.h"

/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}
    415c:	b510      	push	{r4, lr}
    415e:	4604      	mov	r4, r0
    4160:	f7ff fd6a 	bl	3c38 <Adafruit_LSM6DS::Adafruit_LSM6DS()>
    4164:	4b01      	ldr	r3, [pc, #4]	; (416c <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()+0x10>)
    4166:	4620      	mov	r0, r4
    4168:	6023      	str	r3, [r4, #0]
    416a:	bd10      	pop	{r4, pc}
    416c:	200004a8 	.word	0x200004a8

00004170 <Adafruit_LSM6DSOX::_init(long)>:

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    4170:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    4174:	6b83      	ldr	r3, [r0, #56]	; 0x38
/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    4176:	b09a      	sub	sp, #104	; 0x68
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    4178:	2501      	movs	r5, #1
    417a:	2400      	movs	r4, #0
    417c:	270f      	movs	r7, #15
    417e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    4180:	4606      	mov	r6, r0
    4182:	4688      	mov	r8, r1
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    4184:	a808      	add	r0, sp, #32
    4186:	4619      	mov	r1, r3
    4188:	9503      	str	r5, [sp, #12]
    418a:	4623      	mov	r3, r4
    418c:	9501      	str	r5, [sp, #4]
    418e:	9402      	str	r4, [sp, #8]
    4190:	9700      	str	r7, [sp, #0]
    4192:	f7fe fcc9 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    4196:	a808      	add	r0, sp, #32
    4198:	f7fe fd98 	bl	2ccc <Adafruit_BusIO_Register::read()>
    419c:	286c      	cmp	r0, #108	; 0x6c
    419e:	d003      	beq.n	41a8 <Adafruit_LSM6DSOX::_init(long)+0x38>
    return false;
    41a0:	4620      	mov	r0, r4

  // call base class _init()
  Adafruit_LSM6DS::_init(sensor_id);

  return true;
}
    41a2:	b01a      	add	sp, #104	; 0x68
    41a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
    41a8:	fa1f f388 	uxth.w	r3, r8
  _sensorid_gyro = sensor_id + 1;
  _sensorid_temp = sensor_id + 2;

  reset();
    41ac:	4630      	mov	r0, r6
  Adafruit_BusIO_RegisterBits bdu = Adafruit_BusIO_RegisterBits(&ctrl3, 1, 6);
  bdu.write(true);

  // Disable I3C
  Adafruit_BusIO_Register ctrl_9 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL9_XL);
    41ae:	2718      	movs	r7, #24
  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
  _sensorid_gyro = sensor_id + 1;
    41b0:	1959      	adds	r1, r3, r5
  _sensorid_temp = sensor_id + 2;
    41b2:	1c9a      	adds	r2, r3, #2

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
    41b4:	8633      	strh	r3, [r6, #48]	; 0x30
  _sensorid_gyro = sensor_id + 1;
    41b6:	8671      	strh	r1, [r6, #50]	; 0x32
  _sensorid_temp = sensor_id + 2;
    41b8:	86b2      	strh	r2, [r6, #52]	; 0x34

  reset();
    41ba:	f7ff fd75 	bl	3ca8 <Adafruit_LSM6DS::reset()>

  // Block Data Update
  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL3_C);
    41be:	2312      	movs	r3, #18
    41c0:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
    41c2:	a80e      	add	r0, sp, #56	; 0x38
    41c4:	6bb1      	ldr	r1, [r6, #56]	; 0x38
    41c6:	9300      	str	r3, [sp, #0]
    41c8:	4623      	mov	r3, r4
    41ca:	9503      	str	r5, [sp, #12]
    41cc:	9402      	str	r4, [sp, #8]
    41ce:	9501      	str	r5, [sp, #4]
    41d0:	f7fe fcaa 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits bdu = Adafruit_BusIO_RegisterBits(&ctrl3, 1, 6);
    41d4:	462a      	mov	r2, r5
    41d6:	a90e      	add	r1, sp, #56	; 0x38
    41d8:	2306      	movs	r3, #6
    41da:	a804      	add	r0, sp, #16
    41dc:	f7fe fda0 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  bdu.write(true);
    41e0:	4629      	mov	r1, r5
    41e2:	a804      	add	r0, sp, #16
    41e4:	f7fe fdb2 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // Disable I3C
  Adafruit_BusIO_Register ctrl_9 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL9_XL);
    41e8:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
    41ea:	6bb1      	ldr	r1, [r6, #56]	; 0x38
    41ec:	4623      	mov	r3, r4
    41ee:	9503      	str	r5, [sp, #12]
    41f0:	a814      	add	r0, sp, #80	; 0x50
    41f2:	9402      	str	r4, [sp, #8]
    41f4:	9501      	str	r5, [sp, #4]
    41f6:	9700      	str	r7, [sp, #0]
    41f8:	f7fe fc96 	bl	2b28 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits i3c_disable_bit =
      Adafruit_BusIO_RegisterBits(&ctrl_9, 1, 1);
    41fc:	462b      	mov	r3, r5
    41fe:	462a      	mov	r2, r5
    4200:	a914      	add	r1, sp, #80	; 0x50
    4202:	eb0d 0007 	add.w	r0, sp, r7
    4206:	f7fe fd8b 	bl	2d20 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  i3c_disable_bit.write(true);
    420a:	4629      	mov	r1, r5
    420c:	eb0d 0007 	add.w	r0, sp, r7
    4210:	f7fe fd9c 	bl	2d4c <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // call base class _init()
  Adafruit_LSM6DS::_init(sensor_id);
    4214:	4641      	mov	r1, r8
    4216:	4630      	mov	r0, r6
    4218:	f7ff fdea 	bl	3df0 <Adafruit_LSM6DS::_init(long)>
    421c:	4628      	mov	r0, r5

  return true;
}
    421e:	b01a      	add	sp, #104	; 0x68
    4220:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004224 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>:
	if (interruptMask[n >> 5] == 0) {
		interruptMasksUsed &= ~(1 << (n >> 5));
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    4224:	b470      	push	{r4, r5, r6}
    uint8_t *p_read = (uint8_t*)retbuf;
    size_t count_read = count;

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 
    4226:	f240 2501 	movw	r5, #513	; 0x201
    422a:	6804      	ldr	r4, [r0, #0]
    422c:	6125      	str	r5, [r4, #16]

	while (count > 0) {
    422e:	b31b      	cbz	r3, 4278 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
    4230:	461e      	mov	r6, r3
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    4232:	b1f1      	cbz	r1, 4272 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4e>
    4234:	780d      	ldrb	r5, [r1, #0]
    4236:	3101      	adds	r1, #1
		count--; // how many bytes left to output.
    4238:	3b01      	subs	r3, #1
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    423a:	6665      	str	r5, [r4, #100]	; 0x64
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    423c:	6f25      	ldr	r5, [r4, #112]	; 0x70
    423e:	07ad      	lsls	r5, r5, #30
    4240:	d406      	bmi.n	4250 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
				uint8_t b = port().RDR;  // Read any pending RX bytes in
    4242:	6f65      	ldr	r5, [r4, #116]	; 0x74
				if (p_read) *p_read++ = b; 
				count_read--;
    4244:	3e01      	subs	r6, #1
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
				uint8_t b = port().RDR;  // Read any pending RX bytes in
    4246:	b2ed      	uxtb	r5, r5
				if (p_read) *p_read++ = b; 
    4248:	b112      	cbz	r2, 4250 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
    424a:	7015      	strb	r5, [r2, #0]
    424c:	3201      	adds	r2, #1
    424e:	6804      	ldr	r4, [r0, #0]
				count_read--;
			}
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;
    4250:	6965      	ldr	r5, [r4, #20]
	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
    4252:	07ed      	lsls	r5, r5, #31
    4254:	d5f2      	bpl.n	423c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x18>

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
    4256:	2b00      	cmp	r3, #0
    4258:	d1eb      	bne.n	4232 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0xe>
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;

	}

	// now lets wait for all of the read bytes to be returned...
	while (count_read) {
    425a:	b16e      	cbz	r6, 4278 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    425c:	6801      	ldr	r1, [r0, #0]
		if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    425e:	6f0b      	ldr	r3, [r1, #112]	; 0x70
    4260:	079b      	lsls	r3, r3, #30
    4262:	d4fc      	bmi.n	425e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x3a>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
    4264:	6f4b      	ldr	r3, [r1, #116]	; 0x74
    4266:	b2db      	uxtb	r3, r3
			if (p_read) *p_read++ = b; 
    4268:	b10a      	cbz	r2, 426e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4a>
    426a:	7013      	strb	r3, [r2, #0]
    426c:	3201      	adds	r2, #1
			count_read--;
    426e:	3e01      	subs	r6, #1
    4270:	e7f3      	b.n	425a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x36>
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    4272:	f890 503c 	ldrb.w	r5, [r0, #60]	; 0x3c
    4276:	e7df      	b.n	4238 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x14>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
			if (p_read) *p_read++ = b; 
			count_read--;
		}
	}
}
    4278:	bc70      	pop	{r4, r5, r6}
    427a:	4770      	bx	lr

0000427c <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    427c:	b10b      	cbz	r3, 4282 <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    427e:	f7ff bfd1 	b.w	4224 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>
    4282:	4770      	bx	lr

00004284 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    4284:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    4288:	f890 00a2 	ldrb.w	r0, [r0, #162]	; 0xa2
	}
    428c:	1a10      	subs	r0, r2, r0
    428e:	4770      	bx	lr

00004290 <TwoWire::peek()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4290:	f890 30a2 	ldrb.w	r3, [r0, #162]	; 0xa2
    4294:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    4298:	429a      	cmp	r2, r3
    429a:	d902      	bls.n	42a2 <TwoWire::peek()+0x12>
		return rxBuffer[rxBufferIndex];
    429c:	4403      	add	r3, r0
    429e:	7e98      	ldrb	r0, [r3, #26]
    42a0:	4770      	bx	lr
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    42a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    42a6:	4770      	bx	lr

000042a8 <TwoWire::flush()>:
	virtual void flush(void) {
    42a8:	4770      	bx	lr
    42aa:	bf00      	nop

000042ac <TwoWire::write(unsigned char)>:
}


size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    42ac:	f8b0 3130 	ldrh.w	r3, [r0, #304]	; 0x130
    42b0:	b193      	cbz	r3, 42d8 <TwoWire::write(unsigned char)+0x2c>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    42b2:	f890 312f 	ldrb.w	r3, [r0, #303]	; 0x12f
    42b6:	2b88      	cmp	r3, #136	; 0x88
    42b8:	d80b      	bhi.n	42d2 <TwoWire::write(unsigned char)+0x26>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    42ba:	18c2      	adds	r2, r0, r3
{
}


size_t TwoWire::write(uint8_t data)
{
    42bc:	b410      	push	{r4}
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    42be:	1c5c      	adds	r4, r3, #1
		return 1;
    42c0:	2301      	movs	r3, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    42c2:	f880 412f 	strb.w	r4, [r0, #303]	; 0x12f
		return 1;
	}
	return 0;
}
    42c6:	4618      	mov	r0, r3
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    42c8:	f882 10a5 	strb.w	r1, [r2, #165]	; 0xa5
		return 1;
	}
	return 0;
}
    42cc:	f85d 4b04 	ldr.w	r4, [sp], #4
    42d0:	4770      	bx	lr
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	// int printf(const char *format, ...) __attribute__ ((format (printf, 2, 3)));

  protected:
	void setWriteError(int err = 1) { write_error = err; }
    42d2:	2201      	movs	r2, #1
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    42d4:	2300      	movs	r3, #0
    42d6:	7102      	strb	r2, [r0, #4]
		}
		txBuffer[txBufferLength++] = data;
		return 1;
	}
	return 0;
}
    42d8:	4618      	mov	r0, r3
    42da:	4770      	bx	lr

000042dc <TwoWire::write(unsigned char const*, unsigned int)>:

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    42dc:	b538      	push	{r3, r4, r5, lr}
    42de:	4605      	mov	r5, r0
	if (transmitting || slave_mode) {
    42e0:	f8b0 0130 	ldrh.w	r0, [r0, #304]	; 0x130
    42e4:	b190      	cbz	r0, 430c <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    42e6:	f895 312f 	ldrb.w	r3, [r5, #303]	; 0x12f
    42ea:	4614      	mov	r4, r2
    42ec:	f1c3 0289 	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    42f0:	4294      	cmp	r4, r2
    42f2:	d80c      	bhi.n	430e <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    42f4:	f105 00a5 	add.w	r0, r5, #165	; 0xa5
    42f8:	4622      	mov	r2, r4
    42fa:	4418      	add	r0, r3
    42fc:	f002 f930 	bl	6560 <memcpy>
		txBufferLength += quantity;
    4300:	f895 312f 	ldrb.w	r3, [r5, #303]	; 0x12f
    4304:	4620      	mov	r0, r4
    4306:	441c      	add	r4, r3
    4308:	f885 412f 	strb.w	r4, [r5, #303]	; 0x12f
		return quantity;
	}
	return 0;
}
    430c:	bd38      	pop	{r3, r4, r5, pc}
    430e:	4614      	mov	r4, r2
    4310:	2201      	movs	r2, #1
    4312:	712a      	strb	r2, [r5, #4]
    4314:	e7ee      	b.n	42f4 <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    4316:	bf00      	nop

00004318 <TwoWire::force_clock()>:
	if (qty > BUFFER_LENGTH) qty = BUFFER_LENGTH;
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
    4318:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    431c:	4683      	mov	fp, r0
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    431e:	4840      	ldr	r0, [pc, #256]	; (4420 <TwoWire::force_clock()+0x108>)
	if (qty > BUFFER_LENGTH) qty = BUFFER_LENGTH;
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
    4320:	b083      	sub	sp, #12
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    4322:	2515      	movs	r5, #21
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    4324:	f8db a014 	ldr.w	sl, [fp, #20]
    4328:	f89b 6018 	ldrb.w	r6, [fp, #24]
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    432c:	f89b 3019 	ldrb.w	r3, [fp, #25]
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    4330:	eb0a 1606 	add.w	r6, sl, r6, lsl #4
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4334:	493b      	ldr	r1, [pc, #236]	; (4424 <TwoWire::force_clock()+0x10c>)
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    4336:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    433a:	f8df e0ec 	ldr.w	lr, [pc, #236]	; 4428 <TwoWire::force_clock()+0x110>
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    433e:	7a36      	ldrb	r6, [r6, #8]
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4340:	460c      	mov	r4, r1
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    4342:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    4346:	0136      	lsls	r6, r6, #4
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4348:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 442c <TwoWire::force_clock()+0x114>
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    434c:	011b      	lsls	r3, r3, #4
bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    434e:	1987      	adds	r7, r0, r6
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
    4350:	f850 8006 	ldr.w	r8, [r0, r6]
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    4354:	eb00 0c03 	add.w	ip, r0, r3
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
    4358:	58c6      	ldr	r6, [r0, r3]
bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    435a:	68f8      	ldr	r0, [r7, #12]
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    435c:	687b      	ldr	r3, [r7, #4]
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    435e:	f8dc 700c 	ldr.w	r7, [ip, #12]
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    4362:	9300      	str	r3, [sp, #0]
    4364:	601d      	str	r5, [r3, #0]
	*portSetRegister(sda_pin) = sda_mask;
    4366:	f8c8 0084 	str.w	r0, [r8, #132]	; 0x84
	*portModeRegister(sda_pin) |= sda_mask;
    436a:	f8d8 3004 	ldr.w	r3, [r8, #4]
	*portConfigRegister(scl_pin) = 5 | 0x10;
    436e:	f8dc 2004 	ldr.w	r2, [ip, #4]
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
    4372:	4303      	orrs	r3, r0
	*portConfigRegister(scl_pin) = 5 | 0x10;
    4374:	9201      	str	r2, [sp, #4]
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
    4376:	f8c8 3004 	str.w	r3, [r8, #4]
	*portConfigRegister(scl_pin) = 5 | 0x10;
    437a:	6015      	str	r5, [r2, #0]
	*portSetRegister(scl_pin) = scl_mask;
    437c:	f8c6 7084 	str.w	r7, [r6, #132]	; 0x84
	*portModeRegister(scl_pin) |= scl_mask;
    4380:	6873      	ldr	r3, [r6, #4]
    4382:	433b      	orrs	r3, r7
    4384:	6073      	str	r3, [r6, #4]
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4386:	6809      	ldr	r1, [r1, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4388:	f8de 3000 	ldr.w	r3, [lr]
    438c:	fba9 3203 	umull	r3, r2, r9, r3
    4390:	0c92      	lsrs	r2, r2, #18
    4392:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    4396:	0052      	lsls	r2, r2, #1
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4398:	6823      	ldr	r3, [r4, #0]
    439a:	1a5b      	subs	r3, r3, r1
    439c:	429a      	cmp	r2, r3
    439e:	d8fb      	bhi.n	4398 <TwoWire::force_clock()+0x80>
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    43a0:	4a20      	ldr	r2, [pc, #128]	; (4424 <TwoWire::force_clock()+0x10c>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    43a2:	2509      	movs	r5, #9
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    43a4:	f8df c084 	ldr.w	ip, [pc, #132]	; 442c <TwoWire::force_clock()+0x114>
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    43a8:	4691      	mov	r9, r2
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
    43aa:	f8d8 3008 	ldr.w	r3, [r8, #8]
		  && (*portInputRegister(scl_pin) & scl_mask)) {
    43ae:	4218      	tst	r0, r3
    43b0:	d002      	beq.n	43b8 <TwoWire::force_clock()+0xa0>
    43b2:	68b3      	ldr	r3, [r6, #8]
    43b4:	421f      	tst	r7, r3
    43b6:	d131      	bne.n	441c <TwoWire::force_clock()+0x104>
			// success, both pins are high
			ret = true;
			break;
		}
		*portClearRegister(scl_pin) = scl_mask;
    43b8:	f8c6 7088 	str.w	r7, [r6, #136]	; 0x88
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    43bc:	6814      	ldr	r4, [r2, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    43be:	f8de 1000 	ldr.w	r1, [lr]
    43c2:	fbac 3101 	umull	r3, r1, ip, r1
    43c6:	0c89      	lsrs	r1, r1, #18
    43c8:	eb01 0181 	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    43cc:	6813      	ldr	r3, [r2, #0]
    43ce:	1b1b      	subs	r3, r3, r4
    43d0:	4299      	cmp	r1, r3
    43d2:	d8fb      	bhi.n	43cc <TwoWire::force_clock()+0xb4>
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
    43d4:	f8c6 7084 	str.w	r7, [r6, #132]	; 0x84
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    43d8:	f8d9 4000 	ldr.w	r4, [r9]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    43dc:	f8de 1000 	ldr.w	r1, [lr]
    43e0:	fbac 3101 	umull	r3, r1, ip, r1
    43e4:	0c89      	lsrs	r1, r1, #18
    43e6:	eb01 0181 	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    43ea:	6813      	ldr	r3, [r2, #0]
    43ec:	1b1b      	subs	r3, r3, r4
    43ee:	4299      	cmp	r1, r3
    43f0:	d8fb      	bhi.n	43ea <TwoWire::force_clock()+0xd2>
	*portModeRegister(sda_pin) |= sda_mask;
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
	*portModeRegister(scl_pin) |= scl_mask;
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
    43f2:	3d01      	subs	r5, #1
    43f4:	d1d9      	bne.n	43aa <TwoWire::force_clock()+0x92>
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
	bool ret = false;
    43f6:	4628      	mov	r0, r5
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
		delayMicroseconds(5);
	}
	// return control of pins to I2C
	*(portConfigRegister(sda_pin)) = hardware.sda_pins[sda_pin_index_].mux_val;
    43f8:	f89b 3018 	ldrb.w	r3, [fp, #24]
    43fc:	9a00      	ldr	r2, [sp, #0]
    43fe:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
    4402:	68db      	ldr	r3, [r3, #12]
    4404:	6013      	str	r3, [r2, #0]
	*(portConfigRegister(scl_pin)) = hardware.scl_pins[scl_pin_index_].mux_val;
    4406:	f89b 3019 	ldrb.w	r3, [fp, #25]
    440a:	9a01      	ldr	r2, [sp, #4]
    440c:	eb0a 1a03 	add.w	sl, sl, r3, lsl #4
    4410:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
    4414:	6013      	str	r3, [r2, #0]
	return ret;
}
    4416:	b003      	add	sp, #12
    4418:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
		  && (*portInputRegister(scl_pin) & scl_mask)) {
			// success, both pins are high
			ret = true;
    441c:	2001      	movs	r0, #1
    441e:	e7eb      	b.n	43f8 <TwoWire::force_clock()+0xe0>
    4420:	200006dc 	.word	0x200006dc
    4424:	e0001004 	.word	0xe0001004
    4428:	20001430 	.word	0x20001430
    442c:	431bde83 	.word	0x431bde83

00004430 <TwoWire::wait_idle()>:
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
    4430:	490d      	ldr	r1, [pc, #52]	; (4468 <TwoWire::wait_idle()+0x38>)
    4432:	6902      	ldr	r2, [r0, #16]
//   01   EPF = End Packet Flag
//      2 RDF = Receive Data Flag
//      1 TDF = Transmit Data Flag

bool TwoWire::wait_idle()
{
    4434:	b510      	push	{r4, lr}
    4436:	680c      	ldr	r4, [r1, #0]
    4438:	e005      	b.n	4446 <TwoWire::wait_idle()+0x16>
	elapsedMillis timeout = 0;
	while (1) {
		uint32_t status = port->MSR; // pg 2899 & 2892
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
		if (status & LPI2C_MSR_MBF) break; // we already have bus control
    443a:	01db      	lsls	r3, r3, #7
    443c:	d407      	bmi.n	444e <TwoWire::wait_idle()+0x1e>
    443e:	680b      	ldr	r3, [r1, #0]
		if (timeout > 16) {
    4440:	1b1b      	subs	r3, r3, r4
    4442:	2b10      	cmp	r3, #16
    4444:	d808      	bhi.n	4458 <TwoWire::wait_idle()+0x28>

bool TwoWire::wait_idle()
{
	elapsedMillis timeout = 0;
	while (1) {
		uint32_t status = port->MSR; // pg 2899 & 2892
    4446:	6953      	ldr	r3, [r2, #20]
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
    4448:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    444c:	d1f5      	bne.n	443a <TwoWire::wait_idle()+0xa>
			if (force_clock()) break;
			//Serial.printf("unable to get control of I2C bus\n");
			return false;
		}
	}
	port->MSR = 0x00007F00; // clear all prior flags
    444e:	f44f 43fe 	mov.w	r3, #32512	; 0x7f00
	return true;
    4452:	2001      	movs	r0, #1
			if (force_clock()) break;
			//Serial.printf("unable to get control of I2C bus\n");
			return false;
		}
	}
	port->MSR = 0x00007F00; // clear all prior flags
    4454:	6153      	str	r3, [r2, #20]
	return true;
}
    4456:	bd10      	pop	{r4, pc}
    4458:	4604      	mov	r4, r0
		uint32_t status = port->MSR; // pg 2899 & 2892
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
		if (status & LPI2C_MSR_MBF) break; // we already have bus control
		if (timeout > 16) {
			//Serial.printf("timeout waiting for idle, MSR = %x\n", status);
			if (force_clock()) break;
    445a:	f7ff ff5d 	bl	4318 <TwoWire::force_clock()>
    445e:	2800      	cmp	r0, #0
    4460:	d0f9      	beq.n	4456 <TwoWire::wait_idle()+0x26>
    4462:	6922      	ldr	r2, [r4, #16]
    4464:	e7f3      	b.n	444e <TwoWire::wait_idle()+0x1e>
    4466:	bf00      	nop
    4468:	20002740 	.word	0x20002740

0000446c <TwoWire::endTransmission(unsigned char)>:
	return true;
}


uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    446c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t tx_len = txBufferLength;
    4470:	f890 a12f 	ldrb.w	sl, [r0, #303]	; 0x12f
	if (!tx_len) return 4; // no address for transmit
    4474:	f1ba 0f00 	cmp.w	sl, #0
    4478:	d102      	bne.n	4480 <TwoWire::endTransmission(unsigned char)+0x14>
    447a:	2004      	movs	r0, #4
    447c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4480:	4605      	mov	r5, r0
    4482:	460e      	mov	r6, r1
	if (!wait_idle()) return 4;
    4484:	f7ff ffd4 	bl	4430 <TwoWire::wait_idle()>
    4488:	2800      	cmp	r0, #0
    448a:	d0f6      	beq.n	447a <TwoWire::endTransmission(unsigned char)+0xe>
    448c:	4f2e      	ldr	r7, [pc, #184]	; (4548 <TwoWire::endTransmission(unsigned char)+0xdc>)
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
    448e:	2400      	movs	r4, #0
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4490:	f44f 7900 	mov.w	r9, #512	; 0x200
    4494:	f8d7 8000 	ldr.w	r8, [r7]
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
    4498:	4554      	cmp	r4, sl
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
    449a:	6929      	ldr	r1, [r5, #16]
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
    449c:	d81a      	bhi.n	44d4 <TwoWire::endTransmission(unsigned char)+0x68>
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
    449e:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
    44a0:	f003 0307 	and.w	r3, r3, #7
			while (fifo_used < 4) {
    44a4:	2b03      	cmp	r3, #3
    44a6:	d909      	bls.n	44bc <TwoWire::endTransmission(unsigned char)+0x50>
    44a8:	e014      	b.n	44d4 <TwoWire::endTransmission(unsigned char)+0x68>
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    44aa:	f895 20a5 	ldrb.w	r2, [r5, #165]	; 0xa5
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
					tx_index++;
					break;
				}
				fifo_used++;
    44ae:	3301      	adds	r3, #1
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
    44b0:	2401      	movs	r4, #1
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    44b2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    44b6:	2b04      	cmp	r3, #4
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    44b8:	660a      	str	r2, [r1, #96]	; 0x60
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    44ba:	d00b      	beq.n	44d4 <TwoWire::endTransmission(unsigned char)+0x68>
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    44bc:	192a      	adds	r2, r5, r4
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
    44be:	2c00      	cmp	r4, #0
    44c0:	d0f3      	beq.n	44aa <TwoWire::endTransmission(unsigned char)+0x3e>
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
    44c2:	45a2      	cmp	sl, r4
    44c4:	d927      	bls.n	4516 <TwoWire::endTransmission(unsigned char)+0xaa>
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
					tx_index++;
					break;
				}
				fifo_used++;
    44c6:	3301      	adds	r3, #1
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    44c8:	f892 20a5 	ldrb.w	r2, [r2, #165]	; 0xa5
    44cc:	3401      	adds	r4, #1
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    44ce:	2b04      	cmp	r3, #4
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    44d0:	660a      	str	r2, [r1, #96]	; 0x60
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    44d2:	d1f3      	bne.n	44bc <TwoWire::endTransmission(unsigned char)+0x50>
				}
				fifo_used++;
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
    44d4:	694b      	ldr	r3, [r1, #20]
		if (status & LPI2C_MSR_ALF) {
    44d6:	0518      	lsls	r0, r3, #20
    44d8:	d422      	bmi.n	4520 <TwoWire::endTransmission(unsigned char)+0xb4>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			return 4; // we lost bus arbitration to another master
		}
		if (status & LPI2C_MSR_NDF) {
    44da:	055a      	lsls	r2, r3, #21
    44dc:	d427      	bmi.n	452e <TwoWire::endTransmission(unsigned char)+0xc2>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP;
			return 2; // NACK (assume address, TODO: how to tell address from data)
		}
		if ((status & LPI2C_MSR_PLTF) || timeout > 50) {
    44de:	0498      	lsls	r0, r3, #18
    44e0:	d404      	bmi.n	44ec <TwoWire::endTransmission(unsigned char)+0x80>
    44e2:	683a      	ldr	r2, [r7, #0]
    44e4:	ebc8 0202 	rsb	r2, r8, r2
    44e8:	2a32      	cmp	r2, #50	; 0x32
    44ea:	d909      	bls.n	4500 <TwoWire::endTransmission(unsigned char)+0x94>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    44ec:	690b      	ldr	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    44ee:	f44f 7200 	mov.w	r2, #512	; 0x200
			return 4; // clock stretched too long or generic timeout
    44f2:	2004      	movs	r0, #4
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP;
			return 2; // NACK (assume address, TODO: how to tell address from data)
		}
		if ((status & LPI2C_MSR_PLTF) || timeout > 50) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    44f4:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    44f8:	610b      	str	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    44fa:	660a      	str	r2, [r1, #96]	; 0x60
			return 4; // clock stretched too long or generic timeout
    44fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
    4500:	4554      	cmp	r4, sl
    4502:	d905      	bls.n	4510 <TwoWire::endTransmission(unsigned char)+0xa4>
			uint32_t tx_fifo = port->MFSR & 0x07;
    4504:	6dca      	ldr	r2, [r1, #92]	; 0x5c
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
    4506:	0752      	lsls	r2, r2, #29
    4508:	d102      	bne.n	4510 <TwoWire::endTransmission(unsigned char)+0xa4>
    450a:	059b      	lsls	r3, r3, #22
    450c:	d419      	bmi.n	4542 <TwoWire::endTransmission(unsigned char)+0xd6>
    450e:	b1c6      	cbz	r6, 4542 <TwoWire::endTransmission(unsigned char)+0xd6>
				return 0;
			}
		}
		yield();
    4510:	f7fe fa92 	bl	2a38 <yield>
	uint32_t tx_len = txBufferLength;
	if (!tx_len) return 4; // no address for transmit
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
    4514:	e7c0      	b.n	4498 <TwoWire::endTransmission(unsigned char)+0x2c>
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4516:	b10e      	cbz	r6, 451c <TwoWire::endTransmission(unsigned char)+0xb0>
    4518:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
					tx_index++;
    451c:	3401      	adds	r4, #1
					break;
    451e:	e7d9      	b.n	44d4 <TwoWire::endTransmission(unsigned char)+0x68>
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4520:	690b      	ldr	r3, [r1, #16]
			return 4; // we lost bus arbitration to another master
    4522:	2004      	movs	r0, #4
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4524:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    4528:	610b      	str	r3, [r1, #16]
			return 4; // we lost bus arbitration to another master
    452a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		if (status & LPI2C_MSR_NDF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    452e:	690b      	ldr	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP;
    4530:	f44f 7200 	mov.w	r2, #512	; 0x200
			return 2; // NACK (assume address, TODO: how to tell address from data)
    4534:	2002      	movs	r0, #2
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			return 4; // we lost bus arbitration to another master
		}
		if (status & LPI2C_MSR_NDF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4536:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    453a:	610b      	str	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP;
    453c:	660a      	str	r2, [r1, #96]	; 0x60
			return 2; // NACK (assume address, TODO: how to tell address from data)
    453e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
			uint32_t tx_fifo = port->MFSR & 0x07;
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
				return 0;
    4542:	2000      	movs	r0, #0
    4544:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4548:	20002740 	.word	0x20002740

0000454c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
		yield();
	}
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    454c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4550:	460c      	mov	r4, r1
    4552:	4615      	mov	r5, r2
    4554:	4698      	mov	r8, r3
    4556:	4681      	mov	r9, r0
	if (!wait_idle()) return 4;
    4558:	f7ff ff6a 	bl	4430 <TwoWire::wait_idle()>
    455c:	b910      	cbnz	r0, 4564 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x18>
    455e:	2004      	movs	r0, #4
    4560:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
    4564:	2200      	movs	r2, #0
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
    4566:	0063      	lsls	r3, r4, #1
	if (length < 1) length = 1;
    4568:	2d00      	cmp	r5, #0
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    456a:	f240 4a01 	movw	sl, #1025	; 0x401
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
    456e:	4614      	mov	r4, r2
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4570:	b2db      	uxtb	r3, r3
    4572:	4e3d      	ldr	r6, [pc, #244]	; (4668 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>)

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
    4574:	bf08      	it	eq
    4576:	2501      	moveq	r5, #1
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    4578:	2c02      	cmp	r4, #2
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    457a:	ea43 0a0a 	orr.w	sl, r3, sl
    457e:	f8d6 b000 	ldr.w	fp, [r6]
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
    4582:	f889 20a2 	strb.w	r2, [r9, #162]	; 0xa2
	rxBufferLength = 0;
    4586:	f889 20a3 	strb.w	r2, [r9, #163]	; 0xa3
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    458a:	d948      	bls.n	461e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xd2>
    458c:	f8d9 3010 	ldr.w	r3, [r9, #16]
				tx_state++;
				tx_fifo--;
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
    4590:	f899 20a3 	ldrb.w	r2, [r9, #163]	; 0xa3
    4594:	2a87      	cmp	r2, #135	; 0x87
    4596:	d812      	bhi.n	45be <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
    4598:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
    459a:	f3c1 4102 	ubfx	r1, r1, #16, #3
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    459e:	b911      	cbnz	r1, 45a6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x5a>
    45a0:	e00d      	b.n	45be <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    45a2:	2a88      	cmp	r2, #136	; 0x88
    45a4:	d00b      	beq.n	45be <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
				rxBuffer[rxBufferLength++] = port->MRDR;
    45a6:	f102 0e01 	add.w	lr, r2, #1
    45aa:	eb09 0002 	add.w	r0, r9, r2
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    45ae:	3901      	subs	r1, #1
				rxBuffer[rxBufferLength++] = port->MRDR;
    45b0:	fa5f f28e 	uxtb.w	r2, lr
    45b4:	f889 20a3 	strb.w	r2, [r9, #163]	; 0xa3
    45b8:	6f1f      	ldr	r7, [r3, #112]	; 0x70
    45ba:	7687      	strb	r7, [r0, #26]
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    45bc:	d1f1      	bne.n	45a2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x56>
				rxBuffer[rxBufferLength++] = port->MRDR;
				rx_fifo--;
			}
		}
		// monitor status, check for error conditions
		uint32_t status = port->MSR; // pg 2884 & 2891
    45be:	695a      	ldr	r2, [r3, #20]
		if (status & LPI2C_MSR_ALF) {
    45c0:	0510      	lsls	r0, r2, #20
    45c2:	d44c      	bmi.n	465e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x112>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			break;
		}
		if ((status & LPI2C_MSR_NDF) || (status & LPI2C_MSR_PLTF) || timeout > 50) {
    45c4:	f412 5f10 	tst.w	r2, #9216	; 0x2400
    45c8:	d104      	bne.n	45d4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x88>
    45ca:	6831      	ldr	r1, [r6, #0]
    45cc:	ebcb 0101 	rsb	r1, fp, r1
    45d0:	2932      	cmp	r1, #50	; 0x32
    45d2:	d912      	bls.n	45fa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xae>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    45d4:	691a      	ldr	r2, [r3, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    45d6:	f44f 7100 	mov.w	r1, #512	; 0x200
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			break;
		}
		if ((status & LPI2C_MSR_NDF) || (status & LPI2C_MSR_PLTF) || timeout > 50) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    45da:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    45de:	611a      	str	r2, [r3, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    45e0:	6619      	str	r1, [r3, #96]	; 0x60
				break;
			}
		}
		yield();
	}
	uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
    45e2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
	if (rx_fifo > 0) port->MCR |= LPI2C_MCR_RRF;
    45e4:	f412 2fe0 	tst.w	r2, #458752	; 0x70000
    45e8:	d003      	beq.n	45f2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
    45ea:	691a      	ldr	r2, [r3, #16]
    45ec:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    45f0:	611a      	str	r2, [r3, #16]
	return rxBufferLength;
    45f2:	f899 00a3 	ldrb.w	r0, [r9, #163]	; 0xa3
    45f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
			break;
		}
		// are we done yet?
		if (rxBufferLength >= length && tx_state >= 3) {
    45fa:	f899 10a3 	ldrb.w	r1, [r9, #163]	; 0xa3
    45fe:	42a9      	cmp	r1, r5
    4600:	d309      	bcc.n	4616 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    4602:	2c02      	cmp	r4, #2
    4604:	d907      	bls.n	4616 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
			uint32_t tx_fifo = port->MFSR & 0x07;
    4606:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
    4608:	0749      	lsls	r1, r1, #29
    460a:	d104      	bne.n	4616 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    460c:	0592      	lsls	r2, r2, #22
    460e:	d4e8      	bmi.n	45e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    4610:	f1b8 0f00 	cmp.w	r8, #0
    4614:	d0e5      	beq.n	45e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
				break;
			}
		}
		yield();
    4616:	f7fe fa0f 	bl	2a38 <yield>
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    461a:	2c02      	cmp	r4, #2
    461c:	d8b6      	bhi.n	458c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x40>
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
    461e:	f8d9 2010 	ldr.w	r2, [r9, #16]
    4622:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    4624:	f003 0307 	and.w	r3, r3, #7
			while (tx_fifo < 4 && tx_state < 3) {
    4628:	2b03      	cmp	r3, #3
    462a:	d80d      	bhi.n	4648 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    462c:	1e69      	subs	r1, r5, #1
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    462e:	f44f 7000 	mov.w	r0, #512	; 0x200
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    4632:	f441 7180 	orr.w	r1, r1, #256	; 0x100
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
    4636:	b94c      	cbnz	r4, 464c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x100>
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4638:	f8c2 a060 	str.w	sl, [r2, #96]	; 0x60
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
				}
				tx_state++;
				tx_fifo--;
    463c:	3b01      	subs	r3, #1
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
				}
				tx_state++;
    463e:	3401      	adds	r4, #1
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
    4640:	2b03      	cmp	r3, #3
    4642:	d801      	bhi.n	4648 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
    4644:	2c02      	cmp	r4, #2
    4646:	d9f6      	bls.n	4636 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
    4648:	4613      	mov	r3, r2
    464a:	e7a1      	b.n	4590 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
    464c:	2c01      	cmp	r4, #1
    464e:	d004      	beq.n	465a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10e>
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4650:	f1b8 0f00 	cmp.w	r8, #0
    4654:	d0f2      	beq.n	463c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    4656:	6610      	str	r0, [r2, #96]	; 0x60
    4658:	e7f0      	b.n	463c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    465a:	6611      	str	r1, [r2, #96]	; 0x60
    465c:	e7ee      	b.n	463c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
			}
		}
		// monitor status, check for error conditions
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    465e:	691a      	ldr	r2, [r3, #16]
    4660:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    4664:	611a      	str	r2, [r3, #16]
    4666:	e7bc      	b.n	45e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    4668:	20002740 	.word	0x20002740

0000466c <TwoWire::isr()>:
}


void TwoWire::isr(void)
{
	uint32_t status = port->SSR;
    466c:	6903      	ldr	r3, [r0, #16]
	port->SCR = LPI2C_SCR_SEN;
}


void TwoWire::isr(void)
{
    466e:	b570      	push	{r4, r5, r6, lr}
	uint32_t status = port->SSR;
    4670:	f8d3 5114 	ldr.w	r5, [r3, #276]	; 0x114
	port->SCR = LPI2C_SCR_SEN;
}


void TwoWire::isr(void)
{
    4674:	4604      	mov	r4, r0
	uint32_t status = port->SSR;
	uint32_t w1c_bits = status & 0xF00;
	if (w1c_bits) port->SSR = w1c_bits;
    4676:	f415 6270 	ands.w	r2, r5, #3840	; 0xf00
    467a:	d001      	beq.n	4680 <TwoWire::isr()+0x14>
    467c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

	//Serial.print("isr ");
	//Serial.println(status, HEX);

	if (status & LPI2C_SSR_RDF) { // Receive Data Flag
    4680:	07ae      	lsls	r6, r5, #30
    4682:	d50b      	bpl.n	469c <TwoWire::isr()+0x30>
		int rx = port->SRDR;
    4684:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
		if (rx & 0x8000) {
    4688:	0408      	lsls	r0, r1, #16
    468a:	d542      	bpl.n	4712 <TwoWire::isr()+0xa6>
			rxBufferIndex = 0;
    468c:	2200      	movs	r2, #0
    468e:	2001      	movs	r0, #1
    4690:	f884 20a2 	strb.w	r2, [r4, #162]	; 0xa2
			rxBufferLength = 0;
		}
		if (rxBufferLength < BUFFER_LENGTH) {
			rxBuffer[rxBufferLength++] = rx & 255;
    4694:	4422      	add	r2, r4
    4696:	f884 00a3 	strb.w	r0, [r4, #163]	; 0xa3
    469a:	7691      	strb	r1, [r2, #26]
		}
		//Serial.print("rx = ");
		//Serial.println(rx, HEX);
	}
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
    469c:	07ea      	lsls	r2, r5, #31
    469e:	d510      	bpl.n	46c2 <TwoWire::isr()+0x56>
		if (!transmitting) {
    46a0:	f894 6130 	ldrb.w	r6, [r4, #304]	; 0x130
    46a4:	b316      	cbz	r6, 46ec <TwoWire::isr()+0x80>
    46a6:	f894 612e 	ldrb.w	r6, [r4, #302]	; 0x12e
				(*user_onRequest)();
			}
			txBufferIndex = 0;
			transmitting = 1;
		}
		if (txBufferIndex < txBufferLength) {
    46aa:	f894 212f 	ldrb.w	r2, [r4, #303]	; 0x12f
    46ae:	42b2      	cmp	r2, r6
    46b0:	d92b      	bls.n	470a <TwoWire::isr()+0x9e>
			port->STDR = txBuffer[txBufferIndex++];
    46b2:	1c72      	adds	r2, r6, #1
    46b4:	4426      	add	r6, r4
    46b6:	f884 212e 	strb.w	r2, [r4, #302]	; 0x12e
    46ba:	f896 20a5 	ldrb.w	r2, [r6, #165]	; 0xa5
    46be:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
			port->STDR = 0;
		}
		//Serial.println("tx");
	}

	if (status & LPI2C_SSR_SDF) { // Stop
    46c2:	05ab      	lsls	r3, r5, #22
    46c4:	d511      	bpl.n	46ea <TwoWire::isr()+0x7e>
		//Serial.println("Stop");
		if (rxBufferLength > 0 && user_onReceive != nullptr) {
    46c6:	f894 00a3 	ldrb.w	r0, [r4, #163]	; 0xa3
    46ca:	b118      	cbz	r0, 46d4 <TwoWire::isr()+0x68>
    46cc:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
    46d0:	b103      	cbz	r3, 46d4 <TwoWire::isr()+0x68>
			(*user_onReceive)(rxBufferLength);
    46d2:	4798      	blx	r3
		}
		rxBufferIndex = 0;
    46d4:	2300      	movs	r3, #0
    46d6:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
		rxBufferLength = 0;
    46da:	f884 30a3 	strb.w	r3, [r4, #163]	; 0xa3
		txBufferIndex = 0;
    46de:	f884 312e 	strb.w	r3, [r4, #302]	; 0x12e
		txBufferLength = 0;
    46e2:	f884 312f 	strb.w	r3, [r4, #303]	; 0x12f
		transmitting = 0;
    46e6:	f884 3130 	strb.w	r3, [r4, #304]	; 0x130
    46ea:	bd70      	pop	{r4, r5, r6, pc}
		//Serial.print("rx = ");
		//Serial.println(rx, HEX);
	}
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
    46ec:	f8d4 2138 	ldr.w	r2, [r4, #312]	; 0x138
    46f0:	b10a      	cbz	r2, 46f6 <TwoWire::isr()+0x8a>
				(*user_onRequest)();
    46f2:	4790      	blx	r2
    46f4:	6923      	ldr	r3, [r4, #16]
			}
			txBufferIndex = 0;
			transmitting = 1;
    46f6:	2201      	movs	r2, #1
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
				(*user_onRequest)();
			}
			txBufferIndex = 0;
    46f8:	2100      	movs	r1, #0
			transmitting = 1;
    46fa:	f884 2130 	strb.w	r2, [r4, #304]	; 0x130
		}
		if (txBufferIndex < txBufferLength) {
    46fe:	f894 212f 	ldrb.w	r2, [r4, #303]	; 0x12f
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
				(*user_onRequest)();
			}
			txBufferIndex = 0;
    4702:	f884 112e 	strb.w	r1, [r4, #302]	; 0x12e
			transmitting = 1;
		}
		if (txBufferIndex < txBufferLength) {
    4706:	42b2      	cmp	r2, r6
    4708:	d8d3      	bhi.n	46b2 <TwoWire::isr()+0x46>
			port->STDR = txBuffer[txBufferIndex++];
		} else {
			port->STDR = 0;
    470a:	2200      	movs	r2, #0
    470c:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
    4710:	e7d7      	b.n	46c2 <TwoWire::isr()+0x56>
		int rx = port->SRDR;
		if (rx & 0x8000) {
			rxBufferIndex = 0;
			rxBufferLength = 0;
		}
		if (rxBufferLength < BUFFER_LENGTH) {
    4712:	f894 20a3 	ldrb.w	r2, [r4, #163]	; 0xa3
    4716:	2a87      	cmp	r2, #135	; 0x87
    4718:	d8c0      	bhi.n	469c <TwoWire::isr()+0x30>
    471a:	1c50      	adds	r0, r2, #1
    471c:	b2c0      	uxtb	r0, r0
    471e:	e7b9      	b.n	4694 <TwoWire::isr()+0x28>

00004720 <lpi2c1_isr()>:
void lpi2c1_isr(void) { Wire.isr(); }
void lpi2c3_isr(void) { Wire2.isr(); }
void lpi2c4_isr(void) { Wire1.isr(); }
void lpi2c2_isr(void) { Wire3.isr(); }
#else
void lpi2c1_isr(void) { Wire.isr(); }
    4720:	4801      	ldr	r0, [pc, #4]	; (4728 <lpi2c1_isr()+0x8>)
    4722:	f7ff bfa3 	b.w	466c <TwoWire::isr()>
    4726:	bf00      	nop
    4728:	20001444 	.word	0x20001444

0000472c <lpi2c3_isr()>:
void lpi2c3_isr(void) { Wire1.isr(); }
    472c:	4801      	ldr	r0, [pc, #4]	; (4734 <lpi2c3_isr()+0x8>)
    472e:	f7ff bf9d 	b.w	466c <TwoWire::isr()>
    4732:	bf00      	nop
    4734:	20001584 	.word	0x20001584

00004738 <lpi2c4_isr()>:
void lpi2c4_isr(void) { Wire2.isr(); }
    4738:	4801      	ldr	r0, [pc, #4]	; (4740 <lpi2c4_isr()+0x8>)
    473a:	f7ff bf97 	b.w	466c <TwoWire::isr()>
    473e:	bf00      	nop
    4740:	200016c4 	.word	0x200016c4
    4744:	00000000 	.word	0x00000000

00004748 <cos>:
    4748:	b500      	push	{lr}
    474a:	eeb0 7b40 	vmov.f64	d7, d0
    474e:	ee17 3a90 	vmov	r3, s15
    4752:	4a23      	ldr	r2, [pc, #140]	; (47e0 <cos+0x98>)
    4754:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    4758:	4293      	cmp	r3, r2
    475a:	b085      	sub	sp, #20
    475c:	dd19      	ble.n	4792 <cos+0x4a>
    475e:	4a21      	ldr	r2, [pc, #132]	; (47e4 <cos+0x9c>)
    4760:	4293      	cmp	r3, r2
    4762:	dd04      	ble.n	476e <cos+0x26>
    4764:	ee30 0b40 	vsub.f64	d0, d0, d0
    4768:	b005      	add	sp, #20
    476a:	f85d fb04 	ldr.w	pc, [sp], #4
    476e:	4668      	mov	r0, sp
    4770:	f000 f9d2 	bl	4b18 <__ieee754_rem_pio2>
    4774:	f000 0003 	and.w	r0, r0, #3
    4778:	2801      	cmp	r0, #1
    477a:	d01a      	beq.n	47b2 <cos+0x6a>
    477c:	2802      	cmp	r0, #2
    477e:	d00f      	beq.n	47a0 <cos+0x58>
    4780:	b300      	cbz	r0, 47c4 <cos+0x7c>
    4782:	2001      	movs	r0, #1
    4784:	ed9d 1b02 	vldr	d1, [sp, #8]
    4788:	ed9d 0b00 	vldr	d0, [sp]
    478c:	f000 ffa4 	bl	56d8 <__kernel_sin>
    4790:	e7ea      	b.n	4768 <cos+0x20>
    4792:	ed9f 1b11 	vldr	d1, [pc, #68]	; 47d8 <cos+0x90>
    4796:	f000 fbcf 	bl	4f38 <__kernel_cos>
    479a:	b005      	add	sp, #20
    479c:	f85d fb04 	ldr.w	pc, [sp], #4
    47a0:	ed9d 1b02 	vldr	d1, [sp, #8]
    47a4:	ed9d 0b00 	vldr	d0, [sp]
    47a8:	f000 fbc6 	bl	4f38 <__kernel_cos>
    47ac:	eeb1 0b40 	vneg.f64	d0, d0
    47b0:	e7da      	b.n	4768 <cos+0x20>
    47b2:	ed9d 1b02 	vldr	d1, [sp, #8]
    47b6:	ed9d 0b00 	vldr	d0, [sp]
    47ba:	f000 ff8d 	bl	56d8 <__kernel_sin>
    47be:	eeb1 0b40 	vneg.f64	d0, d0
    47c2:	e7d1      	b.n	4768 <cos+0x20>
    47c4:	ed9d 1b02 	vldr	d1, [sp, #8]
    47c8:	ed9d 0b00 	vldr	d0, [sp]
    47cc:	f000 fbb4 	bl	4f38 <__kernel_cos>
    47d0:	e7ca      	b.n	4768 <cos+0x20>
    47d2:	bf00      	nop
    47d4:	f3af 8000 	nop.w
	...
    47e0:	3fe921fb 	.word	0x3fe921fb
    47e4:	7fefffff 	.word	0x7fefffff

000047e8 <sin>:
    47e8:	b500      	push	{lr}
    47ea:	eeb0 7b40 	vmov.f64	d7, d0
    47ee:	ee17 3a90 	vmov	r3, s15
    47f2:	4a23      	ldr	r2, [pc, #140]	; (4880 <sin+0x98>)
    47f4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    47f8:	4293      	cmp	r3, r2
    47fa:	b085      	sub	sp, #20
    47fc:	dd1a      	ble.n	4834 <sin+0x4c>
    47fe:	4a21      	ldr	r2, [pc, #132]	; (4884 <sin+0x9c>)
    4800:	4293      	cmp	r3, r2
    4802:	dd04      	ble.n	480e <sin+0x26>
    4804:	ee30 0b40 	vsub.f64	d0, d0, d0
    4808:	b005      	add	sp, #20
    480a:	f85d fb04 	ldr.w	pc, [sp], #4
    480e:	4668      	mov	r0, sp
    4810:	f000 f982 	bl	4b18 <__ieee754_rem_pio2>
    4814:	f000 0003 	and.w	r0, r0, #3
    4818:	2801      	cmp	r0, #1
    481a:	d01d      	beq.n	4858 <sin+0x70>
    481c:	2802      	cmp	r0, #2
    481e:	d011      	beq.n	4844 <sin+0x5c>
    4820:	b308      	cbz	r0, 4866 <sin+0x7e>
    4822:	ed9d 1b02 	vldr	d1, [sp, #8]
    4826:	ed9d 0b00 	vldr	d0, [sp]
    482a:	f000 fb85 	bl	4f38 <__kernel_cos>
    482e:	eeb1 0b40 	vneg.f64	d0, d0
    4832:	e7e9      	b.n	4808 <sin+0x20>
    4834:	2000      	movs	r0, #0
    4836:	ed9f 1b10 	vldr	d1, [pc, #64]	; 4878 <sin+0x90>
    483a:	f000 ff4d 	bl	56d8 <__kernel_sin>
    483e:	b005      	add	sp, #20
    4840:	f85d fb04 	ldr.w	pc, [sp], #4
    4844:	2001      	movs	r0, #1
    4846:	ed9d 1b02 	vldr	d1, [sp, #8]
    484a:	ed9d 0b00 	vldr	d0, [sp]
    484e:	f000 ff43 	bl	56d8 <__kernel_sin>
    4852:	eeb1 0b40 	vneg.f64	d0, d0
    4856:	e7d7      	b.n	4808 <sin+0x20>
    4858:	ed9d 1b02 	vldr	d1, [sp, #8]
    485c:	ed9d 0b00 	vldr	d0, [sp]
    4860:	f000 fb6a 	bl	4f38 <__kernel_cos>
    4864:	e7d0      	b.n	4808 <sin+0x20>
    4866:	2001      	movs	r0, #1
    4868:	ed9d 1b02 	vldr	d1, [sp, #8]
    486c:	ed9d 0b00 	vldr	d0, [sp]
    4870:	f000 ff32 	bl	56d8 <__kernel_sin>
    4874:	e7c8      	b.n	4808 <sin+0x20>
    4876:	bf00      	nop
	...
    4880:	3fe921fb 	.word	0x3fe921fb
    4884:	7fefffff 	.word	0x7fefffff

00004888 <atan2>:
    4888:	f000 b856 	b.w	4938 <__ieee754_atan2>
    488c:	0000      	movs	r0, r0
	...

00004890 <sqrt>:
    4890:	b500      	push	{lr}
    4892:	ed2d 8b02 	vpush	{d8}
    4896:	eeb0 8b40 	vmov.f64	d8, d0
    489a:	b08b      	sub	sp, #44	; 0x2c
    489c:	f000 fa8a 	bl	4db4 <__ieee754_sqrt>
    48a0:	4b23      	ldr	r3, [pc, #140]	; (4930 <sqrt+0xa0>)
    48a2:	f993 3000 	ldrsb.w	r3, [r3]
    48a6:	1c5a      	adds	r2, r3, #1
    48a8:	d00b      	beq.n	48c2 <sqrt+0x32>
    48aa:	eeb4 8b48 	vcmp.f64	d8, d8
    48ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    48b2:	d606      	bvs.n	48c2 <sqrt+0x32>
    48b4:	ed9f 7b1c 	vldr	d7, [pc, #112]	; 4928 <sqrt+0x98>
    48b8:	eeb4 8bc7 	vcmpe.f64	d8, d7
    48bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    48c0:	d404      	bmi.n	48cc <sqrt+0x3c>
    48c2:	b00b      	add	sp, #44	; 0x2c
    48c4:	ecbd 8b02 	vpop	{d8}
    48c8:	f85d fb04 	ldr.w	pc, [sp], #4
    48cc:	2201      	movs	r2, #1
    48ce:	4919      	ldr	r1, [pc, #100]	; (4934 <sqrt+0xa4>)
    48d0:	9200      	str	r2, [sp, #0]
    48d2:	2200      	movs	r2, #0
    48d4:	ed8d 8b04 	vstr	d8, [sp, #16]
    48d8:	ed8d 8b02 	vstr	d8, [sp, #8]
    48dc:	9101      	str	r1, [sp, #4]
    48de:	9208      	str	r2, [sp, #32]
    48e0:	b193      	cbz	r3, 4908 <sqrt+0x78>
    48e2:	ee87 6b07 	vdiv.f64	d6, d7, d7
    48e6:	2b02      	cmp	r3, #2
    48e8:	ed8d 6b06 	vstr	d6, [sp, #24]
    48ec:	d10e      	bne.n	490c <sqrt+0x7c>
    48ee:	f001 fb1b 	bl	5f28 <__errno>
    48f2:	2321      	movs	r3, #33	; 0x21
    48f4:	6003      	str	r3, [r0, #0]
    48f6:	9b08      	ldr	r3, [sp, #32]
    48f8:	b973      	cbnz	r3, 4918 <sqrt+0x88>
    48fa:	ed9d 0b06 	vldr	d0, [sp, #24]
    48fe:	b00b      	add	sp, #44	; 0x2c
    4900:	ecbd 8b02 	vpop	{d8}
    4904:	f85d fb04 	ldr.w	pc, [sp], #4
    4908:	ed8d 7b06 	vstr	d7, [sp, #24]
    490c:	4668      	mov	r0, sp
    490e:	f001 f8d3 	bl	5ab8 <matherr>
    4912:	2800      	cmp	r0, #0
    4914:	d1ef      	bne.n	48f6 <sqrt+0x66>
    4916:	e7ea      	b.n	48ee <sqrt+0x5e>
    4918:	f001 fb06 	bl	5f28 <__errno>
    491c:	9b08      	ldr	r3, [sp, #32]
    491e:	6003      	str	r3, [r0, #0]
    4920:	e7eb      	b.n	48fa <sqrt+0x6a>
    4922:	bf00      	nop
    4924:	f3af 8000 	nop.w
	...
    4930:	20001dfe 	.word	0x20001dfe
    4934:	20000ddc 	.word	0x20000ddc

00004938 <__ieee754_atan2>:
    4938:	b5f0      	push	{r4, r5, r6, r7, lr}
    493a:	b085      	sub	sp, #20
    493c:	ed8d 1b02 	vstr	d1, [sp, #8]
    4940:	9a02      	ldr	r2, [sp, #8]
    4942:	9803      	ldr	r0, [sp, #12]
    4944:	4972      	ldr	r1, [pc, #456]	; (4b10 <__ieee754_atan2+0x1d8>)
    4946:	4253      	negs	r3, r2
    4948:	ed8d 0b00 	vstr	d0, [sp]
    494c:	4313      	orrs	r3, r2
    494e:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
    4952:	ea45 73d3 	orr.w	r3, r5, r3, lsr #31
    4956:	428b      	cmp	r3, r1
    4958:	e89d 0090 	ldmia.w	sp, {r4, r7}
    495c:	d842      	bhi.n	49e4 <__ieee754_atan2+0xac>
    495e:	4263      	negs	r3, r4
    4960:	4323      	orrs	r3, r4
    4962:	f027 4e00 	bic.w	lr, r7, #2147483648	; 0x80000000
    4966:	ea4e 73d3 	orr.w	r3, lr, r3, lsr #31
    496a:	428b      	cmp	r3, r1
    496c:	d83a      	bhi.n	49e4 <__ieee754_atan2+0xac>
    496e:	f100 4340 	add.w	r3, r0, #3221225472	; 0xc0000000
    4972:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
    4976:	4313      	orrs	r3, r2
    4978:	d053      	beq.n	4a22 <__ieee754_atan2+0xea>
    497a:	1786      	asrs	r6, r0, #30
    497c:	f006 0602 	and.w	r6, r6, #2
    4980:	ea54 030e 	orrs.w	r3, r4, lr
    4984:	ea46 76d7 	orr.w	r6, r6, r7, lsr #31
    4988:	d034      	beq.n	49f4 <__ieee754_atan2+0xbc>
    498a:	ea52 0305 	orrs.w	r3, r2, r5
    498e:	d03e      	beq.n	4a0e <__ieee754_atan2+0xd6>
    4990:	428d      	cmp	r5, r1
    4992:	d052      	beq.n	4a3a <__ieee754_atan2+0x102>
    4994:	458e      	cmp	lr, r1
    4996:	d03a      	beq.n	4a0e <__ieee754_atan2+0xd6>
    4998:	ebc5 050e 	rsb	r5, r5, lr
    499c:	152d      	asrs	r5, r5, #20
    499e:	2d3c      	cmp	r5, #60	; 0x3c
    49a0:	dc44      	bgt.n	4a2c <__ieee754_atan2+0xf4>
    49a2:	2800      	cmp	r0, #0
    49a4:	db6b      	blt.n	4a7e <__ieee754_atan2+0x146>
    49a6:	e9dd 2300 	ldrd	r2, r3, [sp]
    49aa:	ed9d 0b02 	vldr	d0, [sp, #8]
    49ae:	ec43 2b17 	vmov	d7, r2, r3
    49b2:	ee87 0b00 	vdiv.f64	d0, d7, d0
    49b6:	f000 ffe9 	bl	598c <fabs>
    49ba:	f000 fee5 	bl	5788 <atan>
    49be:	ec53 2b10 	vmov	r2, r3, d0
    49c2:	2e01      	cmp	r6, #1
    49c4:	d056      	beq.n	4a74 <__ieee754_atan2+0x13c>
    49c6:	2e02      	cmp	r6, #2
    49c8:	d049      	beq.n	4a5e <__ieee754_atan2+0x126>
    49ca:	2e00      	cmp	r6, #0
    49cc:	d044      	beq.n	4a58 <__ieee754_atan2+0x120>
    49ce:	ed9f 7b3a 	vldr	d7, [pc, #232]	; 4ab8 <__ieee754_atan2+0x180>
    49d2:	ed9f 6b3b 	vldr	d6, [pc, #236]	; 4ac0 <__ieee754_atan2+0x188>
    49d6:	ec43 2b15 	vmov	d5, r2, r3
    49da:	ee35 7b47 	vsub.f64	d7, d5, d7
    49de:	ee37 0b46 	vsub.f64	d0, d7, d6
    49e2:	e005      	b.n	49f0 <__ieee754_atan2+0xb8>
    49e4:	ed9d 7b02 	vldr	d7, [sp, #8]
    49e8:	ed9d 6b00 	vldr	d6, [sp]
    49ec:	ee37 0b06 	vadd.f64	d0, d7, d6
    49f0:	b005      	add	sp, #20
    49f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    49f4:	2e02      	cmp	r6, #2
    49f6:	d01d      	beq.n	4a34 <__ieee754_atan2+0xfc>
    49f8:	ed9f 0b33 	vldr	d0, [pc, #204]	; 4ac8 <__ieee754_atan2+0x190>
    49fc:	ed9d 7b00 	vldr	d7, [sp]
    4a00:	2e03      	cmp	r6, #3
    4a02:	bf08      	it	eq
    4a04:	eeb0 7b40 	vmoveq.f64	d7, d0
    4a08:	eeb0 0b47 	vmov.f64	d0, d7
    4a0c:	e7f0      	b.n	49f0 <__ieee754_atan2+0xb8>
    4a0e:	ed9f 7b30 	vldr	d7, [pc, #192]	; 4ad0 <__ieee754_atan2+0x198>
    4a12:	ed9f 0b31 	vldr	d0, [pc, #196]	; 4ad8 <__ieee754_atan2+0x1a0>
    4a16:	2f00      	cmp	r7, #0
    4a18:	bfa8      	it	ge
    4a1a:	eeb0 0b47 	vmovge.f64	d0, d7
    4a1e:	b005      	add	sp, #20
    4a20:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4a22:	b005      	add	sp, #20
    4a24:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    4a28:	f000 beae 	b.w	5788 <atan>
    4a2c:	a328      	add	r3, pc, #160	; (adr r3, 4ad0 <__ieee754_atan2+0x198>)
    4a2e:	e9d3 2300 	ldrd	r2, r3, [r3]
    4a32:	e7c6      	b.n	49c2 <__ieee754_atan2+0x8a>
    4a34:	ed9f 0b22 	vldr	d0, [pc, #136]	; 4ac0 <__ieee754_atan2+0x188>
    4a38:	e7da      	b.n	49f0 <__ieee754_atan2+0xb8>
    4a3a:	45ae      	cmp	lr, r5
    4a3c:	d024      	beq.n	4a88 <__ieee754_atan2+0x150>
    4a3e:	2e02      	cmp	r6, #2
    4a40:	d0f8      	beq.n	4a34 <__ieee754_atan2+0xfc>
    4a42:	2e03      	cmp	r6, #3
    4a44:	d02d      	beq.n	4aa2 <__ieee754_atan2+0x16a>
    4a46:	ed9f 7b26 	vldr	d7, [pc, #152]	; 4ae0 <__ieee754_atan2+0x1a8>
    4a4a:	ed9f 0b27 	vldr	d0, [pc, #156]	; 4ae8 <__ieee754_atan2+0x1b0>
    4a4e:	2e01      	cmp	r6, #1
    4a50:	bf08      	it	eq
    4a52:	eeb0 0b47 	vmoveq.f64	d0, d7
    4a56:	e7cb      	b.n	49f0 <__ieee754_atan2+0xb8>
    4a58:	ec43 2b10 	vmov	d0, r2, r3
    4a5c:	e7c8      	b.n	49f0 <__ieee754_atan2+0xb8>
    4a5e:	ed9f 7b16 	vldr	d7, [pc, #88]	; 4ab8 <__ieee754_atan2+0x180>
    4a62:	ed9f 6b17 	vldr	d6, [pc, #92]	; 4ac0 <__ieee754_atan2+0x188>
    4a66:	ec43 2b15 	vmov	d5, r2, r3
    4a6a:	ee35 7b47 	vsub.f64	d7, d5, d7
    4a6e:	ee36 0b47 	vsub.f64	d0, d6, d7
    4a72:	e7bd      	b.n	49f0 <__ieee754_atan2+0xb8>
    4a74:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
    4a78:	ec43 2b10 	vmov	d0, r2, r3
    4a7c:	e7b8      	b.n	49f0 <__ieee754_atan2+0xb8>
    4a7e:	353c      	adds	r5, #60	; 0x3c
    4a80:	da91      	bge.n	49a6 <__ieee754_atan2+0x6e>
    4a82:	2200      	movs	r2, #0
    4a84:	2300      	movs	r3, #0
    4a86:	e79c      	b.n	49c2 <__ieee754_atan2+0x8a>
    4a88:	2e02      	cmp	r6, #2
    4a8a:	d010      	beq.n	4aae <__ieee754_atan2+0x176>
    4a8c:	2e03      	cmp	r6, #3
    4a8e:	d00b      	beq.n	4aa8 <__ieee754_atan2+0x170>
    4a90:	ed9f 7b17 	vldr	d7, [pc, #92]	; 4af0 <__ieee754_atan2+0x1b8>
    4a94:	ed9f 0b18 	vldr	d0, [pc, #96]	; 4af8 <__ieee754_atan2+0x1c0>
    4a98:	2e01      	cmp	r6, #1
    4a9a:	bf08      	it	eq
    4a9c:	eeb0 0b47 	vmoveq.f64	d0, d7
    4aa0:	e7a6      	b.n	49f0 <__ieee754_atan2+0xb8>
    4aa2:	ed9f 0b09 	vldr	d0, [pc, #36]	; 4ac8 <__ieee754_atan2+0x190>
    4aa6:	e7a3      	b.n	49f0 <__ieee754_atan2+0xb8>
    4aa8:	ed9f 0b15 	vldr	d0, [pc, #84]	; 4b00 <__ieee754_atan2+0x1c8>
    4aac:	e7a0      	b.n	49f0 <__ieee754_atan2+0xb8>
    4aae:	ed9f 0b16 	vldr	d0, [pc, #88]	; 4b08 <__ieee754_atan2+0x1d0>
    4ab2:	e79d      	b.n	49f0 <__ieee754_atan2+0xb8>
    4ab4:	f3af 8000 	nop.w
    4ab8:	33145c07 	.word	0x33145c07
    4abc:	3ca1a626 	.word	0x3ca1a626
    4ac0:	54442d18 	.word	0x54442d18
    4ac4:	400921fb 	.word	0x400921fb
    4ac8:	54442d18 	.word	0x54442d18
    4acc:	c00921fb 	.word	0xc00921fb
    4ad0:	54442d18 	.word	0x54442d18
    4ad4:	3ff921fb 	.word	0x3ff921fb
    4ad8:	54442d18 	.word	0x54442d18
    4adc:	bff921fb 	.word	0xbff921fb
    4ae0:	00000000 	.word	0x00000000
    4ae4:	80000000 	.word	0x80000000
	...
    4af0:	54442d18 	.word	0x54442d18
    4af4:	bfe921fb 	.word	0xbfe921fb
    4af8:	54442d18 	.word	0x54442d18
    4afc:	3fe921fb 	.word	0x3fe921fb
    4b00:	7f3321d2 	.word	0x7f3321d2
    4b04:	c002d97c 	.word	0xc002d97c
    4b08:	7f3321d2 	.word	0x7f3321d2
    4b0c:	4002d97c 	.word	0x4002d97c
    4b10:	7ff00000 	.word	0x7ff00000
    4b14:	00000000 	.word	0x00000000

00004b18 <__ieee754_rem_pio2>:
    4b18:	b570      	push	{r4, r5, r6, lr}
    4b1a:	ec53 2b10 	vmov	r2, r3, d0
    4b1e:	499e      	ldr	r1, [pc, #632]	; (4d98 <__ieee754_rem_pio2+0x280>)
    4b20:	f023 4600 	bic.w	r6, r3, #2147483648	; 0x80000000
    4b24:	428e      	cmp	r6, r1
    4b26:	b088      	sub	sp, #32
    4b28:	dd62      	ble.n	4bf0 <__ieee754_rem_pio2+0xd8>
    4b2a:	499c      	ldr	r1, [pc, #624]	; (4d9c <__ieee754_rem_pio2+0x284>)
    4b2c:	428e      	cmp	r6, r1
    4b2e:	461d      	mov	r5, r3
    4b30:	dc1c      	bgt.n	4b6c <__ieee754_rem_pio2+0x54>
    4b32:	2b00      	cmp	r3, #0
    4b34:	ed9f 7b88 	vldr	d7, [pc, #544]	; 4d58 <__ieee754_rem_pio2+0x240>
    4b38:	f340 80df 	ble.w	4cfa <__ieee754_rem_pio2+0x1e2>
    4b3c:	ee30 7b47 	vsub.f64	d7, d0, d7
    4b40:	f5a1 211b 	sub.w	r1, r1, #634880	; 0x9b000
    4b44:	f5a1 61f0 	sub.w	r1, r1, #1920	; 0x780
    4b48:	428e      	cmp	r6, r1
    4b4a:	d063      	beq.n	4c14 <__ieee754_rem_pio2+0xfc>
    4b4c:	ed9f 6b84 	vldr	d6, [pc, #528]	; 4d60 <__ieee754_rem_pio2+0x248>
    4b50:	ee37 5b46 	vsub.f64	d5, d7, d6
    4b54:	ee37 7b45 	vsub.f64	d7, d7, d5
    4b58:	2301      	movs	r3, #1
    4b5a:	ed80 5b00 	vstr	d5, [r0]
    4b5e:	ee37 7b46 	vsub.f64	d7, d7, d6
    4b62:	ed80 7b02 	vstr	d7, [r0, #8]
    4b66:	4618      	mov	r0, r3
    4b68:	b008      	add	sp, #32
    4b6a:	bd70      	pop	{r4, r5, r6, pc}
    4b6c:	498c      	ldr	r1, [pc, #560]	; (4da0 <__ieee754_rem_pio2+0x288>)
    4b6e:	428e      	cmp	r6, r1
    4b70:	4604      	mov	r4, r0
    4b72:	dd56      	ble.n	4c22 <__ieee754_rem_pio2+0x10a>
    4b74:	498b      	ldr	r1, [pc, #556]	; (4da4 <__ieee754_rem_pio2+0x28c>)
    4b76:	428e      	cmp	r6, r1
    4b78:	dc44      	bgt.n	4c04 <__ieee754_rem_pio2+0xec>
    4b7a:	4610      	mov	r0, r2
    4b7c:	1532      	asrs	r2, r6, #20
    4b7e:	f2a2 4216 	subw	r2, r2, #1046	; 0x416
    4b82:	eba6 5102 	sub.w	r1, r6, r2, lsl #20
    4b86:	ec41 0b16 	vmov	d6, r0, r1
    4b8a:	ed9f 7b77 	vldr	d7, [pc, #476]	; 4d68 <__ieee754_rem_pio2+0x250>
    4b8e:	eebd 4bc6 	vcvt.s32.f64	s8, d6
    4b92:	2300      	movs	r3, #0
    4b94:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
    4b98:	ee36 6b44 	vsub.f64	d6, d6, d4
    4b9c:	ee26 6b07 	vmul.f64	d6, d6, d7
    4ba0:	eebd 5bc6 	vcvt.s32.f64	s10, d6
    4ba4:	ed8d 4b02 	vstr	d4, [sp, #8]
    4ba8:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
    4bac:	ee36 6b45 	vsub.f64	d6, d6, d5
    4bb0:	ee26 7b07 	vmul.f64	d7, d6, d7
    4bb4:	eeb5 7b40 	vcmp.f64	d7, #0.0
    4bb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4bbc:	ed8d 5b04 	vstr	d5, [sp, #16]
    4bc0:	ed8d 7b06 	vstr	d7, [sp, #24]
    4bc4:	f040 80bb 	bne.w	4d3e <__ieee754_rem_pio2+0x226>
    4bc8:	eeb5 5b40 	vcmp.f64	d5, #0.0
    4bcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4bd0:	bf0c      	ite	eq
    4bd2:	2301      	moveq	r3, #1
    4bd4:	2302      	movne	r3, #2
    4bd6:	4974      	ldr	r1, [pc, #464]	; (4da8 <__ieee754_rem_pio2+0x290>)
    4bd8:	9101      	str	r1, [sp, #4]
    4bda:	2102      	movs	r1, #2
    4bdc:	9100      	str	r1, [sp, #0]
    4bde:	a802      	add	r0, sp, #8
    4be0:	4621      	mov	r1, r4
    4be2:	f000 fa39 	bl	5058 <__kernel_rem_pio2>
    4be6:	2d00      	cmp	r5, #0
    4be8:	f2c0 809b 	blt.w	4d22 <__ieee754_rem_pio2+0x20a>
    4bec:	4603      	mov	r3, r0
    4bee:	e006      	b.n	4bfe <__ieee754_rem_pio2+0xe6>
    4bf0:	2400      	movs	r4, #0
    4bf2:	2500      	movs	r5, #0
    4bf4:	ed80 0b00 	vstr	d0, [r0]
    4bf8:	e9c0 4502 	strd	r4, r5, [r0, #8]
    4bfc:	2300      	movs	r3, #0
    4bfe:	4618      	mov	r0, r3
    4c00:	b008      	add	sp, #32
    4c02:	bd70      	pop	{r4, r5, r6, pc}
    4c04:	ee30 7b40 	vsub.f64	d7, d0, d0
    4c08:	2300      	movs	r3, #0
    4c0a:	ed80 7b02 	vstr	d7, [r0, #8]
    4c0e:	ed80 7b00 	vstr	d7, [r0]
    4c12:	e7f4      	b.n	4bfe <__ieee754_rem_pio2+0xe6>
    4c14:	ed9f 5b56 	vldr	d5, [pc, #344]	; 4d70 <__ieee754_rem_pio2+0x258>
    4c18:	ed9f 6b57 	vldr	d6, [pc, #348]	; 4d78 <__ieee754_rem_pio2+0x260>
    4c1c:	ee37 7b45 	vsub.f64	d7, d7, d5
    4c20:	e796      	b.n	4b50 <__ieee754_rem_pio2+0x38>
    4c22:	f000 feb3 	bl	598c <fabs>
    4c26:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    4c2a:	ed9f 6b55 	vldr	d6, [pc, #340]	; 4d80 <__ieee754_rem_pio2+0x268>
    4c2e:	eea0 7b06 	vfma.f64	d7, d0, d6
    4c32:	eefd 7bc7 	vcvt.s32.f64	s15, d7
    4c36:	ed9f 3b48 	vldr	d3, [pc, #288]	; 4d58 <__ieee754_rem_pio2+0x240>
    4c3a:	ee17 3a90 	vmov	r3, s15
    4c3e:	ed9f 6b48 	vldr	d6, [pc, #288]	; 4d60 <__ieee754_rem_pio2+0x248>
    4c42:	2b1f      	cmp	r3, #31
    4c44:	eeb8 5be7 	vcvt.f64.s32	d5, s15
    4c48:	eeb1 4b45 	vneg.f64	d4, d5
    4c4c:	ee25 7b06 	vmul.f64	d7, d5, d6
    4c50:	eea4 0b03 	vfma.f64	d0, d4, d3
    4c54:	dc1b      	bgt.n	4c8e <__ieee754_rem_pio2+0x176>
    4c56:	4a55      	ldr	r2, [pc, #340]	; (4dac <__ieee754_rem_pio2+0x294>)
    4c58:	1e59      	subs	r1, r3, #1
    4c5a:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    4c5e:	4296      	cmp	r6, r2
    4c60:	d015      	beq.n	4c8e <__ieee754_rem_pio2+0x176>
    4c62:	ee30 6b47 	vsub.f64	d6, d0, d7
    4c66:	ed84 6b00 	vstr	d6, [r4]
    4c6a:	ee30 0b46 	vsub.f64	d0, d0, d6
    4c6e:	ee30 0b47 	vsub.f64	d0, d0, d7
    4c72:	2d00      	cmp	r5, #0
    4c74:	ed84 0b02 	vstr	d0, [r4, #8]
    4c78:	dac1      	bge.n	4bfe <__ieee754_rem_pio2+0xe6>
    4c7a:	eeb1 6b46 	vneg.f64	d6, d6
    4c7e:	eeb1 0b40 	vneg.f64	d0, d0
    4c82:	ed84 6b00 	vstr	d6, [r4]
    4c86:	ed84 0b02 	vstr	d0, [r4, #8]
    4c8a:	425b      	negs	r3, r3
    4c8c:	e7b7      	b.n	4bfe <__ieee754_rem_pio2+0xe6>
    4c8e:	ee30 6b47 	vsub.f64	d6, d0, d7
    4c92:	ee16 2a90 	vmov	r2, s13
    4c96:	1536      	asrs	r6, r6, #20
    4c98:	f3c2 520a 	ubfx	r2, r2, #20, #11
    4c9c:	1ab2      	subs	r2, r6, r2
    4c9e:	2a10      	cmp	r2, #16
    4ca0:	ed84 6b00 	vstr	d6, [r4]
    4ca4:	dde1      	ble.n	4c6a <__ieee754_rem_pio2+0x152>
    4ca6:	eeb0 3b40 	vmov.f64	d3, d0
    4caa:	ed9f 7b31 	vldr	d7, [pc, #196]	; 4d70 <__ieee754_rem_pio2+0x258>
    4cae:	ed9f 6b32 	vldr	d6, [pc, #200]	; 4d78 <__ieee754_rem_pio2+0x260>
    4cb2:	eea4 3b07 	vfma.f64	d3, d4, d7
    4cb6:	ee30 0b43 	vsub.f64	d0, d0, d3
    4cba:	eea4 0b07 	vfma.f64	d0, d4, d7
    4cbe:	eeb0 7b40 	vmov.f64	d7, d0
    4cc2:	ee95 7b06 	vfnms.f64	d7, d5, d6
    4cc6:	ee33 6b47 	vsub.f64	d6, d3, d7
    4cca:	ee16 2a90 	vmov	r2, s13
    4cce:	f3c2 520a 	ubfx	r2, r2, #20, #11
    4cd2:	1ab6      	subs	r6, r6, r2
    4cd4:	2e31      	cmp	r6, #49	; 0x31
    4cd6:	ed84 6b00 	vstr	d6, [r4]
    4cda:	dd39      	ble.n	4d50 <__ieee754_rem_pio2+0x238>
    4cdc:	eeb0 0b43 	vmov.f64	d0, d3
    4ce0:	ed9f 6b29 	vldr	d6, [pc, #164]	; 4d88 <__ieee754_rem_pio2+0x270>
    4ce4:	ed9f 2b2a 	vldr	d2, [pc, #168]	; 4d90 <__ieee754_rem_pio2+0x278>
    4ce8:	eea4 0b06 	vfma.f64	d0, d4, d6
    4cec:	ee33 7b40 	vsub.f64	d7, d3, d0
    4cf0:	eea4 7b06 	vfma.f64	d7, d4, d6
    4cf4:	ee95 7b02 	vfnms.f64	d7, d5, d2
    4cf8:	e7b3      	b.n	4c62 <__ieee754_rem_pio2+0x14a>
    4cfa:	492d      	ldr	r1, [pc, #180]	; (4db0 <__ieee754_rem_pio2+0x298>)
    4cfc:	ee30 7b07 	vadd.f64	d7, d0, d7
    4d00:	428e      	cmp	r6, r1
    4d02:	d01e      	beq.n	4d42 <__ieee754_rem_pio2+0x22a>
    4d04:	ed9f 6b16 	vldr	d6, [pc, #88]	; 4d60 <__ieee754_rem_pio2+0x248>
    4d08:	ee37 5b06 	vadd.f64	d5, d7, d6
    4d0c:	ee37 7b45 	vsub.f64	d7, d7, d5
    4d10:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4d14:	ee37 7b06 	vadd.f64	d7, d7, d6
    4d18:	ed80 5b00 	vstr	d5, [r0]
    4d1c:	ed80 7b02 	vstr	d7, [r0, #8]
    4d20:	e76d      	b.n	4bfe <__ieee754_rem_pio2+0xe6>
    4d22:	ed94 6b00 	vldr	d6, [r4]
    4d26:	ed94 7b02 	vldr	d7, [r4, #8]
    4d2a:	eeb1 6b46 	vneg.f64	d6, d6
    4d2e:	eeb1 7b47 	vneg.f64	d7, d7
    4d32:	4243      	negs	r3, r0
    4d34:	ed84 6b00 	vstr	d6, [r4]
    4d38:	ed84 7b02 	vstr	d7, [r4, #8]
    4d3c:	e75f      	b.n	4bfe <__ieee754_rem_pio2+0xe6>
    4d3e:	2303      	movs	r3, #3
    4d40:	e749      	b.n	4bd6 <__ieee754_rem_pio2+0xbe>
    4d42:	ed9f 5b0b 	vldr	d5, [pc, #44]	; 4d70 <__ieee754_rem_pio2+0x258>
    4d46:	ed9f 6b0c 	vldr	d6, [pc, #48]	; 4d78 <__ieee754_rem_pio2+0x260>
    4d4a:	ee37 7b05 	vadd.f64	d7, d7, d5
    4d4e:	e7db      	b.n	4d08 <__ieee754_rem_pio2+0x1f0>
    4d50:	eeb0 0b43 	vmov.f64	d0, d3
    4d54:	e789      	b.n	4c6a <__ieee754_rem_pio2+0x152>
    4d56:	bf00      	nop
    4d58:	54400000 	.word	0x54400000
    4d5c:	3ff921fb 	.word	0x3ff921fb
    4d60:	1a626331 	.word	0x1a626331
    4d64:	3dd0b461 	.word	0x3dd0b461
    4d68:	00000000 	.word	0x00000000
    4d6c:	41700000 	.word	0x41700000
    4d70:	1a600000 	.word	0x1a600000
    4d74:	3dd0b461 	.word	0x3dd0b461
    4d78:	2e037073 	.word	0x2e037073
    4d7c:	3ba3198a 	.word	0x3ba3198a
    4d80:	6dc9c883 	.word	0x6dc9c883
    4d84:	3fe45f30 	.word	0x3fe45f30
    4d88:	2e000000 	.word	0x2e000000
    4d8c:	3ba3198a 	.word	0x3ba3198a
    4d90:	252049c1 	.word	0x252049c1
    4d94:	397b839a 	.word	0x397b839a
    4d98:	3fe921fb 	.word	0x3fe921fb
    4d9c:	4002d97b 	.word	0x4002d97b
    4da0:	413921fb 	.word	0x413921fb
    4da4:	7fefffff 	.word	0x7fefffff
    4da8:	20000e48 	.word	0x20000e48
    4dac:	20000a5c 	.word	0x20000a5c
    4db0:	3ff921fb 	.word	0x3ff921fb

00004db4 <__ieee754_sqrt>:
    4db4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4db8:	b082      	sub	sp, #8
    4dba:	ed8d 0b00 	vstr	d0, [sp]
    4dbe:	495d      	ldr	r1, [pc, #372]	; (4f34 <__ieee754_sqrt+0x180>)
    4dc0:	9b01      	ldr	r3, [sp, #4]
    4dc2:	9800      	ldr	r0, [sp, #0]
    4dc4:	460c      	mov	r4, r1
    4dc6:	4019      	ands	r1, r3
    4dc8:	42a1      	cmp	r1, r4
    4dca:	f000 8098 	beq.w	4efe <__ieee754_sqrt+0x14a>
    4dce:	2b00      	cmp	r3, #0
    4dd0:	4602      	mov	r2, r0
    4dd2:	dd77      	ble.n	4ec4 <__ieee754_sqrt+0x110>
    4dd4:	151f      	asrs	r7, r3, #20
    4dd6:	f000 8082 	beq.w	4ede <__ieee754_sqrt+0x12a>
    4dda:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
    4dde:	f3c3 0313 	ubfx	r3, r3, #0, #20
    4de2:	07f9      	lsls	r1, r7, #31
    4de4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    4de8:	d467      	bmi.n	4eba <__ieee754_sqrt+0x106>
    4dea:	eb03 71d2 	add.w	r1, r3, r2, lsr #31
    4dee:	2600      	movs	r6, #0
    4df0:	440b      	add	r3, r1
    4df2:	107f      	asrs	r7, r7, #1
    4df4:	0052      	lsls	r2, r2, #1
    4df6:	46b6      	mov	lr, r6
    4df8:	2016      	movs	r0, #22
    4dfa:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    4dfe:	eb0e 0401 	add.w	r4, lr, r1
    4e02:	429c      	cmp	r4, r3
    4e04:	ea4f 75d2 	mov.w	r5, r2, lsr #31
    4e08:	ea4f 0242 	mov.w	r2, r2, lsl #1
    4e0c:	dc03      	bgt.n	4e16 <__ieee754_sqrt+0x62>
    4e0e:	1b1b      	subs	r3, r3, r4
    4e10:	eb04 0e01 	add.w	lr, r4, r1
    4e14:	440e      	add	r6, r1
    4e16:	3801      	subs	r0, #1
    4e18:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    4e1c:	ea4f 0151 	mov.w	r1, r1, lsr #1
    4e20:	d1ed      	bne.n	4dfe <__ieee754_sqrt+0x4a>
    4e22:	4684      	mov	ip, r0
    4e24:	2420      	movs	r4, #32
    4e26:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    4e2a:	e009      	b.n	4e40 <__ieee754_sqrt+0x8c>
    4e2c:	d020      	beq.n	4e70 <__ieee754_sqrt+0xbc>
    4e2e:	eb03 75d2 	add.w	r5, r3, r2, lsr #31
    4e32:	3c01      	subs	r4, #1
    4e34:	ea4f 0151 	mov.w	r1, r1, lsr #1
    4e38:	442b      	add	r3, r5
    4e3a:	ea4f 0242 	mov.w	r2, r2, lsl #1
    4e3e:	d020      	beq.n	4e82 <__ieee754_sqrt+0xce>
    4e40:	459e      	cmp	lr, r3
    4e42:	eb01 050c 	add.w	r5, r1, ip
    4e46:	daf1      	bge.n	4e2c <__ieee754_sqrt+0x78>
    4e48:	2d00      	cmp	r5, #0
    4e4a:	eb05 0c01 	add.w	ip, r5, r1
    4e4e:	db09      	blt.n	4e64 <__ieee754_sqrt+0xb0>
    4e50:	46f0      	mov	r8, lr
    4e52:	4295      	cmp	r5, r2
    4e54:	ebce 0303 	rsb	r3, lr, r3
    4e58:	d900      	bls.n	4e5c <__ieee754_sqrt+0xa8>
    4e5a:	3b01      	subs	r3, #1
    4e5c:	1b52      	subs	r2, r2, r5
    4e5e:	4408      	add	r0, r1
    4e60:	46c6      	mov	lr, r8
    4e62:	e7e4      	b.n	4e2e <__ieee754_sqrt+0x7a>
    4e64:	f1bc 0f00 	cmp.w	ip, #0
    4e68:	dbf2      	blt.n	4e50 <__ieee754_sqrt+0x9c>
    4e6a:	f10e 0801 	add.w	r8, lr, #1
    4e6e:	e7f0      	b.n	4e52 <__ieee754_sqrt+0x9e>
    4e70:	4295      	cmp	r5, r2
    4e72:	d81a      	bhi.n	4eaa <__ieee754_sqrt+0xf6>
    4e74:	2d00      	cmp	r5, #0
    4e76:	eb05 0c01 	add.w	ip, r5, r1
    4e7a:	db48      	blt.n	4f0e <__ieee754_sqrt+0x15a>
    4e7c:	4698      	mov	r8, r3
    4e7e:	2300      	movs	r3, #0
    4e80:	e7ec      	b.n	4e5c <__ieee754_sqrt+0xa8>
    4e82:	4313      	orrs	r3, r2
    4e84:	d113      	bne.n	4eae <__ieee754_sqrt+0xfa>
    4e86:	0840      	lsrs	r0, r0, #1
    4e88:	1071      	asrs	r1, r6, #1
    4e8a:	07f3      	lsls	r3, r6, #31
    4e8c:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
    4e90:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
    4e94:	bf48      	it	mi
    4e96:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
    4e9a:	eb01 5307 	add.w	r3, r1, r7, lsl #20
    4e9e:	4602      	mov	r2, r0
    4ea0:	ec43 2b10 	vmov	d0, r2, r3
    4ea4:	b002      	add	sp, #8
    4ea6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4eaa:	4673      	mov	r3, lr
    4eac:	e7bf      	b.n	4e2e <__ieee754_sqrt+0x7a>
    4eae:	1c42      	adds	r2, r0, #1
    4eb0:	d031      	beq.n	4f16 <__ieee754_sqrt+0x162>
    4eb2:	f000 0301 	and.w	r3, r0, #1
    4eb6:	4418      	add	r0, r3
    4eb8:	e7e5      	b.n	4e86 <__ieee754_sqrt+0xd2>
    4eba:	005b      	lsls	r3, r3, #1
    4ebc:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
    4ec0:	0052      	lsls	r2, r2, #1
    4ec2:	e792      	b.n	4dea <__ieee754_sqrt+0x36>
    4ec4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    4ec8:	4301      	orrs	r1, r0
    4eca:	d01d      	beq.n	4f08 <__ieee754_sqrt+0x154>
    4ecc:	bb5b      	cbnz	r3, 4f26 <__ieee754_sqrt+0x172>
    4ece:	461f      	mov	r7, r3
    4ed0:	0ad3      	lsrs	r3, r2, #11
    4ed2:	3f15      	subs	r7, #21
    4ed4:	0552      	lsls	r2, r2, #21
    4ed6:	2b00      	cmp	r3, #0
    4ed8:	d0fa      	beq.n	4ed0 <__ieee754_sqrt+0x11c>
    4eda:	02dd      	lsls	r5, r3, #11
    4edc:	d41e      	bmi.n	4f1c <__ieee754_sqrt+0x168>
    4ede:	2100      	movs	r1, #0
    4ee0:	e000      	b.n	4ee4 <__ieee754_sqrt+0x130>
    4ee2:	4601      	mov	r1, r0
    4ee4:	005b      	lsls	r3, r3, #1
    4ee6:	02dc      	lsls	r4, r3, #11
    4ee8:	f101 0001 	add.w	r0, r1, #1
    4eec:	d5f9      	bpl.n	4ee2 <__ieee754_sqrt+0x12e>
    4eee:	f1c0 0420 	rsb	r4, r0, #32
    4ef2:	fa22 f404 	lsr.w	r4, r2, r4
    4ef6:	4323      	orrs	r3, r4
    4ef8:	1a7f      	subs	r7, r7, r1
    4efa:	4082      	lsls	r2, r0
    4efc:	e76d      	b.n	4dda <__ieee754_sqrt+0x26>
    4efe:	eea0 0b00 	vfma.f64	d0, d0, d0
    4f02:	b002      	add	sp, #8
    4f04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4f08:	ed9d 0b00 	vldr	d0, [sp]
    4f0c:	e7ca      	b.n	4ea4 <__ieee754_sqrt+0xf0>
    4f0e:	f1bc 0f00 	cmp.w	ip, #0
    4f12:	daaa      	bge.n	4e6a <__ieee754_sqrt+0xb6>
    4f14:	e7b2      	b.n	4e7c <__ieee754_sqrt+0xc8>
    4f16:	3601      	adds	r6, #1
    4f18:	4620      	mov	r0, r4
    4f1a:	e7b5      	b.n	4e88 <__ieee754_sqrt+0xd4>
    4f1c:	2420      	movs	r4, #32
    4f1e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4f22:	2000      	movs	r0, #0
    4f24:	e7e5      	b.n	4ef2 <__ieee754_sqrt+0x13e>
    4f26:	ed9d 7b00 	vldr	d7, [sp]
    4f2a:	ee37 7b47 	vsub.f64	d7, d7, d7
    4f2e:	ee87 0b07 	vdiv.f64	d0, d7, d7
    4f32:	e7b7      	b.n	4ea4 <__ieee754_sqrt+0xf0>
    4f34:	7ff00000 	.word	0x7ff00000

00004f38 <__kernel_cos>:
    4f38:	ee10 3a90 	vmov	r3, s1
    4f3c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    4f40:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
    4f44:	da2c      	bge.n	4fa0 <__kernel_cos+0x68>
    4f46:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    4f4a:	ee17 3a90 	vmov	r3, s15
    4f4e:	2b00      	cmp	r3, #0
    4f50:	d061      	beq.n	5016 <__kernel_cos+0xde>
    4f52:	ee20 7b00 	vmul.f64	d7, d0, d0
    4f56:	ed9f 4b32 	vldr	d4, [pc, #200]	; 5020 <__kernel_cos+0xe8>
    4f5a:	ed9f 5b33 	vldr	d5, [pc, #204]	; 5028 <__kernel_cos+0xf0>
    4f5e:	ed9f 6b34 	vldr	d6, [pc, #208]	; 5030 <__kernel_cos+0xf8>
    4f62:	eea7 5b04 	vfma.f64	d5, d7, d4
    4f66:	ed9f 4b34 	vldr	d4, [pc, #208]	; 5038 <__kernel_cos+0x100>
    4f6a:	eea7 6b05 	vfma.f64	d6, d7, d5
    4f6e:	ed9f 5b34 	vldr	d5, [pc, #208]	; 5040 <__kernel_cos+0x108>
    4f72:	eea7 4b06 	vfma.f64	d4, d7, d6
    4f76:	ed9f 6b34 	vldr	d6, [pc, #208]	; 5048 <__kernel_cos+0x110>
    4f7a:	eea7 5b04 	vfma.f64	d5, d7, d4
    4f7e:	eea7 6b05 	vfma.f64	d6, d7, d5
    4f82:	ee26 6b07 	vmul.f64	d6, d6, d7
    4f86:	ee21 0b40 	vnmul.f64	d0, d1, d0
    4f8a:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
    4f8e:	eea7 0b06 	vfma.f64	d0, d7, d6
    4f92:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    4f96:	ee97 0b05 	vfnms.f64	d0, d7, d5
    4f9a:	ee36 0b40 	vsub.f64	d0, d6, d0
    4f9e:	4770      	bx	lr
    4fa0:	ed9f 4b1f 	vldr	d4, [pc, #124]	; 5020 <__kernel_cos+0xe8>
    4fa4:	ee20 7b00 	vmul.f64	d7, d0, d0
    4fa8:	ed9f 5b1f 	vldr	d5, [pc, #124]	; 5028 <__kernel_cos+0xf0>
    4fac:	ed9f 6b20 	vldr	d6, [pc, #128]	; 5030 <__kernel_cos+0xf8>
    4fb0:	eea7 5b04 	vfma.f64	d5, d7, d4
    4fb4:	ed9f 4b20 	vldr	d4, [pc, #128]	; 5038 <__kernel_cos+0x100>
    4fb8:	eea7 6b05 	vfma.f64	d6, d7, d5
    4fbc:	4a24      	ldr	r2, [pc, #144]	; (5050 <__kernel_cos+0x118>)
    4fbe:	eea7 4b06 	vfma.f64	d4, d7, d6
    4fc2:	ed9f 5b1f 	vldr	d5, [pc, #124]	; 5040 <__kernel_cos+0x108>
    4fc6:	ed9f 6b20 	vldr	d6, [pc, #128]	; 5048 <__kernel_cos+0x110>
    4fca:	eea7 5b04 	vfma.f64	d5, d7, d4
    4fce:	4293      	cmp	r3, r2
    4fd0:	eea7 6b05 	vfma.f64	d6, d7, d5
    4fd4:	ee26 6b07 	vmul.f64	d6, d6, d7
    4fd8:	ddd5      	ble.n	4f86 <__kernel_cos+0x4e>
    4fda:	4a1e      	ldr	r2, [pc, #120]	; (5054 <__kernel_cos+0x11c>)
    4fdc:	4293      	cmp	r3, r2
    4fde:	dc15      	bgt.n	500c <__kernel_cos+0xd4>
    4fe0:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
    4fe4:	2000      	movs	r0, #0
    4fe6:	f5a3 1100 	sub.w	r1, r3, #2097152	; 0x200000
    4fea:	ec41 0b15 	vmov	d5, r0, r1
    4fee:	ee34 4b45 	vsub.f64	d4, d4, d5
    4ff2:	ee21 1b40 	vnmul.f64	d1, d1, d0
    4ff6:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    4ffa:	eea7 1b06 	vfma.f64	d1, d7, d6
    4ffe:	ee97 5b03 	vfnms.f64	d5, d7, d3
    5002:	ee35 5b41 	vsub.f64	d5, d5, d1
    5006:	ee34 0b45 	vsub.f64	d0, d4, d5
    500a:	4770      	bx	lr
    500c:	eeb6 4b07 	vmov.f64	d4, #103	; 0x3f380000  0.7187500
    5010:	eeb5 5b02 	vmov.f64	d5, #82	; 0x3e900000  0.2812500
    5014:	e7ed      	b.n	4ff2 <__kernel_cos+0xba>
    5016:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    501a:	4770      	bx	lr
    501c:	f3af 8000 	nop.w
    5020:	be8838d4 	.word	0xbe8838d4
    5024:	bda8fae9 	.word	0xbda8fae9
    5028:	bdb4b1c4 	.word	0xbdb4b1c4
    502c:	3e21ee9e 	.word	0x3e21ee9e
    5030:	809c52ad 	.word	0x809c52ad
    5034:	be927e4f 	.word	0xbe927e4f
    5038:	19cb1590 	.word	0x19cb1590
    503c:	3efa01a0 	.word	0x3efa01a0
    5040:	16c15177 	.word	0x16c15177
    5044:	bf56c16c 	.word	0xbf56c16c
    5048:	5555554c 	.word	0x5555554c
    504c:	3fa55555 	.word	0x3fa55555
    5050:	3fd33332 	.word	0x3fd33332
    5054:	3fe90000 	.word	0x3fe90000

00005058 <__kernel_rem_pio2>:
    5058:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    505c:	ed2d 8b08 	vpush	{d8-d11}
    5060:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
    5064:	4cb0      	ldr	r4, [pc, #704]	; (5328 <__kernel_rem_pio2+0x2d0>)
    5066:	9ea4      	ldr	r6, [sp, #656]	; 0x290
    5068:	4db0      	ldr	r5, [pc, #704]	; (532c <__kernel_rem_pio2+0x2d4>)
    506a:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
    506e:	9301      	str	r3, [sp, #4]
    5070:	1ed4      	subs	r4, r2, #3
    5072:	fb85 7504 	smull	r7, r5, r5, r4
    5076:	17e4      	asrs	r4, r4, #31
    5078:	ebc4 04a5 	rsb	r4, r4, r5, asr #2
    507c:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
    5080:	1e5f      	subs	r7, r3, #1
    5082:	f104 0a01 	add.w	sl, r4, #1
    5086:	ebaa 0a8a 	sub.w	sl, sl, sl, lsl #2
    508a:	468b      	mov	fp, r1
    508c:	19f1      	adds	r1, r6, r7
    508e:	9402      	str	r4, [sp, #8]
    5090:	4681      	mov	r9, r0
    5092:	eb02 0aca 	add.w	sl, r2, sl, lsl #3
    5096:	eba4 0307 	sub.w	r3, r4, r7
    509a:	d418      	bmi.n	50ce <__kernel_rem_pio2+0x76>
    509c:	4419      	add	r1, r3
    509e:	3101      	adds	r1, #1
    50a0:	aa1a      	add	r2, sp, #104	; 0x68
    50a2:	98a5      	ldr	r0, [sp, #660]	; 0x294
    50a4:	e00a      	b.n	50bc <__kernel_rem_pio2+0x64>
    50a6:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    50aa:	ee07 4a90 	vmov	s15, r4
    50ae:	3301      	adds	r3, #1
    50b0:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    50b4:	428b      	cmp	r3, r1
    50b6:	eca2 7b02 	vstmia	r2!, {d7}
    50ba:	d008      	beq.n	50ce <__kernel_rem_pio2+0x76>
    50bc:	2b00      	cmp	r3, #0
    50be:	daf2      	bge.n	50a6 <__kernel_rem_pio2+0x4e>
    50c0:	ed9f 7b93 	vldr	d7, [pc, #588]	; 5310 <__kernel_rem_pio2+0x2b8>
    50c4:	3301      	adds	r3, #1
    50c6:	428b      	cmp	r3, r1
    50c8:	eca2 7b02 	vstmia	r2!, {d7}
    50cc:	d1f6      	bne.n	50bc <__kernel_rem_pio2+0x64>
    50ce:	2e00      	cmp	r6, #0
    50d0:	f2c0 82e2 	blt.w	5698 <__kernel_rem_pio2+0x640>
    50d4:	9b01      	ldr	r3, [sp, #4]
    50d6:	a86a      	add	r0, sp, #424	; 0x1a8
    50d8:	f106 0e01 	add.w	lr, r6, #1
    50dc:	00dc      	lsls	r4, r3, #3
    50de:	eb00 0ece 	add.w	lr, r0, lr, lsl #3
    50e2:	eb09 0104 	add.w	r1, r9, r4
    50e6:	463d      	mov	r5, r7
    50e8:	2f00      	cmp	r7, #0
    50ea:	f2c0 81c8 	blt.w	547e <__kernel_rem_pio2+0x426>
    50ee:	ab1a      	add	r3, sp, #104	; 0x68
    50f0:	ed9f 7b87 	vldr	d7, [pc, #540]	; 5310 <__kernel_rem_pio2+0x2b8>
    50f4:	eb03 02c5 	add.w	r2, r3, r5, lsl #3
    50f8:	3208      	adds	r2, #8
    50fa:	464b      	mov	r3, r9
    50fc:	ecb3 5b02 	vldmia	r3!, {d5}
    5100:	ed32 6b02 	vldmdb	r2!, {d6}
    5104:	428b      	cmp	r3, r1
    5106:	eea5 7b06 	vfma.f64	d7, d5, d6
    510a:	d1f7      	bne.n	50fc <__kernel_rem_pio2+0xa4>
    510c:	eca0 7b02 	vstmia	r0!, {d7}
    5110:	4570      	cmp	r0, lr
    5112:	f105 0501 	add.w	r5, r5, #1
    5116:	d1e7      	bne.n	50e8 <__kernel_rem_pio2+0x90>
    5118:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
    511c:	3b02      	subs	r3, #2
    511e:	009b      	lsls	r3, r3, #2
    5120:	aa06      	add	r2, sp, #24
    5122:	ed9f 9b7d 	vldr	d9, [pc, #500]	; 5318 <__kernel_rem_pio2+0x2c0>
    5126:	ed9f 8b7e 	vldr	d8, [pc, #504]	; 5320 <__kernel_rem_pio2+0x2c8>
    512a:	f103 0804 	add.w	r8, r3, #4
    512e:	4413      	add	r3, r2
    5130:	444c      	add	r4, r9
    5132:	4490      	add	r8, r2
    5134:	9303      	str	r3, [sp, #12]
    5136:	4635      	mov	r5, r6
    5138:	f8cd b010 	str.w	fp, [sp, #16]
    513c:	ab92      	add	r3, sp, #584	; 0x248
    513e:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    5142:	2d00      	cmp	r5, #0
    5144:	ed13 0b28 	vldr	d0, [r3, #-160]	; 0xffffff60
    5148:	dd17      	ble.n	517a <__kernel_rem_pio2+0x122>
    514a:	a96a      	add	r1, sp, #424	; 0x1a8
    514c:	eb01 03c5 	add.w	r3, r1, r5, lsl #3
    5150:	aa05      	add	r2, sp, #20
    5152:	ee20 7b09 	vmul.f64	d7, d0, d9
    5156:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    515a:	ed33 6b02 	vldmdb	r3!, {d6}
    515e:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    5162:	eea7 0b48 	vfms.f64	d0, d7, d8
    5166:	eefd 5bc0 	vcvt.s32.f64	s11, d0
    516a:	428b      	cmp	r3, r1
    516c:	ee15 0a90 	vmov	r0, s11
    5170:	ee37 0b06 	vadd.f64	d0, d7, d6
    5174:	f842 0f04 	str.w	r0, [r2, #4]!
    5178:	d1eb      	bne.n	5152 <__kernel_rem_pio2+0xfa>
    517a:	4650      	mov	r0, sl
    517c:	f000 fca0 	bl	5ac0 <scalbn>
    5180:	eeb0 ab40 	vmov.f64	d10, d0
    5184:	eeb4 0b00 	vmov.f64	d0, #64	; 0x3e000000  0.125
    5188:	ee2a 0b00 	vmul.f64	d0, d10, d0
    518c:	f000 fc08 	bl	59a0 <floor>
    5190:	eeb2 7b00 	vmov.f64	d7, #32	; 0x41000000  8.0
    5194:	eea0 ab47 	vfms.f64	d10, d0, d7
    5198:	eefd 7bca 	vcvt.s32.f64	s15, d10
    519c:	f1ba 0f00 	cmp.w	sl, #0
    51a0:	ee17 ba90 	vmov	fp, s15
    51a4:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    51a8:	ee3a ab47 	vsub.f64	d10, d10, d7
    51ac:	f340 814c 	ble.w	5448 <__kernel_rem_pio2+0x3f0>
    51b0:	f105 3eff 	add.w	lr, r5, #4294967295	; 0xffffffff
    51b4:	ab06      	add	r3, sp, #24
    51b6:	f1ca 0218 	rsb	r2, sl, #24
    51ba:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
    51be:	fa43 f002 	asr.w	r0, r3, r2
    51c2:	fa00 f202 	lsl.w	r2, r0, r2
    51c6:	a906      	add	r1, sp, #24
    51c8:	1a9b      	subs	r3, r3, r2
    51ca:	f1ca 0217 	rsb	r2, sl, #23
    51ce:	f841 302e 	str.w	r3, [r1, lr, lsl #2]
    51d2:	4483      	add	fp, r0
    51d4:	fa43 f102 	asr.w	r1, r3, r2
    51d8:	2900      	cmp	r1, #0
    51da:	dd39      	ble.n	5250 <__kernel_rem_pio2+0x1f8>
    51dc:	2d00      	cmp	r5, #0
    51de:	f10b 0b01 	add.w	fp, fp, #1
    51e2:	f340 8224 	ble.w	562e <__kernel_rem_pio2+0x5d6>
    51e6:	2200      	movs	r2, #0
    51e8:	4610      	mov	r0, r2
    51ea:	f10d 0e14 	add.w	lr, sp, #20
    51ee:	468c      	mov	ip, r1
    51f0:	e008      	b.n	5204 <__kernel_rem_pio2+0x1ac>
    51f2:	f1c3 7180 	rsb	r1, r3, #16777216	; 0x1000000
    51f6:	b113      	cbz	r3, 51fe <__kernel_rem_pio2+0x1a6>
    51f8:	f8ce 1000 	str.w	r1, [lr]
    51fc:	2001      	movs	r0, #1
    51fe:	3201      	adds	r2, #1
    5200:	4295      	cmp	r5, r2
    5202:	dd0e      	ble.n	5222 <__kernel_rem_pio2+0x1ca>
    5204:	f85e 3f04 	ldr.w	r3, [lr, #4]!
    5208:	2800      	cmp	r0, #0
    520a:	d0f2      	beq.n	51f2 <__kernel_rem_pio2+0x19a>
    520c:	f1c3 13ff 	rsb	r3, r3, #16711935	; 0xff00ff
    5210:	3201      	adds	r2, #1
    5212:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    5216:	4295      	cmp	r5, r2
    5218:	f8ce 3000 	str.w	r3, [lr]
    521c:	f04f 0001 	mov.w	r0, #1
    5220:	dcf0      	bgt.n	5204 <__kernel_rem_pio2+0x1ac>
    5222:	4661      	mov	r1, ip
    5224:	f1ba 0f00 	cmp.w	sl, #0
    5228:	dd10      	ble.n	524c <__kernel_rem_pio2+0x1f4>
    522a:	f1ba 0f01 	cmp.w	sl, #1
    522e:	f000 8112 	beq.w	5456 <__kernel_rem_pio2+0x3fe>
    5232:	f1ba 0f02 	cmp.w	sl, #2
    5236:	d109      	bne.n	524c <__kernel_rem_pio2+0x1f4>
    5238:	1e6a      	subs	r2, r5, #1
    523a:	ab06      	add	r3, sp, #24
    523c:	f10d 0e18 	add.w	lr, sp, #24
    5240:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5244:	f3c3 0315 	ubfx	r3, r3, #0, #22
    5248:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    524c:	2902      	cmp	r1, #2
    524e:	d06f      	beq.n	5330 <__kernel_rem_pio2+0x2d8>
    5250:	eeb5 ab40 	vcmp.f64	d10, #0.0
    5254:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5258:	d17c      	bne.n	5354 <__kernel_rem_pio2+0x2fc>
    525a:	f105 3eff 	add.w	lr, r5, #4294967295	; 0xffffffff
    525e:	4576      	cmp	r6, lr
    5260:	dc0f      	bgt.n	5282 <__kernel_rem_pio2+0x22a>
    5262:	f105 4280 	add.w	r2, r5, #1073741824	; 0x40000000
    5266:	3a01      	subs	r2, #1
    5268:	ab06      	add	r3, sp, #24
    526a:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    526e:	2000      	movs	r0, #0
    5270:	f852 3904 	ldr.w	r3, [r2], #-4
    5274:	4542      	cmp	r2, r8
    5276:	ea40 0003 	orr.w	r0, r0, r3
    527a:	d1f9      	bne.n	5270 <__kernel_rem_pio2+0x218>
    527c:	2800      	cmp	r0, #0
    527e:	f040 8115 	bne.w	54ac <__kernel_rem_pio2+0x454>
    5282:	1e73      	subs	r3, r6, #1
    5284:	aa06      	add	r2, sp, #24
    5286:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    528a:	2b00      	cmp	r3, #0
    528c:	f040 81cc 	bne.w	5628 <__kernel_rem_pio2+0x5d0>
    5290:	9b03      	ldr	r3, [sp, #12]
    5292:	f04f 0e01 	mov.w	lr, #1
    5296:	f853 2904 	ldr.w	r2, [r3], #-4
    529a:	f10e 0e01 	add.w	lr, lr, #1
    529e:	2a00      	cmp	r2, #0
    52a0:	d0f9      	beq.n	5296 <__kernel_rem_pio2+0x23e>
    52a2:	44ae      	add	lr, r5
    52a4:	1c6b      	adds	r3, r5, #1
    52a6:	4573      	cmp	r3, lr
    52a8:	dc2d      	bgt.n	5306 <__kernel_rem_pio2+0x2ae>
    52aa:	9a02      	ldr	r2, [sp, #8]
    52ac:	1898      	adds	r0, r3, r2
    52ae:	9a01      	ldr	r2, [sp, #4]
    52b0:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    52b4:	1951      	adds	r1, r2, r5
    52b6:	eb0e 0c02 	add.w	ip, lr, r2
    52ba:	9aa5      	ldr	r2, [sp, #660]	; 0x294
    52bc:	3801      	subs	r0, #1
    52be:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    52c2:	aa1a      	add	r2, sp, #104	; 0x68
    52c4:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
    52c8:	eb02 0ccc 	add.w	ip, r2, ip, lsl #3
    52cc:	aa6a      	add	r2, sp, #424	; 0x1a8
    52ce:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
    52d2:	f850 3f04 	ldr.w	r3, [r0, #4]!
    52d6:	ee07 3a10 	vmov	s14, r3
    52da:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    52de:	2f00      	cmp	r7, #0
    52e0:	eca1 7b02 	vstmia	r1!, {d7}
    52e4:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 5310 <__kernel_rem_pio2+0x2b8>
    52e8:	db09      	blt.n	52fe <__kernel_rem_pio2+0x2a6>
    52ea:	464b      	mov	r3, r9
    52ec:	460a      	mov	r2, r1
    52ee:	ecb3 5b02 	vldmia	r3!, {d5}
    52f2:	ed32 6b02 	vldmdb	r2!, {d6}
    52f6:	42a3      	cmp	r3, r4
    52f8:	eea5 7b06 	vfma.f64	d7, d5, d6
    52fc:	d1f7      	bne.n	52ee <__kernel_rem_pio2+0x296>
    52fe:	4561      	cmp	r1, ip
    5300:	eca5 7b02 	vstmia	r5!, {d7}
    5304:	d1e5      	bne.n	52d2 <__kernel_rem_pio2+0x27a>
    5306:	4675      	mov	r5, lr
    5308:	e718      	b.n	513c <__kernel_rem_pio2+0xe4>
    530a:	bf00      	nop
    530c:	f3af 8000 	nop.w
	...
    531c:	3e700000 	.word	0x3e700000
    5320:	00000000 	.word	0x00000000
    5324:	41700000 	.word	0x41700000
    5328:	20000a4c 	.word	0x20000a4c
    532c:	2aaaaaab 	.word	0x2aaaaaab
    5330:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    5334:	ee30 ab4a 	vsub.f64	d10, d0, d10
    5338:	2800      	cmp	r0, #0
    533a:	d089      	beq.n	5250 <__kernel_rem_pio2+0x1f8>
    533c:	4650      	mov	r0, sl
    533e:	9105      	str	r1, [sp, #20]
    5340:	f000 fbbe 	bl	5ac0 <scalbn>
    5344:	ee3a ab40 	vsub.f64	d10, d10, d0
    5348:	eeb5 ab40 	vcmp.f64	d10, #0.0
    534c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5350:	9905      	ldr	r1, [sp, #20]
    5352:	d082      	beq.n	525a <__kernel_rem_pio2+0x202>
    5354:	eeb0 0b4a 	vmov.f64	d0, d10
    5358:	f1ca 0000 	rsb	r0, sl, #0
    535c:	ee0b ba10 	vmov	s22, fp
    5360:	4689      	mov	r9, r1
    5362:	f8dd b010 	ldr.w	fp, [sp, #16]
    5366:	f000 fbab 	bl	5ac0 <scalbn>
    536a:	ed9f 6bd1 	vldr	d6, [pc, #836]	; 56b0 <__kernel_rem_pio2+0x658>
    536e:	eeb4 0bc6 	vcmpe.f64	d0, d6
    5372:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5376:	f2c0 8172 	blt.w	565e <__kernel_rem_pio2+0x606>
    537a:	ed9f 7bcf 	vldr	d7, [pc, #828]	; 56b8 <__kernel_rem_pio2+0x660>
    537e:	ee20 7b07 	vmul.f64	d7, d0, d7
    5382:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    5386:	a906      	add	r1, sp, #24
    5388:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
    538c:	eea5 0b46 	vfms.f64	d0, d5, d6
    5390:	eebd 0bc0 	vcvt.s32.f64	s0, d0
    5394:	1c6b      	adds	r3, r5, #1
    5396:	ee10 2a10 	vmov	r2, s0
    539a:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    539e:	ee17 2a10 	vmov	r2, s14
    53a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    53a6:	f10a 0a18 	add.w	sl, sl, #24
    53aa:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    53ae:	4650      	mov	r0, sl
    53b0:	9301      	str	r3, [sp, #4]
    53b2:	f000 fb85 	bl	5ac0 <scalbn>
    53b6:	9b01      	ldr	r3, [sp, #4]
    53b8:	2b00      	cmp	r3, #0
    53ba:	f2c0 815e 	blt.w	567a <__kernel_rem_pio2+0x622>
    53be:	ac6a      	add	r4, sp, #424	; 0x1a8
    53c0:	00df      	lsls	r7, r3, #3
    53c2:	aa06      	add	r2, sp, #24
    53c4:	ed9f 6bbc 	vldr	d6, [pc, #752]	; 56b8 <__kernel_rem_pio2+0x660>
    53c8:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    53cc:	eb04 0c07 	add.w	ip, r4, r7
    53d0:	3204      	adds	r2, #4
    53d2:	f10c 0008 	add.w	r0, ip, #8
    53d6:	ed32 7a01 	vldmdb	r2!, {s14}
    53da:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    53de:	ee27 7b00 	vmul.f64	d7, d7, d0
    53e2:	ed20 7b02 	vstmdb	r0!, {d7}
    53e6:	ee20 0b06 	vmul.f64	d0, d0, d6
    53ea:	42a0      	cmp	r0, r4
    53ec:	d1f3      	bne.n	53d6 <__kernel_rem_pio2+0x37e>
    53ee:	f50d 78d0 	add.w	r8, sp, #416	; 0x1a0
    53f2:	2500      	movs	r5, #0
    53f4:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    53f8:	2e00      	cmp	r6, #0
    53fa:	f2c0 8112 	blt.w	5622 <__kernel_rem_pio2+0x5ca>
    53fe:	48b4      	ldr	r0, [pc, #720]	; (56d0 <__kernel_rem_pio2+0x678>)
    5400:	4661      	mov	r1, ip
    5402:	ed9f 6baf 	vldr	d6, [pc, #700]	; 56c0 <__kernel_rem_pio2+0x668>
    5406:	ed9f 7bb0 	vldr	d7, [pc, #704]	; 56c8 <__kernel_rem_pio2+0x670>
    540a:	2200      	movs	r2, #0
    540c:	e003      	b.n	5416 <__kernel_rem_pio2+0x3be>
    540e:	4295      	cmp	r5, r2
    5410:	db08      	blt.n	5424 <__kernel_rem_pio2+0x3cc>
    5412:	ecb0 6b02 	vldmia	r0!, {d6}
    5416:	ecb1 5b02 	vldmia	r1!, {d5}
    541a:	3201      	adds	r2, #1
    541c:	4296      	cmp	r6, r2
    541e:	eea5 7b06 	vfma.f64	d7, d5, d6
    5422:	daf4      	bge.n	540e <__kernel_rem_pio2+0x3b6>
    5424:	f1ac 0c08 	sub.w	ip, ip, #8
    5428:	eb0e 02c5 	add.w	r2, lr, r5, lsl #3
    542c:	45c4      	cmp	ip, r8
    542e:	ed82 7b00 	vstr	d7, [r2]
    5432:	f105 0501 	add.w	r5, r5, #1
    5436:	d1df      	bne.n	53f8 <__kernel_rem_pio2+0x3a0>
    5438:	9aa4      	ldr	r2, [sp, #656]	; 0x290
    543a:	2a03      	cmp	r2, #3
    543c:	f200 80ad 	bhi.w	559a <__kernel_rem_pio2+0x542>
    5440:	e8df f002 	tbb	[pc, r2]
    5444:	50b5b5dd 	.word	0x50b5b5dd
    5448:	d110      	bne.n	546c <__kernel_rem_pio2+0x414>
    544a:	1e6b      	subs	r3, r5, #1
    544c:	aa06      	add	r2, sp, #24
    544e:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    5452:	15c9      	asrs	r1, r1, #23
    5454:	e6c0      	b.n	51d8 <__kernel_rem_pio2+0x180>
    5456:	1e6a      	subs	r2, r5, #1
    5458:	ab06      	add	r3, sp, #24
    545a:	f10d 0e18 	add.w	lr, sp, #24
    545e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5462:	f3c3 0316 	ubfx	r3, r3, #0, #23
    5466:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    546a:	e6ef      	b.n	524c <__kernel_rem_pio2+0x1f4>
    546c:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    5470:	eeb4 abc7 	vcmpe.f64	d10, d7
    5474:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5478:	da0b      	bge.n	5492 <__kernel_rem_pio2+0x43a>
    547a:	2100      	movs	r1, #0
    547c:	e6e8      	b.n	5250 <__kernel_rem_pio2+0x1f8>
    547e:	ed9f 7b92 	vldr	d7, [pc, #584]	; 56c8 <__kernel_rem_pio2+0x670>
    5482:	eca0 7b02 	vstmia	r0!, {d7}
    5486:	4570      	cmp	r0, lr
    5488:	f105 0501 	add.w	r5, r5, #1
    548c:	f47f ae2c 	bne.w	50e8 <__kernel_rem_pio2+0x90>
    5490:	e642      	b.n	5118 <__kernel_rem_pio2+0xc0>
    5492:	2d00      	cmp	r5, #0
    5494:	f10b 0b01 	add.w	fp, fp, #1
    5498:	bfc8      	it	gt
    549a:	2102      	movgt	r1, #2
    549c:	f73f aea3 	bgt.w	51e6 <__kernel_rem_pio2+0x18e>
    54a0:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    54a4:	2102      	movs	r1, #2
    54a6:	ee37 ab4a 	vsub.f64	d10, d7, d10
    54aa:	e6d1      	b.n	5250 <__kernel_rem_pio2+0x1f8>
    54ac:	aa06      	add	r2, sp, #24
    54ae:	ee0b ba10 	vmov	s22, fp
    54b2:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
    54b6:	f8dd b010 	ldr.w	fp, [sp, #16]
    54ba:	4673      	mov	r3, lr
    54bc:	4689      	mov	r9, r1
    54be:	f1aa 0a18 	sub.w	sl, sl, #24
    54c2:	2a00      	cmp	r2, #0
    54c4:	f47f af71 	bne.w	53aa <__kernel_rem_pio2+0x352>
    54c8:	f10e 4280 	add.w	r2, lr, #1073741824	; 0x40000000
    54cc:	3a01      	subs	r2, #1
    54ce:	a906      	add	r1, sp, #24
    54d0:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    54d4:	f852 1904 	ldr.w	r1, [r2], #-4
    54d8:	3b01      	subs	r3, #1
    54da:	f1aa 0a18 	sub.w	sl, sl, #24
    54de:	2900      	cmp	r1, #0
    54e0:	d0f8      	beq.n	54d4 <__kernel_rem_pio2+0x47c>
    54e2:	e762      	b.n	53aa <__kernel_rem_pio2+0x352>
    54e4:	2b00      	cmp	r3, #0
    54e6:	f340 80c5 	ble.w	5674 <__kernel_rem_pio2+0x61c>
    54ea:	f103 5200 	add.w	r2, r3, #536870912	; 0x20000000
    54ee:	3a01      	subs	r2, #1
    54f0:	eb0e 0407 	add.w	r4, lr, r7
    54f4:	00d0      	lsls	r0, r2, #3
    54f6:	ed94 7b00 	vldr	d7, [r4]
    54fa:	f100 0408 	add.w	r4, r0, #8
    54fe:	3010      	adds	r0, #16
    5500:	4474      	add	r4, lr
    5502:	4470      	add	r0, lr
    5504:	ad44      	add	r5, sp, #272	; 0x110
    5506:	ed34 6b02 	vldmdb	r4!, {d6}
    550a:	ee36 5b07 	vadd.f64	d5, d6, d7
    550e:	ee36 6b45 	vsub.f64	d6, d6, d5
    5512:	ee36 7b07 	vadd.f64	d7, d6, d7
    5516:	ed20 7b02 	vstmdb	r0!, {d7}
    551a:	eeb0 7b45 	vmov.f64	d7, d5
    551e:	42a8      	cmp	r0, r5
    5520:	ed84 5b00 	vstr	d5, [r4]
    5524:	d1ef      	bne.n	5506 <__kernel_rem_pio2+0x4ae>
    5526:	2b01      	cmp	r3, #1
    5528:	f340 80a4 	ble.w	5674 <__kernel_rem_pio2+0x61c>
    552c:	00d2      	lsls	r2, r2, #3
    552e:	4477      	add	r7, lr
    5530:	f102 0010 	add.w	r0, r2, #16
    5534:	ed97 7b00 	vldr	d7, [r7]
    5538:	3208      	adds	r2, #8
    553a:	4470      	add	r0, lr
    553c:	eb0e 0302 	add.w	r3, lr, r2
    5540:	ac46      	add	r4, sp, #280	; 0x118
    5542:	4602      	mov	r2, r0
    5544:	ed33 6b02 	vldmdb	r3!, {d6}
    5548:	ee37 5b06 	vadd.f64	d5, d7, d6
    554c:	ee36 6b45 	vsub.f64	d6, d6, d5
    5550:	ee36 7b07 	vadd.f64	d7, d6, d7
    5554:	ed22 7b02 	vstmdb	r2!, {d7}
    5558:	eeb0 7b45 	vmov.f64	d7, d5
    555c:	4294      	cmp	r4, r2
    555e:	ed83 5b00 	vstr	d5, [r3]
    5562:	d1ef      	bne.n	5544 <__kernel_rem_pio2+0x4ec>
    5564:	ed9f 7b58 	vldr	d7, [pc, #352]	; 56c8 <__kernel_rem_pio2+0x670>
    5568:	ed30 6b02 	vldmdb	r0!, {d6}
    556c:	4284      	cmp	r4, r0
    556e:	ee37 7b06 	vadd.f64	d7, d7, d6
    5572:	d1f9      	bne.n	5568 <__kernel_rem_pio2+0x510>
    5574:	464b      	mov	r3, r9
    5576:	2b00      	cmp	r3, #0
    5578:	d066      	beq.n	5648 <__kernel_rem_pio2+0x5f0>
    557a:	eeb1 7b47 	vneg.f64	d7, d7
    557e:	ed9e 5b00 	vldr	d5, [lr]
    5582:	ed9e 6b02 	vldr	d6, [lr, #8]
    5586:	eeb1 5b45 	vneg.f64	d5, d5
    558a:	ed8b 5b00 	vstr	d5, [fp]
    558e:	ed8b 7b04 	vstr	d7, [fp, #16]
    5592:	eeb1 7b46 	vneg.f64	d7, d6
    5596:	ed8b 7b02 	vstr	d7, [fp, #8]
    559a:	ee1b 3a10 	vmov	r3, s22
    559e:	f003 0007 	and.w	r0, r3, #7
    55a2:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
    55a6:	ecbd 8b08 	vpop	{d8-d11}
    55aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    55ae:	ed9f 7b46 	vldr	d7, [pc, #280]	; 56c8 <__kernel_rem_pio2+0x670>
    55b2:	f107 0208 	add.w	r2, r7, #8
    55b6:	4472      	add	r2, lr
    55b8:	ed32 6b02 	vldmdb	r2!, {d6}
    55bc:	4572      	cmp	r2, lr
    55be:	ee37 7b06 	vadd.f64	d7, d7, d6
    55c2:	d1f9      	bne.n	55b8 <__kernel_rem_pio2+0x560>
    55c4:	464a      	mov	r2, r9
    55c6:	b3a2      	cbz	r2, 5632 <__kernel_rem_pio2+0x5da>
    55c8:	eeb1 5b47 	vneg.f64	d5, d7
    55cc:	ed9e 6b00 	vldr	d6, [lr]
    55d0:	2b00      	cmp	r3, #0
    55d2:	ed8b 5b00 	vstr	d5, [fp]
    55d6:	ee36 7b47 	vsub.f64	d7, d6, d7
    55da:	dd0b      	ble.n	55f4 <__kernel_rem_pio2+0x59c>
    55dc:	a844      	add	r0, sp, #272	; 0x110
    55de:	2201      	movs	r2, #1
    55e0:	ecb0 6b02 	vldmia	r0!, {d6}
    55e4:	3201      	adds	r2, #1
    55e6:	4293      	cmp	r3, r2
    55e8:	ee37 7b06 	vadd.f64	d7, d7, d6
    55ec:	daf8      	bge.n	55e0 <__kernel_rem_pio2+0x588>
    55ee:	464b      	mov	r3, r9
    55f0:	2b00      	cmp	r3, #0
    55f2:	d0d0      	beq.n	5596 <__kernel_rem_pio2+0x53e>
    55f4:	eeb1 7b47 	vneg.f64	d7, d7
    55f8:	ed8b 7b02 	vstr	d7, [fp, #8]
    55fc:	e7cd      	b.n	559a <__kernel_rem_pio2+0x542>
    55fe:	ed9f 7b32 	vldr	d7, [pc, #200]	; 56c8 <__kernel_rem_pio2+0x670>
    5602:	3708      	adds	r7, #8
    5604:	44be      	add	lr, r7
    5606:	ed3e 6b02 	vldmdb	lr!, {d6}
    560a:	3b01      	subs	r3, #1
    560c:	1c5a      	adds	r2, r3, #1
    560e:	ee37 7b06 	vadd.f64	d7, d7, d6
    5612:	d1f8      	bne.n	5606 <__kernel_rem_pio2+0x5ae>
    5614:	464b      	mov	r3, r9
    5616:	b10b      	cbz	r3, 561c <__kernel_rem_pio2+0x5c4>
    5618:	eeb1 7b47 	vneg.f64	d7, d7
    561c:	ed8b 7b00 	vstr	d7, [fp]
    5620:	e7bb      	b.n	559a <__kernel_rem_pio2+0x542>
    5622:	ed9f 7b29 	vldr	d7, [pc, #164]	; 56c8 <__kernel_rem_pio2+0x670>
    5626:	e6fd      	b.n	5424 <__kernel_rem_pio2+0x3cc>
    5628:	f04f 0e01 	mov.w	lr, #1
    562c:	e639      	b.n	52a2 <__kernel_rem_pio2+0x24a>
    562e:	2000      	movs	r0, #0
    5630:	e5f8      	b.n	5224 <__kernel_rem_pio2+0x1cc>
    5632:	ed9e 6b00 	vldr	d6, [lr]
    5636:	2b00      	cmp	r3, #0
    5638:	ed8b 7b00 	vstr	d7, [fp]
    563c:	ee36 7b47 	vsub.f64	d7, d6, d7
    5640:	dccc      	bgt.n	55dc <__kernel_rem_pio2+0x584>
    5642:	ed8b 7b02 	vstr	d7, [fp, #8]
    5646:	e7a8      	b.n	559a <__kernel_rem_pio2+0x542>
    5648:	e9de 0100 	ldrd	r0, r1, [lr]
    564c:	e9de 2302 	ldrd	r2, r3, [lr, #8]
    5650:	ed8b 7b04 	vstr	d7, [fp, #16]
    5654:	e9cb 0100 	strd	r0, r1, [fp]
    5658:	e9cb 2302 	strd	r2, r3, [fp, #8]
    565c:	e79d      	b.n	559a <__kernel_rem_pio2+0x542>
    565e:	eebd 0bc0 	vcvt.s32.f64	s0, d0
    5662:	a906      	add	r1, sp, #24
    5664:	ee10 2a10 	vmov	r2, s0
    5668:	462b      	mov	r3, r5
    566a:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    566e:	e69c      	b.n	53aa <__kernel_rem_pio2+0x352>
    5670:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    5674:	ed9f 7b14 	vldr	d7, [pc, #80]	; 56c8 <__kernel_rem_pio2+0x670>
    5678:	e77c      	b.n	5574 <__kernel_rem_pio2+0x51c>
    567a:	9aa4      	ldr	r2, [sp, #656]	; 0x290
    567c:	2a03      	cmp	r2, #3
    567e:	d88c      	bhi.n	559a <__kernel_rem_pio2+0x542>
    5680:	a101      	add	r1, pc, #4	; (adr r1, 5688 <__kernel_rem_pio2+0x630>)
    5682:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    5686:	bf00      	nop
    5688:	000056a9 	.word	0x000056a9
    568c:	0000569f 	.word	0x0000569f
    5690:	0000569f 	.word	0x0000569f
    5694:	00005671 	.word	0x00005671
    5698:	9b01      	ldr	r3, [sp, #4]
    569a:	00dc      	lsls	r4, r3, #3
    569c:	e53c      	b.n	5118 <__kernel_rem_pio2+0xc0>
    569e:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 56c8 <__kernel_rem_pio2+0x670>
    56a2:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    56a6:	e78d      	b.n	55c4 <__kernel_rem_pio2+0x56c>
    56a8:	ed9f 7b07 	vldr	d7, [pc, #28]	; 56c8 <__kernel_rem_pio2+0x670>
    56ac:	e7b2      	b.n	5614 <__kernel_rem_pio2+0x5bc>
    56ae:	bf00      	nop
    56b0:	00000000 	.word	0x00000000
    56b4:	41700000 	.word	0x41700000
    56b8:	00000000 	.word	0x00000000
    56bc:	3e700000 	.word	0x3e700000
    56c0:	40000000 	.word	0x40000000
    56c4:	3ff921fb 	.word	0x3ff921fb
	...
    56d0:	20000288 	.word	0x20000288
    56d4:	00000000 	.word	0x00000000

000056d8 <__kernel_sin>:
    56d8:	ee10 3a90 	vmov	r3, s1
    56dc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    56e0:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
    56e4:	da04      	bge.n	56f0 <__kernel_sin+0x18>
    56e6:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    56ea:	ee17 3a90 	vmov	r3, s15
    56ee:	b323      	cbz	r3, 573a <__kernel_sin+0x62>
    56f0:	ee20 7b00 	vmul.f64	d7, d0, d0
    56f4:	ee20 4b07 	vmul.f64	d4, d0, d7
    56f8:	ed9f 5b15 	vldr	d5, [pc, #84]	; 5750 <__kernel_sin+0x78>
    56fc:	ed9f 6b16 	vldr	d6, [pc, #88]	; 5758 <__kernel_sin+0x80>
    5700:	ed9f 3b17 	vldr	d3, [pc, #92]	; 5760 <__kernel_sin+0x88>
    5704:	eea7 6b05 	vfma.f64	d6, d7, d5
    5708:	ed9f 5b17 	vldr	d5, [pc, #92]	; 5768 <__kernel_sin+0x90>
    570c:	eea7 3b06 	vfma.f64	d3, d7, d6
    5710:	ed9f 6b17 	vldr	d6, [pc, #92]	; 5770 <__kernel_sin+0x98>
    5714:	eea7 5b03 	vfma.f64	d5, d7, d3
    5718:	eea7 6b05 	vfma.f64	d6, d7, d5
    571c:	b170      	cbz	r0, 573c <__kernel_sin+0x64>
    571e:	ee26 6b44 	vnmul.f64	d6, d6, d4
    5722:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    5726:	ed9f 5b14 	vldr	d5, [pc, #80]	; 5778 <__kernel_sin+0xa0>
    572a:	eea1 6b03 	vfma.f64	d6, d1, d3
    572e:	ee97 1b06 	vfnms.f64	d1, d7, d6
    5732:	eea4 1b05 	vfma.f64	d1, d4, d5
    5736:	ee30 0b41 	vsub.f64	d0, d0, d1
    573a:	4770      	bx	lr
    573c:	ed9f 5b10 	vldr	d5, [pc, #64]	; 5780 <__kernel_sin+0xa8>
    5740:	eea7 5b06 	vfma.f64	d5, d7, d6
    5744:	eea4 0b05 	vfma.f64	d0, d4, d5
    5748:	4770      	bx	lr
    574a:	bf00      	nop
    574c:	f3af 8000 	nop.w
    5750:	5acfd57c 	.word	0x5acfd57c
    5754:	3de5d93a 	.word	0x3de5d93a
    5758:	8a2b9ceb 	.word	0x8a2b9ceb
    575c:	be5ae5e6 	.word	0xbe5ae5e6
    5760:	57b1fe7d 	.word	0x57b1fe7d
    5764:	3ec71de3 	.word	0x3ec71de3
    5768:	19c161d5 	.word	0x19c161d5
    576c:	bf2a01a0 	.word	0xbf2a01a0
    5770:	1110f8a6 	.word	0x1110f8a6
    5774:	3f811111 	.word	0x3f811111
    5778:	55555549 	.word	0x55555549
    577c:	3fc55555 	.word	0x3fc55555
    5780:	55555549 	.word	0x55555549
    5784:	bfc55555 	.word	0xbfc55555

00005788 <atan>:
    5788:	b538      	push	{r3, r4, r5, lr}
    578a:	eeb0 7b40 	vmov.f64	d7, d0
    578e:	ee17 5a90 	vmov	r5, s15
    5792:	4b77      	ldr	r3, [pc, #476]	; (5970 <atan+0x1e8>)
    5794:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
    5798:	429c      	cmp	r4, r3
    579a:	dd0e      	ble.n	57ba <atan+0x32>
    579c:	4b75      	ldr	r3, [pc, #468]	; (5974 <atan+0x1ec>)
    579e:	429c      	cmp	r4, r3
    57a0:	ee10 2a10 	vmov	r2, s0
    57a4:	dc5c      	bgt.n	5860 <atan+0xd8>
    57a6:	d059      	beq.n	585c <atan+0xd4>
    57a8:	ed9f 7b55 	vldr	d7, [pc, #340]	; 5900 <atan+0x178>
    57ac:	ed9f 0b56 	vldr	d0, [pc, #344]	; 5908 <atan+0x180>
    57b0:	2d00      	cmp	r5, #0
    57b2:	bfc8      	it	gt
    57b4:	eeb0 0b47 	vmovgt.f64	d0, d7
    57b8:	bd38      	pop	{r3, r4, r5, pc}
    57ba:	4b6f      	ldr	r3, [pc, #444]	; (5978 <atan+0x1f0>)
    57bc:	429c      	cmp	r4, r3
    57be:	dc60      	bgt.n	5882 <atan+0xfa>
    57c0:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
    57c4:	429c      	cmp	r4, r3
    57c6:	dd4e      	ble.n	5866 <atan+0xde>
    57c8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    57cc:	ed9f 2b50 	vldr	d2, [pc, #320]	; 5910 <atan+0x188>
    57d0:	ee27 4b07 	vmul.f64	d4, d7, d7
    57d4:	ee24 6b04 	vmul.f64	d6, d4, d4
    57d8:	ed9f 3b4f 	vldr	d3, [pc, #316]	; 5918 <atan+0x190>
    57dc:	ed9f 5b50 	vldr	d5, [pc, #320]	; 5920 <atan+0x198>
    57e0:	eea6 3b02 	vfma.f64	d3, d6, d2
    57e4:	ed9f 2b50 	vldr	d2, [pc, #320]	; 5928 <atan+0x1a0>
    57e8:	eea6 5b03 	vfma.f64	d5, d6, d3
    57ec:	ed9f 3b50 	vldr	d3, [pc, #320]	; 5930 <atan+0x1a8>
    57f0:	eea6 2b05 	vfma.f64	d2, d6, d5
    57f4:	ed9f 5b50 	vldr	d5, [pc, #320]	; 5938 <atan+0x1b0>
    57f8:	eea6 3b02 	vfma.f64	d3, d6, d2
    57fc:	ed9f 1b50 	vldr	d1, [pc, #320]	; 5940 <atan+0x1b8>
    5800:	eea6 5b03 	vfma.f64	d5, d6, d3
    5804:	ee25 5b04 	vmul.f64	d5, d5, d4
    5808:	ed9f 2b4f 	vldr	d2, [pc, #316]	; 5948 <atan+0x1c0>
    580c:	ed9f 4b50 	vldr	d4, [pc, #320]	; 5950 <atan+0x1c8>
    5810:	ed9f 3b51 	vldr	d3, [pc, #324]	; 5958 <atan+0x1d0>
    5814:	eea6 4b01 	vfma.f64	d4, d6, d1
    5818:	eea6 2b04 	vfma.f64	d2, d6, d4
    581c:	ed9f 4b50 	vldr	d4, [pc, #320]	; 5960 <atan+0x1d8>
    5820:	eea6 3b02 	vfma.f64	d3, d6, d2
    5824:	1c5a      	adds	r2, r3, #1
    5826:	eea6 4b03 	vfma.f64	d4, d6, d3
    582a:	ee24 6b06 	vmul.f64	d6, d4, d6
    582e:	d040      	beq.n	58b2 <atan+0x12a>
    5830:	ee35 5b06 	vadd.f64	d5, d5, d6
    5834:	4a51      	ldr	r2, [pc, #324]	; (597c <atan+0x1f4>)
    5836:	4952      	ldr	r1, [pc, #328]	; (5980 <atan+0x1f8>)
    5838:	00db      	lsls	r3, r3, #3
    583a:	441a      	add	r2, r3
    583c:	440b      	add	r3, r1
    583e:	ed92 6b00 	vldr	d6, [r2]
    5842:	ed93 0b00 	vldr	d0, [r3]
    5846:	ee97 6b05 	vfnms.f64	d6, d7, d5
    584a:	ee36 7b47 	vsub.f64	d7, d6, d7
    584e:	2d00      	cmp	r5, #0
    5850:	ee30 7b47 	vsub.f64	d7, d0, d7
    5854:	db2a      	blt.n	58ac <atan+0x124>
    5856:	eeb0 0b47 	vmov.f64	d0, d7
    585a:	bd38      	pop	{r3, r4, r5, pc}
    585c:	2a00      	cmp	r2, #0
    585e:	d0a3      	beq.n	57a8 <atan+0x20>
    5860:	ee37 0b07 	vadd.f64	d0, d7, d7
    5864:	bd38      	pop	{r3, r4, r5, pc}
    5866:	ed9f 6b40 	vldr	d6, [pc, #256]	; 5968 <atan+0x1e0>
    586a:	eeb7 5b00 	vmov.f64	d5, #112	; 0x3f800000  1.0
    586e:	ee30 6b06 	vadd.f64	d6, d0, d6
    5872:	eeb4 6bc5 	vcmpe.f64	d6, d5
    5876:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    587a:	dda5      	ble.n	57c8 <atan+0x40>
    587c:	eeb0 0b47 	vmov.f64	d0, d7
    5880:	bd38      	pop	{r3, r4, r5, pc}
    5882:	f000 f883 	bl	598c <fabs>
    5886:	4b3f      	ldr	r3, [pc, #252]	; (5984 <atan+0x1fc>)
    5888:	429c      	cmp	r4, r3
    588a:	dc19      	bgt.n	58c0 <atan+0x138>
    588c:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
    5890:	429c      	cmp	r4, r3
    5892:	dc2a      	bgt.n	58ea <atan+0x162>
    5894:	eeb0 7b00 	vmov.f64	d7, #0	; 0x40000000  2.0
    5898:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
    589c:	ee30 5b07 	vadd.f64	d5, d0, d7
    58a0:	eea0 6b07 	vfma.f64	d6, d0, d7
    58a4:	2300      	movs	r3, #0
    58a6:	ee86 7b05 	vdiv.f64	d7, d6, d5
    58aa:	e78f      	b.n	57cc <atan+0x44>
    58ac:	eeb1 0b47 	vneg.f64	d0, d7
    58b0:	bd38      	pop	{r3, r4, r5, pc}
    58b2:	ee35 6b06 	vadd.f64	d6, d5, d6
    58b6:	eea7 7b46 	vfms.f64	d7, d7, d6
    58ba:	eeb0 0b47 	vmov.f64	d0, d7
    58be:	bd38      	pop	{r3, r4, r5, pc}
    58c0:	4b31      	ldr	r3, [pc, #196]	; (5988 <atan+0x200>)
    58c2:	429c      	cmp	r4, r3
    58c4:	dc0b      	bgt.n	58de <atan+0x156>
    58c6:	eeb7 7b08 	vmov.f64	d7, #120	; 0x3fc00000  1.5
    58ca:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    58ce:	ee30 5b47 	vsub.f64	d5, d0, d7
    58d2:	eea0 6b07 	vfma.f64	d6, d0, d7
    58d6:	2302      	movs	r3, #2
    58d8:	ee85 7b06 	vdiv.f64	d7, d5, d6
    58dc:	e776      	b.n	57cc <atan+0x44>
    58de:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
    58e2:	2303      	movs	r3, #3
    58e4:	ee86 7b00 	vdiv.f64	d7, d6, d0
    58e8:	e770      	b.n	57cc <atan+0x44>
    58ea:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    58ee:	2301      	movs	r3, #1
    58f0:	ee30 6b47 	vsub.f64	d6, d0, d7
    58f4:	ee30 0b07 	vadd.f64	d0, d0, d7
    58f8:	ee86 7b00 	vdiv.f64	d7, d6, d0
    58fc:	e766      	b.n	57cc <atan+0x44>
    58fe:	bf00      	nop
    5900:	54442d18 	.word	0x54442d18
    5904:	3ff921fb 	.word	0x3ff921fb
    5908:	54442d18 	.word	0x54442d18
    590c:	bff921fb 	.word	0xbff921fb
    5910:	e322da11 	.word	0xe322da11
    5914:	3f90ad3a 	.word	0x3f90ad3a
    5918:	24760deb 	.word	0x24760deb
    591c:	3fa97b4b 	.word	0x3fa97b4b
    5920:	a0d03d51 	.word	0xa0d03d51
    5924:	3fb10d66 	.word	0x3fb10d66
    5928:	c54c206e 	.word	0xc54c206e
    592c:	3fb745cd 	.word	0x3fb745cd
    5930:	920083ff 	.word	0x920083ff
    5934:	3fc24924 	.word	0x3fc24924
    5938:	5555550d 	.word	0x5555550d
    593c:	3fd55555 	.word	0x3fd55555
    5940:	2c6a6c2f 	.word	0x2c6a6c2f
    5944:	bfa2b444 	.word	0xbfa2b444
    5948:	af749a6d 	.word	0xaf749a6d
    594c:	bfb3b0f2 	.word	0xbfb3b0f2
    5950:	52defd9a 	.word	0x52defd9a
    5954:	bfadde2d 	.word	0xbfadde2d
    5958:	fe231671 	.word	0xfe231671
    595c:	bfbc71c6 	.word	0xbfbc71c6
    5960:	9998ebc4 	.word	0x9998ebc4
    5964:	bfc99999 	.word	0xbfc99999
    5968:	8800759c 	.word	0x8800759c
    596c:	7e37e43c 	.word	0x7e37e43c
    5970:	440fffff 	.word	0x440fffff
    5974:	7ff00000 	.word	0x7ff00000
    5978:	3fdbffff 	.word	0x3fdbffff
    597c:	200003d0 	.word	0x200003d0
    5980:	200003b0 	.word	0x200003b0
    5984:	3ff2ffff 	.word	0x3ff2ffff
    5988:	40037fff 	.word	0x40037fff

0000598c <fabs>:
    598c:	ec53 2b10 	vmov	r2, r3, d0
    5990:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5994:	ec43 2b10 	vmov	d0, r2, r3
    5998:	4770      	bx	lr
    599a:	bf00      	nop
    599c:	0000      	movs	r0, r0
	...

000059a0 <floor>:
    59a0:	b470      	push	{r4, r5, r6}
    59a2:	b083      	sub	sp, #12
    59a4:	ed8d 0b00 	vstr	d0, [sp]
    59a8:	9901      	ldr	r1, [sp, #4]
    59aa:	9c00      	ldr	r4, [sp, #0]
    59ac:	f3c1 520a 	ubfx	r2, r1, #20, #11
    59b0:	f2a2 33ff 	subw	r3, r2, #1023	; 0x3ff
    59b4:	2b13      	cmp	r3, #19
    59b6:	460d      	mov	r5, r1
    59b8:	4620      	mov	r0, r4
    59ba:	dc1e      	bgt.n	59fa <floor+0x5a>
    59bc:	2b00      	cmp	r3, #0
    59be:	db43      	blt.n	5a48 <floor+0xa8>
    59c0:	4a3b      	ldr	r2, [pc, #236]	; (5ab0 <floor+0x110>)
    59c2:	411a      	asrs	r2, r3
    59c4:	ea01 0602 	and.w	r6, r1, r2
    59c8:	4334      	orrs	r4, r6
    59ca:	d01b      	beq.n	5a04 <floor+0x64>
    59cc:	ed9f 7b36 	vldr	d7, [pc, #216]	; 5aa8 <floor+0x108>
    59d0:	ed9d 6b00 	vldr	d6, [sp]
    59d4:	ee36 7b07 	vadd.f64	d7, d6, d7
    59d8:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    59dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    59e0:	dd04      	ble.n	59ec <floor+0x4c>
    59e2:	2900      	cmp	r1, #0
    59e4:	db43      	blt.n	5a6e <floor+0xce>
    59e6:	ea25 0102 	bic.w	r1, r5, r2
    59ea:	2000      	movs	r0, #0
    59ec:	460b      	mov	r3, r1
    59ee:	4602      	mov	r2, r0
    59f0:	ec43 2b10 	vmov	d0, r2, r3
    59f4:	b003      	add	sp, #12
    59f6:	bc70      	pop	{r4, r5, r6}
    59f8:	4770      	bx	lr
    59fa:	2b33      	cmp	r3, #51	; 0x33
    59fc:	dd07      	ble.n	5a0e <floor+0x6e>
    59fe:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    5a02:	d02f      	beq.n	5a64 <floor+0xc4>
    5a04:	ed9d 0b00 	vldr	d0, [sp]
    5a08:	b003      	add	sp, #12
    5a0a:	bc70      	pop	{r4, r5, r6}
    5a0c:	4770      	bx	lr
    5a0e:	f2a2 4213 	subw	r2, r2, #1043	; 0x413
    5a12:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    5a16:	fa24 f202 	lsr.w	r2, r4, r2
    5a1a:	4210      	tst	r0, r2
    5a1c:	d0f2      	beq.n	5a04 <floor+0x64>
    5a1e:	ed9f 7b22 	vldr	d7, [pc, #136]	; 5aa8 <floor+0x108>
    5a22:	ed9d 6b00 	vldr	d6, [sp]
    5a26:	ee36 7b07 	vadd.f64	d7, d6, d7
    5a2a:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    5a2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5a32:	dddb      	ble.n	59ec <floor+0x4c>
    5a34:	2900      	cmp	r1, #0
    5a36:	db20      	blt.n	5a7a <floor+0xda>
    5a38:	4629      	mov	r1, r5
    5a3a:	ea20 0002 	bic.w	r0, r0, r2
    5a3e:	460b      	mov	r3, r1
    5a40:	4602      	mov	r2, r0
    5a42:	ec43 2b10 	vmov	d0, r2, r3
    5a46:	e7d5      	b.n	59f4 <floor+0x54>
    5a48:	ed9f 7b17 	vldr	d7, [pc, #92]	; 5aa8 <floor+0x108>
    5a4c:	ee30 7b07 	vadd.f64	d7, d0, d7
    5a50:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    5a54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5a58:	ddc8      	ble.n	59ec <floor+0x4c>
    5a5a:	2900      	cmp	r1, #0
    5a5c:	db18      	blt.n	5a90 <floor+0xf0>
    5a5e:	2000      	movs	r0, #0
    5a60:	4601      	mov	r1, r0
    5a62:	e7c3      	b.n	59ec <floor+0x4c>
    5a64:	ed9d 7b00 	vldr	d7, [sp]
    5a68:	ee37 0b07 	vadd.f64	d0, d7, d7
    5a6c:	e7cc      	b.n	5a08 <floor+0x68>
    5a6e:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    5a72:	fa41 f303 	asr.w	r3, r1, r3
    5a76:	441d      	add	r5, r3
    5a78:	e7b5      	b.n	59e6 <floor+0x46>
    5a7a:	2b14      	cmp	r3, #20
    5a7c:	d010      	beq.n	5aa0 <floor+0x100>
    5a7e:	2101      	movs	r1, #1
    5a80:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
    5a84:	fa01 f303 	lsl.w	r3, r1, r3
    5a88:	1818      	adds	r0, r3, r0
    5a8a:	bf28      	it	cs
    5a8c:	186d      	addcs	r5, r5, r1
    5a8e:	e7d3      	b.n	5a38 <floor+0x98>
    5a90:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
    5a94:	4b07      	ldr	r3, [pc, #28]	; (5ab4 <floor+0x114>)
    5a96:	4322      	orrs	r2, r4
    5a98:	bf18      	it	ne
    5a9a:	4619      	movne	r1, r3
    5a9c:	2000      	movs	r0, #0
    5a9e:	e7a5      	b.n	59ec <floor+0x4c>
    5aa0:	3501      	adds	r5, #1
    5aa2:	e7c9      	b.n	5a38 <floor+0x98>
    5aa4:	f3af 8000 	nop.w
    5aa8:	8800759c 	.word	0x8800759c
    5aac:	7e37e43c 	.word	0x7e37e43c
    5ab0:	000fffff 	.word	0x000fffff
    5ab4:	bff00000 	.word	0xbff00000

00005ab8 <matherr>:
    5ab8:	2000      	movs	r0, #0
    5aba:	4770      	bx	lr
    5abc:	0000      	movs	r0, r0
	...

00005ac0 <scalbn>:
    5ac0:	b510      	push	{r4, lr}
    5ac2:	ed2d 8b02 	vpush	{d8}
    5ac6:	b082      	sub	sp, #8
    5ac8:	ed8d 0b00 	vstr	d0, [sp]
    5acc:	9b01      	ldr	r3, [sp, #4]
    5ace:	9900      	ldr	r1, [sp, #0]
    5ad0:	f3c3 520a 	ubfx	r2, r3, #20, #11
    5ad4:	bb2a      	cbnz	r2, 5b22 <scalbn+0x62>
    5ad6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5ada:	430b      	orrs	r3, r1
    5adc:	d02d      	beq.n	5b3a <scalbn+0x7a>
    5ade:	ed9f 7b36 	vldr	d7, [pc, #216]	; 5bb8 <scalbn+0xf8>
    5ae2:	4a3d      	ldr	r2, [pc, #244]	; (5bd8 <scalbn+0x118>)
    5ae4:	ee20 7b07 	vmul.f64	d7, d0, d7
    5ae8:	4290      	cmp	r0, r2
    5aea:	ed8d 7b00 	vstr	d7, [sp]
    5aee:	9b01      	ldr	r3, [sp, #4]
    5af0:	db29      	blt.n	5b46 <scalbn+0x86>
    5af2:	f3c3 520a 	ubfx	r2, r3, #20, #11
    5af6:	3a36      	subs	r2, #54	; 0x36
    5af8:	1884      	adds	r4, r0, r2
    5afa:	f240 72fe 	movw	r2, #2046	; 0x7fe
    5afe:	4294      	cmp	r4, r2
    5b00:	dc30      	bgt.n	5b64 <scalbn+0xa4>
    5b02:	2c00      	cmp	r4, #0
    5b04:	dd27      	ble.n	5b56 <scalbn+0x96>
    5b06:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
    5b0a:	e9dd 2300 	ldrd	r2, r3, [sp]
    5b0e:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    5b12:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    5b16:	ec43 2b10 	vmov	d0, r2, r3
    5b1a:	b002      	add	sp, #8
    5b1c:	ecbd 8b02 	vpop	{d8}
    5b20:	bd10      	pop	{r4, pc}
    5b22:	f240 71ff 	movw	r1, #2047	; 0x7ff
    5b26:	428a      	cmp	r2, r1
    5b28:	d1e6      	bne.n	5af8 <scalbn+0x38>
    5b2a:	ed9d 7b00 	vldr	d7, [sp]
    5b2e:	ee37 0b07 	vadd.f64	d0, d7, d7
    5b32:	b002      	add	sp, #8
    5b34:	ecbd 8b02 	vpop	{d8}
    5b38:	bd10      	pop	{r4, pc}
    5b3a:	ed9d 0b00 	vldr	d0, [sp]
    5b3e:	b002      	add	sp, #8
    5b40:	ecbd 8b02 	vpop	{d8}
    5b44:	bd10      	pop	{r4, pc}
    5b46:	ed9f 0b1e 	vldr	d0, [pc, #120]	; 5bc0 <scalbn+0x100>
    5b4a:	ee27 0b00 	vmul.f64	d0, d7, d0
    5b4e:	b002      	add	sp, #8
    5b50:	ecbd 8b02 	vpop	{d8}
    5b54:	bd10      	pop	{r4, pc}
    5b56:	f114 0f35 	cmn.w	r4, #53	; 0x35
    5b5a:	da11      	bge.n	5b80 <scalbn+0xc0>
    5b5c:	f24c 3350 	movw	r3, #50000	; 0xc350
    5b60:	4298      	cmp	r0, r3
    5b62:	dd1d      	ble.n	5ba0 <scalbn+0xe0>
    5b64:	ed9f 8b18 	vldr	d8, [pc, #96]	; 5bc8 <scalbn+0x108>
    5b68:	ed9d 1b00 	vldr	d1, [sp]
    5b6c:	eeb0 0b48 	vmov.f64	d0, d8
    5b70:	f000 f834 	bl	5bdc <copysign>
    5b74:	ee20 0b08 	vmul.f64	d0, d0, d8
    5b78:	b002      	add	sp, #8
    5b7a:	ecbd 8b02 	vpop	{d8}
    5b7e:	bd10      	pop	{r4, pc}
    5b80:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
    5b84:	e9dd 2300 	ldrd	r2, r3, [sp]
    5b88:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    5b8c:	3436      	adds	r4, #54	; 0x36
    5b8e:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    5b92:	ed9f 0b0f 	vldr	d0, [pc, #60]	; 5bd0 <scalbn+0x110>
    5b96:	ec43 2b17 	vmov	d7, r2, r3
    5b9a:	ee27 0b00 	vmul.f64	d0, d7, d0
    5b9e:	e7bc      	b.n	5b1a <scalbn+0x5a>
    5ba0:	ed9f 8b07 	vldr	d8, [pc, #28]	; 5bc0 <scalbn+0x100>
    5ba4:	ed9d 1b00 	vldr	d1, [sp]
    5ba8:	eeb0 0b48 	vmov.f64	d0, d8
    5bac:	f000 f816 	bl	5bdc <copysign>
    5bb0:	ee20 0b08 	vmul.f64	d0, d0, d8
    5bb4:	e7b1      	b.n	5b1a <scalbn+0x5a>
    5bb6:	bf00      	nop
    5bb8:	00000000 	.word	0x00000000
    5bbc:	43500000 	.word	0x43500000
    5bc0:	c2f8f359 	.word	0xc2f8f359
    5bc4:	01a56e1f 	.word	0x01a56e1f
    5bc8:	8800759c 	.word	0x8800759c
    5bcc:	7e37e43c 	.word	0x7e37e43c
    5bd0:	00000000 	.word	0x00000000
    5bd4:	3c900000 	.word	0x3c900000
    5bd8:	ffff3cb0 	.word	0xffff3cb0

00005bdc <copysign>:
    5bdc:	ec53 2b10 	vmov	r2, r3, d0
    5be0:	ee11 0a90 	vmov	r0, s3
    5be4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    5be8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    5bec:	ea41 0300 	orr.w	r3, r1, r0
    5bf0:	ec43 2b10 	vmov	d0, r2, r3
    5bf4:	4770      	bx	lr
    5bf6:	bf00      	nop

00005bf8 <__aeabi_atexit>:
    5bf8:	460b      	mov	r3, r1
    5bfa:	4601      	mov	r1, r0
    5bfc:	4618      	mov	r0, r3
    5bfe:	f000 b98d 	b.w	5f1c <__cxa_atexit>
    5c02:	bf00      	nop

00005c04 <__aeabi_uldivmod>:
    5c04:	b953      	cbnz	r3, 5c1c <__aeabi_uldivmod+0x18>
    5c06:	b94a      	cbnz	r2, 5c1c <__aeabi_uldivmod+0x18>
    5c08:	2900      	cmp	r1, #0
    5c0a:	bf08      	it	eq
    5c0c:	2800      	cmpeq	r0, #0
    5c0e:	bf1c      	itt	ne
    5c10:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    5c14:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    5c18:	f000 b97e 	b.w	5f18 <__aeabi_idiv0>
    5c1c:	f1ad 0c08 	sub.w	ip, sp, #8
    5c20:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    5c24:	f000 f806 	bl	5c34 <__udivmoddi4>
    5c28:	f8dd e004 	ldr.w	lr, [sp, #4]
    5c2c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    5c30:	b004      	add	sp, #16
    5c32:	4770      	bx	lr

00005c34 <__udivmoddi4>:
    5c34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5c38:	468c      	mov	ip, r1
    5c3a:	460e      	mov	r6, r1
    5c3c:	4604      	mov	r4, r0
    5c3e:	9d08      	ldr	r5, [sp, #32]
    5c40:	2b00      	cmp	r3, #0
    5c42:	d150      	bne.n	5ce6 <__udivmoddi4+0xb2>
    5c44:	428a      	cmp	r2, r1
    5c46:	4617      	mov	r7, r2
    5c48:	d96c      	bls.n	5d24 <__udivmoddi4+0xf0>
    5c4a:	fab2 fe82 	clz	lr, r2
    5c4e:	f1be 0f00 	cmp.w	lr, #0
    5c52:	d00b      	beq.n	5c6c <__udivmoddi4+0x38>
    5c54:	f1ce 0420 	rsb	r4, lr, #32
    5c58:	fa20 f404 	lsr.w	r4, r0, r4
    5c5c:	fa01 f60e 	lsl.w	r6, r1, lr
    5c60:	ea44 0c06 	orr.w	ip, r4, r6
    5c64:	fa02 f70e 	lsl.w	r7, r2, lr
    5c68:	fa00 f40e 	lsl.w	r4, r0, lr
    5c6c:	ea4f 4917 	mov.w	r9, r7, lsr #16
    5c70:	0c22      	lsrs	r2, r4, #16
    5c72:	fbbc f0f9 	udiv	r0, ip, r9
    5c76:	fa1f f887 	uxth.w	r8, r7
    5c7a:	fb09 c610 	mls	r6, r9, r0, ip
    5c7e:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    5c82:	fb00 f308 	mul.w	r3, r0, r8
    5c86:	42b3      	cmp	r3, r6
    5c88:	d909      	bls.n	5c9e <__udivmoddi4+0x6a>
    5c8a:	19f6      	adds	r6, r6, r7
    5c8c:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    5c90:	f080 8122 	bcs.w	5ed8 <__udivmoddi4+0x2a4>
    5c94:	42b3      	cmp	r3, r6
    5c96:	f240 811f 	bls.w	5ed8 <__udivmoddi4+0x2a4>
    5c9a:	3802      	subs	r0, #2
    5c9c:	443e      	add	r6, r7
    5c9e:	1af6      	subs	r6, r6, r3
    5ca0:	b2a2      	uxth	r2, r4
    5ca2:	fbb6 f3f9 	udiv	r3, r6, r9
    5ca6:	fb09 6613 	mls	r6, r9, r3, r6
    5caa:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    5cae:	fb03 f808 	mul.w	r8, r3, r8
    5cb2:	45a0      	cmp	r8, r4
    5cb4:	d909      	bls.n	5cca <__udivmoddi4+0x96>
    5cb6:	19e4      	adds	r4, r4, r7
    5cb8:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    5cbc:	f080 810a 	bcs.w	5ed4 <__udivmoddi4+0x2a0>
    5cc0:	45a0      	cmp	r8, r4
    5cc2:	f240 8107 	bls.w	5ed4 <__udivmoddi4+0x2a0>
    5cc6:	3b02      	subs	r3, #2
    5cc8:	443c      	add	r4, r7
    5cca:	ebc8 0404 	rsb	r4, r8, r4
    5cce:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    5cd2:	2100      	movs	r1, #0
    5cd4:	2d00      	cmp	r5, #0
    5cd6:	d062      	beq.n	5d9e <__udivmoddi4+0x16a>
    5cd8:	fa24 f40e 	lsr.w	r4, r4, lr
    5cdc:	2300      	movs	r3, #0
    5cde:	602c      	str	r4, [r5, #0]
    5ce0:	606b      	str	r3, [r5, #4]
    5ce2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5ce6:	428b      	cmp	r3, r1
    5ce8:	d907      	bls.n	5cfa <__udivmoddi4+0xc6>
    5cea:	2d00      	cmp	r5, #0
    5cec:	d055      	beq.n	5d9a <__udivmoddi4+0x166>
    5cee:	2100      	movs	r1, #0
    5cf0:	e885 0041 	stmia.w	r5, {r0, r6}
    5cf4:	4608      	mov	r0, r1
    5cf6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5cfa:	fab3 f183 	clz	r1, r3
    5cfe:	2900      	cmp	r1, #0
    5d00:	f040 8090 	bne.w	5e24 <__udivmoddi4+0x1f0>
    5d04:	42b3      	cmp	r3, r6
    5d06:	d302      	bcc.n	5d0e <__udivmoddi4+0xda>
    5d08:	4282      	cmp	r2, r0
    5d0a:	f200 80f8 	bhi.w	5efe <__udivmoddi4+0x2ca>
    5d0e:	1a84      	subs	r4, r0, r2
    5d10:	eb66 0603 	sbc.w	r6, r6, r3
    5d14:	2001      	movs	r0, #1
    5d16:	46b4      	mov	ip, r6
    5d18:	2d00      	cmp	r5, #0
    5d1a:	d040      	beq.n	5d9e <__udivmoddi4+0x16a>
    5d1c:	e885 1010 	stmia.w	r5, {r4, ip}
    5d20:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5d24:	b912      	cbnz	r2, 5d2c <__udivmoddi4+0xf8>
    5d26:	2701      	movs	r7, #1
    5d28:	fbb7 f7f2 	udiv	r7, r7, r2
    5d2c:	fab7 fe87 	clz	lr, r7
    5d30:	f1be 0f00 	cmp.w	lr, #0
    5d34:	d135      	bne.n	5da2 <__udivmoddi4+0x16e>
    5d36:	1bf3      	subs	r3, r6, r7
    5d38:	ea4f 4817 	mov.w	r8, r7, lsr #16
    5d3c:	fa1f fc87 	uxth.w	ip, r7
    5d40:	2101      	movs	r1, #1
    5d42:	fbb3 f0f8 	udiv	r0, r3, r8
    5d46:	0c22      	lsrs	r2, r4, #16
    5d48:	fb08 3610 	mls	r6, r8, r0, r3
    5d4c:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    5d50:	fb0c f300 	mul.w	r3, ip, r0
    5d54:	42b3      	cmp	r3, r6
    5d56:	d907      	bls.n	5d68 <__udivmoddi4+0x134>
    5d58:	19f6      	adds	r6, r6, r7
    5d5a:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    5d5e:	d202      	bcs.n	5d66 <__udivmoddi4+0x132>
    5d60:	42b3      	cmp	r3, r6
    5d62:	f200 80ce 	bhi.w	5f02 <__udivmoddi4+0x2ce>
    5d66:	4610      	mov	r0, r2
    5d68:	1af6      	subs	r6, r6, r3
    5d6a:	b2a2      	uxth	r2, r4
    5d6c:	fbb6 f3f8 	udiv	r3, r6, r8
    5d70:	fb08 6613 	mls	r6, r8, r3, r6
    5d74:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    5d78:	fb0c fc03 	mul.w	ip, ip, r3
    5d7c:	45a4      	cmp	ip, r4
    5d7e:	d907      	bls.n	5d90 <__udivmoddi4+0x15c>
    5d80:	19e4      	adds	r4, r4, r7
    5d82:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    5d86:	d202      	bcs.n	5d8e <__udivmoddi4+0x15a>
    5d88:	45a4      	cmp	ip, r4
    5d8a:	f200 80b5 	bhi.w	5ef8 <__udivmoddi4+0x2c4>
    5d8e:	4613      	mov	r3, r2
    5d90:	ebcc 0404 	rsb	r4, ip, r4
    5d94:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    5d98:	e79c      	b.n	5cd4 <__udivmoddi4+0xa0>
    5d9a:	4629      	mov	r1, r5
    5d9c:	4628      	mov	r0, r5
    5d9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5da2:	f1ce 0120 	rsb	r1, lr, #32
    5da6:	fa06 f30e 	lsl.w	r3, r6, lr
    5daa:	fa07 f70e 	lsl.w	r7, r7, lr
    5dae:	fa20 f901 	lsr.w	r9, r0, r1
    5db2:	ea4f 4817 	mov.w	r8, r7, lsr #16
    5db6:	40ce      	lsrs	r6, r1
    5db8:	ea49 0903 	orr.w	r9, r9, r3
    5dbc:	fbb6 faf8 	udiv	sl, r6, r8
    5dc0:	ea4f 4419 	mov.w	r4, r9, lsr #16
    5dc4:	fb08 661a 	mls	r6, r8, sl, r6
    5dc8:	fa1f fc87 	uxth.w	ip, r7
    5dcc:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
    5dd0:	fb0a f20c 	mul.w	r2, sl, ip
    5dd4:	429a      	cmp	r2, r3
    5dd6:	fa00 f40e 	lsl.w	r4, r0, lr
    5dda:	d90a      	bls.n	5df2 <__udivmoddi4+0x1be>
    5ddc:	19db      	adds	r3, r3, r7
    5dde:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    5de2:	f080 8087 	bcs.w	5ef4 <__udivmoddi4+0x2c0>
    5de6:	429a      	cmp	r2, r3
    5de8:	f240 8084 	bls.w	5ef4 <__udivmoddi4+0x2c0>
    5dec:	f1aa 0a02 	sub.w	sl, sl, #2
    5df0:	443b      	add	r3, r7
    5df2:	1a9b      	subs	r3, r3, r2
    5df4:	fa1f f989 	uxth.w	r9, r9
    5df8:	fbb3 f1f8 	udiv	r1, r3, r8
    5dfc:	fb08 3311 	mls	r3, r8, r1, r3
    5e00:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
    5e04:	fb01 f60c 	mul.w	r6, r1, ip
    5e08:	429e      	cmp	r6, r3
    5e0a:	d907      	bls.n	5e1c <__udivmoddi4+0x1e8>
    5e0c:	19db      	adds	r3, r3, r7
    5e0e:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    5e12:	d26b      	bcs.n	5eec <__udivmoddi4+0x2b8>
    5e14:	429e      	cmp	r6, r3
    5e16:	d969      	bls.n	5eec <__udivmoddi4+0x2b8>
    5e18:	3902      	subs	r1, #2
    5e1a:	443b      	add	r3, r7
    5e1c:	1b9b      	subs	r3, r3, r6
    5e1e:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
    5e22:	e78e      	b.n	5d42 <__udivmoddi4+0x10e>
    5e24:	f1c1 0e20 	rsb	lr, r1, #32
    5e28:	fa22 f40e 	lsr.w	r4, r2, lr
    5e2c:	408b      	lsls	r3, r1
    5e2e:	4323      	orrs	r3, r4
    5e30:	fa20 f70e 	lsr.w	r7, r0, lr
    5e34:	fa06 f401 	lsl.w	r4, r6, r1
    5e38:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    5e3c:	fa26 f60e 	lsr.w	r6, r6, lr
    5e40:	433c      	orrs	r4, r7
    5e42:	fbb6 f9fc 	udiv	r9, r6, ip
    5e46:	0c27      	lsrs	r7, r4, #16
    5e48:	fb0c 6619 	mls	r6, ip, r9, r6
    5e4c:	fa1f f883 	uxth.w	r8, r3
    5e50:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
    5e54:	fb09 f708 	mul.w	r7, r9, r8
    5e58:	42b7      	cmp	r7, r6
    5e5a:	fa02 f201 	lsl.w	r2, r2, r1
    5e5e:	fa00 fa01 	lsl.w	sl, r0, r1
    5e62:	d908      	bls.n	5e76 <__udivmoddi4+0x242>
    5e64:	18f6      	adds	r6, r6, r3
    5e66:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    5e6a:	d241      	bcs.n	5ef0 <__udivmoddi4+0x2bc>
    5e6c:	42b7      	cmp	r7, r6
    5e6e:	d93f      	bls.n	5ef0 <__udivmoddi4+0x2bc>
    5e70:	f1a9 0902 	sub.w	r9, r9, #2
    5e74:	441e      	add	r6, r3
    5e76:	1bf6      	subs	r6, r6, r7
    5e78:	b2a0      	uxth	r0, r4
    5e7a:	fbb6 f4fc 	udiv	r4, r6, ip
    5e7e:	fb0c 6614 	mls	r6, ip, r4, r6
    5e82:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
    5e86:	fb04 f808 	mul.w	r8, r4, r8
    5e8a:	45b8      	cmp	r8, r7
    5e8c:	d907      	bls.n	5e9e <__udivmoddi4+0x26a>
    5e8e:	18ff      	adds	r7, r7, r3
    5e90:	f104 30ff 	add.w	r0, r4, #4294967295	; 0xffffffff
    5e94:	d228      	bcs.n	5ee8 <__udivmoddi4+0x2b4>
    5e96:	45b8      	cmp	r8, r7
    5e98:	d926      	bls.n	5ee8 <__udivmoddi4+0x2b4>
    5e9a:	3c02      	subs	r4, #2
    5e9c:	441f      	add	r7, r3
    5e9e:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
    5ea2:	ebc8 0707 	rsb	r7, r8, r7
    5ea6:	fba0 8902 	umull	r8, r9, r0, r2
    5eaa:	454f      	cmp	r7, r9
    5eac:	4644      	mov	r4, r8
    5eae:	464e      	mov	r6, r9
    5eb0:	d314      	bcc.n	5edc <__udivmoddi4+0x2a8>
    5eb2:	d029      	beq.n	5f08 <__udivmoddi4+0x2d4>
    5eb4:	b365      	cbz	r5, 5f10 <__udivmoddi4+0x2dc>
    5eb6:	ebba 0304 	subs.w	r3, sl, r4
    5eba:	eb67 0706 	sbc.w	r7, r7, r6
    5ebe:	fa07 fe0e 	lsl.w	lr, r7, lr
    5ec2:	40cb      	lsrs	r3, r1
    5ec4:	40cf      	lsrs	r7, r1
    5ec6:	ea4e 0303 	orr.w	r3, lr, r3
    5eca:	e885 0088 	stmia.w	r5, {r3, r7}
    5ece:	2100      	movs	r1, #0
    5ed0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5ed4:	4613      	mov	r3, r2
    5ed6:	e6f8      	b.n	5cca <__udivmoddi4+0x96>
    5ed8:	4610      	mov	r0, r2
    5eda:	e6e0      	b.n	5c9e <__udivmoddi4+0x6a>
    5edc:	ebb8 0402 	subs.w	r4, r8, r2
    5ee0:	eb69 0603 	sbc.w	r6, r9, r3
    5ee4:	3801      	subs	r0, #1
    5ee6:	e7e5      	b.n	5eb4 <__udivmoddi4+0x280>
    5ee8:	4604      	mov	r4, r0
    5eea:	e7d8      	b.n	5e9e <__udivmoddi4+0x26a>
    5eec:	4611      	mov	r1, r2
    5eee:	e795      	b.n	5e1c <__udivmoddi4+0x1e8>
    5ef0:	4681      	mov	r9, r0
    5ef2:	e7c0      	b.n	5e76 <__udivmoddi4+0x242>
    5ef4:	468a      	mov	sl, r1
    5ef6:	e77c      	b.n	5df2 <__udivmoddi4+0x1be>
    5ef8:	3b02      	subs	r3, #2
    5efa:	443c      	add	r4, r7
    5efc:	e748      	b.n	5d90 <__udivmoddi4+0x15c>
    5efe:	4608      	mov	r0, r1
    5f00:	e70a      	b.n	5d18 <__udivmoddi4+0xe4>
    5f02:	3802      	subs	r0, #2
    5f04:	443e      	add	r6, r7
    5f06:	e72f      	b.n	5d68 <__udivmoddi4+0x134>
    5f08:	45c2      	cmp	sl, r8
    5f0a:	d3e7      	bcc.n	5edc <__udivmoddi4+0x2a8>
    5f0c:	463e      	mov	r6, r7
    5f0e:	e7d1      	b.n	5eb4 <__udivmoddi4+0x280>
    5f10:	4629      	mov	r1, r5
    5f12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5f16:	bf00      	nop

00005f18 <__aeabi_idiv0>:
    5f18:	4770      	bx	lr
    5f1a:	bf00      	nop

00005f1c <__cxa_atexit>:
    5f1c:	4613      	mov	r3, r2
    5f1e:	460a      	mov	r2, r1
    5f20:	4601      	mov	r1, r0
    5f22:	2002      	movs	r0, #2
    5f24:	f001 b944 	b.w	71b0 <__register_exitproc>

00005f28 <__errno>:
    5f28:	4b01      	ldr	r3, [pc, #4]	; (5f30 <__errno+0x8>)
    5f2a:	6818      	ldr	r0, [r3, #0]
    5f2c:	4770      	bx	lr
    5f2e:	bf00      	nop
    5f30:	20001d90 	.word	0x20001d90

00005f34 <exit>:
    5f34:	b508      	push	{r3, lr}
    5f36:	2100      	movs	r1, #0
    5f38:	4604      	mov	r4, r0
    5f3a:	f001 f98b 	bl	7254 <__call_exitprocs>
    5f3e:	4b04      	ldr	r3, [pc, #16]	; (5f50 <exit+0x1c>)
    5f40:	6818      	ldr	r0, [r3, #0]
    5f42:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    5f44:	b103      	cbz	r3, 5f48 <exit+0x14>
    5f46:	4798      	blx	r3
    5f48:	4620      	mov	r0, r4
    5f4a:	f7fb fca5 	bl	1898 <_exit>
    5f4e:	bf00      	nop
    5f50:	200006c8 	.word	0x200006c8

00005f54 <__libc_init_array>:
    5f54:	b570      	push	{r4, r5, r6, lr}
    5f56:	4e0f      	ldr	r6, [pc, #60]	; (5f94 <__libc_init_array+0x40>)
    5f58:	4d0f      	ldr	r5, [pc, #60]	; (5f98 <__libc_init_array+0x44>)
    5f5a:	1b76      	subs	r6, r6, r5
    5f5c:	10b6      	asrs	r6, r6, #2
    5f5e:	bf18      	it	ne
    5f60:	2400      	movne	r4, #0
    5f62:	d005      	beq.n	5f70 <__libc_init_array+0x1c>
    5f64:	3401      	adds	r4, #1
    5f66:	f855 3b04 	ldr.w	r3, [r5], #4
    5f6a:	4798      	blx	r3
    5f6c:	42a6      	cmp	r6, r4
    5f6e:	d1f9      	bne.n	5f64 <__libc_init_array+0x10>
    5f70:	4e0a      	ldr	r6, [pc, #40]	; (5f9c <__libc_init_array+0x48>)
    5f72:	4d0b      	ldr	r5, [pc, #44]	; (5fa0 <__libc_init_array+0x4c>)
    5f74:	1b76      	subs	r6, r6, r5
    5f76:	f004 f8f7 	bl	a168 <___init_veneer>
    5f7a:	10b6      	asrs	r6, r6, #2
    5f7c:	bf18      	it	ne
    5f7e:	2400      	movne	r4, #0
    5f80:	d006      	beq.n	5f90 <__libc_init_array+0x3c>
    5f82:	3401      	adds	r4, #1
    5f84:	f855 3b04 	ldr.w	r3, [r5], #4
    5f88:	4798      	blx	r3
    5f8a:	42a6      	cmp	r6, r4
    5f8c:	d1f9      	bne.n	5f82 <__libc_init_array+0x2e>
    5f8e:	bd70      	pop	{r4, r5, r6, pc}
    5f90:	bd70      	pop	{r4, r5, r6, pc}
    5f92:	bf00      	nop
    5f94:	60002098 	.word	0x60002098
    5f98:	60002098 	.word	0x60002098
    5f9c:	600020a0 	.word	0x600020a0
    5fa0:	60002098 	.word	0x60002098

00005fa4 <malloc>:
    5fa4:	4b02      	ldr	r3, [pc, #8]	; (5fb0 <malloc+0xc>)
    5fa6:	4601      	mov	r1, r0
    5fa8:	6818      	ldr	r0, [r3, #0]
    5faa:	f000 b80b 	b.w	5fc4 <_malloc_r>
    5fae:	bf00      	nop
    5fb0:	20001d90 	.word	0x20001d90

00005fb4 <free>:
    5fb4:	4b02      	ldr	r3, [pc, #8]	; (5fc0 <free+0xc>)
    5fb6:	4601      	mov	r1, r0
    5fb8:	6818      	ldr	r0, [r3, #0]
    5fba:	f001 ba05 	b.w	73c8 <_free_r>
    5fbe:	bf00      	nop
    5fc0:	20001d90 	.word	0x20001d90

00005fc4 <_malloc_r>:
    5fc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5fc8:	f101 050b 	add.w	r5, r1, #11
    5fcc:	2d16      	cmp	r5, #22
    5fce:	b083      	sub	sp, #12
    5fd0:	4606      	mov	r6, r0
    5fd2:	f240 809f 	bls.w	6114 <_malloc_r+0x150>
    5fd6:	f035 0507 	bics.w	r5, r5, #7
    5fda:	f100 80bf 	bmi.w	615c <_malloc_r+0x198>
    5fde:	42a9      	cmp	r1, r5
    5fe0:	f200 80bc 	bhi.w	615c <_malloc_r+0x198>
    5fe4:	f000 fc08 	bl	67f8 <__malloc_lock>
    5fe8:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    5fec:	f0c0 829c 	bcc.w	6528 <_malloc_r+0x564>
    5ff0:	0a6b      	lsrs	r3, r5, #9
    5ff2:	f000 80ba 	beq.w	616a <_malloc_r+0x1a6>
    5ff6:	2b04      	cmp	r3, #4
    5ff8:	f200 8183 	bhi.w	6302 <_malloc_r+0x33e>
    5ffc:	09a8      	lsrs	r0, r5, #6
    5ffe:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    6002:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6006:	3038      	adds	r0, #56	; 0x38
    6008:	4fc4      	ldr	r7, [pc, #784]	; (631c <_malloc_r+0x358>)
    600a:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    600e:	f1a3 0108 	sub.w	r1, r3, #8
    6012:	685c      	ldr	r4, [r3, #4]
    6014:	42a1      	cmp	r1, r4
    6016:	d107      	bne.n	6028 <_malloc_r+0x64>
    6018:	e0ac      	b.n	6174 <_malloc_r+0x1b0>
    601a:	2a00      	cmp	r2, #0
    601c:	f280 80ac 	bge.w	6178 <_malloc_r+0x1b4>
    6020:	68e4      	ldr	r4, [r4, #12]
    6022:	42a1      	cmp	r1, r4
    6024:	f000 80a6 	beq.w	6174 <_malloc_r+0x1b0>
    6028:	6863      	ldr	r3, [r4, #4]
    602a:	f023 0303 	bic.w	r3, r3, #3
    602e:	1b5a      	subs	r2, r3, r5
    6030:	2a0f      	cmp	r2, #15
    6032:	ddf2      	ble.n	601a <_malloc_r+0x56>
    6034:	49b9      	ldr	r1, [pc, #740]	; (631c <_malloc_r+0x358>)
    6036:	693c      	ldr	r4, [r7, #16]
    6038:	f101 0e08 	add.w	lr, r1, #8
    603c:	4574      	cmp	r4, lr
    603e:	f000 81b3 	beq.w	63a8 <_malloc_r+0x3e4>
    6042:	6863      	ldr	r3, [r4, #4]
    6044:	f023 0303 	bic.w	r3, r3, #3
    6048:	1b5a      	subs	r2, r3, r5
    604a:	2a0f      	cmp	r2, #15
    604c:	f300 8199 	bgt.w	6382 <_malloc_r+0x3be>
    6050:	2a00      	cmp	r2, #0
    6052:	f8c1 e014 	str.w	lr, [r1, #20]
    6056:	f8c1 e010 	str.w	lr, [r1, #16]
    605a:	f280 809e 	bge.w	619a <_malloc_r+0x1d6>
    605e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    6062:	f080 8167 	bcs.w	6334 <_malloc_r+0x370>
    6066:	08db      	lsrs	r3, r3, #3
    6068:	f103 0c01 	add.w	ip, r3, #1
    606c:	2201      	movs	r2, #1
    606e:	109b      	asrs	r3, r3, #2
    6070:	fa02 f303 	lsl.w	r3, r2, r3
    6074:	684a      	ldr	r2, [r1, #4]
    6076:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    607a:	f8c4 8008 	str.w	r8, [r4, #8]
    607e:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    6082:	431a      	orrs	r2, r3
    6084:	f1a9 0308 	sub.w	r3, r9, #8
    6088:	60e3      	str	r3, [r4, #12]
    608a:	604a      	str	r2, [r1, #4]
    608c:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    6090:	f8c8 400c 	str.w	r4, [r8, #12]
    6094:	1083      	asrs	r3, r0, #2
    6096:	2401      	movs	r4, #1
    6098:	409c      	lsls	r4, r3
    609a:	4294      	cmp	r4, r2
    609c:	f200 808a 	bhi.w	61b4 <_malloc_r+0x1f0>
    60a0:	4214      	tst	r4, r2
    60a2:	d106      	bne.n	60b2 <_malloc_r+0xee>
    60a4:	f020 0003 	bic.w	r0, r0, #3
    60a8:	0064      	lsls	r4, r4, #1
    60aa:	4214      	tst	r4, r2
    60ac:	f100 0004 	add.w	r0, r0, #4
    60b0:	d0fa      	beq.n	60a8 <_malloc_r+0xe4>
    60b2:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    60b6:	46cc      	mov	ip, r9
    60b8:	4680      	mov	r8, r0
    60ba:	f8dc 100c 	ldr.w	r1, [ip, #12]
    60be:	458c      	cmp	ip, r1
    60c0:	d107      	bne.n	60d2 <_malloc_r+0x10e>
    60c2:	e173      	b.n	63ac <_malloc_r+0x3e8>
    60c4:	2a00      	cmp	r2, #0
    60c6:	f280 8181 	bge.w	63cc <_malloc_r+0x408>
    60ca:	68c9      	ldr	r1, [r1, #12]
    60cc:	458c      	cmp	ip, r1
    60ce:	f000 816d 	beq.w	63ac <_malloc_r+0x3e8>
    60d2:	684b      	ldr	r3, [r1, #4]
    60d4:	f023 0303 	bic.w	r3, r3, #3
    60d8:	1b5a      	subs	r2, r3, r5
    60da:	2a0f      	cmp	r2, #15
    60dc:	ddf2      	ble.n	60c4 <_malloc_r+0x100>
    60de:	460c      	mov	r4, r1
    60e0:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    60e4:	f854 8f08 	ldr.w	r8, [r4, #8]!
    60e8:	194b      	adds	r3, r1, r5
    60ea:	f045 0501 	orr.w	r5, r5, #1
    60ee:	604d      	str	r5, [r1, #4]
    60f0:	f042 0101 	orr.w	r1, r2, #1
    60f4:	f8c8 c00c 	str.w	ip, [r8, #12]
    60f8:	4630      	mov	r0, r6
    60fa:	f8cc 8008 	str.w	r8, [ip, #8]
    60fe:	617b      	str	r3, [r7, #20]
    6100:	613b      	str	r3, [r7, #16]
    6102:	f8c3 e00c 	str.w	lr, [r3, #12]
    6106:	f8c3 e008 	str.w	lr, [r3, #8]
    610a:	6059      	str	r1, [r3, #4]
    610c:	509a      	str	r2, [r3, r2]
    610e:	f000 fb75 	bl	67fc <__malloc_unlock>
    6112:	e01f      	b.n	6154 <_malloc_r+0x190>
    6114:	2910      	cmp	r1, #16
    6116:	d821      	bhi.n	615c <_malloc_r+0x198>
    6118:	f000 fb6e 	bl	67f8 <__malloc_lock>
    611c:	2510      	movs	r5, #16
    611e:	2306      	movs	r3, #6
    6120:	2002      	movs	r0, #2
    6122:	4f7e      	ldr	r7, [pc, #504]	; (631c <_malloc_r+0x358>)
    6124:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    6128:	f1a3 0208 	sub.w	r2, r3, #8
    612c:	685c      	ldr	r4, [r3, #4]
    612e:	4294      	cmp	r4, r2
    6130:	f000 8145 	beq.w	63be <_malloc_r+0x3fa>
    6134:	6863      	ldr	r3, [r4, #4]
    6136:	68e1      	ldr	r1, [r4, #12]
    6138:	68a5      	ldr	r5, [r4, #8]
    613a:	f023 0303 	bic.w	r3, r3, #3
    613e:	4423      	add	r3, r4
    6140:	4630      	mov	r0, r6
    6142:	685a      	ldr	r2, [r3, #4]
    6144:	60e9      	str	r1, [r5, #12]
    6146:	f042 0201 	orr.w	r2, r2, #1
    614a:	608d      	str	r5, [r1, #8]
    614c:	605a      	str	r2, [r3, #4]
    614e:	f000 fb55 	bl	67fc <__malloc_unlock>
    6152:	3408      	adds	r4, #8
    6154:	4620      	mov	r0, r4
    6156:	b003      	add	sp, #12
    6158:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    615c:	2400      	movs	r4, #0
    615e:	230c      	movs	r3, #12
    6160:	4620      	mov	r0, r4
    6162:	6033      	str	r3, [r6, #0]
    6164:	b003      	add	sp, #12
    6166:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    616a:	2380      	movs	r3, #128	; 0x80
    616c:	f04f 0e40 	mov.w	lr, #64	; 0x40
    6170:	203f      	movs	r0, #63	; 0x3f
    6172:	e749      	b.n	6008 <_malloc_r+0x44>
    6174:	4670      	mov	r0, lr
    6176:	e75d      	b.n	6034 <_malloc_r+0x70>
    6178:	4423      	add	r3, r4
    617a:	68e1      	ldr	r1, [r4, #12]
    617c:	685a      	ldr	r2, [r3, #4]
    617e:	68a5      	ldr	r5, [r4, #8]
    6180:	f042 0201 	orr.w	r2, r2, #1
    6184:	60e9      	str	r1, [r5, #12]
    6186:	4630      	mov	r0, r6
    6188:	608d      	str	r5, [r1, #8]
    618a:	605a      	str	r2, [r3, #4]
    618c:	f000 fb36 	bl	67fc <__malloc_unlock>
    6190:	3408      	adds	r4, #8
    6192:	4620      	mov	r0, r4
    6194:	b003      	add	sp, #12
    6196:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    619a:	4423      	add	r3, r4
    619c:	4630      	mov	r0, r6
    619e:	685a      	ldr	r2, [r3, #4]
    61a0:	f042 0201 	orr.w	r2, r2, #1
    61a4:	605a      	str	r2, [r3, #4]
    61a6:	f000 fb29 	bl	67fc <__malloc_unlock>
    61aa:	3408      	adds	r4, #8
    61ac:	4620      	mov	r0, r4
    61ae:	b003      	add	sp, #12
    61b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    61b4:	68bc      	ldr	r4, [r7, #8]
    61b6:	6863      	ldr	r3, [r4, #4]
    61b8:	f023 0803 	bic.w	r8, r3, #3
    61bc:	45a8      	cmp	r8, r5
    61be:	d304      	bcc.n	61ca <_malloc_r+0x206>
    61c0:	ebc5 0308 	rsb	r3, r5, r8
    61c4:	2b0f      	cmp	r3, #15
    61c6:	f300 808c 	bgt.w	62e2 <_malloc_r+0x31e>
    61ca:	4b55      	ldr	r3, [pc, #340]	; (6320 <_malloc_r+0x35c>)
    61cc:	f8df 9160 	ldr.w	r9, [pc, #352]	; 6330 <_malloc_r+0x36c>
    61d0:	681a      	ldr	r2, [r3, #0]
    61d2:	f8d9 3000 	ldr.w	r3, [r9]
    61d6:	3301      	adds	r3, #1
    61d8:	442a      	add	r2, r5
    61da:	eb04 0a08 	add.w	sl, r4, r8
    61de:	f000 8160 	beq.w	64a2 <_malloc_r+0x4de>
    61e2:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    61e6:	320f      	adds	r2, #15
    61e8:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    61ec:	f022 020f 	bic.w	r2, r2, #15
    61f0:	4611      	mov	r1, r2
    61f2:	4630      	mov	r0, r6
    61f4:	9201      	str	r2, [sp, #4]
    61f6:	f000 fcfb 	bl	6bf0 <_sbrk_r>
    61fa:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    61fe:	4683      	mov	fp, r0
    6200:	9a01      	ldr	r2, [sp, #4]
    6202:	f000 8158 	beq.w	64b6 <_malloc_r+0x4f2>
    6206:	4582      	cmp	sl, r0
    6208:	f200 80fc 	bhi.w	6404 <_malloc_r+0x440>
    620c:	4b45      	ldr	r3, [pc, #276]	; (6324 <_malloc_r+0x360>)
    620e:	6819      	ldr	r1, [r3, #0]
    6210:	45da      	cmp	sl, fp
    6212:	4411      	add	r1, r2
    6214:	6019      	str	r1, [r3, #0]
    6216:	f000 8153 	beq.w	64c0 <_malloc_r+0x4fc>
    621a:	f8d9 0000 	ldr.w	r0, [r9]
    621e:	f8df e110 	ldr.w	lr, [pc, #272]	; 6330 <_malloc_r+0x36c>
    6222:	3001      	adds	r0, #1
    6224:	bf1b      	ittet	ne
    6226:	ebca 0a0b 	rsbne	sl, sl, fp
    622a:	4451      	addne	r1, sl
    622c:	f8ce b000 	streq.w	fp, [lr]
    6230:	6019      	strne	r1, [r3, #0]
    6232:	f01b 0107 	ands.w	r1, fp, #7
    6236:	f000 8117 	beq.w	6468 <_malloc_r+0x4a4>
    623a:	f1c1 0008 	rsb	r0, r1, #8
    623e:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    6242:	4483      	add	fp, r0
    6244:	3108      	adds	r1, #8
    6246:	445a      	add	r2, fp
    6248:	f3c2 020b 	ubfx	r2, r2, #0, #12
    624c:	ebc2 0901 	rsb	r9, r2, r1
    6250:	4649      	mov	r1, r9
    6252:	4630      	mov	r0, r6
    6254:	9301      	str	r3, [sp, #4]
    6256:	f000 fccb 	bl	6bf0 <_sbrk_r>
    625a:	1c43      	adds	r3, r0, #1
    625c:	9b01      	ldr	r3, [sp, #4]
    625e:	f000 813f 	beq.w	64e0 <_malloc_r+0x51c>
    6262:	ebcb 0200 	rsb	r2, fp, r0
    6266:	444a      	add	r2, r9
    6268:	f042 0201 	orr.w	r2, r2, #1
    626c:	6819      	ldr	r1, [r3, #0]
    626e:	f8c7 b008 	str.w	fp, [r7, #8]
    6272:	4449      	add	r1, r9
    6274:	42bc      	cmp	r4, r7
    6276:	f8cb 2004 	str.w	r2, [fp, #4]
    627a:	6019      	str	r1, [r3, #0]
    627c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 6324 <_malloc_r+0x360>
    6280:	d016      	beq.n	62b0 <_malloc_r+0x2ec>
    6282:	f1b8 0f0f 	cmp.w	r8, #15
    6286:	f240 80fd 	bls.w	6484 <_malloc_r+0x4c0>
    628a:	6862      	ldr	r2, [r4, #4]
    628c:	f1a8 030c 	sub.w	r3, r8, #12
    6290:	f023 0307 	bic.w	r3, r3, #7
    6294:	18e0      	adds	r0, r4, r3
    6296:	f002 0201 	and.w	r2, r2, #1
    629a:	f04f 0e05 	mov.w	lr, #5
    629e:	431a      	orrs	r2, r3
    62a0:	2b0f      	cmp	r3, #15
    62a2:	6062      	str	r2, [r4, #4]
    62a4:	f8c0 e004 	str.w	lr, [r0, #4]
    62a8:	f8c0 e008 	str.w	lr, [r0, #8]
    62ac:	f200 811c 	bhi.w	64e8 <_malloc_r+0x524>
    62b0:	4b1d      	ldr	r3, [pc, #116]	; (6328 <_malloc_r+0x364>)
    62b2:	68bc      	ldr	r4, [r7, #8]
    62b4:	681a      	ldr	r2, [r3, #0]
    62b6:	4291      	cmp	r1, r2
    62b8:	bf88      	it	hi
    62ba:	6019      	strhi	r1, [r3, #0]
    62bc:	4b1b      	ldr	r3, [pc, #108]	; (632c <_malloc_r+0x368>)
    62be:	681a      	ldr	r2, [r3, #0]
    62c0:	4291      	cmp	r1, r2
    62c2:	6862      	ldr	r2, [r4, #4]
    62c4:	bf88      	it	hi
    62c6:	6019      	strhi	r1, [r3, #0]
    62c8:	f022 0203 	bic.w	r2, r2, #3
    62cc:	4295      	cmp	r5, r2
    62ce:	eba2 0305 	sub.w	r3, r2, r5
    62d2:	d801      	bhi.n	62d8 <_malloc_r+0x314>
    62d4:	2b0f      	cmp	r3, #15
    62d6:	dc04      	bgt.n	62e2 <_malloc_r+0x31e>
    62d8:	4630      	mov	r0, r6
    62da:	f000 fa8f 	bl	67fc <__malloc_unlock>
    62de:	2400      	movs	r4, #0
    62e0:	e738      	b.n	6154 <_malloc_r+0x190>
    62e2:	1962      	adds	r2, r4, r5
    62e4:	f043 0301 	orr.w	r3, r3, #1
    62e8:	f045 0501 	orr.w	r5, r5, #1
    62ec:	6065      	str	r5, [r4, #4]
    62ee:	4630      	mov	r0, r6
    62f0:	60ba      	str	r2, [r7, #8]
    62f2:	6053      	str	r3, [r2, #4]
    62f4:	f000 fa82 	bl	67fc <__malloc_unlock>
    62f8:	3408      	adds	r4, #8
    62fa:	4620      	mov	r0, r4
    62fc:	b003      	add	sp, #12
    62fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6302:	2b14      	cmp	r3, #20
    6304:	d971      	bls.n	63ea <_malloc_r+0x426>
    6306:	2b54      	cmp	r3, #84	; 0x54
    6308:	f200 80a4 	bhi.w	6454 <_malloc_r+0x490>
    630c:	0b28      	lsrs	r0, r5, #12
    630e:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    6312:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6316:	306e      	adds	r0, #110	; 0x6e
    6318:	e676      	b.n	6008 <_malloc_r+0x44>
    631a:	bf00      	nop
    631c:	20001980 	.word	0x20001980
    6320:	200026e4 	.word	0x200026e4
    6324:	200026b4 	.word	0x200026b4
    6328:	200026dc 	.word	0x200026dc
    632c:	200026e0 	.word	0x200026e0
    6330:	20001d88 	.word	0x20001d88
    6334:	0a5a      	lsrs	r2, r3, #9
    6336:	2a04      	cmp	r2, #4
    6338:	d95e      	bls.n	63f8 <_malloc_r+0x434>
    633a:	2a14      	cmp	r2, #20
    633c:	f200 80b3 	bhi.w	64a6 <_malloc_r+0x4e2>
    6340:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    6344:	0049      	lsls	r1, r1, #1
    6346:	325b      	adds	r2, #91	; 0x5b
    6348:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    634c:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    6350:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 6530 <_malloc_r+0x56c>
    6354:	f1ac 0c08 	sub.w	ip, ip, #8
    6358:	458c      	cmp	ip, r1
    635a:	f000 8088 	beq.w	646e <_malloc_r+0x4aa>
    635e:	684a      	ldr	r2, [r1, #4]
    6360:	f022 0203 	bic.w	r2, r2, #3
    6364:	4293      	cmp	r3, r2
    6366:	d202      	bcs.n	636e <_malloc_r+0x3aa>
    6368:	6889      	ldr	r1, [r1, #8]
    636a:	458c      	cmp	ip, r1
    636c:	d1f7      	bne.n	635e <_malloc_r+0x39a>
    636e:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    6372:	687a      	ldr	r2, [r7, #4]
    6374:	f8c4 c00c 	str.w	ip, [r4, #12]
    6378:	60a1      	str	r1, [r4, #8]
    637a:	f8cc 4008 	str.w	r4, [ip, #8]
    637e:	60cc      	str	r4, [r1, #12]
    6380:	e688      	b.n	6094 <_malloc_r+0xd0>
    6382:	1963      	adds	r3, r4, r5
    6384:	f042 0701 	orr.w	r7, r2, #1
    6388:	f045 0501 	orr.w	r5, r5, #1
    638c:	6065      	str	r5, [r4, #4]
    638e:	4630      	mov	r0, r6
    6390:	614b      	str	r3, [r1, #20]
    6392:	610b      	str	r3, [r1, #16]
    6394:	f8c3 e00c 	str.w	lr, [r3, #12]
    6398:	f8c3 e008 	str.w	lr, [r3, #8]
    639c:	605f      	str	r7, [r3, #4]
    639e:	509a      	str	r2, [r3, r2]
    63a0:	3408      	adds	r4, #8
    63a2:	f000 fa2b 	bl	67fc <__malloc_unlock>
    63a6:	e6d5      	b.n	6154 <_malloc_r+0x190>
    63a8:	684a      	ldr	r2, [r1, #4]
    63aa:	e673      	b.n	6094 <_malloc_r+0xd0>
    63ac:	f108 0801 	add.w	r8, r8, #1
    63b0:	f018 0f03 	tst.w	r8, #3
    63b4:	f10c 0c08 	add.w	ip, ip, #8
    63b8:	f47f ae7f 	bne.w	60ba <_malloc_r+0xf6>
    63bc:	e030      	b.n	6420 <_malloc_r+0x45c>
    63be:	68dc      	ldr	r4, [r3, #12]
    63c0:	42a3      	cmp	r3, r4
    63c2:	bf08      	it	eq
    63c4:	3002      	addeq	r0, #2
    63c6:	f43f ae35 	beq.w	6034 <_malloc_r+0x70>
    63ca:	e6b3      	b.n	6134 <_malloc_r+0x170>
    63cc:	440b      	add	r3, r1
    63ce:	460c      	mov	r4, r1
    63d0:	685a      	ldr	r2, [r3, #4]
    63d2:	68c9      	ldr	r1, [r1, #12]
    63d4:	f854 5f08 	ldr.w	r5, [r4, #8]!
    63d8:	f042 0201 	orr.w	r2, r2, #1
    63dc:	605a      	str	r2, [r3, #4]
    63de:	4630      	mov	r0, r6
    63e0:	60e9      	str	r1, [r5, #12]
    63e2:	608d      	str	r5, [r1, #8]
    63e4:	f000 fa0a 	bl	67fc <__malloc_unlock>
    63e8:	e6b4      	b.n	6154 <_malloc_r+0x190>
    63ea:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    63ee:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    63f2:	ea4f 034e 	mov.w	r3, lr, lsl #1
    63f6:	e607      	b.n	6008 <_malloc_r+0x44>
    63f8:	099a      	lsrs	r2, r3, #6
    63fa:	f102 0139 	add.w	r1, r2, #57	; 0x39
    63fe:	0049      	lsls	r1, r1, #1
    6400:	3238      	adds	r2, #56	; 0x38
    6402:	e7a1      	b.n	6348 <_malloc_r+0x384>
    6404:	42bc      	cmp	r4, r7
    6406:	4b4a      	ldr	r3, [pc, #296]	; (6530 <_malloc_r+0x56c>)
    6408:	f43f af00 	beq.w	620c <_malloc_r+0x248>
    640c:	689c      	ldr	r4, [r3, #8]
    640e:	6862      	ldr	r2, [r4, #4]
    6410:	f022 0203 	bic.w	r2, r2, #3
    6414:	e75a      	b.n	62cc <_malloc_r+0x308>
    6416:	f859 3908 	ldr.w	r3, [r9], #-8
    641a:	4599      	cmp	r9, r3
    641c:	f040 8082 	bne.w	6524 <_malloc_r+0x560>
    6420:	f010 0f03 	tst.w	r0, #3
    6424:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    6428:	d1f5      	bne.n	6416 <_malloc_r+0x452>
    642a:	687b      	ldr	r3, [r7, #4]
    642c:	ea23 0304 	bic.w	r3, r3, r4
    6430:	607b      	str	r3, [r7, #4]
    6432:	0064      	lsls	r4, r4, #1
    6434:	429c      	cmp	r4, r3
    6436:	f63f aebd 	bhi.w	61b4 <_malloc_r+0x1f0>
    643a:	2c00      	cmp	r4, #0
    643c:	f43f aeba 	beq.w	61b4 <_malloc_r+0x1f0>
    6440:	421c      	tst	r4, r3
    6442:	4640      	mov	r0, r8
    6444:	f47f ae35 	bne.w	60b2 <_malloc_r+0xee>
    6448:	0064      	lsls	r4, r4, #1
    644a:	421c      	tst	r4, r3
    644c:	f100 0004 	add.w	r0, r0, #4
    6450:	d0fa      	beq.n	6448 <_malloc_r+0x484>
    6452:	e62e      	b.n	60b2 <_malloc_r+0xee>
    6454:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    6458:	d818      	bhi.n	648c <_malloc_r+0x4c8>
    645a:	0be8      	lsrs	r0, r5, #15
    645c:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    6460:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6464:	3077      	adds	r0, #119	; 0x77
    6466:	e5cf      	b.n	6008 <_malloc_r+0x44>
    6468:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    646c:	e6eb      	b.n	6246 <_malloc_r+0x282>
    646e:	2101      	movs	r1, #1
    6470:	f8d8 3004 	ldr.w	r3, [r8, #4]
    6474:	1092      	asrs	r2, r2, #2
    6476:	fa01 f202 	lsl.w	r2, r1, r2
    647a:	431a      	orrs	r2, r3
    647c:	f8c8 2004 	str.w	r2, [r8, #4]
    6480:	4661      	mov	r1, ip
    6482:	e777      	b.n	6374 <_malloc_r+0x3b0>
    6484:	2301      	movs	r3, #1
    6486:	f8cb 3004 	str.w	r3, [fp, #4]
    648a:	e725      	b.n	62d8 <_malloc_r+0x314>
    648c:	f240 5254 	movw	r2, #1364	; 0x554
    6490:	4293      	cmp	r3, r2
    6492:	d820      	bhi.n	64d6 <_malloc_r+0x512>
    6494:	0ca8      	lsrs	r0, r5, #18
    6496:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    649a:	ea4f 034e 	mov.w	r3, lr, lsl #1
    649e:	307c      	adds	r0, #124	; 0x7c
    64a0:	e5b2      	b.n	6008 <_malloc_r+0x44>
    64a2:	3210      	adds	r2, #16
    64a4:	e6a4      	b.n	61f0 <_malloc_r+0x22c>
    64a6:	2a54      	cmp	r2, #84	; 0x54
    64a8:	d826      	bhi.n	64f8 <_malloc_r+0x534>
    64aa:	0b1a      	lsrs	r2, r3, #12
    64ac:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    64b0:	0049      	lsls	r1, r1, #1
    64b2:	326e      	adds	r2, #110	; 0x6e
    64b4:	e748      	b.n	6348 <_malloc_r+0x384>
    64b6:	68bc      	ldr	r4, [r7, #8]
    64b8:	6862      	ldr	r2, [r4, #4]
    64ba:	f022 0203 	bic.w	r2, r2, #3
    64be:	e705      	b.n	62cc <_malloc_r+0x308>
    64c0:	f3ca 000b 	ubfx	r0, sl, #0, #12
    64c4:	2800      	cmp	r0, #0
    64c6:	f47f aea8 	bne.w	621a <_malloc_r+0x256>
    64ca:	4442      	add	r2, r8
    64cc:	68bb      	ldr	r3, [r7, #8]
    64ce:	f042 0201 	orr.w	r2, r2, #1
    64d2:	605a      	str	r2, [r3, #4]
    64d4:	e6ec      	b.n	62b0 <_malloc_r+0x2ec>
    64d6:	23fe      	movs	r3, #254	; 0xfe
    64d8:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    64dc:	207e      	movs	r0, #126	; 0x7e
    64de:	e593      	b.n	6008 <_malloc_r+0x44>
    64e0:	2201      	movs	r2, #1
    64e2:	f04f 0900 	mov.w	r9, #0
    64e6:	e6c1      	b.n	626c <_malloc_r+0x2a8>
    64e8:	f104 0108 	add.w	r1, r4, #8
    64ec:	4630      	mov	r0, r6
    64ee:	f000 ff6b 	bl	73c8 <_free_r>
    64f2:	f8d9 1000 	ldr.w	r1, [r9]
    64f6:	e6db      	b.n	62b0 <_malloc_r+0x2ec>
    64f8:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    64fc:	d805      	bhi.n	650a <_malloc_r+0x546>
    64fe:	0bda      	lsrs	r2, r3, #15
    6500:	f102 0178 	add.w	r1, r2, #120	; 0x78
    6504:	0049      	lsls	r1, r1, #1
    6506:	3277      	adds	r2, #119	; 0x77
    6508:	e71e      	b.n	6348 <_malloc_r+0x384>
    650a:	f240 5154 	movw	r1, #1364	; 0x554
    650e:	428a      	cmp	r2, r1
    6510:	d805      	bhi.n	651e <_malloc_r+0x55a>
    6512:	0c9a      	lsrs	r2, r3, #18
    6514:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    6518:	0049      	lsls	r1, r1, #1
    651a:	327c      	adds	r2, #124	; 0x7c
    651c:	e714      	b.n	6348 <_malloc_r+0x384>
    651e:	21fe      	movs	r1, #254	; 0xfe
    6520:	227e      	movs	r2, #126	; 0x7e
    6522:	e711      	b.n	6348 <_malloc_r+0x384>
    6524:	687b      	ldr	r3, [r7, #4]
    6526:	e784      	b.n	6432 <_malloc_r+0x46e>
    6528:	08e8      	lsrs	r0, r5, #3
    652a:	1c43      	adds	r3, r0, #1
    652c:	005b      	lsls	r3, r3, #1
    652e:	e5f8      	b.n	6122 <_malloc_r+0x15e>
    6530:	20001980 	.word	0x20001980

00006534 <__ascii_mbtowc>:
    6534:	b082      	sub	sp, #8
    6536:	b149      	cbz	r1, 654c <__ascii_mbtowc+0x18>
    6538:	b15a      	cbz	r2, 6552 <__ascii_mbtowc+0x1e>
    653a:	b16b      	cbz	r3, 6558 <__ascii_mbtowc+0x24>
    653c:	7813      	ldrb	r3, [r2, #0]
    653e:	600b      	str	r3, [r1, #0]
    6540:	7812      	ldrb	r2, [r2, #0]
    6542:	1c10      	adds	r0, r2, #0
    6544:	bf18      	it	ne
    6546:	2001      	movne	r0, #1
    6548:	b002      	add	sp, #8
    654a:	4770      	bx	lr
    654c:	a901      	add	r1, sp, #4
    654e:	2a00      	cmp	r2, #0
    6550:	d1f3      	bne.n	653a <__ascii_mbtowc+0x6>
    6552:	4610      	mov	r0, r2
    6554:	b002      	add	sp, #8
    6556:	4770      	bx	lr
    6558:	f06f 0001 	mvn.w	r0, #1
    655c:	e7f4      	b.n	6548 <__ascii_mbtowc+0x14>
    655e:	bf00      	nop

00006560 <memcpy>:
    6560:	4684      	mov	ip, r0
    6562:	ea41 0300 	orr.w	r3, r1, r0
    6566:	f013 0303 	ands.w	r3, r3, #3
    656a:	d16d      	bne.n	6648 <memcpy+0xe8>
    656c:	3a40      	subs	r2, #64	; 0x40
    656e:	d341      	bcc.n	65f4 <memcpy+0x94>
    6570:	f851 3b04 	ldr.w	r3, [r1], #4
    6574:	f840 3b04 	str.w	r3, [r0], #4
    6578:	f851 3b04 	ldr.w	r3, [r1], #4
    657c:	f840 3b04 	str.w	r3, [r0], #4
    6580:	f851 3b04 	ldr.w	r3, [r1], #4
    6584:	f840 3b04 	str.w	r3, [r0], #4
    6588:	f851 3b04 	ldr.w	r3, [r1], #4
    658c:	f840 3b04 	str.w	r3, [r0], #4
    6590:	f851 3b04 	ldr.w	r3, [r1], #4
    6594:	f840 3b04 	str.w	r3, [r0], #4
    6598:	f851 3b04 	ldr.w	r3, [r1], #4
    659c:	f840 3b04 	str.w	r3, [r0], #4
    65a0:	f851 3b04 	ldr.w	r3, [r1], #4
    65a4:	f840 3b04 	str.w	r3, [r0], #4
    65a8:	f851 3b04 	ldr.w	r3, [r1], #4
    65ac:	f840 3b04 	str.w	r3, [r0], #4
    65b0:	f851 3b04 	ldr.w	r3, [r1], #4
    65b4:	f840 3b04 	str.w	r3, [r0], #4
    65b8:	f851 3b04 	ldr.w	r3, [r1], #4
    65bc:	f840 3b04 	str.w	r3, [r0], #4
    65c0:	f851 3b04 	ldr.w	r3, [r1], #4
    65c4:	f840 3b04 	str.w	r3, [r0], #4
    65c8:	f851 3b04 	ldr.w	r3, [r1], #4
    65cc:	f840 3b04 	str.w	r3, [r0], #4
    65d0:	f851 3b04 	ldr.w	r3, [r1], #4
    65d4:	f840 3b04 	str.w	r3, [r0], #4
    65d8:	f851 3b04 	ldr.w	r3, [r1], #4
    65dc:	f840 3b04 	str.w	r3, [r0], #4
    65e0:	f851 3b04 	ldr.w	r3, [r1], #4
    65e4:	f840 3b04 	str.w	r3, [r0], #4
    65e8:	f851 3b04 	ldr.w	r3, [r1], #4
    65ec:	f840 3b04 	str.w	r3, [r0], #4
    65f0:	3a40      	subs	r2, #64	; 0x40
    65f2:	d2bd      	bcs.n	6570 <memcpy+0x10>
    65f4:	3230      	adds	r2, #48	; 0x30
    65f6:	d311      	bcc.n	661c <memcpy+0xbc>
    65f8:	f851 3b04 	ldr.w	r3, [r1], #4
    65fc:	f840 3b04 	str.w	r3, [r0], #4
    6600:	f851 3b04 	ldr.w	r3, [r1], #4
    6604:	f840 3b04 	str.w	r3, [r0], #4
    6608:	f851 3b04 	ldr.w	r3, [r1], #4
    660c:	f840 3b04 	str.w	r3, [r0], #4
    6610:	f851 3b04 	ldr.w	r3, [r1], #4
    6614:	f840 3b04 	str.w	r3, [r0], #4
    6618:	3a10      	subs	r2, #16
    661a:	d2ed      	bcs.n	65f8 <memcpy+0x98>
    661c:	320c      	adds	r2, #12
    661e:	d305      	bcc.n	662c <memcpy+0xcc>
    6620:	f851 3b04 	ldr.w	r3, [r1], #4
    6624:	f840 3b04 	str.w	r3, [r0], #4
    6628:	3a04      	subs	r2, #4
    662a:	d2f9      	bcs.n	6620 <memcpy+0xc0>
    662c:	3204      	adds	r2, #4
    662e:	d008      	beq.n	6642 <memcpy+0xe2>
    6630:	07d2      	lsls	r2, r2, #31
    6632:	bf1c      	itt	ne
    6634:	f811 3b01 	ldrbne.w	r3, [r1], #1
    6638:	f800 3b01 	strbne.w	r3, [r0], #1
    663c:	d301      	bcc.n	6642 <memcpy+0xe2>
    663e:	880b      	ldrh	r3, [r1, #0]
    6640:	8003      	strh	r3, [r0, #0]
    6642:	4660      	mov	r0, ip
    6644:	4770      	bx	lr
    6646:	bf00      	nop
    6648:	2a08      	cmp	r2, #8
    664a:	d313      	bcc.n	6674 <memcpy+0x114>
    664c:	078b      	lsls	r3, r1, #30
    664e:	d08d      	beq.n	656c <memcpy+0xc>
    6650:	f010 0303 	ands.w	r3, r0, #3
    6654:	d08a      	beq.n	656c <memcpy+0xc>
    6656:	f1c3 0304 	rsb	r3, r3, #4
    665a:	1ad2      	subs	r2, r2, r3
    665c:	07db      	lsls	r3, r3, #31
    665e:	bf1c      	itt	ne
    6660:	f811 3b01 	ldrbne.w	r3, [r1], #1
    6664:	f800 3b01 	strbne.w	r3, [r0], #1
    6668:	d380      	bcc.n	656c <memcpy+0xc>
    666a:	f831 3b02 	ldrh.w	r3, [r1], #2
    666e:	f820 3b02 	strh.w	r3, [r0], #2
    6672:	e77b      	b.n	656c <memcpy+0xc>
    6674:	3a04      	subs	r2, #4
    6676:	d3d9      	bcc.n	662c <memcpy+0xcc>
    6678:	3a01      	subs	r2, #1
    667a:	f811 3b01 	ldrb.w	r3, [r1], #1
    667e:	f800 3b01 	strb.w	r3, [r0], #1
    6682:	d2f9      	bcs.n	6678 <memcpy+0x118>
    6684:	780b      	ldrb	r3, [r1, #0]
    6686:	7003      	strb	r3, [r0, #0]
    6688:	784b      	ldrb	r3, [r1, #1]
    668a:	7043      	strb	r3, [r0, #1]
    668c:	788b      	ldrb	r3, [r1, #2]
    668e:	7083      	strb	r3, [r0, #2]
    6690:	4660      	mov	r0, ip
    6692:	4770      	bx	lr

00006694 <memmove>:
    6694:	4288      	cmp	r0, r1
    6696:	b5f0      	push	{r4, r5, r6, r7, lr}
    6698:	d90d      	bls.n	66b6 <memmove+0x22>
    669a:	188b      	adds	r3, r1, r2
    669c:	4298      	cmp	r0, r3
    669e:	d20a      	bcs.n	66b6 <memmove+0x22>
    66a0:	1881      	adds	r1, r0, r2
    66a2:	2a00      	cmp	r2, #0
    66a4:	d051      	beq.n	674a <memmove+0xb6>
    66a6:	1a9a      	subs	r2, r3, r2
    66a8:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    66ac:	f801 4d01 	strb.w	r4, [r1, #-1]!
    66b0:	4293      	cmp	r3, r2
    66b2:	d1f9      	bne.n	66a8 <memmove+0x14>
    66b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    66b6:	2a0f      	cmp	r2, #15
    66b8:	d948      	bls.n	674c <memmove+0xb8>
    66ba:	ea41 0300 	orr.w	r3, r1, r0
    66be:	079b      	lsls	r3, r3, #30
    66c0:	d146      	bne.n	6750 <memmove+0xbc>
    66c2:	f100 0410 	add.w	r4, r0, #16
    66c6:	f101 0310 	add.w	r3, r1, #16
    66ca:	4615      	mov	r5, r2
    66cc:	f853 6c10 	ldr.w	r6, [r3, #-16]
    66d0:	f844 6c10 	str.w	r6, [r4, #-16]
    66d4:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    66d8:	f844 6c0c 	str.w	r6, [r4, #-12]
    66dc:	f853 6c08 	ldr.w	r6, [r3, #-8]
    66e0:	f844 6c08 	str.w	r6, [r4, #-8]
    66e4:	3d10      	subs	r5, #16
    66e6:	f853 6c04 	ldr.w	r6, [r3, #-4]
    66ea:	f844 6c04 	str.w	r6, [r4, #-4]
    66ee:	2d0f      	cmp	r5, #15
    66f0:	f103 0310 	add.w	r3, r3, #16
    66f4:	f104 0410 	add.w	r4, r4, #16
    66f8:	d8e8      	bhi.n	66cc <memmove+0x38>
    66fa:	f1a2 0310 	sub.w	r3, r2, #16
    66fe:	f023 030f 	bic.w	r3, r3, #15
    6702:	f002 0e0f 	and.w	lr, r2, #15
    6706:	3310      	adds	r3, #16
    6708:	f1be 0f03 	cmp.w	lr, #3
    670c:	4419      	add	r1, r3
    670e:	4403      	add	r3, r0
    6710:	d921      	bls.n	6756 <memmove+0xc2>
    6712:	1f1e      	subs	r6, r3, #4
    6714:	460d      	mov	r5, r1
    6716:	4674      	mov	r4, lr
    6718:	3c04      	subs	r4, #4
    671a:	f855 7b04 	ldr.w	r7, [r5], #4
    671e:	f846 7f04 	str.w	r7, [r6, #4]!
    6722:	2c03      	cmp	r4, #3
    6724:	d8f8      	bhi.n	6718 <memmove+0x84>
    6726:	f1ae 0404 	sub.w	r4, lr, #4
    672a:	f024 0403 	bic.w	r4, r4, #3
    672e:	3404      	adds	r4, #4
    6730:	4423      	add	r3, r4
    6732:	4421      	add	r1, r4
    6734:	f002 0203 	and.w	r2, r2, #3
    6738:	b162      	cbz	r2, 6754 <memmove+0xc0>
    673a:	3b01      	subs	r3, #1
    673c:	440a      	add	r2, r1
    673e:	f811 4b01 	ldrb.w	r4, [r1], #1
    6742:	f803 4f01 	strb.w	r4, [r3, #1]!
    6746:	428a      	cmp	r2, r1
    6748:	d1f9      	bne.n	673e <memmove+0xaa>
    674a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    674c:	4603      	mov	r3, r0
    674e:	e7f3      	b.n	6738 <memmove+0xa4>
    6750:	4603      	mov	r3, r0
    6752:	e7f2      	b.n	673a <memmove+0xa6>
    6754:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6756:	4672      	mov	r2, lr
    6758:	e7ee      	b.n	6738 <memmove+0xa4>
    675a:	bf00      	nop

0000675c <memset>:
    675c:	b470      	push	{r4, r5, r6}
    675e:	0784      	lsls	r4, r0, #30
    6760:	d046      	beq.n	67f0 <memset+0x94>
    6762:	1e54      	subs	r4, r2, #1
    6764:	2a00      	cmp	r2, #0
    6766:	d041      	beq.n	67ec <memset+0x90>
    6768:	b2cd      	uxtb	r5, r1
    676a:	4603      	mov	r3, r0
    676c:	e002      	b.n	6774 <memset+0x18>
    676e:	1e62      	subs	r2, r4, #1
    6770:	b3e4      	cbz	r4, 67ec <memset+0x90>
    6772:	4614      	mov	r4, r2
    6774:	f803 5b01 	strb.w	r5, [r3], #1
    6778:	079a      	lsls	r2, r3, #30
    677a:	d1f8      	bne.n	676e <memset+0x12>
    677c:	2c03      	cmp	r4, #3
    677e:	d92e      	bls.n	67de <memset+0x82>
    6780:	b2cd      	uxtb	r5, r1
    6782:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    6786:	2c0f      	cmp	r4, #15
    6788:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    678c:	d919      	bls.n	67c2 <memset+0x66>
    678e:	f103 0210 	add.w	r2, r3, #16
    6792:	4626      	mov	r6, r4
    6794:	3e10      	subs	r6, #16
    6796:	2e0f      	cmp	r6, #15
    6798:	f842 5c10 	str.w	r5, [r2, #-16]
    679c:	f842 5c0c 	str.w	r5, [r2, #-12]
    67a0:	f842 5c08 	str.w	r5, [r2, #-8]
    67a4:	f842 5c04 	str.w	r5, [r2, #-4]
    67a8:	f102 0210 	add.w	r2, r2, #16
    67ac:	d8f2      	bhi.n	6794 <memset+0x38>
    67ae:	f1a4 0210 	sub.w	r2, r4, #16
    67b2:	f022 020f 	bic.w	r2, r2, #15
    67b6:	f004 040f 	and.w	r4, r4, #15
    67ba:	3210      	adds	r2, #16
    67bc:	2c03      	cmp	r4, #3
    67be:	4413      	add	r3, r2
    67c0:	d90d      	bls.n	67de <memset+0x82>
    67c2:	461e      	mov	r6, r3
    67c4:	4622      	mov	r2, r4
    67c6:	3a04      	subs	r2, #4
    67c8:	2a03      	cmp	r2, #3
    67ca:	f846 5b04 	str.w	r5, [r6], #4
    67ce:	d8fa      	bhi.n	67c6 <memset+0x6a>
    67d0:	1f22      	subs	r2, r4, #4
    67d2:	f022 0203 	bic.w	r2, r2, #3
    67d6:	3204      	adds	r2, #4
    67d8:	4413      	add	r3, r2
    67da:	f004 0403 	and.w	r4, r4, #3
    67de:	b12c      	cbz	r4, 67ec <memset+0x90>
    67e0:	b2c9      	uxtb	r1, r1
    67e2:	441c      	add	r4, r3
    67e4:	f803 1b01 	strb.w	r1, [r3], #1
    67e8:	42a3      	cmp	r3, r4
    67ea:	d1fb      	bne.n	67e4 <memset+0x88>
    67ec:	bc70      	pop	{r4, r5, r6}
    67ee:	4770      	bx	lr
    67f0:	4614      	mov	r4, r2
    67f2:	4603      	mov	r3, r0
    67f4:	e7c2      	b.n	677c <memset+0x20>
    67f6:	bf00      	nop

000067f8 <__malloc_lock>:
    67f8:	4770      	bx	lr
    67fa:	bf00      	nop

000067fc <__malloc_unlock>:
    67fc:	4770      	bx	lr
    67fe:	bf00      	nop

00006800 <realloc>:
    6800:	4b02      	ldr	r3, [pc, #8]	; (680c <realloc+0xc>)
    6802:	460a      	mov	r2, r1
    6804:	4601      	mov	r1, r0
    6806:	6818      	ldr	r0, [r3, #0]
    6808:	f000 b802 	b.w	6810 <_realloc_r>
    680c:	20001d90 	.word	0x20001d90

00006810 <_realloc_r>:
    6810:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6814:	4617      	mov	r7, r2
    6816:	b083      	sub	sp, #12
    6818:	2900      	cmp	r1, #0
    681a:	f000 80c1 	beq.w	69a0 <_realloc_r+0x190>
    681e:	460e      	mov	r6, r1
    6820:	4681      	mov	r9, r0
    6822:	f107 050b 	add.w	r5, r7, #11
    6826:	f7ff ffe7 	bl	67f8 <__malloc_lock>
    682a:	f856 ec04 	ldr.w	lr, [r6, #-4]
    682e:	2d16      	cmp	r5, #22
    6830:	f02e 0403 	bic.w	r4, lr, #3
    6834:	f1a6 0808 	sub.w	r8, r6, #8
    6838:	d840      	bhi.n	68bc <_realloc_r+0xac>
    683a:	2210      	movs	r2, #16
    683c:	4615      	mov	r5, r2
    683e:	42af      	cmp	r7, r5
    6840:	d841      	bhi.n	68c6 <_realloc_r+0xb6>
    6842:	4294      	cmp	r4, r2
    6844:	da75      	bge.n	6932 <_realloc_r+0x122>
    6846:	4bc9      	ldr	r3, [pc, #804]	; (6b6c <_realloc_r+0x35c>)
    6848:	6899      	ldr	r1, [r3, #8]
    684a:	eb08 0004 	add.w	r0, r8, r4
    684e:	4288      	cmp	r0, r1
    6850:	6841      	ldr	r1, [r0, #4]
    6852:	f000 80d9 	beq.w	6a08 <_realloc_r+0x1f8>
    6856:	f021 0301 	bic.w	r3, r1, #1
    685a:	4403      	add	r3, r0
    685c:	685b      	ldr	r3, [r3, #4]
    685e:	07db      	lsls	r3, r3, #31
    6860:	d57d      	bpl.n	695e <_realloc_r+0x14e>
    6862:	f01e 0f01 	tst.w	lr, #1
    6866:	d035      	beq.n	68d4 <_realloc_r+0xc4>
    6868:	4639      	mov	r1, r7
    686a:	4648      	mov	r0, r9
    686c:	f7ff fbaa 	bl	5fc4 <_malloc_r>
    6870:	4607      	mov	r7, r0
    6872:	b1e0      	cbz	r0, 68ae <_realloc_r+0x9e>
    6874:	f856 3c04 	ldr.w	r3, [r6, #-4]
    6878:	f023 0301 	bic.w	r3, r3, #1
    687c:	4443      	add	r3, r8
    687e:	f1a0 0208 	sub.w	r2, r0, #8
    6882:	429a      	cmp	r2, r3
    6884:	f000 8144 	beq.w	6b10 <_realloc_r+0x300>
    6888:	1f22      	subs	r2, r4, #4
    688a:	2a24      	cmp	r2, #36	; 0x24
    688c:	f200 8131 	bhi.w	6af2 <_realloc_r+0x2e2>
    6890:	2a13      	cmp	r2, #19
    6892:	f200 8104 	bhi.w	6a9e <_realloc_r+0x28e>
    6896:	4603      	mov	r3, r0
    6898:	4632      	mov	r2, r6
    689a:	6811      	ldr	r1, [r2, #0]
    689c:	6019      	str	r1, [r3, #0]
    689e:	6851      	ldr	r1, [r2, #4]
    68a0:	6059      	str	r1, [r3, #4]
    68a2:	6892      	ldr	r2, [r2, #8]
    68a4:	609a      	str	r2, [r3, #8]
    68a6:	4631      	mov	r1, r6
    68a8:	4648      	mov	r0, r9
    68aa:	f000 fd8d 	bl	73c8 <_free_r>
    68ae:	4648      	mov	r0, r9
    68b0:	f7ff ffa4 	bl	67fc <__malloc_unlock>
    68b4:	4638      	mov	r0, r7
    68b6:	b003      	add	sp, #12
    68b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    68bc:	f025 0507 	bic.w	r5, r5, #7
    68c0:	2d00      	cmp	r5, #0
    68c2:	462a      	mov	r2, r5
    68c4:	dabb      	bge.n	683e <_realloc_r+0x2e>
    68c6:	230c      	movs	r3, #12
    68c8:	2000      	movs	r0, #0
    68ca:	f8c9 3000 	str.w	r3, [r9]
    68ce:	b003      	add	sp, #12
    68d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    68d4:	f856 3c08 	ldr.w	r3, [r6, #-8]
    68d8:	ebc3 0a08 	rsb	sl, r3, r8
    68dc:	f8da 3004 	ldr.w	r3, [sl, #4]
    68e0:	f023 0c03 	bic.w	ip, r3, #3
    68e4:	eb04 030c 	add.w	r3, r4, ip
    68e8:	4293      	cmp	r3, r2
    68ea:	dbbd      	blt.n	6868 <_realloc_r+0x58>
    68ec:	4657      	mov	r7, sl
    68ee:	f8da 100c 	ldr.w	r1, [sl, #12]
    68f2:	f857 0f08 	ldr.w	r0, [r7, #8]!
    68f6:	1f22      	subs	r2, r4, #4
    68f8:	2a24      	cmp	r2, #36	; 0x24
    68fa:	60c1      	str	r1, [r0, #12]
    68fc:	6088      	str	r0, [r1, #8]
    68fe:	f200 8117 	bhi.w	6b30 <_realloc_r+0x320>
    6902:	2a13      	cmp	r2, #19
    6904:	f240 8112 	bls.w	6b2c <_realloc_r+0x31c>
    6908:	6831      	ldr	r1, [r6, #0]
    690a:	f8ca 1008 	str.w	r1, [sl, #8]
    690e:	6871      	ldr	r1, [r6, #4]
    6910:	f8ca 100c 	str.w	r1, [sl, #12]
    6914:	2a1b      	cmp	r2, #27
    6916:	f200 812b 	bhi.w	6b70 <_realloc_r+0x360>
    691a:	3608      	adds	r6, #8
    691c:	f10a 0210 	add.w	r2, sl, #16
    6920:	6831      	ldr	r1, [r6, #0]
    6922:	6011      	str	r1, [r2, #0]
    6924:	6871      	ldr	r1, [r6, #4]
    6926:	6051      	str	r1, [r2, #4]
    6928:	68b1      	ldr	r1, [r6, #8]
    692a:	6091      	str	r1, [r2, #8]
    692c:	463e      	mov	r6, r7
    692e:	461c      	mov	r4, r3
    6930:	46d0      	mov	r8, sl
    6932:	1b63      	subs	r3, r4, r5
    6934:	2b0f      	cmp	r3, #15
    6936:	d81d      	bhi.n	6974 <_realloc_r+0x164>
    6938:	f8d8 3004 	ldr.w	r3, [r8, #4]
    693c:	f003 0301 	and.w	r3, r3, #1
    6940:	4323      	orrs	r3, r4
    6942:	4444      	add	r4, r8
    6944:	f8c8 3004 	str.w	r3, [r8, #4]
    6948:	6863      	ldr	r3, [r4, #4]
    694a:	f043 0301 	orr.w	r3, r3, #1
    694e:	6063      	str	r3, [r4, #4]
    6950:	4648      	mov	r0, r9
    6952:	f7ff ff53 	bl	67fc <__malloc_unlock>
    6956:	4630      	mov	r0, r6
    6958:	b003      	add	sp, #12
    695a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    695e:	f021 0103 	bic.w	r1, r1, #3
    6962:	4421      	add	r1, r4
    6964:	4291      	cmp	r1, r2
    6966:	db21      	blt.n	69ac <_realloc_r+0x19c>
    6968:	68c3      	ldr	r3, [r0, #12]
    696a:	6882      	ldr	r2, [r0, #8]
    696c:	460c      	mov	r4, r1
    696e:	60d3      	str	r3, [r2, #12]
    6970:	609a      	str	r2, [r3, #8]
    6972:	e7de      	b.n	6932 <_realloc_r+0x122>
    6974:	f8d8 2004 	ldr.w	r2, [r8, #4]
    6978:	eb08 0105 	add.w	r1, r8, r5
    697c:	f002 0201 	and.w	r2, r2, #1
    6980:	4315      	orrs	r5, r2
    6982:	f043 0201 	orr.w	r2, r3, #1
    6986:	440b      	add	r3, r1
    6988:	f8c8 5004 	str.w	r5, [r8, #4]
    698c:	604a      	str	r2, [r1, #4]
    698e:	685a      	ldr	r2, [r3, #4]
    6990:	f042 0201 	orr.w	r2, r2, #1
    6994:	3108      	adds	r1, #8
    6996:	605a      	str	r2, [r3, #4]
    6998:	4648      	mov	r0, r9
    699a:	f000 fd15 	bl	73c8 <_free_r>
    699e:	e7d7      	b.n	6950 <_realloc_r+0x140>
    69a0:	4611      	mov	r1, r2
    69a2:	b003      	add	sp, #12
    69a4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    69a8:	f7ff bb0c 	b.w	5fc4 <_malloc_r>
    69ac:	f01e 0f01 	tst.w	lr, #1
    69b0:	f47f af5a 	bne.w	6868 <_realloc_r+0x58>
    69b4:	f856 3c08 	ldr.w	r3, [r6, #-8]
    69b8:	ebc3 0a08 	rsb	sl, r3, r8
    69bc:	f8da 3004 	ldr.w	r3, [sl, #4]
    69c0:	f023 0c03 	bic.w	ip, r3, #3
    69c4:	eb01 0e0c 	add.w	lr, r1, ip
    69c8:	4596      	cmp	lr, r2
    69ca:	db8b      	blt.n	68e4 <_realloc_r+0xd4>
    69cc:	68c3      	ldr	r3, [r0, #12]
    69ce:	6882      	ldr	r2, [r0, #8]
    69d0:	4657      	mov	r7, sl
    69d2:	60d3      	str	r3, [r2, #12]
    69d4:	609a      	str	r2, [r3, #8]
    69d6:	f857 1f08 	ldr.w	r1, [r7, #8]!
    69da:	f8da 300c 	ldr.w	r3, [sl, #12]
    69de:	60cb      	str	r3, [r1, #12]
    69e0:	1f22      	subs	r2, r4, #4
    69e2:	2a24      	cmp	r2, #36	; 0x24
    69e4:	6099      	str	r1, [r3, #8]
    69e6:	f200 8099 	bhi.w	6b1c <_realloc_r+0x30c>
    69ea:	2a13      	cmp	r2, #19
    69ec:	d962      	bls.n	6ab4 <_realloc_r+0x2a4>
    69ee:	6833      	ldr	r3, [r6, #0]
    69f0:	f8ca 3008 	str.w	r3, [sl, #8]
    69f4:	6873      	ldr	r3, [r6, #4]
    69f6:	f8ca 300c 	str.w	r3, [sl, #12]
    69fa:	2a1b      	cmp	r2, #27
    69fc:	f200 80a0 	bhi.w	6b40 <_realloc_r+0x330>
    6a00:	3608      	adds	r6, #8
    6a02:	f10a 0310 	add.w	r3, sl, #16
    6a06:	e056      	b.n	6ab6 <_realloc_r+0x2a6>
    6a08:	f021 0b03 	bic.w	fp, r1, #3
    6a0c:	44a3      	add	fp, r4
    6a0e:	f105 0010 	add.w	r0, r5, #16
    6a12:	4583      	cmp	fp, r0
    6a14:	da59      	bge.n	6aca <_realloc_r+0x2ba>
    6a16:	f01e 0f01 	tst.w	lr, #1
    6a1a:	f47f af25 	bne.w	6868 <_realloc_r+0x58>
    6a1e:	f856 1c08 	ldr.w	r1, [r6, #-8]
    6a22:	ebc1 0a08 	rsb	sl, r1, r8
    6a26:	f8da 1004 	ldr.w	r1, [sl, #4]
    6a2a:	f021 0c03 	bic.w	ip, r1, #3
    6a2e:	44e3      	add	fp, ip
    6a30:	4558      	cmp	r0, fp
    6a32:	f73f af57 	bgt.w	68e4 <_realloc_r+0xd4>
    6a36:	4657      	mov	r7, sl
    6a38:	f8da 100c 	ldr.w	r1, [sl, #12]
    6a3c:	f857 0f08 	ldr.w	r0, [r7, #8]!
    6a40:	1f22      	subs	r2, r4, #4
    6a42:	2a24      	cmp	r2, #36	; 0x24
    6a44:	60c1      	str	r1, [r0, #12]
    6a46:	6088      	str	r0, [r1, #8]
    6a48:	f200 80b4 	bhi.w	6bb4 <_realloc_r+0x3a4>
    6a4c:	2a13      	cmp	r2, #19
    6a4e:	f240 80a5 	bls.w	6b9c <_realloc_r+0x38c>
    6a52:	6831      	ldr	r1, [r6, #0]
    6a54:	f8ca 1008 	str.w	r1, [sl, #8]
    6a58:	6871      	ldr	r1, [r6, #4]
    6a5a:	f8ca 100c 	str.w	r1, [sl, #12]
    6a5e:	2a1b      	cmp	r2, #27
    6a60:	f200 80af 	bhi.w	6bc2 <_realloc_r+0x3b2>
    6a64:	3608      	adds	r6, #8
    6a66:	f10a 0210 	add.w	r2, sl, #16
    6a6a:	6831      	ldr	r1, [r6, #0]
    6a6c:	6011      	str	r1, [r2, #0]
    6a6e:	6871      	ldr	r1, [r6, #4]
    6a70:	6051      	str	r1, [r2, #4]
    6a72:	68b1      	ldr	r1, [r6, #8]
    6a74:	6091      	str	r1, [r2, #8]
    6a76:	eb0a 0105 	add.w	r1, sl, r5
    6a7a:	ebc5 020b 	rsb	r2, r5, fp
    6a7e:	f042 0201 	orr.w	r2, r2, #1
    6a82:	6099      	str	r1, [r3, #8]
    6a84:	604a      	str	r2, [r1, #4]
    6a86:	f8da 3004 	ldr.w	r3, [sl, #4]
    6a8a:	f003 0301 	and.w	r3, r3, #1
    6a8e:	431d      	orrs	r5, r3
    6a90:	4648      	mov	r0, r9
    6a92:	f8ca 5004 	str.w	r5, [sl, #4]
    6a96:	f7ff feb1 	bl	67fc <__malloc_unlock>
    6a9a:	4638      	mov	r0, r7
    6a9c:	e75c      	b.n	6958 <_realloc_r+0x148>
    6a9e:	6833      	ldr	r3, [r6, #0]
    6aa0:	6003      	str	r3, [r0, #0]
    6aa2:	6873      	ldr	r3, [r6, #4]
    6aa4:	6043      	str	r3, [r0, #4]
    6aa6:	2a1b      	cmp	r2, #27
    6aa8:	d827      	bhi.n	6afa <_realloc_r+0x2ea>
    6aaa:	f100 0308 	add.w	r3, r0, #8
    6aae:	f106 0208 	add.w	r2, r6, #8
    6ab2:	e6f2      	b.n	689a <_realloc_r+0x8a>
    6ab4:	463b      	mov	r3, r7
    6ab6:	6832      	ldr	r2, [r6, #0]
    6ab8:	601a      	str	r2, [r3, #0]
    6aba:	6872      	ldr	r2, [r6, #4]
    6abc:	605a      	str	r2, [r3, #4]
    6abe:	68b2      	ldr	r2, [r6, #8]
    6ac0:	609a      	str	r2, [r3, #8]
    6ac2:	463e      	mov	r6, r7
    6ac4:	4674      	mov	r4, lr
    6ac6:	46d0      	mov	r8, sl
    6ac8:	e733      	b.n	6932 <_realloc_r+0x122>
    6aca:	eb08 0105 	add.w	r1, r8, r5
    6ace:	ebc5 0b0b 	rsb	fp, r5, fp
    6ad2:	f04b 0201 	orr.w	r2, fp, #1
    6ad6:	6099      	str	r1, [r3, #8]
    6ad8:	604a      	str	r2, [r1, #4]
    6ada:	f856 3c04 	ldr.w	r3, [r6, #-4]
    6ade:	f003 0301 	and.w	r3, r3, #1
    6ae2:	431d      	orrs	r5, r3
    6ae4:	4648      	mov	r0, r9
    6ae6:	f846 5c04 	str.w	r5, [r6, #-4]
    6aea:	f7ff fe87 	bl	67fc <__malloc_unlock>
    6aee:	4630      	mov	r0, r6
    6af0:	e732      	b.n	6958 <_realloc_r+0x148>
    6af2:	4631      	mov	r1, r6
    6af4:	f7ff fdce 	bl	6694 <memmove>
    6af8:	e6d5      	b.n	68a6 <_realloc_r+0x96>
    6afa:	68b3      	ldr	r3, [r6, #8]
    6afc:	6083      	str	r3, [r0, #8]
    6afe:	68f3      	ldr	r3, [r6, #12]
    6b00:	60c3      	str	r3, [r0, #12]
    6b02:	2a24      	cmp	r2, #36	; 0x24
    6b04:	d028      	beq.n	6b58 <_realloc_r+0x348>
    6b06:	f100 0310 	add.w	r3, r0, #16
    6b0a:	f106 0210 	add.w	r2, r6, #16
    6b0e:	e6c4      	b.n	689a <_realloc_r+0x8a>
    6b10:	f850 3c04 	ldr.w	r3, [r0, #-4]
    6b14:	f023 0303 	bic.w	r3, r3, #3
    6b18:	441c      	add	r4, r3
    6b1a:	e70a      	b.n	6932 <_realloc_r+0x122>
    6b1c:	4631      	mov	r1, r6
    6b1e:	4638      	mov	r0, r7
    6b20:	4674      	mov	r4, lr
    6b22:	46d0      	mov	r8, sl
    6b24:	f7ff fdb6 	bl	6694 <memmove>
    6b28:	463e      	mov	r6, r7
    6b2a:	e702      	b.n	6932 <_realloc_r+0x122>
    6b2c:	463a      	mov	r2, r7
    6b2e:	e6f7      	b.n	6920 <_realloc_r+0x110>
    6b30:	4631      	mov	r1, r6
    6b32:	4638      	mov	r0, r7
    6b34:	461c      	mov	r4, r3
    6b36:	46d0      	mov	r8, sl
    6b38:	f7ff fdac 	bl	6694 <memmove>
    6b3c:	463e      	mov	r6, r7
    6b3e:	e6f8      	b.n	6932 <_realloc_r+0x122>
    6b40:	68b3      	ldr	r3, [r6, #8]
    6b42:	f8ca 3010 	str.w	r3, [sl, #16]
    6b46:	68f3      	ldr	r3, [r6, #12]
    6b48:	f8ca 3014 	str.w	r3, [sl, #20]
    6b4c:	2a24      	cmp	r2, #36	; 0x24
    6b4e:	d01b      	beq.n	6b88 <_realloc_r+0x378>
    6b50:	3610      	adds	r6, #16
    6b52:	f10a 0318 	add.w	r3, sl, #24
    6b56:	e7ae      	b.n	6ab6 <_realloc_r+0x2a6>
    6b58:	6933      	ldr	r3, [r6, #16]
    6b5a:	6103      	str	r3, [r0, #16]
    6b5c:	6973      	ldr	r3, [r6, #20]
    6b5e:	6143      	str	r3, [r0, #20]
    6b60:	f106 0218 	add.w	r2, r6, #24
    6b64:	f100 0318 	add.w	r3, r0, #24
    6b68:	e697      	b.n	689a <_realloc_r+0x8a>
    6b6a:	bf00      	nop
    6b6c:	20001980 	.word	0x20001980
    6b70:	68b1      	ldr	r1, [r6, #8]
    6b72:	f8ca 1010 	str.w	r1, [sl, #16]
    6b76:	68f1      	ldr	r1, [r6, #12]
    6b78:	f8ca 1014 	str.w	r1, [sl, #20]
    6b7c:	2a24      	cmp	r2, #36	; 0x24
    6b7e:	d00f      	beq.n	6ba0 <_realloc_r+0x390>
    6b80:	3610      	adds	r6, #16
    6b82:	f10a 0218 	add.w	r2, sl, #24
    6b86:	e6cb      	b.n	6920 <_realloc_r+0x110>
    6b88:	6933      	ldr	r3, [r6, #16]
    6b8a:	f8ca 3018 	str.w	r3, [sl, #24]
    6b8e:	6973      	ldr	r3, [r6, #20]
    6b90:	f8ca 301c 	str.w	r3, [sl, #28]
    6b94:	3618      	adds	r6, #24
    6b96:	f10a 0320 	add.w	r3, sl, #32
    6b9a:	e78c      	b.n	6ab6 <_realloc_r+0x2a6>
    6b9c:	463a      	mov	r2, r7
    6b9e:	e764      	b.n	6a6a <_realloc_r+0x25a>
    6ba0:	6932      	ldr	r2, [r6, #16]
    6ba2:	f8ca 2018 	str.w	r2, [sl, #24]
    6ba6:	6972      	ldr	r2, [r6, #20]
    6ba8:	f8ca 201c 	str.w	r2, [sl, #28]
    6bac:	3618      	adds	r6, #24
    6bae:	f10a 0220 	add.w	r2, sl, #32
    6bb2:	e6b5      	b.n	6920 <_realloc_r+0x110>
    6bb4:	4631      	mov	r1, r6
    6bb6:	4638      	mov	r0, r7
    6bb8:	9301      	str	r3, [sp, #4]
    6bba:	f7ff fd6b 	bl	6694 <memmove>
    6bbe:	9b01      	ldr	r3, [sp, #4]
    6bc0:	e759      	b.n	6a76 <_realloc_r+0x266>
    6bc2:	68b1      	ldr	r1, [r6, #8]
    6bc4:	f8ca 1010 	str.w	r1, [sl, #16]
    6bc8:	68f1      	ldr	r1, [r6, #12]
    6bca:	f8ca 1014 	str.w	r1, [sl, #20]
    6bce:	2a24      	cmp	r2, #36	; 0x24
    6bd0:	d003      	beq.n	6bda <_realloc_r+0x3ca>
    6bd2:	3610      	adds	r6, #16
    6bd4:	f10a 0218 	add.w	r2, sl, #24
    6bd8:	e747      	b.n	6a6a <_realloc_r+0x25a>
    6bda:	6932      	ldr	r2, [r6, #16]
    6bdc:	f8ca 2018 	str.w	r2, [sl, #24]
    6be0:	6972      	ldr	r2, [r6, #20]
    6be2:	f8ca 201c 	str.w	r2, [sl, #28]
    6be6:	3618      	adds	r6, #24
    6be8:	f10a 0220 	add.w	r2, sl, #32
    6bec:	e73d      	b.n	6a6a <_realloc_r+0x25a>
    6bee:	bf00      	nop

00006bf0 <_sbrk_r>:
    6bf0:	b538      	push	{r3, r4, r5, lr}
    6bf2:	4c07      	ldr	r4, [pc, #28]	; (6c10 <_sbrk_r+0x20>)
    6bf4:	2300      	movs	r3, #0
    6bf6:	4605      	mov	r5, r0
    6bf8:	4608      	mov	r0, r1
    6bfa:	6023      	str	r3, [r4, #0]
    6bfc:	f7fa fe34 	bl	1868 <_sbrk>
    6c00:	1c43      	adds	r3, r0, #1
    6c02:	d000      	beq.n	6c06 <_sbrk_r+0x16>
    6c04:	bd38      	pop	{r3, r4, r5, pc}
    6c06:	6823      	ldr	r3, [r4, #0]
    6c08:	2b00      	cmp	r3, #0
    6c0a:	d0fb      	beq.n	6c04 <_sbrk_r+0x14>
    6c0c:	602b      	str	r3, [r5, #0]
    6c0e:	bd38      	pop	{r3, r4, r5, pc}
    6c10:	200027b4 	.word	0x200027b4
	...
    6c20:	eba2 0003 	sub.w	r0, r2, r3
    6c24:	4770      	bx	lr
    6c26:	bf00      	nop

00006c28 <strcmp>:
    6c28:	7802      	ldrb	r2, [r0, #0]
    6c2a:	780b      	ldrb	r3, [r1, #0]
    6c2c:	2a01      	cmp	r2, #1
    6c2e:	bf28      	it	cs
    6c30:	429a      	cmpcs	r2, r3
    6c32:	d1f5      	bne.n	6c20 <_sbrk_r+0x30>
    6c34:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    6c38:	ea40 0401 	orr.w	r4, r0, r1
    6c3c:	e9cd 6702 	strd	r6, r7, [sp, #8]
    6c40:	f06f 0c00 	mvn.w	ip, #0
    6c44:	ea4f 7244 	mov.w	r2, r4, lsl #29
    6c48:	b312      	cbz	r2, 6c90 <strcmp+0x68>
    6c4a:	ea80 0401 	eor.w	r4, r0, r1
    6c4e:	f014 0f07 	tst.w	r4, #7
    6c52:	d16a      	bne.n	6d2a <strcmp+0x102>
    6c54:	f000 0407 	and.w	r4, r0, #7
    6c58:	f020 0007 	bic.w	r0, r0, #7
    6c5c:	f004 0503 	and.w	r5, r4, #3
    6c60:	f021 0107 	bic.w	r1, r1, #7
    6c64:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    6c68:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    6c6c:	f014 0f04 	tst.w	r4, #4
    6c70:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    6c74:	fa0c f405 	lsl.w	r4, ip, r5
    6c78:	ea62 0204 	orn	r2, r2, r4
    6c7c:	ea66 0604 	orn	r6, r6, r4
    6c80:	d00a      	beq.n	6c98 <strcmp+0x70>
    6c82:	ea63 0304 	orn	r3, r3, r4
    6c86:	4662      	mov	r2, ip
    6c88:	ea67 0704 	orn	r7, r7, r4
    6c8c:	4666      	mov	r6, ip
    6c8e:	e003      	b.n	6c98 <strcmp+0x70>
    6c90:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    6c94:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    6c98:	fa82 f54c 	uadd8	r5, r2, ip
    6c9c:	ea82 0406 	eor.w	r4, r2, r6
    6ca0:	faa4 f48c 	sel	r4, r4, ip
    6ca4:	bb6c      	cbnz	r4, 6d02 <strcmp+0xda>
    6ca6:	fa83 f54c 	uadd8	r5, r3, ip
    6caa:	ea83 0507 	eor.w	r5, r3, r7
    6cae:	faa5 f58c 	sel	r5, r5, ip
    6cb2:	b995      	cbnz	r5, 6cda <strcmp+0xb2>
    6cb4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    6cb8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    6cbc:	fa82 f54c 	uadd8	r5, r2, ip
    6cc0:	ea82 0406 	eor.w	r4, r2, r6
    6cc4:	faa4 f48c 	sel	r4, r4, ip
    6cc8:	fa83 f54c 	uadd8	r5, r3, ip
    6ccc:	ea83 0507 	eor.w	r5, r3, r7
    6cd0:	faa5 f58c 	sel	r5, r5, ip
    6cd4:	4325      	orrs	r5, r4
    6cd6:	d0db      	beq.n	6c90 <strcmp+0x68>
    6cd8:	b99c      	cbnz	r4, 6d02 <strcmp+0xda>
    6cda:	ba2d      	rev	r5, r5
    6cdc:	fab5 f485 	clz	r4, r5
    6ce0:	f024 0407 	bic.w	r4, r4, #7
    6ce4:	fa27 f104 	lsr.w	r1, r7, r4
    6ce8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    6cec:	fa23 f304 	lsr.w	r3, r3, r4
    6cf0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    6cf4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6cf8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6cfc:	eba0 0001 	sub.w	r0, r0, r1
    6d00:	4770      	bx	lr
    6d02:	ba24      	rev	r4, r4
    6d04:	fab4 f484 	clz	r4, r4
    6d08:	f024 0407 	bic.w	r4, r4, #7
    6d0c:	fa26 f104 	lsr.w	r1, r6, r4
    6d10:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    6d14:	fa22 f204 	lsr.w	r2, r2, r4
    6d18:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    6d1c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6d20:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6d24:	eba0 0001 	sub.w	r0, r0, r1
    6d28:	4770      	bx	lr
    6d2a:	f014 0f03 	tst.w	r4, #3
    6d2e:	d13c      	bne.n	6daa <strcmp+0x182>
    6d30:	f010 0403 	ands.w	r4, r0, #3
    6d34:	d128      	bne.n	6d88 <strcmp+0x160>
    6d36:	f850 2b08 	ldr.w	r2, [r0], #8
    6d3a:	f851 3b08 	ldr.w	r3, [r1], #8
    6d3e:	fa82 f54c 	uadd8	r5, r2, ip
    6d42:	ea82 0503 	eor.w	r5, r2, r3
    6d46:	faa5 f58c 	sel	r5, r5, ip
    6d4a:	b95d      	cbnz	r5, 6d64 <strcmp+0x13c>
    6d4c:	f850 2c04 	ldr.w	r2, [r0, #-4]
    6d50:	f851 3c04 	ldr.w	r3, [r1, #-4]
    6d54:	fa82 f54c 	uadd8	r5, r2, ip
    6d58:	ea82 0503 	eor.w	r5, r2, r3
    6d5c:	faa5 f58c 	sel	r5, r5, ip
    6d60:	2d00      	cmp	r5, #0
    6d62:	d0e8      	beq.n	6d36 <strcmp+0x10e>
    6d64:	ba2d      	rev	r5, r5
    6d66:	fab5 f485 	clz	r4, r5
    6d6a:	f024 0407 	bic.w	r4, r4, #7
    6d6e:	fa23 f104 	lsr.w	r1, r3, r4
    6d72:	fa22 f204 	lsr.w	r2, r2, r4
    6d76:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    6d7a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6d7e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6d82:	eba0 0001 	sub.w	r0, r0, r1
    6d86:	4770      	bx	lr
    6d88:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    6d8c:	f020 0003 	bic.w	r0, r0, #3
    6d90:	f850 2b08 	ldr.w	r2, [r0], #8
    6d94:	f021 0103 	bic.w	r1, r1, #3
    6d98:	f851 3b08 	ldr.w	r3, [r1], #8
    6d9c:	fa0c f404 	lsl.w	r4, ip, r4
    6da0:	ea62 0204 	orn	r2, r2, r4
    6da4:	ea63 0304 	orn	r3, r3, r4
    6da8:	e7c9      	b.n	6d3e <strcmp+0x116>
    6daa:	f010 0403 	ands.w	r4, r0, #3
    6dae:	d01a      	beq.n	6de6 <strcmp+0x1be>
    6db0:	eba1 0104 	sub.w	r1, r1, r4
    6db4:	f020 0003 	bic.w	r0, r0, #3
    6db8:	07e4      	lsls	r4, r4, #31
    6dba:	f850 2b04 	ldr.w	r2, [r0], #4
    6dbe:	d006      	beq.n	6dce <strcmp+0x1a6>
    6dc0:	d20f      	bcs.n	6de2 <strcmp+0x1ba>
    6dc2:	788b      	ldrb	r3, [r1, #2]
    6dc4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    6dc8:	1ae4      	subs	r4, r4, r3
    6dca:	d106      	bne.n	6dda <strcmp+0x1b2>
    6dcc:	b12b      	cbz	r3, 6dda <strcmp+0x1b2>
    6dce:	78cb      	ldrb	r3, [r1, #3]
    6dd0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    6dd4:	1ae4      	subs	r4, r4, r3
    6dd6:	d100      	bne.n	6dda <strcmp+0x1b2>
    6dd8:	b91b      	cbnz	r3, 6de2 <strcmp+0x1ba>
    6dda:	4620      	mov	r0, r4
    6ddc:	f85d 4b10 	ldr.w	r4, [sp], #16
    6de0:	4770      	bx	lr
    6de2:	f101 0104 	add.w	r1, r1, #4
    6de6:	f850 2b04 	ldr.w	r2, [r0], #4
    6dea:	07cc      	lsls	r4, r1, #31
    6dec:	f021 0103 	bic.w	r1, r1, #3
    6df0:	f851 3b04 	ldr.w	r3, [r1], #4
    6df4:	d848      	bhi.n	6e88 <strcmp+0x260>
    6df6:	d224      	bcs.n	6e42 <strcmp+0x21a>
    6df8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    6dfc:	fa82 f54c 	uadd8	r5, r2, ip
    6e00:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    6e04:	faa5 f58c 	sel	r5, r5, ip
    6e08:	d10a      	bne.n	6e20 <strcmp+0x1f8>
    6e0a:	b965      	cbnz	r5, 6e26 <strcmp+0x1fe>
    6e0c:	f851 3b04 	ldr.w	r3, [r1], #4
    6e10:	ea84 0402 	eor.w	r4, r4, r2
    6e14:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    6e18:	d10e      	bne.n	6e38 <strcmp+0x210>
    6e1a:	f850 2b04 	ldr.w	r2, [r0], #4
    6e1e:	e7eb      	b.n	6df8 <strcmp+0x1d0>
    6e20:	ea4f 2313 	mov.w	r3, r3, lsr #8
    6e24:	e055      	b.n	6ed2 <strcmp+0x2aa>
    6e26:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    6e2a:	d14d      	bne.n	6ec8 <strcmp+0x2a0>
    6e2c:	7808      	ldrb	r0, [r1, #0]
    6e2e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6e32:	f1c0 0000 	rsb	r0, r0, #0
    6e36:	4770      	bx	lr
    6e38:	ea4f 6212 	mov.w	r2, r2, lsr #24
    6e3c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    6e40:	e047      	b.n	6ed2 <strcmp+0x2aa>
    6e42:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    6e46:	fa82 f54c 	uadd8	r5, r2, ip
    6e4a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    6e4e:	faa5 f58c 	sel	r5, r5, ip
    6e52:	d10a      	bne.n	6e6a <strcmp+0x242>
    6e54:	b965      	cbnz	r5, 6e70 <strcmp+0x248>
    6e56:	f851 3b04 	ldr.w	r3, [r1], #4
    6e5a:	ea84 0402 	eor.w	r4, r4, r2
    6e5e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    6e62:	d10c      	bne.n	6e7e <strcmp+0x256>
    6e64:	f850 2b04 	ldr.w	r2, [r0], #4
    6e68:	e7eb      	b.n	6e42 <strcmp+0x21a>
    6e6a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    6e6e:	e030      	b.n	6ed2 <strcmp+0x2aa>
    6e70:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    6e74:	d128      	bne.n	6ec8 <strcmp+0x2a0>
    6e76:	880b      	ldrh	r3, [r1, #0]
    6e78:	ea4f 4212 	mov.w	r2, r2, lsr #16
    6e7c:	e029      	b.n	6ed2 <strcmp+0x2aa>
    6e7e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    6e82:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    6e86:	e024      	b.n	6ed2 <strcmp+0x2aa>
    6e88:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    6e8c:	fa82 f54c 	uadd8	r5, r2, ip
    6e90:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    6e94:	faa5 f58c 	sel	r5, r5, ip
    6e98:	d10a      	bne.n	6eb0 <strcmp+0x288>
    6e9a:	b965      	cbnz	r5, 6eb6 <strcmp+0x28e>
    6e9c:	f851 3b04 	ldr.w	r3, [r1], #4
    6ea0:	ea84 0402 	eor.w	r4, r4, r2
    6ea4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    6ea8:	d109      	bne.n	6ebe <strcmp+0x296>
    6eaa:	f850 2b04 	ldr.w	r2, [r0], #4
    6eae:	e7eb      	b.n	6e88 <strcmp+0x260>
    6eb0:	ea4f 6313 	mov.w	r3, r3, lsr #24
    6eb4:	e00d      	b.n	6ed2 <strcmp+0x2aa>
    6eb6:	f015 0fff 	tst.w	r5, #255	; 0xff
    6eba:	d105      	bne.n	6ec8 <strcmp+0x2a0>
    6ebc:	680b      	ldr	r3, [r1, #0]
    6ebe:	ea4f 2212 	mov.w	r2, r2, lsr #8
    6ec2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    6ec6:	e004      	b.n	6ed2 <strcmp+0x2aa>
    6ec8:	f04f 0000 	mov.w	r0, #0
    6ecc:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6ed0:	4770      	bx	lr
    6ed2:	ba12      	rev	r2, r2
    6ed4:	ba1b      	rev	r3, r3
    6ed6:	fa82 f44c 	uadd8	r4, r2, ip
    6eda:	ea82 0403 	eor.w	r4, r2, r3
    6ede:	faa4 f58c 	sel	r5, r4, ip
    6ee2:	fab5 f485 	clz	r4, r5
    6ee6:	fa02 f204 	lsl.w	r2, r2, r4
    6eea:	fa03 f304 	lsl.w	r3, r3, r4
    6eee:	ea4f 6012 	mov.w	r0, r2, lsr #24
    6ef2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6ef6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    6efa:	4770      	bx	lr

00006efc <strcpy>:
    6efc:	ea80 0201 	eor.w	r2, r0, r1
    6f00:	4684      	mov	ip, r0
    6f02:	f012 0f03 	tst.w	r2, #3
    6f06:	d14f      	bne.n	6fa8 <strcpy+0xac>
    6f08:	f011 0f03 	tst.w	r1, #3
    6f0c:	d132      	bne.n	6f74 <strcpy+0x78>
    6f0e:	f84d 4d04 	str.w	r4, [sp, #-4]!
    6f12:	f011 0f04 	tst.w	r1, #4
    6f16:	f851 3b04 	ldr.w	r3, [r1], #4
    6f1a:	d00b      	beq.n	6f34 <strcpy+0x38>
    6f1c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    6f20:	439a      	bics	r2, r3
    6f22:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    6f26:	bf04      	itt	eq
    6f28:	f84c 3b04 	streq.w	r3, [ip], #4
    6f2c:	f851 3b04 	ldreq.w	r3, [r1], #4
    6f30:	d116      	bne.n	6f60 <strcpy+0x64>
    6f32:	bf00      	nop
    6f34:	f851 4b04 	ldr.w	r4, [r1], #4
    6f38:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    6f3c:	439a      	bics	r2, r3
    6f3e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    6f42:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    6f46:	d10b      	bne.n	6f60 <strcpy+0x64>
    6f48:	f84c 3b04 	str.w	r3, [ip], #4
    6f4c:	43a2      	bics	r2, r4
    6f4e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    6f52:	bf04      	itt	eq
    6f54:	f851 3b04 	ldreq.w	r3, [r1], #4
    6f58:	f84c 4b04 	streq.w	r4, [ip], #4
    6f5c:	d0ea      	beq.n	6f34 <strcpy+0x38>
    6f5e:	4623      	mov	r3, r4
    6f60:	f80c 3b01 	strb.w	r3, [ip], #1
    6f64:	f013 0fff 	tst.w	r3, #255	; 0xff
    6f68:	ea4f 2333 	mov.w	r3, r3, ror #8
    6f6c:	d1f8      	bne.n	6f60 <strcpy+0x64>
    6f6e:	f85d 4b04 	ldr.w	r4, [sp], #4
    6f72:	4770      	bx	lr
    6f74:	f011 0f01 	tst.w	r1, #1
    6f78:	d006      	beq.n	6f88 <strcpy+0x8c>
    6f7a:	f811 2b01 	ldrb.w	r2, [r1], #1
    6f7e:	f80c 2b01 	strb.w	r2, [ip], #1
    6f82:	2a00      	cmp	r2, #0
    6f84:	bf08      	it	eq
    6f86:	4770      	bxeq	lr
    6f88:	f011 0f02 	tst.w	r1, #2
    6f8c:	d0bf      	beq.n	6f0e <strcpy+0x12>
    6f8e:	f831 2b02 	ldrh.w	r2, [r1], #2
    6f92:	f012 0fff 	tst.w	r2, #255	; 0xff
    6f96:	bf16      	itet	ne
    6f98:	f82c 2b02 	strhne.w	r2, [ip], #2
    6f9c:	f88c 2000 	strbeq.w	r2, [ip]
    6fa0:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    6fa4:	d1b3      	bne.n	6f0e <strcpy+0x12>
    6fa6:	4770      	bx	lr
    6fa8:	f811 2b01 	ldrb.w	r2, [r1], #1
    6fac:	f80c 2b01 	strb.w	r2, [ip], #1
    6fb0:	2a00      	cmp	r2, #0
    6fb2:	d1f9      	bne.n	6fa8 <strcpy+0xac>
    6fb4:	4770      	bx	lr
    6fb6:	bf00      	nop
	...

00006fc0 <strlen>:
    6fc0:	f890 f000 	pld	[r0]
    6fc4:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    6fc8:	f020 0107 	bic.w	r1, r0, #7
    6fcc:	f06f 0c00 	mvn.w	ip, #0
    6fd0:	f010 0407 	ands.w	r4, r0, #7
    6fd4:	f891 f020 	pld	[r1, #32]
    6fd8:	f040 8049 	bne.w	706e <strlen+0xae>
    6fdc:	f04f 0400 	mov.w	r4, #0
    6fe0:	f06f 0007 	mvn.w	r0, #7
    6fe4:	e9d1 2300 	ldrd	r2, r3, [r1]
    6fe8:	f891 f040 	pld	[r1, #64]	; 0x40
    6fec:	f100 0008 	add.w	r0, r0, #8
    6ff0:	fa82 f24c 	uadd8	r2, r2, ip
    6ff4:	faa4 f28c 	sel	r2, r4, ip
    6ff8:	fa83 f34c 	uadd8	r3, r3, ip
    6ffc:	faa2 f38c 	sel	r3, r2, ip
    7000:	bb4b      	cbnz	r3, 7056 <strlen+0x96>
    7002:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    7006:	fa82 f24c 	uadd8	r2, r2, ip
    700a:	f100 0008 	add.w	r0, r0, #8
    700e:	faa4 f28c 	sel	r2, r4, ip
    7012:	fa83 f34c 	uadd8	r3, r3, ip
    7016:	faa2 f38c 	sel	r3, r2, ip
    701a:	b9e3      	cbnz	r3, 7056 <strlen+0x96>
    701c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    7020:	fa82 f24c 	uadd8	r2, r2, ip
    7024:	f100 0008 	add.w	r0, r0, #8
    7028:	faa4 f28c 	sel	r2, r4, ip
    702c:	fa83 f34c 	uadd8	r3, r3, ip
    7030:	faa2 f38c 	sel	r3, r2, ip
    7034:	b97b      	cbnz	r3, 7056 <strlen+0x96>
    7036:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    703a:	f101 0120 	add.w	r1, r1, #32
    703e:	fa82 f24c 	uadd8	r2, r2, ip
    7042:	f100 0008 	add.w	r0, r0, #8
    7046:	faa4 f28c 	sel	r2, r4, ip
    704a:	fa83 f34c 	uadd8	r3, r3, ip
    704e:	faa2 f38c 	sel	r3, r2, ip
    7052:	2b00      	cmp	r3, #0
    7054:	d0c6      	beq.n	6fe4 <strlen+0x24>
    7056:	2a00      	cmp	r2, #0
    7058:	bf04      	itt	eq
    705a:	3004      	addeq	r0, #4
    705c:	461a      	moveq	r2, r3
    705e:	ba12      	rev	r2, r2
    7060:	fab2 f282 	clz	r2, r2
    7064:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    7068:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    706c:	4770      	bx	lr
    706e:	e9d1 2300 	ldrd	r2, r3, [r1]
    7072:	f004 0503 	and.w	r5, r4, #3
    7076:	f1c4 0000 	rsb	r0, r4, #0
    707a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    707e:	f014 0f04 	tst.w	r4, #4
    7082:	f891 f040 	pld	[r1, #64]	; 0x40
    7086:	fa0c f505 	lsl.w	r5, ip, r5
    708a:	ea62 0205 	orn	r2, r2, r5
    708e:	bf1c      	itt	ne
    7090:	ea63 0305 	ornne	r3, r3, r5
    7094:	4662      	movne	r2, ip
    7096:	f04f 0400 	mov.w	r4, #0
    709a:	e7a9      	b.n	6ff0 <strlen+0x30>

0000709c <strncpy>:
    709c:	ea40 0301 	orr.w	r3, r0, r1
    70a0:	079b      	lsls	r3, r3, #30
    70a2:	b470      	push	{r4, r5, r6}
    70a4:	d12b      	bne.n	70fe <strncpy+0x62>
    70a6:	2a03      	cmp	r2, #3
    70a8:	d929      	bls.n	70fe <strncpy+0x62>
    70aa:	460c      	mov	r4, r1
    70ac:	4603      	mov	r3, r0
    70ae:	4621      	mov	r1, r4
    70b0:	f854 6b04 	ldr.w	r6, [r4], #4
    70b4:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
    70b8:	ea25 0506 	bic.w	r5, r5, r6
    70bc:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
    70c0:	d106      	bne.n	70d0 <strncpy+0x34>
    70c2:	3a04      	subs	r2, #4
    70c4:	2a03      	cmp	r2, #3
    70c6:	f843 6b04 	str.w	r6, [r3], #4
    70ca:	4621      	mov	r1, r4
    70cc:	d8ef      	bhi.n	70ae <strncpy+0x12>
    70ce:	b1a2      	cbz	r2, 70fa <strncpy+0x5e>
    70d0:	780c      	ldrb	r4, [r1, #0]
    70d2:	701c      	strb	r4, [r3, #0]
    70d4:	3a01      	subs	r2, #1
    70d6:	3301      	adds	r3, #1
    70d8:	3101      	adds	r1, #1
    70da:	b13c      	cbz	r4, 70ec <strncpy+0x50>
    70dc:	b16a      	cbz	r2, 70fa <strncpy+0x5e>
    70de:	f811 4b01 	ldrb.w	r4, [r1], #1
    70e2:	f803 4b01 	strb.w	r4, [r3], #1
    70e6:	3a01      	subs	r2, #1
    70e8:	2c00      	cmp	r4, #0
    70ea:	d1f7      	bne.n	70dc <strncpy+0x40>
    70ec:	b12a      	cbz	r2, 70fa <strncpy+0x5e>
    70ee:	441a      	add	r2, r3
    70f0:	2100      	movs	r1, #0
    70f2:	f803 1b01 	strb.w	r1, [r3], #1
    70f6:	429a      	cmp	r2, r3
    70f8:	d1fb      	bne.n	70f2 <strncpy+0x56>
    70fa:	bc70      	pop	{r4, r5, r6}
    70fc:	4770      	bx	lr
    70fe:	4603      	mov	r3, r0
    7100:	e7e5      	b.n	70ce <strncpy+0x32>
    7102:	bf00      	nop

00007104 <_vdprintf_r>:
    7104:	b5f0      	push	{r4, r5, r6, r7, lr}
    7106:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
    710a:	ad04      	add	r5, sp, #16
    710c:	9300      	str	r3, [sp, #0]
    710e:	460f      	mov	r7, r1
    7110:	4613      	mov	r3, r2
    7112:	f44f 7400 	mov.w	r4, #512	; 0x200
    7116:	aa03      	add	r2, sp, #12
    7118:	4629      	mov	r1, r5
    711a:	9403      	str	r4, [sp, #12]
    711c:	4606      	mov	r6, r0
    711e:	f000 fdb1 	bl	7c84 <_vasnprintf_r>
    7122:	b188      	cbz	r0, 7148 <_vdprintf_r+0x44>
    7124:	4604      	mov	r4, r0
    7126:	4602      	mov	r2, r0
    7128:	4639      	mov	r1, r7
    712a:	9b03      	ldr	r3, [sp, #12]
    712c:	4630      	mov	r0, r6
    712e:	f000 f829 	bl	7184 <_write_r>
    7132:	42ac      	cmp	r4, r5
    7134:	9003      	str	r0, [sp, #12]
    7136:	d004      	beq.n	7142 <_vdprintf_r+0x3e>
    7138:	4630      	mov	r0, r6
    713a:	4621      	mov	r1, r4
    713c:	f000 f944 	bl	73c8 <_free_r>
    7140:	9803      	ldr	r0, [sp, #12]
    7142:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
    7146:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7148:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    714c:	e7f9      	b.n	7142 <_vdprintf_r+0x3e>
    714e:	bf00      	nop

00007150 <vdprintf>:
    7150:	b410      	push	{r4}
    7152:	4c04      	ldr	r4, [pc, #16]	; (7164 <vdprintf+0x14>)
    7154:	4613      	mov	r3, r2
    7156:	460a      	mov	r2, r1
    7158:	4601      	mov	r1, r0
    715a:	6820      	ldr	r0, [r4, #0]
    715c:	f85d 4b04 	ldr.w	r4, [sp], #4
    7160:	f7ff bfd0 	b.w	7104 <_vdprintf_r>
    7164:	20001d90 	.word	0x20001d90

00007168 <__ascii_wctomb>:
    7168:	b121      	cbz	r1, 7174 <__ascii_wctomb+0xc>
    716a:	2aff      	cmp	r2, #255	; 0xff
    716c:	d804      	bhi.n	7178 <__ascii_wctomb+0x10>
    716e:	700a      	strb	r2, [r1, #0]
    7170:	2001      	movs	r0, #1
    7172:	4770      	bx	lr
    7174:	4608      	mov	r0, r1
    7176:	4770      	bx	lr
    7178:	238a      	movs	r3, #138	; 0x8a
    717a:	6003      	str	r3, [r0, #0]
    717c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7180:	4770      	bx	lr
    7182:	bf00      	nop

00007184 <_write_r>:
    7184:	b570      	push	{r4, r5, r6, lr}
    7186:	460d      	mov	r5, r1
    7188:	4c08      	ldr	r4, [pc, #32]	; (71ac <_write_r+0x28>)
    718a:	4611      	mov	r1, r2
    718c:	4606      	mov	r6, r0
    718e:	461a      	mov	r2, r3
    7190:	4628      	mov	r0, r5
    7192:	2300      	movs	r3, #0
    7194:	6023      	str	r3, [r4, #0]
    7196:	f7fb fba1 	bl	28dc <_write>
    719a:	1c43      	adds	r3, r0, #1
    719c:	d000      	beq.n	71a0 <_write_r+0x1c>
    719e:	bd70      	pop	{r4, r5, r6, pc}
    71a0:	6823      	ldr	r3, [r4, #0]
    71a2:	2b00      	cmp	r3, #0
    71a4:	d0fb      	beq.n	719e <_write_r+0x1a>
    71a6:	6033      	str	r3, [r6, #0]
    71a8:	bd70      	pop	{r4, r5, r6, pc}
    71aa:	bf00      	nop
    71ac:	200027b4 	.word	0x200027b4

000071b0 <__register_exitproc>:
    71b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    71b4:	4c25      	ldr	r4, [pc, #148]	; (724c <__register_exitproc+0x9c>)
    71b6:	6825      	ldr	r5, [r4, #0]
    71b8:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    71bc:	4606      	mov	r6, r0
    71be:	4688      	mov	r8, r1
    71c0:	4692      	mov	sl, r2
    71c2:	4699      	mov	r9, r3
    71c4:	b3c4      	cbz	r4, 7238 <__register_exitproc+0x88>
    71c6:	6860      	ldr	r0, [r4, #4]
    71c8:	281f      	cmp	r0, #31
    71ca:	dc17      	bgt.n	71fc <__register_exitproc+0x4c>
    71cc:	1c43      	adds	r3, r0, #1
    71ce:	b176      	cbz	r6, 71ee <__register_exitproc+0x3e>
    71d0:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    71d4:	2201      	movs	r2, #1
    71d6:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    71da:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    71de:	4082      	lsls	r2, r0
    71e0:	4311      	orrs	r1, r2
    71e2:	2e02      	cmp	r6, #2
    71e4:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    71e8:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    71ec:	d01e      	beq.n	722c <__register_exitproc+0x7c>
    71ee:	3002      	adds	r0, #2
    71f0:	6063      	str	r3, [r4, #4]
    71f2:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    71f6:	2000      	movs	r0, #0
    71f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    71fc:	4b14      	ldr	r3, [pc, #80]	; (7250 <__register_exitproc+0xa0>)
    71fe:	b303      	cbz	r3, 7242 <__register_exitproc+0x92>
    7200:	f44f 70c8 	mov.w	r0, #400	; 0x190
    7204:	f7fe fece 	bl	5fa4 <malloc>
    7208:	4604      	mov	r4, r0
    720a:	b1d0      	cbz	r0, 7242 <__register_exitproc+0x92>
    720c:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    7210:	2700      	movs	r7, #0
    7212:	e880 0088 	stmia.w	r0, {r3, r7}
    7216:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    721a:	4638      	mov	r0, r7
    721c:	2301      	movs	r3, #1
    721e:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    7222:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    7226:	2e00      	cmp	r6, #0
    7228:	d0e1      	beq.n	71ee <__register_exitproc+0x3e>
    722a:	e7d1      	b.n	71d0 <__register_exitproc+0x20>
    722c:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    7230:	430a      	orrs	r2, r1
    7232:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    7236:	e7da      	b.n	71ee <__register_exitproc+0x3e>
    7238:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    723c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    7240:	e7c1      	b.n	71c6 <__register_exitproc+0x16>
    7242:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7246:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    724a:	bf00      	nop
    724c:	200006c8 	.word	0x200006c8
    7250:	00005fa5 	.word	0x00005fa5

00007254 <__call_exitprocs>:
    7254:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7258:	4b32      	ldr	r3, [pc, #200]	; (7324 <__call_exitprocs+0xd0>)
    725a:	b085      	sub	sp, #20
    725c:	681b      	ldr	r3, [r3, #0]
    725e:	9302      	str	r3, [sp, #8]
    7260:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    7264:	9001      	str	r0, [sp, #4]
    7266:	460e      	mov	r6, r1
    7268:	9303      	str	r3, [sp, #12]
    726a:	9b02      	ldr	r3, [sp, #8]
    726c:	f8d3 7148 	ldr.w	r7, [r3, #328]	; 0x148
    7270:	b33f      	cbz	r7, 72c2 <__call_exitprocs+0x6e>
    7272:	f8dd a00c 	ldr.w	sl, [sp, #12]
    7276:	f04f 0901 	mov.w	r9, #1
    727a:	46d3      	mov	fp, sl
    727c:	687c      	ldr	r4, [r7, #4]
    727e:	1e65      	subs	r5, r4, #1
    7280:	d40e      	bmi.n	72a0 <__call_exitprocs+0x4c>
    7282:	3401      	adds	r4, #1
    7284:	eb07 0484 	add.w	r4, r7, r4, lsl #2
    7288:	f04f 0800 	mov.w	r8, #0
    728c:	b1e6      	cbz	r6, 72c8 <__call_exitprocs+0x74>
    728e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    7292:	429e      	cmp	r6, r3
    7294:	d018      	beq.n	72c8 <__call_exitprocs+0x74>
    7296:	3d01      	subs	r5, #1
    7298:	1c6b      	adds	r3, r5, #1
    729a:	f1a4 0404 	sub.w	r4, r4, #4
    729e:	d1f5      	bne.n	728c <__call_exitprocs+0x38>
    72a0:	4b21      	ldr	r3, [pc, #132]	; (7328 <__call_exitprocs+0xd4>)
    72a2:	b173      	cbz	r3, 72c2 <__call_exitprocs+0x6e>
    72a4:	687b      	ldr	r3, [r7, #4]
    72a6:	2b00      	cmp	r3, #0
    72a8:	d136      	bne.n	7318 <__call_exitprocs+0xc4>
    72aa:	683b      	ldr	r3, [r7, #0]
    72ac:	2b00      	cmp	r3, #0
    72ae:	d034      	beq.n	731a <__call_exitprocs+0xc6>
    72b0:	4638      	mov	r0, r7
    72b2:	f8cb 3000 	str.w	r3, [fp]
    72b6:	f7fe fe7d 	bl	5fb4 <free>
    72ba:	f8db 7000 	ldr.w	r7, [fp]
    72be:	2f00      	cmp	r7, #0
    72c0:	d1dc      	bne.n	727c <__call_exitprocs+0x28>
    72c2:	b005      	add	sp, #20
    72c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    72c8:	687b      	ldr	r3, [r7, #4]
    72ca:	6822      	ldr	r2, [r4, #0]
    72cc:	3b01      	subs	r3, #1
    72ce:	42ab      	cmp	r3, r5
    72d0:	bf0c      	ite	eq
    72d2:	607d      	streq	r5, [r7, #4]
    72d4:	f8c4 8000 	strne.w	r8, [r4]
    72d8:	2a00      	cmp	r2, #0
    72da:	d0dc      	beq.n	7296 <__call_exitprocs+0x42>
    72dc:	f8d7 1188 	ldr.w	r1, [r7, #392]	; 0x188
    72e0:	f8d7 a004 	ldr.w	sl, [r7, #4]
    72e4:	fa09 f305 	lsl.w	r3, r9, r5
    72e8:	420b      	tst	r3, r1
    72ea:	d00f      	beq.n	730c <__call_exitprocs+0xb8>
    72ec:	f8d7 118c 	ldr.w	r1, [r7, #396]	; 0x18c
    72f0:	420b      	tst	r3, r1
    72f2:	d10d      	bne.n	7310 <__call_exitprocs+0xbc>
    72f4:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
    72f8:	9801      	ldr	r0, [sp, #4]
    72fa:	4790      	blx	r2
    72fc:	687b      	ldr	r3, [r7, #4]
    72fe:	4553      	cmp	r3, sl
    7300:	d1b3      	bne.n	726a <__call_exitprocs+0x16>
    7302:	f8db 3000 	ldr.w	r3, [fp]
    7306:	42bb      	cmp	r3, r7
    7308:	d0c5      	beq.n	7296 <__call_exitprocs+0x42>
    730a:	e7ae      	b.n	726a <__call_exitprocs+0x16>
    730c:	4790      	blx	r2
    730e:	e7f5      	b.n	72fc <__call_exitprocs+0xa8>
    7310:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
    7314:	4790      	blx	r2
    7316:	e7f1      	b.n	72fc <__call_exitprocs+0xa8>
    7318:	683b      	ldr	r3, [r7, #0]
    731a:	46bb      	mov	fp, r7
    731c:	461f      	mov	r7, r3
    731e:	2f00      	cmp	r7, #0
    7320:	d1ac      	bne.n	727c <__call_exitprocs+0x28>
    7322:	e7ce      	b.n	72c2 <__call_exitprocs+0x6e>
    7324:	200006c8 	.word	0x200006c8
    7328:	00005fb5 	.word	0x00005fb5

0000732c <_malloc_trim_r>:
    732c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    732e:	4f23      	ldr	r7, [pc, #140]	; (73bc <_malloc_trim_r+0x90>)
    7330:	460c      	mov	r4, r1
    7332:	4606      	mov	r6, r0
    7334:	f7ff fa60 	bl	67f8 <__malloc_lock>
    7338:	68bb      	ldr	r3, [r7, #8]
    733a:	685d      	ldr	r5, [r3, #4]
    733c:	f025 0503 	bic.w	r5, r5, #3
    7340:	1b29      	subs	r1, r5, r4
    7342:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    7346:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    734a:	f021 010f 	bic.w	r1, r1, #15
    734e:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    7352:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    7356:	db07      	blt.n	7368 <_malloc_trim_r+0x3c>
    7358:	2100      	movs	r1, #0
    735a:	4630      	mov	r0, r6
    735c:	f7ff fc48 	bl	6bf0 <_sbrk_r>
    7360:	68bb      	ldr	r3, [r7, #8]
    7362:	442b      	add	r3, r5
    7364:	4298      	cmp	r0, r3
    7366:	d004      	beq.n	7372 <_malloc_trim_r+0x46>
    7368:	4630      	mov	r0, r6
    736a:	f7ff fa47 	bl	67fc <__malloc_unlock>
    736e:	2000      	movs	r0, #0
    7370:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7372:	4261      	negs	r1, r4
    7374:	4630      	mov	r0, r6
    7376:	f7ff fc3b 	bl	6bf0 <_sbrk_r>
    737a:	3001      	adds	r0, #1
    737c:	d00d      	beq.n	739a <_malloc_trim_r+0x6e>
    737e:	4b10      	ldr	r3, [pc, #64]	; (73c0 <_malloc_trim_r+0x94>)
    7380:	68ba      	ldr	r2, [r7, #8]
    7382:	6819      	ldr	r1, [r3, #0]
    7384:	1b2d      	subs	r5, r5, r4
    7386:	f045 0501 	orr.w	r5, r5, #1
    738a:	4630      	mov	r0, r6
    738c:	1b09      	subs	r1, r1, r4
    738e:	6055      	str	r5, [r2, #4]
    7390:	6019      	str	r1, [r3, #0]
    7392:	f7ff fa33 	bl	67fc <__malloc_unlock>
    7396:	2001      	movs	r0, #1
    7398:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    739a:	2100      	movs	r1, #0
    739c:	4630      	mov	r0, r6
    739e:	f7ff fc27 	bl	6bf0 <_sbrk_r>
    73a2:	68ba      	ldr	r2, [r7, #8]
    73a4:	1a83      	subs	r3, r0, r2
    73a6:	2b0f      	cmp	r3, #15
    73a8:	ddde      	ble.n	7368 <_malloc_trim_r+0x3c>
    73aa:	4c06      	ldr	r4, [pc, #24]	; (73c4 <_malloc_trim_r+0x98>)
    73ac:	4904      	ldr	r1, [pc, #16]	; (73c0 <_malloc_trim_r+0x94>)
    73ae:	6824      	ldr	r4, [r4, #0]
    73b0:	f043 0301 	orr.w	r3, r3, #1
    73b4:	1b00      	subs	r0, r0, r4
    73b6:	6053      	str	r3, [r2, #4]
    73b8:	6008      	str	r0, [r1, #0]
    73ba:	e7d5      	b.n	7368 <_malloc_trim_r+0x3c>
    73bc:	20001980 	.word	0x20001980
    73c0:	200026b4 	.word	0x200026b4
    73c4:	20001d88 	.word	0x20001d88

000073c8 <_free_r>:
    73c8:	2900      	cmp	r1, #0
    73ca:	d045      	beq.n	7458 <_free_r+0x90>
    73cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    73d0:	460d      	mov	r5, r1
    73d2:	4680      	mov	r8, r0
    73d4:	f7ff fa10 	bl	67f8 <__malloc_lock>
    73d8:	f855 7c04 	ldr.w	r7, [r5, #-4]
    73dc:	496a      	ldr	r1, [pc, #424]	; (7588 <_free_r+0x1c0>)
    73de:	f027 0301 	bic.w	r3, r7, #1
    73e2:	f1a5 0408 	sub.w	r4, r5, #8
    73e6:	18e2      	adds	r2, r4, r3
    73e8:	688e      	ldr	r6, [r1, #8]
    73ea:	6850      	ldr	r0, [r2, #4]
    73ec:	42b2      	cmp	r2, r6
    73ee:	f020 0003 	bic.w	r0, r0, #3
    73f2:	d062      	beq.n	74ba <_free_r+0xf2>
    73f4:	07fe      	lsls	r6, r7, #31
    73f6:	6050      	str	r0, [r2, #4]
    73f8:	d40b      	bmi.n	7412 <_free_r+0x4a>
    73fa:	f855 7c08 	ldr.w	r7, [r5, #-8]
    73fe:	1be4      	subs	r4, r4, r7
    7400:	f101 0e08 	add.w	lr, r1, #8
    7404:	68a5      	ldr	r5, [r4, #8]
    7406:	4575      	cmp	r5, lr
    7408:	443b      	add	r3, r7
    740a:	d06f      	beq.n	74ec <_free_r+0x124>
    740c:	68e7      	ldr	r7, [r4, #12]
    740e:	60ef      	str	r7, [r5, #12]
    7410:	60bd      	str	r5, [r7, #8]
    7412:	1815      	adds	r5, r2, r0
    7414:	686d      	ldr	r5, [r5, #4]
    7416:	07ed      	lsls	r5, r5, #31
    7418:	d542      	bpl.n	74a0 <_free_r+0xd8>
    741a:	f043 0201 	orr.w	r2, r3, #1
    741e:	6062      	str	r2, [r4, #4]
    7420:	50e3      	str	r3, [r4, r3]
    7422:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    7426:	d218      	bcs.n	745a <_free_r+0x92>
    7428:	08db      	lsrs	r3, r3, #3
    742a:	1c5a      	adds	r2, r3, #1
    742c:	684d      	ldr	r5, [r1, #4]
    742e:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    7432:	60a7      	str	r7, [r4, #8]
    7434:	2001      	movs	r0, #1
    7436:	109b      	asrs	r3, r3, #2
    7438:	fa00 f303 	lsl.w	r3, r0, r3
    743c:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    7440:	431d      	orrs	r5, r3
    7442:	3808      	subs	r0, #8
    7444:	60e0      	str	r0, [r4, #12]
    7446:	604d      	str	r5, [r1, #4]
    7448:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    744c:	60fc      	str	r4, [r7, #12]
    744e:	4640      	mov	r0, r8
    7450:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7454:	f7ff b9d2 	b.w	67fc <__malloc_unlock>
    7458:	4770      	bx	lr
    745a:	0a5a      	lsrs	r2, r3, #9
    745c:	2a04      	cmp	r2, #4
    745e:	d853      	bhi.n	7508 <_free_r+0x140>
    7460:	099a      	lsrs	r2, r3, #6
    7462:	f102 0739 	add.w	r7, r2, #57	; 0x39
    7466:	007f      	lsls	r7, r7, #1
    7468:	f102 0538 	add.w	r5, r2, #56	; 0x38
    746c:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    7470:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    7474:	4944      	ldr	r1, [pc, #272]	; (7588 <_free_r+0x1c0>)
    7476:	3808      	subs	r0, #8
    7478:	4290      	cmp	r0, r2
    747a:	d04d      	beq.n	7518 <_free_r+0x150>
    747c:	6851      	ldr	r1, [r2, #4]
    747e:	f021 0103 	bic.w	r1, r1, #3
    7482:	428b      	cmp	r3, r1
    7484:	d202      	bcs.n	748c <_free_r+0xc4>
    7486:	6892      	ldr	r2, [r2, #8]
    7488:	4290      	cmp	r0, r2
    748a:	d1f7      	bne.n	747c <_free_r+0xb4>
    748c:	68d0      	ldr	r0, [r2, #12]
    748e:	60e0      	str	r0, [r4, #12]
    7490:	60a2      	str	r2, [r4, #8]
    7492:	6084      	str	r4, [r0, #8]
    7494:	60d4      	str	r4, [r2, #12]
    7496:	4640      	mov	r0, r8
    7498:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    749c:	f7ff b9ae 	b.w	67fc <__malloc_unlock>
    74a0:	6895      	ldr	r5, [r2, #8]
    74a2:	4f3a      	ldr	r7, [pc, #232]	; (758c <_free_r+0x1c4>)
    74a4:	42bd      	cmp	r5, r7
    74a6:	4403      	add	r3, r0
    74a8:	d03f      	beq.n	752a <_free_r+0x162>
    74aa:	68d0      	ldr	r0, [r2, #12]
    74ac:	60e8      	str	r0, [r5, #12]
    74ae:	f043 0201 	orr.w	r2, r3, #1
    74b2:	6085      	str	r5, [r0, #8]
    74b4:	6062      	str	r2, [r4, #4]
    74b6:	50e3      	str	r3, [r4, r3]
    74b8:	e7b3      	b.n	7422 <_free_r+0x5a>
    74ba:	07ff      	lsls	r7, r7, #31
    74bc:	4403      	add	r3, r0
    74be:	d407      	bmi.n	74d0 <_free_r+0x108>
    74c0:	f855 2c08 	ldr.w	r2, [r5, #-8]
    74c4:	1aa4      	subs	r4, r4, r2
    74c6:	4413      	add	r3, r2
    74c8:	68a0      	ldr	r0, [r4, #8]
    74ca:	68e2      	ldr	r2, [r4, #12]
    74cc:	60c2      	str	r2, [r0, #12]
    74ce:	6090      	str	r0, [r2, #8]
    74d0:	4a2f      	ldr	r2, [pc, #188]	; (7590 <_free_r+0x1c8>)
    74d2:	6812      	ldr	r2, [r2, #0]
    74d4:	f043 0001 	orr.w	r0, r3, #1
    74d8:	4293      	cmp	r3, r2
    74da:	6060      	str	r0, [r4, #4]
    74dc:	608c      	str	r4, [r1, #8]
    74de:	d3b6      	bcc.n	744e <_free_r+0x86>
    74e0:	4b2c      	ldr	r3, [pc, #176]	; (7594 <_free_r+0x1cc>)
    74e2:	4640      	mov	r0, r8
    74e4:	6819      	ldr	r1, [r3, #0]
    74e6:	f7ff ff21 	bl	732c <_malloc_trim_r>
    74ea:	e7b0      	b.n	744e <_free_r+0x86>
    74ec:	1811      	adds	r1, r2, r0
    74ee:	6849      	ldr	r1, [r1, #4]
    74f0:	07c9      	lsls	r1, r1, #31
    74f2:	d444      	bmi.n	757e <_free_r+0x1b6>
    74f4:	6891      	ldr	r1, [r2, #8]
    74f6:	68d2      	ldr	r2, [r2, #12]
    74f8:	60ca      	str	r2, [r1, #12]
    74fa:	4403      	add	r3, r0
    74fc:	f043 0001 	orr.w	r0, r3, #1
    7500:	6091      	str	r1, [r2, #8]
    7502:	6060      	str	r0, [r4, #4]
    7504:	50e3      	str	r3, [r4, r3]
    7506:	e7a2      	b.n	744e <_free_r+0x86>
    7508:	2a14      	cmp	r2, #20
    750a:	d817      	bhi.n	753c <_free_r+0x174>
    750c:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    7510:	007f      	lsls	r7, r7, #1
    7512:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    7516:	e7a9      	b.n	746c <_free_r+0xa4>
    7518:	10aa      	asrs	r2, r5, #2
    751a:	684b      	ldr	r3, [r1, #4]
    751c:	2501      	movs	r5, #1
    751e:	fa05 f202 	lsl.w	r2, r5, r2
    7522:	4313      	orrs	r3, r2
    7524:	604b      	str	r3, [r1, #4]
    7526:	4602      	mov	r2, r0
    7528:	e7b1      	b.n	748e <_free_r+0xc6>
    752a:	f043 0201 	orr.w	r2, r3, #1
    752e:	614c      	str	r4, [r1, #20]
    7530:	610c      	str	r4, [r1, #16]
    7532:	60e5      	str	r5, [r4, #12]
    7534:	60a5      	str	r5, [r4, #8]
    7536:	6062      	str	r2, [r4, #4]
    7538:	50e3      	str	r3, [r4, r3]
    753a:	e788      	b.n	744e <_free_r+0x86>
    753c:	2a54      	cmp	r2, #84	; 0x54
    753e:	d806      	bhi.n	754e <_free_r+0x186>
    7540:	0b1a      	lsrs	r2, r3, #12
    7542:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    7546:	007f      	lsls	r7, r7, #1
    7548:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    754c:	e78e      	b.n	746c <_free_r+0xa4>
    754e:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    7552:	d806      	bhi.n	7562 <_free_r+0x19a>
    7554:	0bda      	lsrs	r2, r3, #15
    7556:	f102 0778 	add.w	r7, r2, #120	; 0x78
    755a:	007f      	lsls	r7, r7, #1
    755c:	f102 0577 	add.w	r5, r2, #119	; 0x77
    7560:	e784      	b.n	746c <_free_r+0xa4>
    7562:	f240 5054 	movw	r0, #1364	; 0x554
    7566:	4282      	cmp	r2, r0
    7568:	d806      	bhi.n	7578 <_free_r+0x1b0>
    756a:	0c9a      	lsrs	r2, r3, #18
    756c:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    7570:	007f      	lsls	r7, r7, #1
    7572:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    7576:	e779      	b.n	746c <_free_r+0xa4>
    7578:	27fe      	movs	r7, #254	; 0xfe
    757a:	257e      	movs	r5, #126	; 0x7e
    757c:	e776      	b.n	746c <_free_r+0xa4>
    757e:	f043 0201 	orr.w	r2, r3, #1
    7582:	6062      	str	r2, [r4, #4]
    7584:	50e3      	str	r3, [r4, r3]
    7586:	e762      	b.n	744e <_free_r+0x86>
    7588:	20001980 	.word	0x20001980
    758c:	20001988 	.word	0x20001988
    7590:	20001d8c 	.word	0x20001d8c
    7594:	200026e4 	.word	0x200026e4

00007598 <_localeconv_r>:
    7598:	4a04      	ldr	r2, [pc, #16]	; (75ac <_localeconv_r+0x14>)
    759a:	4b05      	ldr	r3, [pc, #20]	; (75b0 <_localeconv_r+0x18>)
    759c:	6812      	ldr	r2, [r2, #0]
    759e:	6b50      	ldr	r0, [r2, #52]	; 0x34
    75a0:	2800      	cmp	r0, #0
    75a2:	bf08      	it	eq
    75a4:	4618      	moveq	r0, r3
    75a6:	30f0      	adds	r0, #240	; 0xf0
    75a8:	4770      	bx	lr
    75aa:	bf00      	nop
    75ac:	20001d90 	.word	0x20001d90
    75b0:	20001814 	.word	0x20001814
	...

000075c0 <memchr>:
    75c0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    75c4:	2a10      	cmp	r2, #16
    75c6:	db2b      	blt.n	7620 <memchr+0x60>
    75c8:	f010 0f07 	tst.w	r0, #7
    75cc:	d008      	beq.n	75e0 <memchr+0x20>
    75ce:	f810 3b01 	ldrb.w	r3, [r0], #1
    75d2:	3a01      	subs	r2, #1
    75d4:	428b      	cmp	r3, r1
    75d6:	d02d      	beq.n	7634 <memchr+0x74>
    75d8:	f010 0f07 	tst.w	r0, #7
    75dc:	b342      	cbz	r2, 7630 <memchr+0x70>
    75de:	d1f6      	bne.n	75ce <memchr+0xe>
    75e0:	b4f0      	push	{r4, r5, r6, r7}
    75e2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    75e6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    75ea:	f022 0407 	bic.w	r4, r2, #7
    75ee:	f07f 0700 	mvns.w	r7, #0
    75f2:	2300      	movs	r3, #0
    75f4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    75f8:	3c08      	subs	r4, #8
    75fa:	ea85 0501 	eor.w	r5, r5, r1
    75fe:	ea86 0601 	eor.w	r6, r6, r1
    7602:	fa85 f547 	uadd8	r5, r5, r7
    7606:	faa3 f587 	sel	r5, r3, r7
    760a:	fa86 f647 	uadd8	r6, r6, r7
    760e:	faa5 f687 	sel	r6, r5, r7
    7612:	b98e      	cbnz	r6, 7638 <memchr+0x78>
    7614:	d1ee      	bne.n	75f4 <memchr+0x34>
    7616:	bcf0      	pop	{r4, r5, r6, r7}
    7618:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    761c:	f002 0207 	and.w	r2, r2, #7
    7620:	b132      	cbz	r2, 7630 <memchr+0x70>
    7622:	f810 3b01 	ldrb.w	r3, [r0], #1
    7626:	3a01      	subs	r2, #1
    7628:	ea83 0301 	eor.w	r3, r3, r1
    762c:	b113      	cbz	r3, 7634 <memchr+0x74>
    762e:	d1f8      	bne.n	7622 <memchr+0x62>
    7630:	2000      	movs	r0, #0
    7632:	4770      	bx	lr
    7634:	3801      	subs	r0, #1
    7636:	4770      	bx	lr
    7638:	2d00      	cmp	r5, #0
    763a:	bf06      	itte	eq
    763c:	4635      	moveq	r5, r6
    763e:	3803      	subeq	r0, #3
    7640:	3807      	subne	r0, #7
    7642:	f015 0f01 	tst.w	r5, #1
    7646:	d107      	bne.n	7658 <memchr+0x98>
    7648:	3001      	adds	r0, #1
    764a:	f415 7f80 	tst.w	r5, #256	; 0x100
    764e:	bf02      	ittt	eq
    7650:	3001      	addeq	r0, #1
    7652:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    7656:	3001      	addeq	r0, #1
    7658:	bcf0      	pop	{r4, r5, r6, r7}
    765a:	3801      	subs	r0, #1
    765c:	4770      	bx	lr
    765e:	bf00      	nop

00007660 <_Balloc>:
    7660:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    7662:	b570      	push	{r4, r5, r6, lr}
    7664:	4605      	mov	r5, r0
    7666:	460c      	mov	r4, r1
    7668:	b14b      	cbz	r3, 767e <_Balloc+0x1e>
    766a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    766e:	b180      	cbz	r0, 7692 <_Balloc+0x32>
    7670:	6802      	ldr	r2, [r0, #0]
    7672:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    7676:	2300      	movs	r3, #0
    7678:	6103      	str	r3, [r0, #16]
    767a:	60c3      	str	r3, [r0, #12]
    767c:	bd70      	pop	{r4, r5, r6, pc}
    767e:	2221      	movs	r2, #33	; 0x21
    7680:	2104      	movs	r1, #4
    7682:	f000 fb2f 	bl	7ce4 <_calloc_r>
    7686:	64e8      	str	r0, [r5, #76]	; 0x4c
    7688:	4603      	mov	r3, r0
    768a:	2800      	cmp	r0, #0
    768c:	d1ed      	bne.n	766a <_Balloc+0xa>
    768e:	2000      	movs	r0, #0
    7690:	bd70      	pop	{r4, r5, r6, pc}
    7692:	2101      	movs	r1, #1
    7694:	fa01 f604 	lsl.w	r6, r1, r4
    7698:	1d72      	adds	r2, r6, #5
    769a:	4628      	mov	r0, r5
    769c:	0092      	lsls	r2, r2, #2
    769e:	f000 fb21 	bl	7ce4 <_calloc_r>
    76a2:	2800      	cmp	r0, #0
    76a4:	d0f3      	beq.n	768e <_Balloc+0x2e>
    76a6:	6044      	str	r4, [r0, #4]
    76a8:	6086      	str	r6, [r0, #8]
    76aa:	e7e4      	b.n	7676 <_Balloc+0x16>

000076ac <_Bfree>:
    76ac:	b131      	cbz	r1, 76bc <_Bfree+0x10>
    76ae:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    76b0:	684a      	ldr	r2, [r1, #4]
    76b2:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    76b6:	6008      	str	r0, [r1, #0]
    76b8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    76bc:	4770      	bx	lr
    76be:	bf00      	nop

000076c0 <__multadd>:
    76c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    76c2:	690c      	ldr	r4, [r1, #16]
    76c4:	b083      	sub	sp, #12
    76c6:	460d      	mov	r5, r1
    76c8:	4606      	mov	r6, r0
    76ca:	f101 0e14 	add.w	lr, r1, #20
    76ce:	2700      	movs	r7, #0
    76d0:	f8de 0000 	ldr.w	r0, [lr]
    76d4:	b281      	uxth	r1, r0
    76d6:	fb02 3101 	mla	r1, r2, r1, r3
    76da:	0c0b      	lsrs	r3, r1, #16
    76dc:	0c00      	lsrs	r0, r0, #16
    76de:	fb02 3300 	mla	r3, r2, r0, r3
    76e2:	b289      	uxth	r1, r1
    76e4:	3701      	adds	r7, #1
    76e6:	eb01 4103 	add.w	r1, r1, r3, lsl #16
    76ea:	42bc      	cmp	r4, r7
    76ec:	f84e 1b04 	str.w	r1, [lr], #4
    76f0:	ea4f 4313 	mov.w	r3, r3, lsr #16
    76f4:	dcec      	bgt.n	76d0 <__multadd+0x10>
    76f6:	b13b      	cbz	r3, 7708 <__multadd+0x48>
    76f8:	68aa      	ldr	r2, [r5, #8]
    76fa:	4294      	cmp	r4, r2
    76fc:	da07      	bge.n	770e <__multadd+0x4e>
    76fe:	eb05 0284 	add.w	r2, r5, r4, lsl #2
    7702:	3401      	adds	r4, #1
    7704:	6153      	str	r3, [r2, #20]
    7706:	612c      	str	r4, [r5, #16]
    7708:	4628      	mov	r0, r5
    770a:	b003      	add	sp, #12
    770c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    770e:	6869      	ldr	r1, [r5, #4]
    7710:	9301      	str	r3, [sp, #4]
    7712:	3101      	adds	r1, #1
    7714:	4630      	mov	r0, r6
    7716:	f7ff ffa3 	bl	7660 <_Balloc>
    771a:	692a      	ldr	r2, [r5, #16]
    771c:	3202      	adds	r2, #2
    771e:	f105 010c 	add.w	r1, r5, #12
    7722:	4607      	mov	r7, r0
    7724:	0092      	lsls	r2, r2, #2
    7726:	300c      	adds	r0, #12
    7728:	f7fe ff1a 	bl	6560 <memcpy>
    772c:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
    772e:	6869      	ldr	r1, [r5, #4]
    7730:	9b01      	ldr	r3, [sp, #4]
    7732:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
    7736:	6028      	str	r0, [r5, #0]
    7738:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
    773c:	463d      	mov	r5, r7
    773e:	e7de      	b.n	76fe <__multadd+0x3e>

00007740 <__hi0bits>:
    7740:	0c03      	lsrs	r3, r0, #16
    7742:	041b      	lsls	r3, r3, #16
    7744:	b9b3      	cbnz	r3, 7774 <__hi0bits+0x34>
    7746:	0400      	lsls	r0, r0, #16
    7748:	2310      	movs	r3, #16
    774a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
    774e:	bf04      	itt	eq
    7750:	0200      	lsleq	r0, r0, #8
    7752:	3308      	addeq	r3, #8
    7754:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
    7758:	bf04      	itt	eq
    775a:	0100      	lsleq	r0, r0, #4
    775c:	3304      	addeq	r3, #4
    775e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
    7762:	bf04      	itt	eq
    7764:	0080      	lsleq	r0, r0, #2
    7766:	3302      	addeq	r3, #2
    7768:	2800      	cmp	r0, #0
    776a:	db07      	blt.n	777c <__hi0bits+0x3c>
    776c:	0042      	lsls	r2, r0, #1
    776e:	d403      	bmi.n	7778 <__hi0bits+0x38>
    7770:	2020      	movs	r0, #32
    7772:	4770      	bx	lr
    7774:	2300      	movs	r3, #0
    7776:	e7e8      	b.n	774a <__hi0bits+0xa>
    7778:	1c58      	adds	r0, r3, #1
    777a:	4770      	bx	lr
    777c:	4618      	mov	r0, r3
    777e:	4770      	bx	lr

00007780 <__lo0bits>:
    7780:	6803      	ldr	r3, [r0, #0]
    7782:	f013 0207 	ands.w	r2, r3, #7
    7786:	d007      	beq.n	7798 <__lo0bits+0x18>
    7788:	07d9      	lsls	r1, r3, #31
    778a:	d420      	bmi.n	77ce <__lo0bits+0x4e>
    778c:	079a      	lsls	r2, r3, #30
    778e:	d420      	bmi.n	77d2 <__lo0bits+0x52>
    7790:	089b      	lsrs	r3, r3, #2
    7792:	6003      	str	r3, [r0, #0]
    7794:	2002      	movs	r0, #2
    7796:	4770      	bx	lr
    7798:	b299      	uxth	r1, r3
    779a:	b909      	cbnz	r1, 77a0 <__lo0bits+0x20>
    779c:	0c1b      	lsrs	r3, r3, #16
    779e:	2210      	movs	r2, #16
    77a0:	f013 0fff 	tst.w	r3, #255	; 0xff
    77a4:	bf04      	itt	eq
    77a6:	0a1b      	lsreq	r3, r3, #8
    77a8:	3208      	addeq	r2, #8
    77aa:	0719      	lsls	r1, r3, #28
    77ac:	bf04      	itt	eq
    77ae:	091b      	lsreq	r3, r3, #4
    77b0:	3204      	addeq	r2, #4
    77b2:	0799      	lsls	r1, r3, #30
    77b4:	bf04      	itt	eq
    77b6:	089b      	lsreq	r3, r3, #2
    77b8:	3202      	addeq	r2, #2
    77ba:	07d9      	lsls	r1, r3, #31
    77bc:	d404      	bmi.n	77c8 <__lo0bits+0x48>
    77be:	085b      	lsrs	r3, r3, #1
    77c0:	d101      	bne.n	77c6 <__lo0bits+0x46>
    77c2:	2020      	movs	r0, #32
    77c4:	4770      	bx	lr
    77c6:	3201      	adds	r2, #1
    77c8:	6003      	str	r3, [r0, #0]
    77ca:	4610      	mov	r0, r2
    77cc:	4770      	bx	lr
    77ce:	2000      	movs	r0, #0
    77d0:	4770      	bx	lr
    77d2:	085b      	lsrs	r3, r3, #1
    77d4:	6003      	str	r3, [r0, #0]
    77d6:	2001      	movs	r0, #1
    77d8:	4770      	bx	lr
    77da:	bf00      	nop

000077dc <__i2b>:
    77dc:	b510      	push	{r4, lr}
    77de:	460c      	mov	r4, r1
    77e0:	2101      	movs	r1, #1
    77e2:	f7ff ff3d 	bl	7660 <_Balloc>
    77e6:	2201      	movs	r2, #1
    77e8:	6144      	str	r4, [r0, #20]
    77ea:	6102      	str	r2, [r0, #16]
    77ec:	bd10      	pop	{r4, pc}
    77ee:	bf00      	nop

000077f0 <__multiply>:
    77f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    77f4:	690d      	ldr	r5, [r1, #16]
    77f6:	6917      	ldr	r7, [r2, #16]
    77f8:	42bd      	cmp	r5, r7
    77fa:	b083      	sub	sp, #12
    77fc:	460c      	mov	r4, r1
    77fe:	4616      	mov	r6, r2
    7800:	da04      	bge.n	780c <__multiply+0x1c>
    7802:	462a      	mov	r2, r5
    7804:	4634      	mov	r4, r6
    7806:	463d      	mov	r5, r7
    7808:	460e      	mov	r6, r1
    780a:	4617      	mov	r7, r2
    780c:	68a3      	ldr	r3, [r4, #8]
    780e:	6861      	ldr	r1, [r4, #4]
    7810:	eb05 0807 	add.w	r8, r5, r7
    7814:	4598      	cmp	r8, r3
    7816:	bfc8      	it	gt
    7818:	3101      	addgt	r1, #1
    781a:	f7ff ff21 	bl	7660 <_Balloc>
    781e:	f100 0c14 	add.w	ip, r0, #20
    7822:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
    7826:	45cc      	cmp	ip, r9
    7828:	9000      	str	r0, [sp, #0]
    782a:	d205      	bcs.n	7838 <__multiply+0x48>
    782c:	4663      	mov	r3, ip
    782e:	2100      	movs	r1, #0
    7830:	f843 1b04 	str.w	r1, [r3], #4
    7834:	4599      	cmp	r9, r3
    7836:	d8fb      	bhi.n	7830 <__multiply+0x40>
    7838:	f106 0214 	add.w	r2, r6, #20
    783c:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
    7840:	f104 0314 	add.w	r3, r4, #20
    7844:	4552      	cmp	r2, sl
    7846:	eb03 0e85 	add.w	lr, r3, r5, lsl #2
    784a:	d254      	bcs.n	78f6 <__multiply+0x106>
    784c:	f8cd 9004 	str.w	r9, [sp, #4]
    7850:	4699      	mov	r9, r3
    7852:	f852 3b04 	ldr.w	r3, [r2], #4
    7856:	fa1f fb83 	uxth.w	fp, r3
    785a:	f1bb 0f00 	cmp.w	fp, #0
    785e:	d020      	beq.n	78a2 <__multiply+0xb2>
    7860:	2000      	movs	r0, #0
    7862:	464f      	mov	r7, r9
    7864:	4666      	mov	r6, ip
    7866:	4605      	mov	r5, r0
    7868:	e000      	b.n	786c <__multiply+0x7c>
    786a:	461e      	mov	r6, r3
    786c:	f857 4b04 	ldr.w	r4, [r7], #4
    7870:	6830      	ldr	r0, [r6, #0]
    7872:	b2a1      	uxth	r1, r4
    7874:	b283      	uxth	r3, r0
    7876:	fb0b 3101 	mla	r1, fp, r1, r3
    787a:	0c24      	lsrs	r4, r4, #16
    787c:	0c00      	lsrs	r0, r0, #16
    787e:	194b      	adds	r3, r1, r5
    7880:	fb0b 0004 	mla	r0, fp, r4, r0
    7884:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    7888:	b299      	uxth	r1, r3
    788a:	4633      	mov	r3, r6
    788c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    7890:	45be      	cmp	lr, r7
    7892:	ea4f 4510 	mov.w	r5, r0, lsr #16
    7896:	f843 1b04 	str.w	r1, [r3], #4
    789a:	d8e6      	bhi.n	786a <__multiply+0x7a>
    789c:	6075      	str	r5, [r6, #4]
    789e:	f852 3c04 	ldr.w	r3, [r2, #-4]
    78a2:	ea5f 4b13 	movs.w	fp, r3, lsr #16
    78a6:	d020      	beq.n	78ea <__multiply+0xfa>
    78a8:	f8dc 3000 	ldr.w	r3, [ip]
    78ac:	4667      	mov	r7, ip
    78ae:	4618      	mov	r0, r3
    78b0:	464d      	mov	r5, r9
    78b2:	2100      	movs	r1, #0
    78b4:	e000      	b.n	78b8 <__multiply+0xc8>
    78b6:	4637      	mov	r7, r6
    78b8:	882c      	ldrh	r4, [r5, #0]
    78ba:	0c00      	lsrs	r0, r0, #16
    78bc:	fb0b 0004 	mla	r0, fp, r4, r0
    78c0:	4401      	add	r1, r0
    78c2:	b29c      	uxth	r4, r3
    78c4:	463e      	mov	r6, r7
    78c6:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
    78ca:	f846 3b04 	str.w	r3, [r6], #4
    78ce:	6878      	ldr	r0, [r7, #4]
    78d0:	f855 4b04 	ldr.w	r4, [r5], #4
    78d4:	b283      	uxth	r3, r0
    78d6:	0c24      	lsrs	r4, r4, #16
    78d8:	fb0b 3404 	mla	r4, fp, r4, r3
    78dc:	eb04 4311 	add.w	r3, r4, r1, lsr #16
    78e0:	45ae      	cmp	lr, r5
    78e2:	ea4f 4113 	mov.w	r1, r3, lsr #16
    78e6:	d8e6      	bhi.n	78b6 <__multiply+0xc6>
    78e8:	607b      	str	r3, [r7, #4]
    78ea:	4592      	cmp	sl, r2
    78ec:	f10c 0c04 	add.w	ip, ip, #4
    78f0:	d8af      	bhi.n	7852 <__multiply+0x62>
    78f2:	f8dd 9004 	ldr.w	r9, [sp, #4]
    78f6:	f1b8 0f00 	cmp.w	r8, #0
    78fa:	dd0b      	ble.n	7914 <__multiply+0x124>
    78fc:	f859 3c04 	ldr.w	r3, [r9, #-4]
    7900:	f1a9 0904 	sub.w	r9, r9, #4
    7904:	b11b      	cbz	r3, 790e <__multiply+0x11e>
    7906:	e005      	b.n	7914 <__multiply+0x124>
    7908:	f859 3d04 	ldr.w	r3, [r9, #-4]!
    790c:	b913      	cbnz	r3, 7914 <__multiply+0x124>
    790e:	f1b8 0801 	subs.w	r8, r8, #1
    7912:	d1f9      	bne.n	7908 <__multiply+0x118>
    7914:	9800      	ldr	r0, [sp, #0]
    7916:	f8c0 8010 	str.w	r8, [r0, #16]
    791a:	b003      	add	sp, #12
    791c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00007920 <__pow5mult>:
    7920:	f012 0303 	ands.w	r3, r2, #3
    7924:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7928:	4614      	mov	r4, r2
    792a:	4607      	mov	r7, r0
    792c:	d12e      	bne.n	798c <__pow5mult+0x6c>
    792e:	460e      	mov	r6, r1
    7930:	10a4      	asrs	r4, r4, #2
    7932:	d01c      	beq.n	796e <__pow5mult+0x4e>
    7934:	6cbd      	ldr	r5, [r7, #72]	; 0x48
    7936:	b395      	cbz	r5, 799e <__pow5mult+0x7e>
    7938:	07e3      	lsls	r3, r4, #31
    793a:	f04f 0800 	mov.w	r8, #0
    793e:	d406      	bmi.n	794e <__pow5mult+0x2e>
    7940:	1064      	asrs	r4, r4, #1
    7942:	d014      	beq.n	796e <__pow5mult+0x4e>
    7944:	6828      	ldr	r0, [r5, #0]
    7946:	b1a8      	cbz	r0, 7974 <__pow5mult+0x54>
    7948:	4605      	mov	r5, r0
    794a:	07e3      	lsls	r3, r4, #31
    794c:	d5f8      	bpl.n	7940 <__pow5mult+0x20>
    794e:	462a      	mov	r2, r5
    7950:	4631      	mov	r1, r6
    7952:	4638      	mov	r0, r7
    7954:	f7ff ff4c 	bl	77f0 <__multiply>
    7958:	b1b6      	cbz	r6, 7988 <__pow5mult+0x68>
    795a:	6872      	ldr	r2, [r6, #4]
    795c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    795e:	1064      	asrs	r4, r4, #1
    7960:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    7964:	6031      	str	r1, [r6, #0]
    7966:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    796a:	4606      	mov	r6, r0
    796c:	d1ea      	bne.n	7944 <__pow5mult+0x24>
    796e:	4630      	mov	r0, r6
    7970:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7974:	462a      	mov	r2, r5
    7976:	4629      	mov	r1, r5
    7978:	4638      	mov	r0, r7
    797a:	f7ff ff39 	bl	77f0 <__multiply>
    797e:	6028      	str	r0, [r5, #0]
    7980:	f8c0 8000 	str.w	r8, [r0]
    7984:	4605      	mov	r5, r0
    7986:	e7e0      	b.n	794a <__pow5mult+0x2a>
    7988:	4606      	mov	r6, r0
    798a:	e7d9      	b.n	7940 <__pow5mult+0x20>
    798c:	1e5a      	subs	r2, r3, #1
    798e:	4d0b      	ldr	r5, [pc, #44]	; (79bc <__pow5mult+0x9c>)
    7990:	2300      	movs	r3, #0
    7992:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
    7996:	f7ff fe93 	bl	76c0 <__multadd>
    799a:	4606      	mov	r6, r0
    799c:	e7c8      	b.n	7930 <__pow5mult+0x10>
    799e:	2101      	movs	r1, #1
    79a0:	4638      	mov	r0, r7
    79a2:	f7ff fe5d 	bl	7660 <_Balloc>
    79a6:	f240 2171 	movw	r1, #625	; 0x271
    79aa:	2201      	movs	r2, #1
    79ac:	2300      	movs	r3, #0
    79ae:	6141      	str	r1, [r0, #20]
    79b0:	6102      	str	r2, [r0, #16]
    79b2:	4605      	mov	r5, r0
    79b4:	64b8      	str	r0, [r7, #72]	; 0x48
    79b6:	6003      	str	r3, [r0, #0]
    79b8:	e7be      	b.n	7938 <__pow5mult+0x18>
    79ba:	bf00      	nop
    79bc:	20000adc 	.word	0x20000adc

000079c0 <__lshift>:
    79c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    79c4:	4691      	mov	r9, r2
    79c6:	690a      	ldr	r2, [r1, #16]
    79c8:	688b      	ldr	r3, [r1, #8]
    79ca:	ea4f 1469 	mov.w	r4, r9, asr #5
    79ce:	eb04 0802 	add.w	r8, r4, r2
    79d2:	f108 0501 	add.w	r5, r8, #1
    79d6:	429d      	cmp	r5, r3
    79d8:	460e      	mov	r6, r1
    79da:	4682      	mov	sl, r0
    79dc:	6849      	ldr	r1, [r1, #4]
    79de:	dd04      	ble.n	79ea <__lshift+0x2a>
    79e0:	005b      	lsls	r3, r3, #1
    79e2:	429d      	cmp	r5, r3
    79e4:	f101 0101 	add.w	r1, r1, #1
    79e8:	dcfa      	bgt.n	79e0 <__lshift+0x20>
    79ea:	4650      	mov	r0, sl
    79ec:	f7ff fe38 	bl	7660 <_Balloc>
    79f0:	2c00      	cmp	r4, #0
    79f2:	f100 0214 	add.w	r2, r0, #20
    79f6:	dd38      	ble.n	7a6a <__lshift+0xaa>
    79f8:	eb02 0384 	add.w	r3, r2, r4, lsl #2
    79fc:	2100      	movs	r1, #0
    79fe:	f842 1b04 	str.w	r1, [r2], #4
    7a02:	4293      	cmp	r3, r2
    7a04:	d1fb      	bne.n	79fe <__lshift+0x3e>
    7a06:	6934      	ldr	r4, [r6, #16]
    7a08:	f106 0114 	add.w	r1, r6, #20
    7a0c:	f019 091f 	ands.w	r9, r9, #31
    7a10:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
    7a14:	d021      	beq.n	7a5a <__lshift+0x9a>
    7a16:	f1c9 0220 	rsb	r2, r9, #32
    7a1a:	2400      	movs	r4, #0
    7a1c:	680f      	ldr	r7, [r1, #0]
    7a1e:	fa07 fc09 	lsl.w	ip, r7, r9
    7a22:	ea4c 0404 	orr.w	r4, ip, r4
    7a26:	469c      	mov	ip, r3
    7a28:	f843 4b04 	str.w	r4, [r3], #4
    7a2c:	f851 4b04 	ldr.w	r4, [r1], #4
    7a30:	458e      	cmp	lr, r1
    7a32:	fa24 f402 	lsr.w	r4, r4, r2
    7a36:	d8f1      	bhi.n	7a1c <__lshift+0x5c>
    7a38:	f8cc 4004 	str.w	r4, [ip, #4]
    7a3c:	b10c      	cbz	r4, 7a42 <__lshift+0x82>
    7a3e:	f108 0502 	add.w	r5, r8, #2
    7a42:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    7a46:	6872      	ldr	r2, [r6, #4]
    7a48:	3d01      	subs	r5, #1
    7a4a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    7a4e:	6105      	str	r5, [r0, #16]
    7a50:	6031      	str	r1, [r6, #0]
    7a52:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    7a56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7a5a:	3b04      	subs	r3, #4
    7a5c:	f851 2b04 	ldr.w	r2, [r1], #4
    7a60:	f843 2f04 	str.w	r2, [r3, #4]!
    7a64:	458e      	cmp	lr, r1
    7a66:	d8f9      	bhi.n	7a5c <__lshift+0x9c>
    7a68:	e7eb      	b.n	7a42 <__lshift+0x82>
    7a6a:	4613      	mov	r3, r2
    7a6c:	e7cb      	b.n	7a06 <__lshift+0x46>
    7a6e:	bf00      	nop

00007a70 <__mcmp>:
    7a70:	6902      	ldr	r2, [r0, #16]
    7a72:	690b      	ldr	r3, [r1, #16]
    7a74:	1ad2      	subs	r2, r2, r3
    7a76:	d113      	bne.n	7aa0 <__mcmp+0x30>
    7a78:	009b      	lsls	r3, r3, #2
    7a7a:	3014      	adds	r0, #20
    7a7c:	3114      	adds	r1, #20
    7a7e:	4419      	add	r1, r3
    7a80:	b410      	push	{r4}
    7a82:	4403      	add	r3, r0
    7a84:	e001      	b.n	7a8a <__mcmp+0x1a>
    7a86:	4298      	cmp	r0, r3
    7a88:	d20c      	bcs.n	7aa4 <__mcmp+0x34>
    7a8a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
    7a8e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
    7a92:	4294      	cmp	r4, r2
    7a94:	d0f7      	beq.n	7a86 <__mcmp+0x16>
    7a96:	d309      	bcc.n	7aac <__mcmp+0x3c>
    7a98:	2001      	movs	r0, #1
    7a9a:	f85d 4b04 	ldr.w	r4, [sp], #4
    7a9e:	4770      	bx	lr
    7aa0:	4610      	mov	r0, r2
    7aa2:	4770      	bx	lr
    7aa4:	2000      	movs	r0, #0
    7aa6:	f85d 4b04 	ldr.w	r4, [sp], #4
    7aaa:	4770      	bx	lr
    7aac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7ab0:	e7f3      	b.n	7a9a <__mcmp+0x2a>
    7ab2:	bf00      	nop

00007ab4 <__mdiff>:
    7ab4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    7ab8:	690b      	ldr	r3, [r1, #16]
    7aba:	460f      	mov	r7, r1
    7abc:	6911      	ldr	r1, [r2, #16]
    7abe:	1a5b      	subs	r3, r3, r1
    7ac0:	2b00      	cmp	r3, #0
    7ac2:	4690      	mov	r8, r2
    7ac4:	d117      	bne.n	7af6 <__mdiff+0x42>
    7ac6:	0089      	lsls	r1, r1, #2
    7ac8:	f107 0214 	add.w	r2, r7, #20
    7acc:	f108 0514 	add.w	r5, r8, #20
    7ad0:	1853      	adds	r3, r2, r1
    7ad2:	4429      	add	r1, r5
    7ad4:	e001      	b.n	7ada <__mdiff+0x26>
    7ad6:	429a      	cmp	r2, r3
    7ad8:	d25e      	bcs.n	7b98 <__mdiff+0xe4>
    7ada:	f853 6d04 	ldr.w	r6, [r3, #-4]!
    7ade:	f851 4d04 	ldr.w	r4, [r1, #-4]!
    7ae2:	42a6      	cmp	r6, r4
    7ae4:	d0f7      	beq.n	7ad6 <__mdiff+0x22>
    7ae6:	d260      	bcs.n	7baa <__mdiff+0xf6>
    7ae8:	463b      	mov	r3, r7
    7aea:	4614      	mov	r4, r2
    7aec:	4647      	mov	r7, r8
    7aee:	f04f 0901 	mov.w	r9, #1
    7af2:	4698      	mov	r8, r3
    7af4:	e006      	b.n	7b04 <__mdiff+0x50>
    7af6:	db5d      	blt.n	7bb4 <__mdiff+0x100>
    7af8:	f107 0514 	add.w	r5, r7, #20
    7afc:	f102 0414 	add.w	r4, r2, #20
    7b00:	f04f 0900 	mov.w	r9, #0
    7b04:	6879      	ldr	r1, [r7, #4]
    7b06:	f7ff fdab 	bl	7660 <_Balloc>
    7b0a:	f8d8 3010 	ldr.w	r3, [r8, #16]
    7b0e:	693e      	ldr	r6, [r7, #16]
    7b10:	f8c0 900c 	str.w	r9, [r0, #12]
    7b14:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
    7b18:	46a6      	mov	lr, r4
    7b1a:	eb05 0786 	add.w	r7, r5, r6, lsl #2
    7b1e:	f100 0414 	add.w	r4, r0, #20
    7b22:	2300      	movs	r3, #0
    7b24:	f85e 1b04 	ldr.w	r1, [lr], #4
    7b28:	f855 8b04 	ldr.w	r8, [r5], #4
    7b2c:	b28a      	uxth	r2, r1
    7b2e:	fa13 f388 	uxtah	r3, r3, r8
    7b32:	0c09      	lsrs	r1, r1, #16
    7b34:	1a9a      	subs	r2, r3, r2
    7b36:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
    7b3a:	eb03 4322 	add.w	r3, r3, r2, asr #16
    7b3e:	b292      	uxth	r2, r2
    7b40:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    7b44:	45f4      	cmp	ip, lr
    7b46:	f844 2b04 	str.w	r2, [r4], #4
    7b4a:	ea4f 4323 	mov.w	r3, r3, asr #16
    7b4e:	d8e9      	bhi.n	7b24 <__mdiff+0x70>
    7b50:	42af      	cmp	r7, r5
    7b52:	d917      	bls.n	7b84 <__mdiff+0xd0>
    7b54:	46a4      	mov	ip, r4
    7b56:	4629      	mov	r1, r5
    7b58:	f851 eb04 	ldr.w	lr, [r1], #4
    7b5c:	fa13 f28e 	uxtah	r2, r3, lr
    7b60:	1413      	asrs	r3, r2, #16
    7b62:	eb03 431e 	add.w	r3, r3, lr, lsr #16
    7b66:	b292      	uxth	r2, r2
    7b68:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    7b6c:	428f      	cmp	r7, r1
    7b6e:	f84c 2b04 	str.w	r2, [ip], #4
    7b72:	ea4f 4323 	mov.w	r3, r3, asr #16
    7b76:	d8ef      	bhi.n	7b58 <__mdiff+0xa4>
    7b78:	43ed      	mvns	r5, r5
    7b7a:	443d      	add	r5, r7
    7b7c:	f025 0503 	bic.w	r5, r5, #3
    7b80:	3504      	adds	r5, #4
    7b82:	442c      	add	r4, r5
    7b84:	3c04      	subs	r4, #4
    7b86:	b922      	cbnz	r2, 7b92 <__mdiff+0xde>
    7b88:	f854 3d04 	ldr.w	r3, [r4, #-4]!
    7b8c:	3e01      	subs	r6, #1
    7b8e:	2b00      	cmp	r3, #0
    7b90:	d0fa      	beq.n	7b88 <__mdiff+0xd4>
    7b92:	6106      	str	r6, [r0, #16]
    7b94:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7b98:	2100      	movs	r1, #0
    7b9a:	f7ff fd61 	bl	7660 <_Balloc>
    7b9e:	2201      	movs	r2, #1
    7ba0:	2300      	movs	r3, #0
    7ba2:	6102      	str	r2, [r0, #16]
    7ba4:	6143      	str	r3, [r0, #20]
    7ba6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7baa:	462c      	mov	r4, r5
    7bac:	f04f 0900 	mov.w	r9, #0
    7bb0:	4615      	mov	r5, r2
    7bb2:	e7a7      	b.n	7b04 <__mdiff+0x50>
    7bb4:	463b      	mov	r3, r7
    7bb6:	f107 0414 	add.w	r4, r7, #20
    7bba:	f108 0514 	add.w	r5, r8, #20
    7bbe:	4647      	mov	r7, r8
    7bc0:	f04f 0901 	mov.w	r9, #1
    7bc4:	4698      	mov	r8, r3
    7bc6:	e79d      	b.n	7b04 <__mdiff+0x50>

00007bc8 <__d2b>:
    7bc8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7bcc:	ec57 6b10 	vmov	r6, r7, d0
    7bd0:	b083      	sub	sp, #12
    7bd2:	4688      	mov	r8, r1
    7bd4:	2101      	movs	r1, #1
    7bd6:	463c      	mov	r4, r7
    7bd8:	f3c7 550a 	ubfx	r5, r7, #20, #11
    7bdc:	4617      	mov	r7, r2
    7bde:	f7ff fd3f 	bl	7660 <_Balloc>
    7be2:	f3c4 0413 	ubfx	r4, r4, #0, #20
    7be6:	4681      	mov	r9, r0
    7be8:	b10d      	cbz	r5, 7bee <__d2b+0x26>
    7bea:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
    7bee:	9401      	str	r4, [sp, #4]
    7bf0:	b31e      	cbz	r6, 7c3a <__d2b+0x72>
    7bf2:	a802      	add	r0, sp, #8
    7bf4:	f840 6d08 	str.w	r6, [r0, #-8]!
    7bf8:	f7ff fdc2 	bl	7780 <__lo0bits>
    7bfc:	2800      	cmp	r0, #0
    7bfe:	d134      	bne.n	7c6a <__d2b+0xa2>
    7c00:	e89d 000c 	ldmia.w	sp, {r2, r3}
    7c04:	f8c9 2014 	str.w	r2, [r9, #20]
    7c08:	2b00      	cmp	r3, #0
    7c0a:	bf0c      	ite	eq
    7c0c:	2101      	moveq	r1, #1
    7c0e:	2102      	movne	r1, #2
    7c10:	f8c9 3018 	str.w	r3, [r9, #24]
    7c14:	f8c9 1010 	str.w	r1, [r9, #16]
    7c18:	b9dd      	cbnz	r5, 7c52 <__d2b+0x8a>
    7c1a:	eb09 0381 	add.w	r3, r9, r1, lsl #2
    7c1e:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
    7c22:	f8c8 0000 	str.w	r0, [r8]
    7c26:	6918      	ldr	r0, [r3, #16]
    7c28:	f7ff fd8a 	bl	7740 <__hi0bits>
    7c2c:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
    7c30:	6038      	str	r0, [r7, #0]
    7c32:	4648      	mov	r0, r9
    7c34:	b003      	add	sp, #12
    7c36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    7c3a:	a801      	add	r0, sp, #4
    7c3c:	f7ff fda0 	bl	7780 <__lo0bits>
    7c40:	9b01      	ldr	r3, [sp, #4]
    7c42:	f8c9 3014 	str.w	r3, [r9, #20]
    7c46:	2101      	movs	r1, #1
    7c48:	3020      	adds	r0, #32
    7c4a:	f8c9 1010 	str.w	r1, [r9, #16]
    7c4e:	2d00      	cmp	r5, #0
    7c50:	d0e3      	beq.n	7c1a <__d2b+0x52>
    7c52:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
    7c56:	4405      	add	r5, r0
    7c58:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
    7c5c:	f8c8 5000 	str.w	r5, [r8]
    7c60:	6038      	str	r0, [r7, #0]
    7c62:	4648      	mov	r0, r9
    7c64:	b003      	add	sp, #12
    7c66:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    7c6a:	e89d 000c 	ldmia.w	sp, {r2, r3}
    7c6e:	f1c0 0120 	rsb	r1, r0, #32
    7c72:	fa03 f101 	lsl.w	r1, r3, r1
    7c76:	430a      	orrs	r2, r1
    7c78:	40c3      	lsrs	r3, r0
    7c7a:	9301      	str	r3, [sp, #4]
    7c7c:	f8c9 2014 	str.w	r2, [r9, #20]
    7c80:	e7c2      	b.n	7c08 <__d2b+0x40>
    7c82:	bf00      	nop

00007c84 <_vasnprintf_r>:
    7c84:	b570      	push	{r4, r5, r6, lr}
    7c86:	4615      	mov	r5, r2
    7c88:	b09a      	sub	sp, #104	; 0x68
    7c8a:	6814      	ldr	r4, [r2, #0]
    7c8c:	b109      	cbz	r1, 7c92 <_vasnprintf_r+0xe>
    7c8e:	2c00      	cmp	r4, #0
    7c90:	d11a      	bne.n	7cc8 <_vasnprintf_r+0x44>
    7c92:	2400      	movs	r4, #0
    7c94:	f44f 7222 	mov.w	r2, #648	; 0x288
    7c98:	f8ad 200c 	strh.w	r2, [sp, #12]
    7c9c:	9400      	str	r4, [sp, #0]
    7c9e:	9404      	str	r4, [sp, #16]
    7ca0:	461a      	mov	r2, r3
    7ca2:	f64f 76ff 	movw	r6, #65535	; 0xffff
    7ca6:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    7ca8:	9402      	str	r4, [sp, #8]
    7caa:	4669      	mov	r1, sp
    7cac:	9405      	str	r4, [sp, #20]
    7cae:	f8ad 600e 	strh.w	r6, [sp, #14]
    7cb2:	f000 ff21 	bl	8af8 <_svfprintf_r>
    7cb6:	2800      	cmp	r0, #0
    7cb8:	db11      	blt.n	7cde <_vasnprintf_r+0x5a>
    7cba:	9b00      	ldr	r3, [sp, #0]
    7cbc:	6028      	str	r0, [r5, #0]
    7cbe:	2200      	movs	r2, #0
    7cc0:	701a      	strb	r2, [r3, #0]
    7cc2:	9804      	ldr	r0, [sp, #16]
    7cc4:	b01a      	add	sp, #104	; 0x68
    7cc6:	bd70      	pop	{r4, r5, r6, pc}
    7cc8:	f44f 62c1 	mov.w	r2, #1544	; 0x608
    7ccc:	9100      	str	r1, [sp, #0]
    7cce:	9104      	str	r1, [sp, #16]
    7cd0:	f8ad 200c 	strh.w	r2, [sp, #12]
    7cd4:	dae4      	bge.n	7ca0 <_vasnprintf_r+0x1c>
    7cd6:	238b      	movs	r3, #139	; 0x8b
    7cd8:	6003      	str	r3, [r0, #0]
    7cda:	2000      	movs	r0, #0
    7cdc:	e7f2      	b.n	7cc4 <_vasnprintf_r+0x40>
    7cde:	2000      	movs	r0, #0
    7ce0:	e7f0      	b.n	7cc4 <_vasnprintf_r+0x40>
    7ce2:	bf00      	nop

00007ce4 <_calloc_r>:
    7ce4:	b510      	push	{r4, lr}
    7ce6:	fb02 f101 	mul.w	r1, r2, r1
    7cea:	f7fe f96b 	bl	5fc4 <_malloc_r>
    7cee:	4604      	mov	r4, r0
    7cf0:	b1d8      	cbz	r0, 7d2a <_calloc_r+0x46>
    7cf2:	f850 2c04 	ldr.w	r2, [r0, #-4]
    7cf6:	f022 0203 	bic.w	r2, r2, #3
    7cfa:	3a04      	subs	r2, #4
    7cfc:	2a24      	cmp	r2, #36	; 0x24
    7cfe:	d818      	bhi.n	7d32 <_calloc_r+0x4e>
    7d00:	2a13      	cmp	r2, #19
    7d02:	d914      	bls.n	7d2e <_calloc_r+0x4a>
    7d04:	2300      	movs	r3, #0
    7d06:	2a1b      	cmp	r2, #27
    7d08:	6003      	str	r3, [r0, #0]
    7d0a:	6043      	str	r3, [r0, #4]
    7d0c:	d916      	bls.n	7d3c <_calloc_r+0x58>
    7d0e:	2a24      	cmp	r2, #36	; 0x24
    7d10:	6083      	str	r3, [r0, #8]
    7d12:	60c3      	str	r3, [r0, #12]
    7d14:	bf11      	iteee	ne
    7d16:	f100 0210 	addne.w	r2, r0, #16
    7d1a:	6103      	streq	r3, [r0, #16]
    7d1c:	6143      	streq	r3, [r0, #20]
    7d1e:	f100 0218 	addeq.w	r2, r0, #24
    7d22:	2300      	movs	r3, #0
    7d24:	6013      	str	r3, [r2, #0]
    7d26:	6053      	str	r3, [r2, #4]
    7d28:	6093      	str	r3, [r2, #8]
    7d2a:	4620      	mov	r0, r4
    7d2c:	bd10      	pop	{r4, pc}
    7d2e:	4602      	mov	r2, r0
    7d30:	e7f7      	b.n	7d22 <_calloc_r+0x3e>
    7d32:	2100      	movs	r1, #0
    7d34:	f7fe fd12 	bl	675c <memset>
    7d38:	4620      	mov	r0, r4
    7d3a:	bd10      	pop	{r4, pc}
    7d3c:	f100 0208 	add.w	r2, r0, #8
    7d40:	e7ef      	b.n	7d22 <_calloc_r+0x3e>
    7d42:	bf00      	nop

00007d44 <quorem>:
    7d44:	6902      	ldr	r2, [r0, #16]
    7d46:	690b      	ldr	r3, [r1, #16]
    7d48:	4293      	cmp	r3, r2
    7d4a:	f300 808d 	bgt.w	7e68 <quorem+0x124>
    7d4e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7d52:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    7d56:	f101 0714 	add.w	r7, r1, #20
    7d5a:	f100 0b14 	add.w	fp, r0, #20
    7d5e:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
    7d62:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    7d66:	ea4f 0488 	mov.w	r4, r8, lsl #2
    7d6a:	b083      	sub	sp, #12
    7d6c:	3201      	adds	r2, #1
    7d6e:	fbb3 f9f2 	udiv	r9, r3, r2
    7d72:	eb0b 0304 	add.w	r3, fp, r4
    7d76:	9400      	str	r4, [sp, #0]
    7d78:	eb07 0a04 	add.w	sl, r7, r4
    7d7c:	9301      	str	r3, [sp, #4]
    7d7e:	f1b9 0f00 	cmp.w	r9, #0
    7d82:	d039      	beq.n	7df8 <quorem+0xb4>
    7d84:	2500      	movs	r5, #0
    7d86:	46bc      	mov	ip, r7
    7d88:	46de      	mov	lr, fp
    7d8a:	462b      	mov	r3, r5
    7d8c:	f85c 6b04 	ldr.w	r6, [ip], #4
    7d90:	f8de 2000 	ldr.w	r2, [lr]
    7d94:	b2b4      	uxth	r4, r6
    7d96:	fb09 5504 	mla	r5, r9, r4, r5
    7d9a:	0c36      	lsrs	r6, r6, #16
    7d9c:	0c2c      	lsrs	r4, r5, #16
    7d9e:	fb09 4406 	mla	r4, r9, r6, r4
    7da2:	b2ad      	uxth	r5, r5
    7da4:	1b5b      	subs	r3, r3, r5
    7da6:	b2a6      	uxth	r6, r4
    7da8:	fa13 f382 	uxtah	r3, r3, r2
    7dac:	ebc6 4612 	rsb	r6, r6, r2, lsr #16
    7db0:	eb06 4623 	add.w	r6, r6, r3, asr #16
    7db4:	b29b      	uxth	r3, r3
    7db6:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    7dba:	45e2      	cmp	sl, ip
    7dbc:	f84e 3b04 	str.w	r3, [lr], #4
    7dc0:	ea4f 4514 	mov.w	r5, r4, lsr #16
    7dc4:	ea4f 4326 	mov.w	r3, r6, asr #16
    7dc8:	d2e0      	bcs.n	7d8c <quorem+0x48>
    7dca:	9b00      	ldr	r3, [sp, #0]
    7dcc:	f85b 3003 	ldr.w	r3, [fp, r3]
    7dd0:	b993      	cbnz	r3, 7df8 <quorem+0xb4>
    7dd2:	9c01      	ldr	r4, [sp, #4]
    7dd4:	1f23      	subs	r3, r4, #4
    7dd6:	459b      	cmp	fp, r3
    7dd8:	d20c      	bcs.n	7df4 <quorem+0xb0>
    7dda:	f854 3c04 	ldr.w	r3, [r4, #-4]
    7dde:	b94b      	cbnz	r3, 7df4 <quorem+0xb0>
    7de0:	f1a4 0308 	sub.w	r3, r4, #8
    7de4:	e002      	b.n	7dec <quorem+0xa8>
    7de6:	681a      	ldr	r2, [r3, #0]
    7de8:	3b04      	subs	r3, #4
    7dea:	b91a      	cbnz	r2, 7df4 <quorem+0xb0>
    7dec:	459b      	cmp	fp, r3
    7dee:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    7df2:	d3f8      	bcc.n	7de6 <quorem+0xa2>
    7df4:	f8c0 8010 	str.w	r8, [r0, #16]
    7df8:	4604      	mov	r4, r0
    7dfa:	f7ff fe39 	bl	7a70 <__mcmp>
    7dfe:	2800      	cmp	r0, #0
    7e00:	db2e      	blt.n	7e60 <quorem+0x11c>
    7e02:	f109 0901 	add.w	r9, r9, #1
    7e06:	465d      	mov	r5, fp
    7e08:	2300      	movs	r3, #0
    7e0a:	f857 1b04 	ldr.w	r1, [r7], #4
    7e0e:	6828      	ldr	r0, [r5, #0]
    7e10:	b28a      	uxth	r2, r1
    7e12:	1a9a      	subs	r2, r3, r2
    7e14:	0c09      	lsrs	r1, r1, #16
    7e16:	fa12 f280 	uxtah	r2, r2, r0
    7e1a:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
    7e1e:	eb03 4322 	add.w	r3, r3, r2, asr #16
    7e22:	b291      	uxth	r1, r2
    7e24:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    7e28:	45ba      	cmp	sl, r7
    7e2a:	f845 1b04 	str.w	r1, [r5], #4
    7e2e:	ea4f 4323 	mov.w	r3, r3, asr #16
    7e32:	d2ea      	bcs.n	7e0a <quorem+0xc6>
    7e34:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
    7e38:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
    7e3c:	b982      	cbnz	r2, 7e60 <quorem+0x11c>
    7e3e:	1f1a      	subs	r2, r3, #4
    7e40:	4593      	cmp	fp, r2
    7e42:	d20b      	bcs.n	7e5c <quorem+0x118>
    7e44:	f853 2c04 	ldr.w	r2, [r3, #-4]
    7e48:	b942      	cbnz	r2, 7e5c <quorem+0x118>
    7e4a:	3b08      	subs	r3, #8
    7e4c:	e002      	b.n	7e54 <quorem+0x110>
    7e4e:	681a      	ldr	r2, [r3, #0]
    7e50:	3b04      	subs	r3, #4
    7e52:	b91a      	cbnz	r2, 7e5c <quorem+0x118>
    7e54:	459b      	cmp	fp, r3
    7e56:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    7e5a:	d3f8      	bcc.n	7e4e <quorem+0x10a>
    7e5c:	f8c4 8010 	str.w	r8, [r4, #16]
    7e60:	4648      	mov	r0, r9
    7e62:	b003      	add	sp, #12
    7e64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e68:	2000      	movs	r0, #0
    7e6a:	4770      	bx	lr
    7e6c:	0000      	movs	r0, r0
	...

00007e70 <_dtoa_r>:
    7e70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7e74:	ec57 6b10 	vmov	r6, r7, d0
    7e78:	b093      	sub	sp, #76	; 0x4c
    7e7a:	6c05      	ldr	r5, [r0, #64]	; 0x40
    7e7c:	9101      	str	r1, [sp, #4]
    7e7e:	4604      	mov	r4, r0
    7e80:	4690      	mov	r8, r2
    7e82:	9304      	str	r3, [sp, #16]
    7e84:	ee10 aa10 	vmov	sl, s0
    7e88:	46bb      	mov	fp, r7
    7e8a:	b14d      	cbz	r5, 7ea0 <_dtoa_r+0x30>
    7e8c:	6c42      	ldr	r2, [r0, #68]	; 0x44
    7e8e:	606a      	str	r2, [r5, #4]
    7e90:	2301      	movs	r3, #1
    7e92:	4093      	lsls	r3, r2
    7e94:	60ab      	str	r3, [r5, #8]
    7e96:	4629      	mov	r1, r5
    7e98:	f7ff fc08 	bl	76ac <_Bfree>
    7e9c:	2300      	movs	r3, #0
    7e9e:	6423      	str	r3, [r4, #64]	; 0x40
    7ea0:	f1bb 0f00 	cmp.w	fp, #0
    7ea4:	465e      	mov	r6, fp
    7ea6:	db34      	blt.n	7f12 <_dtoa_r+0xa2>
    7ea8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    7eaa:	2300      	movs	r3, #0
    7eac:	6013      	str	r3, [r2, #0]
    7eae:	4bc4      	ldr	r3, [pc, #784]	; (81c0 <_dtoa_r+0x350>)
    7eb0:	461a      	mov	r2, r3
    7eb2:	4033      	ands	r3, r6
    7eb4:	4293      	cmp	r3, r2
    7eb6:	d015      	beq.n	7ee4 <_dtoa_r+0x74>
    7eb8:	ec4b ab17 	vmov	d7, sl, fp
    7ebc:	eeb5 7b40 	vcmp.f64	d7, #0.0
    7ec0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    7ec4:	e9cd ab02 	strd	sl, fp, [sp, #8]
    7ec8:	d12a      	bne.n	7f20 <_dtoa_r+0xb0>
    7eca:	9a04      	ldr	r2, [sp, #16]
    7ecc:	2301      	movs	r3, #1
    7ece:	6013      	str	r3, [r2, #0]
    7ed0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    7ed2:	2b00      	cmp	r3, #0
    7ed4:	f000 80b7 	beq.w	8046 <_dtoa_r+0x1d6>
    7ed8:	48ba      	ldr	r0, [pc, #744]	; (81c4 <_dtoa_r+0x354>)
    7eda:	6018      	str	r0, [r3, #0]
    7edc:	3801      	subs	r0, #1
    7ede:	b013      	add	sp, #76	; 0x4c
    7ee0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7ee4:	9a04      	ldr	r2, [sp, #16]
    7ee6:	f242 730f 	movw	r3, #9999	; 0x270f
    7eea:	6013      	str	r3, [r2, #0]
    7eec:	f1ba 0f00 	cmp.w	sl, #0
    7ef0:	f000 8092 	beq.w	8018 <_dtoa_r+0x1a8>
    7ef4:	48b4      	ldr	r0, [pc, #720]	; (81c8 <_dtoa_r+0x358>)
    7ef6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    7ef8:	2b00      	cmp	r3, #0
    7efa:	d0f0      	beq.n	7ede <_dtoa_r+0x6e>
    7efc:	78c3      	ldrb	r3, [r0, #3]
    7efe:	2b00      	cmp	r3, #0
    7f00:	f000 80a3 	beq.w	804a <_dtoa_r+0x1da>
    7f04:	f100 0308 	add.w	r3, r0, #8
    7f08:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    7f0a:	6013      	str	r3, [r2, #0]
    7f0c:	b013      	add	sp, #76	; 0x4c
    7f0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7f12:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    7f14:	2301      	movs	r3, #1
    7f16:	f02b 4600 	bic.w	r6, fp, #2147483648	; 0x80000000
    7f1a:	6013      	str	r3, [r2, #0]
    7f1c:	46b3      	mov	fp, r6
    7f1e:	e7c6      	b.n	7eae <_dtoa_r+0x3e>
    7f20:	a911      	add	r1, sp, #68	; 0x44
    7f22:	aa10      	add	r2, sp, #64	; 0x40
    7f24:	ed9d 0b02 	vldr	d0, [sp, #8]
    7f28:	4620      	mov	r0, r4
    7f2a:	f7ff fe4d 	bl	7bc8 <__d2b>
    7f2e:	0d31      	lsrs	r1, r6, #20
    7f30:	9007      	str	r0, [sp, #28]
    7f32:	d17a      	bne.n	802a <_dtoa_r+0x1ba>
    7f34:	9810      	ldr	r0, [sp, #64]	; 0x40
    7f36:	9911      	ldr	r1, [sp, #68]	; 0x44
    7f38:	4401      	add	r1, r0
    7f3a:	f201 4332 	addw	r3, r1, #1074	; 0x432
    7f3e:	2b20      	cmp	r3, #32
    7f40:	f340 8241 	ble.w	83c6 <_dtoa_r+0x556>
    7f44:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    7f48:	f201 4212 	addw	r2, r1, #1042	; 0x412
    7f4c:	409e      	lsls	r6, r3
    7f4e:	fa2a f302 	lsr.w	r3, sl, r2
    7f52:	4333      	orrs	r3, r6
    7f54:	ee07 3a90 	vmov	s15, r3
    7f58:	eeb8 7b67 	vcvt.f64.u32	d7, s15
    7f5c:	2501      	movs	r5, #1
    7f5e:	ec53 2b17 	vmov	r2, r3, d7
    7f62:	3901      	subs	r1, #1
    7f64:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
    7f68:	950a      	str	r5, [sp, #40]	; 0x28
    7f6a:	ec43 2b17 	vmov	d7, r2, r3
    7f6e:	eeb7 6b08 	vmov.f64	d6, #120	; 0x3fc00000  1.5
    7f72:	ed9f 4b8d 	vldr	d4, [pc, #564]	; 81a8 <_dtoa_r+0x338>
    7f76:	ee37 6b46 	vsub.f64	d6, d7, d6
    7f7a:	ed9f 7b8d 	vldr	d7, [pc, #564]	; 81b0 <_dtoa_r+0x340>
    7f7e:	ed9f 5b8e 	vldr	d5, [pc, #568]	; 81b8 <_dtoa_r+0x348>
    7f82:	eea6 7b04 	vfma.f64	d7, d6, d4
    7f86:	ee06 1a90 	vmov	s13, r1
    7f8a:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    7f8e:	eea6 7b05 	vfma.f64	d7, d6, d5
    7f92:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    7f96:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    7f9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    7f9e:	edcd 6a02 	vstr	s13, [sp, #8]
    7fa2:	f100 811c 	bmi.w	81de <_dtoa_r+0x36e>
    7fa6:	9d02      	ldr	r5, [sp, #8]
    7fa8:	2d16      	cmp	r5, #22
    7faa:	f200 8115 	bhi.w	81d8 <_dtoa_r+0x368>
    7fae:	4b87      	ldr	r3, [pc, #540]	; (81cc <_dtoa_r+0x35c>)
    7fb0:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    7fb4:	ed93 7b00 	vldr	d7, [r3]
    7fb8:	ec4b ab16 	vmov	d6, sl, fp
    7fbc:	eeb4 7bc6 	vcmpe.f64	d7, d6
    7fc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    7fc4:	f340 8206 	ble.w	83d4 <_dtoa_r+0x564>
    7fc8:	1e6b      	subs	r3, r5, #1
    7fca:	9302      	str	r3, [sp, #8]
    7fcc:	2300      	movs	r3, #0
    7fce:	930c      	str	r3, [sp, #48]	; 0x30
    7fd0:	1a41      	subs	r1, r0, r1
    7fd2:	f1b1 0901 	subs.w	r9, r1, #1
    7fd6:	f100 8117 	bmi.w	8208 <_dtoa_r+0x398>
    7fda:	2300      	movs	r3, #0
    7fdc:	9306      	str	r3, [sp, #24]
    7fde:	9b02      	ldr	r3, [sp, #8]
    7fe0:	2b00      	cmp	r3, #0
    7fe2:	f2c0 8108 	blt.w	81f6 <_dtoa_r+0x386>
    7fe6:	4499      	add	r9, r3
    7fe8:	930b      	str	r3, [sp, #44]	; 0x2c
    7fea:	2300      	movs	r3, #0
    7fec:	9305      	str	r3, [sp, #20]
    7fee:	9b01      	ldr	r3, [sp, #4]
    7ff0:	2b09      	cmp	r3, #9
    7ff2:	d82c      	bhi.n	804e <_dtoa_r+0x1de>
    7ff4:	2b05      	cmp	r3, #5
    7ff6:	f340 855f 	ble.w	8ab8 <_dtoa_r+0xc48>
    7ffa:	3b04      	subs	r3, #4
    7ffc:	9301      	str	r3, [sp, #4]
    7ffe:	2300      	movs	r3, #0
    8000:	930e      	str	r3, [sp, #56]	; 0x38
    8002:	9b01      	ldr	r3, [sp, #4]
    8004:	3b02      	subs	r3, #2
    8006:	2b03      	cmp	r3, #3
    8008:	f200 855f 	bhi.w	8aca <_dtoa_r+0xc5a>
    800c:	e8df f013 	tbh	[pc, r3, lsl #1]
    8010:	01e502a9 	.word	0x01e502a9
    8014:	03c802b5 	.word	0x03c802b5
    8018:	4b6b      	ldr	r3, [pc, #428]	; (81c8 <_dtoa_r+0x358>)
    801a:	4a6d      	ldr	r2, [pc, #436]	; (81d0 <_dtoa_r+0x360>)
    801c:	f3c6 0013 	ubfx	r0, r6, #0, #20
    8020:	2800      	cmp	r0, #0
    8022:	bf14      	ite	ne
    8024:	4618      	movne	r0, r3
    8026:	4610      	moveq	r0, r2
    8028:	e765      	b.n	7ef6 <_dtoa_r+0x86>
    802a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    802e:	f3c3 0013 	ubfx	r0, r3, #0, #20
    8032:	f040 537f 	orr.w	r3, r0, #1069547520	; 0x3fc00000
    8036:	2500      	movs	r5, #0
    8038:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
    803c:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    8040:	9810      	ldr	r0, [sp, #64]	; 0x40
    8042:	950a      	str	r5, [sp, #40]	; 0x28
    8044:	e791      	b.n	7f6a <_dtoa_r+0xfa>
    8046:	4863      	ldr	r0, [pc, #396]	; (81d4 <_dtoa_r+0x364>)
    8048:	e749      	b.n	7ede <_dtoa_r+0x6e>
    804a:	1cc3      	adds	r3, r0, #3
    804c:	e75c      	b.n	7f08 <_dtoa_r+0x98>
    804e:	2100      	movs	r1, #0
    8050:	6461      	str	r1, [r4, #68]	; 0x44
    8052:	4620      	mov	r0, r4
    8054:	4688      	mov	r8, r1
    8056:	9101      	str	r1, [sp, #4]
    8058:	f7ff fb02 	bl	7660 <_Balloc>
    805c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    8060:	2301      	movs	r3, #1
    8062:	9008      	str	r0, [sp, #32]
    8064:	6420      	str	r0, [r4, #64]	; 0x40
    8066:	970d      	str	r7, [sp, #52]	; 0x34
    8068:	9309      	str	r3, [sp, #36]	; 0x24
    806a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    806c:	2b00      	cmp	r3, #0
    806e:	db7a      	blt.n	8166 <_dtoa_r+0x2f6>
    8070:	9a02      	ldr	r2, [sp, #8]
    8072:	2a0e      	cmp	r2, #14
    8074:	dc77      	bgt.n	8166 <_dtoa_r+0x2f6>
    8076:	4b55      	ldr	r3, [pc, #340]	; (81cc <_dtoa_r+0x35c>)
    8078:	f1b8 0f00 	cmp.w	r8, #0
    807c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    8080:	ed93 4b00 	vldr	d4, [r3]
    8084:	f2c0 8284 	blt.w	8590 <_dtoa_r+0x720>
    8088:	eeb1 2b44 	vneg.f64	d2, d4
    808c:	ec4b ab17 	vmov	d7, sl, fp
    8090:	ee87 6b04 	vdiv.f64	d6, d7, d4
    8094:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    8098:	9a08      	ldr	r2, [sp, #32]
    809a:	ee16 3a10 	vmov	r3, s12
    809e:	2f01      	cmp	r7, #1
    80a0:	f103 0330 	add.w	r3, r3, #48	; 0x30
    80a4:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    80a8:	f102 0b01 	add.w	fp, r2, #1
    80ac:	7013      	strb	r3, [r2, #0]
    80ae:	eea2 7b05 	vfma.f64	d7, d2, d5
    80b2:	d022      	beq.n	80fa <_dtoa_r+0x28a>
    80b4:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
    80b8:	ee27 7b03 	vmul.f64	d7, d7, d3
    80bc:	eeb5 7b40 	vcmp.f64	d7, #0.0
    80c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    80c4:	d03a      	beq.n	813c <_dtoa_r+0x2cc>
    80c6:	9a08      	ldr	r2, [sp, #32]
    80c8:	e006      	b.n	80d8 <_dtoa_r+0x268>
    80ca:	ee27 7b03 	vmul.f64	d7, d7, d3
    80ce:	eeb5 7b40 	vcmp.f64	d7, #0.0
    80d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    80d6:	d031      	beq.n	813c <_dtoa_r+0x2cc>
    80d8:	ee87 6b04 	vdiv.f64	d6, d7, d4
    80dc:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    80e0:	ee16 3a10 	vmov	r3, s12
    80e4:	3330      	adds	r3, #48	; 0x30
    80e6:	f80b 3b01 	strb.w	r3, [fp], #1
    80ea:	ebc2 030b 	rsb	r3, r2, fp
    80ee:	42bb      	cmp	r3, r7
    80f0:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    80f4:	eea2 7b05 	vfma.f64	d7, d2, d5
    80f8:	d1e7      	bne.n	80ca <_dtoa_r+0x25a>
    80fa:	ee37 7b07 	vadd.f64	d7, d7, d7
    80fe:	eeb4 4bc7 	vcmpe.f64	d4, d7
    8102:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8106:	d408      	bmi.n	811a <_dtoa_r+0x2aa>
    8108:	eeb4 4b47 	vcmp.f64	d4, d7
    810c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8110:	d114      	bne.n	813c <_dtoa_r+0x2cc>
    8112:	ee16 3a10 	vmov	r3, s12
    8116:	07db      	lsls	r3, r3, #31
    8118:	d510      	bpl.n	813c <_dtoa_r+0x2cc>
    811a:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    811e:	9a08      	ldr	r2, [sp, #32]
    8120:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    8124:	e004      	b.n	8130 <_dtoa_r+0x2c0>
    8126:	429a      	cmp	r2, r3
    8128:	f000 83e5 	beq.w	88f6 <_dtoa_r+0xa86>
    812c:	f813 0d01 	ldrb.w	r0, [r3, #-1]!
    8130:	2839      	cmp	r0, #57	; 0x39
    8132:	f103 0b01 	add.w	fp, r3, #1
    8136:	d0f6      	beq.n	8126 <_dtoa_r+0x2b6>
    8138:	3001      	adds	r0, #1
    813a:	7018      	strb	r0, [r3, #0]
    813c:	9907      	ldr	r1, [sp, #28]
    813e:	4620      	mov	r0, r4
    8140:	f7ff fab4 	bl	76ac <_Bfree>
    8144:	2200      	movs	r2, #0
    8146:	9b02      	ldr	r3, [sp, #8]
    8148:	f88b 2000 	strb.w	r2, [fp]
    814c:	9a04      	ldr	r2, [sp, #16]
    814e:	3301      	adds	r3, #1
    8150:	6013      	str	r3, [r2, #0]
    8152:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    8154:	2b00      	cmp	r3, #0
    8156:	f000 8366 	beq.w	8826 <_dtoa_r+0x9b6>
    815a:	9808      	ldr	r0, [sp, #32]
    815c:	f8c3 b000 	str.w	fp, [r3]
    8160:	b013      	add	sp, #76	; 0x4c
    8162:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8166:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8168:	2a00      	cmp	r2, #0
    816a:	d053      	beq.n	8214 <_dtoa_r+0x3a4>
    816c:	9a01      	ldr	r2, [sp, #4]
    816e:	2a01      	cmp	r2, #1
    8170:	f340 822e 	ble.w	85d0 <_dtoa_r+0x760>
    8174:	9905      	ldr	r1, [sp, #20]
    8176:	1e7a      	subs	r2, r7, #1
    8178:	4291      	cmp	r1, r2
    817a:	f2c0 8357 	blt.w	882c <_dtoa_r+0x9bc>
    817e:	1a8b      	subs	r3, r1, r2
    8180:	930e      	str	r3, [sp, #56]	; 0x38
    8182:	2f00      	cmp	r7, #0
    8184:	9b06      	ldr	r3, [sp, #24]
    8186:	f2c0 8424 	blt.w	89d2 <_dtoa_r+0xb62>
    818a:	930a      	str	r3, [sp, #40]	; 0x28
    818c:	463b      	mov	r3, r7
    818e:	9a06      	ldr	r2, [sp, #24]
    8190:	2101      	movs	r1, #1
    8192:	441a      	add	r2, r3
    8194:	4620      	mov	r0, r4
    8196:	9206      	str	r2, [sp, #24]
    8198:	4499      	add	r9, r3
    819a:	f7ff fb1f 	bl	77dc <__i2b>
    819e:	4606      	mov	r6, r0
    81a0:	e03d      	b.n	821e <_dtoa_r+0x3ae>
    81a2:	bf00      	nop
    81a4:	f3af 8000 	nop.w
    81a8:	636f4361 	.word	0x636f4361
    81ac:	3fd287a7 	.word	0x3fd287a7
    81b0:	8b60c8b3 	.word	0x8b60c8b3
    81b4:	3fc68a28 	.word	0x3fc68a28
    81b8:	509f79fb 	.word	0x509f79fb
    81bc:	3fd34413 	.word	0x3fd34413
    81c0:	7ff00000 	.word	0x7ff00000
    81c4:	20000e05 	.word	0x20000e05
    81c8:	20000e00 	.word	0x20000e00
    81cc:	200002e8 	.word	0x200002e8
    81d0:	20000df4 	.word	0x20000df4
    81d4:	20000e04 	.word	0x20000e04
    81d8:	2301      	movs	r3, #1
    81da:	930c      	str	r3, [sp, #48]	; 0x30
    81dc:	e6f8      	b.n	7fd0 <_dtoa_r+0x160>
    81de:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    81e2:	eeb4 7b46 	vcmp.f64	d7, d6
    81e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    81ea:	f43f aedc 	beq.w	7fa6 <_dtoa_r+0x136>
    81ee:	9b02      	ldr	r3, [sp, #8]
    81f0:	3b01      	subs	r3, #1
    81f2:	9302      	str	r3, [sp, #8]
    81f4:	e6d7      	b.n	7fa6 <_dtoa_r+0x136>
    81f6:	9a06      	ldr	r2, [sp, #24]
    81f8:	9b02      	ldr	r3, [sp, #8]
    81fa:	1ad2      	subs	r2, r2, r3
    81fc:	425b      	negs	r3, r3
    81fe:	9305      	str	r3, [sp, #20]
    8200:	2300      	movs	r3, #0
    8202:	9206      	str	r2, [sp, #24]
    8204:	930b      	str	r3, [sp, #44]	; 0x2c
    8206:	e6f2      	b.n	7fee <_dtoa_r+0x17e>
    8208:	f1c9 0300 	rsb	r3, r9, #0
    820c:	9306      	str	r3, [sp, #24]
    820e:	f04f 0900 	mov.w	r9, #0
    8212:	e6e4      	b.n	7fde <_dtoa_r+0x16e>
    8214:	9b05      	ldr	r3, [sp, #20]
    8216:	930e      	str	r3, [sp, #56]	; 0x38
    8218:	9e09      	ldr	r6, [sp, #36]	; 0x24
    821a:	9b06      	ldr	r3, [sp, #24]
    821c:	930a      	str	r3, [sp, #40]	; 0x28
    821e:	990a      	ldr	r1, [sp, #40]	; 0x28
    8220:	460b      	mov	r3, r1
    8222:	b161      	cbz	r1, 823e <_dtoa_r+0x3ce>
    8224:	f1b9 0f00 	cmp.w	r9, #0
    8228:	dd09      	ble.n	823e <_dtoa_r+0x3ce>
    822a:	4549      	cmp	r1, r9
    822c:	9a06      	ldr	r2, [sp, #24]
    822e:	bfa8      	it	ge
    8230:	464b      	movge	r3, r9
    8232:	1ad2      	subs	r2, r2, r3
    8234:	9206      	str	r2, [sp, #24]
    8236:	1aca      	subs	r2, r1, r3
    8238:	920a      	str	r2, [sp, #40]	; 0x28
    823a:	ebc3 0909 	rsb	r9, r3, r9
    823e:	9b05      	ldr	r3, [sp, #20]
    8240:	2b00      	cmp	r3, #0
    8242:	f340 8280 	ble.w	8746 <_dtoa_r+0x8d6>
    8246:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8248:	2a00      	cmp	r2, #0
    824a:	f000 819a 	beq.w	8582 <_dtoa_r+0x712>
    824e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    8250:	2a00      	cmp	r2, #0
    8252:	f000 8196 	beq.w	8582 <_dtoa_r+0x712>
    8256:	4631      	mov	r1, r6
    8258:	4620      	mov	r0, r4
    825a:	f7ff fb61 	bl	7920 <__pow5mult>
    825e:	9a07      	ldr	r2, [sp, #28]
    8260:	4601      	mov	r1, r0
    8262:	4606      	mov	r6, r0
    8264:	4620      	mov	r0, r4
    8266:	f7ff fac3 	bl	77f0 <__multiply>
    826a:	9907      	ldr	r1, [sp, #28]
    826c:	4605      	mov	r5, r0
    826e:	4620      	mov	r0, r4
    8270:	f7ff fa1c 	bl	76ac <_Bfree>
    8274:	9b05      	ldr	r3, [sp, #20]
    8276:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    8278:	1a9b      	subs	r3, r3, r2
    827a:	9305      	str	r3, [sp, #20]
    827c:	f040 8180 	bne.w	8580 <_dtoa_r+0x710>
    8280:	2101      	movs	r1, #1
    8282:	4620      	mov	r0, r4
    8284:	f7ff faaa 	bl	77dc <__i2b>
    8288:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    828a:	9005      	str	r0, [sp, #20]
    828c:	2b00      	cmp	r3, #0
    828e:	f000 81ac 	beq.w	85ea <_dtoa_r+0x77a>
    8292:	4601      	mov	r1, r0
    8294:	461a      	mov	r2, r3
    8296:	4620      	mov	r0, r4
    8298:	f7ff fb42 	bl	7920 <__pow5mult>
    829c:	9b01      	ldr	r3, [sp, #4]
    829e:	9005      	str	r0, [sp, #20]
    82a0:	2b01      	cmp	r3, #1
    82a2:	f340 8280 	ble.w	87a6 <_dtoa_r+0x936>
    82a6:	2300      	movs	r3, #0
    82a8:	9307      	str	r3, [sp, #28]
    82aa:	9a05      	ldr	r2, [sp, #20]
    82ac:	6913      	ldr	r3, [r2, #16]
    82ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    82b2:	6918      	ldr	r0, [r3, #16]
    82b4:	f7ff fa44 	bl	7740 <__hi0bits>
    82b8:	f1c0 0020 	rsb	r0, r0, #32
    82bc:	4448      	add	r0, r9
    82be:	f010 001f 	ands.w	r0, r0, #31
    82c2:	f000 8190 	beq.w	85e6 <_dtoa_r+0x776>
    82c6:	f1c0 0320 	rsb	r3, r0, #32
    82ca:	2b04      	cmp	r3, #4
    82cc:	f340 83f8 	ble.w	8ac0 <_dtoa_r+0xc50>
    82d0:	f1c0 001c 	rsb	r0, r0, #28
    82d4:	9b06      	ldr	r3, [sp, #24]
    82d6:	4403      	add	r3, r0
    82d8:	9306      	str	r3, [sp, #24]
    82da:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    82dc:	4403      	add	r3, r0
    82de:	930a      	str	r3, [sp, #40]	; 0x28
    82e0:	4481      	add	r9, r0
    82e2:	9b06      	ldr	r3, [sp, #24]
    82e4:	2b00      	cmp	r3, #0
    82e6:	dd05      	ble.n	82f4 <_dtoa_r+0x484>
    82e8:	4629      	mov	r1, r5
    82ea:	461a      	mov	r2, r3
    82ec:	4620      	mov	r0, r4
    82ee:	f7ff fb67 	bl	79c0 <__lshift>
    82f2:	4605      	mov	r5, r0
    82f4:	f1b9 0f00 	cmp.w	r9, #0
    82f8:	dd05      	ble.n	8306 <_dtoa_r+0x496>
    82fa:	464a      	mov	r2, r9
    82fc:	9905      	ldr	r1, [sp, #20]
    82fe:	4620      	mov	r0, r4
    8300:	f7ff fb5e 	bl	79c0 <__lshift>
    8304:	9005      	str	r0, [sp, #20]
    8306:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    8308:	2b00      	cmp	r3, #0
    830a:	f040 8201 	bne.w	8710 <_dtoa_r+0x8a0>
    830e:	2f00      	cmp	r7, #0
    8310:	f340 8220 	ble.w	8754 <_dtoa_r+0x8e4>
    8314:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8316:	2b00      	cmp	r3, #0
    8318:	f040 817b 	bne.w	8612 <_dtoa_r+0x7a2>
    831c:	f8dd b020 	ldr.w	fp, [sp, #32]
    8320:	f8dd a014 	ldr.w	sl, [sp, #20]
    8324:	46d8      	mov	r8, fp
    8326:	e002      	b.n	832e <_dtoa_r+0x4be>
    8328:	f7ff f9ca 	bl	76c0 <__multadd>
    832c:	4605      	mov	r5, r0
    832e:	4651      	mov	r1, sl
    8330:	4628      	mov	r0, r5
    8332:	f7ff fd07 	bl	7d44 <quorem>
    8336:	f100 0930 	add.w	r9, r0, #48	; 0x30
    833a:	f808 9b01 	strb.w	r9, [r8], #1
    833e:	ebcb 0308 	rsb	r3, fp, r8
    8342:	42bb      	cmp	r3, r7
    8344:	f04f 020a 	mov.w	r2, #10
    8348:	f04f 0300 	mov.w	r3, #0
    834c:	4629      	mov	r1, r5
    834e:	4620      	mov	r0, r4
    8350:	dbea      	blt.n	8328 <_dtoa_r+0x4b8>
    8352:	9b08      	ldr	r3, [sp, #32]
    8354:	2f01      	cmp	r7, #1
    8356:	bfac      	ite	ge
    8358:	19db      	addge	r3, r3, r7
    835a:	3301      	addlt	r3, #1
    835c:	469b      	mov	fp, r3
    835e:	f04f 0a00 	mov.w	sl, #0
    8362:	4629      	mov	r1, r5
    8364:	2201      	movs	r2, #1
    8366:	4620      	mov	r0, r4
    8368:	f7ff fb2a 	bl	79c0 <__lshift>
    836c:	9905      	ldr	r1, [sp, #20]
    836e:	9007      	str	r0, [sp, #28]
    8370:	f7ff fb7e 	bl	7a70 <__mcmp>
    8374:	2800      	cmp	r0, #0
    8376:	f340 828c 	ble.w	8892 <_dtoa_r+0xa22>
    837a:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
    837e:	9908      	ldr	r1, [sp, #32]
    8380:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    8384:	e004      	b.n	8390 <_dtoa_r+0x520>
    8386:	428b      	cmp	r3, r1
    8388:	f000 8203 	beq.w	8792 <_dtoa_r+0x922>
    838c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    8390:	2a39      	cmp	r2, #57	; 0x39
    8392:	f103 0b01 	add.w	fp, r3, #1
    8396:	d0f6      	beq.n	8386 <_dtoa_r+0x516>
    8398:	3201      	adds	r2, #1
    839a:	701a      	strb	r2, [r3, #0]
    839c:	9905      	ldr	r1, [sp, #20]
    839e:	4620      	mov	r0, r4
    83a0:	f7ff f984 	bl	76ac <_Bfree>
    83a4:	2e00      	cmp	r6, #0
    83a6:	f43f aec9 	beq.w	813c <_dtoa_r+0x2cc>
    83aa:	f1ba 0f00 	cmp.w	sl, #0
    83ae:	d005      	beq.n	83bc <_dtoa_r+0x54c>
    83b0:	45b2      	cmp	sl, r6
    83b2:	d003      	beq.n	83bc <_dtoa_r+0x54c>
    83b4:	4651      	mov	r1, sl
    83b6:	4620      	mov	r0, r4
    83b8:	f7ff f978 	bl	76ac <_Bfree>
    83bc:	4631      	mov	r1, r6
    83be:	4620      	mov	r0, r4
    83c0:	f7ff f974 	bl	76ac <_Bfree>
    83c4:	e6ba      	b.n	813c <_dtoa_r+0x2cc>
    83c6:	f1c3 0320 	rsb	r3, r3, #32
    83ca:	fa0a f303 	lsl.w	r3, sl, r3
    83ce:	ee07 3a90 	vmov	s15, r3
    83d2:	e5c1      	b.n	7f58 <_dtoa_r+0xe8>
    83d4:	2300      	movs	r3, #0
    83d6:	930c      	str	r3, [sp, #48]	; 0x30
    83d8:	e5fa      	b.n	7fd0 <_dtoa_r+0x160>
    83da:	2300      	movs	r3, #0
    83dc:	9309      	str	r3, [sp, #36]	; 0x24
    83de:	9b02      	ldr	r3, [sp, #8]
    83e0:	4443      	add	r3, r8
    83e2:	1c5f      	adds	r7, r3, #1
    83e4:	2f00      	cmp	r7, #0
    83e6:	930d      	str	r3, [sp, #52]	; 0x34
    83e8:	f340 822d 	ble.w	8846 <_dtoa_r+0x9d6>
    83ec:	463e      	mov	r6, r7
    83ee:	463d      	mov	r5, r7
    83f0:	2100      	movs	r1, #0
    83f2:	2e17      	cmp	r6, #23
    83f4:	6461      	str	r1, [r4, #68]	; 0x44
    83f6:	d90a      	bls.n	840e <_dtoa_r+0x59e>
    83f8:	2201      	movs	r2, #1
    83fa:	2304      	movs	r3, #4
    83fc:	005b      	lsls	r3, r3, #1
    83fe:	f103 0014 	add.w	r0, r3, #20
    8402:	42b0      	cmp	r0, r6
    8404:	4611      	mov	r1, r2
    8406:	f102 0201 	add.w	r2, r2, #1
    840a:	d9f7      	bls.n	83fc <_dtoa_r+0x58c>
    840c:	6461      	str	r1, [r4, #68]	; 0x44
    840e:	4620      	mov	r0, r4
    8410:	f7ff f926 	bl	7660 <_Balloc>
    8414:	2d0e      	cmp	r5, #14
    8416:	9008      	str	r0, [sp, #32]
    8418:	6420      	str	r0, [r4, #64]	; 0x40
    841a:	f63f ae26 	bhi.w	806a <_dtoa_r+0x1fa>
    841e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8420:	2b00      	cmp	r3, #0
    8422:	f43f ae22 	beq.w	806a <_dtoa_r+0x1fa>
    8426:	9902      	ldr	r1, [sp, #8]
    8428:	2900      	cmp	r1, #0
    842a:	e9cd ab0e 	strd	sl, fp, [sp, #56]	; 0x38
    842e:	f340 8241 	ble.w	88b4 <_dtoa_r+0xa44>
    8432:	4bc6      	ldr	r3, [pc, #792]	; (874c <_dtoa_r+0x8dc>)
    8434:	f001 020f 	and.w	r2, r1, #15
    8438:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    843c:	110b      	asrs	r3, r1, #4
    843e:	06de      	lsls	r6, r3, #27
    8440:	ed92 6b00 	vldr	d6, [r2]
    8444:	f140 81fb 	bpl.w	883e <_dtoa_r+0x9ce>
    8448:	4ac1      	ldr	r2, [pc, #772]	; (8750 <_dtoa_r+0x8e0>)
    844a:	ed92 7b08 	vldr	d7, [r2, #32]
    844e:	ec4b ab14 	vmov	d4, sl, fp
    8452:	f003 030f 	and.w	r3, r3, #15
    8456:	2103      	movs	r1, #3
    8458:	ee84 5b07 	vdiv.f64	d5, d4, d7
    845c:	b15b      	cbz	r3, 8476 <_dtoa_r+0x606>
    845e:	4abc      	ldr	r2, [pc, #752]	; (8750 <_dtoa_r+0x8e0>)
    8460:	07dd      	lsls	r5, r3, #31
    8462:	d504      	bpl.n	846e <_dtoa_r+0x5fe>
    8464:	ed92 7b00 	vldr	d7, [r2]
    8468:	3101      	adds	r1, #1
    846a:	ee26 6b07 	vmul.f64	d6, d6, d7
    846e:	105b      	asrs	r3, r3, #1
    8470:	f102 0208 	add.w	r2, r2, #8
    8474:	d1f4      	bne.n	8460 <_dtoa_r+0x5f0>
    8476:	ee85 4b06 	vdiv.f64	d4, d5, d6
    847a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    847c:	b13b      	cbz	r3, 848e <_dtoa_r+0x61e>
    847e:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    8482:	eeb4 4bc7 	vcmpe.f64	d4, d7
    8486:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    848a:	f100 82b7 	bmi.w	89fc <_dtoa_r+0xb8c>
    848e:	ee07 1a90 	vmov	s15, r1
    8492:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    8496:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    849a:	eea6 7b04 	vfma.f64	d7, d6, d4
    849e:	ec53 2b17 	vmov	r2, r3, d7
    84a2:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    84a6:	2f00      	cmp	r7, #0
    84a8:	f000 81a6 	beq.w	87f8 <_dtoa_r+0x988>
    84ac:	9e02      	ldr	r6, [sp, #8]
    84ae:	4639      	mov	r1, r7
    84b0:	9809      	ldr	r0, [sp, #36]	; 0x24
    84b2:	2800      	cmp	r0, #0
    84b4:	f000 824d 	beq.w	8952 <_dtoa_r+0xae2>
    84b8:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    84bc:	48a3      	ldr	r0, [pc, #652]	; (874c <_dtoa_r+0x8dc>)
    84be:	9d08      	ldr	r5, [sp, #32]
    84c0:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
    84c4:	ed10 6b02 	vldr	d6, [r0, #-8]
    84c8:	eebd 7bc4 	vcvt.s32.f64	s14, d4
    84cc:	ee83 5b06 	vdiv.f64	d5, d3, d6
    84d0:	ee17 0a10 	vmov	r0, s14
    84d4:	ec43 2b16 	vmov	d6, r2, r3
    84d8:	3030      	adds	r0, #48	; 0x30
    84da:	b2c0      	uxtb	r0, r0
    84dc:	ee35 5b46 	vsub.f64	d5, d5, d6
    84e0:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    84e4:	ee34 7b47 	vsub.f64	d7, d4, d7
    84e8:	eeb4 5bc7 	vcmpe.f64	d5, d7
    84ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    84f0:	7028      	strb	r0, [r5, #0]
    84f2:	f105 0b01 	add.w	fp, r5, #1
    84f6:	dc32      	bgt.n	855e <_dtoa_r+0x6ee>
    84f8:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
    84fc:	ee33 6b47 	vsub.f64	d6, d3, d7
    8500:	eeb4 5bc6 	vcmpe.f64	d5, d6
    8504:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8508:	f300 82ae 	bgt.w	8a68 <_dtoa_r+0xbf8>
    850c:	2901      	cmp	r1, #1
    850e:	f340 81cd 	ble.w	88ac <_dtoa_r+0xa3c>
    8512:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    8516:	9b08      	ldr	r3, [sp, #32]
    8518:	4419      	add	r1, r3
    851a:	e00a      	b.n	8532 <_dtoa_r+0x6c2>
    851c:	ee33 6b47 	vsub.f64	d6, d3, d7
    8520:	eeb4 6bc5 	vcmpe.f64	d6, d5
    8524:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8528:	f100 829e 	bmi.w	8a68 <_dtoa_r+0xbf8>
    852c:	458b      	cmp	fp, r1
    852e:	f000 81bd 	beq.w	88ac <_dtoa_r+0xa3c>
    8532:	ee27 7b04 	vmul.f64	d7, d7, d4
    8536:	ee25 5b04 	vmul.f64	d5, d5, d4
    853a:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    853e:	ee16 3a10 	vmov	r3, s12
    8542:	f103 0030 	add.w	r0, r3, #48	; 0x30
    8546:	b2c0      	uxtb	r0, r0
    8548:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    854c:	ee37 7b46 	vsub.f64	d7, d7, d6
    8550:	eeb4 7bc5 	vcmpe.f64	d7, d5
    8554:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8558:	f80b 0b01 	strb.w	r0, [fp], #1
    855c:	d5de      	bpl.n	851c <_dtoa_r+0x6ac>
    855e:	9602      	str	r6, [sp, #8]
    8560:	e5ec      	b.n	813c <_dtoa_r+0x2cc>
    8562:	2300      	movs	r3, #0
    8564:	9309      	str	r3, [sp, #36]	; 0x24
    8566:	f1b8 0f00 	cmp.w	r8, #0
    856a:	f340 8170 	ble.w	884e <_dtoa_r+0x9de>
    856e:	4646      	mov	r6, r8
    8570:	4645      	mov	r5, r8
    8572:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    8576:	4647      	mov	r7, r8
    8578:	e73a      	b.n	83f0 <_dtoa_r+0x580>
    857a:	2301      	movs	r3, #1
    857c:	9309      	str	r3, [sp, #36]	; 0x24
    857e:	e7f2      	b.n	8566 <_dtoa_r+0x6f6>
    8580:	9507      	str	r5, [sp, #28]
    8582:	9a05      	ldr	r2, [sp, #20]
    8584:	9907      	ldr	r1, [sp, #28]
    8586:	4620      	mov	r0, r4
    8588:	f7ff f9ca 	bl	7920 <__pow5mult>
    858c:	4605      	mov	r5, r0
    858e:	e677      	b.n	8280 <_dtoa_r+0x410>
    8590:	2f00      	cmp	r7, #0
    8592:	f73f ad79 	bgt.w	8088 <_dtoa_r+0x218>
    8596:	f040 8142 	bne.w	881e <_dtoa_r+0x9ae>
    859a:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    859e:	ee24 4b07 	vmul.f64	d4, d4, d7
    85a2:	ec4b ab17 	vmov	d7, sl, fp
    85a6:	eeb4 4bc7 	vcmpe.f64	d4, d7
    85aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    85ae:	463e      	mov	r6, r7
    85b0:	9705      	str	r7, [sp, #20]
    85b2:	f2c0 80e5 	blt.w	8780 <_dtoa_r+0x910>
    85b6:	ea6f 0308 	mvn.w	r3, r8
    85ba:	f8dd b020 	ldr.w	fp, [sp, #32]
    85be:	9302      	str	r3, [sp, #8]
    85c0:	9905      	ldr	r1, [sp, #20]
    85c2:	4620      	mov	r0, r4
    85c4:	f7ff f872 	bl	76ac <_Bfree>
    85c8:	2e00      	cmp	r6, #0
    85ca:	f43f adb7 	beq.w	813c <_dtoa_r+0x2cc>
    85ce:	e6f5      	b.n	83bc <_dtoa_r+0x54c>
    85d0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    85d2:	2a00      	cmp	r2, #0
    85d4:	f000 8202 	beq.w	89dc <_dtoa_r+0xb6c>
    85d8:	9a05      	ldr	r2, [sp, #20]
    85da:	920e      	str	r2, [sp, #56]	; 0x38
    85dc:	9a06      	ldr	r2, [sp, #24]
    85de:	920a      	str	r2, [sp, #40]	; 0x28
    85e0:	f203 4333 	addw	r3, r3, #1075	; 0x433
    85e4:	e5d3      	b.n	818e <_dtoa_r+0x31e>
    85e6:	201c      	movs	r0, #28
    85e8:	e674      	b.n	82d4 <_dtoa_r+0x464>
    85ea:	9b01      	ldr	r3, [sp, #4]
    85ec:	2b01      	cmp	r3, #1
    85ee:	f340 8240 	ble.w	8a72 <_dtoa_r+0xc02>
    85f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    85f4:	9307      	str	r3, [sp, #28]
    85f6:	2001      	movs	r0, #1
    85f8:	e660      	b.n	82bc <_dtoa_r+0x44c>
    85fa:	4631      	mov	r1, r6
    85fc:	2300      	movs	r3, #0
    85fe:	220a      	movs	r2, #10
    8600:	4620      	mov	r0, r4
    8602:	f7ff f85d 	bl	76c0 <__multadd>
    8606:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    8608:	2b00      	cmp	r3, #0
    860a:	4606      	mov	r6, r0
    860c:	f340 824d 	ble.w	8aaa <_dtoa_r+0xc3a>
    8610:	461f      	mov	r7, r3
    8612:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8614:	2b00      	cmp	r3, #0
    8616:	dd05      	ble.n	8624 <_dtoa_r+0x7b4>
    8618:	4631      	mov	r1, r6
    861a:	461a      	mov	r2, r3
    861c:	4620      	mov	r0, r4
    861e:	f7ff f9cf 	bl	79c0 <__lshift>
    8622:	4606      	mov	r6, r0
    8624:	9b07      	ldr	r3, [sp, #28]
    8626:	2b00      	cmp	r3, #0
    8628:	f040 816e 	bne.w	8908 <_dtoa_r+0xa98>
    862c:	46b0      	mov	r8, r6
    862e:	9b08      	ldr	r3, [sp, #32]
    8630:	3f01      	subs	r7, #1
    8632:	19da      	adds	r2, r3, r7
    8634:	9209      	str	r2, [sp, #36]	; 0x24
    8636:	f00a 0201 	and.w	r2, sl, #1
    863a:	920a      	str	r2, [sp, #40]	; 0x28
    863c:	461f      	mov	r7, r3
    863e:	f8dd b014 	ldr.w	fp, [sp, #20]
    8642:	4628      	mov	r0, r5
    8644:	4659      	mov	r1, fp
    8646:	f7ff fb7d 	bl	7d44 <quorem>
    864a:	4631      	mov	r1, r6
    864c:	4682      	mov	sl, r0
    864e:	4628      	mov	r0, r5
    8650:	f7ff fa0e 	bl	7a70 <__mcmp>
    8654:	4642      	mov	r2, r8
    8656:	4659      	mov	r1, fp
    8658:	4681      	mov	r9, r0
    865a:	4620      	mov	r0, r4
    865c:	f7ff fa2a 	bl	7ab4 <__mdiff>
    8660:	68c3      	ldr	r3, [r0, #12]
    8662:	4683      	mov	fp, r0
    8664:	f10a 0230 	add.w	r2, sl, #48	; 0x30
    8668:	2b00      	cmp	r3, #0
    866a:	d149      	bne.n	8700 <_dtoa_r+0x890>
    866c:	4601      	mov	r1, r0
    866e:	4628      	mov	r0, r5
    8670:	9207      	str	r2, [sp, #28]
    8672:	f7ff f9fd 	bl	7a70 <__mcmp>
    8676:	4659      	mov	r1, fp
    8678:	9006      	str	r0, [sp, #24]
    867a:	4620      	mov	r0, r4
    867c:	f7ff f816 	bl	76ac <_Bfree>
    8680:	9b06      	ldr	r3, [sp, #24]
    8682:	9a07      	ldr	r2, [sp, #28]
    8684:	b92b      	cbnz	r3, 8692 <_dtoa_r+0x822>
    8686:	9901      	ldr	r1, [sp, #4]
    8688:	b919      	cbnz	r1, 8692 <_dtoa_r+0x822>
    868a:	990a      	ldr	r1, [sp, #40]	; 0x28
    868c:	2900      	cmp	r1, #0
    868e:	f000 81f5 	beq.w	8a7c <_dtoa_r+0xc0c>
    8692:	f1b9 0f00 	cmp.w	r9, #0
    8696:	f2c0 80df 	blt.w	8858 <_dtoa_r+0x9e8>
    869a:	d105      	bne.n	86a8 <_dtoa_r+0x838>
    869c:	9901      	ldr	r1, [sp, #4]
    869e:	b919      	cbnz	r1, 86a8 <_dtoa_r+0x838>
    86a0:	990a      	ldr	r1, [sp, #40]	; 0x28
    86a2:	2900      	cmp	r1, #0
    86a4:	f000 80d8 	beq.w	8858 <_dtoa_r+0x9e8>
    86a8:	2b00      	cmp	r3, #0
    86aa:	f300 8141 	bgt.w	8930 <_dtoa_r+0xac0>
    86ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
    86b0:	703a      	strb	r2, [r7, #0]
    86b2:	f107 0901 	add.w	r9, r7, #1
    86b6:	429f      	cmp	r7, r3
    86b8:	46cb      	mov	fp, r9
    86ba:	f000 8146 	beq.w	894a <_dtoa_r+0xada>
    86be:	4629      	mov	r1, r5
    86c0:	2300      	movs	r3, #0
    86c2:	220a      	movs	r2, #10
    86c4:	4620      	mov	r0, r4
    86c6:	f7fe fffb 	bl	76c0 <__multadd>
    86ca:	4546      	cmp	r6, r8
    86cc:	4605      	mov	r5, r0
    86ce:	4631      	mov	r1, r6
    86d0:	f04f 0300 	mov.w	r3, #0
    86d4:	f04f 020a 	mov.w	r2, #10
    86d8:	4620      	mov	r0, r4
    86da:	d00b      	beq.n	86f4 <_dtoa_r+0x884>
    86dc:	f7fe fff0 	bl	76c0 <__multadd>
    86e0:	4641      	mov	r1, r8
    86e2:	4606      	mov	r6, r0
    86e4:	2300      	movs	r3, #0
    86e6:	220a      	movs	r2, #10
    86e8:	4620      	mov	r0, r4
    86ea:	f7fe ffe9 	bl	76c0 <__multadd>
    86ee:	464f      	mov	r7, r9
    86f0:	4680      	mov	r8, r0
    86f2:	e7a4      	b.n	863e <_dtoa_r+0x7ce>
    86f4:	f7fe ffe4 	bl	76c0 <__multadd>
    86f8:	464f      	mov	r7, r9
    86fa:	4606      	mov	r6, r0
    86fc:	4680      	mov	r8, r0
    86fe:	e79e      	b.n	863e <_dtoa_r+0x7ce>
    8700:	4601      	mov	r1, r0
    8702:	4620      	mov	r0, r4
    8704:	9206      	str	r2, [sp, #24]
    8706:	f7fe ffd1 	bl	76ac <_Bfree>
    870a:	2301      	movs	r3, #1
    870c:	9a06      	ldr	r2, [sp, #24]
    870e:	e7c0      	b.n	8692 <_dtoa_r+0x822>
    8710:	9905      	ldr	r1, [sp, #20]
    8712:	4628      	mov	r0, r5
    8714:	f7ff f9ac 	bl	7a70 <__mcmp>
    8718:	2800      	cmp	r0, #0
    871a:	f6bf adf8 	bge.w	830e <_dtoa_r+0x49e>
    871e:	4629      	mov	r1, r5
    8720:	9d02      	ldr	r5, [sp, #8]
    8722:	2300      	movs	r3, #0
    8724:	3d01      	subs	r5, #1
    8726:	220a      	movs	r2, #10
    8728:	4620      	mov	r0, r4
    872a:	9502      	str	r5, [sp, #8]
    872c:	f7fe ffc8 	bl	76c0 <__multadd>
    8730:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8732:	4605      	mov	r5, r0
    8734:	2b00      	cmp	r3, #0
    8736:	f47f af60 	bne.w	85fa <_dtoa_r+0x78a>
    873a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    873c:	2b00      	cmp	r3, #0
    873e:	f340 81ad 	ble.w	8a9c <_dtoa_r+0xc2c>
    8742:	461f      	mov	r7, r3
    8744:	e5ea      	b.n	831c <_dtoa_r+0x4ac>
    8746:	9d07      	ldr	r5, [sp, #28]
    8748:	e59a      	b.n	8280 <_dtoa_r+0x410>
    874a:	bf00      	nop
    874c:	200002e8 	.word	0x200002e8
    8750:	200002c0 	.word	0x200002c0
    8754:	9b01      	ldr	r3, [sp, #4]
    8756:	2b02      	cmp	r3, #2
    8758:	f77f addc 	ble.w	8314 <_dtoa_r+0x4a4>
    875c:	2f00      	cmp	r7, #0
    875e:	f040 8169 	bne.w	8a34 <_dtoa_r+0xbc4>
    8762:	463b      	mov	r3, r7
    8764:	9905      	ldr	r1, [sp, #20]
    8766:	2205      	movs	r2, #5
    8768:	4620      	mov	r0, r4
    876a:	f7fe ffa9 	bl	76c0 <__multadd>
    876e:	4601      	mov	r1, r0
    8770:	9005      	str	r0, [sp, #20]
    8772:	4628      	mov	r0, r5
    8774:	f7ff f97c 	bl	7a70 <__mcmp>
    8778:	2800      	cmp	r0, #0
    877a:	9507      	str	r5, [sp, #28]
    877c:	f77f af1b 	ble.w	85b6 <_dtoa_r+0x746>
    8780:	9a02      	ldr	r2, [sp, #8]
    8782:	9908      	ldr	r1, [sp, #32]
    8784:	2331      	movs	r3, #49	; 0x31
    8786:	3201      	adds	r2, #1
    8788:	9202      	str	r2, [sp, #8]
    878a:	700b      	strb	r3, [r1, #0]
    878c:	f101 0b01 	add.w	fp, r1, #1
    8790:	e716      	b.n	85c0 <_dtoa_r+0x750>
    8792:	9a02      	ldr	r2, [sp, #8]
    8794:	3201      	adds	r2, #1
    8796:	9202      	str	r2, [sp, #8]
    8798:	9a08      	ldr	r2, [sp, #32]
    879a:	2331      	movs	r3, #49	; 0x31
    879c:	7013      	strb	r3, [r2, #0]
    879e:	e5fd      	b.n	839c <_dtoa_r+0x52c>
    87a0:	2301      	movs	r3, #1
    87a2:	9309      	str	r3, [sp, #36]	; 0x24
    87a4:	e61b      	b.n	83de <_dtoa_r+0x56e>
    87a6:	f1ba 0f00 	cmp.w	sl, #0
    87aa:	f47f ad7c 	bne.w	82a6 <_dtoa_r+0x436>
    87ae:	f3cb 0313 	ubfx	r3, fp, #0, #20
    87b2:	2b00      	cmp	r3, #0
    87b4:	f040 811b 	bne.w	89ee <_dtoa_r+0xb7e>
    87b8:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
    87bc:	0d1b      	lsrs	r3, r3, #20
    87be:	051b      	lsls	r3, r3, #20
    87c0:	2b00      	cmp	r3, #0
    87c2:	f000 8154 	beq.w	8a6e <_dtoa_r+0xbfe>
    87c6:	9b06      	ldr	r3, [sp, #24]
    87c8:	3301      	adds	r3, #1
    87ca:	9306      	str	r3, [sp, #24]
    87cc:	2301      	movs	r3, #1
    87ce:	f109 0901 	add.w	r9, r9, #1
    87d2:	9307      	str	r3, [sp, #28]
    87d4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    87d6:	2001      	movs	r0, #1
    87d8:	2b00      	cmp	r3, #0
    87da:	f43f ad6f 	beq.w	82bc <_dtoa_r+0x44c>
    87de:	e564      	b.n	82aa <_dtoa_r+0x43a>
    87e0:	ee07 1a90 	vmov	s15, r1
    87e4:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    87e8:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    87ec:	eea4 7b06 	vfma.f64	d7, d4, d6
    87f0:	ec53 2b17 	vmov	r2, r3, d7
    87f4:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    87f8:	ec43 2b16 	vmov	d6, r2, r3
    87fc:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    8800:	ee34 7b47 	vsub.f64	d7, d4, d7
    8804:	eeb4 7bc6 	vcmpe.f64	d7, d6
    8808:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    880c:	f300 80dd 	bgt.w	89ca <_dtoa_r+0xb5a>
    8810:	eeb1 6b46 	vneg.f64	d6, d6
    8814:	eeb4 7bc6 	vcmpe.f64	d7, d6
    8818:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    881c:	d546      	bpl.n	88ac <_dtoa_r+0xa3c>
    881e:	2300      	movs	r3, #0
    8820:	9305      	str	r3, [sp, #20]
    8822:	461e      	mov	r6, r3
    8824:	e6c7      	b.n	85b6 <_dtoa_r+0x746>
    8826:	9808      	ldr	r0, [sp, #32]
    8828:	f7ff bb59 	b.w	7ede <_dtoa_r+0x6e>
    882c:	9b05      	ldr	r3, [sp, #20]
    882e:	990b      	ldr	r1, [sp, #44]	; 0x2c
    8830:	9205      	str	r2, [sp, #20]
    8832:	1ad3      	subs	r3, r2, r3
    8834:	4419      	add	r1, r3
    8836:	2300      	movs	r3, #0
    8838:	910b      	str	r1, [sp, #44]	; 0x2c
    883a:	930e      	str	r3, [sp, #56]	; 0x38
    883c:	e4a1      	b.n	8182 <_dtoa_r+0x312>
    883e:	ed9d 5b0e 	vldr	d5, [sp, #56]	; 0x38
    8842:	2102      	movs	r1, #2
    8844:	e60a      	b.n	845c <_dtoa_r+0x5ec>
    8846:	463d      	mov	r5, r7
    8848:	2100      	movs	r1, #0
    884a:	6461      	str	r1, [r4, #68]	; 0x44
    884c:	e5df      	b.n	840e <_dtoa_r+0x59e>
    884e:	2501      	movs	r5, #1
    8850:	950d      	str	r5, [sp, #52]	; 0x34
    8852:	462f      	mov	r7, r5
    8854:	46a8      	mov	r8, r5
    8856:	e7f7      	b.n	8848 <_dtoa_r+0x9d8>
    8858:	2b00      	cmp	r3, #0
    885a:	4691      	mov	r9, r2
    885c:	dd11      	ble.n	8882 <_dtoa_r+0xa12>
    885e:	4629      	mov	r1, r5
    8860:	2201      	movs	r2, #1
    8862:	4620      	mov	r0, r4
    8864:	f7ff f8ac 	bl	79c0 <__lshift>
    8868:	9905      	ldr	r1, [sp, #20]
    886a:	4605      	mov	r5, r0
    886c:	f7ff f900 	bl	7a70 <__mcmp>
    8870:	2800      	cmp	r0, #0
    8872:	f340 810c 	ble.w	8a8e <_dtoa_r+0xc1e>
    8876:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
    887a:	f000 80dd 	beq.w	8a38 <_dtoa_r+0xbc8>
    887e:	f10a 0931 	add.w	r9, sl, #49	; 0x31
    8882:	46b2      	mov	sl, r6
    8884:	f887 9000 	strb.w	r9, [r7]
    8888:	f107 0b01 	add.w	fp, r7, #1
    888c:	4646      	mov	r6, r8
    888e:	9507      	str	r5, [sp, #28]
    8890:	e584      	b.n	839c <_dtoa_r+0x52c>
    8892:	d104      	bne.n	889e <_dtoa_r+0xa2e>
    8894:	f019 0f01 	tst.w	r9, #1
    8898:	d001      	beq.n	889e <_dtoa_r+0xa2e>
    889a:	e56e      	b.n	837a <_dtoa_r+0x50a>
    889c:	4693      	mov	fp, r2
    889e:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    88a2:	2b30      	cmp	r3, #48	; 0x30
    88a4:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    88a8:	d0f8      	beq.n	889c <_dtoa_r+0xa2c>
    88aa:	e577      	b.n	839c <_dtoa_r+0x52c>
    88ac:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
    88b0:	f7ff bbdb 	b.w	806a <_dtoa_r+0x1fa>
    88b4:	9b02      	ldr	r3, [sp, #8]
    88b6:	425b      	negs	r3, r3
    88b8:	2b00      	cmp	r3, #0
    88ba:	f000 809b 	beq.w	89f4 <_dtoa_r+0xb84>
    88be:	4a8b      	ldr	r2, [pc, #556]	; (8aec <_dtoa_r+0xc7c>)
    88c0:	f003 010f 	and.w	r1, r3, #15
    88c4:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
    88c8:	ed92 7b00 	vldr	d7, [r2]
    88cc:	ed9d 6b0e 	vldr	d6, [sp, #56]	; 0x38
    88d0:	111b      	asrs	r3, r3, #4
    88d2:	ee26 4b07 	vmul.f64	d4, d6, d7
    88d6:	f000 80e6 	beq.w	8aa6 <_dtoa_r+0xc36>
    88da:	4a85      	ldr	r2, [pc, #532]	; (8af0 <_dtoa_r+0xc80>)
    88dc:	2102      	movs	r1, #2
    88de:	07d8      	lsls	r0, r3, #31
    88e0:	d504      	bpl.n	88ec <_dtoa_r+0xa7c>
    88e2:	ed92 7b00 	vldr	d7, [r2]
    88e6:	3101      	adds	r1, #1
    88e8:	ee24 4b07 	vmul.f64	d4, d4, d7
    88ec:	105b      	asrs	r3, r3, #1
    88ee:	f102 0208 	add.w	r2, r2, #8
    88f2:	d1f4      	bne.n	88de <_dtoa_r+0xa6e>
    88f4:	e5c1      	b.n	847a <_dtoa_r+0x60a>
    88f6:	9908      	ldr	r1, [sp, #32]
    88f8:	2230      	movs	r2, #48	; 0x30
    88fa:	700a      	strb	r2, [r1, #0]
    88fc:	9a02      	ldr	r2, [sp, #8]
    88fe:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    8902:	3201      	adds	r2, #1
    8904:	9202      	str	r2, [sp, #8]
    8906:	e417      	b.n	8138 <_dtoa_r+0x2c8>
    8908:	6871      	ldr	r1, [r6, #4]
    890a:	4620      	mov	r0, r4
    890c:	f7fe fea8 	bl	7660 <_Balloc>
    8910:	6933      	ldr	r3, [r6, #16]
    8912:	1c9a      	adds	r2, r3, #2
    8914:	4680      	mov	r8, r0
    8916:	0092      	lsls	r2, r2, #2
    8918:	f106 010c 	add.w	r1, r6, #12
    891c:	300c      	adds	r0, #12
    891e:	f7fd fe1f 	bl	6560 <memcpy>
    8922:	4641      	mov	r1, r8
    8924:	2201      	movs	r2, #1
    8926:	4620      	mov	r0, r4
    8928:	f7ff f84a 	bl	79c0 <__lshift>
    892c:	4680      	mov	r8, r0
    892e:	e67e      	b.n	862e <_dtoa_r+0x7be>
    8930:	2a39      	cmp	r2, #57	; 0x39
    8932:	f000 8081 	beq.w	8a38 <_dtoa_r+0xbc8>
    8936:	f102 0901 	add.w	r9, r2, #1
    893a:	46b2      	mov	sl, r6
    893c:	f887 9000 	strb.w	r9, [r7]
    8940:	f107 0b01 	add.w	fp, r7, #1
    8944:	4646      	mov	r6, r8
    8946:	9507      	str	r5, [sp, #28]
    8948:	e528      	b.n	839c <_dtoa_r+0x52c>
    894a:	46b2      	mov	sl, r6
    894c:	4691      	mov	r9, r2
    894e:	4646      	mov	r6, r8
    8950:	e507      	b.n	8362 <_dtoa_r+0x4f2>
    8952:	4866      	ldr	r0, [pc, #408]	; (8aec <_dtoa_r+0xc7c>)
    8954:	eebd 6bc4 	vcvt.s32.f64	s12, d4
    8958:	1e4d      	subs	r5, r1, #1
    895a:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
    895e:	ec43 2b17 	vmov	d7, r2, r3
    8962:	ed90 3b00 	vldr	d3, [r0]
    8966:	ee16 3a10 	vmov	r3, s12
    896a:	ee23 3b07 	vmul.f64	d3, d3, d7
    896e:	9808      	ldr	r0, [sp, #32]
    8970:	3330      	adds	r3, #48	; 0x30
    8972:	2901      	cmp	r1, #1
    8974:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    8978:	7003      	strb	r3, [r0, #0]
    897a:	f100 0b01 	add.w	fp, r0, #1
    897e:	ee34 7b46 	vsub.f64	d7, d4, d6
    8982:	d014      	beq.n	89ae <_dtoa_r+0xb3e>
    8984:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    8988:	9b08      	ldr	r3, [sp, #32]
    898a:	4419      	add	r1, r3
    898c:	465b      	mov	r3, fp
    898e:	ee27 7b05 	vmul.f64	d7, d7, d5
    8992:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    8996:	ee16 2a10 	vmov	r2, s12
    899a:	3230      	adds	r2, #48	; 0x30
    899c:	f803 2b01 	strb.w	r2, [r3], #1
    89a0:	4299      	cmp	r1, r3
    89a2:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    89a6:	ee37 7b46 	vsub.f64	d7, d7, d6
    89aa:	d1f0      	bne.n	898e <_dtoa_r+0xb1e>
    89ac:	44ab      	add	fp, r5
    89ae:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
    89b2:	ee33 5b06 	vadd.f64	d5, d3, d6
    89b6:	eeb4 5bc7 	vcmpe.f64	d5, d7
    89ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    89be:	d543      	bpl.n	8a48 <_dtoa_r+0xbd8>
    89c0:	9602      	str	r6, [sp, #8]
    89c2:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    89c6:	f7ff bbaa 	b.w	811e <_dtoa_r+0x2ae>
    89ca:	2300      	movs	r3, #0
    89cc:	9305      	str	r3, [sp, #20]
    89ce:	461e      	mov	r6, r3
    89d0:	e6d6      	b.n	8780 <_dtoa_r+0x910>
    89d2:	1bdb      	subs	r3, r3, r7
    89d4:	930a      	str	r3, [sp, #40]	; 0x28
    89d6:	2300      	movs	r3, #0
    89d8:	f7ff bbd9 	b.w	818e <_dtoa_r+0x31e>
    89dc:	9a05      	ldr	r2, [sp, #20]
    89de:	9b10      	ldr	r3, [sp, #64]	; 0x40
    89e0:	920e      	str	r2, [sp, #56]	; 0x38
    89e2:	9a06      	ldr	r2, [sp, #24]
    89e4:	920a      	str	r2, [sp, #40]	; 0x28
    89e6:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    89ea:	f7ff bbd0 	b.w	818e <_dtoa_r+0x31e>
    89ee:	2300      	movs	r3, #0
    89f0:	9307      	str	r3, [sp, #28]
    89f2:	e6ef      	b.n	87d4 <_dtoa_r+0x964>
    89f4:	ed9d 4b0e 	vldr	d4, [sp, #56]	; 0x38
    89f8:	2102      	movs	r1, #2
    89fa:	e53e      	b.n	847a <_dtoa_r+0x60a>
    89fc:	2f00      	cmp	r7, #0
    89fe:	f43f aeef 	beq.w	87e0 <_dtoa_r+0x970>
    8a02:	980d      	ldr	r0, [sp, #52]	; 0x34
    8a04:	2800      	cmp	r0, #0
    8a06:	f77f af51 	ble.w	88ac <_dtoa_r+0xa3c>
    8a0a:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    8a0e:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    8a12:	3101      	adds	r1, #1
    8a14:	ee06 1a90 	vmov	s13, r1
    8a18:	ee24 4b05 	vmul.f64	d4, d4, d5
    8a1c:	9b02      	ldr	r3, [sp, #8]
    8a1e:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    8a22:	1e5e      	subs	r6, r3, #1
    8a24:	eea4 7b06 	vfma.f64	d7, d4, d6
    8a28:	ec53 2b17 	vmov	r2, r3, d7
    8a2c:	4601      	mov	r1, r0
    8a2e:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    8a32:	e53d      	b.n	84b0 <_dtoa_r+0x640>
    8a34:	9507      	str	r5, [sp, #28]
    8a36:	e5be      	b.n	85b6 <_dtoa_r+0x746>
    8a38:	2239      	movs	r2, #57	; 0x39
    8a3a:	46b2      	mov	sl, r6
    8a3c:	9507      	str	r5, [sp, #28]
    8a3e:	4646      	mov	r6, r8
    8a40:	703a      	strb	r2, [r7, #0]
    8a42:	f107 0b01 	add.w	fp, r7, #1
    8a46:	e49a      	b.n	837e <_dtoa_r+0x50e>
    8a48:	ee36 6b43 	vsub.f64	d6, d6, d3
    8a4c:	eeb4 6bc7 	vcmpe.f64	d6, d7
    8a50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8a54:	dc01      	bgt.n	8a5a <_dtoa_r+0xbea>
    8a56:	e729      	b.n	88ac <_dtoa_r+0xa3c>
    8a58:	4693      	mov	fp, r2
    8a5a:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    8a5e:	2b30      	cmp	r3, #48	; 0x30
    8a60:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    8a64:	d0f8      	beq.n	8a58 <_dtoa_r+0xbe8>
    8a66:	e57a      	b.n	855e <_dtoa_r+0x6ee>
    8a68:	9602      	str	r6, [sp, #8]
    8a6a:	f7ff bb58 	b.w	811e <_dtoa_r+0x2ae>
    8a6e:	9307      	str	r3, [sp, #28]
    8a70:	e6b0      	b.n	87d4 <_dtoa_r+0x964>
    8a72:	f1ba 0f00 	cmp.w	sl, #0
    8a76:	f47f adbc 	bne.w	85f2 <_dtoa_r+0x782>
    8a7a:	e698      	b.n	87ae <_dtoa_r+0x93e>
    8a7c:	2a39      	cmp	r2, #57	; 0x39
    8a7e:	46cb      	mov	fp, r9
    8a80:	4691      	mov	r9, r2
    8a82:	d0d9      	beq.n	8a38 <_dtoa_r+0xbc8>
    8a84:	f1bb 0f00 	cmp.w	fp, #0
    8a88:	f73f aef9 	bgt.w	887e <_dtoa_r+0xa0e>
    8a8c:	e6f9      	b.n	8882 <_dtoa_r+0xa12>
    8a8e:	f47f aef8 	bne.w	8882 <_dtoa_r+0xa12>
    8a92:	f019 0f01 	tst.w	r9, #1
    8a96:	f43f aef4 	beq.w	8882 <_dtoa_r+0xa12>
    8a9a:	e6ec      	b.n	8876 <_dtoa_r+0xa06>
    8a9c:	9b01      	ldr	r3, [sp, #4]
    8a9e:	2b02      	cmp	r3, #2
    8aa0:	dc08      	bgt.n	8ab4 <_dtoa_r+0xc44>
    8aa2:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    8aa4:	e43a      	b.n	831c <_dtoa_r+0x4ac>
    8aa6:	2102      	movs	r1, #2
    8aa8:	e4e7      	b.n	847a <_dtoa_r+0x60a>
    8aaa:	9b01      	ldr	r3, [sp, #4]
    8aac:	2b02      	cmp	r3, #2
    8aae:	dc01      	bgt.n	8ab4 <_dtoa_r+0xc44>
    8ab0:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    8ab2:	e5ae      	b.n	8612 <_dtoa_r+0x7a2>
    8ab4:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    8ab6:	e651      	b.n	875c <_dtoa_r+0x8ec>
    8ab8:	2301      	movs	r3, #1
    8aba:	930e      	str	r3, [sp, #56]	; 0x38
    8abc:	f7ff baa1 	b.w	8002 <_dtoa_r+0x192>
    8ac0:	f43f ac0f 	beq.w	82e2 <_dtoa_r+0x472>
    8ac4:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
    8ac8:	e404      	b.n	82d4 <_dtoa_r+0x464>
    8aca:	2500      	movs	r5, #0
    8acc:	6465      	str	r5, [r4, #68]	; 0x44
    8ace:	4629      	mov	r1, r5
    8ad0:	4620      	mov	r0, r4
    8ad2:	f7fe fdc5 	bl	7660 <_Balloc>
    8ad6:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    8ada:	2301      	movs	r3, #1
    8adc:	9008      	str	r0, [sp, #32]
    8ade:	46a8      	mov	r8, r5
    8ae0:	6420      	str	r0, [r4, #64]	; 0x40
    8ae2:	970d      	str	r7, [sp, #52]	; 0x34
    8ae4:	9309      	str	r3, [sp, #36]	; 0x24
    8ae6:	f7ff bac0 	b.w	806a <_dtoa_r+0x1fa>
    8aea:	bf00      	nop
    8aec:	200002e8 	.word	0x200002e8
    8af0:	200002c0 	.word	0x200002c0
    8af4:	00000000 	.word	0x00000000

00008af8 <_svfprintf_r>:
    8af8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8afc:	ed2d 8b06 	vpush	{d8-d10}
    8b00:	b0b9      	sub	sp, #228	; 0xe4
    8b02:	460c      	mov	r4, r1
    8b04:	9103      	str	r1, [sp, #12]
    8b06:	4692      	mov	sl, r2
    8b08:	9309      	str	r3, [sp, #36]	; 0x24
    8b0a:	9005      	str	r0, [sp, #20]
    8b0c:	f7fe fd44 	bl	7598 <_localeconv_r>
    8b10:	6803      	ldr	r3, [r0, #0]
    8b12:	9310      	str	r3, [sp, #64]	; 0x40
    8b14:	4618      	mov	r0, r3
    8b16:	f7fe fa53 	bl	6fc0 <strlen>
    8b1a:	89a3      	ldrh	r3, [r4, #12]
    8b1c:	900f      	str	r0, [sp, #60]	; 0x3c
    8b1e:	0619      	lsls	r1, r3, #24
    8b20:	d503      	bpl.n	8b2a <_svfprintf_r+0x32>
    8b22:	6923      	ldr	r3, [r4, #16]
    8b24:	2b00      	cmp	r3, #0
    8b26:	f001 807d 	beq.w	9c24 <_svfprintf_r+0x112c>
    8b2a:	2300      	movs	r3, #0
    8b2c:	ed9f 8ba4 	vldr	d8, [pc, #656]	; 8dc0 <_svfprintf_r+0x2c8>
    8b30:	ed9f 9ba5 	vldr	d9, [pc, #660]	; 8dc8 <_svfprintf_r+0x2d0>
    8b34:	930d      	str	r3, [sp, #52]	; 0x34
    8b36:	931d      	str	r3, [sp, #116]	; 0x74
    8b38:	931c      	str	r3, [sp, #112]	; 0x70
    8b3a:	9311      	str	r3, [sp, #68]	; 0x44
    8b3c:	9306      	str	r3, [sp, #24]
    8b3e:	ab28      	add	r3, sp, #160	; 0xa0
    8b40:	931b      	str	r3, [sp, #108]	; 0x6c
    8b42:	4699      	mov	r9, r3
    8b44:	f89a 3000 	ldrb.w	r3, [sl]
    8b48:	4654      	mov	r4, sl
    8b4a:	b1eb      	cbz	r3, 8b88 <_svfprintf_r+0x90>
    8b4c:	2b25      	cmp	r3, #37	; 0x25
    8b4e:	d102      	bne.n	8b56 <_svfprintf_r+0x5e>
    8b50:	e01a      	b.n	8b88 <_svfprintf_r+0x90>
    8b52:	2b25      	cmp	r3, #37	; 0x25
    8b54:	d003      	beq.n	8b5e <_svfprintf_r+0x66>
    8b56:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    8b5a:	2b00      	cmp	r3, #0
    8b5c:	d1f9      	bne.n	8b52 <_svfprintf_r+0x5a>
    8b5e:	ebca 0504 	rsb	r5, sl, r4
    8b62:	b18d      	cbz	r5, 8b88 <_svfprintf_r+0x90>
    8b64:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    8b66:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    8b68:	f8c9 a000 	str.w	sl, [r9]
    8b6c:	3301      	adds	r3, #1
    8b6e:	442a      	add	r2, r5
    8b70:	2b07      	cmp	r3, #7
    8b72:	f8c9 5004 	str.w	r5, [r9, #4]
    8b76:	921d      	str	r2, [sp, #116]	; 0x74
    8b78:	931c      	str	r3, [sp, #112]	; 0x70
    8b7a:	f300 80a3 	bgt.w	8cc4 <_svfprintf_r+0x1cc>
    8b7e:	f109 0908 	add.w	r9, r9, #8
    8b82:	9b06      	ldr	r3, [sp, #24]
    8b84:	442b      	add	r3, r5
    8b86:	9306      	str	r3, [sp, #24]
    8b88:	7823      	ldrb	r3, [r4, #0]
    8b8a:	2b00      	cmp	r3, #0
    8b8c:	f000 80a3 	beq.w	8cd6 <_svfprintf_r+0x1de>
    8b90:	2300      	movs	r3, #0
    8b92:	461a      	mov	r2, r3
    8b94:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    8b98:	4619      	mov	r1, r3
    8b9a:	9307      	str	r3, [sp, #28]
    8b9c:	469b      	mov	fp, r3
    8b9e:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    8ba2:	7863      	ldrb	r3, [r4, #1]
    8ba4:	f104 0a01 	add.w	sl, r4, #1
    8ba8:	4645      	mov	r5, r8
    8baa:	f10a 0a01 	add.w	sl, sl, #1
    8bae:	f1a3 0020 	sub.w	r0, r3, #32
    8bb2:	2858      	cmp	r0, #88	; 0x58
    8bb4:	f200 83f8 	bhi.w	93a8 <_svfprintf_r+0x8b0>
    8bb8:	e8df f010 	tbh	[pc, r0, lsl #1]
    8bbc:	03f60363 	.word	0x03f60363
    8bc0:	036b03f6 	.word	0x036b03f6
    8bc4:	03f603f6 	.word	0x03f603f6
    8bc8:	03f603f6 	.word	0x03f603f6
    8bcc:	03f603f6 	.word	0x03f603f6
    8bd0:	037e0370 	.word	0x037e0370
    8bd4:	005d03f6 	.word	0x005d03f6
    8bd8:	03f600df 	.word	0x03f600df
    8bdc:	010c00fb 	.word	0x010c00fb
    8be0:	010c010c 	.word	0x010c010c
    8be4:	010c010c 	.word	0x010c010c
    8be8:	010c010c 	.word	0x010c010c
    8bec:	010c010c 	.word	0x010c010c
    8bf0:	03f603f6 	.word	0x03f603f6
    8bf4:	03f603f6 	.word	0x03f603f6
    8bf8:	03f603f6 	.word	0x03f603f6
    8bfc:	03f603f6 	.word	0x03f603f6
    8c00:	03f603f6 	.word	0x03f603f6
    8c04:	015e011c 	.word	0x015e011c
    8c08:	015e03f6 	.word	0x015e03f6
    8c0c:	03f603f6 	.word	0x03f603f6
    8c10:	03f603f6 	.word	0x03f603f6
    8c14:	03f602a1 	.word	0x03f602a1
    8c18:	02a603f6 	.word	0x02a603f6
    8c1c:	03f603f6 	.word	0x03f603f6
    8c20:	03f603f6 	.word	0x03f603f6
    8c24:	02d803f6 	.word	0x02d803f6
    8c28:	03f603f6 	.word	0x03f603f6
    8c2c:	03f60305 	.word	0x03f60305
    8c30:	03f603f6 	.word	0x03f603f6
    8c34:	03f603f6 	.word	0x03f603f6
    8c38:	03f603f6 	.word	0x03f603f6
    8c3c:	03f603f6 	.word	0x03f603f6
    8c40:	034303f6 	.word	0x034303f6
    8c44:	015e0356 	.word	0x015e0356
    8c48:	015e015e 	.word	0x015e015e
    8c4c:	0356035e 	.word	0x0356035e
    8c50:	03f603f6 	.word	0x03f603f6
    8c54:	03f603a4 	.word	0x03f603a4
    8c58:	00a203b1 	.word	0x00a203b1
    8c5c:	03c30062 	.word	0x03c30062
    8c60:	03c803f6 	.word	0x03c803f6
    8c64:	038303f6 	.word	0x038303f6
    8c68:	03f603f6 	.word	0x03f603f6
    8c6c:	038b      	.short	0x038b
    8c6e:	9807      	ldr	r0, [sp, #28]
    8c70:	9309      	str	r3, [sp, #36]	; 0x24
    8c72:	4240      	negs	r0, r0
    8c74:	9007      	str	r0, [sp, #28]
    8c76:	f04b 0b04 	orr.w	fp, fp, #4
    8c7a:	f89a 3000 	ldrb.w	r3, [sl]
    8c7e:	e794      	b.n	8baa <_svfprintf_r+0xb2>
    8c80:	46a8      	mov	r8, r5
    8c82:	9809      	ldr	r0, [sp, #36]	; 0x24
    8c84:	2100      	movs	r1, #0
    8c86:	2330      	movs	r3, #48	; 0x30
    8c88:	2278      	movs	r2, #120	; 0x78
    8c8a:	4588      	cmp	r8, r1
    8c8c:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    8c90:	6804      	ldr	r4, [r0, #0]
    8c92:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    8c96:	f100 0704 	add.w	r7, r0, #4
    8c9a:	f04f 0500 	mov.w	r5, #0
    8c9e:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    8ca2:	f04b 0302 	orr.w	r3, fp, #2
    8ca6:	f2c0 839c 	blt.w	93e2 <_svfprintf_r+0x8ea>
    8caa:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    8cae:	f043 0b02 	orr.w	fp, r3, #2
    8cb2:	ea54 0305 	orrs.w	r3, r4, r5
    8cb6:	9709      	str	r7, [sp, #36]	; 0x24
    8cb8:	f000 8369 	beq.w	938e <_svfprintf_r+0x896>
    8cbc:	460f      	mov	r7, r1
    8cbe:	920c      	str	r2, [sp, #48]	; 0x30
    8cc0:	4843      	ldr	r0, [pc, #268]	; (8dd0 <_svfprintf_r+0x2d8>)
    8cc2:	e2ae      	b.n	9222 <_svfprintf_r+0x72a>
    8cc4:	aa1b      	add	r2, sp, #108	; 0x6c
    8cc6:	9903      	ldr	r1, [sp, #12]
    8cc8:	9805      	ldr	r0, [sp, #20]
    8cca:	f001 f9cd 	bl	a068 <__ssprint_r>
    8cce:	b948      	cbnz	r0, 8ce4 <_svfprintf_r+0x1ec>
    8cd0:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    8cd4:	e755      	b.n	8b82 <_svfprintf_r+0x8a>
    8cd6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    8cd8:	b123      	cbz	r3, 8ce4 <_svfprintf_r+0x1ec>
    8cda:	9805      	ldr	r0, [sp, #20]
    8cdc:	9903      	ldr	r1, [sp, #12]
    8cde:	aa1b      	add	r2, sp, #108	; 0x6c
    8ce0:	f001 f9c2 	bl	a068 <__ssprint_r>
    8ce4:	9b03      	ldr	r3, [sp, #12]
    8ce6:	899b      	ldrh	r3, [r3, #12]
    8ce8:	f013 0f40 	tst.w	r3, #64	; 0x40
    8cec:	9b06      	ldr	r3, [sp, #24]
    8cee:	bf18      	it	ne
    8cf0:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    8cf4:	4618      	mov	r0, r3
    8cf6:	b039      	add	sp, #228	; 0xe4
    8cf8:	ecbd 8b06 	vpop	{d8-d10}
    8cfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8d00:	930c      	str	r3, [sp, #48]	; 0x30
    8d02:	46a8      	mov	r8, r5
    8d04:	2a00      	cmp	r2, #0
    8d06:	f041 819a 	bne.w	a03e <_svfprintf_r+0x1546>
    8d0a:	f01b 0320 	ands.w	r3, fp, #32
    8d0e:	f000 8206 	beq.w	911e <_svfprintf_r+0x626>
    8d12:	9f09      	ldr	r7, [sp, #36]	; 0x24
    8d14:	3707      	adds	r7, #7
    8d16:	f027 0307 	bic.w	r3, r7, #7
    8d1a:	2700      	movs	r7, #0
    8d1c:	f103 0208 	add.w	r2, r3, #8
    8d20:	45b8      	cmp	r8, r7
    8d22:	9209      	str	r2, [sp, #36]	; 0x24
    8d24:	e9d3 4500 	ldrd	r4, r5, [r3]
    8d28:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    8d2c:	f2c0 865e 	blt.w	99ec <_svfprintf_r+0xef4>
    8d30:	ea54 0305 	orrs.w	r3, r4, r5
    8d34:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    8d38:	f000 834b 	beq.w	93d2 <_svfprintf_r+0x8da>
    8d3c:	ae28      	add	r6, sp, #160	; 0xa0
    8d3e:	08e2      	lsrs	r2, r4, #3
    8d40:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
    8d44:	08e9      	lsrs	r1, r5, #3
    8d46:	f004 0307 	and.w	r3, r4, #7
    8d4a:	460d      	mov	r5, r1
    8d4c:	4614      	mov	r4, r2
    8d4e:	3330      	adds	r3, #48	; 0x30
    8d50:	ea54 0205 	orrs.w	r2, r4, r5
    8d54:	f806 3d01 	strb.w	r3, [r6, #-1]!
    8d58:	d1f1      	bne.n	8d3e <_svfprintf_r+0x246>
    8d5a:	f01b 0f01 	tst.w	fp, #1
    8d5e:	f000 8227 	beq.w	91b0 <_svfprintf_r+0x6b8>
    8d62:	2b30      	cmp	r3, #48	; 0x30
    8d64:	f000 8224 	beq.w	91b0 <_svfprintf_r+0x6b8>
    8d68:	2230      	movs	r2, #48	; 0x30
    8d6a:	1e73      	subs	r3, r6, #1
    8d6c:	f806 2c01 	strb.w	r2, [r6, #-1]
    8d70:	aa28      	add	r2, sp, #160	; 0xa0
    8d72:	1ad2      	subs	r2, r2, r3
    8d74:	9208      	str	r2, [sp, #32]
    8d76:	461e      	mov	r6, r3
    8d78:	e21d      	b.n	91b6 <_svfprintf_r+0x6be>
    8d7a:	f89a 3000 	ldrb.w	r3, [sl]
    8d7e:	2b2a      	cmp	r3, #42	; 0x2a
    8d80:	f10a 0401 	add.w	r4, sl, #1
    8d84:	f001 812f 	beq.w	9fe6 <_svfprintf_r+0x14ee>
    8d88:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    8d8c:	2809      	cmp	r0, #9
    8d8e:	bf98      	it	ls
    8d90:	2500      	movls	r5, #0
    8d92:	f201 80d5 	bhi.w	9f40 <_svfprintf_r+0x1448>
    8d96:	f814 3b01 	ldrb.w	r3, [r4], #1
    8d9a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    8d9e:	eb00 0545 	add.w	r5, r0, r5, lsl #1
    8da2:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    8da6:	2809      	cmp	r0, #9
    8da8:	d9f5      	bls.n	8d96 <_svfprintf_r+0x29e>
    8daa:	ea45 75e5 	orr.w	r5, r5, r5, asr #31
    8dae:	46a2      	mov	sl, r4
    8db0:	e6fd      	b.n	8bae <_svfprintf_r+0xb6>
    8db2:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
    8db6:	f89a 3000 	ldrb.w	r3, [sl]
    8dba:	e6f6      	b.n	8baa <_svfprintf_r+0xb2>
    8dbc:	f3af 8000 	nop.w
	...
    8dc8:	ffffffff 	.word	0xffffffff
    8dcc:	7fefffff 	.word	0x7fefffff
    8dd0:	20000e2c 	.word	0x20000e2c
    8dd4:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    8dd8:	2300      	movs	r3, #0
    8dda:	461c      	mov	r4, r3
    8ddc:	f81a 3b01 	ldrb.w	r3, [sl], #1
    8de0:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    8de4:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    8de8:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    8dec:	2809      	cmp	r0, #9
    8dee:	d9f5      	bls.n	8ddc <_svfprintf_r+0x2e4>
    8df0:	9407      	str	r4, [sp, #28]
    8df2:	e6dc      	b.n	8bae <_svfprintf_r+0xb6>
    8df4:	930c      	str	r3, [sp, #48]	; 0x30
    8df6:	46a8      	mov	r8, r5
    8df8:	2a00      	cmp	r2, #0
    8dfa:	f041 812c 	bne.w	a056 <_svfprintf_r+0x155e>
    8dfe:	f04b 0b10 	orr.w	fp, fp, #16
    8e02:	f01b 0f20 	tst.w	fp, #32
    8e06:	f000 8503 	beq.w	9810 <_svfprintf_r+0xd18>
    8e0a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    8e0c:	3707      	adds	r7, #7
    8e0e:	f027 0707 	bic.w	r7, r7, #7
    8e12:	e9d7 2300 	ldrd	r2, r3, [r7]
    8e16:	f107 0108 	add.w	r1, r7, #8
    8e1a:	9109      	str	r1, [sp, #36]	; 0x24
    8e1c:	4614      	mov	r4, r2
    8e1e:	461d      	mov	r5, r3
    8e20:	2a00      	cmp	r2, #0
    8e22:	f173 0300 	sbcs.w	r3, r3, #0
    8e26:	f2c0 8537 	blt.w	9898 <_svfprintf_r+0xda0>
    8e2a:	f1b8 0f00 	cmp.w	r8, #0
    8e2e:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    8e32:	f2c0 81b5 	blt.w	91a0 <_svfprintf_r+0x6a8>
    8e36:	ea54 0305 	orrs.w	r3, r4, r5
    8e3a:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    8e3e:	f000 83f6 	beq.w	962e <_svfprintf_r+0xb36>
    8e42:	2d00      	cmp	r5, #0
    8e44:	bf08      	it	eq
    8e46:	2c0a      	cmpeq	r4, #10
    8e48:	f0c0 81ae 	bcc.w	91a8 <_svfprintf_r+0x6b0>
    8e4c:	ae28      	add	r6, sp, #160	; 0xa0
    8e4e:	4620      	mov	r0, r4
    8e50:	4629      	mov	r1, r5
    8e52:	220a      	movs	r2, #10
    8e54:	2300      	movs	r3, #0
    8e56:	f7fc fed5 	bl	5c04 <__aeabi_uldivmod>
    8e5a:	3230      	adds	r2, #48	; 0x30
    8e5c:	f806 2d01 	strb.w	r2, [r6, #-1]!
    8e60:	4620      	mov	r0, r4
    8e62:	4629      	mov	r1, r5
    8e64:	2300      	movs	r3, #0
    8e66:	220a      	movs	r2, #10
    8e68:	f7fc fecc 	bl	5c04 <__aeabi_uldivmod>
    8e6c:	4604      	mov	r4, r0
    8e6e:	460d      	mov	r5, r1
    8e70:	ea54 0305 	orrs.w	r3, r4, r5
    8e74:	d1eb      	bne.n	8e4e <_svfprintf_r+0x356>
    8e76:	e19b      	b.n	91b0 <_svfprintf_r+0x6b8>
    8e78:	930c      	str	r3, [sp, #48]	; 0x30
    8e7a:	46a8      	mov	r8, r5
    8e7c:	2a00      	cmp	r2, #0
    8e7e:	f041 80e6 	bne.w	a04e <_svfprintf_r+0x1556>
    8e82:	9f09      	ldr	r7, [sp, #36]	; 0x24
    8e84:	f01b 0f08 	tst.w	fp, #8
    8e88:	f107 0707 	add.w	r7, r7, #7
    8e8c:	f000 8640 	beq.w	9b10 <_svfprintf_r+0x1018>
    8e90:	f027 0307 	bic.w	r3, r7, #7
    8e94:	ed93 8b00 	vldr	d8, [r3]
    8e98:	f103 0208 	add.w	r2, r3, #8
    8e9c:	9209      	str	r2, [sp, #36]	; 0x24
    8e9e:	eeb0 7bc8 	vabs.f64	d7, d8
    8ea2:	eeb4 7b49 	vcmp.f64	d7, d9
    8ea6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8eaa:	f340 85bc 	ble.w	9a26 <_svfprintf_r+0xf2e>
    8eae:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
    8eb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8eb6:	f100 87ca 	bmi.w	9e4e <_svfprintf_r+0x1356>
    8eba:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    8ebe:	4ea7      	ldr	r6, [pc, #668]	; (915c <_svfprintf_r+0x664>)
    8ec0:	4ba7      	ldr	r3, [pc, #668]	; (9160 <_svfprintf_r+0x668>)
    8ec2:	990c      	ldr	r1, [sp, #48]	; 0x30
    8ec4:	2203      	movs	r2, #3
    8ec6:	f04f 0800 	mov.w	r8, #0
    8eca:	9204      	str	r2, [sp, #16]
    8ecc:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    8ed0:	2947      	cmp	r1, #71	; 0x47
    8ed2:	bfd8      	it	le
    8ed4:	461e      	movle	r6, r3
    8ed6:	9208      	str	r2, [sp, #32]
    8ed8:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    8edc:	b117      	cbz	r7, 8ee4 <_svfprintf_r+0x3ec>
    8ede:	9b04      	ldr	r3, [sp, #16]
    8ee0:	3301      	adds	r3, #1
    8ee2:	9304      	str	r3, [sp, #16]
    8ee4:	f01b 0302 	ands.w	r3, fp, #2
    8ee8:	930a      	str	r3, [sp, #40]	; 0x28
    8eea:	d002      	beq.n	8ef2 <_svfprintf_r+0x3fa>
    8eec:	9b04      	ldr	r3, [sp, #16]
    8eee:	3302      	adds	r3, #2
    8ef0:	9304      	str	r3, [sp, #16]
    8ef2:	f01b 0384 	ands.w	r3, fp, #132	; 0x84
    8ef6:	930b      	str	r3, [sp, #44]	; 0x2c
    8ef8:	f040 8280 	bne.w	93fc <_svfprintf_r+0x904>
    8efc:	9b07      	ldr	r3, [sp, #28]
    8efe:	9a04      	ldr	r2, [sp, #16]
    8f00:	1a9c      	subs	r4, r3, r2
    8f02:	2c00      	cmp	r4, #0
    8f04:	f340 827a 	ble.w	93fc <_svfprintf_r+0x904>
    8f08:	2c10      	cmp	r4, #16
    8f0a:	991d      	ldr	r1, [sp, #116]	; 0x74
    8f0c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    8f0e:	4f95      	ldr	r7, [pc, #596]	; (9164 <_svfprintf_r+0x66c>)
    8f10:	dd23      	ble.n	8f5a <_svfprintf_r+0x462>
    8f12:	4648      	mov	r0, r9
    8f14:	2510      	movs	r5, #16
    8f16:	46c1      	mov	r9, r8
    8f18:	46b0      	mov	r8, r6
    8f1a:	9e05      	ldr	r6, [sp, #20]
    8f1c:	e004      	b.n	8f28 <_svfprintf_r+0x430>
    8f1e:	3c10      	subs	r4, #16
    8f20:	2c10      	cmp	r4, #16
    8f22:	f100 0008 	add.w	r0, r0, #8
    8f26:	dd15      	ble.n	8f54 <_svfprintf_r+0x45c>
    8f28:	3201      	adds	r2, #1
    8f2a:	3110      	adds	r1, #16
    8f2c:	2a07      	cmp	r2, #7
    8f2e:	911d      	str	r1, [sp, #116]	; 0x74
    8f30:	921c      	str	r2, [sp, #112]	; 0x70
    8f32:	6007      	str	r7, [r0, #0]
    8f34:	6045      	str	r5, [r0, #4]
    8f36:	ddf2      	ble.n	8f1e <_svfprintf_r+0x426>
    8f38:	aa1b      	add	r2, sp, #108	; 0x6c
    8f3a:	9903      	ldr	r1, [sp, #12]
    8f3c:	4630      	mov	r0, r6
    8f3e:	f001 f893 	bl	a068 <__ssprint_r>
    8f42:	2800      	cmp	r0, #0
    8f44:	f47f aece 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    8f48:	3c10      	subs	r4, #16
    8f4a:	2c10      	cmp	r4, #16
    8f4c:	991d      	ldr	r1, [sp, #116]	; 0x74
    8f4e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    8f50:	a828      	add	r0, sp, #160	; 0xa0
    8f52:	dce9      	bgt.n	8f28 <_svfprintf_r+0x430>
    8f54:	4646      	mov	r6, r8
    8f56:	46c8      	mov	r8, r9
    8f58:	4681      	mov	r9, r0
    8f5a:	3201      	adds	r2, #1
    8f5c:	1863      	adds	r3, r4, r1
    8f5e:	2a07      	cmp	r2, #7
    8f60:	931d      	str	r3, [sp, #116]	; 0x74
    8f62:	921c      	str	r2, [sp, #112]	; 0x70
    8f64:	f8c9 7000 	str.w	r7, [r9]
    8f68:	f8c9 4004 	str.w	r4, [r9, #4]
    8f6c:	f300 83e2 	bgt.w	9734 <_svfprintf_r+0xc3c>
    8f70:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    8f74:	f109 0908 	add.w	r9, r9, #8
    8f78:	b177      	cbz	r7, 8f98 <_svfprintf_r+0x4a0>
    8f7a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    8f7c:	3201      	adds	r2, #1
    8f7e:	3301      	adds	r3, #1
    8f80:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
    8f84:	2101      	movs	r1, #1
    8f86:	2a07      	cmp	r2, #7
    8f88:	931d      	str	r3, [sp, #116]	; 0x74
    8f8a:	921c      	str	r2, [sp, #112]	; 0x70
    8f8c:	e889 0003 	stmia.w	r9, {r0, r1}
    8f90:	f300 835f 	bgt.w	9652 <_svfprintf_r+0xb5a>
    8f94:	f109 0908 	add.w	r9, r9, #8
    8f98:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    8f9a:	b16a      	cbz	r2, 8fb8 <_svfprintf_r+0x4c0>
    8f9c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    8f9e:	3201      	adds	r2, #1
    8fa0:	3302      	adds	r3, #2
    8fa2:	a814      	add	r0, sp, #80	; 0x50
    8fa4:	2102      	movs	r1, #2
    8fa6:	2a07      	cmp	r2, #7
    8fa8:	931d      	str	r3, [sp, #116]	; 0x74
    8faa:	921c      	str	r2, [sp, #112]	; 0x70
    8fac:	e889 0003 	stmia.w	r9, {r0, r1}
    8fb0:	f300 835b 	bgt.w	966a <_svfprintf_r+0xb72>
    8fb4:	f109 0908 	add.w	r9, r9, #8
    8fb8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    8fba:	2a80      	cmp	r2, #128	; 0x80
    8fbc:	f000 827e 	beq.w	94bc <_svfprintf_r+0x9c4>
    8fc0:	9a08      	ldr	r2, [sp, #32]
    8fc2:	ebc2 0408 	rsb	r4, r2, r8
    8fc6:	2c00      	cmp	r4, #0
    8fc8:	dd34      	ble.n	9034 <_svfprintf_r+0x53c>
    8fca:	2c10      	cmp	r4, #16
    8fcc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    8fce:	4f66      	ldr	r7, [pc, #408]	; (9168 <_svfprintf_r+0x670>)
    8fd0:	dd23      	ble.n	901a <_svfprintf_r+0x522>
    8fd2:	4649      	mov	r1, r9
    8fd4:	f04f 0810 	mov.w	r8, #16
    8fd8:	46b1      	mov	r9, r6
    8fda:	9d05      	ldr	r5, [sp, #20]
    8fdc:	9e03      	ldr	r6, [sp, #12]
    8fde:	e004      	b.n	8fea <_svfprintf_r+0x4f2>
    8fe0:	3c10      	subs	r4, #16
    8fe2:	2c10      	cmp	r4, #16
    8fe4:	f101 0108 	add.w	r1, r1, #8
    8fe8:	dd15      	ble.n	9016 <_svfprintf_r+0x51e>
    8fea:	3201      	adds	r2, #1
    8fec:	3310      	adds	r3, #16
    8fee:	2a07      	cmp	r2, #7
    8ff0:	931d      	str	r3, [sp, #116]	; 0x74
    8ff2:	921c      	str	r2, [sp, #112]	; 0x70
    8ff4:	e881 0180 	stmia.w	r1, {r7, r8}
    8ff8:	ddf2      	ble.n	8fe0 <_svfprintf_r+0x4e8>
    8ffa:	aa1b      	add	r2, sp, #108	; 0x6c
    8ffc:	4631      	mov	r1, r6
    8ffe:	4628      	mov	r0, r5
    9000:	f001 f832 	bl	a068 <__ssprint_r>
    9004:	2800      	cmp	r0, #0
    9006:	f47f ae6d 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    900a:	3c10      	subs	r4, #16
    900c:	2c10      	cmp	r4, #16
    900e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9010:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9012:	a928      	add	r1, sp, #160	; 0xa0
    9014:	dce9      	bgt.n	8fea <_svfprintf_r+0x4f2>
    9016:	464e      	mov	r6, r9
    9018:	4689      	mov	r9, r1
    901a:	3201      	adds	r2, #1
    901c:	4423      	add	r3, r4
    901e:	2a07      	cmp	r2, #7
    9020:	931d      	str	r3, [sp, #116]	; 0x74
    9022:	921c      	str	r2, [sp, #112]	; 0x70
    9024:	f8c9 7000 	str.w	r7, [r9]
    9028:	f8c9 4004 	str.w	r4, [r9, #4]
    902c:	f300 8305 	bgt.w	963a <_svfprintf_r+0xb42>
    9030:	f109 0908 	add.w	r9, r9, #8
    9034:	f41b 7f80 	tst.w	fp, #256	; 0x100
    9038:	f040 81e2 	bne.w	9400 <_svfprintf_r+0x908>
    903c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    903e:	9808      	ldr	r0, [sp, #32]
    9040:	f8c9 6000 	str.w	r6, [r9]
    9044:	3201      	adds	r2, #1
    9046:	4403      	add	r3, r0
    9048:	2a07      	cmp	r2, #7
    904a:	931d      	str	r3, [sp, #116]	; 0x74
    904c:	f8c9 0004 	str.w	r0, [r9, #4]
    9050:	921c      	str	r2, [sp, #112]	; 0x70
    9052:	f300 82c2 	bgt.w	95da <_svfprintf_r+0xae2>
    9056:	f109 0908 	add.w	r9, r9, #8
    905a:	f01b 0f04 	tst.w	fp, #4
    905e:	d03e      	beq.n	90de <_svfprintf_r+0x5e6>
    9060:	9a07      	ldr	r2, [sp, #28]
    9062:	9904      	ldr	r1, [sp, #16]
    9064:	1a54      	subs	r4, r2, r1
    9066:	2c00      	cmp	r4, #0
    9068:	dd39      	ble.n	90de <_svfprintf_r+0x5e6>
    906a:	2c10      	cmp	r4, #16
    906c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    906e:	4f3d      	ldr	r7, [pc, #244]	; (9164 <_svfprintf_r+0x66c>)
    9070:	dd22      	ble.n	90b8 <_svfprintf_r+0x5c0>
    9072:	2510      	movs	r5, #16
    9074:	9e05      	ldr	r6, [sp, #20]
    9076:	f8dd 800c 	ldr.w	r8, [sp, #12]
    907a:	e004      	b.n	9086 <_svfprintf_r+0x58e>
    907c:	3c10      	subs	r4, #16
    907e:	2c10      	cmp	r4, #16
    9080:	f109 0908 	add.w	r9, r9, #8
    9084:	dd18      	ble.n	90b8 <_svfprintf_r+0x5c0>
    9086:	3201      	adds	r2, #1
    9088:	3310      	adds	r3, #16
    908a:	2a07      	cmp	r2, #7
    908c:	931d      	str	r3, [sp, #116]	; 0x74
    908e:	921c      	str	r2, [sp, #112]	; 0x70
    9090:	f8c9 7000 	str.w	r7, [r9]
    9094:	f8c9 5004 	str.w	r5, [r9, #4]
    9098:	ddf0      	ble.n	907c <_svfprintf_r+0x584>
    909a:	aa1b      	add	r2, sp, #108	; 0x6c
    909c:	4641      	mov	r1, r8
    909e:	4630      	mov	r0, r6
    90a0:	f000 ffe2 	bl	a068 <__ssprint_r>
    90a4:	2800      	cmp	r0, #0
    90a6:	f47f ae1d 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    90aa:	3c10      	subs	r4, #16
    90ac:	2c10      	cmp	r4, #16
    90ae:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    90b0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    90b2:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    90b6:	dce6      	bgt.n	9086 <_svfprintf_r+0x58e>
    90b8:	3201      	adds	r2, #1
    90ba:	4423      	add	r3, r4
    90bc:	2a07      	cmp	r2, #7
    90be:	931d      	str	r3, [sp, #116]	; 0x74
    90c0:	921c      	str	r2, [sp, #112]	; 0x70
    90c2:	f8c9 7000 	str.w	r7, [r9]
    90c6:	f8c9 4004 	str.w	r4, [r9, #4]
    90ca:	dd08      	ble.n	90de <_svfprintf_r+0x5e6>
    90cc:	aa1b      	add	r2, sp, #108	; 0x6c
    90ce:	9903      	ldr	r1, [sp, #12]
    90d0:	9805      	ldr	r0, [sp, #20]
    90d2:	f000 ffc9 	bl	a068 <__ssprint_r>
    90d6:	2800      	cmp	r0, #0
    90d8:	f47f ae04 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    90dc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    90de:	9a06      	ldr	r2, [sp, #24]
    90e0:	9907      	ldr	r1, [sp, #28]
    90e2:	9804      	ldr	r0, [sp, #16]
    90e4:	4281      	cmp	r1, r0
    90e6:	bfac      	ite	ge
    90e8:	1852      	addge	r2, r2, r1
    90ea:	1812      	addlt	r2, r2, r0
    90ec:	9206      	str	r2, [sp, #24]
    90ee:	2b00      	cmp	r3, #0
    90f0:	f040 827f 	bne.w	95f2 <_svfprintf_r+0xafa>
    90f4:	2300      	movs	r3, #0
    90f6:	931c      	str	r3, [sp, #112]	; 0x70
    90f8:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    90fc:	e522      	b.n	8b44 <_svfprintf_r+0x4c>
    90fe:	f04b 0b08 	orr.w	fp, fp, #8
    9102:	f89a 3000 	ldrb.w	r3, [sl]
    9106:	e550      	b.n	8baa <_svfprintf_r+0xb2>
    9108:	930c      	str	r3, [sp, #48]	; 0x30
    910a:	46a8      	mov	r8, r5
    910c:	2a00      	cmp	r2, #0
    910e:	f040 879a 	bne.w	a046 <_svfprintf_r+0x154e>
    9112:	f04b 0b10 	orr.w	fp, fp, #16
    9116:	f01b 0320 	ands.w	r3, fp, #32
    911a:	f47f adfa 	bne.w	8d12 <_svfprintf_r+0x21a>
    911e:	f01b 0210 	ands.w	r2, fp, #16
    9122:	f040 8391 	bne.w	9848 <_svfprintf_r+0xd50>
    9126:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    912a:	f000 838d 	beq.w	9848 <_svfprintf_r+0xd50>
    912e:	9909      	ldr	r1, [sp, #36]	; 0x24
    9130:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    9134:	460b      	mov	r3, r1
    9136:	f1b8 0f00 	cmp.w	r8, #0
    913a:	f103 0304 	add.w	r3, r3, #4
    913e:	880c      	ldrh	r4, [r1, #0]
    9140:	f04f 0500 	mov.w	r5, #0
    9144:	f2c0 85ab 	blt.w	9c9e <_svfprintf_r+0x11a6>
    9148:	ea54 0105 	orrs.w	r1, r4, r5
    914c:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9150:	9309      	str	r3, [sp, #36]	; 0x24
    9152:	f000 813e 	beq.w	93d2 <_svfprintf_r+0x8da>
    9156:	4617      	mov	r7, r2
    9158:	e5f0      	b.n	8d3c <_svfprintf_r+0x244>
    915a:	bf00      	nop
    915c:	20000e0c 	.word	0x20000e0c
    9160:	20000e08 	.word	0x20000e08
    9164:	200006cc 	.word	0x200006cc
    9168:	20000fec 	.word	0x20000fec
    916c:	930c      	str	r3, [sp, #48]	; 0x30
    916e:	46a8      	mov	r8, r5
    9170:	2a00      	cmp	r2, #0
    9172:	f040 8759 	bne.w	a028 <_svfprintf_r+0x1530>
    9176:	f04b 0b10 	orr.w	fp, fp, #16
    917a:	f01b 0320 	ands.w	r3, fp, #32
    917e:	f000 82e7 	beq.w	9750 <_svfprintf_r+0xc58>
    9182:	9f09      	ldr	r7, [sp, #36]	; 0x24
    9184:	3707      	adds	r7, #7
    9186:	f027 0307 	bic.w	r3, r7, #7
    918a:	2700      	movs	r7, #0
    918c:	f103 0208 	add.w	r2, r3, #8
    9190:	45b8      	cmp	r8, r7
    9192:	9209      	str	r2, [sp, #36]	; 0x24
    9194:	e9d3 4500 	ldrd	r4, r5, [r3]
    9198:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    919c:	f6bf ae4b 	bge.w	8e36 <_svfprintf_r+0x33e>
    91a0:	ea54 0305 	orrs.w	r3, r4, r5
    91a4:	f47f ae4d 	bne.w	8e42 <_svfprintf_r+0x34a>
    91a8:	ae38      	add	r6, sp, #224	; 0xe0
    91aa:	3430      	adds	r4, #48	; 0x30
    91ac:	f806 4d41 	strb.w	r4, [r6, #-65]!
    91b0:	ab28      	add	r3, sp, #160	; 0xa0
    91b2:	1b9b      	subs	r3, r3, r6
    91b4:	9308      	str	r3, [sp, #32]
    91b6:	9b08      	ldr	r3, [sp, #32]
    91b8:	4543      	cmp	r3, r8
    91ba:	bfb8      	it	lt
    91bc:	4643      	movlt	r3, r8
    91be:	9304      	str	r3, [sp, #16]
    91c0:	2300      	movs	r3, #0
    91c2:	930e      	str	r3, [sp, #56]	; 0x38
    91c4:	e68a      	b.n	8edc <_svfprintf_r+0x3e4>
    91c6:	930c      	str	r3, [sp, #48]	; 0x30
    91c8:	46a8      	mov	r8, r5
    91ca:	2a00      	cmp	r2, #0
    91cc:	f040 8728 	bne.w	a020 <_svfprintf_r+0x1528>
    91d0:	f01b 0f20 	tst.w	fp, #32
    91d4:	48c2      	ldr	r0, [pc, #776]	; (94e0 <_svfprintf_r+0x9e8>)
    91d6:	f000 8086 	beq.w	92e6 <_svfprintf_r+0x7ee>
    91da:	9f09      	ldr	r7, [sp, #36]	; 0x24
    91dc:	3707      	adds	r7, #7
    91de:	f027 0307 	bic.w	r3, r7, #7
    91e2:	e9d3 4500 	ldrd	r4, r5, [r3]
    91e6:	f103 0208 	add.w	r2, r3, #8
    91ea:	9209      	str	r2, [sp, #36]	; 0x24
    91ec:	f01b 0701 	ands.w	r7, fp, #1
    91f0:	f000 8247 	beq.w	9682 <_svfprintf_r+0xb8a>
    91f4:	ea54 0305 	orrs.w	r3, r4, r5
    91f8:	f000 84a3 	beq.w	9b42 <_svfprintf_r+0x104a>
    91fc:	2700      	movs	r7, #0
    91fe:	2330      	movs	r3, #48	; 0x30
    9200:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    9204:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    9208:	45b8      	cmp	r8, r7
    920a:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    920e:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9212:	f04b 0302 	orr.w	r3, fp, #2
    9216:	f2c0 8617 	blt.w	9e48 <_svfprintf_r+0x1350>
    921a:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    921e:	f043 0b02 	orr.w	fp, r3, #2
    9222:	ae28      	add	r6, sp, #160	; 0xa0
    9224:	0923      	lsrs	r3, r4, #4
    9226:	f004 010f 	and.w	r1, r4, #15
    922a:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
    922e:	092a      	lsrs	r2, r5, #4
    9230:	461c      	mov	r4, r3
    9232:	4615      	mov	r5, r2
    9234:	5c43      	ldrb	r3, [r0, r1]
    9236:	f806 3d01 	strb.w	r3, [r6, #-1]!
    923a:	ea54 0305 	orrs.w	r3, r4, r5
    923e:	d1f1      	bne.n	9224 <_svfprintf_r+0x72c>
    9240:	e7b6      	b.n	91b0 <_svfprintf_r+0x6b8>
    9242:	9909      	ldr	r1, [sp, #36]	; 0x24
    9244:	930c      	str	r3, [sp, #48]	; 0x30
    9246:	680a      	ldr	r2, [r1, #0]
    9248:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    924c:	2300      	movs	r3, #0
    924e:	460a      	mov	r2, r1
    9250:	461f      	mov	r7, r3
    9252:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9256:	3204      	adds	r2, #4
    9258:	2301      	movs	r3, #1
    925a:	9304      	str	r3, [sp, #16]
    925c:	46b8      	mov	r8, r7
    925e:	970e      	str	r7, [sp, #56]	; 0x38
    9260:	9209      	str	r2, [sp, #36]	; 0x24
    9262:	9308      	str	r3, [sp, #32]
    9264:	ae1e      	add	r6, sp, #120	; 0x78
    9266:	e63d      	b.n	8ee4 <_svfprintf_r+0x3ec>
    9268:	930c      	str	r3, [sp, #48]	; 0x30
    926a:	46a8      	mov	r8, r5
    926c:	2a00      	cmp	r2, #0
    926e:	f43f adc8 	beq.w	8e02 <_svfprintf_r+0x30a>
    9272:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    9276:	e5c4      	b.n	8e02 <_svfprintf_r+0x30a>
    9278:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
    927c:	f89a 3000 	ldrb.w	r3, [sl]
    9280:	e493      	b.n	8baa <_svfprintf_r+0xb2>
    9282:	f89a 3000 	ldrb.w	r3, [sl]
    9286:	2900      	cmp	r1, #0
    9288:	f47f ac8f 	bne.w	8baa <_svfprintf_r+0xb2>
    928c:	2201      	movs	r2, #1
    928e:	2120      	movs	r1, #32
    9290:	e48b      	b.n	8baa <_svfprintf_r+0xb2>
    9292:	f04b 0b01 	orr.w	fp, fp, #1
    9296:	f89a 3000 	ldrb.w	r3, [sl]
    929a:	e486      	b.n	8baa <_svfprintf_r+0xb2>
    929c:	9c09      	ldr	r4, [sp, #36]	; 0x24
    929e:	6823      	ldr	r3, [r4, #0]
    92a0:	9307      	str	r3, [sp, #28]
    92a2:	4618      	mov	r0, r3
    92a4:	2800      	cmp	r0, #0
    92a6:	4623      	mov	r3, r4
    92a8:	f103 0304 	add.w	r3, r3, #4
    92ac:	f6ff acdf 	blt.w	8c6e <_svfprintf_r+0x176>
    92b0:	9309      	str	r3, [sp, #36]	; 0x24
    92b2:	f89a 3000 	ldrb.w	r3, [sl]
    92b6:	e478      	b.n	8baa <_svfprintf_r+0xb2>
    92b8:	f89a 3000 	ldrb.w	r3, [sl]
    92bc:	2201      	movs	r2, #1
    92be:	212b      	movs	r1, #43	; 0x2b
    92c0:	e473      	b.n	8baa <_svfprintf_r+0xb2>
    92c2:	930c      	str	r3, [sp, #48]	; 0x30
    92c4:	46a8      	mov	r8, r5
    92c6:	2a00      	cmp	r2, #0
    92c8:	f43f af57 	beq.w	917a <_svfprintf_r+0x682>
    92cc:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    92d0:	e753      	b.n	917a <_svfprintf_r+0x682>
    92d2:	930c      	str	r3, [sp, #48]	; 0x30
    92d4:	46a8      	mov	r8, r5
    92d6:	2a00      	cmp	r2, #0
    92d8:	f040 86aa 	bne.w	a030 <_svfprintf_r+0x1538>
    92dc:	f01b 0f20 	tst.w	fp, #32
    92e0:	4880      	ldr	r0, [pc, #512]	; (94e4 <_svfprintf_r+0x9ec>)
    92e2:	f47f af7a 	bne.w	91da <_svfprintf_r+0x6e2>
    92e6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    92e8:	f01b 0f10 	tst.w	fp, #16
    92ec:	4613      	mov	r3, r2
    92ee:	f040 82c1 	bne.w	9874 <_svfprintf_r+0xd7c>
    92f2:	f01b 0f40 	tst.w	fp, #64	; 0x40
    92f6:	f000 82bd 	beq.w	9874 <_svfprintf_r+0xd7c>
    92fa:	3304      	adds	r3, #4
    92fc:	8814      	ldrh	r4, [r2, #0]
    92fe:	9309      	str	r3, [sp, #36]	; 0x24
    9300:	2500      	movs	r5, #0
    9302:	e773      	b.n	91ec <_svfprintf_r+0x6f4>
    9304:	f89a 3000 	ldrb.w	r3, [sl]
    9308:	2b6c      	cmp	r3, #108	; 0x6c
    930a:	bf03      	ittte	eq
    930c:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
    9310:	f04b 0b20 	orreq.w	fp, fp, #32
    9314:	f10a 0a01 	addeq.w	sl, sl, #1
    9318:	f04b 0b10 	orrne.w	fp, fp, #16
    931c:	e445      	b.n	8baa <_svfprintf_r+0xb2>
    931e:	2a00      	cmp	r2, #0
    9320:	f040 866f 	bne.w	a002 <_svfprintf_r+0x150a>
    9324:	f01b 0f20 	tst.w	fp, #32
    9328:	f000 8366 	beq.w	99f8 <_svfprintf_r+0xf00>
    932c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    932e:	9906      	ldr	r1, [sp, #24]
    9330:	6813      	ldr	r3, [r2, #0]
    9332:	17cd      	asrs	r5, r1, #31
    9334:	4608      	mov	r0, r1
    9336:	3204      	adds	r2, #4
    9338:	4629      	mov	r1, r5
    933a:	9209      	str	r2, [sp, #36]	; 0x24
    933c:	e9c3 0100 	strd	r0, r1, [r3]
    9340:	e400      	b.n	8b44 <_svfprintf_r+0x4c>
    9342:	f04b 0b20 	orr.w	fp, fp, #32
    9346:	f89a 3000 	ldrb.w	r3, [sl]
    934a:	e42e      	b.n	8baa <_svfprintf_r+0xb2>
    934c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    934e:	930c      	str	r3, [sp, #48]	; 0x30
    9350:	6816      	ldr	r6, [r2, #0]
    9352:	2400      	movs	r4, #0
    9354:	f88d 404f 	strb.w	r4, [sp, #79]	; 0x4f
    9358:	1d17      	adds	r7, r2, #4
    935a:	2e00      	cmp	r6, #0
    935c:	f000 8565 	beq.w	9e2a <_svfprintf_r+0x1332>
    9360:	2d00      	cmp	r5, #0
    9362:	f2c0 84a2 	blt.w	9caa <_svfprintf_r+0x11b2>
    9366:	462a      	mov	r2, r5
    9368:	4621      	mov	r1, r4
    936a:	4630      	mov	r0, r6
    936c:	f7fe f928 	bl	75c0 <memchr>
    9370:	2800      	cmp	r0, #0
    9372:	f000 85cc 	beq.w	9f0e <_svfprintf_r+0x1416>
    9376:	1b83      	subs	r3, r0, r6
    9378:	9308      	str	r3, [sp, #32]
    937a:	46a0      	mov	r8, r4
    937c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9380:	9709      	str	r7, [sp, #36]	; 0x24
    9382:	9304      	str	r3, [sp, #16]
    9384:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    9388:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    938c:	e5a6      	b.n	8edc <_svfprintf_r+0x3e4>
    938e:	4855      	ldr	r0, [pc, #340]	; (94e4 <_svfprintf_r+0x9ec>)
    9390:	920c      	str	r2, [sp, #48]	; 0x30
    9392:	f1b8 0f00 	cmp.w	r8, #0
    9396:	f040 8184 	bne.w	96a2 <_svfprintf_r+0xbaa>
    939a:	4647      	mov	r7, r8
    939c:	f04f 0800 	mov.w	r8, #0
    93a0:	f8cd 8020 	str.w	r8, [sp, #32]
    93a4:	ae28      	add	r6, sp, #160	; 0xa0
    93a6:	e706      	b.n	91b6 <_svfprintf_r+0x6be>
    93a8:	930c      	str	r3, [sp, #48]	; 0x30
    93aa:	2a00      	cmp	r2, #0
    93ac:	f040 862d 	bne.w	a00a <_svfprintf_r+0x1512>
    93b0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    93b2:	2a00      	cmp	r2, #0
    93b4:	f43f ac8f 	beq.w	8cd6 <_svfprintf_r+0x1de>
    93b8:	2300      	movs	r3, #0
    93ba:	2101      	movs	r1, #1
    93bc:	461f      	mov	r7, r3
    93be:	9104      	str	r1, [sp, #16]
    93c0:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    93c4:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    93c8:	4698      	mov	r8, r3
    93ca:	930e      	str	r3, [sp, #56]	; 0x38
    93cc:	9108      	str	r1, [sp, #32]
    93ce:	ae1e      	add	r6, sp, #120	; 0x78
    93d0:	e588      	b.n	8ee4 <_svfprintf_r+0x3ec>
    93d2:	f1b8 0f00 	cmp.w	r8, #0
    93d6:	f000 858b 	beq.w	9ef0 <_svfprintf_r+0x13f8>
    93da:	2700      	movs	r7, #0
    93dc:	2400      	movs	r4, #0
    93de:	2500      	movs	r5, #0
    93e0:	e4ac      	b.n	8d3c <_svfprintf_r+0x244>
    93e2:	4840      	ldr	r0, [pc, #256]	; (94e4 <_svfprintf_r+0x9ec>)
    93e4:	920c      	str	r2, [sp, #48]	; 0x30
    93e6:	469b      	mov	fp, r3
    93e8:	ea54 0305 	orrs.w	r3, r4, r5
    93ec:	9709      	str	r7, [sp, #36]	; 0x24
    93ee:	f04f 0700 	mov.w	r7, #0
    93f2:	f47f af16 	bne.w	9222 <_svfprintf_r+0x72a>
    93f6:	2400      	movs	r4, #0
    93f8:	2500      	movs	r5, #0
    93fa:	e712      	b.n	9222 <_svfprintf_r+0x72a>
    93fc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    93fe:	e5bb      	b.n	8f78 <_svfprintf_r+0x480>
    9400:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9402:	2a65      	cmp	r2, #101	; 0x65
    9404:	f340 80a1 	ble.w	954a <_svfprintf_r+0xa52>
    9408:	eeb5 8b40 	vcmp.f64	d8, #0.0
    940c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9410:	f040 8149 	bne.w	96a6 <_svfprintf_r+0xbae>
    9414:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9416:	4934      	ldr	r1, [pc, #208]	; (94e8 <_svfprintf_r+0x9f0>)
    9418:	f8c9 1000 	str.w	r1, [r9]
    941c:	3201      	adds	r2, #1
    941e:	3301      	adds	r3, #1
    9420:	2101      	movs	r1, #1
    9422:	2a07      	cmp	r2, #7
    9424:	931d      	str	r3, [sp, #116]	; 0x74
    9426:	921c      	str	r2, [sp, #112]	; 0x70
    9428:	f8c9 1004 	str.w	r1, [r9, #4]
    942c:	f300 8392 	bgt.w	9b54 <_svfprintf_r+0x105c>
    9430:	f109 0908 	add.w	r9, r9, #8
    9434:	9a15      	ldr	r2, [sp, #84]	; 0x54
    9436:	990d      	ldr	r1, [sp, #52]	; 0x34
    9438:	428a      	cmp	r2, r1
    943a:	db03      	blt.n	9444 <_svfprintf_r+0x94c>
    943c:	f01b 0f01 	tst.w	fp, #1
    9440:	f43f ae0b 	beq.w	905a <_svfprintf_r+0x562>
    9444:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9446:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9448:	9910      	ldr	r1, [sp, #64]	; 0x40
    944a:	f8c9 1000 	str.w	r1, [r9]
    944e:	3201      	adds	r2, #1
    9450:	4403      	add	r3, r0
    9452:	2a07      	cmp	r2, #7
    9454:	931d      	str	r3, [sp, #116]	; 0x74
    9456:	f8c9 0004 	str.w	r0, [r9, #4]
    945a:	921c      	str	r2, [sp, #112]	; 0x70
    945c:	f300 83d6 	bgt.w	9c0c <_svfprintf_r+0x1114>
    9460:	f109 0908 	add.w	r9, r9, #8
    9464:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9466:	1e54      	subs	r4, r2, #1
    9468:	2c00      	cmp	r4, #0
    946a:	f77f adf6 	ble.w	905a <_svfprintf_r+0x562>
    946e:	2c10      	cmp	r4, #16
    9470:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9472:	4f1e      	ldr	r7, [pc, #120]	; (94ec <_svfprintf_r+0x9f4>)
    9474:	f340 81dc 	ble.w	9830 <_svfprintf_r+0xd38>
    9478:	2510      	movs	r5, #16
    947a:	9e05      	ldr	r6, [sp, #20]
    947c:	f8dd 800c 	ldr.w	r8, [sp, #12]
    9480:	e005      	b.n	948e <_svfprintf_r+0x996>
    9482:	f109 0908 	add.w	r9, r9, #8
    9486:	3c10      	subs	r4, #16
    9488:	2c10      	cmp	r4, #16
    948a:	f340 81d1 	ble.w	9830 <_svfprintf_r+0xd38>
    948e:	3201      	adds	r2, #1
    9490:	3310      	adds	r3, #16
    9492:	2a07      	cmp	r2, #7
    9494:	931d      	str	r3, [sp, #116]	; 0x74
    9496:	921c      	str	r2, [sp, #112]	; 0x70
    9498:	f8c9 7000 	str.w	r7, [r9]
    949c:	f8c9 5004 	str.w	r5, [r9, #4]
    94a0:	ddef      	ble.n	9482 <_svfprintf_r+0x98a>
    94a2:	aa1b      	add	r2, sp, #108	; 0x6c
    94a4:	4641      	mov	r1, r8
    94a6:	4630      	mov	r0, r6
    94a8:	f000 fdde 	bl	a068 <__ssprint_r>
    94ac:	2800      	cmp	r0, #0
    94ae:	f47f ac19 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    94b2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    94b4:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    94b6:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    94ba:	e7e4      	b.n	9486 <_svfprintf_r+0x98e>
    94bc:	9a07      	ldr	r2, [sp, #28]
    94be:	9904      	ldr	r1, [sp, #16]
    94c0:	1a54      	subs	r4, r2, r1
    94c2:	2c00      	cmp	r4, #0
    94c4:	f77f ad7c 	ble.w	8fc0 <_svfprintf_r+0x4c8>
    94c8:	2c10      	cmp	r4, #16
    94ca:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    94cc:	4f07      	ldr	r7, [pc, #28]	; (94ec <_svfprintf_r+0x9f4>)
    94ce:	dd2e      	ble.n	952e <_svfprintf_r+0xa36>
    94d0:	4649      	mov	r1, r9
    94d2:	2510      	movs	r5, #16
    94d4:	46c1      	mov	r9, r8
    94d6:	4618      	mov	r0, r3
    94d8:	46b0      	mov	r8, r6
    94da:	9e05      	ldr	r6, [sp, #20]
    94dc:	e00d      	b.n	94fa <_svfprintf_r+0xa02>
    94de:	bf00      	nop
    94e0:	20000e18 	.word	0x20000e18
    94e4:	20000e2c 	.word	0x20000e2c
    94e8:	20000e04 	.word	0x20000e04
    94ec:	20000fec 	.word	0x20000fec
    94f0:	3c10      	subs	r4, #16
    94f2:	2c10      	cmp	r4, #16
    94f4:	f101 0108 	add.w	r1, r1, #8
    94f8:	dd15      	ble.n	9526 <_svfprintf_r+0xa2e>
    94fa:	3201      	adds	r2, #1
    94fc:	3010      	adds	r0, #16
    94fe:	2a07      	cmp	r2, #7
    9500:	901d      	str	r0, [sp, #116]	; 0x74
    9502:	921c      	str	r2, [sp, #112]	; 0x70
    9504:	600f      	str	r7, [r1, #0]
    9506:	604d      	str	r5, [r1, #4]
    9508:	ddf2      	ble.n	94f0 <_svfprintf_r+0x9f8>
    950a:	aa1b      	add	r2, sp, #108	; 0x6c
    950c:	9903      	ldr	r1, [sp, #12]
    950e:	4630      	mov	r0, r6
    9510:	f000 fdaa 	bl	a068 <__ssprint_r>
    9514:	2800      	cmp	r0, #0
    9516:	f47f abe5 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    951a:	3c10      	subs	r4, #16
    951c:	2c10      	cmp	r4, #16
    951e:	981d      	ldr	r0, [sp, #116]	; 0x74
    9520:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9522:	a928      	add	r1, sp, #160	; 0xa0
    9524:	dce9      	bgt.n	94fa <_svfprintf_r+0xa02>
    9526:	4646      	mov	r6, r8
    9528:	4603      	mov	r3, r0
    952a:	46c8      	mov	r8, r9
    952c:	4689      	mov	r9, r1
    952e:	3201      	adds	r2, #1
    9530:	4423      	add	r3, r4
    9532:	2a07      	cmp	r2, #7
    9534:	931d      	str	r3, [sp, #116]	; 0x74
    9536:	921c      	str	r2, [sp, #112]	; 0x70
    9538:	f8c9 7000 	str.w	r7, [r9]
    953c:	f8c9 4004 	str.w	r4, [r9, #4]
    9540:	f300 8246 	bgt.w	99d0 <_svfprintf_r+0xed8>
    9544:	f109 0908 	add.w	r9, r9, #8
    9548:	e53a      	b.n	8fc0 <_svfprintf_r+0x4c8>
    954a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    954c:	f8c9 6000 	str.w	r6, [r9]
    9550:	2a01      	cmp	r2, #1
    9552:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9554:	f103 0301 	add.w	r3, r3, #1
    9558:	f102 0201 	add.w	r2, r2, #1
    955c:	f04f 0101 	mov.w	r1, #1
    9560:	931d      	str	r3, [sp, #116]	; 0x74
    9562:	921c      	str	r2, [sp, #112]	; 0x70
    9564:	f8c9 1004 	str.w	r1, [r9, #4]
    9568:	f340 8210 	ble.w	998c <_svfprintf_r+0xe94>
    956c:	2a07      	cmp	r2, #7
    956e:	f300 8215 	bgt.w	999c <_svfprintf_r+0xea4>
    9572:	f109 0908 	add.w	r9, r9, #8
    9576:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9578:	9910      	ldr	r1, [sp, #64]	; 0x40
    957a:	f8c9 1000 	str.w	r1, [r9]
    957e:	3201      	adds	r2, #1
    9580:	4403      	add	r3, r0
    9582:	2a07      	cmp	r2, #7
    9584:	931d      	str	r3, [sp, #116]	; 0x74
    9586:	921c      	str	r2, [sp, #112]	; 0x70
    9588:	f8c9 0004 	str.w	r0, [r9, #4]
    958c:	f300 8213 	bgt.w	99b6 <_svfprintf_r+0xebe>
    9590:	f109 0908 	add.w	r9, r9, #8
    9594:	eeb5 8b40 	vcmp.f64	d8, #0.0
    9598:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    959c:	990d      	ldr	r1, [sp, #52]	; 0x34
    959e:	f000 80f5 	beq.w	978c <_svfprintf_r+0xc94>
    95a2:	3901      	subs	r1, #1
    95a4:	3201      	adds	r2, #1
    95a6:	3601      	adds	r6, #1
    95a8:	440b      	add	r3, r1
    95aa:	2a07      	cmp	r2, #7
    95ac:	f8c9 6000 	str.w	r6, [r9]
    95b0:	921c      	str	r2, [sp, #112]	; 0x70
    95b2:	931d      	str	r3, [sp, #116]	; 0x74
    95b4:	f8c9 1004 	str.w	r1, [r9, #4]
    95b8:	f300 811d 	bgt.w	97f6 <_svfprintf_r+0xcfe>
    95bc:	f109 0908 	add.w	r9, r9, #8
    95c0:	9811      	ldr	r0, [sp, #68]	; 0x44
    95c2:	f8c9 0004 	str.w	r0, [r9, #4]
    95c6:	3201      	adds	r2, #1
    95c8:	4403      	add	r3, r0
    95ca:	a917      	add	r1, sp, #92	; 0x5c
    95cc:	2a07      	cmp	r2, #7
    95ce:	931d      	str	r3, [sp, #116]	; 0x74
    95d0:	921c      	str	r2, [sp, #112]	; 0x70
    95d2:	f8c9 1000 	str.w	r1, [r9]
    95d6:	f77f ad3e 	ble.w	9056 <_svfprintf_r+0x55e>
    95da:	aa1b      	add	r2, sp, #108	; 0x6c
    95dc:	9903      	ldr	r1, [sp, #12]
    95de:	9805      	ldr	r0, [sp, #20]
    95e0:	f000 fd42 	bl	a068 <__ssprint_r>
    95e4:	2800      	cmp	r0, #0
    95e6:	f47f ab7d 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    95ea:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    95ec:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    95f0:	e533      	b.n	905a <_svfprintf_r+0x562>
    95f2:	aa1b      	add	r2, sp, #108	; 0x6c
    95f4:	9903      	ldr	r1, [sp, #12]
    95f6:	9805      	ldr	r0, [sp, #20]
    95f8:	f000 fd36 	bl	a068 <__ssprint_r>
    95fc:	2800      	cmp	r0, #0
    95fe:	f43f ad79 	beq.w	90f4 <_svfprintf_r+0x5fc>
    9602:	f7ff bb6f 	b.w	8ce4 <_svfprintf_r+0x1ec>
    9606:	9909      	ldr	r1, [sp, #36]	; 0x24
    9608:	f1b8 0f00 	cmp.w	r8, #0
    960c:	680c      	ldr	r4, [r1, #0]
    960e:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9612:	f101 0704 	add.w	r7, r1, #4
    9616:	f04f 0500 	mov.w	r5, #0
    961a:	f2c0 8371 	blt.w	9d00 <_svfprintf_r+0x1208>
    961e:	ea54 0205 	orrs.w	r2, r4, r5
    9622:	9709      	str	r7, [sp, #36]	; 0x24
    9624:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9628:	461f      	mov	r7, r3
    962a:	f47f ac0a 	bne.w	8e42 <_svfprintf_r+0x34a>
    962e:	f1b8 0f00 	cmp.w	r8, #0
    9632:	f43f aeb3 	beq.w	939c <_svfprintf_r+0x8a4>
    9636:	2400      	movs	r4, #0
    9638:	e5b6      	b.n	91a8 <_svfprintf_r+0x6b0>
    963a:	aa1b      	add	r2, sp, #108	; 0x6c
    963c:	9903      	ldr	r1, [sp, #12]
    963e:	9805      	ldr	r0, [sp, #20]
    9640:	f000 fd12 	bl	a068 <__ssprint_r>
    9644:	2800      	cmp	r0, #0
    9646:	f47f ab4d 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    964a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    964c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9650:	e4f0      	b.n	9034 <_svfprintf_r+0x53c>
    9652:	aa1b      	add	r2, sp, #108	; 0x6c
    9654:	9903      	ldr	r1, [sp, #12]
    9656:	9805      	ldr	r0, [sp, #20]
    9658:	f000 fd06 	bl	a068 <__ssprint_r>
    965c:	2800      	cmp	r0, #0
    965e:	f47f ab41 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9662:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9664:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9668:	e496      	b.n	8f98 <_svfprintf_r+0x4a0>
    966a:	aa1b      	add	r2, sp, #108	; 0x6c
    966c:	9903      	ldr	r1, [sp, #12]
    966e:	9805      	ldr	r0, [sp, #20]
    9670:	f000 fcfa 	bl	a068 <__ssprint_r>
    9674:	2800      	cmp	r0, #0
    9676:	f47f ab35 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    967a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    967c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9680:	e49a      	b.n	8fb8 <_svfprintf_r+0x4c0>
    9682:	f1b8 0f00 	cmp.w	r8, #0
    9686:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    968a:	f2c0 826f 	blt.w	9b6c <_svfprintf_r+0x1074>
    968e:	ea54 0305 	orrs.w	r3, r4, r5
    9692:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9696:	f47f adc4 	bne.w	9222 <_svfprintf_r+0x72a>
    969a:	f1b8 0f00 	cmp.w	r8, #0
    969e:	f43f ae7c 	beq.w	939a <_svfprintf_r+0x8a2>
    96a2:	2700      	movs	r7, #0
    96a4:	e6a7      	b.n	93f6 <_svfprintf_r+0x8fe>
    96a6:	9c15      	ldr	r4, [sp, #84]	; 0x54
    96a8:	2c00      	cmp	r4, #0
    96aa:	f340 8261 	ble.w	9b70 <_svfprintf_r+0x1078>
    96ae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    96b0:	990d      	ldr	r1, [sp, #52]	; 0x34
    96b2:	428a      	cmp	r2, r1
    96b4:	bfa8      	it	ge
    96b6:	460a      	movge	r2, r1
    96b8:	2a00      	cmp	r2, #0
    96ba:	4614      	mov	r4, r2
    96bc:	dd0d      	ble.n	96da <_svfprintf_r+0xbe2>
    96be:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    96c0:	f8c9 6000 	str.w	r6, [r9]
    96c4:	3201      	adds	r2, #1
    96c6:	4423      	add	r3, r4
    96c8:	2a07      	cmp	r2, #7
    96ca:	931d      	str	r3, [sp, #116]	; 0x74
    96cc:	f8c9 4004 	str.w	r4, [r9, #4]
    96d0:	921c      	str	r2, [sp, #112]	; 0x70
    96d2:	f300 8372 	bgt.w	9dba <_svfprintf_r+0x12c2>
    96d6:	f109 0908 	add.w	r9, r9, #8
    96da:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    96dc:	2c00      	cmp	r4, #0
    96de:	bfa8      	it	ge
    96e0:	1b12      	subge	r2, r2, r4
    96e2:	2a00      	cmp	r2, #0
    96e4:	4614      	mov	r4, r2
    96e6:	f340 80f1 	ble.w	98cc <_svfprintf_r+0xdd4>
    96ea:	2c10      	cmp	r4, #16
    96ec:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    96ee:	4fc1      	ldr	r7, [pc, #772]	; (99f4 <_svfprintf_r+0xefc>)
    96f0:	f340 8219 	ble.w	9b26 <_svfprintf_r+0x102e>
    96f4:	4649      	mov	r1, r9
    96f6:	2510      	movs	r5, #16
    96f8:	46b1      	mov	r9, r6
    96fa:	f8dd 8014 	ldr.w	r8, [sp, #20]
    96fe:	9e03      	ldr	r6, [sp, #12]
    9700:	e004      	b.n	970c <_svfprintf_r+0xc14>
    9702:	3108      	adds	r1, #8
    9704:	3c10      	subs	r4, #16
    9706:	2c10      	cmp	r4, #16
    9708:	f340 820b 	ble.w	9b22 <_svfprintf_r+0x102a>
    970c:	3201      	adds	r2, #1
    970e:	3310      	adds	r3, #16
    9710:	2a07      	cmp	r2, #7
    9712:	931d      	str	r3, [sp, #116]	; 0x74
    9714:	921c      	str	r2, [sp, #112]	; 0x70
    9716:	600f      	str	r7, [r1, #0]
    9718:	604d      	str	r5, [r1, #4]
    971a:	ddf2      	ble.n	9702 <_svfprintf_r+0xc0a>
    971c:	aa1b      	add	r2, sp, #108	; 0x6c
    971e:	4631      	mov	r1, r6
    9720:	4640      	mov	r0, r8
    9722:	f000 fca1 	bl	a068 <__ssprint_r>
    9726:	2800      	cmp	r0, #0
    9728:	f47f aadc 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    972c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    972e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9730:	a928      	add	r1, sp, #160	; 0xa0
    9732:	e7e7      	b.n	9704 <_svfprintf_r+0xc0c>
    9734:	aa1b      	add	r2, sp, #108	; 0x6c
    9736:	9903      	ldr	r1, [sp, #12]
    9738:	9805      	ldr	r0, [sp, #20]
    973a:	f000 fc95 	bl	a068 <__ssprint_r>
    973e:	2800      	cmp	r0, #0
    9740:	f47f aad0 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9744:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9748:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    974a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    974e:	e413      	b.n	8f78 <_svfprintf_r+0x480>
    9750:	f01b 0210 	ands.w	r2, fp, #16
    9754:	f47f af57 	bne.w	9606 <_svfprintf_r+0xb0e>
    9758:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    975c:	f43f af53 	beq.w	9606 <_svfprintf_r+0xb0e>
    9760:	9909      	ldr	r1, [sp, #36]	; 0x24
    9762:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    9766:	460b      	mov	r3, r1
    9768:	f1b8 0f00 	cmp.w	r8, #0
    976c:	f103 0304 	add.w	r3, r3, #4
    9770:	880c      	ldrh	r4, [r1, #0]
    9772:	f04f 0500 	mov.w	r5, #0
    9776:	f2c0 8294 	blt.w	9ca2 <_svfprintf_r+0x11aa>
    977a:	ea54 0105 	orrs.w	r1, r4, r5
    977e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9782:	9309      	str	r3, [sp, #36]	; 0x24
    9784:	4617      	mov	r7, r2
    9786:	f47f ab5c 	bne.w	8e42 <_svfprintf_r+0x34a>
    978a:	e750      	b.n	962e <_svfprintf_r+0xb36>
    978c:	1e4c      	subs	r4, r1, #1
    978e:	2c00      	cmp	r4, #0
    9790:	f77f af16 	ble.w	95c0 <_svfprintf_r+0xac8>
    9794:	2c10      	cmp	r4, #16
    9796:	4f97      	ldr	r7, [pc, #604]	; (99f4 <_svfprintf_r+0xefc>)
    9798:	dd22      	ble.n	97e0 <_svfprintf_r+0xce8>
    979a:	2510      	movs	r5, #16
    979c:	9e05      	ldr	r6, [sp, #20]
    979e:	f8dd 800c 	ldr.w	r8, [sp, #12]
    97a2:	e004      	b.n	97ae <_svfprintf_r+0xcb6>
    97a4:	3c10      	subs	r4, #16
    97a6:	2c10      	cmp	r4, #16
    97a8:	f109 0908 	add.w	r9, r9, #8
    97ac:	dd18      	ble.n	97e0 <_svfprintf_r+0xce8>
    97ae:	3201      	adds	r2, #1
    97b0:	3310      	adds	r3, #16
    97b2:	2a07      	cmp	r2, #7
    97b4:	931d      	str	r3, [sp, #116]	; 0x74
    97b6:	921c      	str	r2, [sp, #112]	; 0x70
    97b8:	f8c9 7000 	str.w	r7, [r9]
    97bc:	f8c9 5004 	str.w	r5, [r9, #4]
    97c0:	ddf0      	ble.n	97a4 <_svfprintf_r+0xcac>
    97c2:	aa1b      	add	r2, sp, #108	; 0x6c
    97c4:	4641      	mov	r1, r8
    97c6:	4630      	mov	r0, r6
    97c8:	f000 fc4e 	bl	a068 <__ssprint_r>
    97cc:	2800      	cmp	r0, #0
    97ce:	f47f aa89 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    97d2:	3c10      	subs	r4, #16
    97d4:	2c10      	cmp	r4, #16
    97d6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    97d8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    97da:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    97de:	dce6      	bgt.n	97ae <_svfprintf_r+0xcb6>
    97e0:	3201      	adds	r2, #1
    97e2:	4423      	add	r3, r4
    97e4:	2a07      	cmp	r2, #7
    97e6:	931d      	str	r3, [sp, #116]	; 0x74
    97e8:	921c      	str	r2, [sp, #112]	; 0x70
    97ea:	f8c9 7000 	str.w	r7, [r9]
    97ee:	f8c9 4004 	str.w	r4, [r9, #4]
    97f2:	f77f aee3 	ble.w	95bc <_svfprintf_r+0xac4>
    97f6:	aa1b      	add	r2, sp, #108	; 0x6c
    97f8:	9903      	ldr	r1, [sp, #12]
    97fa:	9805      	ldr	r0, [sp, #20]
    97fc:	f000 fc34 	bl	a068 <__ssprint_r>
    9800:	2800      	cmp	r0, #0
    9802:	f47f aa6f 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9806:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9808:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    980a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    980e:	e6d7      	b.n	95c0 <_svfprintf_r+0xac8>
    9810:	f01b 0f10 	tst.w	fp, #16
    9814:	d133      	bne.n	987e <_svfprintf_r+0xd86>
    9816:	f01b 0f40 	tst.w	fp, #64	; 0x40
    981a:	d030      	beq.n	987e <_svfprintf_r+0xd86>
    981c:	9909      	ldr	r1, [sp, #36]	; 0x24
    981e:	f9b1 4000 	ldrsh.w	r4, [r1]
    9822:	3104      	adds	r1, #4
    9824:	17e5      	asrs	r5, r4, #31
    9826:	4622      	mov	r2, r4
    9828:	462b      	mov	r3, r5
    982a:	9109      	str	r1, [sp, #36]	; 0x24
    982c:	f7ff baf8 	b.w	8e20 <_svfprintf_r+0x328>
    9830:	3201      	adds	r2, #1
    9832:	4423      	add	r3, r4
    9834:	2a07      	cmp	r2, #7
    9836:	931d      	str	r3, [sp, #116]	; 0x74
    9838:	921c      	str	r2, [sp, #112]	; 0x70
    983a:	f8c9 7000 	str.w	r7, [r9]
    983e:	f8c9 4004 	str.w	r4, [r9, #4]
    9842:	f77f ac08 	ble.w	9056 <_svfprintf_r+0x55e>
    9846:	e6c8      	b.n	95da <_svfprintf_r+0xae2>
    9848:	9909      	ldr	r1, [sp, #36]	; 0x24
    984a:	f1b8 0f00 	cmp.w	r8, #0
    984e:	680c      	ldr	r4, [r1, #0]
    9850:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9854:	f101 0704 	add.w	r7, r1, #4
    9858:	f04f 0500 	mov.w	r5, #0
    985c:	f2c0 80c5 	blt.w	99ea <_svfprintf_r+0xef2>
    9860:	ea54 0205 	orrs.w	r2, r4, r5
    9864:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9868:	9709      	str	r7, [sp, #36]	; 0x24
    986a:	f43f adb2 	beq.w	93d2 <_svfprintf_r+0x8da>
    986e:	461f      	mov	r7, r3
    9870:	f7ff ba64 	b.w	8d3c <_svfprintf_r+0x244>
    9874:	681c      	ldr	r4, [r3, #0]
    9876:	3304      	adds	r3, #4
    9878:	9309      	str	r3, [sp, #36]	; 0x24
    987a:	2500      	movs	r5, #0
    987c:	e4b6      	b.n	91ec <_svfprintf_r+0x6f4>
    987e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9880:	6814      	ldr	r4, [r2, #0]
    9882:	4613      	mov	r3, r2
    9884:	3304      	adds	r3, #4
    9886:	17e5      	asrs	r5, r4, #31
    9888:	4622      	mov	r2, r4
    988a:	9309      	str	r3, [sp, #36]	; 0x24
    988c:	2a00      	cmp	r2, #0
    988e:	462b      	mov	r3, r5
    9890:	f173 0300 	sbcs.w	r3, r3, #0
    9894:	f6bf aac9 	bge.w	8e2a <_svfprintf_r+0x332>
    9898:	4264      	negs	r4, r4
    989a:	f04f 072d 	mov.w	r7, #45	; 0x2d
    989e:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
    98a2:	f1b8 0f00 	cmp.w	r8, #0
    98a6:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    98aa:	f6ff aaca 	blt.w	8e42 <_svfprintf_r+0x34a>
    98ae:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    98b2:	f7ff bac6 	b.w	8e42 <_svfprintf_r+0x34a>
    98b6:	aa1b      	add	r2, sp, #108	; 0x6c
    98b8:	9903      	ldr	r1, [sp, #12]
    98ba:	9805      	ldr	r0, [sp, #20]
    98bc:	f000 fbd4 	bl	a068 <__ssprint_r>
    98c0:	2800      	cmp	r0, #0
    98c2:	f47f aa0f 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    98c6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    98c8:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    98cc:	990e      	ldr	r1, [sp, #56]	; 0x38
    98ce:	9a15      	ldr	r2, [sp, #84]	; 0x54
    98d0:	4431      	add	r1, r6
    98d2:	460d      	mov	r5, r1
    98d4:	990d      	ldr	r1, [sp, #52]	; 0x34
    98d6:	428a      	cmp	r2, r1
    98d8:	db47      	blt.n	996a <_svfprintf_r+0xe72>
    98da:	f01b 0f01 	tst.w	fp, #1
    98de:	d144      	bne.n	996a <_svfprintf_r+0xe72>
    98e0:	980d      	ldr	r0, [sp, #52]	; 0x34
    98e2:	4406      	add	r6, r0
    98e4:	1b74      	subs	r4, r6, r5
    98e6:	1a82      	subs	r2, r0, r2
    98e8:	4294      	cmp	r4, r2
    98ea:	bfa8      	it	ge
    98ec:	4614      	movge	r4, r2
    98ee:	2c00      	cmp	r4, #0
    98f0:	4626      	mov	r6, r4
    98f2:	dd0d      	ble.n	9910 <_svfprintf_r+0xe18>
    98f4:	991c      	ldr	r1, [sp, #112]	; 0x70
    98f6:	f8c9 5000 	str.w	r5, [r9]
    98fa:	3101      	adds	r1, #1
    98fc:	4423      	add	r3, r4
    98fe:	2907      	cmp	r1, #7
    9900:	931d      	str	r3, [sp, #116]	; 0x74
    9902:	f8c9 4004 	str.w	r4, [r9, #4]
    9906:	911c      	str	r1, [sp, #112]	; 0x70
    9908:	f300 8280 	bgt.w	9e0c <_svfprintf_r+0x1314>
    990c:	f109 0908 	add.w	r9, r9, #8
    9910:	2e00      	cmp	r6, #0
    9912:	bfac      	ite	ge
    9914:	1b94      	subge	r4, r2, r6
    9916:	4614      	movlt	r4, r2
    9918:	2c00      	cmp	r4, #0
    991a:	f77f ab9e 	ble.w	905a <_svfprintf_r+0x562>
    991e:	2c10      	cmp	r4, #16
    9920:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9922:	4f34      	ldr	r7, [pc, #208]	; (99f4 <_svfprintf_r+0xefc>)
    9924:	dd84      	ble.n	9830 <_svfprintf_r+0xd38>
    9926:	2510      	movs	r5, #16
    9928:	9e05      	ldr	r6, [sp, #20]
    992a:	f8dd 800c 	ldr.w	r8, [sp, #12]
    992e:	e005      	b.n	993c <_svfprintf_r+0xe44>
    9930:	f109 0908 	add.w	r9, r9, #8
    9934:	3c10      	subs	r4, #16
    9936:	2c10      	cmp	r4, #16
    9938:	f77f af7a 	ble.w	9830 <_svfprintf_r+0xd38>
    993c:	3201      	adds	r2, #1
    993e:	3310      	adds	r3, #16
    9940:	2a07      	cmp	r2, #7
    9942:	931d      	str	r3, [sp, #116]	; 0x74
    9944:	921c      	str	r2, [sp, #112]	; 0x70
    9946:	f8c9 7000 	str.w	r7, [r9]
    994a:	f8c9 5004 	str.w	r5, [r9, #4]
    994e:	ddef      	ble.n	9930 <_svfprintf_r+0xe38>
    9950:	aa1b      	add	r2, sp, #108	; 0x6c
    9952:	4641      	mov	r1, r8
    9954:	4630      	mov	r0, r6
    9956:	f000 fb87 	bl	a068 <__ssprint_r>
    995a:	2800      	cmp	r0, #0
    995c:	f47f a9c2 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9960:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9962:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9964:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9968:	e7e4      	b.n	9934 <_svfprintf_r+0xe3c>
    996a:	991c      	ldr	r1, [sp, #112]	; 0x70
    996c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    996e:	9810      	ldr	r0, [sp, #64]	; 0x40
    9970:	f8c9 0000 	str.w	r0, [r9]
    9974:	3101      	adds	r1, #1
    9976:	4423      	add	r3, r4
    9978:	2907      	cmp	r1, #7
    997a:	931d      	str	r3, [sp, #116]	; 0x74
    997c:	f8c9 4004 	str.w	r4, [r9, #4]
    9980:	911c      	str	r1, [sp, #112]	; 0x70
    9982:	f300 8226 	bgt.w	9dd2 <_svfprintf_r+0x12da>
    9986:	f109 0908 	add.w	r9, r9, #8
    998a:	e7a9      	b.n	98e0 <_svfprintf_r+0xde8>
    998c:	f01b 0f01 	tst.w	fp, #1
    9990:	f47f adec 	bne.w	956c <_svfprintf_r+0xa74>
    9994:	2a07      	cmp	r2, #7
    9996:	f77f ae11 	ble.w	95bc <_svfprintf_r+0xac4>
    999a:	e72c      	b.n	97f6 <_svfprintf_r+0xcfe>
    999c:	aa1b      	add	r2, sp, #108	; 0x6c
    999e:	9903      	ldr	r1, [sp, #12]
    99a0:	9805      	ldr	r0, [sp, #20]
    99a2:	f000 fb61 	bl	a068 <__ssprint_r>
    99a6:	2800      	cmp	r0, #0
    99a8:	f47f a99c 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    99ac:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    99ae:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    99b0:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    99b4:	e5df      	b.n	9576 <_svfprintf_r+0xa7e>
    99b6:	aa1b      	add	r2, sp, #108	; 0x6c
    99b8:	9903      	ldr	r1, [sp, #12]
    99ba:	9805      	ldr	r0, [sp, #20]
    99bc:	f000 fb54 	bl	a068 <__ssprint_r>
    99c0:	2800      	cmp	r0, #0
    99c2:	f47f a98f 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    99c6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    99c8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    99ca:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    99ce:	e5e1      	b.n	9594 <_svfprintf_r+0xa9c>
    99d0:	aa1b      	add	r2, sp, #108	; 0x6c
    99d2:	9903      	ldr	r1, [sp, #12]
    99d4:	9805      	ldr	r0, [sp, #20]
    99d6:	f000 fb47 	bl	a068 <__ssprint_r>
    99da:	2800      	cmp	r0, #0
    99dc:	f47f a982 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    99e0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    99e2:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    99e6:	f7ff baeb 	b.w	8fc0 <_svfprintf_r+0x4c8>
    99ea:	9709      	str	r7, [sp, #36]	; 0x24
    99ec:	2700      	movs	r7, #0
    99ee:	f7ff b9a5 	b.w	8d3c <_svfprintf_r+0x244>
    99f2:	bf00      	nop
    99f4:	20000fec 	.word	0x20000fec
    99f8:	f01b 0f10 	tst.w	fp, #16
    99fc:	d10b      	bne.n	9a16 <_svfprintf_r+0xf1e>
    99fe:	f01b 0f40 	tst.w	fp, #64	; 0x40
    9a02:	d008      	beq.n	9a16 <_svfprintf_r+0xf1e>
    9a04:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9a06:	6813      	ldr	r3, [r2, #0]
    9a08:	3204      	adds	r2, #4
    9a0a:	9209      	str	r2, [sp, #36]	; 0x24
    9a0c:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    9a10:	801a      	strh	r2, [r3, #0]
    9a12:	f7ff b897 	b.w	8b44 <_svfprintf_r+0x4c>
    9a16:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9a18:	6813      	ldr	r3, [r2, #0]
    9a1a:	3204      	adds	r2, #4
    9a1c:	9209      	str	r2, [sp, #36]	; 0x24
    9a1e:	9a06      	ldr	r2, [sp, #24]
    9a20:	601a      	str	r2, [r3, #0]
    9a22:	f7ff b88f 	b.w	8b44 <_svfprintf_r+0x4c>
    9a26:	eeb4 8b48 	vcmp.f64	d8, d8
    9a2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9a2e:	f180 829e 	bvs.w	9f6e <_svfprintf_r+0x1476>
    9a32:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9a34:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    9a38:	f023 0520 	bic.w	r5, r3, #32
    9a3c:	f000 8225 	beq.w	9e8a <_svfprintf_r+0x1392>
    9a40:	2d47      	cmp	r5, #71	; 0x47
    9a42:	f000 8126 	beq.w	9c92 <_svfprintf_r+0x119a>
    9a46:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
    9a4a:	930a      	str	r3, [sp, #40]	; 0x28
    9a4c:	ee18 3a90 	vmov	r3, s17
    9a50:	2b00      	cmp	r3, #0
    9a52:	f2c0 821d 	blt.w	9e90 <_svfprintf_r+0x1398>
    9a56:	eeb0 ab48 	vmov.f64	d10, d8
    9a5a:	2700      	movs	r7, #0
    9a5c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9a5e:	2b66      	cmp	r3, #102	; 0x66
    9a60:	f000 8202 	beq.w	9e68 <_svfprintf_r+0x1370>
    9a64:	2b46      	cmp	r3, #70	; 0x46
    9a66:	f000 80ec 	beq.w	9c42 <_svfprintf_r+0x114a>
    9a6a:	eeb0 0b4a 	vmov.f64	d0, d10
    9a6e:	2d45      	cmp	r5, #69	; 0x45
    9a70:	bf0c      	ite	eq
    9a72:	f108 0401 	addeq.w	r4, r8, #1
    9a76:	4644      	movne	r4, r8
    9a78:	aa19      	add	r2, sp, #100	; 0x64
    9a7a:	ab16      	add	r3, sp, #88	; 0x58
    9a7c:	9201      	str	r2, [sp, #4]
    9a7e:	9300      	str	r3, [sp, #0]
    9a80:	4622      	mov	r2, r4
    9a82:	ab15      	add	r3, sp, #84	; 0x54
    9a84:	2102      	movs	r1, #2
    9a86:	9805      	ldr	r0, [sp, #20]
    9a88:	f7fe f9f2 	bl	7e70 <_dtoa_r>
    9a8c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9a8e:	2b67      	cmp	r3, #103	; 0x67
    9a90:	4606      	mov	r6, r0
    9a92:	f040 820e 	bne.w	9eb2 <_svfprintf_r+0x13ba>
    9a96:	f01b 0f01 	tst.w	fp, #1
    9a9a:	f000 8266 	beq.w	9f6a <_svfprintf_r+0x1472>
    9a9e:	1931      	adds	r1, r6, r4
    9aa0:	eeb5 ab40 	vcmp.f64	d10, #0.0
    9aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9aa8:	f000 8185 	beq.w	9db6 <_svfprintf_r+0x12be>
    9aac:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9aae:	4299      	cmp	r1, r3
    9ab0:	d906      	bls.n	9ac0 <_svfprintf_r+0xfc8>
    9ab2:	2030      	movs	r0, #48	; 0x30
    9ab4:	1c5a      	adds	r2, r3, #1
    9ab6:	9219      	str	r2, [sp, #100]	; 0x64
    9ab8:	7018      	strb	r0, [r3, #0]
    9aba:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9abc:	4299      	cmp	r1, r3
    9abe:	d8f9      	bhi.n	9ab4 <_svfprintf_r+0xfbc>
    9ac0:	1b9b      	subs	r3, r3, r6
    9ac2:	2d47      	cmp	r5, #71	; 0x47
    9ac4:	930d      	str	r3, [sp, #52]	; 0x34
    9ac6:	f000 811f 	beq.w	9d08 <_svfprintf_r+0x1210>
    9aca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9acc:	2b65      	cmp	r3, #101	; 0x65
    9ace:	f340 81ff 	ble.w	9ed0 <_svfprintf_r+0x13d8>
    9ad2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9ad4:	2b66      	cmp	r3, #102	; 0x66
    9ad6:	9b15      	ldr	r3, [sp, #84]	; 0x54
    9ad8:	f000 81fc 	beq.w	9ed4 <_svfprintf_r+0x13dc>
    9adc:	930e      	str	r3, [sp, #56]	; 0x38
    9ade:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    9ae0:	990d      	ldr	r1, [sp, #52]	; 0x34
    9ae2:	428a      	cmp	r2, r1
    9ae4:	f2c0 81d8 	blt.w	9e98 <_svfprintf_r+0x13a0>
    9ae8:	f01b 0f01 	tst.w	fp, #1
    9aec:	f040 8234 	bne.w	9f58 <_svfprintf_r+0x1460>
    9af0:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    9af4:	9208      	str	r2, [sp, #32]
    9af6:	2267      	movs	r2, #103	; 0x67
    9af8:	920c      	str	r2, [sp, #48]	; 0x30
    9afa:	2f00      	cmp	r7, #0
    9afc:	f040 80f6 	bne.w	9cec <_svfprintf_r+0x11f4>
    9b00:	46b8      	mov	r8, r7
    9b02:	9304      	str	r3, [sp, #16]
    9b04:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    9b08:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9b0c:	f7ff b9e6 	b.w	8edc <_svfprintf_r+0x3e4>
    9b10:	f027 0707 	bic.w	r7, r7, #7
    9b14:	f107 0308 	add.w	r3, r7, #8
    9b18:	ed97 8b00 	vldr	d8, [r7]
    9b1c:	9309      	str	r3, [sp, #36]	; 0x24
    9b1e:	f7ff b9be 	b.w	8e9e <_svfprintf_r+0x3a6>
    9b22:	464e      	mov	r6, r9
    9b24:	4689      	mov	r9, r1
    9b26:	3201      	adds	r2, #1
    9b28:	4423      	add	r3, r4
    9b2a:	2a07      	cmp	r2, #7
    9b2c:	931d      	str	r3, [sp, #116]	; 0x74
    9b2e:	921c      	str	r2, [sp, #112]	; 0x70
    9b30:	f8c9 7000 	str.w	r7, [r9]
    9b34:	f8c9 4004 	str.w	r4, [r9, #4]
    9b38:	f73f aebd 	bgt.w	98b6 <_svfprintf_r+0xdbe>
    9b3c:	f109 0908 	add.w	r9, r9, #8
    9b40:	e6c4      	b.n	98cc <_svfprintf_r+0xdd4>
    9b42:	2700      	movs	r7, #0
    9b44:	45b8      	cmp	r8, r7
    9b46:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9b4a:	f6ff ac54 	blt.w	93f6 <_svfprintf_r+0x8fe>
    9b4e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9b52:	e41e      	b.n	9392 <_svfprintf_r+0x89a>
    9b54:	aa1b      	add	r2, sp, #108	; 0x6c
    9b56:	9903      	ldr	r1, [sp, #12]
    9b58:	9805      	ldr	r0, [sp, #20]
    9b5a:	f000 fa85 	bl	a068 <__ssprint_r>
    9b5e:	2800      	cmp	r0, #0
    9b60:	f47f a8c0 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9b64:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9b66:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9b6a:	e463      	b.n	9434 <_svfprintf_r+0x93c>
    9b6c:	9f09      	ldr	r7, [sp, #36]	; 0x24
    9b6e:	e43b      	b.n	93e8 <_svfprintf_r+0x8f0>
    9b70:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9b72:	49b9      	ldr	r1, [pc, #740]	; (9e58 <_svfprintf_r+0x1360>)
    9b74:	f8c9 1000 	str.w	r1, [r9]
    9b78:	3201      	adds	r2, #1
    9b7a:	3301      	adds	r3, #1
    9b7c:	2101      	movs	r1, #1
    9b7e:	2a07      	cmp	r2, #7
    9b80:	931d      	str	r3, [sp, #116]	; 0x74
    9b82:	921c      	str	r2, [sp, #112]	; 0x70
    9b84:	f8c9 1004 	str.w	r1, [r9, #4]
    9b88:	dc76      	bgt.n	9c78 <_svfprintf_r+0x1180>
    9b8a:	f109 0908 	add.w	r9, r9, #8
    9b8e:	b92c      	cbnz	r4, 9b9c <_svfprintf_r+0x10a4>
    9b90:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9b92:	b91a      	cbnz	r2, 9b9c <_svfprintf_r+0x10a4>
    9b94:	f01b 0f01 	tst.w	fp, #1
    9b98:	f43f aa5f 	beq.w	905a <_svfprintf_r+0x562>
    9b9c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9b9e:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9ba0:	9910      	ldr	r1, [sp, #64]	; 0x40
    9ba2:	f8c9 1000 	str.w	r1, [r9]
    9ba6:	3201      	adds	r2, #1
    9ba8:	4403      	add	r3, r0
    9baa:	2a07      	cmp	r2, #7
    9bac:	931d      	str	r3, [sp, #116]	; 0x74
    9bae:	f8c9 0004 	str.w	r0, [r9, #4]
    9bb2:	921c      	str	r2, [sp, #112]	; 0x70
    9bb4:	f300 81b6 	bgt.w	9f24 <_svfprintf_r+0x142c>
    9bb8:	f109 0908 	add.w	r9, r9, #8
    9bbc:	4264      	negs	r4, r4
    9bbe:	2c00      	cmp	r4, #0
    9bc0:	f340 8087 	ble.w	9cd2 <_svfprintf_r+0x11da>
    9bc4:	2c10      	cmp	r4, #16
    9bc6:	4fa5      	ldr	r7, [pc, #660]	; (9e5c <_svfprintf_r+0x1364>)
    9bc8:	f340 8112 	ble.w	9df0 <_svfprintf_r+0x12f8>
    9bcc:	4649      	mov	r1, r9
    9bce:	2510      	movs	r5, #16
    9bd0:	46b1      	mov	r9, r6
    9bd2:	f8dd 8014 	ldr.w	r8, [sp, #20]
    9bd6:	9e03      	ldr	r6, [sp, #12]
    9bd8:	e004      	b.n	9be4 <_svfprintf_r+0x10ec>
    9bda:	3108      	adds	r1, #8
    9bdc:	3c10      	subs	r4, #16
    9bde:	2c10      	cmp	r4, #16
    9be0:	f340 8104 	ble.w	9dec <_svfprintf_r+0x12f4>
    9be4:	3201      	adds	r2, #1
    9be6:	3310      	adds	r3, #16
    9be8:	2a07      	cmp	r2, #7
    9bea:	931d      	str	r3, [sp, #116]	; 0x74
    9bec:	921c      	str	r2, [sp, #112]	; 0x70
    9bee:	600f      	str	r7, [r1, #0]
    9bf0:	604d      	str	r5, [r1, #4]
    9bf2:	ddf2      	ble.n	9bda <_svfprintf_r+0x10e2>
    9bf4:	aa1b      	add	r2, sp, #108	; 0x6c
    9bf6:	4631      	mov	r1, r6
    9bf8:	4640      	mov	r0, r8
    9bfa:	f000 fa35 	bl	a068 <__ssprint_r>
    9bfe:	2800      	cmp	r0, #0
    9c00:	f47f a870 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9c04:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9c06:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9c08:	a928      	add	r1, sp, #160	; 0xa0
    9c0a:	e7e7      	b.n	9bdc <_svfprintf_r+0x10e4>
    9c0c:	aa1b      	add	r2, sp, #108	; 0x6c
    9c0e:	9903      	ldr	r1, [sp, #12]
    9c10:	9805      	ldr	r0, [sp, #20]
    9c12:	f000 fa29 	bl	a068 <__ssprint_r>
    9c16:	2800      	cmp	r0, #0
    9c18:	f47f a864 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9c1c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9c1e:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9c22:	e41f      	b.n	9464 <_svfprintf_r+0x96c>
    9c24:	2140      	movs	r1, #64	; 0x40
    9c26:	9805      	ldr	r0, [sp, #20]
    9c28:	f7fc f9cc 	bl	5fc4 <_malloc_r>
    9c2c:	9a03      	ldr	r2, [sp, #12]
    9c2e:	6010      	str	r0, [r2, #0]
    9c30:	6110      	str	r0, [r2, #16]
    9c32:	2800      	cmp	r0, #0
    9c34:	f000 81ed 	beq.w	a012 <_svfprintf_r+0x151a>
    9c38:	9a03      	ldr	r2, [sp, #12]
    9c3a:	2340      	movs	r3, #64	; 0x40
    9c3c:	6153      	str	r3, [r2, #20]
    9c3e:	f7fe bf74 	b.w	8b2a <_svfprintf_r+0x32>
    9c42:	aa19      	add	r2, sp, #100	; 0x64
    9c44:	ab16      	add	r3, sp, #88	; 0x58
    9c46:	9201      	str	r2, [sp, #4]
    9c48:	9300      	str	r3, [sp, #0]
    9c4a:	4642      	mov	r2, r8
    9c4c:	ab15      	add	r3, sp, #84	; 0x54
    9c4e:	2103      	movs	r1, #3
    9c50:	eeb0 0b4a 	vmov.f64	d0, d10
    9c54:	9805      	ldr	r0, [sp, #20]
    9c56:	f7fe f90b 	bl	7e70 <_dtoa_r>
    9c5a:	4644      	mov	r4, r8
    9c5c:	4606      	mov	r6, r0
    9c5e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9c60:	2b46      	cmp	r3, #70	; 0x46
    9c62:	eb06 0104 	add.w	r1, r6, r4
    9c66:	f47f af1b 	bne.w	9aa0 <_svfprintf_r+0xfa8>
    9c6a:	7833      	ldrb	r3, [r6, #0]
    9c6c:	2b30      	cmp	r3, #48	; 0x30
    9c6e:	f000 818d 	beq.w	9f8c <_svfprintf_r+0x1494>
    9c72:	9c15      	ldr	r4, [sp, #84]	; 0x54
    9c74:	4421      	add	r1, r4
    9c76:	e713      	b.n	9aa0 <_svfprintf_r+0xfa8>
    9c78:	aa1b      	add	r2, sp, #108	; 0x6c
    9c7a:	9903      	ldr	r1, [sp, #12]
    9c7c:	9805      	ldr	r0, [sp, #20]
    9c7e:	f000 f9f3 	bl	a068 <__ssprint_r>
    9c82:	2800      	cmp	r0, #0
    9c84:	f47f a82e 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9c88:	9c15      	ldr	r4, [sp, #84]	; 0x54
    9c8a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9c8c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9c90:	e77d      	b.n	9b8e <_svfprintf_r+0x1096>
    9c92:	f1b8 0f00 	cmp.w	r8, #0
    9c96:	bf08      	it	eq
    9c98:	f04f 0801 	moveq.w	r8, #1
    9c9c:	e6d3      	b.n	9a46 <_svfprintf_r+0xf4e>
    9c9e:	9309      	str	r3, [sp, #36]	; 0x24
    9ca0:	e6a4      	b.n	99ec <_svfprintf_r+0xef4>
    9ca2:	9309      	str	r3, [sp, #36]	; 0x24
    9ca4:	4617      	mov	r7, r2
    9ca6:	f7ff ba7b 	b.w	91a0 <_svfprintf_r+0x6a8>
    9caa:	4630      	mov	r0, r6
    9cac:	f7fd f988 	bl	6fc0 <strlen>
    9cb0:	46a0      	mov	r8, r4
    9cb2:	4603      	mov	r3, r0
    9cb4:	9008      	str	r0, [sp, #32]
    9cb6:	f7ff bb61 	b.w	937c <_svfprintf_r+0x884>
    9cba:	aa1b      	add	r2, sp, #108	; 0x6c
    9cbc:	9903      	ldr	r1, [sp, #12]
    9cbe:	9805      	ldr	r0, [sp, #20]
    9cc0:	f000 f9d2 	bl	a068 <__ssprint_r>
    9cc4:	2800      	cmp	r0, #0
    9cc6:	f47f a80d 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9cca:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9ccc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9cce:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9cd2:	980d      	ldr	r0, [sp, #52]	; 0x34
    9cd4:	f8c9 6000 	str.w	r6, [r9]
    9cd8:	3201      	adds	r2, #1
    9cda:	4403      	add	r3, r0
    9cdc:	2a07      	cmp	r2, #7
    9cde:	931d      	str	r3, [sp, #116]	; 0x74
    9ce0:	921c      	str	r2, [sp, #112]	; 0x70
    9ce2:	f8c9 0004 	str.w	r0, [r9, #4]
    9ce6:	f77f a9b6 	ble.w	9056 <_svfprintf_r+0x55e>
    9cea:	e476      	b.n	95da <_svfprintf_r+0xae2>
    9cec:	272d      	movs	r7, #45	; 0x2d
    9cee:	9304      	str	r3, [sp, #16]
    9cf0:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    9cf4:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9cf8:	f04f 0800 	mov.w	r8, #0
    9cfc:	f7ff b8ef 	b.w	8ede <_svfprintf_r+0x3e6>
    9d00:	9709      	str	r7, [sp, #36]	; 0x24
    9d02:	461f      	mov	r7, r3
    9d04:	f7ff ba4c 	b.w	91a0 <_svfprintf_r+0x6a8>
    9d08:	9b15      	ldr	r3, [sp, #84]	; 0x54
    9d0a:	1cda      	adds	r2, r3, #3
    9d0c:	db02      	blt.n	9d14 <_svfprintf_r+0x121c>
    9d0e:	4598      	cmp	r8, r3
    9d10:	f6bf aee4 	bge.w	9adc <_svfprintf_r+0xfe4>
    9d14:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9d16:	3a02      	subs	r2, #2
    9d18:	920c      	str	r2, [sp, #48]	; 0x30
    9d1a:	3b01      	subs	r3, #1
    9d1c:	2b00      	cmp	r3, #0
    9d1e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    9d22:	9315      	str	r3, [sp, #84]	; 0x54
    9d24:	bfb8      	it	lt
    9d26:	425b      	neglt	r3, r3
    9d28:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
    9d2c:	bfb4      	ite	lt
    9d2e:	222d      	movlt	r2, #45	; 0x2d
    9d30:	222b      	movge	r2, #43	; 0x2b
    9d32:	2b09      	cmp	r3, #9
    9d34:	f88d 205d 	strb.w	r2, [sp, #93]	; 0x5d
    9d38:	f340 8106 	ble.w	9f48 <_svfprintf_r+0x1450>
    9d3c:	f10d 006b 	add.w	r0, sp, #107	; 0x6b
    9d40:	4604      	mov	r4, r0
    9d42:	4a47      	ldr	r2, [pc, #284]	; (9e60 <_svfprintf_r+0x1368>)
    9d44:	fb82 2103 	smull	r2, r1, r2, r3
    9d48:	17da      	asrs	r2, r3, #31
    9d4a:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
    9d4e:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    9d52:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
    9d56:	f103 0130 	add.w	r1, r3, #48	; 0x30
    9d5a:	2a09      	cmp	r2, #9
    9d5c:	4613      	mov	r3, r2
    9d5e:	f804 1d01 	strb.w	r1, [r4, #-1]!
    9d62:	dcee      	bgt.n	9d42 <_svfprintf_r+0x124a>
    9d64:	4621      	mov	r1, r4
    9d66:	3330      	adds	r3, #48	; 0x30
    9d68:	b2da      	uxtb	r2, r3
    9d6a:	f801 2d01 	strb.w	r2, [r1, #-1]!
    9d6e:	4288      	cmp	r0, r1
    9d70:	f240 8162 	bls.w	a038 <_svfprintf_r+0x1540>
    9d74:	f10d 015e 	add.w	r1, sp, #94	; 0x5e
    9d78:	4623      	mov	r3, r4
    9d7a:	e001      	b.n	9d80 <_svfprintf_r+0x1288>
    9d7c:	f813 2b01 	ldrb.w	r2, [r3], #1
    9d80:	f801 2b01 	strb.w	r2, [r1], #1
    9d84:	4298      	cmp	r0, r3
    9d86:	d1f9      	bne.n	9d7c <_svfprintf_r+0x1284>
    9d88:	1c43      	adds	r3, r0, #1
    9d8a:	1b1b      	subs	r3, r3, r4
    9d8c:	f10d 025e 	add.w	r2, sp, #94	; 0x5e
    9d90:	4413      	add	r3, r2
    9d92:	aa17      	add	r2, sp, #92	; 0x5c
    9d94:	1a9b      	subs	r3, r3, r2
    9d96:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9d98:	9311      	str	r3, [sp, #68]	; 0x44
    9d9a:	2a01      	cmp	r2, #1
    9d9c:	4413      	add	r3, r2
    9d9e:	9308      	str	r3, [sp, #32]
    9da0:	f340 80ff 	ble.w	9fa2 <_svfprintf_r+0x14aa>
    9da4:	9b08      	ldr	r3, [sp, #32]
    9da6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9da8:	4413      	add	r3, r2
    9daa:	2200      	movs	r2, #0
    9dac:	9308      	str	r3, [sp, #32]
    9dae:	920e      	str	r2, [sp, #56]	; 0x38
    9db0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9db4:	e6a1      	b.n	9afa <_svfprintf_r+0x1002>
    9db6:	460b      	mov	r3, r1
    9db8:	e682      	b.n	9ac0 <_svfprintf_r+0xfc8>
    9dba:	aa1b      	add	r2, sp, #108	; 0x6c
    9dbc:	9903      	ldr	r1, [sp, #12]
    9dbe:	9805      	ldr	r0, [sp, #20]
    9dc0:	f000 f952 	bl	a068 <__ssprint_r>
    9dc4:	2800      	cmp	r0, #0
    9dc6:	f47e af8d 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9dca:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9dcc:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9dd0:	e483      	b.n	96da <_svfprintf_r+0xbe2>
    9dd2:	aa1b      	add	r2, sp, #108	; 0x6c
    9dd4:	9903      	ldr	r1, [sp, #12]
    9dd6:	9805      	ldr	r0, [sp, #20]
    9dd8:	f000 f946 	bl	a068 <__ssprint_r>
    9ddc:	2800      	cmp	r0, #0
    9dde:	f47e af81 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9de2:	9a15      	ldr	r2, [sp, #84]	; 0x54
    9de4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9de6:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9dea:	e579      	b.n	98e0 <_svfprintf_r+0xde8>
    9dec:	464e      	mov	r6, r9
    9dee:	4689      	mov	r9, r1
    9df0:	3201      	adds	r2, #1
    9df2:	4423      	add	r3, r4
    9df4:	2a07      	cmp	r2, #7
    9df6:	931d      	str	r3, [sp, #116]	; 0x74
    9df8:	921c      	str	r2, [sp, #112]	; 0x70
    9dfa:	f8c9 7000 	str.w	r7, [r9]
    9dfe:	f8c9 4004 	str.w	r4, [r9, #4]
    9e02:	f73f af5a 	bgt.w	9cba <_svfprintf_r+0x11c2>
    9e06:	f109 0908 	add.w	r9, r9, #8
    9e0a:	e762      	b.n	9cd2 <_svfprintf_r+0x11da>
    9e0c:	aa1b      	add	r2, sp, #108	; 0x6c
    9e0e:	9903      	ldr	r1, [sp, #12]
    9e10:	9805      	ldr	r0, [sp, #20]
    9e12:	f000 f929 	bl	a068 <__ssprint_r>
    9e16:	2800      	cmp	r0, #0
    9e18:	f47e af64 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9e1c:	9a15      	ldr	r2, [sp, #84]	; 0x54
    9e1e:	990d      	ldr	r1, [sp, #52]	; 0x34
    9e20:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9e22:	1a8a      	subs	r2, r1, r2
    9e24:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9e28:	e572      	b.n	9910 <_svfprintf_r+0xe18>
    9e2a:	2d06      	cmp	r5, #6
    9e2c:	462b      	mov	r3, r5
    9e2e:	bf28      	it	cs
    9e30:	2306      	movcs	r3, #6
    9e32:	9308      	str	r3, [sp, #32]
    9e34:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9e38:	46b0      	mov	r8, r6
    9e3a:	9709      	str	r7, [sp, #36]	; 0x24
    9e3c:	960e      	str	r6, [sp, #56]	; 0x38
    9e3e:	4637      	mov	r7, r6
    9e40:	9304      	str	r3, [sp, #16]
    9e42:	4e08      	ldr	r6, [pc, #32]	; (9e64 <_svfprintf_r+0x136c>)
    9e44:	f7ff b84a 	b.w	8edc <_svfprintf_r+0x3e4>
    9e48:	469b      	mov	fp, r3
    9e4a:	f7ff b9ea 	b.w	9222 <_svfprintf_r+0x72a>
    9e4e:	272d      	movs	r7, #45	; 0x2d
    9e50:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9e54:	f7ff b833 	b.w	8ebe <_svfprintf_r+0x3c6>
    9e58:	20000e04 	.word	0x20000e04
    9e5c:	20000fec 	.word	0x20000fec
    9e60:	66666667 	.word	0x66666667
    9e64:	20000e40 	.word	0x20000e40
    9e68:	aa19      	add	r2, sp, #100	; 0x64
    9e6a:	ab16      	add	r3, sp, #88	; 0x58
    9e6c:	9201      	str	r2, [sp, #4]
    9e6e:	9300      	str	r3, [sp, #0]
    9e70:	2103      	movs	r1, #3
    9e72:	ab15      	add	r3, sp, #84	; 0x54
    9e74:	4642      	mov	r2, r8
    9e76:	eeb0 0b4a 	vmov.f64	d0, d10
    9e7a:	9805      	ldr	r0, [sp, #20]
    9e7c:	f7fd fff8 	bl	7e70 <_dtoa_r>
    9e80:	4644      	mov	r4, r8
    9e82:	4606      	mov	r6, r0
    9e84:	eb00 0108 	add.w	r1, r0, r8
    9e88:	e6ef      	b.n	9c6a <_svfprintf_r+0x1172>
    9e8a:	f04f 0806 	mov.w	r8, #6
    9e8e:	e5da      	b.n	9a46 <_svfprintf_r+0xf4e>
    9e90:	eeb1 ab48 	vneg.f64	d10, d8
    9e94:	272d      	movs	r7, #45	; 0x2d
    9e96:	e5e1      	b.n	9a5c <_svfprintf_r+0xf64>
    9e98:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9e9a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    9e9c:	4413      	add	r3, r2
    9e9e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    9ea0:	9308      	str	r3, [sp, #32]
    9ea2:	2a00      	cmp	r2, #0
    9ea4:	f340 8086 	ble.w	9fb4 <_svfprintf_r+0x14bc>
    9ea8:	2267      	movs	r2, #103	; 0x67
    9eaa:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9eae:	920c      	str	r2, [sp, #48]	; 0x30
    9eb0:	e623      	b.n	9afa <_svfprintf_r+0x1002>
    9eb2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9eb4:	2b47      	cmp	r3, #71	; 0x47
    9eb6:	f47f adf2 	bne.w	9a9e <_svfprintf_r+0xfa6>
    9eba:	f01b 0f01 	tst.w	fp, #1
    9ebe:	f47f aece 	bne.w	9c5e <_svfprintf_r+0x1166>
    9ec2:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9ec4:	2d47      	cmp	r5, #71	; 0x47
    9ec6:	eba3 0306 	sub.w	r3, r3, r6
    9eca:	930d      	str	r3, [sp, #52]	; 0x34
    9ecc:	f43f af1c 	beq.w	9d08 <_svfprintf_r+0x1210>
    9ed0:	9b15      	ldr	r3, [sp, #84]	; 0x54
    9ed2:	e722      	b.n	9d1a <_svfprintf_r+0x1222>
    9ed4:	2b00      	cmp	r3, #0
    9ed6:	461a      	mov	r2, r3
    9ed8:	930e      	str	r3, [sp, #56]	; 0x38
    9eda:	dd73      	ble.n	9fc4 <_svfprintf_r+0x14cc>
    9edc:	f1b8 0f00 	cmp.w	r8, #0
    9ee0:	d14b      	bne.n	9f7a <_svfprintf_r+0x1482>
    9ee2:	f01b 0f01 	tst.w	fp, #1
    9ee6:	d148      	bne.n	9f7a <_svfprintf_r+0x1482>
    9ee8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9eec:	9208      	str	r2, [sp, #32]
    9eee:	e604      	b.n	9afa <_svfprintf_r+0x1002>
    9ef0:	f01b 0f01 	tst.w	fp, #1
    9ef4:	4647      	mov	r7, r8
    9ef6:	d005      	beq.n	9f04 <_svfprintf_r+0x140c>
    9ef8:	ae38      	add	r6, sp, #224	; 0xe0
    9efa:	2330      	movs	r3, #48	; 0x30
    9efc:	f806 3d41 	strb.w	r3, [r6, #-65]!
    9f00:	f7ff b956 	b.w	91b0 <_svfprintf_r+0x6b8>
    9f04:	f8cd 8020 	str.w	r8, [sp, #32]
    9f08:	ae28      	add	r6, sp, #160	; 0xa0
    9f0a:	f7ff b954 	b.w	91b6 <_svfprintf_r+0x6be>
    9f0e:	ea25 73e5 	bic.w	r3, r5, r5, asr #31
    9f12:	9709      	str	r7, [sp, #36]	; 0x24
    9f14:	9304      	str	r3, [sp, #16]
    9f16:	9508      	str	r5, [sp, #32]
    9f18:	4680      	mov	r8, r0
    9f1a:	900e      	str	r0, [sp, #56]	; 0x38
    9f1c:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9f20:	f7fe bfdc 	b.w	8edc <_svfprintf_r+0x3e4>
    9f24:	aa1b      	add	r2, sp, #108	; 0x6c
    9f26:	9903      	ldr	r1, [sp, #12]
    9f28:	9805      	ldr	r0, [sp, #20]
    9f2a:	f000 f89d 	bl	a068 <__ssprint_r>
    9f2e:	2800      	cmp	r0, #0
    9f30:	f47e aed8 	bne.w	8ce4 <_svfprintf_r+0x1ec>
    9f34:	9c15      	ldr	r4, [sp, #84]	; 0x54
    9f36:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9f38:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9f3a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9f3e:	e63d      	b.n	9bbc <_svfprintf_r+0x10c4>
    9f40:	46a2      	mov	sl, r4
    9f42:	2500      	movs	r5, #0
    9f44:	f7fe be33 	b.w	8bae <_svfprintf_r+0xb6>
    9f48:	3330      	adds	r3, #48	; 0x30
    9f4a:	2230      	movs	r2, #48	; 0x30
    9f4c:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    9f50:	f88d 205e 	strb.w	r2, [sp, #94]	; 0x5e
    9f54:	ab18      	add	r3, sp, #96	; 0x60
    9f56:	e71c      	b.n	9d92 <_svfprintf_r+0x129a>
    9f58:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9f5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    9f5c:	4413      	add	r3, r2
    9f5e:	2267      	movs	r2, #103	; 0x67
    9f60:	9308      	str	r3, [sp, #32]
    9f62:	920c      	str	r2, [sp, #48]	; 0x30
    9f64:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9f68:	e5c7      	b.n	9afa <_svfprintf_r+0x1002>
    9f6a:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9f6c:	e5a8      	b.n	9ac0 <_svfprintf_r+0xfc8>
    9f6e:	4e3c      	ldr	r6, [pc, #240]	; (a060 <_svfprintf_r+0x1568>)
    9f70:	4b3c      	ldr	r3, [pc, #240]	; (a064 <_svfprintf_r+0x156c>)
    9f72:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9f76:	f7fe bfa4 	b.w	8ec2 <_svfprintf_r+0x3ca>
    9f7a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    9f7c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9f7e:	189d      	adds	r5, r3, r2
    9f80:	eb05 0308 	add.w	r3, r5, r8
    9f84:	9308      	str	r3, [sp, #32]
    9f86:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9f8a:	e5b6      	b.n	9afa <_svfprintf_r+0x1002>
    9f8c:	eeb5 ab40 	vcmp.f64	d10, #0.0
    9f90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9f94:	f43f ae6d 	beq.w	9c72 <_svfprintf_r+0x117a>
    9f98:	f1c4 0401 	rsb	r4, r4, #1
    9f9c:	9415      	str	r4, [sp, #84]	; 0x54
    9f9e:	4421      	add	r1, r4
    9fa0:	e57e      	b.n	9aa0 <_svfprintf_r+0xfa8>
    9fa2:	f01b 0301 	ands.w	r3, fp, #1
    9fa6:	f47f aefd 	bne.w	9da4 <_svfprintf_r+0x12ac>
    9faa:	930e      	str	r3, [sp, #56]	; 0x38
    9fac:	9b08      	ldr	r3, [sp, #32]
    9fae:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9fb2:	e5a2      	b.n	9afa <_svfprintf_r+0x1002>
    9fb4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    9fb6:	9a08      	ldr	r2, [sp, #32]
    9fb8:	f1c3 0301 	rsb	r3, r3, #1
    9fbc:	441a      	add	r2, r3
    9fbe:	4613      	mov	r3, r2
    9fc0:	9208      	str	r2, [sp, #32]
    9fc2:	e771      	b.n	9ea8 <_svfprintf_r+0x13b0>
    9fc4:	f1b8 0f00 	cmp.w	r8, #0
    9fc8:	d102      	bne.n	9fd0 <_svfprintf_r+0x14d8>
    9fca:	f01b 0f01 	tst.w	fp, #1
    9fce:	d007      	beq.n	9fe0 <_svfprintf_r+0x14e8>
    9fd0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    9fd2:	1c5d      	adds	r5, r3, #1
    9fd4:	eb05 0308 	add.w	r3, r5, r8
    9fd8:	9308      	str	r3, [sp, #32]
    9fda:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9fde:	e58c      	b.n	9afa <_svfprintf_r+0x1002>
    9fe0:	2301      	movs	r3, #1
    9fe2:	9308      	str	r3, [sp, #32]
    9fe4:	e589      	b.n	9afa <_svfprintf_r+0x1002>
    9fe6:	9809      	ldr	r0, [sp, #36]	; 0x24
    9fe8:	f89a 3001 	ldrb.w	r3, [sl, #1]
    9fec:	6805      	ldr	r5, [r0, #0]
    9fee:	3004      	adds	r0, #4
    9ff0:	2d00      	cmp	r5, #0
    9ff2:	9009      	str	r0, [sp, #36]	; 0x24
    9ff4:	46a2      	mov	sl, r4
    9ff6:	f6be add8 	bge.w	8baa <_svfprintf_r+0xb2>
    9ffa:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    9ffe:	f7fe bdd4 	b.w	8baa <_svfprintf_r+0xb2>
    a002:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a006:	f7ff b98d 	b.w	9324 <_svfprintf_r+0x82c>
    a00a:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a00e:	f7ff b9cf 	b.w	93b0 <_svfprintf_r+0x8b8>
    a012:	9a05      	ldr	r2, [sp, #20]
    a014:	230c      	movs	r3, #12
    a016:	6013      	str	r3, [r2, #0]
    a018:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a01c:	f7fe be6b 	b.w	8cf6 <_svfprintf_r+0x1fe>
    a020:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a024:	f7ff b8d4 	b.w	91d0 <_svfprintf_r+0x6d8>
    a028:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a02c:	f7ff b8a3 	b.w	9176 <_svfprintf_r+0x67e>
    a030:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a034:	f7ff b952 	b.w	92dc <_svfprintf_r+0x7e4>
    a038:	f10d 035e 	add.w	r3, sp, #94	; 0x5e
    a03c:	e6a9      	b.n	9d92 <_svfprintf_r+0x129a>
    a03e:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a042:	f7fe be62 	b.w	8d0a <_svfprintf_r+0x212>
    a046:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a04a:	f7ff b862 	b.w	9112 <_svfprintf_r+0x61a>
    a04e:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a052:	f7fe bf16 	b.w	8e82 <_svfprintf_r+0x38a>
    a056:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a05a:	f7fe bed0 	b.w	8dfe <_svfprintf_r+0x306>
    a05e:	bf00      	nop
    a060:	20000e14 	.word	0x20000e14
    a064:	20000e10 	.word	0x20000e10

0000a068 <__ssprint_r>:
    a068:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a06c:	6893      	ldr	r3, [r2, #8]
    a06e:	b083      	sub	sp, #12
    a070:	4690      	mov	r8, r2
    a072:	2b00      	cmp	r3, #0
    a074:	d072      	beq.n	a15c <__ssprint_r+0xf4>
    a076:	4683      	mov	fp, r0
    a078:	f04f 0900 	mov.w	r9, #0
    a07c:	6816      	ldr	r6, [r2, #0]
    a07e:	6808      	ldr	r0, [r1, #0]
    a080:	688b      	ldr	r3, [r1, #8]
    a082:	460d      	mov	r5, r1
    a084:	464c      	mov	r4, r9
    a086:	2c00      	cmp	r4, #0
    a088:	d045      	beq.n	a116 <__ssprint_r+0xae>
    a08a:	429c      	cmp	r4, r3
    a08c:	461f      	mov	r7, r3
    a08e:	469a      	mov	sl, r3
    a090:	d346      	bcc.n	a120 <__ssprint_r+0xb8>
    a092:	89ab      	ldrh	r3, [r5, #12]
    a094:	f413 6f90 	tst.w	r3, #1152	; 0x480
    a098:	d02d      	beq.n	a0f6 <__ssprint_r+0x8e>
    a09a:	696f      	ldr	r7, [r5, #20]
    a09c:	6929      	ldr	r1, [r5, #16]
    a09e:	eb07 0747 	add.w	r7, r7, r7, lsl #1
    a0a2:	ebc1 0a00 	rsb	sl, r1, r0
    a0a6:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
    a0aa:	1c60      	adds	r0, r4, #1
    a0ac:	107f      	asrs	r7, r7, #1
    a0ae:	4450      	add	r0, sl
    a0b0:	42b8      	cmp	r0, r7
    a0b2:	463a      	mov	r2, r7
    a0b4:	bf84      	itt	hi
    a0b6:	4607      	movhi	r7, r0
    a0b8:	463a      	movhi	r2, r7
    a0ba:	055b      	lsls	r3, r3, #21
    a0bc:	d533      	bpl.n	a126 <__ssprint_r+0xbe>
    a0be:	4611      	mov	r1, r2
    a0c0:	4658      	mov	r0, fp
    a0c2:	f7fb ff7f 	bl	5fc4 <_malloc_r>
    a0c6:	2800      	cmp	r0, #0
    a0c8:	d037      	beq.n	a13a <__ssprint_r+0xd2>
    a0ca:	4652      	mov	r2, sl
    a0cc:	6929      	ldr	r1, [r5, #16]
    a0ce:	9001      	str	r0, [sp, #4]
    a0d0:	f7fc fa46 	bl	6560 <memcpy>
    a0d4:	89aa      	ldrh	r2, [r5, #12]
    a0d6:	9b01      	ldr	r3, [sp, #4]
    a0d8:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    a0dc:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    a0e0:	81aa      	strh	r2, [r5, #12]
    a0e2:	ebca 0207 	rsb	r2, sl, r7
    a0e6:	eb03 000a 	add.w	r0, r3, sl
    a0ea:	616f      	str	r7, [r5, #20]
    a0ec:	612b      	str	r3, [r5, #16]
    a0ee:	6028      	str	r0, [r5, #0]
    a0f0:	60aa      	str	r2, [r5, #8]
    a0f2:	4627      	mov	r7, r4
    a0f4:	46a2      	mov	sl, r4
    a0f6:	4652      	mov	r2, sl
    a0f8:	4649      	mov	r1, r9
    a0fa:	f7fc facb 	bl	6694 <memmove>
    a0fe:	f8d8 2008 	ldr.w	r2, [r8, #8]
    a102:	68ab      	ldr	r3, [r5, #8]
    a104:	6828      	ldr	r0, [r5, #0]
    a106:	1bdb      	subs	r3, r3, r7
    a108:	4450      	add	r0, sl
    a10a:	1b14      	subs	r4, r2, r4
    a10c:	60ab      	str	r3, [r5, #8]
    a10e:	6028      	str	r0, [r5, #0]
    a110:	f8c8 4008 	str.w	r4, [r8, #8]
    a114:	b314      	cbz	r4, a15c <__ssprint_r+0xf4>
    a116:	f8d6 9000 	ldr.w	r9, [r6]
    a11a:	6874      	ldr	r4, [r6, #4]
    a11c:	3608      	adds	r6, #8
    a11e:	e7b2      	b.n	a086 <__ssprint_r+0x1e>
    a120:	4627      	mov	r7, r4
    a122:	46a2      	mov	sl, r4
    a124:	e7e7      	b.n	a0f6 <__ssprint_r+0x8e>
    a126:	4658      	mov	r0, fp
    a128:	f7fc fb72 	bl	6810 <_realloc_r>
    a12c:	4603      	mov	r3, r0
    a12e:	2800      	cmp	r0, #0
    a130:	d1d7      	bne.n	a0e2 <__ssprint_r+0x7a>
    a132:	6929      	ldr	r1, [r5, #16]
    a134:	4658      	mov	r0, fp
    a136:	f7fd f947 	bl	73c8 <_free_r>
    a13a:	230c      	movs	r3, #12
    a13c:	f8cb 3000 	str.w	r3, [fp]
    a140:	89ab      	ldrh	r3, [r5, #12]
    a142:	2200      	movs	r2, #0
    a144:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a148:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a14c:	81ab      	strh	r3, [r5, #12]
    a14e:	f8c8 2008 	str.w	r2, [r8, #8]
    a152:	f8c8 2004 	str.w	r2, [r8, #4]
    a156:	b003      	add	sp, #12
    a158:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a15c:	2000      	movs	r0, #0
    a15e:	f8c8 0004 	str.w	r0, [r8, #4]
    a162:	b003      	add	sp, #12
    a164:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000a168 <___init_veneer>:
    a168:	f85f f000 	ldr.w	pc, [pc]	; a16c <___init_veneer+0x4>
    a16c:	6000204d 	.word	0x6000204d

0000a170 <___reboot_Teensyduino__veneer>:
    a170:	f85f f000 	ldr.w	pc, [pc]	; a174 <___reboot_Teensyduino__veneer+0x4>
    a174:	60001dc5 	.word	0x60001dc5

0000a178 <___ZN7TwoWire5beginEv_veneer>:
    a178:	f85f f000 	ldr.w	pc, [pc]	; a17c <___ZN7TwoWire5beginEv_veneer+0x4>
    a17c:	60001e19 	.word	0x60001e19

Disassembly of section .fini:

0000a180 <_fini>:
    a180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a182:	bf00      	nop

Disassembly of section .text.csf:

6000e6c4 <_heap_end+0x3fd8e6c4>:
6000e6c4:	ffffffff 	.word	0xffffffff
6000e6c8:	ffffffff 	.word	0xffffffff
6000e6cc:	ffffffff 	.word	0xffffffff
6000e6d0:	ffffffff 	.word	0xffffffff
6000e6d4:	ffffffff 	.word	0xffffffff
6000e6d8:	ffffffff 	.word	0xffffffff
6000e6dc:	ffffffff 	.word	0xffffffff
6000e6e0:	ffffffff 	.word	0xffffffff
6000e6e4:	ffffffff 	.word	0xffffffff
6000e6e8:	ffffffff 	.word	0xffffffff
6000e6ec:	ffffffff 	.word	0xffffffff
6000e6f0:	ffffffff 	.word	0xffffffff
6000e6f4:	ffffffff 	.word	0xffffffff
6000e6f8:	ffffffff 	.word	0xffffffff
6000e6fc:	ffffffff 	.word	0xffffffff
6000e700:	ffffffff 	.word	0xffffffff
6000e704:	ffffffff 	.word	0xffffffff
6000e708:	ffffffff 	.word	0xffffffff
6000e70c:	ffffffff 	.word	0xffffffff
6000e710:	ffffffff 	.word	0xffffffff
6000e714:	ffffffff 	.word	0xffffffff
6000e718:	ffffffff 	.word	0xffffffff
6000e71c:	ffffffff 	.word	0xffffffff
6000e720:	ffffffff 	.word	0xffffffff
6000e724:	ffffffff 	.word	0xffffffff
6000e728:	ffffffff 	.word	0xffffffff
6000e72c:	ffffffff 	.word	0xffffffff
6000e730:	ffffffff 	.word	0xffffffff
6000e734:	ffffffff 	.word	0xffffffff
6000e738:	ffffffff 	.word	0xffffffff
6000e73c:	ffffffff 	.word	0xffffffff
6000e740:	ffffffff 	.word	0xffffffff
6000e744:	ffffffff 	.word	0xffffffff
6000e748:	ffffffff 	.word	0xffffffff
6000e74c:	ffffffff 	.word	0xffffffff
6000e750:	ffffffff 	.word	0xffffffff
6000e754:	ffffffff 	.word	0xffffffff
6000e758:	ffffffff 	.word	0xffffffff
6000e75c:	ffffffff 	.word	0xffffffff
6000e760:	ffffffff 	.word	0xffffffff
6000e764:	ffffffff 	.word	0xffffffff
6000e768:	ffffffff 	.word	0xffffffff
6000e76c:	ffffffff 	.word	0xffffffff
6000e770:	ffffffff 	.word	0xffffffff
6000e774:	ffffffff 	.word	0xffffffff
6000e778:	ffffffff 	.word	0xffffffff
6000e77c:	ffffffff 	.word	0xffffffff
6000e780:	ffffffff 	.word	0xffffffff
6000e784:	ffffffff 	.word	0xffffffff
6000e788:	ffffffff 	.word	0xffffffff
6000e78c:	ffffffff 	.word	0xffffffff
6000e790:	ffffffff 	.word	0xffffffff
6000e794:	ffffffff 	.word	0xffffffff
6000e798:	ffffffff 	.word	0xffffffff
6000e79c:	ffffffff 	.word	0xffffffff
6000e7a0:	ffffffff 	.word	0xffffffff
6000e7a4:	ffffffff 	.word	0xffffffff
6000e7a8:	ffffffff 	.word	0xffffffff
6000e7ac:	ffffffff 	.word	0xffffffff
6000e7b0:	ffffffff 	.word	0xffffffff
6000e7b4:	ffffffff 	.word	0xffffffff
6000e7b8:	ffffffff 	.word	0xffffffff
6000e7bc:	ffffffff 	.word	0xffffffff
6000e7c0:	ffffffff 	.word	0xffffffff
6000e7c4:	ffffffff 	.word	0xffffffff
6000e7c8:	ffffffff 	.word	0xffffffff
6000e7cc:	ffffffff 	.word	0xffffffff
6000e7d0:	ffffffff 	.word	0xffffffff
6000e7d4:	ffffffff 	.word	0xffffffff
6000e7d8:	ffffffff 	.word	0xffffffff
6000e7dc:	ffffffff 	.word	0xffffffff
6000e7e0:	ffffffff 	.word	0xffffffff
6000e7e4:	ffffffff 	.word	0xffffffff
6000e7e8:	ffffffff 	.word	0xffffffff
6000e7ec:	ffffffff 	.word	0xffffffff
6000e7f0:	ffffffff 	.word	0xffffffff
6000e7f4:	ffffffff 	.word	0xffffffff
6000e7f8:	ffffffff 	.word	0xffffffff
6000e7fc:	ffffffff 	.word	0xffffffff

6000e800 <hab_csf>:
	...
