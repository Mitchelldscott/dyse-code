
/Users/mitchellscott/Desktop/rufous/src/firmware/build/examples/system_graph/process_tests.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001400:	4288      	cmp	r0, r1
60001402:	d007      	beq.n	60001414 <memory_copy+0x14>
	while (dest < dest_end) {
60001404:	4290      	cmp	r0, r2
60001406:	d205      	bcs.n	60001414 <memory_copy+0x14>
		*dest++ = *src++;
60001408:	f851 3b04 	ldr.w	r3, [r1], #4
6000140c:	f840 3b04 	str.w	r3, [r0], #4

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001410:	4282      	cmp	r2, r0
60001412:	d8f9      	bhi.n	60001408 <memory_copy+0x8>
60001414:	4770      	bx	lr
60001416:	bf00      	nop

60001418 <memory_clear>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001418:	4288      	cmp	r0, r1
6000141a:	d204      	bcs.n	60001426 <memory_clear+0xe>
		*dest++ = 0;
6000141c:	2300      	movs	r3, #0
6000141e:	f840 3b04 	str.w	r3, [r0], #4
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001422:	4281      	cmp	r1, r0
60001424:	d8fb      	bhi.n	6000141e <memory_clear+0x6>
60001426:	4770      	bx	lr

60001428 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001428:	4b66      	ldr	r3, [pc, #408]	; (600015c4 <ResetHandler+0x19c>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000142a:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000142e:	4a66      	ldr	r2, [pc, #408]	; (600015c8 <ResetHandler+0x1a0>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001430:	4866      	ldr	r0, [pc, #408]	; (600015cc <ResetHandler+0x1a4>)
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
void startup_late_hook(void)	__attribute__ ((weak, alias("startup_default_late_hook")));
__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
void ResetHandler(void)
{
60001432:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001436:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001438:	6418      	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143a:	4a65      	ldr	r2, [pc, #404]	; (600015d0 <ResetHandler+0x1a8>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000143c:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143e:	4695      	mov	sp, r2
	__asm__ volatile("dsb":::"memory");
60001440:	f3bf 8f4f 	dsb	sy
	__asm__ volatile("isb":::"memory");
60001444:	f3bf 8f6f 	isb	sy
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
60001448:	f000 f930 	bl	600016ac <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000144c:	4b61      	ldr	r3, [pc, #388]	; (600015d4 <ResetHandler+0x1ac>)
6000144e:	2008      	movs	r0, #8
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001450:	4a61      	ldr	r2, [pc, #388]	; (600015d8 <ResetHandler+0x1b0>)
60001452:	4962      	ldr	r1, [pc, #392]	; (600015dc <ResetHandler+0x1b4>)
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
	__asm__ volatile("dsb":::"memory");
	__asm__ volatile("isb":::"memory");
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001454:	f8c3 0154 	str.w	r0, [r3, #340]	; 0x154
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001458:	4861      	ldr	r0, [pc, #388]	; (600015e0 <ResetHandler+0x1b8>)
6000145a:	f7ff ffd1 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
6000145e:	4a61      	ldr	r2, [pc, #388]	; (600015e4 <ResetHandler+0x1bc>)
60001460:	4961      	ldr	r1, [pc, #388]	; (600015e8 <ResetHandler+0x1c0>)
60001462:	4862      	ldr	r0, [pc, #392]	; (600015ec <ResetHandler+0x1c4>)
60001464:	f7ff ffcc 	bl	60001400 <memory_copy>
	memory_clear(&_sbss, &_ebss);
60001468:	4961      	ldr	r1, [pc, #388]	; (600015f0 <ResetHandler+0x1c8>)
6000146a:	4862      	ldr	r0, [pc, #392]	; (600015f4 <ResetHandler+0x1cc>)
6000146c:	f7ff ffd4 	bl	60001418 <memory_clear>
60001470:	4c61      	ldr	r4, [pc, #388]	; (600015f8 <ResetHandler+0x1d0>)

	// enable FPU
	SCB_CPACR = 0x00F00000;
60001472:	4962      	ldr	r1, [pc, #392]	; (600015fc <ResetHandler+0x1d4>)
60001474:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001478:	2300      	movs	r3, #0
6000147a:	4a61      	ldr	r2, [pc, #388]	; (60001600 <ResetHandler+0x1d8>)
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
6000147c:	6008      	str	r0, [r1, #0]

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000147e:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
60001482:	3301      	adds	r3, #1
60001484:	2bb0      	cmp	r3, #176	; 0xb0
60001486:	d1fa      	bne.n	6000147e <ResetHandler+0x56>
60001488:	4b5e      	ldr	r3, [pc, #376]	; (60001604 <ResetHandler+0x1dc>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
6000148a:	2180      	movs	r1, #128	; 0x80
6000148c:	4a5e      	ldr	r2, [pc, #376]	; (60001608 <ResetHandler+0x1e0>)
6000148e:	f803 1b01 	strb.w	r1, [r3], #1
60001492:	4293      	cmp	r3, r2
60001494:	d1fb      	bne.n	6000148e <ResetHandler+0x66>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001496:	4d4f      	ldr	r5, [pc, #316]	; (600015d4 <ResetHandler+0x1ac>)
60001498:	f04f 3880 	mov.w	r8, #2155905152	; 0x80808080
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
6000149c:	495b      	ldr	r1, [pc, #364]	; (6000160c <ResetHandler+0x1e4>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
6000149e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014a2:	4b5b      	ldr	r3, [pc, #364]	; (60001610 <ResetHandler+0x1e8>)
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600014a4:	2600      	movs	r6, #0

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014a6:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 6000164c <ResetHandler+0x224>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014aa:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 60001650 <ResetHandler+0x228>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014ae:	601c      	str	r4, [r3, #0]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014b0:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014b4:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014b8:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014bc:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c0:	680b      	ldr	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014c2:	4f54      	ldr	r7, [pc, #336]	; (60001614 <ResetHandler+0x1ec>)
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c4:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
600014c8:	600b      	str	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ca:	69fb      	ldr	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014cc:	493d      	ldr	r1, [pc, #244]	; (600015c4 <ResetHandler+0x19c>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ce:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014d6:	61fb      	str	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
600014da:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014e2:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014e4:	668a      	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
600014e6:	66ca      	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
600014e8:	670a      	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
600014ea:	674a      	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
600014ec:	f000 f8e4 	bl	600016b8 <configure_cache>
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f0:	4a49      	ldr	r2, [pc, #292]	; (60001618 <ResetHandler+0x1f0>)
	_VectorsRam[15] = systick_isr;
600014f2:	4b4a      	ldr	r3, [pc, #296]	; (6000161c <ResetHandler+0x1f4>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014f4:	2063      	movs	r0, #99	; 0x63
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f6:	63a2      	str	r2, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
600014f8:	2103      	movs	r1, #3

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
600014fa:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014fc:	4a48      	ldr	r2, [pc, #288]	; (60001620 <ResetHandler+0x1f8>)
	SYST_CVR = 0;
600014fe:	4b49      	ldr	r3, [pc, #292]	; (60001624 <ResetHandler+0x1fc>)
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001500:	6010      	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001502:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
60001506:	601e      	str	r6, [r3, #0]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001508:	f842 1c04 	str.w	r1, [r2, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000150c:	f600 70a1 	addw	r0, r0, #4001	; 0xfa1
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001510:	4945      	ldr	r1, [pc, #276]	; (60001628 <ResetHandler+0x200>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001512:	4a46      	ldr	r2, [pc, #280]	; (6000162c <ResetHandler+0x204>)
60001514:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001518:	680b      	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000151a:	4a45      	ldr	r2, [pc, #276]	; (60001630 <ResetHandler+0x208>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000151c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
60001520:	600b      	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001522:	6813      	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001524:	4943      	ldr	r1, [pc, #268]	; (60001634 <ResetHandler+0x20c>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001526:	f043 0301 	orr.w	r3, r3, #1
6000152a:	6013      	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000152c:	6803      	ldr	r3, [r0, #0]
6000152e:	600b      	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
60001530:	f000 fb12 	bl	60001b58 <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001534:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001538:	483f      	ldr	r0, [pc, #252]	; (60001638 <ResetHandler+0x210>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000153a:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000153e:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001542:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001546:	f000 fd87 	bl	60002058 <__set_arm_clock_veneer>
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154a:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
6000154c:	4a3b      	ldr	r2, [pc, #236]	; (6000163c <ResetHandler+0x214>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154e:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001552:	4b3b      	ldr	r3, [pc, #236]	; (60001640 <ResetHandler+0x218>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001554:	66f9      	str	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
60001556:	6016      	str	r6, [r2, #0]
	PIT_TCTRL0 = 0;
60001558:	f8c2 6108 	str.w	r6, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000155c:	f8c2 6118 	str.w	r6, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001560:	f8c2 6128 	str.w	r6, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001564:	f8c2 6138 	str.w	r6, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001568:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000156a:	07d2      	lsls	r2, r2, #31
6000156c:	d408      	bmi.n	60001580 <ResetHandler+0x158>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000156e:	f642 6215 	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
60001572:	4934      	ldr	r1, [pc, #208]	; (60001644 <ResetHandler+0x21c>)
60001574:	6559      	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001576:	651a      	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001578:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000157a:	f042 0201 	orr.w	r2, r2, #1
6000157e:	639a      	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
60001580:	4a2f      	ldr	r2, [pc, #188]	; (60001640 <ResetHandler+0x218>)
60001582:	4c31      	ldr	r4, [pc, #196]	; (60001648 <ResetHandler+0x220>)
60001584:	6893      	ldr	r3, [r2, #8]
60001586:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
6000158a:	6093      	str	r3, [r2, #8]

#ifdef ARDUINO_TEENSY41
	configure_external_ram();
6000158c:	f000 f906 	bl	6000179c <configure_external_ram>
#endif
	analog_init();
60001590:	f000 f860 	bl	60001654 <analog_init>
	pwm_init();
60001594:	f000 fd6c 	bl	60002070 <__pwm_init_veneer>
	tempmon_init();
60001598:	f000 fb10 	bl	60001bbc <tempmon_init>
	startup_middle_hook();
6000159c:	f000 f888 	bl	600016b0 <startup_default_middle_hook>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
600015a0:	6823      	ldr	r3, [r4, #0]
#endif
	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290?p=87273&viewfull=1#post87273

	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015a2:	2b13      	cmp	r3, #19
600015a4:	d9fc      	bls.n	600015a0 <ResetHandler+0x178>
	usb_init();
600015a6:	f000 fb97 	bl	60001cd8 <usb_init>
600015aa:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015ac:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
600015b0:	d3fb      	bcc.n	600015aa <ResetHandler+0x182>
	//printf("before C++ constructors\n");
	startup_late_hook();
600015b2:	f000 f87f 	bl	600016b4 <startup_default_late_hook>
	__libc_init_array();
600015b6:	f000 fd53 	bl	60002060 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
600015ba:	f000 fd61 	bl	60002080 <__main_veneer>
	
	while (1) asm("WFI");
600015be:	bf30      	wfi
600015c0:	e7fd      	b.n	600015be <ResetHandler+0x196>
600015c2:	bf00      	nop
600015c4:	400ac000 	.word	0x400ac000
600015c8:	aaaaaaaf 	.word	0xaaaaaaaf
600015cc:	00200007 	.word	0x00200007
600015d0:	20070000 	.word	0x20070000
600015d4:	400d8000 	.word	0x400d8000
600015d8:	0000a848 	.word	0x0000a848
600015dc:	60002278 	.word	0x60002278
600015e0:	00000000 	.word	0x00000000
600015e4:	200022c0 	.word	0x200022c0
600015e8:	6000cac4 	.word	0x6000cac4
600015ec:	20000000 	.word	0x20000000
600015f0:	200027e0 	.word	0x200027e0
600015f4:	200022c0 	.word	0x200022c0
600015f8:	20002000 	.word	0x20002000
600015fc:	e000ed88 	.word	0xe000ed88
60001600:	00001b6d 	.word	0x00001b6d
60001604:	e000e400 	.word	0xe000e400
60001608:	e000e4a0 	.word	0xe000e4a0
6000160c:	e000ed24 	.word	0xe000ed24
60001610:	e000ed08 	.word	0xe000ed08
60001614:	400fc000 	.word	0x400fc000
60001618:	00002ccd 	.word	0x00002ccd
6000161c:	00002cd1 	.word	0x00002cd1
60001620:	e000e014 	.word	0xe000e014
60001624:	e000e018 	.word	0xe000e018
60001628:	e000edfc 	.word	0xe000edfc
6000162c:	20200000 	.word	0x20200000
60001630:	e0001000 	.word	0xe0001000
60001634:	2000273c 	.word	0x2000273c
60001638:	23c34600 	.word	0x23c34600
6000163c:	40084000 	.word	0x40084000
60001640:	400d4000 	.word	0x400d4000
60001644:	56c00000 	.word	0x56c00000
60001648:	20002740 	.word	0x20002740
6000164c:	2018101b 	.word	0x2018101b
60001650:	13110d0c 	.word	0x13110d0c

60001654 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001654:	4b11      	ldr	r3, [pc, #68]	; (6000169c <analog_init+0x48>)
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001656:	4912      	ldr	r1, [pc, #72]	; (600016a0 <analog_init+0x4c>)
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001658:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
6000165a:	460a      	mov	r2, r1
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
6000165c:	f440 3040 	orr.w	r0, r0, #196608	; 0x30000
}

#define MAX_ADC_CLOCK 20000000

FLASHMEM void analog_init(void)
{
60001660:	b430      	push	{r4, r5}
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001662:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001664:	f240 6537 	movw	r5, #1591	; 0x637
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001668:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
6000166a:	24a0      	movs	r4, #160	; 0xa0
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
6000166c:	f440 7040 	orr.w	r0, r0, #768	; 0x300
60001670:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001672:	644d      	str	r5, [r1, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001674:	648c      	str	r4, [r1, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
60001676:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001678:	061b      	lsls	r3, r3, #24
6000167a:	d4fc      	bmi.n	60001676 <analog_init+0x22>
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
6000167c:	4b09      	ldr	r3, [pc, #36]	; (600016a4 <analog_init+0x50>)
6000167e:	f240 6037 	movw	r0, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001682:	21a0      	movs	r1, #160	; 0xa0
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
60001684:	461a      	mov	r2, r3
	while (ADC1_GC & ADC_GC_CAL) {
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001686:	6458      	str	r0, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001688:	6499      	str	r1, [r3, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
6000168a:	6c93      	ldr	r3, [r2, #72]	; 0x48
6000168c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
60001690:	d1fb      	bne.n	6000168a <analog_init+0x36>
		//yield();
	}
	calibrating = 0;
60001692:	4a05      	ldr	r2, [pc, #20]	; (600016a8 <analog_init+0x54>)
60001694:	7013      	strb	r3, [r2, #0]
}
60001696:	bc30      	pop	{r4, r5}
60001698:	4770      	bx	lr
6000169a:	bf00      	nop
6000169c:	400fc000 	.word	0x400fc000
600016a0:	400c4000 	.word	0x400c4000
600016a4:	400c8000 	.word	0x400c8000
600016a8:	20002751 	.word	0x20002751

600016ac <startup_default_early_hook>:
600016ac:	4770      	bx	lr
600016ae:	bf00      	nop

600016b0 <startup_default_middle_hook>:
600016b0:	4770      	bx	lr
600016b2:	bf00      	nop

600016b4 <startup_default_late_hook>:
extern int main (void);
FLASHMEM void startup_default_early_hook(void) {}
void startup_early_hook(void)	__attribute__ ((weak, alias("startup_default_early_hook")));
FLASHMEM void startup_default_middle_hook(void) {}
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
600016b4:	4770      	bx	lr
600016b6:	bf00      	nop

600016b8 <configure_cache>:
#define SIZE_2G		(SCB_MPU_RASR_SIZE(30) | SCB_MPU_RASR_ENABLE)
#define SIZE_4G		(SCB_MPU_RASR_SIZE(31) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
600016b8:	b5f0      	push	{r4, r5, r6, r7, lr}
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016ba:	4a24      	ldr	r2, [pc, #144]	; (6000174c <configure_cache+0x94>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016bc:	2000      	movs	r0, #0

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016be:	4b24      	ldr	r3, [pc, #144]	; (60001750 <configure_cache+0x98>)
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016c0:	f04f 0c10 	mov.w	ip, #16
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016c4:	4c23      	ldr	r4, [pc, #140]	; (60001754 <configure_cache+0x9c>)

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016c6:	2611      	movs	r6, #17

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016c8:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 60001794 <configure_cache+0xdc>
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016cc:	2712      	movs	r7, #18
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016ce:	6020      	str	r0, [r4, #0]
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600016d0:	2501      	movs	r5, #1
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016d2:	f8c2 c000 	str.w	ip, [r2]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016d6:	f8c3 e000 	str.w	lr, [r3]
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016da:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016dc:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 60001798 <configure_cache+0xe0>

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016e0:	4e1d      	ldr	r6, [pc, #116]	; (60001758 <configure_cache+0xa0>)
	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016e2:	f8c3 e000 	str.w	lr, [r3]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016e6:	491d      	ldr	r1, [pc, #116]	; (6000175c <configure_cache+0xa4>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016e8:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016ea:	601e      	str	r6, [r3, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016ec:	f041 0115 	orr.w	r1, r1, #21
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f0:	4f1b      	ldr	r7, [pc, #108]	; (60001760 <configure_cache+0xa8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f2:	4e1c      	ldr	r6, [pc, #112]	; (60001764 <configure_cache+0xac>)
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f4:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f6:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016f8:	4f1b      	ldr	r7, [pc, #108]	; (60001768 <configure_cache+0xb0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fa:	4e1c      	ldr	r6, [pc, #112]	; (6000176c <configure_cache+0xb4>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016fc:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fe:	601e      	str	r6, [r3, #0]
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001700:	4f1b      	ldr	r7, [pc, #108]	; (60001770 <configure_cache+0xb8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
60001702:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
60001704:	4e1b      	ldr	r6, [pc, #108]	; (60001774 <configure_cache+0xbc>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
60001706:	491c      	ldr	r1, [pc, #112]	; (60001778 <configure_cache+0xc0>)

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001708:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
6000170a:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
6000170c:	4f1b      	ldr	r7, [pc, #108]	; (6000177c <configure_cache+0xc4>)
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
6000170e:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001710:	4e1b      	ldr	r6, [pc, #108]	; (60001780 <configure_cache+0xc8>)

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
60001712:	491c      	ldr	r1, [pc, #112]	; (60001784 <configure_cache+0xcc>)
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
60001714:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001716:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001718:	4f1b      	ldr	r7, [pc, #108]	; (60001788 <configure_cache+0xd0>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
6000171a:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
6000171c:	4e1b      	ldr	r6, [pc, #108]	; (6000178c <configure_cache+0xd4>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
6000171e:	491c      	ldr	r1, [pc, #112]	; (60001790 <configure_cache+0xd8>)

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001720:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
60001722:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
60001724:	6019      	str	r1, [r3, #0]

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
60001726:	6025      	str	r5, [r4, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
60001728:	f3bf 8f4f 	dsb	sy
	asm("isb");
6000172c:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
60001730:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0

	asm("dsb");
60001734:	f3bf 8f4f 	dsb	sy
	asm("isb");
60001738:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000173c:	f852 3c88 	ldr.w	r3, [r2, #-136]
60001740:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
60001744:	f842 3c88 	str.w	r3, [r2, #-136]
60001748:	bdf0      	pop	{r4, r5, r6, r7, pc}
6000174a:	bf00      	nop
6000174c:	e000ed9c 	.word	0xe000ed9c
60001750:	e000eda0 	.word	0xe000eda0
60001754:	e000ed94 	.word	0xe000ed94
60001758:	00100009 	.word	0x00100009
6000175c:	200027e0 	.word	0x200027e0
60001760:	00200013 	.word	0x00200013
60001764:	07020021 	.word	0x07020021
60001768:	20000014 	.word	0x20000014
6000176c:	13080025 	.word	0x13080025
60001770:	10000009 	.word	0x10000009
60001774:	20200016 	.word	0x20200016
60001778:	130b0027 	.word	0x130b0027
6000177c:	40000017 	.word	0x40000017
60001780:	13100033 	.word	0x13100033
60001784:	60000018 	.word	0x60000018
60001788:	070b002f 	.word	0x070b002f
6000178c:	70000019 	.word	0x70000019
60001790:	130b002f 	.word	0x130b002f
60001794:	1000003f 	.word	0x1000003f
60001798:	03080025 	.word	0x03080025

6000179c <configure_external_ram>:
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
6000179c:	b5f0      	push	{r4, r5, r6, r7, lr}
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
6000179e:	4b8d      	ldr	r3, [pc, #564]	; (600019d4 <configure_external_ram+0x238>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017a0:	2218      	movs	r2, #24
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017a2:	4e8d      	ldr	r6, [pc, #564]	; (600019d8 <configure_external_ram+0x23c>)
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017a4:	2001      	movs	r0, #1
}

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017a6:	498d      	ldr	r1, [pc, #564]	; (600019dc <configure_external_ram+0x240>)
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
600017a8:	f248 7e0c 	movw	lr, #34572	; 0x870c

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ac:	4d8c      	ldr	r5, [pc, #560]	; (600019e0 <configure_external_ram+0x244>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
600017ae:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017b2:	4c8c      	ldr	r4, [pc, #560]	; (600019e4 <configure_external_ram+0x248>)
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
600017b4:	b083      	sub	sp, #12
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017b6:	f8c3 125c 	str.w	r1, [r3, #604]	; 0x25c
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ba:	f8c3 5260 	str.w	r5, [r3, #608]	; 0x260
	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
600017be:	2500      	movs	r5, #0
FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017c0:	f8c3 1264 	str.w	r1, [r3, #612]	; 0x264
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017c4:	f8c3 4268 	str.w	r4, [r3, #616]	; 0x268
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600017c8:	f44f 5400 	mov.w	r4, #8192	; 0x2000
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017cc:	f8c3 626c 	str.w	r6, [r3, #620]	; 0x26c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017d0:	4985      	ldr	r1, [pc, #532]	; (600019e8 <configure_external_ram+0x24c>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d2:	f8c3 6270 	str.w	r6, [r3, #624]	; 0x270
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d6:	f8c3 6274 	str.w	r6, [r3, #628]	; 0x274
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017da:	f8c3 6278 	str.w	r6, [r3, #632]	; 0x278
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
600017de:	4e83      	ldr	r6, [pc, #524]	; (600019ec <configure_external_ram+0x250>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017e0:	66da      	str	r2, [r3, #108]	; 0x6c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DQS
600017e2:	671a      	str	r2, [r3, #112]	; 0x70
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS0_B (RAM)
600017e4:	675a      	str	r2, [r3, #116]	; 0x74
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SCLK
600017e6:	679a      	str	r2, [r3, #120]	; 0x78
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
600017e8:	67da      	str	r2, [r3, #124]	; 0x7c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
600017ea:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
600017ee:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3
600017f2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600017f6:	f240 6205 	movw	r2, #1541	; 0x605
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017fa:	f8c1 032c 	str.w	r0, [r1, #812]	; 0x32c
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT = 1; // GPIO_EMC_26 for Mode: ALT8
600017fe:	f8c1 0330 	str.w	r0, [r1, #816]	; 0x330
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT = 1; // GPIO_EMC_27 for Mode: ALT8
60001802:	f8c1 0334 	str.w	r0, [r1, #820]	; 0x334
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
60001806:	f8c1 0338 	str.w	r0, [r1, #824]	; 0x338
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
6000180a:	f8c1 033c 	str.w	r0, [r1, #828]	; 0x33c
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8
6000180e:	f8c1 0350 	str.w	r0, [r1, #848]	; 0x350
	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
60001812:	4629      	mov	r1, r5
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001814:	69b3      	ldr	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
60001816:	4876      	ldr	r0, [pc, #472]	; (600019f0 <configure_external_ram+0x254>)
60001818:	4018      	ands	r0, r3
6000181a:	4b76      	ldr	r3, [pc, #472]	; (600019f4 <configure_external_ram+0x258>)
6000181c:	4303      	orrs	r3, r0
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
6000181e:	4876      	ldr	r0, [pc, #472]	; (600019f8 <configure_external_ram+0x25c>)
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001820:	61b3      	str	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);
60001822:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
60001826:	f043 030c 	orr.w	r3, r3, #12
6000182a:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
6000182e:	2602      	movs	r6, #2
	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
60001830:	6803      	ldr	r3, [r0, #0]
60001832:	4333      	orrs	r3, r6
60001834:	6003      	str	r3, [r0, #0]
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001836:	6803      	ldr	r3, [r0, #0]
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
60001838:	ea03 0e0e 	and.w	lr, r3, lr
6000183c:	4b6f      	ldr	r3, [pc, #444]	; (600019fc <configure_external_ram+0x260>)
6000183e:	ea4e 0303 	orr.w	r3, lr, r3
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001842:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 60001a34 <configure_external_ram+0x298>
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001846:	6003      	str	r3, [r0, #0]
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001848:	4b6d      	ldr	r3, [pc, #436]	; (60001a00 <configure_external_ram+0x264>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
6000184a:	6047      	str	r7, [r0, #4]
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
6000184c:	f8de 7008 	ldr.w	r7, [lr, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001850:	403b      	ands	r3, r7
	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001852:	4f6c      	ldr	r7, [pc, #432]	; (60001a04 <configure_external_ram+0x268>)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001854:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001858:	6083      	str	r3, [r0, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
6000185a:	68c3      	ldr	r3, [r0, #12]
6000185c:	f023 0378 	bic.w	r3, r3, #120	; 0x78
60001860:	60c3      	str	r3, [r0, #12]
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001862:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001864:	401f      	ands	r7, r3
60001866:	4b68      	ldr	r3, [pc, #416]	; (60001a08 <configure_external_ram+0x26c>)
60001868:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
6000186a:	4f66      	ldr	r7, [pc, #408]	; (60001a04 <configure_external_ram+0x268>)

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186c:	6203      	str	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186e:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001870:	401f      	ands	r7, r3
60001872:	4b65      	ldr	r3, [pc, #404]	; (60001a08 <configure_external_ram+0x26c>)
60001874:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF2CR0 = mask;
60001876:	4f65      	ldr	r7, [pc, #404]	; (60001a0c <configure_external_ram+0x270>)
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001878:	6243      	str	r3, [r0, #36]	; 0x24
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
6000187a:	6287      	str	r7, [r0, #40]	; 0x28
	FLEXSPI2_AHBRXBUF3CR0 = mask;
6000187c:	62c7      	str	r7, [r0, #44]	; 0x2c

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
6000187e:	f8de 30b8 	ldr.w	r3, [lr, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
60001882:	4f63      	ldr	r7, [pc, #396]	; (60001a10 <configure_external_ram+0x274>)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
60001884:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
60001888:	f043 0301 	orr.w	r3, r3, #1
6000188c:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001890:	f8de 30bc 	ldr.w	r3, [lr, #188]	; 0xbc
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
60001894:	f8df e184 	ldr.w	lr, [pc, #388]	; 60001a1c <configure_external_ram+0x280>
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001898:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
6000189c:	f043 0301 	orr.w	r3, r3, #1
600018a0:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc

	FLEXSPI2_INTEN = 0;
600018a4:	6105      	str	r5, [r0, #16]
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600018a6:	6604      	str	r4, [r0, #96]	; 0x60
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018a8:	6707      	str	r7, [r0, #112]	; 0x70
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018aa:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_FLSHA2CR0 = 0x2000; // 8 MByte
600018ae:	6644      	str	r4, [r0, #100]	; 0x64
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018b0:	6747      	str	r7, [r0, #116]	; 0x74
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018b2:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018b6:	6804      	ldr	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018b8:	4b56      	ldr	r3, [pc, #344]	; (60001a14 <configure_external_ram+0x278>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018ba:	f024 0402 	bic.w	r4, r4, #2

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018be:	4a56      	ldr	r2, [pc, #344]	; (60001a18 <configure_external_ram+0x27c>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018c0:	6004      	str	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018c2:	f8c0 e018 	str.w	lr, [r0, #24]
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018c6:	61c6      	str	r6, [r0, #28]
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018c8:	f843 1b04 	str.w	r1, [r3], #4
600018cc:	4293      	cmp	r3, r2
600018ce:	d1fb      	bne.n	600018c8 <configure_external_ram+0x12c>
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d0:	4b49      	ldr	r3, [pc, #292]	; (600019f8 <configure_external_ram+0x25c>)
600018d2:	681a      	ldr	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018d4:	4619      	mov	r1, r3

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d6:	f042 0201 	orr.w	r2, r2, #1
600018da:	601a      	str	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018dc:	680b      	ldr	r3, [r1, #0]
600018de:	4a46      	ldr	r2, [pc, #280]	; (600019f8 <configure_external_ram+0x25c>)
600018e0:	f013 0301 	ands.w	r3, r3, #1
600018e4:	d1fa      	bne.n	600018dc <configure_external_ram+0x140>

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018e6:	4e4d      	ldr	r6, [pc, #308]	; (60001a1c <configure_external_ram+0x280>)
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018e8:	2502      	movs	r5, #2

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
600018ea:	f240 64f5 	movw	r4, #1781	; 0x6f5
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
600018ee:	f240 4066 	movw	r0, #1126	; 0x466
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
600018f2:	f240 4199 	movw	r1, #1177	; 0x499
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
600018f6:	4f4a      	ldr	r7, [pc, #296]	; (60001a20 <configure_external_ram+0x284>)
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018f8:	6196      	str	r6, [r2, #24]
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
600018fa:	f242 4601 	movw	r6, #9217	; 0x2401
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018fe:	61d5      	str	r5, [r2, #28]
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001900:	f240 4535 	movw	r5, #1077	; 0x435

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
60001904:	f8c2 4200 	str.w	r4, [r2, #512]	; 0x200
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
60001908:	f242 2401 	movw	r4, #8705	; 0x2201
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
6000190c:	f8c2 0210 	str.w	r0, [r2, #528]	; 0x210

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001910:	2001      	movs	r0, #1
	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
60001912:	f8c2 1220 	str.w	r1, [r2, #544]	; 0x220
FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001916:	4611      	mov	r1, r2
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
60001918:	f8c2 7230 	str.w	r7, [r2, #560]	; 0x230
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
6000191c:	f107 475a 	add.w	r7, r7, #3657433088	; 0xda000000
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
60001920:	f8c2 6234 	str.w	r6, [r2, #564]	; 0x234
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001924:	f507 7713 	add.w	r7, r7, #588	; 0x24c
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001928:	f8c2 5240 	str.w	r5, [r2, #576]	; 0x240
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
6000192c:	4e3d      	ldr	r6, [pc, #244]	; (60001a24 <configure_external_ram+0x288>)
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
6000192e:	4d3e      	ldr	r5, [pc, #248]	; (60001a28 <configure_external_ram+0x28c>)
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001930:	f8c2 7250 	str.w	r7, [r2, #592]	; 0x250
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
60001934:	f8c2 6254 	str.w	r6, [r2, #596]	; 0x254
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
60001938:	f8c2 5260 	str.w	r5, [r2, #608]	; 0x260
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
6000193c:	f8c2 4264 	str.w	r4, [r2, #612]	; 0x264
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001940:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001944:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001948:	f8c2 00b0 	str.w	r0, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000194c:	694b      	ldr	r3, [r1, #20]
6000194e:	4a2a      	ldr	r2, [pc, #168]	; (600019f8 <configure_external_ram+0x25c>)
60001950:	07dd      	lsls	r5, r3, #31
60001952:	d5fb      	bpl.n	6000194c <configure_external_ram+0x1b0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001954:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001956:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001958:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000195c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000195e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001960:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001964:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001968:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000196c:	694b      	ldr	r3, [r1, #20]
6000196e:	4a22      	ldr	r2, [pc, #136]	; (600019f8 <configure_external_ram+0x25c>)
60001970:	07dc      	lsls	r4, r3, #31
60001972:	d5fb      	bpl.n	6000196c <configure_external_ram+0x1d0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001974:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001976:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001978:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000197c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000197e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001980:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001984:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001988:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000198c:	694b      	ldr	r3, [r1, #20]
6000198e:	4a1a      	ldr	r2, [pc, #104]	; (600019f8 <configure_external_ram+0x25c>)
60001990:	07d8      	lsls	r0, r3, #31
60001992:	d5fb      	bpl.n	6000198c <configure_external_ram+0x1f0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001994:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001996:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001998:	4824      	ldr	r0, [pc, #144]	; (60001a2c <configure_external_ram+0x290>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000199a:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000199c:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000199e:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
600019a2:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
600019a6:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
600019aa:	694b      	ldr	r3, [r1, #20]
600019ac:	4a12      	ldr	r2, [pc, #72]	; (600019f8 <configure_external_ram+0x25c>)
600019ae:	07db      	lsls	r3, r3, #31
600019b0:	d5fb      	bpl.n	600019aa <configure_external_ram+0x20e>
	uint32_t id = FLEXSPI2_RFDR0;
600019b2:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019b6:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019ba:	2021      	movs	r0, #33	; 0x21

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019bc:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019be:	6150      	str	r0, [r2, #20]

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019c0:	428b      	cmp	r3, r1
600019c2:	d039      	beq.n	60001a38 <configure_external_ram+0x29c>
			external_psram_size * 0x100000 -
			((uint32_t)&_extram_end - (uint32_t)&_extram_start),
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
600019c4:	4b1a      	ldr	r3, [pc, #104]	; (60001a30 <configure_external_ram+0x294>)
600019c6:	2200      	movs	r2, #0
600019c8:	601a      	str	r2, [r3, #0]
600019ca:	605a      	str	r2, [r3, #4]
600019cc:	609a      	str	r2, [r3, #8]
600019ce:	60da      	str	r2, [r3, #12]
	}
}
600019d0:	b003      	add	sp, #12
600019d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
600019d4:	401f8000 	.word	0x401f8000
600019d8:	000170f9 	.word	0x000170f9
600019dc:	0001b0f9 	.word	0x0001b0f9
600019e0:	000110f9 	.word	0x000110f9
600019e4:	000100f9 	.word	0x000100f9
600019e8:	401f8400 	.word	0x401f8400
600019ec:	400fc000 	.word	0x400fc000
600019f0:	1ffffcff 	.word	0x1ffffcff
600019f4:	a0000300 	.word	0xa0000300
600019f8:	402a4000 	.word	0x402a4000
600019fc:	ffff0012 	.word	0xffff0012
60001a00:	00f737ff 	.word	0x00f737ff
60001a04:	7cf0ff00 	.word	0x7cf0ff00
60001a08:	80000040 	.word	0x80000040
60001a0c:	830f00ff 	.word	0x830f00ff
60001a10:	00020063 	.word	0x00020063
60001a14:	402a4200 	.word	0x402a4200
60001a18:	402a4300 	.word	0x402a4300
60001a1c:	5af05af0 	.word	0x5af05af0
60001a20:	3018049f 	.word	0x3018049f
60001a24:	26013206 	.word	0x26013206
60001a28:	0a180638 	.word	0x0a180638
60001a2c:	00030004 	.word	0x00030004
60001a30:	200027a4 	.word	0x200027a4
60001a34:	402a8000 	.word	0x402a8000
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a38:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a3a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a3e:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a40:	4611      	mov	r1, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a42:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a46:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a4a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a4e:	694b      	ldr	r3, [r1, #20]
60001a50:	4a3b      	ldr	r2, [pc, #236]	; (60001b40 <configure_external_ram+0x3a4>)
60001a52:	07df      	lsls	r7, r3, #31
60001a54:	d5fb      	bpl.n	60001a4e <configure_external_ram+0x2b2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a56:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a58:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a5c:	2000      	movs	r0, #0
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a5e:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a60:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a62:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a66:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a6a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a6e:	694b      	ldr	r3, [r1, #20]
60001a70:	4a33      	ldr	r2, [pc, #204]	; (60001b40 <configure_external_ram+0x3a4>)
60001a72:	07de      	lsls	r6, r3, #31
60001a74:	d5fb      	bpl.n	60001a6e <configure_external_ram+0x2d2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a76:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a78:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a7c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a80:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a82:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a84:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a88:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a8c:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a90:	694b      	ldr	r3, [r1, #20]
60001a92:	4a2b      	ldr	r2, [pc, #172]	; (60001b40 <configure_external_ram+0x3a4>)
60001a94:	07dd      	lsls	r5, r3, #31
60001a96:	d5fb      	bpl.n	60001a90 <configure_external_ram+0x2f4>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a98:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a9a:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a9e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001aa2:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aa4:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001aa6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001aaa:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001aae:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ab2:	694b      	ldr	r3, [r1, #20]
60001ab4:	4a22      	ldr	r2, [pc, #136]	; (60001b40 <configure_external_ram+0x3a4>)
60001ab6:	07dc      	lsls	r4, r3, #31
60001ab8:	d5fb      	bpl.n	60001ab2 <configure_external_ram+0x316>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aba:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001abc:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001ac0:	4820      	ldr	r0, [pc, #128]	; (60001b44 <configure_external_ram+0x3a8>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ac2:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001ac4:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001ac6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001aca:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001ace:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ad2:	694b      	ldr	r3, [r1, #20]
60001ad4:	4a1a      	ldr	r2, [pc, #104]	; (60001b40 <configure_external_ram+0x3a4>)
60001ad6:	07d8      	lsls	r0, r3, #31
60001ad8:	d5fb      	bpl.n	60001ad2 <configure_external_ram+0x336>
	uint32_t id = FLEXSPI2_RFDR0;
60001ada:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ade:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae2:	2021      	movs	r0, #33	; 0x21
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae4:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae6:	6150      	str	r0, [r2, #20]
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae8:	428b      	cmp	r3, r1
60001aea:	d010      	beq.n	60001b0e <configure_external_ram+0x372>
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
		} else {
			// One PSRAM chip is present, 8 MByte
			external_psram_size = 8;
60001aec:	4b16      	ldr	r3, [pc, #88]	; (60001b48 <configure_external_ram+0x3ac>)
60001aee:	2208      	movs	r2, #8
60001af0:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
60001af4:	701a      	strb	r2, [r3, #0]
		}
		// TODO: zero uninitialized EXTMEM variables
		// TODO: copy from flash to initialize EXTMEM variables
		sm_set_pool(&extmem_smalloc_pool, &_extram_end,
60001af6:	4915      	ldr	r1, [pc, #84]	; (60001b4c <configure_external_ram+0x3b0>)
60001af8:	2000      	movs	r0, #0
60001afa:	4a15      	ldr	r2, [pc, #84]	; (60001b50 <configure_external_ram+0x3b4>)
60001afc:	2301      	movs	r3, #1
60001afe:	9000      	str	r0, [sp, #0]
60001b00:	1a52      	subs	r2, r2, r1
60001b02:	4814      	ldr	r0, [pc, #80]	; (60001b54 <configure_external_ram+0x3b8>)
60001b04:	4422      	add	r2, r4
60001b06:	f000 fabf 	bl	60002088 <__sm_set_pool_veneer>
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
	}
}
60001b0a:	b003      	add	sp, #12
60001b0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b0e:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b12:	f44f 2180 	mov.w	r1, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b16:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b18:	4610      	mov	r0, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b1a:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b1e:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b22:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b26:	6943      	ldr	r3, [r0, #20]
60001b28:	4905      	ldr	r1, [pc, #20]	; (60001b40 <configure_external_ram+0x3a4>)
60001b2a:	07db      	lsls	r3, r3, #31
60001b2c:	d5fb      	bpl.n	60001b26 <configure_external_ram+0x38a>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b2e:	2001      	movs	r0, #1
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b30:	4b05      	ldr	r3, [pc, #20]	; (60001b48 <configure_external_ram+0x3ac>)
60001b32:	2210      	movs	r2, #16
60001b34:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b38:	6148      	str	r0, [r1, #20]
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b3a:	701a      	strb	r2, [r3, #0]
60001b3c:	e7db      	b.n	60001af6 <configure_external_ram+0x35a>
60001b3e:	bf00      	nop
60001b40:	402a4000 	.word	0x402a4000
60001b44:	00030004 	.word	0x00030004
60001b48:	20002752 	.word	0x20002752
60001b4c:	70000000 	.word	0x70000000
60001b50:	70000000 	.word	0x70000000
60001b54:	200027a4 	.word	0x200027a4

60001b58 <usb_pll_start>:

#endif // ARDUINO_TEENSY41


FLASHMEM void usb_pll_start()
{
60001b58:	b4f0      	push	{r4, r5, r6, r7}
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b5a:	4a17      	ldr	r2, [pc, #92]	; (60001bb8 <usb_pll_start+0x60>)
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001b5c:	2740      	movs	r7, #64	; 0x40
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001b5e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b62:	f44f 5680 	mov.w	r6, #4096	; 0x1000
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b66:	f44f 5500 	mov.w	r5, #8192	; 0x2000
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b6a:	f44f 4440 	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b6e:	f243 0042 	movw	r0, #12354	; 0x3042


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b72:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b74:	f013 0f02 	tst.w	r3, #2
60001b78:	d006      	beq.n	60001b88 <usb_pll_start+0x30>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b7a:	6194      	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001b7c:	6151      	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b7e:	6190      	str	r0, [r2, #24]


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b80:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b82:	f013 0f02 	tst.w	r3, #2
60001b86:	d1f8      	bne.n	60001b7a <usb_pll_start+0x22>
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
60001b88:	f413 5f00 	tst.w	r3, #8192	; 0x2000
60001b8c:	d101      	bne.n	60001b92 <usb_pll_start+0x3a>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b8e:	6155      	str	r5, [r2, #20]
			continue;
60001b90:	e7ef      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001b92:	f413 5f80 	tst.w	r3, #4096	; 0x1000
60001b96:	d101      	bne.n	60001b9c <usb_pll_start+0x44>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b98:	6156      	str	r6, [r2, #20]
			continue;
60001b9a:	e7ea      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
60001b9c:	2b00      	cmp	r3, #0
60001b9e:	dae8      	bge.n	60001b72 <usb_pll_start+0x1a>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
60001ba0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
60001ba4:	d001      	beq.n	60001baa <usb_pll_start+0x52>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001ba6:	6191      	str	r1, [r2, #24]
			continue;
60001ba8:	e7e3      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
60001baa:	065b      	lsls	r3, r3, #25
60001bac:	d401      	bmi.n	60001bb2 <usb_pll_start+0x5a>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001bae:	6157      	str	r7, [r2, #20]
			continue;
60001bb0:	e7df      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		return; // everything is as it should be  :-)
	}
}
60001bb2:	bcf0      	pop	{r4, r5, r6, r7}
60001bb4:	4770      	bx	lr
60001bb6:	bf00      	nop
60001bb8:	400d8000 	.word	0x400d8000

60001bbc <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bbc:	4a39      	ldr	r2, [pc, #228]	; (60001ca4 <tempmon_init+0xe8>)

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bbe:	2003      	movs	r0, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bc0:	4939      	ldr	r1, [pc, #228]	; (60001ca8 <tempmon_init+0xec>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bc2:	eef3 5a09 	vmov.f32	s11, #57	; 0x41c80000  25.0
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bc6:	6813      	ldr	r3, [r2, #0]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001bc8:	ed9f 6a38 	vldr	s12, [pc, #224]	; 60001cac <tempmon_init+0xf0>
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bcc:	f023 0301 	bic.w	r3, r3, #1
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001bd0:	eddf 6a37 	vldr	s13, [pc, #220]	; 60001cb0 <tempmon_init+0xf4>
  //asm volatile ("dsb":::"memory");
  //while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
60001bd4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bd6:	6013      	str	r3, [r2, #0]
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001bd8:	2400      	movs	r4, #0
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bda:	6110      	str	r0, [r2, #16]
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bdc:	f8d1 30e0 	ldr.w	r3, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be0:	4f34      	ldr	r7, [pc, #208]	; (60001cb4 <tempmon_init+0xf8>)
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001be2:	b2d8      	uxtb	r0, r3
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001be4:	f3c3 210b 	ubfx	r1, r3, #8, #12
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be8:	0d1b      	lsrs	r3, r3, #20
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001bea:	4e33      	ldr	r6, [pc, #204]	; (60001cb8 <tempmon_init+0xfc>)
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bec:	ee07 0a10 	vmov	s14, r0
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bf0:	ee05 1a10 	vmov	s10, r1
60001bf4:	ee07 3a90 	vmov	s15, r3
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bf8:	4b30      	ldr	r3, [pc, #192]	; (60001cbc <tempmon_init+0x100>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bfa:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001bfe:	4d30      	ldr	r5, [pc, #192]	; (60001cc0 <tempmon_init+0x104>)
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c00:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001c04:	6030      	str	r0, [r6, #0]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001c0a:	6029      	str	r1, [r5, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c0c:	492d      	ldr	r1, [pc, #180]	; (60001cc4 <tempmon_init+0x108>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c0e:	ee37 6a46 	vsub.f32	s12, s14, s12
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c12:	4e2d      	ldr	r6, [pc, #180]	; (60001cc8 <tempmon_init+0x10c>)
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c14:	ee77 7ac5 	vsub.f32	s15, s15, s10
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
60001c18:	482c      	ldr	r0, [pc, #176]	; (60001ccc <tempmon_init+0x110>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c1a:	ee77 6a66 	vsub.f32	s13, s14, s13
60001c1e:	4d2c      	ldr	r5, [pc, #176]	; (60001cd0 <tempmon_init+0x114>)
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c20:	ee37 7a65 	vsub.f32	s14, s14, s11
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c24:	ee26 6a27 	vmul.f32	s12, s12, s15
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c28:	edc7 7a00 	vstr	s15, [r7]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c2c:	ee66 6aa7 	vmul.f32	s13, s13, s15
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c30:	6817      	ldr	r7, [r2, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c32:	ee67 7a27 	vmul.f32	s15, s14, s15
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c36:	ed83 7a00 	vstr	s14, [r3]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c3a:	eec6 5a07 	vdiv.f32	s11, s12, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c3e:	ee86 6a87 	vdiv.f32	s12, s13, s14
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c42:	eec7 6a87 	vdiv.f32	s13, s15, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c46:	ee35 7a85 	vadd.f32	s14, s11, s10
60001c4a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c4e:	ee36 7a05 	vadd.f32	s14, s12, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c52:	ee17 3a90 	vmov	r3, s15
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c56:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c5a:	ea47 5303 	orr.w	r3, r7, r3, lsl #20
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c5e:	ee76 7a85 	vadd.f32	s15, s13, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c62:	6013      	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c64:	ee17 3a10 	vmov	r3, s14
60001c68:	f8d2 7110 	ldr.w	r7, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c6c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c70:	ea01 4103 	and.w	r1, r1, r3, lsl #16
60001c74:	4339      	orrs	r1, r7
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c76:	ee17 3a90 	vmov	r3, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c7a:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c7e:	f3c3 030b 	ubfx	r3, r3, #0, #12
60001c82:	f8d2 1110 	ldr.w	r1, [r2, #272]	; 0x110
60001c86:	430b      	orrs	r3, r1
60001c88:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
60001c8c:	6813      	ldr	r3, [r2, #0]
60001c8e:	f043 0302 	orr.w	r3, r3, #2
60001c92:	6013      	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c94:	7034      	strb	r4, [r6, #0]
60001c96:	f8c0 5140 	str.w	r5, [r0, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001c9a:	4b0e      	ldr	r3, [pc, #56]	; (60001cd4 <tempmon_init+0x118>)
60001c9c:	2201      	movs	r2, #1
}
60001c9e:	bcf0      	pop	{r4, r5, r6, r7}
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001ca0:	601a      	str	r2, [r3, #0]
}
60001ca2:	4770      	bx	lr
60001ca4:	400d8180 	.word	0x400d8180
60001ca8:	401f4400 	.word	0x401f4400
60001cac:	42aa0000 	.word	0x42aa0000
60001cb0:	42b40000 	.word	0x42b40000
60001cb4:	20002734 	.word	0x20002734
60001cb8:	2000272c 	.word	0x2000272c
60001cbc:	20002730 	.word	0x20002730
60001cc0:	20002728 	.word	0x20002728
60001cc4:	0fff0000 	.word	0x0fff0000
60001cc8:	e000e440 	.word	0xe000e440
60001ccc:	20002000 	.word	0x20002000
60001cd0:	00001d31 	.word	0x00001d31
60001cd4:	e000e108 	.word	0xe000e108

60001cd8 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001cd8:	4b30      	ldr	r3, [pc, #192]	; (60001d9c <usb_init+0xc4>)
60001cda:	f640 7261 	movw	r2, #3937	; 0xf61

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
60001cde:	b570      	push	{r4, r5, r6, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001ce0:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001ce4:	f240 4504 	movw	r5, #1028	; 0x404
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
60001ce8:	f000 f9c6 	bl	60002078 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cec:	492c      	ldr	r1, [pc, #176]	; (60001da0 <usb_init+0xc8>)
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001cee:	482d      	ldr	r0, [pc, #180]	; (60001da4 <usb_init+0xcc>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf0:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cf4:	4c2c      	ldr	r4, [pc, #176]	; (60001da8 <usb_init+0xd0>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf6:	f042 0203 	orr.w	r2, r2, #3
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cfa:	4b2c      	ldr	r3, [pc, #176]	; (60001dac <usb_init+0xd4>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cfc:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001d00:	f8c0 5160 	str.w	r5, [r0, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001d04:	6822      	ldr	r2, [r4, #0]
60001d06:	4013      	ands	r3, r2
60001d08:	b91b      	cbnz	r3, 60001d12 <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
60001d0a:	f8d0 31a8 	ldr.w	r3, [r0, #424]	; 0x1a8
60001d0e:	079a      	lsls	r2, r3, #30
60001d10:	d01a      	beq.n	60001d48 <usb_init+0x70>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d12:	4b24      	ldr	r3, [pc, #144]	; (60001da4 <usb_init+0xcc>)
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001d14:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
60001d18:	4a23      	ldr	r2, [pc, #140]	; (60001da8 <usb_init+0xd0>)
60001d1a:	6351      	str	r1, [r2, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d1c:	461a      	mov	r2, r3
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d1e:	f8d3 1140 	ldr.w	r1, [r3, #320]	; 0x140
60001d22:	f041 0102 	orr.w	r1, r1, #2
60001d26:	f8c3 1140 	str.w	r1, [r3, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d2a:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001d2e:	079b      	lsls	r3, r3, #30
60001d30:	d4fb      	bmi.n	60001d2a <usb_init+0x52>
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d32:	f44f 3000 	mov.w	r0, #131072	; 0x20000
60001d36:	491e      	ldr	r1, [pc, #120]	; (60001db0 <usb_init+0xd8>)
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d38:	4b1b      	ldr	r3, [pc, #108]	; (60001da8 <usb_init+0xd0>)
60001d3a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d3e:	6008      	str	r0, [r1, #0]
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d40:	2019      	movs	r0, #25
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d42:	639a      	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d44:	f000 f9a4 	bl	60002090 <__delay_veneer>
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d48:	4d1a      	ldr	r5, [pc, #104]	; (60001db4 <usb_init+0xdc>)
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d4a:	2200      	movs	r2, #0
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d4c:	4b16      	ldr	r3, [pc, #88]	; (60001da8 <usb_init+0xd0>)
60001d4e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d52:	4c14      	ldr	r4, [pc, #80]	; (60001da4 <usb_init+0xcc>)
60001d54:	260a      	movs	r6, #10
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d56:	6399      	str	r1, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d58:	4628      	mov	r0, r5
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d5a:	601a      	str	r2, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d5c:	4611      	mov	r1, r2
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d5e:	f8c4 61a8 	str.w	r6, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d62:	f44f 7220 	mov.w	r2, #640	; 0x280
60001d66:	f000 f97f 	bl	60002068 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d6a:	f44f 0681 	mov.w	r6, #4227072	; 0x408000
	endpoint_queue_head[1].config = (64 << 16);
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d6e:	f240 1143 	movw	r1, #323	; 0x143
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
	endpoint_queue_head[1].config = (64 << 16);
60001d72:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
60001d76:	4b10      	ldr	r3, [pc, #64]	; (60001db8 <usb_init+0xe0>)
60001d78:	4a10      	ldr	r2, [pc, #64]	; (60001dbc <usb_init+0xe4>)
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d7a:	602e      	str	r6, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
60001d7c:	6428      	str	r0, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001d7e:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d82:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
60001d86:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d8a:	4a0d      	ldr	r2, [pc, #52]	; (60001dc0 <usb_init+0xe8>)
60001d8c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d90:	2301      	movs	r3, #1
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d92:	6011      	str	r1, [r2, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d94:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
60001d98:	bd70      	pop	{r4, r5, r6, pc}
60001d9a:	bf00      	nop
60001d9c:	400d8000 	.word	0x400d8000
60001da0:	400fc000 	.word	0x400fc000
60001da4:	402e0000 	.word	0x402e0000
60001da8:	400d9000 	.word	0x400d9000
60001dac:	001e1c00 	.word	0x001e1c00
60001db0:	e000e28c 	.word	0xe000e28c
60001db4:	20000000 	.word	0x20000000
60001db8:	20002000 	.word	0x20002000
60001dbc:	00001efd 	.word	0x00001efd
60001dc0:	e000e10c 	.word	0xe000e10c

60001dc4 <_reboot_Teensyduino_>:
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


FLASHMEM void _reboot_Teensyduino_(void)
{
60001dc4:	b508      	push	{r3, lr}
	if (!(HW_OCOTP_CFG5 & 0x02)) {
60001dc6:	4b0e      	ldr	r3, [pc, #56]	; (60001e00 <_reboot_Teensyduino_+0x3c>)
60001dc8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
60001dca:	079b      	lsls	r3, r3, #30
60001dcc:	d400      	bmi.n	60001dd0 <_reboot_Teensyduino_+0xc>
		asm("bkpt #251"); // run bootloader
60001dce:	befb      	bkpt	0x00fb
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
60001dd0:	b672      	cpsid	i
		USB1_USBCMD = 0;
60001dd2:	4b0c      	ldr	r3, [pc, #48]	; (60001e04 <_reboot_Teensyduino_+0x40>)
60001dd4:	2000      	movs	r0, #0
		IOMUXC_GPR_GPR16 = 0x00200003;
60001dd6:	4a0c      	ldr	r2, [pc, #48]	; (60001e08 <_reboot_Teensyduino_+0x44>)
{
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
60001dd8:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001ddc:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de0:	490a      	ldr	r1, [pc, #40]	; (60001e0c <_reboot_Teensyduino_+0x48>)
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de2:	f5a3 235f 	sub.w	r3, r3, #913408	; 0xdf000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de6:	6411      	str	r1, [r2, #64]	; 0x40
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de8:	469d      	mov	sp, r3
		__asm__ volatile("dsb":::"memory");
60001dea:	f3bf 8f4f 	dsb	sy
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dee:	4a08      	ldr	r2, [pc, #32]	; (60001e10 <_reboot_Teensyduino_+0x4c>)
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001df0:	f503 43e0 	add.w	r3, r3, #28672	; 0x7000
60001df4:	4907      	ldr	r1, [pc, #28]	; (60001e14 <_reboot_Teensyduino_+0x50>)
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001df6:	6812      	ldr	r2, [r2, #0]
60001df8:	4618      	mov	r0, r3
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001dfa:	6019      	str	r1, [r3, #0]
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dfc:	6893      	ldr	r3, [r2, #8]
60001dfe:	4798      	blx	r3
60001e00:	401f4400 	.word	0x401f4400
60001e04:	402e0000 	.word	0x402e0000
60001e08:	400ac000 	.word	0x400ac000
60001e0c:	00200003 	.word	0x00200003
60001e10:	0020001c 	.word	0x0020001c
60001e14:	eb120000 	.word	0xeb120000

60001e18 <TwoWire::begin()>:
//***************************************************
//  Master Mode
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
60001e18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e1c:	4f29      	ldr	r7, [pc, #164]	; (60001ec4 <TwoWire::begin()+0xac>)
#define CLOCK_STRETCH_TIMEOUT 15000


void TwoWire::setClock(uint32_t frequency)
{
	port->MCR = 0;
60001e1e:	2500      	movs	r5, #0

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e20:	6942      	ldr	r2, [r0, #20]
	port->MCR = 0;
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
60001e22:	2401      	movs	r4, #1
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e24:	6bb9      	ldr	r1, [r7, #56]	; 0x38
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e26:	f04f 0e02 	mov.w	lr, #2

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e2a:	6816      	ldr	r6, [r2, #0]
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1);
60001e2c:	f44f 3830 	mov.w	r8, #180224	; 0x2c000
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e30:	f421 017c 	bic.w	r1, r1, #16515072	; 0xfc0000
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e34:	6903      	ldr	r3, [r0, #16]
{
	port->MCR = 0;
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
60001e36:	f8df c09c 	ldr.w	ip, [pc, #156]	; 60001ed4 <TwoWire::begin()+0xbc>
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e3a:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
60001e3e:	63b9      	str	r1, [r7, #56]	; 0x38
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e40:	6831      	ldr	r1, [r6, #0]
60001e42:	6857      	ldr	r7, [r2, #4]
60001e44:	4339      	orrs	r1, r7
60001e46:	6031      	str	r1, [r6, #0]
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
	port->MCFGR0 = 0;
	port->MFCR = LPI2C_MFCR_RXWATER(1) | LPI2C_MFCR_TXWATER(1);
60001e48:	f04f 1601 	mov.w	r6, #65537	; 0x10001
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
60001e4c:	491e      	ldr	r1, [pc, #120]	; (60001ec8 <TwoWire::begin()+0xb0>)
FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e4e:	f8c3 e010 	str.w	lr, [r3, #16]
#define CLOCK_STRETCH_TIMEOUT 15000


void TwoWire::setClock(uint32_t frequency)
{
	port->MCR = 0;
60001e52:	611d      	str	r5, [r3, #16]
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
60001e54:	f8c3 c048 	str.w	ip, [r3, #72]	; 0x48
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
60001e58:	625c      	str	r4, [r3, #36]	; 0x24
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
60001e5a:	6299      	str	r1, [r3, #40]	; 0x28
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1);
60001e5c:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | LPI2C_MCFGR2_FILTSCL(1) |
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
60001e60:	6c9f      	ldr	r7, [r3, #72]	; 0x48
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001e62:	491a      	ldr	r1, [pc, #104]	; (60001ecc <TwoWire::begin()+0xb4>)
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | LPI2C_MCFGR2_FILTSCL(1) |
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
60001e64:	651f      	str	r7, [r3, #80]	; 0x50
	port->MCFGR0 = 0;
60001e66:	621d      	str	r5, [r3, #32]
	port->MFCR = LPI2C_MFCR_RXWATER(1) | LPI2C_MFCR_TXWATER(1);
60001e68:	659e      	str	r6, [r3, #88]	; 0x58
	port->MCR = LPI2C_MCR_MEN;
60001e6a:	611c      	str	r4, [r3, #16]
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
	setClock(100000);
	// setSDA() & setSCL() may be called before or after begin()
	configSDApin(sda_pin_index_); // Setup SDA register
60001e6c:	7e03      	ldrb	r3, [r0, #24]
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001e6e:	4e18      	ldr	r6, [pc, #96]	; (60001ed0 <TwoWire::begin()+0xb8>)
60001e70:	eb02 1503 	add.w	r5, r2, r3, lsl #4
60001e74:	7a2c      	ldrb	r4, [r5, #8]
60001e76:	462b      	mov	r3, r5
60001e78:	eb01 1404 	add.w	r4, r1, r4, lsl #4
60001e7c:	68a4      	ldr	r4, [r4, #8]
60001e7e:	6026      	str	r6, [r4, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001e80:	7a2c      	ldrb	r4, [r5, #8]
60001e82:	68ed      	ldr	r5, [r5, #12]
60001e84:	eb01 1404 	add.w	r4, r1, r4, lsl #4
60001e88:	6864      	ldr	r4, [r4, #4]
60001e8a:	6025      	str	r5, [r4, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001e8c:	691c      	ldr	r4, [r3, #16]
60001e8e:	b10c      	cbz	r4, 60001e94 <TwoWire::begin()+0x7c>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001e90:	695b      	ldr	r3, [r3, #20]
60001e92:	6023      	str	r3, [r4, #0]
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
	setClock(100000);
	// setSDA() & setSCL() may be called before or after begin()
	configSDApin(sda_pin_index_); // Setup SDA register
	configSCLpin(scl_pin_index_); // setup SCL register
60001e94:	7e40      	ldrb	r0, [r0, #25]
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001e96:	4c0e      	ldr	r4, [pc, #56]	; (60001ed0 <TwoWire::begin()+0xb8>)
60001e98:	eb02 1300 	add.w	r3, r2, r0, lsl #4
60001e9c:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
60001ea0:	461a      	mov	r2, r3
60001ea2:	eb01 1000 	add.w	r0, r1, r0, lsl #4
60001ea6:	6880      	ldr	r0, [r0, #8]
60001ea8:	6004      	str	r4, [r0, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60001eaa:	f893 4028 	ldrb.w	r4, [r3, #40]	; 0x28
60001eae:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
60001eb0:	eb01 1104 	add.w	r1, r1, r4, lsl #4
60001eb4:	684b      	ldr	r3, [r1, #4]
60001eb6:	6018      	str	r0, [r3, #0]
	if (hardware.scl_pins[i].select_input_register) {
60001eb8:	6b13      	ldr	r3, [r2, #48]	; 0x30
60001eba:	b10b      	cbz	r3, 60001ec0 <TwoWire::begin()+0xa8>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
60001ebc:	6b52      	ldr	r2, [r2, #52]	; 0x34
60001ebe:	601a      	str	r2, [r3, #0]
60001ec0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
60001ec4:	400fc000 	.word	0x400fc000
60001ec8:	05050bb8 	.word	0x05050bb8
60001ecc:	200006dc 	.word	0x200006dc
60001ed0:	0001f861 	.word	0x0001f861
60001ed4:	1928373b 	.word	0x1928373b

60001ed8 <TwoWire::setSDA(unsigned char)>:
//  Pins Configuration
//***************************************************


FLASHMEM void TwoWire::setSDA(uint8_t pin) {
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
60001ed8:	6943      	ldr	r3, [r0, #20]
60001eda:	7e02      	ldrb	r2, [r0, #24]
60001edc:	eb03 1202 	add.w	r2, r3, r2, lsl #4
//***************************************************
//  Pins Configuration
//***************************************************


FLASHMEM void TwoWire::setSDA(uint8_t pin) {
60001ee0:	b4f0      	push	{r4, r5, r6, r7}
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
60001ee2:	7a14      	ldrb	r4, [r2, #8]
60001ee4:	428c      	cmp	r4, r1
60001ee6:	d009      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
60001ee8:	7a1a      	ldrb	r2, [r3, #8]
		if (sda_pin == 255) return;
60001eea:	2aff      	cmp	r2, #255	; 0xff
60001eec:	d006      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
		if (sda_pin == pin) break;
60001eee:	428a      	cmp	r2, r1
60001ef0:	d028      	beq.n	60001f44 <TwoWire::setSDA(unsigned char)+0x6c>

FLASHMEM void TwoWire::setSDA(uint8_t pin) {
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
60001ef2:	7e1a      	ldrb	r2, [r3, #24]
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
60001ef4:	2aff      	cmp	r2, #255	; 0xff
60001ef6:	d001      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
60001ef8:	428a      	cmp	r2, r1
60001efa:	d001      	beq.n	60001f00 <TwoWire::setSDA(unsigned char)+0x28>
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
		// setup new one...
		configSDApin(newindex);
	}
	sda_pin_index_ = newindex;
}
60001efc:	bcf0      	pop	{r4, r5, r6, r7}
60001efe:	4770      	bx	lr
60001f00:	2501      	movs	r5, #1
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
60001f02:	462e      	mov	r6, r5
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
60001f04:	e893 0006 	ldmia.w	r3, {r1, r2}
60001f08:	6809      	ldr	r1, [r1, #0]
60001f0a:	4211      	tst	r1, r2
60001f0c:	d017      	beq.n	60001f3e <TwoWire::setSDA(unsigned char)+0x66>
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f0e:	4a0f      	ldr	r2, [pc, #60]	; (60001f4c <TwoWire::setSDA(unsigned char)+0x74>)
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f10:	eb03 1306 	add.w	r3, r3, r6, lsl #4
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f14:	2705      	movs	r7, #5
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f16:	4e0e      	ldr	r6, [pc, #56]	; (60001f50 <TwoWire::setSDA(unsigned char)+0x78>)
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f18:	eb02 1404 	add.w	r4, r2, r4, lsl #4
60001f1c:	6861      	ldr	r1, [r4, #4]
60001f1e:	600f      	str	r7, [r1, #0]
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f20:	7a19      	ldrb	r1, [r3, #8]
60001f22:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001f26:	6889      	ldr	r1, [r1, #8]
60001f28:	600e      	str	r6, [r1, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001f2a:	7a1c      	ldrb	r4, [r3, #8]
60001f2c:	68d9      	ldr	r1, [r3, #12]
60001f2e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001f32:	6852      	ldr	r2, [r2, #4]
60001f34:	6011      	str	r1, [r2, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001f36:	691a      	ldr	r2, [r3, #16]
60001f38:	b10a      	cbz	r2, 60001f3e <TwoWire::setSDA(unsigned char)+0x66>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001f3a:	695b      	ldr	r3, [r3, #20]
60001f3c:	6013      	str	r3, [r2, #0]
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
		// setup new one...
		configSDApin(newindex);
	}
	sda_pin_index_ = newindex;
60001f3e:	7605      	strb	r5, [r0, #24]
}
60001f40:	bcf0      	pop	{r4, r5, r6, r7}
60001f42:	4770      	bx	lr
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
60001f44:	2500      	movs	r5, #0
60001f46:	462e      	mov	r6, r5
60001f48:	e7dc      	b.n	60001f04 <TwoWire::setSDA(unsigned char)+0x2c>
60001f4a:	bf00      	nop
60001f4c:	200006dc 	.word	0x200006dc
60001f50:	0001f861 	.word	0x0001f861

60001f54 <TwoWire::configSDApin(unsigned char)>:
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f54:	6943      	ldr	r3, [r0, #20]
60001f56:	4a0b      	ldr	r2, [pc, #44]	; (60001f84 <TwoWire::configSDApin(unsigned char)+0x30>)
60001f58:	eb03 1001 	add.w	r0, r3, r1, lsl #4
	}
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
60001f5c:	b410      	push	{r4}
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f5e:	7a01      	ldrb	r1, [r0, #8]
60001f60:	4c09      	ldr	r4, [pc, #36]	; (60001f88 <TwoWire::configSDApin(unsigned char)+0x34>)
60001f62:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001f66:	6889      	ldr	r1, [r1, #8]
60001f68:	600c      	str	r4, [r1, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001f6a:	7a04      	ldrb	r4, [r0, #8]
60001f6c:	68c1      	ldr	r1, [r0, #12]
60001f6e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001f72:	6852      	ldr	r2, [r2, #4]
60001f74:	6011      	str	r1, [r2, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001f76:	6902      	ldr	r2, [r0, #16]
60001f78:	b10a      	cbz	r2, 60001f7e <TwoWire::configSDApin(unsigned char)+0x2a>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001f7a:	6943      	ldr	r3, [r0, #20]
60001f7c:	6013      	str	r3, [r2, #0]
	}
}
60001f7e:	f85d 4b04 	ldr.w	r4, [sp], #4
60001f82:	4770      	bx	lr
60001f84:	200006dc 	.word	0x200006dc
60001f88:	0001f861 	.word	0x0001f861

60001f8c <TwoWire::setSCL(unsigned char)>:

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
60001f8c:	6943      	ldr	r3, [r0, #20]
60001f8e:	7e42      	ldrb	r2, [r0, #25]
60001f90:	eb03 1202 	add.w	r2, r3, r2, lsl #4
	if (hardware.sda_pins[i].select_input_register) {
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
	}
}

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
60001f94:	b4f0      	push	{r4, r5, r6, r7}
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
60001f96:	f892 4028 	ldrb.w	r4, [r2, #40]	; 0x28
60001f9a:	428c      	cmp	r4, r1
60001f9c:	d00b      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
60001f9e:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
		if (scl_pin == 255) return;
60001fa2:	2aff      	cmp	r2, #255	; 0xff
60001fa4:	d007      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
		if (scl_pin == pin) break;
60001fa6:	428a      	cmp	r2, r1
60001fa8:	d02b      	beq.n	60002002 <TwoWire::setSCL(unsigned char)+0x76>

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
60001faa:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
60001fae:	2aff      	cmp	r2, #255	; 0xff
60001fb0:	d001      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
60001fb2:	428a      	cmp	r2, r1
60001fb4:	d001      	beq.n	60001fba <TwoWire::setSCL(unsigned char)+0x2e>
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
		// setup new one...
		configSCLpin(newindex);
	}
	scl_pin_index_ = newindex;
}
60001fb6:	bcf0      	pop	{r4, r5, r6, r7}
60001fb8:	4770      	bx	lr
60001fba:	2501      	movs	r5, #1
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
60001fbc:	462e      	mov	r6, r5
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
60001fbe:	e893 0006 	ldmia.w	r3, {r1, r2}
60001fc2:	6809      	ldr	r1, [r1, #0]
60001fc4:	4211      	tst	r1, r2
60001fc6:	d019      	beq.n	60001ffc <TwoWire::setSCL(unsigned char)+0x70>
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fc8:	4a0f      	ldr	r2, [pc, #60]	; (60002008 <TwoWire::setSCL(unsigned char)+0x7c>)
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fca:	eb03 1306 	add.w	r3, r3, r6, lsl #4
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fce:	2705      	movs	r7, #5
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fd0:	4e0e      	ldr	r6, [pc, #56]	; (6000200c <TwoWire::setSCL(unsigned char)+0x80>)
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fd2:	eb02 1404 	add.w	r4, r2, r4, lsl #4
60001fd6:	6861      	ldr	r1, [r4, #4]
60001fd8:	600f      	str	r7, [r1, #0]
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fda:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
60001fde:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001fe2:	6889      	ldr	r1, [r1, #8]
60001fe4:	600e      	str	r6, [r1, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60001fe6:	f893 4028 	ldrb.w	r4, [r3, #40]	; 0x28
60001fea:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
60001fec:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001ff0:	6852      	ldr	r2, [r2, #4]
60001ff2:	6011      	str	r1, [r2, #0]
	if (hardware.scl_pins[i].select_input_register) {
60001ff4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
60001ff6:	b10a      	cbz	r2, 60001ffc <TwoWire::setSCL(unsigned char)+0x70>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
60001ff8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
60001ffa:	6013      	str	r3, [r2, #0]
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
		// setup new one...
		configSCLpin(newindex);
	}
	scl_pin_index_ = newindex;
60001ffc:	7645      	strb	r5, [r0, #25]
}
60001ffe:	bcf0      	pop	{r4, r5, r6, r7}
60002000:	4770      	bx	lr
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
60002002:	2500      	movs	r5, #0
60002004:	462e      	mov	r6, r5
60002006:	e7da      	b.n	60001fbe <TwoWire::setSCL(unsigned char)+0x32>
60002008:	200006dc 	.word	0x200006dc
6000200c:	0001f861 	.word	0x0001f861

60002010 <TwoWire::configSCLpin(unsigned char)>:
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60002010:	6943      	ldr	r3, [r0, #20]
60002012:	4a0c      	ldr	r2, [pc, #48]	; (60002044 <TwoWire::configSCLpin(unsigned char)+0x34>)
60002014:	eb03 1001 	add.w	r0, r3, r1, lsl #4
	}
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
60002018:	b410      	push	{r4}
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
6000201a:	f890 1028 	ldrb.w	r1, [r0, #40]	; 0x28
6000201e:	4c0a      	ldr	r4, [pc, #40]	; (60002048 <TwoWire::configSCLpin(unsigned char)+0x38>)
60002020:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60002024:	6889      	ldr	r1, [r1, #8]
60002026:	600c      	str	r4, [r1, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60002028:	f890 4028 	ldrb.w	r4, [r0, #40]	; 0x28
6000202c:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
6000202e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60002032:	6852      	ldr	r2, [r2, #4]
60002034:	6011      	str	r1, [r2, #0]
	if (hardware.scl_pins[i].select_input_register) {
60002036:	6b02      	ldr	r2, [r0, #48]	; 0x30
60002038:	b10a      	cbz	r2, 6000203e <TwoWire::configSCLpin(unsigned char)+0x2e>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
6000203a:	6b43      	ldr	r3, [r0, #52]	; 0x34
6000203c:	6013      	str	r3, [r2, #0]
	}
}
6000203e:	f85d 4b04 	ldr.w	r4, [sp], #4
60002042:	4770      	bx	lr
60002044:	200006dc 	.word	0x200006dc
60002048:	0001f861 	.word	0x0001f861

6000204c <_init>:
6000204c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000204e:	bf00      	nop
60002050:	bcf8      	pop	{r3, r4, r5, r6, r7}
60002052:	bc08      	pop	{r3}
60002054:	469e      	mov	lr, r3
60002056:	4770      	bx	lr

60002058 <__set_arm_clock_veneer>:
60002058:	f85f f000 	ldr.w	pc, [pc]	; 6000205c <__set_arm_clock_veneer+0x4>
6000205c:	00001345 	.word	0x00001345

60002060 <____libc_init_array_veneer>:
60002060:	f85f f000 	ldr.w	pc, [pc]	; 60002064 <____libc_init_array_veneer+0x4>
60002064:	00006565 	.word	0x00006565

60002068 <__memset_veneer>:
60002068:	f85f f000 	ldr.w	pc, [pc]	; 6000206c <__memset_veneer+0x4>
6000206c:	00006da1 	.word	0x00006da1

60002070 <__pwm_init_veneer>:
60002070:	f85f f000 	ldr.w	pc, [pc]	; 60002074 <__pwm_init_veneer+0x4>
60002074:	000017a5 	.word	0x000017a5

60002078 <__usb_init_serialnumber_veneer>:
60002078:	f85f f000 	ldr.w	pc, [pc]	; 6000207c <__usb_init_serialnumber_veneer+0x4>
6000207c:	00002661 	.word	0x00002661

60002080 <__main_veneer>:
60002080:	f85f f000 	ldr.w	pc, [pc]	; 60002084 <__main_veneer+0x4>
60002084:	000008b1 	.word	0x000008b1

60002088 <__sm_set_pool_veneer>:
60002088:	f85f f000 	ldr.w	pc, [pc]	; 6000208c <__sm_set_pool_veneer+0x4>
6000208c:	00001add 	.word	0x00001add

60002090 <__delay_veneer>:
60002090:	f85f f000 	ldr.w	pc, [pc]	; 60002094 <__delay_veneer+0x4>
60002094:	00001609 	.word	0x00001609

60002098 <__init_array_start>:
60002098:	00000045 	.word	0x00000045
6000209c:	00002df9 	.word	0x00002df9

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      20:	4c05b510 	.word	0x4c05b510
      24:	7823      	ldrb	r3, [r4, #0]
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      26:	b933      	.short	0xb933
      28:	4b04      	ldr	r3, [pc, #16]	; (3c <_teensy_model_identifier+0x17>)
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      2a:	b113      	.short	0xb113
      2c:	4804      	ldr	r0, [pc, #16]	; (40 <_teensy_model_identifier+0x1b>)
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      2e:	f3af 8000 	nop.w
      32:	2301      	.short	0x2301
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      34:	7023      	strb	r3, [r4, #0]
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
      36:	bd10      	.short	0xbd10
      38:	2668      	movs	r6, #104	; 0x68
      3a:	2000      	.short	0x2000
      3c:	0000      	movs	r0, r0
      3e:	0000      	.short	0x0000
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
      40:	a844      	add	r0, sp, #272	; 0x110
	...

00000044 <frame_dummy>:

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      44:	b5104b08 	.word	0xb5104b08
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      48:	b11b      	cbz	r3, 52 <frame_dummy+0xe>
      4a:	4908      	.short	0x4908
      4c:	4808      	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	f3af      	.short	0xf3af
      50:	8000      	strh	r0, [r0, #0]
      52:	4808      	.short	0x4808
      54:	6803      	ldr	r3, [r0, #0]
      56:	b903      	.short	0xb903
      58:	bd10      	pop	{r4, pc}
      5a:	4b07      	.short	0x4b07
      5c:	2b00      	cmp	r3, #0
      5e:	d0fb      	.short	0xd0fb
      60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      64:	4718      	bx	r3
      66:	bf00      	nop
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      68:	0000      	movs	r0, r0
      6a:	0000      	movs	r0, r0
			yield(); // TODO: what happens if yield-called code uses analogRead()
      6c:	266c      	movs	r6, #108	; 0x6c
      6e:	2000      	movs	r0, #0
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      70:	a844      	add	r0, sp, #272	; 0x110
      72:	0000      	.short	0x0000
      74:	22c0      	movs	r2, #192	; 0xc0
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC2_R0;
      76:	2000      	movs	r0, #0
      78:	0000      	movs	r0, r0
	...

0000007c <Adafruit_Sensor::enableAutoRange(bool)>:
  // These must be defined by the subclass

  /*! @brief Whether we should automatically change the range (if possible) for
     higher precision
      @param enabled True if we will try to autorange */
  virtual void enableAutoRange(bool enabled) {
      7c:	4770      	bx	lr
      7e:	bf00      	nop

00000080 <ComplimentaryFilter::clear()>:
			K = DEFAULT_GAIN;
			clear();
		}

		void clear() {
			axz_norm = 0;
      80:	2300      	movs	r3, #0
      82:	6343      	str	r3, [r0, #52]	; 0x34
			ayz_norm = 0;
      84:	6383      	str	r3, [r0, #56]	; 0x38
			mag_norm = 0;
      86:	63c3      	str	r3, [r0, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
      88:	65036443 	.word	0x65036443
				q_accel[i] = 0;
				bias_accel[i] = 0;
      8c:	65c3      	str	r3, [r0, #92]	; 0x5c
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
      8e:	6483      	.short	0x6483
				q_accel[i] = 0;
      90:	6543      	str	r3, [r0, #84]	; 0x54
				bias_accel[i] = 0;
      92:	6603      	.short	0x6603
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
      94:	64c3      	str	r3, [r0, #76]	; 0x4c
				q_accel[i] = 0;
      96:	6583      	.short	0x6583
				bias_accel[i] = 0;
      98:	6643      	str	r3, [r0, #100]	; 0x64
      9a:	4770      	.short	0x4770

0000009c <ComplimentaryFilter::run(Vector<float>*, Vector<float>*)>:
    durbits.write(duration);

    Adafruit_BusIO_Register wake_ths = Adafruit_BusIO_Register(
        i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WAKEUP_THS);
    Adafruit_BusIO_RegisterBits thsbits =
        Adafruit_BusIO_RegisterBits(&wake_ths, 6, 0);
      9c:	b5f0      	push	{r4, r5, r6, r7, lr}
      9e:	f100      	.short	0xf100
      a0:	060c      	lsls	r4, r1, #24
      a2:	4604      	mov	r4, r0
    thsbits.write(thresh);
      a4:	2100460d 	.word	0x2100460d
      a8:	4630      	mov	r0, r6
      aa:	4617      	mov	r7, r2
  }
}
      ac:	8b0eed2d 	.word	0x8b0eed2d
      b0:	b091      	sub	sp, #68	; 0x44
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
	NVIC_ENABLE_IRQ(hardware.irq_number);
      b2:	f000 ff3d 	bl	f30 <FTYK::micros(int)>
      b6:	4630      	mov	r0, r6
	port->SIER = LPI2C_SIER_TDIE |  LPI2C_SIER_RDIE | LPI2C_SIER_SDIE;
      b8:	2100      	movs	r1, #0
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
	NVIC_ENABLE_IRQ(hardware.irq_number);
      ba:	eeb0 ea40 	vmov.f32	s28, s0
      be:	f000      	.short	0xf000
      c0:	ff2f 4628 	vmax.u32	d4, d15, d24
      c4:	a904      	add	r1, sp, #16
      c6:	2303      	.short	0x2303
      c8:	2200      	movs	r2, #0
      ca:	f001      	.short	0xf001
	port->SIER = LPI2C_SIER_TDIE |  LPI2C_SIER_RDIE | LPI2C_SIER_SDIE;
      cc:	f8a7 4628 	strh.w	r4, [r7, #1576]	; 0x628
	transmitting = 0;
      d0:	2306      	movs	r3, #6
      d2:	2203      	movs	r2, #3
	slave_mode = 1;
      d4:	a907      	add	r1, sp, #28
      d6:	f001 f8a1 	bl	121c <Vector<float>::slice(float*, int, int)>
	port->SCR = LPI2C_SCR_SEN;
      da:	4628      	mov	r0, r5
      dc:	a90a      	add	r1, sp, #40	; 0x28
      de:	2309      	.short	0x2309
      e0:	2206      	movs	r2, #6
      e2:	f001      	.short	0xf001
      e4:	f89b 4628 	ldrb.w	r4, [fp, #1576]	; 0x628
      e8:	230ca90d 	.word	0x230ca90d
      ec:	2209      	movs	r2, #9
      ee:	f001      	.short	0xf001
      f0:	f895 9b09 	ldrb.w	r9, [r5, #2825]	; 0xb09
      f4:	9a08      	ldr	r2, [sp, #32]
      f6:	2102      	movs	r1, #2
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
      f8:	46689d07 	.word	0x46689d07
      fc:	9301      	str	r3, [sp, #4]
			float ayz[2] = {accel[1], accel[2]};
      fe:	9303      	.short	0x9303
     100:	9202      	str	r2, [sp, #8]
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
     102:	9500      	.short	0x9500
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     104:	f000 fc94 	bl	a30 <nd_norm(float*, int)>
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     108:	2102      	movs	r1, #2
     10a:	a802      	add	r0, sp, #8
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     10c:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     110:	f000 fc8e 	bl	a30 <nd_norm(float*, int)>
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     114:	a80d      	add	r0, sp, #52	; 0x34
     116:	2103      	movs	r1, #3

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     118:	0a0eed84 	.word	0x0a0eed84
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     11c:	f000 fc88 	bl	a30 <nd_norm(float*, int)>

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     120:	eddd 7a08 	vldr	s15, [sp, #32]
     124:	1a0ded94 	.word	0x1a0ded94
		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     128:	ed84 0a0f 	vstr	s0, [r4, #60]	; 0x3c

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     12c:	eeb7 0ae7 	vcvt.f64.f32	d0, s15
     130:	1ac1eeb7 	.word	0x1ac1eeb7
     134:	f004 feb0 	bl	4e98 <atan2>
			q_accel[1] = atan2(-accel[0], ayz_norm);
     138:	7a07eddd 	.word	0x7a07eddd
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     13c:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
			q_accel[1] = atan2(-accel[0], ayz_norm);
     140:	1a0eed94 	.word	0x1a0eed94
     144:	eef1 7a67 	vneg.f32	s15, s15
     148:	1ac1eeb7 	.word	0x1ac1eeb7
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     14c:	ed84 0a14 	vstr	s0, [r4, #80]	; 0x50
			q_accel[1] = atan2(-accel[0], ayz_norm);
     150:	0ae7eeb7 	.word	0x0ae7eeb7
     154:	f004 fea0 	bl	4e98 <atan2>

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     158:	8a14ed94 	.word	0x8a14ed94
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
			q_accel[1] = atan2(-accel[0], ayz_norm);
     15c:	eeb7 0bc0 	vcvt.f32.f64	s0, d0

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     160:	ba0fed9d 	.word	0xba0fed9d
     164:	eeb7 8ac8 	vcvt.f64.f32	d8, s16
     168:	bacbeeb7 	.word	0xbacbeeb7
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;
     16c:	eeb7 9ac0 	vcvt.f64.f32	d9, s0
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
			q_accel[1] = atan2(-accel[0], ayz_norm);
     170:	0a15ed84 	.word	0x0a15ed84

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     174:	eeb0 0b48 	vmov.f64	d0, d8
     178:	fe3ef004 	.word	0xfe3ef004
     17c:	eeb0 db40 	vmov.f64	d13, d0
     180:	0b48eeb0 	.word	0x0b48eeb0
     184:	f004 fde8 	bl	4d58 <cos>
     188:	ed9d 8a0e 	vldr	s16, [sp, #56]	; 0x38
     18c:	aa0fed94 	.word	0xaa0fed94
     190:	eeb7 8ac8 	vcvt.f64.f32	d8, s16
     194:	aacaeeb7 	.word	0xaacaeeb7
     198:	ee28 8b00 	vmul.f64	d8, d8, d0
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;
     19c:	0b49eeb0 	.word	0x0b49eeb0
     1a0:	f004 fdda 	bl	4d58 <cos>
     1a4:	cb40eeb0 	.word	0xcb40eeb0
     1a8:	eeb0 0b49 	vmov.f64	d0, d9
     1ac:	fe24f004 	.word	0xfe24f004

			q_accel[2] = atan2(opposite, adjacent);
     1b0:	ee28 0b00 	vmul.f64	d0, d8, d0
     1b4:	ed9d 6a0d 	vldr	s12, [sp, #52]	; 0x34
     1b8:	6ac6eeb7 	.word	0x6ac6eeb7
     1bc:	ee9b 8b0d 	vfnms.f64	d8, d11, d13
     1c0:	0b0deeab 	.word	0x0b0deeab
     1c4:	ee88 7b0a 	vdiv.f64	d7, d8, d10
     1c8:	0b0ceea6 	.word	0x0b0ceea6
     1cc:	ee80 1b0a 	vdiv.f64	d1, d0, d10
     1d0:	0bc7eeb7 	.word	0x0bc7eeb7
     1d4:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
     1d8:	eeb7 1bc1 	vcvt.f32.f64	s2, d1
     1dc:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
     1e0:	f004 fe5a 	bl	4e98 <atan2>
     1e4:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
			if (isnan(q_accel[2])) {
     1e8:	eeb4 0a40 	vcmp.f32	s0, s0
			q_accel[1] = atan2(-accel[0], ayz_norm);

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;

			q_accel[2] = atan2(opposite, adjacent);
     1ec:	ed84 0a16 	vstr	s0, [r4, #88]	; 0x58
			if (isnan(q_accel[2])) {
     1f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     1f4:	d625      	bvs.n	242 <ComplimentaryFilter::run(Vector<float>*, Vector<float>*)+0x1a6>
				q_accel[2] = 0;
			}

			// integrate gyro measurements over time
			weighted_vector_addition(estimate, gyro, 1, dt, 3, q_gyro);
     1f6:	f104      	.short	0xf104
     1f8:	0544      	lsls	r4, r0, #21
     1fa:	eef0      	.short	0xeef0
     1fc:	0a4e      	lsrs	r6, r1, #9
     1fe:	a90a      	.short	0xa90a
     200:	a804      	add	r0, sp, #16
     202:	462b      	.short	0x462b
     204:	2203      	movs	r2, #3
     206:	eeb7      	.short	0xeeb7
     208:	0a00      	lsrs	r0, r0, #8
     20a:	f000 fc3b 	bl	a84 <weighted_vector_addition(float*, float*, float, float, int, float*)>

			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
     20e:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
     212:	ed94 0a10 	vldr	s0, [r4, #64]	; 0x40
     216:	ab04      	.short	0xab04
     218:	4629      	mov	r1, r5
     21a:	2203      	movs	r2, #3
     21c:	ee70 0ac0 	vsub.f32	s1, s1, s0
     220:	f104 0050 	add.w	r0, r4, #80	; 0x50
     224:	f000 fc2e 	bl	a84 <weighted_vector_addition(float*, float*, float, float, int, float*)>
			inputs->slice(gyro, 6, 9);
			inputs->slice(mag, 9, 12);
			
			filter(accel, gyro, mag, dt, estimate);

			outputs->from_array(estimate, dimensions[OUTPUT_DIMENSION]);
     228:	1d20      	adds	r0, r4, #4
     22a:	2102      	movs	r1, #2
     22c:	ff2ef000 	.word	0xff2ef000
     230:	a904      	add	r1, sp, #16
     232:	6802      	.short	0x6802
     234:	4638      	mov	r0, r7
     236:	f000      	.short	0xf000
     238:	ff6d b011 	vqadd.u32	d27, d13, d1
		}
     23c:	8b0eecbd 	.word	0x8b0eecbd
     240:	bdf0      	pop	{r4, r5, r6, r7, pc}
			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;

			q_accel[2] = atan2(opposite, adjacent);
			if (isnan(q_accel[2])) {
				q_accel[2] = 0;
     242:	2300      	.short	0x2300
     244:	65a3      	str	r3, [r4, #88]	; 0x58
     246:	e7d6      	.short	0xe7d6

00000248 <ComplimentaryFilter::context(Vector<float>*)>:
				q_accel[i] = 0;
				q_gyro[i] = 0;
			}
		}

		void context(Vector<float>* context) {
     248:	b570      	push	{r4, r5, r6, lr}
     24a:	460c      	.short	0x460c
     24c:	4605      	mov	r5, r0
			context->reset(dimensions[CONTEXT_DIMENSION]);
     24e:	2101      	.short	0x2101
     250:	3004      	adds	r0, #4
     252:	f000 ff1b 	bl	108c <Vector<int>::operator[](int)>
     256:	6801      	ldr	r1, [r0, #0]
     258:	4620      	mov	r0, r4
     25a:	f000      	.short	0xf000
     25c:	ff45 f105 	vrhadd.u8	d31, d5, d5
			context->insert(q_gyro, 0, ATTITUDE_DIM);
     260:	0144      	lsls	r4, r0, #5
     262:	4620      	mov	r0, r4
     264:	2303      	movs	r3, #3
     266:	2200      	.short	0x2200
     268:	f000 ffb2 	bl	11d0 <Vector<float>::insert(float*, int, int)>
			context->insert(q_accel, 3, ATTITUDE_DIM);
     26c:	f1052303 	.word	0xf1052303
     270:	0150      	lsls	r0, r2, #5
     272:	4620      	mov	r0, r4
     274:	461a      	mov	r2, r3
		}
     276:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		}

		void context(Vector<float>* context) {
			context->reset(dimensions[CONTEXT_DIMENSION]);
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
     27a:	f000 bfa9 	b.w	11d0 <Vector<float>::insert(float*, int, int)>

		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
	} else {
		// Half duplex maybe different pin pad config like PU...		
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
     27e:	bf00      	nop

00000280 <ComplimentaryFilter::setup(Vector<float>*)>:
			watches.set(0);
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
     280:	460b      	mov	r3, r1
			K = (*config)[0];
     282:	2100      	movs	r1, #0
			watches.set(0);
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
     284:	b510      	push	{r4, lr}
     286:	4604      	mov	r4, r0
			K = (*config)[0];
     288:	f0004618 	.word	0xf0004618
     28c:	ffdd 6803 	vmlal.u16	q11, d13, d3
			watches.set(0);
     290:	f1042100 	.word	0xf1042100
     294:	000c      	movs	r4, r1
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
			K = (*config)[0];
     296:	6423      	.short	0x6423
			watches.set(0);
     298:	f000 fe42 	bl	f20 <FTYK::set(int)>
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     29c:	2300      	movs	r3, #0
     29e:	6523      	.short	0x6523
				q_gyro[i] = 0;
     2a0:	6463      	str	r3, [r4, #68]	; 0x44

		void setup(Vector<float>* config) {
			K = (*config)[0];
			watches.set(0);
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     2a2:	6563      	str	r3, [r4, #84]	; 0x54
				q_gyro[i] = 0;
     2a4:	64a3      	str	r3, [r4, #72]	; 0x48

		void setup(Vector<float>* config) {
			K = (*config)[0];
			watches.set(0);
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     2a6:	65a3      	str	r3, [r4, #88]	; 0x58
				q_gyro[i] = 0;
     2a8:	64e3      	str	r3, [r4, #76]	; 0x4c
     2aa:	bd10      	.short	0xbd10

000002ac <ComplimentaryFilter::reset()>:
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
     2ac:	6802      	ldr	r2, [r0, #0]
     2ae:	490d      	.short	0x490d
     2b0:	6912      	ldr	r2, [r2, #16]

			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
     2b2:	b410      	.short	0xb410
     2b4:	428a      	cmp	r2, r1
			K = DEFAULT_GAIN;
     2b6:	4c0c      	ldr	r4, [pc, #48]	; (2e8 <ComplimentaryFilter::reset()+0x3c>)
     2b8:	6404      	str	r4, [r0, #64]	; 0x40
     2ba:	d10f      	.short	0xd10f
			clear();
		}

		void clear() {
			axz_norm = 0;
     2bc:	2200      	movs	r2, #0
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
		}
     2be:	f85d 4b04 	ldr.w	r4, [sp], #4

		void clear() {
			axz_norm = 0;
     2c2:	6342      	str	r2, [r0, #52]	; 0x34
			ayz_norm = 0;
     2c4:	6382      	str	r2, [r0, #56]	; 0x38
			mag_norm = 0;
     2c6:	63c2      	str	r2, [r0, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     2c8:	6442      	str	r2, [r0, #68]	; 0x44
				q_accel[i] = 0;
     2ca:	6502      	str	r2, [r0, #80]	; 0x50
				bias_accel[i] = 0;
     2cc:	65c2      	str	r2, [r0, #92]	; 0x5c
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     2ce:	6482      	str	r2, [r0, #72]	; 0x48
				q_accel[i] = 0;
     2d0:	6542      	str	r2, [r0, #84]	; 0x54
				bias_accel[i] = 0;
     2d2:	6602      	str	r2, [r0, #96]	; 0x60
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     2d4:	64c2      	str	r2, [r0, #76]	; 0x4c
				q_accel[i] = 0;
     2d6:	6582      	str	r2, [r0, #88]	; 0x58
				bias_accel[i] = 0;
     2d8:	6642      	str	r2, [r0, #100]	; 0x64
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
		}
     2da:	4770      	.short	0x4770
     2dc:	f85d 4b04 	ldr.w	r4, [sp], #4
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
     2e0:	4710      	bx	r2
     2e2:	bf00      	nop
     2e4:	0081      	lsls	r1, r0, #2
     2e6:	0000      	movs	r0, r0
     2e8:	cccd      	ldmia	r4!, {r0, r2, r3, r6, r7}
     2ea:	3ecc      	subs	r6, #204	; 0xcc

000002ec <ComplimentaryFilter::print()>:
			filter(accel, gyro, mag, dt, estimate);

			outputs->from_array(estimate, dimensions[OUTPUT_DIMENSION]);
		}

		void print() {
     2ec:	b530      	push	{r4, r5, lr}
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     2ee:	4d21      	ldr	r5, [pc, #132]	; (374 <ComplimentaryFilter::print()+0x88>)
     2f0:	b085      	sub	sp, #20
     2f2:	4604      	mov	r4, r0
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
     2f4:	2113      	movs	r1, #19
     2f6:	4820      	ldr	r0, [pc, #128]	; (378 <ComplimentaryFilter::print()+0x8c>)
     2f8:	f002 fc9a 	bl	2c30 <usb_seremu_write>
     2fc:	4628      	mov	r0, r5
     2fe:	f002 fd4d 	bl	2d9c <Print::println()>
			Serial.println("ComplimentaryFilter");
			Serial.printf("\tgain: [%f]\n", K);
     302:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
     306:	4628      	mov	r0, r5
     308:	491c      	ldr	r1, [pc, #112]	; (37c <ComplimentaryFilter::print()+0x90>)
     30a:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
     30e:	ec53 2b17 	vmov	r2, r3, d7
     312:	f002 fd5b 	bl	2dcc <Print::printf(char const*, ...)>
			Serial.printf("\tq_accel: [%f, %f, %f]\n", q_accel[0], q_accel[1], q_accel[2]);
     316:	ed94 6a16 	vldr	s12, [r4, #88]	; 0x58
     31a:	ed94 7a15 	vldr	s14, [r4, #84]	; 0x54
     31e:	4628      	.short	0x4628
     320:	edd4 5a14 	vldr	s11, [r4, #80]	; 0x50
     324:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     328:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     32c:	4914      	ldr	r1, [pc, #80]	; (380 <ComplimentaryFilter::print()+0x94>)
     32e:	eeb7      	.short	0xeeb7
     330:	5ae5      	ldrh	r5, [r4, r3]
     332:	ed8d 6b02 	vstr	d6, [sp, #8]
     336:	ec53 2b15 	vmov	r2, r3, d5
     33a:	ed8d      	.short	0xed8d
     33c:	7b00      	ldrb	r0, [r0, #12]
     33e:	f002      	.short	0xf002
     340:	fd45 ed94 	stc2l	13, cr14, [r5, #-592]	; 0xfffffdb0
			Serial.printf("\tq_gyro: [%f, %f, %f]\n", q_gyro[0], q_gyro[1], q_gyro[2]);
     344:	6a13      	ldr	r3, [r2, #32]
     346:	ed94      	.short	0xed94
     348:	7a12      	ldrb	r2, [r2, #8]
     34a:	4628      	.short	0x4628
     34c:	edd4 5a11 	vldr	s11, [r4, #68]	; 0x44
     350:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     354:	7ac7eeb7 	.word	0x7ac7eeb7
     358:	490a      	ldr	r1, [pc, #40]	; (384 <ComplimentaryFilter::print()+0x98>)
     35a:	eeb7      	.short	0xeeb7
     35c:	5ae5      	ldrh	r5, [r4, r3]
     35e:	ed8d      	.short	0xed8d
     360:	6b02      	ldr	r2, [r0, #48]	; 0x30
     362:	ec53      	.short	0xec53
     364:	2b15      	cmp	r3, #21
     366:	ed8d      	.short	0xed8d
     368:	7b00      	ldrb	r0, [r0, #12]
     36a:	f002      	.short	0xf002
     36c:	fd2f b005 	stc2	0, cr11, [pc, #-20]!	; 35c <ComplimentaryFilter::print()+0x70>
		}
     370:	bf00bd30 	.word	0xbf00bd30
     374:	1594      	asrs	r4, r2, #22
     376:	2000      	.short	0x2000
     378:	0ae8      	lsrs	r0, r5, #11
     37a:	2000      	.short	0x2000
     37c:	0afc      	lsrs	r4, r7, #11
     37e:	2000      	.short	0x2000
     380:	0b0c      	lsrs	r4, r1, #12
     382:	2000      	.short	0x2000
     384:	0b24      	lsrs	r4, r4, #12
     386:	2000      	.short	0x2000

00000388 <Print::println(char const*)>:
     388:	b538      	push	{r3, r4, r5, lr}
     38a:	4604      	.short	0x4604
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     38c:	4608      	mov	r0, r1
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     38e:	460d      	.short	0x460d
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     390:	f007 f936 	bl	7600 <strlen>
     394:	46026823 	.word	0x46026823
     398:	4629      	mov	r1, r5
     39a:	4620      	.short	0x4620
     39c:	685b      	ldr	r3, [r3, #4]
     39e:	4798      	blx	r3
     3a0:	46204605 	.word	0x46204605
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     3a4:	f002 fcfa 	bl	2d9c <Print::println()>
     3a8:	bd384428 	.word	0xbd384428

000003ac <ComplimentaryFilter::ComplimentaryFilter()>:
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     3ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	Base class for all user defined processes.
	Must override the functions below, constructor
	optional... I think.
*/

class Process {	
     3b0:	4b20      	ldr	r3, [pc, #128]	; (434 <ComplimentaryFilter::ComplimentaryFilter()+0x88>)
     3b2:	4606      	.short	0x4606
     3b4:	4604      	mov	r4, r0
     3b6:	4607      	.short	0x4607
     3b8:	f846 3b04 	str.w	r3, [r6], #4
     3bc:	f0004630 	.word	0xf0004630
     3c0:	fe3d 4b1d 	vselgt.f64	d4, d13, d13
     3c4:	f8df2500 	.word	0xf8df2500
     3c8:	8074      	strh	r4, [r6, #2]
     3ca:	f847      	.short	0xf847
     3cc:	3b0c      	subs	r3, #12
     3ce:	4638      	mov	r0, r7
     3d0:	fd96f000 	.word	0xfd96f000
			dimensions.reset(PROCESS_DIMENSIONS);
     3d4:	4630      	mov	r0, r6
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     3d6:	6365      	.short	0x6365
			dimensions.reset(PROCESS_DIMENSIONS);
     3d8:	2103      	movs	r1, #3
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     3da:	63a5      	str	r5, [r4, #56]	; 0x38
     3dc:	63e5      	str	r5, [r4, #60]	; 0x3c
     3de:	f8c4      	.short	0xf8c4
     3e0:	8040      	strh	r0, [r0, #2]
			dimensions.reset(PROCESS_DIMENSIONS);
     3e2:	f000      	.short	0xf000
     3e4:	fe3d 4630 	mrc2	6, 1, r4, cr13, cr0, {1}
			dimensions[INPUT_DIMENSION] = CMF_INPUT_DIMS;
     3e8:	f0002100 	.word	0xf0002100
     3ec:	fe4f 230c 	cdp2	3, 4, cr2, cr15, cr12, {0}
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
     3f0:	60032101 	.word	0x60032101
     3f4:	4630      	mov	r0, r6
     3f6:	f000      	.short	0xf000
     3f8:	fe49 2306 	cdp2	3, 4, cr2, cr9, cr6, {0}
			dimensions[OUTPUT_DIMENSION] = ATTITUDE_DIM;
     3fc:	60032102 	.word	0x60032102
     400:	4630      	mov	r0, r6
     402:	f000 fe43 	bl	108c <Vector<int>::operator[](int)>
     406:	2303      	movs	r3, #3
			watches.set(0);
     408:	2100      	movs	r1, #0
	public:
		ComplimentaryFilter() {
			dimensions.reset(PROCESS_DIMENSIONS);
			dimensions[INPUT_DIMENSION] = CMF_INPUT_DIMS;
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
			dimensions[OUTPUT_DIMENSION] = ATTITUDE_DIM;
     40a:	6003      	.short	0x6003
			watches.set(0);
     40c:	4638      	mov	r0, r7
     40e:	f000      	.short	0xf000
     410:	fd87 f8c4 	stc2	8, cr15, [r7, #784]	; 0x310
			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
     414:	63658040 	.word	0x63658040
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
			dimensions[OUTPUT_DIMENSION] = ATTITUDE_DIM;
			watches.set(0);
			reset();
			clear();
		}
     418:	4620      	mov	r0, r4
			clear();
		}

		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
     41a:	63a5      	.short	0x63a5
			mag_norm = 0;
     41c:	63e5      	str	r5, [r4, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     41e:	6465      	str	r5, [r4, #68]	; 0x44
				q_accel[i] = 0;
     420:	6525      	str	r5, [r4, #80]	; 0x50
				bias_accel[i] = 0;
     422:	65e5      	str	r5, [r4, #92]	; 0x5c
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     424:	64a5      	str	r5, [r4, #72]	; 0x48
				q_accel[i] = 0;
     426:	6565      	str	r5, [r4, #84]	; 0x54
				bias_accel[i] = 0;
     428:	6625      	str	r5, [r4, #96]	; 0x60
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     42a:	64e5      	str	r5, [r4, #76]	; 0x4c
				q_accel[i] = 0;
     42c:	65a5      	str	r5, [r4, #88]	; 0x58
				bias_accel[i] = 0;
     42e:	6665      	str	r5, [r4, #100]	; 0x64
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
			dimensions[OUTPUT_DIMENSION] = ATTITUDE_DIM;
			watches.set(0);
			reset();
			clear();
		}
     430:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     434:	0540      	lsls	r0, r0, #21
     436:	2000      	movs	r0, #0
     438:	04c0      	lsls	r0, r0, #19
     43a:	2000      	movs	r0, #0
     43c:	cccd      	ldmia	r4!, {r0, r2, r3, r6, r7}
     43e:	3ecc      	subs	r6, #204	; 0xcc

00000440 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.7]>:
*/
class Process_Factory {
	// private:
		
	public:
		Process* new_proc(String index) {
     440:	b510      	push	{r4, lr}
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
     442:	490d      	ldr	r1, [pc, #52]	; (478 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.7]+0x38>)
     444:	4604      	mov	r4, r0
     446:	f002 fdb7 	bl	2fb8 <String::equals(char const*) const>
			if (index == LSM6DSOX_ID) {
     44a:	b960      	cbnz	r0, 466 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.7]+0x26>
     44c:	4620      	mov	r0, r4
     44e:	490b      	ldr	r1, [pc, #44]	; (47c <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.7]+0x3c>)
     450:	f002 fdb2 	bl	2fb8 <String::equals(char const*) const>
				return new LSM6DSOX();
			}
			else if (index == COMPLIMENTARYFILTER_ID) {
     454:	2068b130 	.word	0x2068b130
				return new ComplimentaryFilter();
     458:	f002 fdde 	bl	3018 <operator new(unsigned int)>
     45c:	f7ff4604 	.word	0xf7ff4604
     460:	ffa5 4620 	vrsubhn.i64	d4, <illegal reg q2.5>, q8
			}
			else {
				return nullptr;
			}
		}
     464:	20b0bd10 	.word	0x20b0bd10
	// private:
		
	public:
		Process* new_proc(String index) {
			if (index == LSM6DSOX_ID) {
				return new LSM6DSOX();
     468:	f002 fdd6 	bl	3018 <operator new(unsigned int)>
     46c:	f0004604 	.word	0xf0004604
     470:	fc0d 4620 	stc2	6, cr4, [sp], {32}
     474:	bf00bd10 	.word	0xbf00bd10
     478:	0b78      	lsrs	r0, r7, #13
     47a:	2000      	.short	0x2000
     47c:	0b7c      	lsrs	r4, r7, #13
     47e:	2000      	.short	0x2000

00000480 <int assert_eq<float>(float*, float, String, int)>:
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     480:	2a00      	cmp	r2, #0
		return 1;
	}
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
     482:	e92d      	.short	0xe92d
     484:	43f0      	mvns	r0, r6
     486:	ed2d      	.short	0xed2d
     488:	8b04      	ldrh	r4, [r0, #24]
     48a:	b091      	.short	0xb091
	int errors = 0;
	for (int i = 0; i < n; i++) {
     48c:	dd5c      	ble.n	548 <int assert_eq<float>(float*, float, String, int)+0xc8>
     48e:	2400      	.short	0x2400
     490:	4690      	mov	r8, r2
     492:	460f      	.short	0x460f
     494:	eef0 8a40 	vmov.f32	s17, s0
     498:	46264605 	.word	0x46264605
	Serial.print(msg); \
	Serial.printf(": %f %s %f\n", a, op, b); \
}

template <typename T> int assert_eq(T a, T b, String message) {
	if (abs(a - b) > 1E-15) {
     49c:	ed9f 9b2e 	vldr	d9, [pc, #184]	; 558 <int assert_eq<float>(float*, float, String, int)+0xd8>
     4a0:	a80ce00c 	.word	0xa80ce00c
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
     4a4:	441e      	add	r6, r3
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     4a6:	3401      	.short	0x3401
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
     4a8:	f002 fcb2 	bl	2e10 <String::~String()>
     4ac:	f002a808 	.word	0xf002a808
     4b0:	fcaf a804 	stc2	8, cr10, [pc], #16	; 4c4 <int assert_eq<float>(float*, float, String, int)+0x44>
	static const char zerotermination;
public:
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
};

class StringSumHelper : public String
     4b4:	f002 fcac 	bl	2e10 <String::~String()>
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     4b8:	45a0      	cmp	r8, r4
     4ba:	d046      	beq.n	54a <int assert_eq<float>(float*, float, String, int)+0xca>
{
public:
	StringSumHelper(const String &s) : String(s) {}
     4bc:	4639      	mov	r1, r7
     4be:	a804      	add	r0, sp, #16
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
     4c0:	ecb5 8a01 	vldmia	r5!, {s16}
     4c4:	fcf8f002 	.word	0xfcf8f002
     4c8:	4925      	ldr	r1, [pc, #148]	; (560 <int assert_eq<float>(float*, float, String, int)+0xe0>)
     4ca:	a804      	.short	0xa804
     4cc:	f002 fd66 	bl	2f9c <operator+(StringSumHelper const&, char const*)>
     4d0:	220a4681 	.word	0x220a4681
     4d4:	4621      	mov	r1, r4
     4d6:	a808      	.short	0xa808
     4d8:	f002 fd0c 	bl	2ef4 <String::String(int, unsigned char)>
     4dc:	4648a908 	.word	0x4648a908
     4e0:	f002 fd54 	bl	2f8c <operator+(StringSumHelper const&, String const&)>
     4e4:	f002491f 	.word	0xf002491f
     4e8:	fd59 4601 	ldc2l	6, cr4, [r9, #-4]
     4ec:	a80c      	add	r0, sp, #48	; 0x30
     4ee:	f002 fce3 	bl	2eb8 <String::String(String const&)>
	Serial.print(msg); \
	Serial.printf(": %f %s %f\n", a, op, b); \
}

template <typename T> int assert_eq(T a, T b, String message) {
	if (abs(a - b) > 1E-15) {
     4f2:	ee78 7a68 	vsub.f32	s15, s16, s17
		TEST_INFO(message, "!=", a, b);
		return 1;
	}
	return 0;
     4f6:	2300      	movs	r3, #0
	Serial.print(msg); \
	Serial.printf(": %f %s %f\n", a, op, b); \
}

template <typename T> int assert_eq(T a, T b, String message) {
	if (abs(a - b) > 1E-15) {
     4f8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
     4fc:	eeb0 7a67 	vmov.f32	s14, s15
     500:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     504:	bfd8      	it	le
     506:	eeb1 7a67 	vnegle.f32	s14, s15
     50a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     50e:	eeb4 7bc9 	vcmpe.f64	d7, d9
     512:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     516:	ddc4      	ble.n	4a2 <int assert_eq<float>(float*, float, String, int)+0x22>
     518:	210c      	movs	r1, #12
     51a:	4813      	ldr	r0, [pc, #76]	; (568 <int assert_eq<float>(float*, float, String, int)+0xe8>)
     51c:	f002 fb88 	bl	2c30 <usb_seremu_write>
		TEST_INFO(message, "!=", a, b);
     520:	a90c      	add	r1, sp, #48	; 0x30
     522:	4812      	ldr	r0, [pc, #72]	; (56c <int assert_eq<float>(float*, float, String, int)+0xec>)
     524:	f002 fc14 	bl	2d50 <Print::print(String const&)>
     528:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
     52c:	eeb7 6ac8 	vcvt.f64.f32	d6, s16
     530:	480f      	ldr	r0, [pc, #60]	; (570 <int assert_eq<float>(float*, float, String, int)+0xf0>)
     532:	4910      	ldr	r1, [pc, #64]	; (574 <int assert_eq<float>(float*, float, String, int)+0xf4>)
     534:	9000      	str	r0, [sp, #0]
     536:	480d      	ldr	r0, [pc, #52]	; (56c <int assert_eq<float>(float*, float, String, int)+0xec>)
     538:	ec53 2b16 	vmov	r2, r3, d6
     53c:	ed8d 7b02 	vstr	d7, [sp, #8]
     540:	f002 fc44 	bl	2dcc <Print::printf(char const*, ...)>
     544:	2301      	movs	r3, #1
     546:	e7ac      	b.n	4a2 <int assert_eq<float>(float*, float, String, int)+0x22>
	}
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
     548:	2600      	movs	r6, #0
	for (int i = 0; i < n; i++) {
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
	}
	return errors;
}
     54a:	4630      	mov	r0, r6
     54c:	b011      	add	sp, #68	; 0x44
     54e:	ecbd 8b04 	vpop	{d8-d9}
     552:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     556:	bf00      	nop
     558:	9ee75616 	.word	0x9ee75616
     55c:	3cd203af 	.word	0x3cd203af
     560:	20000b80 	.word	0x20000b80
     564:	20000b84 	.word	0x20000b84
     568:	20000b3c 	.word	0x20000b3c
     56c:	20001594 	.word	0x20001594
     570:	20000b94 	.word	0x20000b94
     574:	20000b88 	.word	0x20000b88

00000578 <setup_proc_test(Process*, Vector<float>*, int)>:
	errors += assert_eq<float>(context.as_array(), 0.0f, "Process post run cleared empty context test", context.size());

	return errors;
}

int setup_proc_test(Process* p, Vector<float>* config, int num_inputs) {
     578:	b570      	push	{r4, r5, r6, lr}
     57a:	ed2d 8b02 	vpush	{d8}
     57e:	b08a      	sub	sp, #40	; 0x28
     580:	4604      	mov	r4, r0
     582:	4615      	mov	r5, r2
     584:	460e      	mov	r6, r1
	int errors = 0;
	Vector<float> outputs(0);
     586:	4668      	mov	r0, sp
     588:	2100      	movs	r1, #0
     58a:	f000 fd9b 	bl	10c4 <Vector<float>::Vector(int)>
	Vector<float> context(0);
     58e:	a802      	add	r0, sp, #8
     590:	2100      	movs	r1, #0
	Vector<float> inputs(num_inputs);

	p->reset();
	p->context(&context);
	errors += assert_eq<float>(context.as_array(), 0.0f, "Process with setup uninitialized empty context test", context.size());
     592:	ed9f 8a35 	vldr	s16, [pc, #212]	; 668 <setup_proc_test(Process*, Vector<float>*, int)+0xf0>
}

int setup_proc_test(Process* p, Vector<float>* config, int num_inputs) {
	int errors = 0;
	Vector<float> outputs(0);
	Vector<float> context(0);
     596:	f000 fd95 	bl	10c4 <Vector<float>::Vector(int)>
	Vector<float> inputs(num_inputs);
     59a:	4629      	mov	r1, r5
     59c:	a804      	add	r0, sp, #16
     59e:	f000 fd91 	bl	10c4 <Vector<float>::Vector(int)>

	p->reset();
     5a2:	6823      	ldr	r3, [r4, #0]
     5a4:	4620      	mov	r0, r4
     5a6:	68db      	ldr	r3, [r3, #12]
     5a8:	4798      	blx	r3
	p->context(&context);
     5aa:	6823      	ldr	r3, [r4, #0]
     5ac:	a902      	add	r1, sp, #8
     5ae:	4620      	mov	r0, r4
     5b0:	69db      	ldr	r3, [r3, #28]
     5b2:	4798      	blx	r3
	errors += assert_eq<float>(context.as_array(), 0.0f, "Process with setup uninitialized empty context test", context.size());
     5b4:	a802      	add	r0, sp, #8
     5b6:	f000 fddf 	bl	1178 <Vector<float>::as_array()>
     5ba:	492c      	ldr	r1, [pc, #176]	; (66c <setup_proc_test(Process*, Vector<float>*, int)+0xf4>)
     5bc:	4605      	mov	r5, r0
     5be:	a806      	add	r0, sp, #24
     5c0:	f002 fc66 	bl	2e90 <String::String(char const*)>
     5c4:	a802      	add	r0, sp, #8
     5c6:	f000 fdd5 	bl	1174 <Vector<float>::size()>
     5ca:	eeb0 0a48 	vmov.f32	s0, s16
     5ce:	4602      	mov	r2, r0
     5d0:	a906      	add	r1, sp, #24
     5d2:	4628      	mov	r0, r5
     5d4:	f7ff ff54 	bl	480 <int assert_eq<float>(float*, float, String, int)>
     5d8:	4605      	mov	r5, r0
     5da:	a806      	add	r0, sp, #24
     5dc:	f002 fc18 	bl	2e10 <String::~String()>

	p->setup(config);
     5e0:	6823      	ldr	r3, [r4, #0]
     5e2:	4631      	mov	r1, r6
     5e4:	4620      	mov	r0, r4
     5e6:	699b      	ldr	r3, [r3, #24]
     5e8:	4798      	blx	r3
	
	p->run(&inputs, &outputs);
     5ea:	6823      	ldr	r3, [r4, #0]
     5ec:	466a      	mov	r2, sp
     5ee:	a904      	add	r1, sp, #16
     5f0:	4620      	mov	r0, r4
     5f2:	6a1b      	ldr	r3, [r3, #32]
     5f4:	4798      	blx	r3
	p->run(&inputs, &outputs);
     5f6:	6823      	ldr	r3, [r4, #0]
     5f8:	466a      	mov	r2, sp
     5fa:	a904      	add	r1, sp, #16
     5fc:	4620      	mov	r0, r4
     5fe:	6a1b      	ldr	r3, [r3, #32]
     600:	4798      	blx	r3
	p->run(&inputs, &outputs);
     602:	6823      	ldr	r3, [r4, #0]
     604:	466a      	mov	r2, sp
     606:	a904      	add	r1, sp, #16
     608:	4620      	mov	r0, r4
     60a:	6a1b      	ldr	r3, [r3, #32]
     60c:	4798      	blx	r3
	// errors += assert_neq<float>(outputs.as_array(), 0.0f, "Process with setup post run non-empty outputs test", outputs.size());

	// p->context(&context);
	// errors += assert_neq<float>(context.as_array(), 0.0f, "Process with setup post run non-empty context test", context.size());

	p->reset();
     60e:	6823      	ldr	r3, [r4, #0]
     610:	4620      	mov	r0, r4
     612:	68db      	ldr	r3, [r3, #12]
     614:	4798      	blx	r3
	p->context(&context);
     616:	6823      	ldr	r3, [r4, #0]
     618:	a902      	add	r1, sp, #8
     61a:	4620      	mov	r0, r4
     61c:	69db      	ldr	r3, [r3, #28]
     61e:	4798      	blx	r3
	errors += assert_eq<float>(context.as_array(), 0.0f, "Process with setup post run cleared empty context test", context.size());
     620:	a802      	add	r0, sp, #8
     622:	f000 fda9 	bl	1178 <Vector<float>::as_array()>
     626:	4912      	ldr	r1, [pc, #72]	; (670 <setup_proc_test(Process*, Vector<float>*, int)+0xf8>)
     628:	4604      	mov	r4, r0
     62a:	a806      	add	r0, sp, #24
     62c:	f002 fc30 	bl	2e90 <String::String(char const*)>
     630:	a802      	add	r0, sp, #8
     632:	f000 fd9f 	bl	1174 <Vector<float>::size()>
     636:	a906      	add	r1, sp, #24
     638:	4602      	mov	r2, r0
     63a:	eeb0 0a48 	vmov.f32	s0, s16
     63e:	4620      	mov	r0, r4
     640:	f7ff ff1e 	bl	480 <int assert_eq<float>(float*, float, String, int)>
     644:	4405      	add	r5, r0
     646:	a806      	add	r0, sp, #24
     648:	f002 fbe2 	bl	2e10 <String::~String()>

int setup_proc_test(Process* p, Vector<float>* config, int num_inputs) {
	int errors = 0;
	Vector<float> outputs(0);
	Vector<float> context(0);
	Vector<float> inputs(num_inputs);
     64c:	a804      	add	r0, sp, #16
     64e:	f000 fd2b 	bl	10a8 <Vector<float>::~Vector()>
}

int setup_proc_test(Process* p, Vector<float>* config, int num_inputs) {
	int errors = 0;
	Vector<float> outputs(0);
	Vector<float> context(0);
     652:	a802      	add	r0, sp, #8
     654:	f000 fd28 	bl	10a8 <Vector<float>::~Vector()>
	return errors;
}

int setup_proc_test(Process* p, Vector<float>* config, int num_inputs) {
	int errors = 0;
	Vector<float> outputs(0);
     658:	4668      	mov	r0, sp
     65a:	f000 fd25 	bl	10a8 <Vector<float>::~Vector()>
	p->reset();
	p->context(&context);
	errors += assert_eq<float>(context.as_array(), 0.0f, "Process with setup post run cleared empty context test", context.size());

	return errors;
}
     65e:	4628      	mov	r0, r5
     660:	b00a      	add	sp, #40	; 0x28
     662:	ecbd 8b02 	vpop	{d8}
     666:	bd70      	pop	{r4, r5, r6, pc}
     668:	00000000 	.word	0x00000000
     66c:	20000b98 	.word	0x20000b98
     670:	20000bcc 	.word	0x20000bcc

00000674 <int assert_neq<float>(float*, float, String, int)>:
	return 0;
}

template <typename T> int assert_neq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     674:	2a00      	cmp	r2, #0
		return 1;
	}
	return 0;
}

template <typename T> int assert_neq(T* a, T b, String message, int n) {
     676:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     67a:	ed2d 8b02 	vpush	{d8}
     67e:	b091      	sub	sp, #68	; 0x44
	int errors = 0;
	for (int i = 0; i < n; i++) {
     680:	dd4d      	ble.n	71e <int assert_neq<float>(float*, float, String, int)+0xaa>
     682:	2400      	movs	r4, #0
     684:	4690      	mov	r8, r2
     686:	460f      	mov	r7, r1
     688:	eef0 8a40 	vmov.f32	s17, s0
     68c:	4605      	mov	r5, r0
     68e:	4626      	mov	r6, r4
     690:	e00c      	b.n	6ac <int assert_neq<float>(float*, float, String, int)+0x38>
		errors += assert_neq(a[i], b, message + " [" + String(i) + "]");
     692:	a80c      	add	r0, sp, #48	; 0x30
     694:	441e      	add	r6, r3
	return 0;
}

template <typename T> int assert_neq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     696:	3401      	adds	r4, #1
		errors += assert_neq(a[i], b, message + " [" + String(i) + "]");
     698:	f002 fbba 	bl	2e10 <String::~String()>
     69c:	a808      	add	r0, sp, #32
     69e:	f002 fbb7 	bl	2e10 <String::~String()>
	static const char zerotermination;
public:
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
};

class StringSumHelper : public String
     6a2:	a804      	add	r0, sp, #16
     6a4:	f002 fbb4 	bl	2e10 <String::~String()>
	return 0;
}

template <typename T> int assert_neq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     6a8:	45a0      	cmp	r8, r4
     6aa:	d039      	beq.n	720 <int assert_neq<float>(float*, float, String, int)+0xac>
{
public:
	StringSumHelper(const String &s) : String(s) {}
     6ac:	4639      	mov	r1, r7
     6ae:	a804      	add	r0, sp, #16
		errors += assert_neq(a[i], b, message + " [" + String(i) + "]");
     6b0:	ecb5 8a01 	vldmia	r5!, {s16}
     6b4:	f002 fc00 	bl	2eb8 <String::String(String const&)>
     6b8:	491c      	ldr	r1, [pc, #112]	; (72c <int assert_neq<float>(float*, float, String, int)+0xb8>)
     6ba:	a804      	add	r0, sp, #16
     6bc:	f002 fc6e 	bl	2f9c <operator+(StringSumHelper const&, char const*)>
     6c0:	4681      	mov	r9, r0
     6c2:	220a      	movs	r2, #10
     6c4:	4621      	mov	r1, r4
     6c6:	a808      	add	r0, sp, #32
     6c8:	f002 fc14 	bl	2ef4 <String::String(int, unsigned char)>
     6cc:	a908      	add	r1, sp, #32
     6ce:	4648      	mov	r0, r9
     6d0:	f002 fc5c 	bl	2f8c <operator+(StringSumHelper const&, String const&)>
     6d4:	4916      	ldr	r1, [pc, #88]	; (730 <int assert_neq<float>(float*, float, String, int)+0xbc>)
     6d6:	f002 fc61 	bl	2f9c <operator+(StringSumHelper const&, char const*)>
     6da:	4601      	mov	r1, r0
     6dc:	a80c      	add	r0, sp, #48	; 0x30
     6de:	f002 fbeb 	bl	2eb8 <String::String(String const&)>
	}
	return errors;
}

template <typename T> int assert_neq(T a, T b, String message) {
	if (a == b) {
     6e2:	eeb4 8a68 	vcmp.f32	s16, s17
		TEST_INFO(message, "==", a, b);
		return 1;
	}
	return 0;
     6e6:	2300      	movs	r3, #0
	}
	return errors;
}

template <typename T> int assert_neq(T a, T b, String message) {
	if (a == b) {
     6e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     6ec:	d1d1      	bne.n	692 <int assert_neq<float>(float*, float, String, int)+0x1e>
     6ee:	210c      	movs	r1, #12
     6f0:	4810      	ldr	r0, [pc, #64]	; (734 <int assert_neq<float>(float*, float, String, int)+0xc0>)
     6f2:	f002 fa9d 	bl	2c30 <usb_seremu_write>
		TEST_INFO(message, "==", a, b);
     6f6:	a90c      	add	r1, sp, #48	; 0x30
     6f8:	480f      	ldr	r0, [pc, #60]	; (738 <int assert_neq<float>(float*, float, String, int)+0xc4>)
     6fa:	f002 fb29 	bl	2d50 <Print::print(String const&)>
     6fe:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
     702:	eeb7 6ac8 	vcvt.f64.f32	d6, s16
     706:	480d      	ldr	r0, [pc, #52]	; (73c <int assert_neq<float>(float*, float, String, int)+0xc8>)
     708:	490d      	ldr	r1, [pc, #52]	; (740 <int assert_neq<float>(float*, float, String, int)+0xcc>)
     70a:	9000      	str	r0, [sp, #0]
     70c:	480a      	ldr	r0, [pc, #40]	; (738 <int assert_neq<float>(float*, float, String, int)+0xc4>)
     70e:	ec53 2b16 	vmov	r2, r3, d6
     712:	ed8d 7b02 	vstr	d7, [sp, #8]
     716:	f002 fb59 	bl	2dcc <Print::printf(char const*, ...)>
     71a:	2301      	movs	r3, #1
     71c:	e7b9      	b.n	692 <int assert_neq<float>(float*, float, String, int)+0x1e>
	}
	return 0;
}

template <typename T> int assert_neq(T* a, T b, String message, int n) {
	int errors = 0;
     71e:	2600      	movs	r6, #0
	for (int i = 0; i < n; i++) {
		errors += assert_neq(a[i], b, message + " [" + String(i) + "]");
	}
	return errors;
}
     720:	4630      	mov	r0, r6
     722:	b011      	add	sp, #68	; 0x44
     724:	ecbd 8b02 	vpop	{d8}
     728:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     72c:	20000b80 	.word	0x20000b80
     730:	20000b84 	.word	0x20000b84
     734:	20000b3c 	.word	0x20000b3c
     738:	20001594 	.word	0x20001594
     73c:	20000cc4 	.word	0x20000cc4
     740:	20000b88 	.word	0x20000b88

00000744 <simple_proc_test(Process*)>:


int simple_proc_test(Process* p) {
	int errors = 0;

	p->reset();
     744:	6803      	ldr	r3, [r0, #0]
#include "algorithms/complimentary_filter.h"

#include "sensors/lsm6dsox.h"


int simple_proc_test(Process* p) {
     746:	b570      	push	{r4, r5, r6, lr}
     748:	4604      	mov	r4, r0
	int errors = 0;

	p->reset();
     74a:	68db      	ldr	r3, [r3, #12]
#include "algorithms/complimentary_filter.h"

#include "sensors/lsm6dsox.h"


int simple_proc_test(Process* p) {
     74c:	ed2d 8b02 	vpush	{d8}
     750:	b08c      	sub	sp, #48	; 0x30
	Vector<float> outputs(0);
	Vector<float> context(0);
	Vector<float> config(0);

	p->context(&context);
	errors += assert_eq<float>(context.as_array(), 0.0f, "Process uninitialized empty context test", context.size());
     752:	ed9f 8a52 	vldr	s16, [pc, #328]	; 89c <simple_proc_test(Process*)+0x158>


int simple_proc_test(Process* p) {
	int errors = 0;

	p->reset();
     756:	4798      	blx	r3
	p->print();
     758:	6823      	ldr	r3, [r4, #0]
     75a:	4620      	mov	r0, r4
     75c:	695b      	ldr	r3, [r3, #20]
     75e:	4798      	blx	r3

	Vector<float> inputs(0);
     760:	4668      	mov	r0, sp
     762:	2100      	movs	r1, #0
     764:	f000 fcae 	bl	10c4 <Vector<float>::Vector(int)>
	Vector<float> outputs(0);
     768:	a802      	add	r0, sp, #8
     76a:	2100      	movs	r1, #0
     76c:	f000 fcaa 	bl	10c4 <Vector<float>::Vector(int)>
	Vector<float> context(0);
     770:	a804      	add	r0, sp, #16
     772:	2100      	movs	r1, #0
     774:	f000 fca6 	bl	10c4 <Vector<float>::Vector(int)>
	Vector<float> config(0);
     778:	a806      	add	r0, sp, #24
     77a:	2100      	movs	r1, #0
     77c:	f000 fca2 	bl	10c4 <Vector<float>::Vector(int)>

	p->context(&context);
     780:	6823      	ldr	r3, [r4, #0]
     782:	a904      	add	r1, sp, #16
     784:	4620      	mov	r0, r4
     786:	69db      	ldr	r3, [r3, #28]
     788:	4798      	blx	r3
	errors += assert_eq<float>(context.as_array(), 0.0f, "Process uninitialized empty context test", context.size());
     78a:	a804      	add	r0, sp, #16
     78c:	f000 fcf4 	bl	1178 <Vector<float>::as_array()>
     790:	4943      	ldr	r1, [pc, #268]	; (8a0 <simple_proc_test(Process*)+0x15c>)
     792:	4605      	mov	r5, r0
     794:	a808      	add	r0, sp, #32
     796:	f002 fb7b 	bl	2e90 <String::String(char const*)>
     79a:	a804      	add	r0, sp, #16
     79c:	f000 fcea 	bl	1174 <Vector<float>::size()>
     7a0:	eeb0 0a48 	vmov.f32	s0, s16
     7a4:	a908      	add	r1, sp, #32
     7a6:	4602      	mov	r2, r0
     7a8:	4628      	mov	r0, r5
     7aa:	f7ff fe69 	bl	480 <int assert_eq<float>(float*, float, String, int)>
     7ae:	4605      	mov	r5, r0
     7b0:	a808      	add	r0, sp, #32
     7b2:	f002 fb2d 	bl	2e10 <String::~String()>

	p->run(&inputs, &outputs);
     7b6:	6823      	ldr	r3, [r4, #0]
     7b8:	aa02      	add	r2, sp, #8
     7ba:	4669      	mov	r1, sp
     7bc:	4620      	mov	r0, r4
     7be:	6a1b      	ldr	r3, [r3, #32]
     7c0:	4798      	blx	r3
	p->run(&inputs, &outputs);
     7c2:	6823      	ldr	r3, [r4, #0]
     7c4:	aa02      	add	r2, sp, #8
     7c6:	4669      	mov	r1, sp
     7c8:	4620      	mov	r0, r4
     7ca:	6a1b      	ldr	r3, [r3, #32]
     7cc:	4798      	blx	r3
	p->run(&inputs, &outputs);
     7ce:	6823      	ldr	r3, [r4, #0]
     7d0:	aa02      	add	r2, sp, #8
     7d2:	4669      	mov	r1, sp
     7d4:	4620      	mov	r0, r4
     7d6:	6a1b      	ldr	r3, [r3, #32]
     7d8:	4798      	blx	r3

	p->context(&context);
     7da:	6823      	ldr	r3, [r4, #0]
     7dc:	a904      	add	r1, sp, #16
     7de:	4620      	mov	r0, r4
     7e0:	69db      	ldr	r3, [r3, #28]
     7e2:	4798      	blx	r3
	errors += assert_neq<float>(context.as_array(), 0.0f, "Process post run non-empty context test", context.size());
     7e4:	a804      	add	r0, sp, #16
     7e6:	f000 fcc7 	bl	1178 <Vector<float>::as_array()>
     7ea:	492e      	ldr	r1, [pc, #184]	; (8a4 <simple_proc_test(Process*)+0x160>)
     7ec:	4606      	mov	r6, r0
     7ee:	a808      	add	r0, sp, #32
     7f0:	f002 fb4e 	bl	2e90 <String::String(char const*)>
     7f4:	a804      	add	r0, sp, #16
     7f6:	f000 fcbd 	bl	1174 <Vector<float>::size()>
     7fa:	eeb0 0a48 	vmov.f32	s0, s16
     7fe:	4602      	mov	r2, r0
     800:	a908      	add	r1, sp, #32
     802:	4630      	mov	r0, r6
     804:	f7ff ff36 	bl	674 <int assert_neq<float>(float*, float, String, int)>
     808:	4405      	add	r5, r0
     80a:	a808      	add	r0, sp, #32
     80c:	f002 fb00 	bl	2e10 <String::~String()>
	errors += assert_neq<float>(outputs.as_array(), 0.0f, "Process post run non-empty outputs test", outputs.size());
     810:	a802      	add	r0, sp, #8
     812:	f000 fcb1 	bl	1178 <Vector<float>::as_array()>
     816:	4924      	ldr	r1, [pc, #144]	; (8a8 <simple_proc_test(Process*)+0x164>)
     818:	4606      	mov	r6, r0
     81a:	a808      	add	r0, sp, #32
     81c:	f002 fb38 	bl	2e90 <String::String(char const*)>
     820:	a802      	add	r0, sp, #8
     822:	f000 fca7 	bl	1174 <Vector<float>::size()>
     826:	eeb0 0a48 	vmov.f32	s0, s16
     82a:	4602      	mov	r2, r0
     82c:	a908      	add	r1, sp, #32
     82e:	4630      	mov	r0, r6
     830:	f7ff ff20 	bl	674 <int assert_neq<float>(float*, float, String, int)>
     834:	4405      	add	r5, r0
     836:	a808      	add	r0, sp, #32
     838:	f002 faea 	bl	2e10 <String::~String()>

	p->clear();
     83c:	6823      	ldr	r3, [r4, #0]
     83e:	4620      	mov	r0, r4
     840:	691b      	ldr	r3, [r3, #16]
     842:	4798      	blx	r3

	p->context(&context);
     844:	6823      	ldr	r3, [r4, #0]
     846:	a904      	add	r1, sp, #16
     848:	4620      	mov	r0, r4
     84a:	69db      	ldr	r3, [r3, #28]
     84c:	4798      	blx	r3
	errors += assert_eq<float>(context.as_array(), 0.0f, "Process post run cleared empty context test", context.size());
     84e:	a804      	add	r0, sp, #16
     850:	f000 fc92 	bl	1178 <Vector<float>::as_array()>
     854:	4915      	ldr	r1, [pc, #84]	; (8ac <simple_proc_test(Process*)+0x168>)
     856:	4604      	mov	r4, r0
     858:	a808      	add	r0, sp, #32
     85a:	f002 fb19 	bl	2e90 <String::String(char const*)>
     85e:	a804      	add	r0, sp, #16
     860:	f000 fc88 	bl	1174 <Vector<float>::size()>
     864:	a908      	add	r1, sp, #32
     866:	4602      	mov	r2, r0
     868:	eeb0 0a48 	vmov.f32	s0, s16
     86c:	4620      	mov	r0, r4
     86e:	f7ff fe07 	bl	480 <int assert_eq<float>(float*, float, String, int)>
     872:	4405      	add	r5, r0
     874:	a808      	add	r0, sp, #32
     876:	f002 facb 	bl	2e10 <String::~String()>
	p->print();

	Vector<float> inputs(0);
	Vector<float> outputs(0);
	Vector<float> context(0);
	Vector<float> config(0);
     87a:	a806      	add	r0, sp, #24
     87c:	f000 fc14 	bl	10a8 <Vector<float>::~Vector()>
	p->reset();
	p->print();

	Vector<float> inputs(0);
	Vector<float> outputs(0);
	Vector<float> context(0);
     880:	a804      	add	r0, sp, #16
     882:	f000 fc11 	bl	10a8 <Vector<float>::~Vector()>

	p->reset();
	p->print();

	Vector<float> inputs(0);
	Vector<float> outputs(0);
     886:	a802      	add	r0, sp, #8
     888:	f000 fc0e 	bl	10a8 <Vector<float>::~Vector()>
	int errors = 0;

	p->reset();
	p->print();

	Vector<float> inputs(0);
     88c:	4668      	mov	r0, sp
     88e:	f000 fc0b 	bl	10a8 <Vector<float>::~Vector()>

	p->context(&context);
	errors += assert_eq<float>(context.as_array(), 0.0f, "Process post run cleared empty context test", context.size());

	return errors;
}
     892:	4628      	mov	r0, r5
     894:	b00c      	add	sp, #48	; 0x30
     896:	ecbd 8b02 	vpop	{d8}
     89a:	bd70      	pop	{r4, r5, r6, pc}
     89c:	00000000 	.word	0x00000000
     8a0:	20000c04 	.word	0x20000c04
     8a4:	20000c30 	.word	0x20000c30
     8a8:	20000c58 	.word	0x20000c58
     8ac:	20000c80 	.word	0x20000c80

000008b0 <main>:

	return errors;
}


int main() {
     8b0:	b530      	push	{r4, r5, lr}
     8b2:	4c4f      	ldr	r4, [pc, #316]	; (9f0 <main+0x140>)
     8b4:	b0d3      	sub	sp, #332	; 0x14c
     8b6:	4d4f      	ldr	r5, [pc, #316]	; (9f4 <main+0x144>)
        uint8_t stopbits(void) { return 1; }
        uint8_t paritytype(void) { return 0; }
        uint8_t numbits(void) { return 8; }
        uint8_t dtr(void) { return 1; }
        uint8_t rts(void) { return 1; }
        operator bool() { yield(); return usb_configuration && usb_seremu_online; }
     8b8:	f002 fbc8 	bl	304c <yield>
     8bc:	7823      	ldrb	r3, [r4, #0]
     8be:	2b00      	cmp	r3, #0
     8c0:	d0fa      	beq.n	8b8 <main+0x8>
     8c2:	782b      	ldrb	r3, [r5, #0]
     8c4:	2b00      	cmp	r3, #0
     8c6:	d0f7      	beq.n	8b8 <main+0x8>
     8c8:	4c4b      	ldr	r4, [pc, #300]	; (9f8 <main+0x148>)
	while(!Serial){}

	Serial.println("=== Starting PBO tests ===");
     8ca:	494c      	ldr	r1, [pc, #304]	; (9fc <main+0x14c>)
     8cc:	484c      	ldr	r0, [pc, #304]	; (a00 <main+0x150>)
     8ce:	f7ff fd5b 	bl	388 <Print::println(char const*)>
     8d2:	a806      	add	r0, sp, #24
     8d4:	9405      	str	r4, [sp, #20]
     8d6:	f000 fbb1 	bl	103c <Vector<int>::Vector()>
	Process p;
	simple_proc_test(&p);
     8da:	a805      	add	r0, sp, #20
     8dc:	f7ff ff32 	bl	744 <simple_proc_test(Process*)>

	Serial.println("=== Starting LSM6DSOX tests ===");
     8e0:	4948      	ldr	r1, [pc, #288]	; (a04 <main+0x154>)
     8e2:	4847      	ldr	r0, [pc, #284]	; (a00 <main+0x150>)
     8e4:	f7ff fd50 	bl	388 <Print::println(char const*)>

	LSM6DSOX imu;
     8e8:	a826      	add	r0, sp, #152	; 0x98
     8ea:	f000 f9cf 	bl	c8c <LSM6DSOX::LSM6DSOX()>
	simple_proc_test(&imu);
     8ee:	a826      	add	r0, sp, #152	; 0x98
     8f0:	f7ff ff28 	bl	744 <simple_proc_test(Process*)>

	Serial.println("=== Starting ComplimentaryFilter tests ===");
     8f4:	4944      	ldr	r1, [pc, #272]	; (a08 <main+0x158>)
     8f6:	4842      	ldr	r0, [pc, #264]	; (a00 <main+0x150>)
     8f8:	f7ff fd46 	bl	388 <Print::println(char const*)>

	ComplimentaryFilter cmf;
     8fc:	a80c      	add	r0, sp, #48	; 0x30
     8fe:	f7ff fd55 	bl	3ac <ComplimentaryFilter::ComplimentaryFilter()>
	Vector<float> cmf_config(0);
     902:	2100      	movs	r1, #0
     904:	a801      	add	r0, sp, #4
     906:	f000 fbdd 	bl	10c4 <Vector<float>::Vector(int)>
	cmf_config.push(0.6);
     90a:	ed9f 0a40 	vldr	s0, [pc, #256]	; a0c <main+0x15c>
     90e:	a801      	add	r0, sp, #4
     910:	f000 fc0e 	bl	1130 <Vector<float>::push(float)>
	setup_proc_test(&cmf, &cmf_config, 12);
     914:	220c      	movs	r2, #12
     916:	a901      	add	r1, sp, #4
     918:	a80c      	add	r0, sp, #48	; 0x30
     91a:	f7ff fe2d 	bl	578 <setup_proc_test(Process*, Vector<float>*, int)>

	Serial.println("=== Starting Factory tests ==="); Serial.flush();
     91e:	493c      	ldr	r1, [pc, #240]	; (a10 <main+0x160>)
     920:	4837      	ldr	r0, [pc, #220]	; (a00 <main+0x150>)
     922:	f7ff fd31 	bl	388 <Print::println(char const*)>
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
     926:	f002 f991 	bl	2c4c <usb_seremu_flush_output>

	Process_Factory p_fact;

	Vector<Process*> p_list(0);
     92a:	2100      	movs	r1, #0
     92c:	a803      	add	r0, sp, #12
     92e:	f000 fca7 	bl	1280 <Vector<Process*>::Vector(int)>
	p_list.print();
     932:	a803      	add	r0, sp, #12
     934:	f000 fb46 	bl	fc4 <Vector<Process*>::print()>
	p_list.push(p_fact.new_proc("LSM"));
     938:	4936      	ldr	r1, [pc, #216]	; (a14 <main+0x164>)
     93a:	a808      	add	r0, sp, #32
     93c:	f002 faa8 	bl	2e90 <String::String(char const*)>
     940:	a808      	add	r0, sp, #32
     942:	f7ff fd7d 	bl	440 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.7]>
     946:	4601      	mov	r1, r0
     948:	a803      	add	r0, sp, #12
     94a:	f000 fccf 	bl	12ec <Vector<Process*>::push(Process*)>
     94e:	a808      	add	r0, sp, #32
     950:	f002 fa5e 	bl	2e10 <String::~String()>
	p_list.print();
     954:	a803      	add	r0, sp, #12
     956:	f000 fb35 	bl	fc4 <Vector<Process*>::print()>
	p_list.push(p_fact.new_proc("CMF"));
     95a:	492f      	ldr	r1, [pc, #188]	; (a18 <main+0x168>)
     95c:	a808      	add	r0, sp, #32
     95e:	f002 fa97 	bl	2e90 <String::String(char const*)>
     962:	a808      	add	r0, sp, #32
     964:	f7ff fd6c 	bl	440 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.7]>
     968:	4601      	mov	r1, r0
     96a:	a803      	add	r0, sp, #12
     96c:	f000 fcbe 	bl	12ec <Vector<Process*>::push(Process*)>
     970:	a808      	add	r0, sp, #32
     972:	f002 fa4d 	bl	2e10 <String::~String()>
	p_list.print();
     976:	a803      	add	r0, sp, #12
     978:	f000 fb24 	bl	fc4 <Vector<Process*>::print()>

	Serial.println("=== LSM6DSOX ===");
     97c:	4927      	ldr	r1, [pc, #156]	; (a1c <main+0x16c>)
     97e:	4820      	ldr	r0, [pc, #128]	; (a00 <main+0x150>)
     980:	f7ff fd02 	bl	388 <Print::println(char const*)>
	simple_proc_test(p_list[0]);
     984:	2100      	movs	r1, #0
     986:	a803      	add	r0, sp, #12
     988:	f000 fcce 	bl	1328 <Vector<Process*>::operator[](int)>
     98c:	6800      	ldr	r0, [r0, #0]
     98e:	f7ff fed9 	bl	744 <simple_proc_test(Process*)>
	Serial.println("=== ComplimentaryFilter ===");
     992:	4923      	ldr	r1, [pc, #140]	; (a20 <main+0x170>)
     994:	481a      	ldr	r0, [pc, #104]	; (a00 <main+0x150>)
     996:	f7ff fcf7 	bl	388 <Print::println(char const*)>
	setup_proc_test(p_list[1], &cmf_config, 12);
     99a:	a803      	add	r0, sp, #12
     99c:	2101      	movs	r1, #1
     99e:	f000 fcc3 	bl	1328 <Vector<Process*>::operator[](int)>
     9a2:	220c      	movs	r2, #12
     9a4:	a901      	add	r1, sp, #4
     9a6:	6800      	ldr	r0, [r0, #0]
     9a8:	f7ff fde6 	bl	578 <setup_proc_test(Process*, Vector<float>*, int)>


	Serial.println("=== Finished Process tests ===");
     9ac:	491d      	ldr	r1, [pc, #116]	; (a24 <main+0x174>)
     9ae:	4814      	ldr	r0, [pc, #80]	; (a00 <main+0x150>)
     9b0:	f7ff fcea 	bl	388 <Print::println(char const*)>

	Serial.println("=== Starting Factory tests ==="); Serial.flush();

	Process_Factory p_fact;

	Vector<Process*> p_list(0);
     9b4:	a803      	add	r0, sp, #12
     9b6:	f000 fc55 	bl	1264 <Vector<Process*>::~Vector()>
	simple_proc_test(&imu);

	Serial.println("=== Starting ComplimentaryFilter tests ===");

	ComplimentaryFilter cmf;
	Vector<float> cmf_config(0);
     9ba:	a801      	add	r0, sp, #4
     9bc:	f000 fb74 	bl	10a8 <Vector<float>::~Vector()>
     9c0:	a80d      	add	r0, sp, #52	; 0x34
     9c2:	940c      	str	r4, [sp, #48]	; 0x30
     9c4:	f000 fb3e 	bl	1044 <Vector<int>::~Vector()>

/*!
 *    @brief  Class that stores state and functions for interacting with
 *            the LSM6DSOX I2C Digital Potentiometer
 */
class Adafruit_LSM6DSOX : public Adafruit_LSM6DS {
     9c8:	4a17      	ldr	r2, [pc, #92]	; (a28 <main+0x178>)
     9ca:	a852      	add	r0, sp, #328	; 0x148
	LIS3MDL_SINGLEMODE = 0b01,     ///< Single-shot conversion
	LIS3MDL_POWERDOWNMODE = 0b11,  ///< Powered-down mode
} lis3mdl_operationmode_t; */
#define IMU_M_OP_MODE LIS3MDL_CONTINUOUSMODE

class LSM6DSOX: public Process {
     9cc:	4b17      	ldr	r3, [pc, #92]	; (a2c <main+0x17c>)
     9ce:	f840 2d54 	str.w	r2, [r0, #-84]!
     9d2:	9326      	str	r3, [sp, #152]	; 0x98
     9d4:	f003 fa5e 	bl	3e94 <Adafruit_LSM6DS::~Adafruit_LSM6DS()>
     9d8:	a827      	add	r0, sp, #156	; 0x9c
     9da:	9426      	str	r4, [sp, #152]	; 0x98
     9dc:	f000 fb32 	bl	1044 <Vector<int>::~Vector()>
     9e0:	a806      	add	r0, sp, #24
     9e2:	9405      	str	r4, [sp, #20]
     9e4:	f000 fb2e 	bl	1044 <Vector<int>::~Vector()>


	Serial.println("=== Finished Process tests ===");

	return 0;
     9e8:	2000      	movs	r0, #0
     9ea:	b053      	add	sp, #332	; 0x14c
     9ec:	bd30      	pop	{r4, r5, pc}
     9ee:	bf00      	nop
     9f0:	2000275c 	.word	0x2000275c
     9f4:	2000275f 	.word	0x2000275f
     9f8:	20000540 	.word	0x20000540
     9fc:	20000cac 	.word	0x20000cac
     a00:	20001594 	.word	0x20001594
     a04:	20000cc8 	.word	0x20000cc8
     a08:	20000ce8 	.word	0x20000ce8
     a0c:	3f19999a 	.word	0x3f19999a
     a10:	20000d14 	.word	0x20000d14
     a14:	20000b78 	.word	0x20000b78
     a18:	20000b7c 	.word	0x20000b7c
     a1c:	20000d34 	.word	0x20000d34
     a20:	20000d48 	.word	0x20000d48
     a24:	20000d64 	.word	0x20000d64
     a28:	200004a8 	.word	0x200004a8
     a2c:	20000590 	.word	0x20000590

00000a30 <nd_norm(float*, int)>:
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     a30:	2900      	cmp	r1, #0
     a32:	dd15      	ble.n	a60 <nd_norm(float*, int)+0x30>
     a34:	ed9f 7a12 	vldr	s14, [pc, #72]	; a80 <nd_norm(float*, int)+0x50>
     a38:	eb00 0181 	add.w	r1, r0, r1, lsl #2
		sum += v[i] * v[i];
     a3c:	ecf0 7a01 	vldmia	r0!, {s15}
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     a40:	4281      	cmp	r1, r0
		sum += v[i] * v[i];
     a42:	eea7 7aa7 	vfma.f32	s14, s15, s15
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     a46:	d1f9      	bne.n	a3c <nd_norm(float*, int)+0xc>
     a48:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
		sum += v[i] * v[i];
	}
	return sqrt(sum);
     a4c:	eeb1 0bc7 	vsqrt.f64	d0, d7
     a50:	eeb4 0b40 	vcmp.f64	d0, d0
     a54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     a58:	d105      	bne.n	a66 <nd_norm(float*, int)+0x36>
}
     a5a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     a5e:	4770      	bx	lr
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     a60:	ed9f 7b05 	vldr	d7, [pc, #20]	; a78 <nd_norm(float*, int)+0x48>
     a64:	e7f2      	b.n	a4c <nd_norm(float*, int)+0x1c>

/*
	Vector ops
*/

float nd_norm(float* v, int n) {
     a66:	b508      	push	{r3, lr}
	float sum = 0;
	for (int i = 0; i < n; i++) {
		sum += v[i] * v[i];
	}
	return sqrt(sum);
     a68:	eeb0 0b47 	vmov.f64	d0, d7
     a6c:	f004 fa18 	bl	4ea0 <sqrt>
}
     a70:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     a74:	bd08      	pop	{r3, pc}
     a76:	bf00      	nop
	...

00000a84 <weighted_vector_addition(float*, float*, float, float, int, float*)>:

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     a84:	2a00      	cmp	r2, #0
     a86:	dd0d      	ble.n	aa4 <weighted_vector_addition(float*, float*, float, float, int, float*)+0x20>
     a88:	eb00 0282 	add.w	r2, r0, r2, lsl #2
		output[i] = (k1 * a[i]) + (k2 * b[i]);
     a8c:	ecf1 7a01 	vldmia	r1!, {s15}
     a90:	ecb0 7a01 	vldmia	r0!, {s14}
     a94:	ee67 7aa0 	vmul.f32	s15, s15, s1

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     a98:	4290      	cmp	r0, r2
		output[i] = (k1 * a[i]) + (k2 * b[i]);
     a9a:	eee7 7a00 	vfma.f32	s15, s14, s0
     a9e:	ece3 7a01 	vstmia	r3!, {s15}

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     aa2:	d1f3      	bne.n	a8c <weighted_vector_addition(float*, float*, float, float, int, float*)+0x8>
     aa4:	4770      	bx	lr
     aa6:	bf00      	nop

00000aa8 <LSM6DSOX::reset()>:
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     aa8:	2300      	movs	r3, #0
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     aaa:	2200      	movs	r2, #0
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     aac:	6103      	str	r3, [r0, #16]
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     aae:	60c2      	str	r2, [r0, #12]
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
     ab0:	61c3      	str	r3, [r0, #28]
		mag[i] = 0;
     ab2:	6283      	str	r3, [r0, #40]	; 0x28
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     ab4:	6143      	str	r3, [r0, #20]
		gyro[i] = 0;
     ab6:	6203      	str	r3, [r0, #32]
		mag[i] = 0;
     ab8:	62c3      	str	r3, [r0, #44]	; 0x2c
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     aba:	6183      	str	r3, [r0, #24]
		gyro[i] = 0;
     abc:	6243      	str	r3, [r0, #36]	; 0x24
		mag[i] = 0;
     abe:	6303      	str	r3, [r0, #48]	; 0x30
     ac0:	4770      	bx	lr
     ac2:	bf00      	nop

00000ac4 <LSM6DSOX::clear()>:
	}
}

void LSM6DSOX::clear() {
	reset();
     ac4:	6803      	ldr	r3, [r0, #0]
     ac6:	68db      	ldr	r3, [r3, #12]
     ac8:	4718      	bx	r3
     aca:	bf00      	nop

00000acc <LSM6DSOX::setup(Vector<float>*)>:
}

void LSM6DSOX::setup(Vector<float>* config) {
	reset();
     acc:	6803      	ldr	r3, [r0, #0]
     ace:	68db      	ldr	r3, [r3, #12]
     ad0:	4718      	bx	r3
     ad2:	bf00      	nop

00000ad4 <LSM6DSOX::context(Vector<float>*)>:
}

void LSM6DSOX::context(Vector<float>* context) {
     ad4:	b538      	push	{r3, r4, r5, lr}
     ad6:	460c      	mov	r4, r1
     ad8:	4605      	mov	r5, r0
	context->reset(dimensions[2]);
     ada:	2102      	movs	r1, #2
     adc:	3004      	adds	r0, #4
     ade:	f000 fad5 	bl	108c <Vector<int>::operator[](int)>
     ae2:	6801      	ldr	r1, [r0, #0]
     ae4:	4620      	mov	r0, r4
     ae6:	f000 faff 	bl	10e8 <Vector<float>::reset(int)>
	context->push(sensor_index);
     aea:	ed95 0a03 	vldr	s0, [r5, #12]
     aee:	4620      	mov	r0, r4
     af0:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
}
     af4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	reset();
}

void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
     af8:	f000 bb1a 	b.w	1130 <Vector<float>::push(float)>

00000afc <LSM6DSOX::run(Vector<float>*, Vector<float>*)>:
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
	switch (sensor_index) {
     afc:	68c3      	ldr	r3, [r0, #12]
     afe:	2b01      	cmp	r3, #1
void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
     b00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     b04:	4604      	mov	r4, r0
     b06:	b08a      	sub	sp, #40	; 0x28
     b08:	4617      	mov	r7, r2
	switch (sensor_index) {
     b0a:	d04c      	beq.n	ba6 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0xaa>
     b0c:	2b02      	cmp	r3, #2
     b0e:	d039      	beq.n	b84 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x88>
     b10:	b333      	cbz	r3, b60 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x64>
			read_lis3mdl();
			sensor_index = 0;
			break;

		default:
			sensor_index = 0;
     b12:	2300      	movs	r3, #0
     b14:	f100 0810 	add.w	r8, r0, #16
     b18:	f100 061c 	add.w	r6, r0, #28
     b1c:	f100 0528 	add.w	r5, r0, #40	; 0x28
     b20:	60c3      	str	r3, [r0, #12]
     b22:	46c6      	mov	lr, r8
     b24:	4631      	mov	r1, r6
     b26:	4628      	mov	r0, r5
     b28:	ab01      	add	r3, sp, #4
void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
     b2a:	2203      	movs	r2, #3
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		tmp[i] = accel[i];
     b2c:	f85e cb04 	ldr.w	ip, [lr], #4
			sensor_index = 0;
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
     b30:	3a01      	subs	r2, #1
		tmp[i] = accel[i];
		tmp[i+3] = gyro[i];
     b32:	f851 6b04 	ldr.w	r6, [r1], #4
     b36:	f103 0304 	add.w	r3, r3, #4
		tmp[i+6] = mag[i];
     b3a:	f850 5b04 	ldr.w	r5, [r0], #4
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		tmp[i] = accel[i];
     b3e:	f843 cc04 	str.w	ip, [r3, #-4]
		tmp[i+3] = gyro[i];
     b42:	609e      	str	r6, [r3, #8]
		tmp[i+6] = mag[i];
     b44:	615d      	str	r5, [r3, #20]
			sensor_index = 0;
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
     b46:	d1f1      	bne.n	b2c <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x30>
		tmp[i] = accel[i];
		tmp[i+3] = gyro[i];
		tmp[i+6] = mag[i];
	}

	output->from_array(tmp, dimensions[OUTPUT_DIMENSION]);
     b48:	1d20      	adds	r0, r4, #4
     b4a:	2102      	movs	r1, #2
     b4c:	f000 fa9e 	bl	108c <Vector<int>::operator[](int)>
     b50:	a901      	add	r1, sp, #4
     b52:	6802      	ldr	r2, [r0, #0]
     b54:	4638      	mov	r0, r7
     b56:	f000 fadd 	bl	1114 <Vector<float>::from_array(float*, int)>
}
     b5a:	b00a      	add	sp, #40	; 0x28
     b5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

void LSM6DSOX::read_lsm6dsox_accel(){
	/*
		Get the jawns from the jimmys
	*/
	lsm6dsox.readAcceleration(accel[0], accel[1], accel[2]);
     b60:	f100 0810 	add.w	r8, r0, #16
     b64:	f100 0318 	add.w	r3, r0, #24
     b68:	f100 0214 	add.w	r2, r0, #20
     b6c:	305c      	adds	r0, #92	; 0x5c
     b6e:	4641      	mov	r1, r8
     b70:	f104 061c 	add.w	r6, r4, #28
     b74:	f003 fd18 	bl	45a8 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)>

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
	switch (sensor_index) {
		case 0:
			read_lsm6dsox_accel();
			sensor_index ++;
     b78:	68e3      	ldr	r3, [r4, #12]
     b7a:	f104 0528 	add.w	r5, r4, #40	; 0x28
     b7e:	3301      	adds	r3, #1
     b80:	60e3      	str	r3, [r4, #12]
			break;
     b82:	e7ce      	b.n	b22 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>

void LSM6DSOX::read_lis3mdl(){
	/*
		Get the jawns from the jimmys
	*/
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
     b84:	f100 0528 	add.w	r5, r0, #40	; 0x28
     b88:	f100 0330 	add.w	r3, r0, #48	; 0x30
     b8c:	f100 022c 	add.w	r2, r0, #44	; 0x2c
     b90:	3034      	adds	r0, #52	; 0x34
     b92:	4629      	mov	r1, r5
     b94:	f104 0810 	add.w	r8, r4, #16
     b98:	f003 f90e 	bl	3db8 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)>
			sensor_index ++;
			break;

		case 2:
			read_lis3mdl();
			sensor_index = 0;
     b9c:	2300      	movs	r3, #0
     b9e:	f104 061c 	add.w	r6, r4, #28
     ba2:	60e3      	str	r3, [r4, #12]
			break;
     ba4:	e7bd      	b.n	b22 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>

void LSM6DSOX::read_lsm6dsox_gyro(){
	/*
		Get the jawns from the jimmys
	*/
	lsm6dsox.readGyroscope(gyro[0], gyro[1], gyro[2]);
     ba6:	f100 061c 	add.w	r6, r0, #28
     baa:	f100 0324 	add.w	r3, r0, #36	; 0x24
     bae:	f100 0220 	add.w	r2, r0, #32
     bb2:	305c      	adds	r0, #92	; 0x5c
     bb4:	4631      	mov	r1, r6
     bb6:	f104 0810 	add.w	r8, r4, #16
     bba:	f003 fd59 	bl	4670 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)>
			sensor_index ++;
			break;

		case 1:
			read_lsm6dsox_gyro();
			sensor_index ++;
     bbe:	68e3      	ldr	r3, [r4, #12]
     bc0:	f104 0528 	add.w	r5, r4, #40	; 0x28
     bc4:	3301      	adds	r3, #1
     bc6:	60e3      	str	r3, [r4, #12]
			break;
     bc8:	e7ab      	b.n	b22 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>
     bca:	bf00      	nop

00000bcc <LSM6DSOX::print()>:

	output->from_array(tmp, dimensions[OUTPUT_DIMENSION]);
}


void LSM6DSOX::print() {
     bcc:	b530      	push	{r4, r5, lr}
     bce:	4d29      	ldr	r5, [pc, #164]	; (c74 <LSM6DSOX::print()+0xa8>)
     bd0:	b085      	sub	sp, #20
     bd2:	4604      	mov	r4, r0
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
     bd4:	2108      	movs	r1, #8
     bd6:	4828      	ldr	r0, [pc, #160]	; (c78 <LSM6DSOX::print()+0xac>)
     bd8:	f002 f82a 	bl	2c30 <usb_seremu_write>
     bdc:	4628      	mov	r0, r5
     bde:	f002 f8dd 	bl	2d9c <Print::println()>
	Serial.println("LSM6DSOX");
	Serial.printf("\tsensor_index: %i\n", sensor_index);
     be2:	68e2      	ldr	r2, [r4, #12]
     be4:	4628      	mov	r0, r5
     be6:	4925      	ldr	r1, [pc, #148]	; (c7c <LSM6DSOX::print()+0xb0>)
     be8:	f002 f8f0 	bl	2dcc <Print::printf(char const*, ...)>
	Serial.printf("\taccel: [%f, %f, %f]\n", accel[0], accel[1], accel[2]);
     bec:	ed94 6a06 	vldr	s12, [r4, #24]
     bf0:	ed94 7a05 	vldr	s14, [r4, #20]
     bf4:	4628      	mov	r0, r5
     bf6:	edd4 5a04 	vldr	s11, [r4, #16]
     bfa:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     bfe:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     c02:	491f      	ldr	r1, [pc, #124]	; (c80 <LSM6DSOX::print()+0xb4>)
     c04:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     c08:	ed8d 6b02 	vstr	d6, [sp, #8]
     c0c:	ec53 2b15 	vmov	r2, r3, d5
     c10:	ed8d 7b00 	vstr	d7, [sp]
     c14:	f002 f8da 	bl	2dcc <Print::printf(char const*, ...)>
	Serial.printf("\tgyro: [%f, %f, %f]\n", gyro[0], gyro[1], gyro[2]);
     c18:	ed94 6a09 	vldr	s12, [r4, #36]	; 0x24
     c1c:	ed94 7a08 	vldr	s14, [r4, #32]
     c20:	4628      	mov	r0, r5
     c22:	edd4 5a07 	vldr	s11, [r4, #28]
     c26:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     c2a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     c2e:	4915      	ldr	r1, [pc, #84]	; (c84 <LSM6DSOX::print()+0xb8>)
     c30:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     c34:	ed8d 6b02 	vstr	d6, [sp, #8]
     c38:	ec53 2b15 	vmov	r2, r3, d5
     c3c:	ed8d 7b00 	vstr	d7, [sp]
     c40:	f002 f8c4 	bl	2dcc <Print::printf(char const*, ...)>
	Serial.printf("\tmag: [%f, %f, %f]\n", mag[0], mag[1], mag[2]);
     c44:	ed94 6a0c 	vldr	s12, [r4, #48]	; 0x30
     c48:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
     c4c:	4628      	mov	r0, r5
     c4e:	edd4 5a0a 	vldr	s11, [r4, #40]	; 0x28
     c52:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     c56:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     c5a:	490b      	ldr	r1, [pc, #44]	; (c88 <LSM6DSOX::print()+0xbc>)
     c5c:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     c60:	ed8d 6b02 	vstr	d6, [sp, #8]
     c64:	ec53 2b15 	vmov	r2, r3, d5
     c68:	ed8d 7b00 	vstr	d7, [sp]
     c6c:	f002 f8ae 	bl	2dcc <Print::printf(char const*, ...)>
	// data.print();
}
     c70:	b005      	add	sp, #20
     c72:	bd30      	pop	{r4, r5, pc}
     c74:	20001594 	.word	0x20001594
     c78:	20000d84 	.word	0x20000d84
     c7c:	20000d90 	.word	0x20000d90
     c80:	20000da4 	.word	0x20000da4
     c84:	20000dbc 	.word	0x20000dbc
     c88:	20000dd4 	.word	0x20000dd4

00000c8c <LSM6DSOX::LSM6DSOX()>:
#include "lsm6dsox.h"

LSM6DSOX::LSM6DSOX() {
     c8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     c90:	4b48      	ldr	r3, [pc, #288]	; (db4 <LSM6DSOX::LSM6DSOX()+0x128>)
     c92:	4680      	mov	r8, r0
     c94:	b084      	sub	sp, #16
     c96:	4605      	mov	r5, r0
     c98:	f100 075c 	add.w	r7, r0, #92	; 0x5c
     c9c:	4606      	mov	r6, r0
     c9e:	f848 3b04 	str.w	r3, [r8], #4
     ca2:	4640      	mov	r0, r8
     ca4:	f000 f9ca 	bl	103c <Vector<int>::Vector()>
     ca8:	4b43      	ldr	r3, [pc, #268]	; (db8 <LSM6DSOX::LSM6DSOX()+0x12c>)
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     caa:	2400      	movs	r4, #0
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     cac:	f8df a10c 	ldr.w	sl, [pc, #268]	; dbc <LSM6DSOX::LSM6DSOX()+0x130>
#include "lsm6dsox.h"

LSM6DSOX::LSM6DSOX() {
     cb0:	f846 3b34 	str.w	r3, [r6], #52
     cb4:	4630      	mov	r0, r6
     cb6:	f002 fe93 	bl	39e0 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()>
     cba:	4638      	mov	r0, r7
     cbc:	f003 fd56 	bl	476c <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()>
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     cc0:	f04f 0e00 	mov.w	lr, #0
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     cc4:	4623      	mov	r3, r4
     cc6:	4652      	mov	r2, sl
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     cc8:	f8c5 e010 	str.w	lr, [r5, #16]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     ccc:	4638      	mov	r0, r7

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
     cce:	f8c5 e01c 	str.w	lr, [r5, #28]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     cd2:	216a      	movs	r1, #106	; 0x6a
void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
		mag[i] = 0;
     cd4:	f8c5 e028 	str.w	lr, [r5, #40]	; 0x28
	lis3mdl.setOperationMode(IMU_M_OP_MODE);
	
	lis3mdl.configInterrupt(false, false, false,   // enable z axis
											true,  // polarity
											false, // don't latch
											true); // enabled!
     cd8:	f04f 0901 	mov.w	r9, #1
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     cdc:	f8c5 e014 	str.w	lr, [r5, #20]
		gyro[i] = 0;
     ce0:	f8c5 e020 	str.w	lr, [r5, #32]
		mag[i] = 0;
     ce4:	f8c5 e02c 	str.w	lr, [r5, #44]	; 0x2c
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     ce8:	f8c5 e018 	str.w	lr, [r5, #24]
		gyro[i] = 0;
     cec:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
		mag[i] = 0;
     cf0:	f8c5 e030 	str.w	lr, [r5, #48]	; 0x30
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     cf4:	60ec      	str	r4, [r5, #12]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     cf6:	f003 fabd 	bl	4274 <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)>
	lsm6dsox.setAccelRange(IMU_A_RANGE);
     cfa:	4638      	mov	r0, r7
     cfc:	2102      	movs	r1, #2
     cfe:	f003 fb1f 	bl	4340 <Adafruit_LSM6DS::setAccelRange(accel_range)>
	lsm6dsox.setGyroRange(IMU_G_RANGE);
     d02:	4638      	mov	r0, r7
     d04:	2108      	movs	r1, #8
     d06:	f003 fb5b 	bl	43c0 <Adafruit_LSM6DS::setGyroRange(gyro_range)>
	lsm6dsox.setAccelDataRate(IMU_A_DATA_RATE);
     d0a:	4638      	mov	r0, r7
     d0c:	2108      	movs	r1, #8
     d0e:	f003 faf7 	bl	4300 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>
	lsm6dsox.setGyroDataRate(IMU_G_DATA_RATE);
     d12:	4638      	mov	r0, r7
     d14:	2108      	movs	r1, #8
     d16:	f003 fb35 	bl	4384 <Adafruit_LSM6DS::setGyroDataRate(data_rate)>
		@param active_low true to set the pins  as active high, false to set the
		mode to active low
		@param open_drain true to set the pin mode as open-drain, false to set the
		mode to push-pull
	*/
	lsm6dsox.configIntOutputs(false, true);
     d1a:	4638      	mov	r0, r7
     d1c:	4621      	mov	r1, r4
     d1e:	464a      	mov	r2, r9
     d20:	f003 fbba 	bl	4498 <Adafruit_LSM6DS::configIntOutputs(bool, bool)>
		@param drdy_g true to output the data ready gyro interrupt
		@param drdy_xl true to output the data ready accelerometer interrupt
		@param step_detect true to output the step detection interrupt (default off)
		@param wakeup true to output the wake up interrupt (default off)
	*/
	lsm6dsox.configInt1(false, false, false, false, false);
     d24:	4638      	mov	r0, r7
     d26:	4623      	mov	r3, r4
     d28:	4622      	mov	r2, r4
     d2a:	4621      	mov	r1, r4
     d2c:	9401      	str	r4, [sp, #4]
     d2e:	9400      	str	r4, [sp, #0]
     d30:	f003 fbd4 	bl	44dc <Adafruit_LSM6DS::configInt1(bool, bool, bool, bool, bool)>
		@brief Enables and disables the data ready interrupt on INT 2.
		@param drdy_temp true to output the data ready temperature interrupt
		@param drdy_g true to output the data ready gyro interrupt
		@param drdy_xl true to output the data ready accelerometer interrupt
	*/
	lsm6dsox.configInt2(false, false, false);
     d34:	4623      	mov	r3, r4
     d36:	4622      	mov	r2, r4
     d38:	4621      	mov	r1, r4
     d3a:	4638      	mov	r0, r7
     d3c:	f003 fc0c 	bl	4558 <Adafruit_LSM6DS::configInt2(bool, bool, bool)>

	// LIS3MDL Setup
	lis3mdl.begin_I2C();
     d40:	4652      	mov	r2, sl
     d42:	4630      	mov	r0, r6
     d44:	211c      	movs	r1, #28
     d46:	f002 ffeb 	bl	3d20 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)>
	lis3mdl.setRange(IMU_M_RANGE);
     d4a:	4630      	mov	r0, r6
     d4c:	4649      	mov	r1, r9
     d4e:	f002 ff5d 	bl	3c0c <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>
	lis3mdl.setDataRate(IMU_M_DATA_RATE);
     d52:	4630      	mov	r0, r6
     d54:	2107      	movs	r1, #7
     d56:	f002 ff05 	bl	3b64 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>
	lis3mdl.setPerformanceMode(IMU_M_PERFORMANCE);
     d5a:	4630      	mov	r0, r6
     d5c:	2103      	movs	r1, #3
     d5e:	f002 fecb 	bl	3af8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
	lis3mdl.setOperationMode(IMU_M_OP_MODE);
     d62:	4621      	mov	r1, r4
     d64:	4630      	mov	r0, r6
     d66:	f002 ff35 	bl	3bd4 <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>
	
	lis3mdl.configInterrupt(false, false, false,   // enable z axis
											true,  // polarity
											false, // don't latch
											true); // enabled!
     d6a:	4622      	mov	r2, r4
     d6c:	4623      	mov	r3, r4
     d6e:	4630      	mov	r0, r6
     d70:	4621      	mov	r1, r4
     d72:	9401      	str	r4, [sp, #4]
     d74:	f8cd 9008 	str.w	r9, [sp, #8]
     d78:	f8cd 9000 	str.w	r9, [sp]
     d7c:	f002 fff0 	bl	3d60 <Adafruit_LIS3MDL::configInterrupt(bool, bool, bool, bool, bool, bool)>

	dimensions.reset(PROCESS_DIMENSIONS);
     d80:	4640      	mov	r0, r8
     d82:	2103      	movs	r1, #3
     d84:	f000 f96c 	bl	1060 <Vector<int>::reset(int)>
	dimensions[INPUT_DIMENSION] = 0;
     d88:	4621      	mov	r1, r4
     d8a:	4640      	mov	r0, r8
     d8c:	f000 f97e 	bl	108c <Vector<int>::operator[](int)>
     d90:	4603      	mov	r3, r0
	dimensions[CONTEXT_DIMENSION] = 1;
     d92:	4649      	mov	r1, r9
     d94:	4640      	mov	r0, r8
											true,  // polarity
											false, // don't latch
											true); // enabled!

	dimensions.reset(PROCESS_DIMENSIONS);
	dimensions[INPUT_DIMENSION] = 0;
     d96:	601c      	str	r4, [r3, #0]
	dimensions[CONTEXT_DIMENSION] = 1;
     d98:	f000 f978 	bl	108c <Vector<int>::operator[](int)>
	dimensions[OUTPUT_DIMENSION] = LSM6DSOX_DOF;
     d9c:	2102      	movs	r1, #2
											false, // don't latch
											true); // enabled!

	dimensions.reset(PROCESS_DIMENSIONS);
	dimensions[INPUT_DIMENSION] = 0;
	dimensions[CONTEXT_DIMENSION] = 1;
     d9e:	f8c0 9000 	str.w	r9, [r0]
	dimensions[OUTPUT_DIMENSION] = LSM6DSOX_DOF;
     da2:	4640      	mov	r0, r8
     da4:	f000 f972 	bl	108c <Vector<int>::operator[](int)>
     da8:	2309      	movs	r3, #9
     daa:	6003      	str	r3, [r0, #0]
}
     dac:	4628      	mov	r0, r5
     dae:	b004      	add	sp, #16
     db0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     db4:	20000540 	.word	0x20000540
     db8:	20000590 	.word	0x20000590
     dbc:	200015a4 	.word	0x200015a4

00000dc0 <Process::reset()>:
#include "system_graph/process.h"

// Drivers
#include "sensors/lsm6dsox.h"

void Process::reset() {
     dc0:	b508      	push	{r3, lr}
     dc2:	2109      	movs	r1, #9
     dc4:	4803      	ldr	r0, [pc, #12]	; (dd4 <Process::reset()+0x14>)
     dc6:	f001 ff33 	bl	2c30 <usb_seremu_write>
     dca:	4803      	ldr	r0, [pc, #12]	; (dd8 <Process::reset()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Reset");
}
     dcc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     dd0:	f001 bfe4 	b.w	2d9c <Print::println()>
     dd4:	20000de8 	.word	0x20000de8
     dd8:	20001594 	.word	0x20001594

00000ddc <Process::clear()>:

void Process::clear() {
     ddc:	b508      	push	{r3, lr}
     dde:	2109      	movs	r1, #9
     de0:	4803      	ldr	r0, [pc, #12]	; (df0 <Process::clear()+0x14>)
     de2:	f001 ff25 	bl	2c30 <usb_seremu_write>
     de6:	4803      	ldr	r0, [pc, #12]	; (df4 <Process::clear()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Clear");
}
     de8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     dec:	f001 bfd6 	b.w	2d9c <Print::println()>
     df0:	20000df4 	.word	0x20000df4
     df4:	20001594 	.word	0x20001594

00000df8 <Process::print()>:

void Process::print() {
     df8:	b508      	push	{r3, lr}
     dfa:	2109      	movs	r1, #9
     dfc:	4803      	ldr	r0, [pc, #12]	; (e0c <Process::print()+0x14>)
     dfe:	f001 ff17 	bl	2c30 <usb_seremu_write>
     e02:	4803      	ldr	r0, [pc, #12]	; (e10 <Process::print()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Print");
}
     e04:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     e08:	f001 bfc8 	b.w	2d9c <Print::println()>
     e0c:	20000e00 	.word	0x20000e00
     e10:	20001594 	.word	0x20001594

00000e14 <Process::setup(Vector<float>*)>:
	*/
	Serial.println("PBO Output Dimension");
	return dimensions[2];
}

void Process::setup(Vector<float>* config) {
     e14:	b510      	push	{r4, lr}
     e16:	4806      	ldr	r0, [pc, #24]	; (e30 <Process::setup(Vector<float>*)+0x1c>)
     e18:	460c      	mov	r4, r1
     e1a:	2109      	movs	r1, #9
     e1c:	f001 ff08 	bl	2c30 <usb_seremu_write>
     e20:	4804      	ldr	r0, [pc, #16]	; (e34 <Process::setup(Vector<float>*)+0x20>)
     e22:	f001 ffbb 	bl	2d9c <Print::println()>
		@param
			config: (Vector<float>) Vector of configuration data, 
				organization is handled by user
	*/
	Serial.println("PBO Setup");
	config->print();
     e26:	4620      	mov	r0, r4
}
     e28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		@param
			config: (Vector<float>) Vector of configuration data, 
				organization is handled by user
	*/
	Serial.println("PBO Setup");
	config->print();
     e2c:	f000 b896 	b.w	f5c <Vector<float>::print()>
     e30:	20000e0c 	.word	0x20000e0c
     e34:	20001594 	.word	0x20001594

00000e38 <Process::run(Vector<float>*, Vector<float>*)>:
	*/
	Serial.println("Requested PBO context");
	context->reset(0);
}

void Process::run(Vector<float>* input, Vector<float>* output) {
     e38:	b510      	push	{r4, lr}
     e3a:	2107      	movs	r1, #7
     e3c:	4614      	mov	r4, r2
     e3e:	4806      	ldr	r0, [pc, #24]	; (e58 <Process::run(Vector<float>*, Vector<float>*)+0x20>)
     e40:	f001 fef6 	bl	2c30 <usb_seremu_write>
     e44:	4805      	ldr	r0, [pc, #20]	; (e5c <Process::run(Vector<float>*, Vector<float>*)+0x24>)
     e46:	f001 ffa9 	bl	2d9c <Print::println()>
		@param
			input: (Vector<float>*) flattened Vector of input data for process
			output: (Vector<float>*) flattened Vector of output data from process
	*/
	Serial.println("PBO Run");
	output->reset(0);
     e4a:	4620      	mov	r0, r4
     e4c:	2100      	movs	r1, #0
}
     e4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		@param
			input: (Vector<float>*) flattened Vector of input data for process
			output: (Vector<float>*) flattened Vector of output data from process
	*/
	Serial.println("PBO Run");
	output->reset(0);
     e52:	f000 b949 	b.w	10e8 <Vector<float>::reset(int)>
     e56:	bf00      	nop
     e58:	20000e18 	.word	0x20000e18
     e5c:	20001594 	.word	0x20001594

00000e60 <Process::context(Vector<float>*)>:
	*/
	Serial.println("PBO Setup");
	config->print();
}

void Process::context(Vector<float>* context) {
     e60:	b510      	push	{r4, lr}
     e62:	4807      	ldr	r0, [pc, #28]	; (e80 <Process::context(Vector<float>*)+0x20>)
     e64:	460c      	mov	r4, r1
     e66:	2115      	movs	r1, #21
     e68:	f001 fee2 	bl	2c30 <usb_seremu_write>
     e6c:	4805      	ldr	r0, [pc, #20]	; (e84 <Process::context(Vector<float>*)+0x24>)
     e6e:	f001 ff95 	bl	2d9c <Print::println()>
		Only defined to show user when inheritance has issues.
		@param
			context: (Vector<float>*) empty vector to fill with the context
	*/
	Serial.println("Requested PBO context");
	context->reset(0);
     e72:	4620      	mov	r0, r4
     e74:	2100      	movs	r1, #0
}
     e76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		Only defined to show user when inheritance has issues.
		@param
			context: (Vector<float>*) empty vector to fill with the context
	*/
	Serial.println("Requested PBO context");
	context->reset(0);
     e7a:	f000 b935 	b.w	10e8 <Vector<float>::reset(int)>
     e7e:	bf00      	nop
     e80:	20000e20 	.word	0x20000e20
     e84:	20001594 	.word	0x20001594

00000e88 <Process::input_dim()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Print");
}

int Process::input_dim() {
     e88:	b510      	push	{r4, lr}
     e8a:	2113      	movs	r1, #19
     e8c:	4604      	mov	r4, r0
     e8e:	4806      	ldr	r0, [pc, #24]	; (ea8 <Process::input_dim()+0x20>)
     e90:	f001 fece 	bl	2c30 <usb_seremu_write>
     e94:	4805      	ldr	r0, [pc, #20]	; (eac <Process::input_dim()+0x24>)
     e96:	f001 ff81 	bl	2d9c <Print::println()>
		Only defined to show user when inheritance has issues.
		@return
			dimension: (int) size of input
	*/
	Serial.println("PBO Input Dimension");
	return dimensions[0];
     e9a:	1d20      	adds	r0, r4, #4
     e9c:	2100      	movs	r1, #0
     e9e:	f000 f8f5 	bl	108c <Vector<int>::operator[](int)>
}
     ea2:	6800      	ldr	r0, [r0, #0]
     ea4:	bd10      	pop	{r4, pc}
     ea6:	bf00      	nop
     ea8:	20000e38 	.word	0x20000e38
     eac:	20001594 	.word	0x20001594

00000eb0 <Process::context_dim()>:

int Process::context_dim() {
     eb0:	b510      	push	{r4, lr}
     eb2:	2115      	movs	r1, #21
     eb4:	4604      	mov	r4, r0
     eb6:	4806      	ldr	r0, [pc, #24]	; (ed0 <Process::context_dim()+0x20>)
     eb8:	f001 feba 	bl	2c30 <usb_seremu_write>
     ebc:	4805      	ldr	r0, [pc, #20]	; (ed4 <Process::context_dim()+0x24>)
     ebe:	f001 ff6d 	bl	2d9c <Print::println()>
		Only defined to show user when inheritance has issues.
		@return
			dimension: (int) size of input
	*/
	Serial.println("PBO Context Dimension");
	return dimensions[1];
     ec2:	1d20      	adds	r0, r4, #4
     ec4:	2101      	movs	r1, #1
     ec6:	f000 f8e1 	bl	108c <Vector<int>::operator[](int)>
}
     eca:	6800      	ldr	r0, [r0, #0]
     ecc:	bd10      	pop	{r4, pc}
     ece:	bf00      	nop
     ed0:	20000e4c 	.word	0x20000e4c
     ed4:	20001594 	.word	0x20001594

00000ed8 <Process::output_dim()>:

int Process::output_dim() {
     ed8:	b510      	push	{r4, lr}
     eda:	2114      	movs	r1, #20
     edc:	4604      	mov	r4, r0
     ede:	4806      	ldr	r0, [pc, #24]	; (ef8 <Process::output_dim()+0x20>)
     ee0:	f001 fea6 	bl	2c30 <usb_seremu_write>
     ee4:	4805      	ldr	r0, [pc, #20]	; (efc <Process::output_dim()+0x24>)
     ee6:	f001 ff59 	bl	2d9c <Print::println()>
		Only defined to show user when inheritance has issues.
		@return
			dimension: (int) size of input
	*/
	Serial.println("PBO Output Dimension");
	return dimensions[2];
     eea:	1d20      	adds	r0, r4, #4
     eec:	2102      	movs	r1, #2
     eee:	f000 f8cd 	bl	108c <Vector<int>::operator[](int)>
}
     ef2:	6800      	ldr	r0, [r0, #0]
     ef4:	bd10      	pop	{r4, pc}
     ef6:	bf00      	nop
     ef8:	20000e64 	.word	0x20000e64
     efc:	20001594 	.word	0x20001594

00000f00 <FTYK::FTYK()>:
	uint32_t delta_ns = CYCLES_2_NS(delta_cycles); 
	Serial.printf( "\t%1lu cycles, %1lu ns\n", delta_cycles, delta_ns);
	return delta_ns;
}

FTYK::FTYK() {
     f00:	b410      	push	{r4}
     f02:	1f03      	subs	r3, r0, #4
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
		timers[i] = ARM_DWT_CYCCNT;
     f04:	4c05      	ldr	r4, [pc, #20]	; (f1c <FTYK::FTYK()+0x1c>)
     f06:	f100 0124 	add.w	r1, r0, #36	; 0x24
     f0a:	6822      	ldr	r2, [r4, #0]
     f0c:	f843 2f04 	str.w	r2, [r3, #4]!
			- add rollover support: ARM_DWT_CYCCNT is a cycle count that resets every 8
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
     f10:	428b      	cmp	r3, r1
     f12:	d1fa      	bne.n	f0a <FTYK::FTYK()+0xa>
		timers[i] = ARM_DWT_CYCCNT;
	}
}
     f14:	f85d 4b04 	ldr.w	r4, [sp], #4
     f18:	4770      	bx	lr
     f1a:	bf00      	nop
     f1c:	e0001004 	.word	0xe0001004

00000f20 <FTYK::set(int)>:
	/*
		  Set the timer at idx to the current cycle count.
		@param:
			idx: (int) index of the timer to set.
	*/
	timers[idx] = ARM_DWT_CYCCNT;
     f20:	4b02      	ldr	r3, [pc, #8]	; (f2c <FTYK::set(int)+0xc>)
     f22:	681b      	ldr	r3, [r3, #0]
     f24:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
     f28:	4770      	bx	lr
     f2a:	bf00      	nop
     f2c:	e0001004 	.word	0xe0001004

00000f30 <FTYK::micros(int)>:
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     f30:	4b09      	ldr	r3, [pc, #36]	; (f58 <FTYK::micros(int)+0x28>)
	/*
		  Get the number of microseconds since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return CYCLES_2_US(cycles(idx)); 
     f32:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     f36:	681b      	ldr	r3, [r3, #0]
	/*
		  Get the number of microseconds since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return CYCLES_2_US(cycles(idx)); 
     f38:	1a9b      	subs	r3, r3, r2
     f3a:	ee00 3a10 	vmov	s0, r3
     f3e:	ed9f 7b04 	vldr	d7, [pc, #16]	; f50 <FTYK::micros(int)+0x20>
     f42:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
     f46:	ee20 0b07 	vmul.f64	d0, d0, d7
}
     f4a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     f4e:	4770      	bx	lr
     f50:	b4e81b4f 	.word	0xb4e81b4f
     f54:	3f5b4e81 	.word	0x3f5b4e81
     f58:	e0001004 	.word	0xe0001004

00000f5c <Vector<float>::print()>:
		Serial.printf("%i, ", buffer[i]);
	}
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
     f5c:	b570      	push	{r4, r5, r6, lr}
     f5e:	4605      	mov	r5, r0
	Serial.printf("Vectorf [%i]: [", length);
     f60:	4914      	ldr	r1, [pc, #80]	; (fb4 <Vector<float>::print()+0x58>)
     f62:	4815      	ldr	r0, [pc, #84]	; (fb8 <Vector<float>::print()+0x5c>)
     f64:	682a      	ldr	r2, [r5, #0]
     f66:	f001 ff31 	bl	2dcc <Print::printf(char const*, ...)>
	for (int i = 0; i < length-1; i++) {
     f6a:	682b      	ldr	r3, [r5, #0]
     f6c:	2b01      	cmp	r3, #1
     f6e:	dd12      	ble.n	f96 <Vector<float>::print()+0x3a>
     f70:	2400      	movs	r4, #0
		Serial.printf("%f, ", buffer[i]);
     f72:	686b      	ldr	r3, [r5, #4]
     f74:	4911      	ldr	r1, [pc, #68]	; (fbc <Vector<float>::print()+0x60>)
     f76:	eb03 0384 	add.w	r3, r3, r4, lsl #2
     f7a:	480f      	ldr	r0, [pc, #60]	; (fb8 <Vector<float>::print()+0x5c>)
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
     f7c:	3401      	adds	r4, #1
		Serial.printf("%f, ", buffer[i]);
     f7e:	edd3 7a00 	vldr	s15, [r3]
     f82:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
     f86:	ec53 2b17 	vmov	r2, r3, d7
     f8a:	f001 ff1f 	bl	2dcc <Print::printf(char const*, ...)>
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
     f8e:	682b      	ldr	r3, [r5, #0]
     f90:	1e5a      	subs	r2, r3, #1
     f92:	42a2      	cmp	r2, r4
     f94:	dced      	bgt.n	f72 <Vector<float>::print()+0x16>
		Serial.printf("%f, ", buffer[i]);
	}
	Serial.printf("%f]\n", buffer[length-1]);
     f96:	686a      	ldr	r2, [r5, #4]
     f98:	4909      	ldr	r1, [pc, #36]	; (fc0 <Vector<float>::print()+0x64>)
     f9a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
     f9e:	4806      	ldr	r0, [pc, #24]	; (fb8 <Vector<float>::print()+0x5c>)
     fa0:	ed53 7a01 	vldr	s15, [r3, #-4]
     fa4:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
}
     fa8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
template <> void Vector<float>::print() {
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
		Serial.printf("%f, ", buffer[i]);
	}
	Serial.printf("%f]\n", buffer[length-1]);
     fac:	ec53 2b17 	vmov	r2, r3, d7
     fb0:	f001 bf0c 	b.w	2dcc <Print::printf(char const*, ...)>
     fb4:	20000eac 	.word	0x20000eac
     fb8:	20001594 	.word	0x20001594
     fbc:	20000ebc 	.word	0x20000ebc
     fc0:	20000dcc 	.word	0x20000dcc

00000fc4 <Vector<Process*>::print()>:
}

template <> void Vector<Process*>::print() {
	if (length == 0) {
     fc4:	6802      	ldr	r2, [r0, #0]
     fc6:	b352      	cbz	r2, 101e <Vector<Process*>::print()+0x5a>
		Serial.printf("VectorP [%i]\n", length);
		return;
	}
	Serial.printf("VectorP [%i]: [", length);
     fc8:	4917      	ldr	r1, [pc, #92]	; (1028 <Vector<Process*>::print()+0x64>)
		Serial.printf("%f, ", buffer[i]);
	}
	Serial.printf("%f]\n", buffer[length-1]);
}

template <> void Vector<Process*>::print() {
     fca:	b538      	push	{r3, r4, r5, lr}
     fcc:	4605      	mov	r5, r0
	if (length == 0) {
		Serial.printf("VectorP [%i]\n", length);
		return;
	}
	Serial.printf("VectorP [%i]: [", length);
     fce:	4817      	ldr	r0, [pc, #92]	; (102c <Vector<Process*>::print()+0x68>)
     fd0:	f001 fefc 	bl	2dcc <Print::printf(char const*, ...)>
	for (int i = 0; i < length-1; i++) {
     fd4:	682b      	ldr	r3, [r5, #0]
     fd6:	2b01      	cmp	r3, #1
     fd8:	dd0f      	ble.n	ffa <Vector<Process*>::print()+0x36>
     fda:	2400      	movs	r4, #0
		buffer[i]->print();
     fdc:	686b      	ldr	r3, [r5, #4]
     fde:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
	if (length == 0) {
		Serial.printf("VectorP [%i]\n", length);
		return;
	}
	Serial.printf("VectorP [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
     fe2:	3401      	adds	r4, #1
		buffer[i]->print();
     fe4:	6803      	ldr	r3, [r0, #0]
     fe6:	695b      	ldr	r3, [r3, #20]
     fe8:	4798      	blx	r3
     fea:	2102      	movs	r1, #2
     fec:	4810      	ldr	r0, [pc, #64]	; (1030 <Vector<Process*>::print()+0x6c>)
     fee:	f001 fe1f 	bl	2c30 <usb_seremu_write>
	if (length == 0) {
		Serial.printf("VectorP [%i]\n", length);
		return;
	}
	Serial.printf("VectorP [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
     ff2:	682b      	ldr	r3, [r5, #0]
     ff4:	1e5a      	subs	r2, r3, #1
     ff6:	42a2      	cmp	r2, r4
     ff8:	dcf0      	bgt.n	fdc <Vector<Process*>::print()+0x18>
		buffer[i]->print();
		Serial.print(", ");
	}
	buffer[length-1]->print();
     ffa:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
     ffe:	6869      	ldr	r1, [r5, #4]
    1000:	441a      	add	r2, r3
    1002:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
    1006:	6803      	ldr	r3, [r0, #0]
    1008:	695b      	ldr	r3, [r3, #20]
    100a:	4798      	blx	r3
    100c:	2101      	movs	r1, #1
    100e:	4809      	ldr	r0, [pc, #36]	; (1034 <Vector<Process*>::print()+0x70>)
    1010:	f001 fe0e 	bl	2c30 <usb_seremu_write>
    1014:	4805      	ldr	r0, [pc, #20]	; (102c <Vector<Process*>::print()+0x68>)
	Serial.println("]");
}
    1016:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    101a:	f001 bebf 	b.w	2d9c <Print::println()>
	Serial.printf("%f]\n", buffer[length-1]);
}

template <> void Vector<Process*>::print() {
	if (length == 0) {
		Serial.printf("VectorP [%i]\n", length);
    101e:	4906      	ldr	r1, [pc, #24]	; (1038 <Vector<Process*>::print()+0x74>)
    1020:	4802      	ldr	r0, [pc, #8]	; (102c <Vector<Process*>::print()+0x68>)
    1022:	f001 bed3 	b.w	2dcc <Print::printf(char const*, ...)>
    1026:	bf00      	nop
    1028:	20000ed4 	.word	0x20000ed4
    102c:	20001594 	.word	0x20001594
    1030:	20000ee4 	.word	0x20000ee4
    1034:	20000b84 	.word	0x20000b84
    1038:	20000ec4 	.word	0x20000ec4

0000103c <Vector<int>::Vector()>:
#include "utilities/vector.h"
#include "system_graph/process.h"
#include "system_graph/graph_node.h"

template <typename T> Vector<T>::Vector() {
	length = 0;
    103c:	2200      	movs	r2, #0
    103e:	6002      	str	r2, [r0, #0]
	buffer = NULL;
    1040:	6042      	str	r2, [r0, #4]
}
    1042:	4770      	bx	lr

00001044 <Vector<int>::~Vector()>:

template <typename T> Vector<T>::~Vector() {
    1044:	b510      	push	{r4, lr}
    1046:	4604      	mov	r4, r0
	delete buffer;
    1048:	2104      	movs	r1, #4
    104a:	6840      	ldr	r0, [r0, #4]
    104c:	f001 ffe8 	bl	3020 <operator delete(void*, unsigned int)>
}
    1050:	4620      	mov	r0, r4
    1052:	bd10      	pop	{r4, pc}

00001054 <Vector<int>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
    1054:	6802      	ldr	r2, [r0, #0]
    1056:	2100      	movs	r1, #0
    1058:	6840      	ldr	r0, [r0, #4]
    105a:	0092      	lsls	r2, r2, #2
    105c:	f005 bea0 	b.w	6da0 <memset>

00001060 <Vector<int>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    1060:	b538      	push	{r3, r4, r5, lr}
    1062:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    1064:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    1066:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    1068:	b110      	cbz	r0, 1070 <Vector<int>::reset(int)+0x10>
		delete buffer;
    106a:	2104      	movs	r1, #4
    106c:	f001 ffd8 	bl	3020 <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
    1070:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
    1074:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
    1076:	bf94      	ite	ls
    1078:	00a0      	lslls	r0, r4, #2
    107a:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
    107e:	f001 ffcd 	bl	301c <operator new[](unsigned int)>
    1082:	6068      	str	r0, [r5, #4]
	clear();
    1084:	4628      	mov	r0, r5
    1086:	f7ff ffe5 	bl	1054 <Vector<int>::clear()>
    108a:	bd38      	pop	{r3, r4, r5, pc}

0000108c <Vector<int>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
    108c:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
    108e:	6803      	ldr	r3, [r0, #0]
    1090:	428b      	cmp	r3, r1
    1092:	dd05      	ble.n	10a0 <Vector<int>::operator[](int)+0x14>
    1094:	2900      	cmp	r1, #0
    1096:	db03      	blt.n	10a0 <Vector<int>::operator[](int)+0x14>
		return buffer[index];
    1098:	6840      	ldr	r0, [r0, #4]
    109a:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
    109e:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
    10a0:	2000      	movs	r0, #0
    10a2:	f005 fa4f 	bl	6544 <exit>
    10a6:	bf00      	nop

000010a8 <Vector<float>::~Vector()>:
template <typename T> Vector<T>::Vector() {
	length = 0;
	buffer = NULL;
}

template <typename T> Vector<T>::~Vector() {
    10a8:	b510      	push	{r4, lr}
    10aa:	4604      	mov	r4, r0
	delete buffer;
    10ac:	2104      	movs	r1, #4
    10ae:	6840      	ldr	r0, [r0, #4]
    10b0:	f001 ffb6 	bl	3020 <operator delete(void*, unsigned int)>
}
    10b4:	4620      	mov	r0, r4
    10b6:	bd10      	pop	{r4, pc}

000010b8 <Vector<float>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
    10b8:	6802      	ldr	r2, [r0, #0]
    10ba:	2100      	movs	r1, #0
    10bc:	6840      	ldr	r0, [r0, #4]
    10be:	0092      	lsls	r2, r2, #2
    10c0:	f005 be6e 	b.w	6da0 <memset>

000010c4 <Vector<float>::Vector(int)>:
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
	buffer = new T[size];
    10c4:	f1b1 5ffe 	cmp.w	r1, #532676608	; 0x1fc00000

template <typename T> Vector<T>::~Vector() {
	delete buffer;
}

template <typename T> Vector<T>::Vector(int size) {
    10c8:	b510      	push	{r4, lr}
    10ca:	4604      	mov	r4, r0
	/*
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
    10cc:	6001      	str	r1, [r0, #0]
	buffer = new T[size];
    10ce:	bf94      	ite	ls
    10d0:	0088      	lslls	r0, r1, #2
    10d2:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
    10d6:	f001 ffa1 	bl	301c <operator new[](unsigned int)>
    10da:	6060      	str	r0, [r4, #4]
	clear();
    10dc:	4620      	mov	r0, r4
    10de:	f7ff ffeb 	bl	10b8 <Vector<float>::clear()>
}
    10e2:	4620      	mov	r0, r4
    10e4:	bd10      	pop	{r4, pc}
    10e6:	bf00      	nop

000010e8 <Vector<float>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    10e8:	b538      	push	{r3, r4, r5, lr}
    10ea:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    10ec:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    10ee:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    10f0:	b110      	cbz	r0, 10f8 <Vector<float>::reset(int)+0x10>
		delete buffer;
    10f2:	2104      	movs	r1, #4
    10f4:	f001 ff94 	bl	3020 <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
    10f8:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
    10fc:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
    10fe:	bf94      	ite	ls
    1100:	00a0      	lslls	r0, r4, #2
    1102:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
    1106:	f001 ff89 	bl	301c <operator new[](unsigned int)>
    110a:	6068      	str	r0, [r5, #4]
	clear();
    110c:	4628      	mov	r0, r5
    110e:	f7ff ffd3 	bl	10b8 <Vector<float>::clear()>
    1112:	bd38      	pop	{r3, r4, r5, pc}

00001114 <Vector<float>::from_array(float*, int)>:
}

template <typename T> void Vector<T>::from_array(T* data, int size) {
    1114:	b570      	push	{r4, r5, r6, lr}
    1116:	4614      	mov	r4, r2
    1118:	460e      	mov	r6, r1
    111a:	4605      	mov	r5, r0
		  reset the buffer to size n with data T*.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
    111c:	4611      	mov	r1, r2
    111e:	f7ff ffe3 	bl	10e8 <Vector<float>::reset(int)>
	memcpy(buffer, data, size * sizeof(T));
    1122:	4631      	mov	r1, r6
    1124:	00a2      	lsls	r2, r4, #2
    1126:	6868      	ldr	r0, [r5, #4]
}
    1128:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
	memcpy(buffer, data, size * sizeof(T));
    112c:	f005 bd3a 	b.w	6ba4 <memcpy>

00001130 <Vector<float>::push(float)>:
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    1130:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    1132:	6806      	ldr	r6, [r0, #0]
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    1134:	4604      	mov	r4, r0
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
    1136:	6841      	ldr	r1, [r0, #4]
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    1138:	1c75      	adds	r5, r6, #1
    113a:	00aa      	lsls	r2, r5, #2
    113c:	f102 000a 	add.w	r0, r2, #10
	memcpy(tmp, buffer, length * sizeof(T));
    1140:	3a04      	subs	r2, #4
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    1142:	f020 0007 	bic.w	r0, r0, #7
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    1146:	ed2d 8b02 	vpush	{d8}
    114a:	af00      	add	r7, sp, #0
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    114c:	ebad 0d00 	sub.w	sp, sp, r0
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    1150:	eeb0 8a40 	vmov.f32	s16, s0
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
    1154:	4668      	mov	r0, sp
    1156:	f005 fd25 	bl	6ba4 <memcpy>
	tmp[length] = item;
	from_array(tmp, length+1);
    115a:	462a      	mov	r2, r5
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
    115c:	eb00 0386 	add.w	r3, r0, r6, lsl #2
	from_array(tmp, length+1);
    1160:	4601      	mov	r1, r0
    1162:	4620      	mov	r0, r4
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
    1164:	ed83 8a00 	vstr	s16, [r3]
	from_array(tmp, length+1);
    1168:	f7ff ffd4 	bl	1114 <Vector<float>::from_array(float*, int)>
}
    116c:	46bd      	mov	sp, r7
    116e:	ecbd 8b02 	vpop	{d8}
    1172:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00001174 <Vector<float>::size()>:
		  Get the size of buffer (not necessarily elements available)
		@return
			length: (int) size of buffer
	*/
	return length;
}
    1174:	6800      	ldr	r0, [r0, #0]
    1176:	4770      	bx	lr

00001178 <Vector<float>::as_array()>:
	return -1;
}

template <typename T> T* Vector<T>::as_array() {
	return buffer;
}
    1178:	6840      	ldr	r0, [r0, #4]
    117a:	4770      	bx	lr

0000117c <Vector<float>::append(Vector<float>*)>:
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
    117c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		  Add n values to the buffer. Stores the current buffer and
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
    1180:	f8d0 8000 	ldr.w	r8, [r0]
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
    1184:	af00      	add	r7, sp, #0
    1186:	4604      	mov	r4, r0
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();
    1188:	4608      	mov	r0, r1

	T tmp1[n];
    118a:	ea4f 0588 	mov.w	r5, r8, lsl #2
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
    118e:	4689      	mov	r9, r1
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();
    1190:	f7ff fff0 	bl	1174 <Vector<float>::size()>
    1194:	4606      	mov	r6, r0

	T tmp1[n];
    1196:	f105 030a 	add.w	r3, r5, #10
	T* tmp2 = data->as_array();
    119a:	4648      	mov	r0, r9
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();

	T tmp1[n];
    119c:	f023 0307 	bic.w	r3, r3, #7
    11a0:	ebad 0d03 	sub.w	sp, sp, r3
	T* tmp2 = data->as_array();
    11a4:	f7ff ffe8 	bl	1178 <Vector<float>::as_array()>

	reset(n + m);
    11a8:	eb08 0106 	add.w	r1, r8, r6
	*/
	int n = length;
	int m = data->size();

	T tmp1[n];
	T* tmp2 = data->as_array();
    11ac:	4681      	mov	r9, r0

	reset(n + m);
    11ae:	4620      	mov	r0, r4
    11b0:	f7ff ff9a 	bl	10e8 <Vector<float>::reset(int)>
	memcpy(buffer, tmp1, n * sizeof(T));
    11b4:	462a      	mov	r2, r5
    11b6:	4669      	mov	r1, sp
    11b8:	6860      	ldr	r0, [r4, #4]
    11ba:	f005 fcf3 	bl	6ba4 <memcpy>
	memcpy(&buffer[n], tmp2, m * sizeof(T));
    11be:	6860      	ldr	r0, [r4, #4]
    11c0:	00b2      	lsls	r2, r6, #2
    11c2:	4649      	mov	r1, r9
    11c4:	4428      	add	r0, r5
    11c6:	f005 fced 	bl	6ba4 <memcpy>
}
    11ca:	46bd      	mov	sp, r7
    11cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000011d0 <Vector<float>::insert(float*, int, int)>:

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
    11d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    11d2:	461d      	mov	r5, r3
    11d4:	460c      	mov	r4, r1
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
    11d6:	6803      	ldr	r3, [r0, #0]
	reset(n + m);
	memcpy(buffer, tmp1, n * sizeof(T));
	memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
    11d8:	b083      	sub	sp, #12
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
    11da:	1951      	adds	r1, r2, r5
	reset(n + m);
	memcpy(buffer, tmp1, n * sizeof(T));
	memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
    11dc:	4606      	mov	r6, r0
    11de:	4617      	mov	r7, r2
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
    11e0:	4299      	cmp	r1, r3
    11e2:	dc0f      	bgt.n	1204 <Vector<float>::insert(float*, int, int)+0x34>
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
    11e4:	2d00      	cmp	r5, #0
    11e6:	dd0b      	ble.n	1200 <Vector<float>::insert(float*, int, int)+0x30>
    11e8:	6870      	ldr	r0, [r6, #4]
    11ea:	4621      	mov	r1, r4
    11ec:	eb04 0385 	add.w	r3, r4, r5, lsl #2
    11f0:	eb00 0287 	add.w	r2, r0, r7, lsl #2
		buffer[i + index] = data[i];
    11f4:	f851 0b04 	ldr.w	r0, [r1], #4
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
    11f8:	428b      	cmp	r3, r1
		buffer[i + index] = data[i];
    11fa:	f842 0b04 	str.w	r0, [r2], #4
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
    11fe:	d1f9      	bne.n	11f4 <Vector<float>::insert(float*, int, int)+0x24>
		buffer[i + index] = data[i];
	}
}
    1200:	b003      	add	sp, #12
    1202:	bdf0      	pop	{r4, r5, r6, r7, pc}
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
    1204:	1ac9      	subs	r1, r1, r3
    1206:	4668      	mov	r0, sp
    1208:	f7ff ff5c 	bl	10c4 <Vector<float>::Vector(int)>
		append(&empty);
    120c:	4630      	mov	r0, r6
    120e:	4669      	mov	r1, sp
    1210:	f7ff ffb4 	bl	117c <Vector<float>::append(Vector<float>*)>
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
    1214:	4668      	mov	r0, sp
    1216:	f7ff ff47 	bl	10a8 <Vector<float>::~Vector()>
    121a:	e7e3      	b.n	11e4 <Vector<float>::insert(float*, int, int)+0x14>

0000121c <Vector<float>::slice(float*, int, int)>:

template <typename T> T* Vector<T>::as_array() {
	return buffer;
}

template <typename T> void Vector<T>::slice(T* data, int start, int n) {
    121c:	b430      	push	{r4, r5}
		@return
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
    121e:	1e14      	subs	r4, r2, #0
    1220:	db03      	blt.n	122a <Vector<float>::slice(float*, int, int)+0xe>
    1222:	18e2      	adds	r2, r4, r3
    1224:	6805      	ldr	r5, [r0, #0]
    1226:	42aa      	cmp	r2, r5
    1228:	dd05      	ble.n	1236 <Vector<float>::slice(float*, int, int)+0x1a>
		memcpy(data, &buffer[start], n * sizeof(T));
	}
	else {
		memset(data, 0, n * sizeof(T));
    122a:	4608      	mov	r0, r1
    122c:	009a      	lsls	r2, r3, #2
    122e:	2100      	movs	r1, #0
	}
}
    1230:	bc30      	pop	{r4, r5}
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
	}
	else {
		memset(data, 0, n * sizeof(T));
    1232:	f005 bdb5 	b.w	6da0 <memset>
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
    1236:	6845      	ldr	r5, [r0, #4]
    1238:	009a      	lsls	r2, r3, #2
    123a:	4608      	mov	r0, r1
    123c:	eb05 0184 	add.w	r1, r5, r4, lsl #2
	}
	else {
		memset(data, 0, n * sizeof(T));
	}
}
    1240:	bc30      	pop	{r4, r5}
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
    1242:	f005 bcaf 	b.w	6ba4 <memcpy>
    1246:	bf00      	nop

00001248 <Vector<float>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
    1248:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
    124a:	6803      	ldr	r3, [r0, #0]
    124c:	428b      	cmp	r3, r1
    124e:	dd05      	ble.n	125c <Vector<float>::operator[](int)+0x14>
    1250:	2900      	cmp	r1, #0
    1252:	db03      	blt.n	125c <Vector<float>::operator[](int)+0x14>
		return buffer[index];
    1254:	6840      	ldr	r0, [r0, #4]
    1256:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
    125a:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
    125c:	2000      	movs	r0, #0
    125e:	f005 f971 	bl	6544 <exit>
    1262:	bf00      	nop

00001264 <Vector<Process*>::~Vector()>:
template <typename T> Vector<T>::Vector() {
	length = 0;
	buffer = NULL;
}

template <typename T> Vector<T>::~Vector() {
    1264:	b510      	push	{r4, lr}
    1266:	4604      	mov	r4, r0
	delete buffer;
    1268:	2104      	movs	r1, #4
    126a:	6840      	ldr	r0, [r0, #4]
    126c:	f001 fed8 	bl	3020 <operator delete(void*, unsigned int)>
}
    1270:	4620      	mov	r0, r4
    1272:	bd10      	pop	{r4, pc}

00001274 <Vector<Process*>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
    1274:	6802      	ldr	r2, [r0, #0]
    1276:	2100      	movs	r1, #0
    1278:	6840      	ldr	r0, [r0, #4]
    127a:	0092      	lsls	r2, r2, #2
    127c:	f005 bd90 	b.w	6da0 <memset>

00001280 <Vector<Process*>::Vector(int)>:
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
	buffer = new T[size];
    1280:	f1b1 5ffe 	cmp.w	r1, #532676608	; 0x1fc00000

template <typename T> Vector<T>::~Vector() {
	delete buffer;
}

template <typename T> Vector<T>::Vector(int size) {
    1284:	b510      	push	{r4, lr}
    1286:	4604      	mov	r4, r0
	/*
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
    1288:	6001      	str	r1, [r0, #0]
	buffer = new T[size];
    128a:	bf94      	ite	ls
    128c:	0088      	lslls	r0, r1, #2
    128e:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
    1292:	f001 fec3 	bl	301c <operator new[](unsigned int)>
    1296:	6060      	str	r0, [r4, #4]
	clear();
    1298:	4620      	mov	r0, r4
    129a:	f7ff ffeb 	bl	1274 <Vector<Process*>::clear()>
}
    129e:	4620      	mov	r0, r4
    12a0:	bd10      	pop	{r4, pc}
    12a2:	bf00      	nop

000012a4 <Vector<Process*>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    12a4:	b538      	push	{r3, r4, r5, lr}
    12a6:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    12a8:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    12aa:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    12ac:	b110      	cbz	r0, 12b4 <Vector<Process*>::reset(int)+0x10>
		delete buffer;
    12ae:	2104      	movs	r1, #4
    12b0:	f001 feb6 	bl	3020 <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
    12b4:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
    12b8:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
    12ba:	bf94      	ite	ls
    12bc:	00a0      	lslls	r0, r4, #2
    12be:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
    12c2:	f001 feab 	bl	301c <operator new[](unsigned int)>
    12c6:	6068      	str	r0, [r5, #4]
	clear();
    12c8:	4628      	mov	r0, r5
    12ca:	f7ff ffd3 	bl	1274 <Vector<Process*>::clear()>
    12ce:	bd38      	pop	{r3, r4, r5, pc}

000012d0 <Vector<Process*>::from_array(Process**, int)>:
}

template <typename T> void Vector<T>::from_array(T* data, int size) {
    12d0:	b570      	push	{r4, r5, r6, lr}
    12d2:	4614      	mov	r4, r2
    12d4:	460e      	mov	r6, r1
    12d6:	4605      	mov	r5, r0
		  reset the buffer to size n with data T*.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
    12d8:	4611      	mov	r1, r2
    12da:	f7ff ffe3 	bl	12a4 <Vector<Process*>::reset(int)>
	memcpy(buffer, data, size * sizeof(T));
    12de:	4631      	mov	r1, r6
    12e0:	00a2      	lsls	r2, r4, #2
    12e2:	6868      	ldr	r0, [r5, #4]
}
    12e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
	memcpy(buffer, data, size * sizeof(T));
    12e8:	f005 bc5c 	b.w	6ba4 <memcpy>

000012ec <Vector<Process*>::push(Process*)>:
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    12ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    12f0:	6805      	ldr	r5, [r0, #0]
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    12f2:	af00      	add	r7, sp, #0
    12f4:	4604      	mov	r4, r0
    12f6:	4688      	mov	r8, r1
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    12f8:	1c6e      	adds	r6, r5, #1
	memcpy(tmp, buffer, length * sizeof(T));
    12fa:	6841      	ldr	r1, [r0, #4]
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    12fc:	00b2      	lsls	r2, r6, #2
    12fe:	f102 030a 	add.w	r3, r2, #10
	memcpy(tmp, buffer, length * sizeof(T));
    1302:	3a04      	subs	r2, #4
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    1304:	f023 0307 	bic.w	r3, r3, #7
    1308:	ebad 0d03 	sub.w	sp, sp, r3
	memcpy(tmp, buffer, length * sizeof(T));
    130c:	4668      	mov	r0, sp
    130e:	f005 fc49 	bl	6ba4 <memcpy>
    1312:	4603      	mov	r3, r0
	tmp[length] = item;
	from_array(tmp, length+1);
    1314:	4601      	mov	r1, r0
    1316:	4632      	mov	r2, r6
    1318:	4620      	mov	r0, r4
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
    131a:	f843 8025 	str.w	r8, [r3, r5, lsl #2]
	from_array(tmp, length+1);
    131e:	f7ff ffd7 	bl	12d0 <Vector<Process*>::from_array(Process**, int)>
}
    1322:	46bd      	mov	sp, r7
    1324:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00001328 <Vector<Process*>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
    1328:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
    132a:	6803      	ldr	r3, [r0, #0]
    132c:	428b      	cmp	r3, r1
    132e:	dd05      	ble.n	133c <Vector<Process*>::operator[](int)+0x14>
    1330:	2900      	cmp	r1, #0
    1332:	db03      	blt.n	133c <Vector<Process*>::operator[](int)+0x14>
		return buffer[index];
    1334:	6840      	ldr	r0, [r0, #4]
    1336:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
    133a:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
    133c:	2000      	movs	r0, #0
    133e:	f005 f901 	bl	6544 <exit>
    1342:	bf00      	nop

00001344 <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    1344:	4a96      	ldr	r2, [pc, #600]	; (15a0 <set_arm_clock+0x25c>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    1346:	4b97      	ldr	r3, [pc, #604]	; (15a4 <set_arm_clock+0x260>)
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    1348:	4290      	cmp	r0, r2
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
    134a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;
    134e:	4c96      	ldr	r4, [pc, #600]	; (15a8 <set_arm_clock+0x264>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    1350:	f8d3 e014 	ldr.w	lr, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    1354:	6999      	ldr	r1, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    1356:	68e6      	ldr	r6, [r4, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    1358:	d91c      	bls.n	1394 <set_arm_clock+0x50>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    135a:	4b94      	ldr	r3, [pc, #592]	; (15ac <set_arm_clock+0x268>)
    135c:	4298      	cmp	r0, r3
    135e:	f240 8115 	bls.w	158c <set_arm_clock+0x248>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    1362:	4b93      	ldr	r3, [pc, #588]	; (15b0 <set_arm_clock+0x26c>)
    1364:	f240 6527 	movw	r5, #1575	; 0x627
    1368:	4f92      	ldr	r7, [pc, #584]	; (15b4 <set_arm_clock+0x270>)
    136a:	4403      	add	r3, r0
    136c:	4c92      	ldr	r4, [pc, #584]	; (15b8 <set_arm_clock+0x274>)
    136e:	0a1a      	lsrs	r2, r3, #8
    1370:	fba7 3202 	umull	r3, r2, r7, r2
    1374:	09d3      	lsrs	r3, r2, #7
    1376:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    137a:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    137e:	f202 43e2 	addw	r3, r2, #1250	; 0x4e2
    1382:	42ab      	cmp	r3, r5
    1384:	bf28      	it	cs
    1386:	462b      	movcs	r3, r5
    1388:	f5a3 7348 	sub.w	r3, r3, #800	; 0x320
    138c:	fba4 3503 	umull	r3, r5, r4, r3
    1390:	08ed      	lsrs	r5, r5, #3
    1392:	e004      	b.n	139e <set_arm_clock+0x5a>
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
		}
#endif
	} else if (frequency <= 24000000) {
    1394:	4d89      	ldr	r5, [pc, #548]	; (15bc <set_arm_clock+0x278>)
    1396:	42a8      	cmp	r0, r5
    1398:	bf94      	ite	ls
    139a:	2506      	movls	r5, #6
    139c:	250e      	movhi	r5, #14
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    139e:	4a81      	ldr	r2, [pc, #516]	; (15a4 <set_arm_clock+0x260>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    13a0:	f006 071f 	and.w	r7, r6, #31
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    13a4:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    13a8:	42af      	cmp	r7, r5
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    13aa:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    13ae:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    13b2:	d20a      	bcs.n	13ca <set_arm_clock+0x86>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    13b4:	4b7c      	ldr	r3, [pc, #496]	; (15a8 <set_arm_clock+0x264>)

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    13b6:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    13ba:	461a      	mov	r2, r3
	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    13bc:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
    13be:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    13c0:	6813      	ldr	r3, [r2, #0]
    13c2:	2b00      	cmp	r3, #0
    13c4:	dafc      	bge.n	13c0 <set_arm_clock+0x7c>
    13c6:	f006 071f 	and.w	r7, r6, #31
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    13ca:	f01e 7300 	ands.w	r3, lr, #33554432	; 0x2000000
    13ce:	d131      	bne.n	1434 <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    13d0:	4c7b      	ldr	r4, [pc, #492]	; (15c0 <set_arm_clock+0x27c>)
    13d2:	4a7c      	ldr	r2, [pc, #496]	; (15c4 <set_arm_clock+0x280>)
    13d4:	f8d4 c010 	ldr.w	ip, [r4, #16]
    13d8:	4614      	mov	r4, r2
    13da:	ea0c 0202 	and.w	r2, ip, r2
    13de:	42a2      	cmp	r2, r4
    13e0:	bf0a      	itet	eq
    13e2:	f04f 53c0 	moveq.w	r3, #402653184	; 0x18000000
    13e6:	f44f 5280 	movne.w	r2, #4096	; 0x1000
    13ea:	2200      	moveq	r2, #0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    13ec:	ea8e 0403 	eor.w	r4, lr, r3
    13f0:	f014 5f60 	tst.w	r4, #939524096	; 0x38000000
    13f4:	d008      	beq.n	1408 <set_arm_clock+0xc4>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    13f6:	f02e 5e60 	bic.w	lr, lr, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    13fa:	f003 5360 	and.w	r3, r3, #939524096	; 0x38000000
			CCM_CBCDR = cbcdr;
    13fe:	4c69      	ldr	r4, [pc, #420]	; (15a4 <set_arm_clock+0x260>)
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    1400:	ea43 0e0e 	orr.w	lr, r3, lr
			CCM_CBCDR = cbcdr;
    1404:	f8c4 e014 	str.w	lr, [r4, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    1408:	ea81 0302 	eor.w	r3, r1, r2
    140c:	f413 5f40 	tst.w	r3, #12288	; 0x3000
    1410:	d008      	beq.n	1424 <set_arm_clock+0xe0>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    1412:	4b64      	ldr	r3, [pc, #400]	; (15a4 <set_arm_clock+0x260>)
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
			CCM_CBCDR = cbcdr;
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    1414:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    1418:	4311      	orrs	r1, r2
			CCM_CBCMR = cbcmr;
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    141a:	461a      	mov	r2, r3
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    141c:	6199      	str	r1, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    141e:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1420:	071c      	lsls	r4, r3, #28
    1422:	d4fc      	bmi.n	141e <set_arm_clock+0xda>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    1424:	f04e 7e00 	orr.w	lr, lr, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    1428:	4a5e      	ldr	r2, [pc, #376]	; (15a4 <set_arm_clock+0x260>)
    142a:	f8c2 e014 	str.w	lr, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    142e:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1430:	0699      	lsls	r1, r3, #26
    1432:	d4fc      	bmi.n	142e <set_arm_clock+0xea>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
    1434:	2101      	movs	r1, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    1436:	4c64      	ldr	r4, [pc, #400]	; (15c8 <set_arm_clock+0x284>)
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
    1438:	460a      	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    143a:	fb01 f302 	mul.w	r3, r1, r2
    143e:	fb00 f303 	mul.w	r3, r0, r3
    1442:	42a3      	cmp	r3, r4
    1444:	d809      	bhi.n	145a <set_arm_clock+0x116>
		if (div_arm < 8) {
    1446:	2a07      	cmp	r2, #7
    1448:	f200 8095 	bhi.w	1576 <set_arm_clock+0x232>
			div_arm = div_arm + 1;
    144c:	3201      	adds	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    144e:	fb01 f302 	mul.w	r3, r1, r2
    1452:	fb00 f303 	mul.w	r3, r0, r3
    1456:	42a3      	cmp	r3, r4
    1458:	d9f5      	bls.n	1446 <set_arm_clock+0x102>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    145a:	485c      	ldr	r0, [pc, #368]	; (15cc <set_arm_clock+0x288>)
    145c:	4c5c      	ldr	r4, [pc, #368]	; (15d0 <set_arm_clock+0x28c>)
    145e:	4418      	add	r0, r3
    1460:	fba4 0300 	umull	r0, r3, r4, r0
    1464:	0d1b      	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
    1466:	2b6c      	cmp	r3, #108	; 0x6c
    1468:	f200 808b 	bhi.w	1582 <set_arm_clock+0x23e>
	if (mult < 54) mult = 54;
    146c:	2b35      	cmp	r3, #53	; 0x35
    146e:	f200 808f 	bhi.w	1590 <set_arm_clock+0x24c>
    1472:	f8df 8188 	ldr.w	r8, [pc, #392]	; 15fc <set_arm_clock+0x2b8>
    1476:	2336      	movs	r3, #54	; 0x36
    1478:	4856      	ldr	r0, [pc, #344]	; (15d4 <set_arm_clock+0x290>)

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    147a:	f8df c144 	ldr.w	ip, [pc, #324]	; 15c0 <set_arm_clock+0x27c>
    147e:	4c56      	ldr	r4, [pc, #344]	; (15d8 <set_arm_clock+0x294>)
    1480:	f8dc 9000 	ldr.w	r9, [ip]
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    1484:	fbb0 f0f2 	udiv	r0, r0, r2

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    1488:	ea09 0404 	and.w	r4, r9, r4
    148c:	4544      	cmp	r4, r8
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    148e:	fbb0 f0f1 	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    1492:	d00b      	beq.n	14ac <set_arm_clock+0x168>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    1494:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    1498:	f44f 5880 	mov.w	r8, #4096	; 0x1000
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    149c:	4664      	mov	r4, ip
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    149e:	f8cc 8000 	str.w	r8, [ip]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    14a2:	f8cc 3000 	str.w	r3, [ip]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    14a6:	6823      	ldr	r3, [r4, #0]
    14a8:	2b00      	cmp	r3, #0
    14aa:	dafc      	bge.n	14a6 <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    14ac:	f8df c0f4 	ldr.w	ip, [pc, #244]	; 15a4 <set_arm_clock+0x260>
    14b0:	3a01      	subs	r2, #1
    14b2:	f8dc 3010 	ldr.w	r3, [ip, #16]
    14b6:	f003 0307 	and.w	r3, r3, #7
    14ba:	4293      	cmp	r3, r2
    14bc:	d007      	beq.n	14ce <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    14be:	f002 0207 	and.w	r2, r2, #7
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    14c2:	4664      	mov	r4, ip
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    14c4:	f8cc 2010 	str.w	r2, [ip, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    14c8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    14ca:	03db      	lsls	r3, r3, #15
    14cc:	d4fc      	bmi.n	14c8 <set_arm_clock+0x184>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    14ce:	3901      	subs	r1, #1
    14d0:	0289      	lsls	r1, r1, #10
    14d2:	ea8e 0301 	eor.w	r3, lr, r1
    14d6:	f413 5fe0 	tst.w	r3, #7168	; 0x1c00
    14da:	d00c      	beq.n	14f6 <set_arm_clock+0x1b2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
		CCM_CBCDR = cbcdr;
    14dc:	4b31      	ldr	r3, [pc, #196]	; (15a4 <set_arm_clock+0x260>)
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    14de:	f42e 5ee0 	bic.w	lr, lr, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    14e2:	f401 51e0 	and.w	r1, r1, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    14e6:	461a      	mov	r2, r3
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    14e8:	ea41 0e0e 	orr.w	lr, r1, lr
		CCM_CBCDR = cbcdr;
    14ec:	f8c3 e014 	str.w	lr, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    14f0:	6c93      	ldr	r3, [r2, #72]	; 0x48
    14f2:	0799      	lsls	r1, r3, #30
    14f4:	d4fc      	bmi.n	14f0 <set_arm_clock+0x1ac>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    14f6:	4b39      	ldr	r3, [pc, #228]	; (15dc <set_arm_clock+0x298>)
    14f8:	4939      	ldr	r1, [pc, #228]	; (15e0 <set_arm_clock+0x29c>)
    14fa:	4403      	add	r3, r0
    14fc:	09db      	lsrs	r3, r3, #7
    14fe:	fba1 3103 	umull	r3, r1, r1, r3
    1502:	0b09      	lsrs	r1, r1, #12
    1504:	2904      	cmp	r1, #4
    1506:	bf28      	it	cs
    1508:	2104      	movcs	r1, #4
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    150a:	1e4b      	subs	r3, r1, #1
    150c:	021b      	lsls	r3, r3, #8
    150e:	ea8e 0203 	eor.w	r2, lr, r3
    1512:	f412 7f40 	tst.w	r2, #768	; 0x300
    1516:	d007      	beq.n	1528 <set_arm_clock+0x1e4>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    1518:	f42e 7e40 	bic.w	lr, lr, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    151c:	f403 7340 	and.w	r3, r3, #768	; 0x300
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    1520:	4a20      	ldr	r2, [pc, #128]	; (15a4 <set_arm_clock+0x260>)

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    1522:	ea43 030e 	orr.w	r3, r3, lr
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    1526:	6153      	str	r3, [r2, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    1528:	4b1e      	ldr	r3, [pc, #120]	; (15a4 <set_arm_clock+0x260>)
    152a:	695c      	ldr	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    152c:	461a      	mov	r2, r3
		CCM_CBCDR = cbcdr;
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    152e:	f024 7400 	bic.w	r4, r4, #33554432	; 0x2000000
    1532:	615c      	str	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    1534:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1536:	069b      	lsls	r3, r3, #26
    1538:	d4fc      	bmi.n	1534 <set_arm_clock+0x1f0>

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    153a:	4b2a      	ldr	r3, [pc, #168]	; (15e4 <set_arm_clock+0x2a0>)
    153c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    1540:	4c29      	ldr	r4, [pc, #164]	; (15e8 <set_arm_clock+0x2a4>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    1542:	42bd      	cmp	r5, r7
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    1544:	fba3 e300 	umull	lr, r3, r3, r0
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    1548:	6020      	str	r0, [r4, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    154a:	ea4f 4393 	mov.w	r3, r3, lsr #18
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    154e:	4c27      	ldr	r4, [pc, #156]	; (15ec <set_arm_clock+0x2a8>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    1550:	fbb2 f3f3 	udiv	r3, r2, r3
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    1554:	fbb0 f1f1 	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    1558:	4a25      	ldr	r2, [pc, #148]	; (15f0 <set_arm_clock+0x2ac>)
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    155a:	6021      	str	r1, [r4, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    155c:	6013      	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    155e:	d208      	bcs.n	1572 <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    1560:	4b11      	ldr	r3, [pc, #68]	; (15a8 <set_arm_clock+0x264>)
	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    1562:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    1566:	461a      	mov	r2, r3

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    1568:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
    156a:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    156c:	6813      	ldr	r3, [r2, #0]
    156e:	2b00      	cmp	r3, #0
    1570:	dafc      	bge.n	156c <set_arm_clock+0x228>
	}

	return frequency;
}
    1572:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
		if (div_arm < 8) {
			div_arm = div_arm + 1;
		} else {
			if (div_ahb < 5) {
    1576:	2904      	cmp	r1, #4
    1578:	f63f af6f 	bhi.w	145a <set_arm_clock+0x116>
				div_ahb = div_ahb + 1;
    157c:	3101      	adds	r1, #1
				div_arm = 1;
    157e:	2201      	movs	r2, #1
    1580:	e75b      	b.n	143a <set_arm_clock+0xf6>
    1582:	f8df 807c 	ldr.w	r8, [pc, #124]	; 1600 <set_arm_clock+0x2bc>
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
    1586:	236c      	movs	r3, #108	; 0x6c
    1588:	481a      	ldr	r0, [pc, #104]	; (15f4 <set_arm_clock+0x2b0>)
    158a:	e776      	b.n	147a <set_arm_clock+0x136>
    158c:	2512      	movs	r5, #18
    158e:	e706      	b.n	139e <set_arm_clock+0x5a>
    1590:	4819      	ldr	r0, [pc, #100]	; (15f8 <set_arm_clock+0x2b4>)
    1592:	f8df 8070 	ldr.w	r8, [pc, #112]	; 1604 <set_arm_clock+0x2c0>
    1596:	fb00 f003 	mul.w	r0, r0, r3
    159a:	ea43 0808 	orr.w	r8, r3, r8
    159e:	e76c      	b.n	147a <set_arm_clock+0x136>
    15a0:	1f78a400 	.word	0x1f78a400
    15a4:	400fc000 	.word	0x400fc000
    15a8:	40080000 	.word	0x40080000
    15ac:	23c34600 	.word	0x23c34600
    15b0:	dc3cba00 	.word	0xdc3cba00
    15b4:	004cb223 	.word	0x004cb223
    15b8:	51eb851f 	.word	0x51eb851f
    15bc:	016e3600 	.word	0x016e3600
    15c0:	400d8000 	.word	0x400d8000
    15c4:	80003040 	.word	0x80003040
    15c8:	269fb1ff 	.word	0x269fb1ff
    15cc:	005b8d80 	.word	0x005b8d80
    15d0:	165e9f81 	.word	0x165e9f81
    15d4:	269fb200 	.word	0x269fb200
    15d8:	8001307f 	.word	0x8001307f
    15dc:	08f0d17f 	.word	0x08f0d17f
    15e0:	00e5109f 	.word	0x00e5109f
    15e4:	431bde83 	.word	0x431bde83
    15e8:	20001590 	.word	0x20001590
    15ec:	2000158c 	.word	0x2000158c
    15f0:	20002738 	.word	0x20002738
    15f4:	4d3f6400 	.word	0x4d3f6400
    15f8:	00b71b00 	.word	0x00b71b00
    15fc:	80002036 	.word	0x80002036
    1600:	8000206c 	.word	0x8000206c
    1604:	80002000 	.word	0x80002000

00001608 <delay>:
// or delayNanoseconds().
void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
    1608:	2800      	cmp	r0, #0
    160a:	d057      	beq.n	16bc <delay+0xb4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    160c:	2201      	movs	r2, #1
// active, but the rest of your program becomes effectively stalled.  Usually
// delay() is used in very simple programs.  To achieve delay without waiting
// use millis() or elapsedMillis.  For shorter delay, use delayMicroseconds()
// or delayNanoseconds().
void delay(uint32_t msec)
{
    160e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1612:	b085      	sub	sp, #20
    1614:	4683      	mov	fp, r0
    1616:	4c2a      	ldr	r4, [pc, #168]	; (16c0 <delay+0xb8>)
    1618:	4d2a      	ldr	r5, [pc, #168]	; (16c4 <delay+0xbc>)
    161a:	4e2b      	ldr	r6, [pc, #172]	; (16c8 <delay+0xc0>)
    161c:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    1620:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    1624:	6828      	ldr	r0, [r5, #0]
		scc = systick_cycle_count;
    1626:	6833      	ldr	r3, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    1628:	e844 2100 	strex	r1, r2, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    162c:	2900      	cmp	r1, #0
    162e:	d1f7      	bne.n	1620 <delay+0x18>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    1630:	4f26      	ldr	r7, [pc, #152]	; (16cc <delay+0xc4>)
    1632:	e9cd 8902 	strd	r8, r9, [sp, #8]
    1636:	683a      	ldr	r2, [r7, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    1638:	1ad3      	subs	r3, r2, r3
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    163a:	4a25      	ldr	r2, [pc, #148]	; (16d0 <delay+0xc8>)
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    163c:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    1640:	9701      	str	r7, [sp, #4]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1642:	6812      	ldr	r2, [r2, #0]
    1644:	2701      	movs	r7, #1
    1646:	fba3 2302 	umull	r2, r3, r3, r2
	if (frac > 1000) frac = 1000;
    164a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    164e:	4698      	mov	r8, r3
	if (frac > 1000) frac = 1000;
    1650:	2300      	movs	r3, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1652:	428b      	cmp	r3, r1
    1654:	bf08      	it	eq
    1656:	4542      	cmpeq	r2, r8
    1658:	bf2c      	ite	cs
    165a:	46c2      	movcs	sl, r8
    165c:	46f2      	movcc	sl, lr
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    165e:	fb0e aa00 	mla	sl, lr, r0, sl
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    1662:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    1666:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    1668:	6831      	ldr	r1, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    166a:	e844 7300 	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    166e:	2b00      	cmp	r3, #0
    1670:	d1f7      	bne.n	1662 <delay+0x5a>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    1672:	9801      	ldr	r0, [sp, #4]
    1674:	6800      	ldr	r0, [r0, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    1676:	1a41      	subs	r1, r0, r1
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1678:	4815      	ldr	r0, [pc, #84]	; (16d0 <delay+0xc8>)
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    167a:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    167e:	6800      	ldr	r0, [r0, #0]
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    1680:	fb0e f202 	mul.w	r2, lr, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1684:	fba1 0100 	umull	r0, r1, r1, r0
	if (frac > 1000) frac = 1000;
    1688:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    168c:	ebca 0202 	rsb	r2, sl, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1690:	4688      	mov	r8, r1
	if (frac > 1000) frac = 1000;
    1692:	2100      	movs	r1, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1694:	4299      	cmp	r1, r3
    1696:	bf08      	it	eq
    1698:	4540      	cmpeq	r0, r8
    169a:	bf2c      	ite	cs
    169c:	4643      	movcs	r3, r8
    169e:	4673      	movcc	r3, lr
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    16a0:	441a      	add	r2, r3
    16a2:	4572      	cmp	r2, lr
    16a4:	d307      	bcc.n	16b6 <delay+0xae>
			if (--msec == 0) return;
    16a6:	f1bb 0b01 	subs.w	fp, fp, #1
			start += 1000;
    16aa:	f50a 7a7a 	add.w	sl, sl, #1000	; 0x3e8

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
    16ae:	d1d8      	bne.n	1662 <delay+0x5a>
			start += 1000;
		}
		yield();
	}
	// TODO...
}
    16b0:	b005      	add	sp, #20
    16b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
    16b6:	f001 fcc9 	bl	304c <yield>
	}
    16ba:	e7d2      	b.n	1662 <delay+0x5a>
    16bc:	4770      	bx	lr
    16be:	bf00      	nop
    16c0:	200027a0 	.word	0x200027a0
    16c4:	20002740 	.word	0x20002740
    16c8:	2000273c 	.word	0x2000273c
    16cc:	e0001004 	.word	0xe0001004
    16d0:	20002738 	.word	0x20002738

000016d4 <digitalWrite.part.0>:
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    16d4:	0100      	lsls	r0, r0, #4
    16d6:	4b0f      	ldr	r3, [pc, #60]	; (1714 <digitalWrite.part.0+0x40>)
    16d8:	181a      	adds	r2, r3, r0
	pinmode = *(p->reg + 1);
    16da:	581b      	ldr	r3, [r3, r0]
	{&CORE_PIN53_PORTREG, &CORE_PIN53_CONFIG, &CORE_PIN53_PADCONFIG, CORE_PIN53_BITMASK},
	{&CORE_PIN54_PORTREG, &CORE_PIN54_CONFIG, &CORE_PIN54_PADCONFIG, CORE_PIN54_BITMASK},
#endif
};

void digitalWrite(uint8_t pin, uint8_t val)
    16dc:	b410      	push	{r4}
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
	mask = p->mask;
    16de:	68d0      	ldr	r0, [r2, #12]
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
    16e0:	685c      	ldr	r4, [r3, #4]
	mask = p->mask;
	if (pinmode & mask) {
    16e2:	4204      	tst	r4, r0
    16e4:	d005      	beq.n	16f2 <digitalWrite.part.0+0x1e>
		// pin is configured for output mode
		if (val) {
    16e6:	b159      	cbz	r1, 1700 <digitalWrite.part.0+0x2c>
			*(p->reg + 0x21) = mask; // set register
    16e8:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    16ec:	f85d 4b04 	ldr.w	r4, [sp], #4
    16f0:	4770      	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    16f2:	6893      	ldr	r3, [r2, #8]
			*(p->reg + 0x22) = mask; // clear register
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
    16f4:	b949      	cbnz	r1, 170a <digitalWrite.part.0+0x36>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    16f6:	4a08      	ldr	r2, [pc, #32]	; (1718 <digitalWrite.part.0+0x44>)
		}
	}
}
    16f8:	f85d 4b04 	ldr.w	r4, [sp], #4
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    16fc:	601a      	str	r2, [r3, #0]
		}
	}
}
    16fe:	4770      	bx	lr
	if (pinmode & mask) {
		// pin is configured for output mode
		if (val) {
			*(p->reg + 0x21) = mask; // set register
		} else {
			*(p->reg + 0x22) = mask; // clear register
    1700:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    1704:	f85d 4b04 	ldr.w	r4, [sp], #4
    1708:	4770      	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    170a:	4a04      	ldr	r2, [pc, #16]	; (171c <digitalWrite.part.0+0x48>)
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    170c:	f85d 4b04 	ldr.w	r4, [sp], #4
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    1710:	601a      	str	r2, [r3, #0]
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    1712:	4770      	bx	lr
    1714:	200006dc 	.word	0x200006dc
    1718:	00013038 	.word	0x00013038
    171c:	0001f038 	.word	0x0001f038

00001720 <digitalRead.part.1>:
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    1720:	0100      	lsls	r0, r0, #4
    1722:	4b05      	ldr	r3, [pc, #20]	; (1738 <digitalRead.part.1+0x18>)
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    1724:	581a      	ldr	r2, [r3, r0]
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    1726:	1819      	adds	r1, r3, r0
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    1728:	6892      	ldr	r2, [r2, #8]
    172a:	68cb      	ldr	r3, [r1, #12]
    172c:	421a      	tst	r2, r3
}
    172e:	bf14      	ite	ne
    1730:	2001      	movne	r0, #1
    1732:	2000      	moveq	r0, #0
    1734:	4770      	bx	lr
    1736:	bf00      	nop
    1738:	200006dc 	.word	0x200006dc

0000173c <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    173c:	2836      	cmp	r0, #54	; 0x36
    173e:	d801      	bhi.n	1744 <digitalWrite+0x8>
    1740:	f7ff bfc8 	b.w	16d4 <digitalWrite.part.0>
    1744:	4770      	bx	lr
    1746:	bf00      	nop

00001748 <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    1748:	2836      	cmp	r0, #54	; 0x36
    174a:	d801      	bhi.n	1750 <digitalRead+0x8>
    174c:	f7ff bfe8 	b.w	1720 <digitalRead.part.1>
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}
    1750:	2000      	movs	r0, #0
    1752:	4770      	bx	lr

00001754 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    1754:	b4f0      	push	{r4, r5, r6, r7}
    1756:	1e4e      	subs	r6, r1, #1
	unsigned digit;
	int i=0, j;
    1758:	2500      	movs	r5, #0
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    175a:	4637      	mov	r7, r6
    175c:	e000      	b.n	1760 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    175e:	3501      	adds	r5, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    1760:	fbb0 f3f2 	udiv	r3, r0, r2
    1764:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    1768:	f100 0437 	add.w	r4, r0, #55	; 0x37
    176c:	2809      	cmp	r0, #9
    176e:	f100 0030 	add.w	r0, r0, #48	; 0x30
    1772:	b2e4      	uxtb	r4, r4
    1774:	bf98      	it	ls
    1776:	b2c4      	uxtbls	r4, r0
		val /= radix;
		if (val == 0) break;
    1778:	4618      	mov	r0, r3
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    177a:	f807 4f01 	strb.w	r4, [r7, #1]!
		val /= radix;
		if (val == 0) break;
    177e:	2b00      	cmp	r3, #0
    1780:	d1ed      	bne.n	175e <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    1782:	194a      	adds	r2, r1, r5
    1784:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    1786:	b14d      	cbz	r5, 179c <ultoa+0x48>
    1788:	3301      	adds	r3, #1
		t = buf[j];
    178a:	f816 4f01 	ldrb.w	r4, [r6, #1]!
		buf[j] = buf[i];
    178e:	7817      	ldrb	r7, [r2, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    1790:	1ae8      	subs	r0, r5, r3
		t = buf[j];
		buf[j] = buf[i];
    1792:	7037      	strb	r7, [r6, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    1794:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    1796:	f802 4901 	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    179a:	dbf5      	blt.n	1788 <ultoa+0x34>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    179c:	4608      	mov	r0, r1
    179e:	bcf0      	pop	{r4, r5, r6, r7}
    17a0:	4770      	bx	lr
    17a2:	bf00      	nop

000017a4 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    17a4:	48a4      	ldr	r0, [pc, #656]	; (1a38 <pwm_init+0x294>)
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    17a6:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    17aa:	4ba4      	ldr	r3, [pc, #656]	; (1a3c <pwm_init+0x298>)
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    17ac:	6f82      	ldr	r2, [r0, #120]	; 0x78
    17ae:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}

void pwm_init(void)
{
    17b2:	b5f0      	push	{r4, r5, r6, r7, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    17b4:	6782      	str	r2, [r0, #120]	; 0x78
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    17b6:	2500      	movs	r5, #0
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    17b8:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    17bc:	f44f 4670 	mov.w	r6, #61440	; 0xf000
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    17c0:	4c9f      	ldr	r4, [pc, #636]	; (1a40 <pwm_init+0x29c>)
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    17c2:	f44f 4e60 	mov.w	lr, #57344	; 0xe000

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    17c6:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    17c8:	f44f 6780 	mov.w	r7, #1024	; 0x400
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    17cc:	4314      	orrs	r4, r2
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    17ce:	462a      	mov	r2, r5
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    17d0:	f8c0 4080 	str.w	r4, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    17d4:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    17d8:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    17dc:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    17e0:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    17e4:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    17e8:	b280      	uxth	r0, r0
    17ea:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    17ee:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    17f2:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    17f6:	4b91      	ldr	r3, [pc, #580]	; (1a3c <pwm_init+0x298>)
	for (i=0; i < 4; i++) {
    17f8:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    17fa:	2500      	movs	r5, #0
    17fc:	0140      	lsls	r0, r0, #5
    17fe:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1800:	2904      	cmp	r1, #4
    1802:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1804:	f8a3 e004 	strh.w	lr, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1808:	80df      	strh	r7, [r3, #6]
		p->SM[i].OCTRL = 0;
    180a:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    180c:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    180e:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    1810:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    1812:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    1814:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    1816:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1818:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    181a:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    181c:	d1e9      	bne.n	17f2 <pwm_init+0x4e>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    181e:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1822:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1826:	4b87      	ldr	r3, [pc, #540]	; (1a44 <pwm_init+0x2a0>)
    1828:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    182c:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    182e:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1830:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1834:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1836:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    183a:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    183e:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    1842:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    1846:	b280      	uxth	r0, r0
    1848:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    184c:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1850:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    1854:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1858:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    185c:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1860:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    1864:	b280      	uxth	r0, r0
    1866:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    186a:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    186e:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    1872:	4b74      	ldr	r3, [pc, #464]	; (1a44 <pwm_init+0x2a0>)
	for (i=0; i < 4; i++) {
    1874:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1876:	2500      	movs	r5, #0
    1878:	0140      	lsls	r0, r0, #5
    187a:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    187c:	2904      	cmp	r1, #4
    187e:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1880:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1882:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    1886:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1888:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    188a:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    188c:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    188e:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    1890:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    1892:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1894:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    1896:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1898:	d1e9      	bne.n	186e <pwm_init+0xca>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    189a:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    189e:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    18a2:	4b69      	ldr	r3, [pc, #420]	; (1a48 <pwm_init+0x2a4>)
    18a4:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    18a8:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    18aa:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    18ac:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    18b0:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    18b2:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    18b6:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    18ba:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    18be:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    18c2:	b280      	uxth	r0, r0
    18c4:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    18c8:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    18cc:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    18d0:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    18d4:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    18d8:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    18dc:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    18e0:	b280      	uxth	r0, r0
    18e2:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    18e6:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    18ea:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    18ee:	4b56      	ldr	r3, [pc, #344]	; (1a48 <pwm_init+0x2a4>)
	for (i=0; i < 4; i++) {
    18f0:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    18f2:	2500      	movs	r5, #0
    18f4:	0140      	lsls	r0, r0, #5
    18f6:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    18f8:	2904      	cmp	r1, #4
    18fa:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    18fc:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    18fe:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    1902:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1904:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    1906:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    1908:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    190a:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    190c:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    190e:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1910:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    1912:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1914:	d1e9      	bne.n	18ea <pwm_init+0x146>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1916:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    191a:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    191e:	4b4b      	ldr	r3, [pc, #300]	; (1a4c <pwm_init+0x2a8>)
    1920:	f44f 4770 	mov.w	r7, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1924:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1926:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1928:	f44f 4660 	mov.w	r6, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    192c:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    192e:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1932:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1936:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    193a:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    193e:	b280      	uxth	r0, r0
    1940:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    1944:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1948:	f8a3 718c 	strh.w	r7, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    194c:	f248 27b8 	movw	r7, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1950:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    1954:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1958:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    195c:	b280      	uxth	r0, r0
    195e:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1962:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    1966:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    196a:	4b38      	ldr	r3, [pc, #224]	; (1a4c <pwm_init+0x2a8>)
	for (i=0; i < 4; i++) {
    196c:	3101      	adds	r1, #1
    196e:	0140      	lsls	r0, r0, #5
    1970:	461c      	mov	r4, r3
    1972:	2904      	cmp	r1, #4
    1974:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1976:	809e      	strh	r6, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1978:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    197c:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    197e:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    1980:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    1982:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    1984:	81df      	strh	r7, [r3, #14]
		p->SM[i].VAL2 = 0;
    1986:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    1988:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    198a:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    198c:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    198e:	d1ea      	bne.n	1966 <pwm_init+0x1c2>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1990:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1994:	270f      	movs	r7, #15

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1996:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1998:	f241 0601 	movw	r6, #4097	; 0x1001
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    199c:	b29b      	uxth	r3, r3
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    199e:	f645 5ec0 	movw	lr, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    19a2:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    19a4:	f243 0526 	movw	r5, #12326	; 0x3026
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    19a8:	433b      	orrs	r3, r7
    19aa:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    19ae:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
    19b2:	b29b      	uxth	r3, r3
    19b4:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
    19b8:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    19bc:	0150      	lsls	r0, r2, #5
    19be:	4b24      	ldr	r3, [pc, #144]	; (1a50 <pwm_init+0x2ac>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    19c0:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    19c2:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    19c4:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    19c6:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    19c8:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    19ca:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    19cc:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    19ce:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    19d2:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    19d4:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    19d6:	819d      	strh	r5, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    19d8:	d1f0      	bne.n	19bc <pwm_init+0x218>
    19da:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    19dc:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    19de:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    19e2:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    19e6:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    19e8:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    19ec:	0150      	lsls	r0, r2, #5
    19ee:	4b19      	ldr	r3, [pc, #100]	; (1a54 <pwm_init+0x2b0>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    19f0:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    19f2:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    19f4:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    19f6:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    19f8:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    19fa:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    19fc:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    19fe:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    1a00:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    1a02:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1a04:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1a06:	d1f1      	bne.n	19ec <pwm_init+0x248>
    1a08:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1a0a:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1a0c:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1a10:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1a14:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1a16:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1a1a:	0150      	lsls	r0, r2, #5
    1a1c:	4b0e      	ldr	r3, [pc, #56]	; (1a58 <pwm_init+0x2b4>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1a1e:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    1a20:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1a22:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    1a24:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    1a26:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1a28:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1a2a:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1a2c:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    1a2e:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    1a30:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1a32:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1a34:	d1f1      	bne.n	1a1a <pwm_init+0x276>
	flexpwm_init(&IMXRT_FLEXPWM3);
	flexpwm_init(&IMXRT_FLEXPWM4);
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    1a36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a38:	400fc000 	.word	0x400fc000
    1a3c:	403dc000 	.word	0x403dc000
    1a40:	fc030000 	.word	0xfc030000
    1a44:	403e0000 	.word	0x403e0000
    1a48:	403e4000 	.word	0x403e4000
    1a4c:	403e8000 	.word	0x403e8000
    1a50:	401dc000 	.word	0x401dc000
    1a54:	401e0000 	.word	0x401e0000
    1a58:	401e4000 	.word	0x401e4000

00001a5c <rtc_get>:
#include "debug/printf.h"


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
    1a5c:	4b0a      	ldr	r3, [pc, #40]	; (1a88 <rtc_get+0x2c>)
#include "imxrt.h"
#include "debug/printf.h"


unsigned long rtc_get(void)
{
    1a5e:	b430      	push	{r4, r5}
	uint32_t hi1 = SNVS_HPRTCMR;
    1a60:	6a58      	ldr	r0, [r3, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    1a62:	461c      	mov	r4, r3


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
    1a64:	6a99      	ldr	r1, [r3, #40]	; 0x28
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    1a66:	6a62      	ldr	r2, [r4, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
    1a68:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
    1a6a:	4299      	cmp	r1, r3
    1a6c:	bf08      	it	eq
    1a6e:	4290      	cmpeq	r0, r2
unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    1a70:	4610      	mov	r0, r2
		uint32_t lo2 = SNVS_HPRTCLR;
    1a72:	4619      	mov	r1, r3
		if (lo1 == lo2 && hi1 == hi2) {
    1a74:	bf0c      	ite	eq
    1a76:	2501      	moveq	r5, #1
    1a78:	2500      	movne	r5, #0
    1a7a:	2d00      	cmp	r5, #0
    1a7c:	d0f3      	beq.n	1a66 <rtc_get+0xa>
			return (hi2 << 17) | (lo2 >> 15);
    1a7e:	0bd9      	lsrs	r1, r3, #15
		}
		hi1 = hi2;
		lo1 = lo2;
	}
}
    1a80:	bc30      	pop	{r4, r5}
    1a82:	ea41 4042 	orr.w	r0, r1, r2, lsl #17
    1a86:	4770      	bx	lr
    1a88:	400d4000 	.word	0x400d4000

00001a8c <sm_align_pool>:
	if (spool->pool_size % HEADER_SZ) return 0;
	return 1;
}

int sm_align_pool(struct smalloc_pool *spool)
{
    1a8c:	b508      	push	{r3, lr}

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    1a8e:	6803      	ldr	r3, [r0, #0]
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    1a90:	6842      	ldr	r2, [r0, #4]

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    1a92:	b1bb      	cbz	r3, 1ac4 <sm_align_pool+0x38>
    1a94:	b17a      	cbz	r2, 1ab6 <sm_align_pool+0x2a>
	if (spool->pool_size % HEADER_SZ) return 0;
    1a96:	4b10      	ldr	r3, [pc, #64]	; (1ad8 <sm_align_pool+0x4c>)
    1a98:	fba3 1302 	umull	r1, r3, r3, r2
    1a9c:	08db      	lsrs	r3, r3, #3
    1a9e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    1aa2:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
    1aa6:	d003      	beq.n	1ab0 <sm_align_pool+0x24>
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
    1aa8:	1ad2      	subs	r2, r2, r3
    1aaa:	6042      	str	r2, [r0, #4]
	if (spool->pool_size <= MIN_POOL_SZ) {
    1aac:	2af0      	cmp	r2, #240	; 0xf0
    1aae:	d902      	bls.n	1ab6 <sm_align_pool+0x2a>

int sm_align_pool(struct smalloc_pool *spool)
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;
    1ab0:	2301      	movs	r3, #1
		errno = ENOSPC;
		return 0;
	}

	return 1;
}
    1ab2:	4618      	mov	r0, r3
    1ab4:	bd08      	pop	{r3, pc}
	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
	if (spool->pool_size <= MIN_POOL_SZ) {
		errno = ENOSPC;
    1ab6:	f004 fd3f 	bl	6538 <__errno>
    1aba:	221c      	movs	r2, #28
    1abc:	2300      	movs	r3, #0
    1abe:	6002      	str	r2, [r0, #0]
		return 0;
	}

	return 1;
}
    1ac0:	4618      	mov	r0, r3
    1ac2:	bd08      	pop	{r3, pc}
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    1ac4:	4b04      	ldr	r3, [pc, #16]	; (1ad8 <sm_align_pool+0x4c>)
    1ac6:	fba3 1302 	umull	r1, r3, r3, r2
    1aca:	08db      	lsrs	r3, r3, #3
    1acc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (x) spool->pool_size -= x;
    1ad0:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
    1ad4:	d1e8      	bne.n	1aa8 <sm_align_pool+0x1c>
    1ad6:	e7e9      	b.n	1aac <sm_align_pool+0x20>
    1ad8:	aaaaaaab 	.word	0xaaaaaaab

00001adc <sm_set_pool>:

	return 1;
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
    1adc:	b570      	push	{r4, r5, r6, lr}
	if (!spool) {
    1ade:	4604      	mov	r4, r0
    1ae0:	2800      	cmp	r0, #0
    1ae2:	d03a      	beq.n	1b5a <sm_set_pool+0x7e>
		errno = EINVAL;
		return 0;
	}

	if (!new_pool || !new_pool_size) {
    1ae4:	b119      	cbz	r1, 1aee <sm_set_pool+0x12>
    1ae6:	fab2 f582 	clz	r5, r2
    1aea:	096d      	lsrs	r5, r5, #5
    1aec:	b1fd      	cbz	r5, 1b2e <sm_set_pool+0x52>

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    1aee:	6820      	ldr	r0, [r4, #0]
    1af0:	b108      	cbz	r0, 1af6 <sm_set_pool+0x1a>
    1af2:	6862      	ldr	r2, [r4, #4]
    1af4:	b932      	cbnz	r2, 1b04 <sm_set_pool+0x28>
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    1af6:	f004 fd1f 	bl	6538 <__errno>
    1afa:	2316      	movs	r3, #22
		return 0;
    1afc:	2200      	movs	r2, #0
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    1afe:	6003      	str	r3, [r0, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1b00:	4610      	mov	r0, r2
    1b02:	bd70      	pop	{r4, r5, r6, pc}
struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
	if (spool->pool_size % HEADER_SZ) return 0;
    1b04:	4918      	ldr	r1, [pc, #96]	; (1b68 <sm_set_pool+0x8c>)
    1b06:	fba1 3102 	umull	r3, r1, r1, r2
    1b0a:	08c9      	lsrs	r1, r1, #3
    1b0c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    1b10:	ebb2 0181 	subs.w	r1, r2, r1, lsl #2
    1b14:	d1ef      	bne.n	1af6 <sm_set_pool+0x1a>
		return 0;
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
    1b16:	68a3      	ldr	r3, [r4, #8]
    1b18:	b10b      	cbz	r3, 1b1e <sm_set_pool+0x42>
    1b1a:	f005 f941 	bl	6da0 <memset>
			memset(spool, 0, sizeof(struct smalloc_pool));
    1b1e:	2300      	movs	r3, #0
			return 1;
    1b20:	2201      	movs	r2, #1
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    1b22:	6023      	str	r3, [r4, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1b24:	4610      	mov	r0, r2
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    1b26:	6063      	str	r3, [r4, #4]
    1b28:	60a3      	str	r3, [r4, #8]
    1b2a:	60e3      	str	r3, [r4, #12]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1b2c:	bd70      	pop	{r4, r5, r6, pc}
    1b2e:	461e      	mov	r6, r3
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
    1b30:	9b04      	ldr	r3, [sp, #16]
		errno = EINVAL;
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
    1b32:	e880 0006 	stmia.w	r0, {r1, r2}
	spool->oomfn = oom_handler;
    1b36:	60c3      	str	r3, [r0, #12]
	if (!sm_align_pool(spool)) return 0;
    1b38:	f7ff ffa8 	bl	1a8c <sm_align_pool>
    1b3c:	4602      	mov	r2, r0
    1b3e:	2800      	cmp	r0, #0
    1b40:	d0de      	beq.n	1b00 <sm_set_pool+0x24>

	if (do_zero) {
    1b42:	b916      	cbnz	r6, 1b4a <sm_set_pool+0x6e>
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
    1b44:	2201      	movs	r2, #1
}
    1b46:	4610      	mov	r0, r2
    1b48:	bd70      	pop	{r4, r5, r6, pc}
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
    1b4a:	e894 0005 	ldmia.w	r4, {r0, r2}
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
    1b4e:	60a6      	str	r6, [r4, #8]
		memset(spool->pool, 0, spool->pool_size);
    1b50:	4629      	mov	r1, r5
    1b52:	f005 f925 	bl	6da0 <memset>
	}

	return 1;
    1b56:	2201      	movs	r2, #1
    1b58:	e7d2      	b.n	1b00 <sm_set_pool+0x24>
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    1b5a:	f004 fced 	bl	6538 <__errno>
    1b5e:	2316      	movs	r3, #22
		return 0;
    1b60:	4622      	mov	r2, r4
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    1b62:	6003      	str	r3, [r0, #0]
		return 0;
    1b64:	e7cc      	b.n	1b00 <sm_set_pool+0x24>
    1b66:	bf00      	nop
    1b68:	aaaaaaab 	.word	0xaaaaaaab

00001b6c <unused_interrupt_vector>:
	const uint32_t *stack;
	struct arm_fault_info_struct *info;
	const uint32_t *p, *end;

	// disallow any nested interrupts
	__disable_irq();
    1b6c:	b672      	cpsid	i
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
    1b6e:	f3ef 8305 	mrs	r3, IPSR
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
    1b72:	4d49      	ldr	r5, [pc, #292]	; (1c98 <unused_interrupt_vector+0x12c>)
    1b74:	606b      	str	r3, [r5, #4]
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
    1b76:	f3ef 8308 	mrs	r3, MSP
	info->cfsr = SCB_CFSR;
    1b7a:	4c48      	ldr	r4, [pc, #288]	; (1c9c <unused_interrupt_vector+0x130>)
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
	info->len = sizeof(*info) / 4;
    1b7c:	462e      	mov	r6, r5
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
    1b7e:	4848      	ldr	r0, [pc, #288]	; (1ca0 <unused_interrupt_vector+0x134>)
	info->mmfar = SCB_MMFAR;
    1b80:	4948      	ldr	r1, [pc, #288]	; (1ca4 <unused_interrupt_vector+0x138>)
	info->bfar = SCB_BFAR;
    1b82:	4a49      	ldr	r2, [pc, #292]	; (1ca8 <unused_interrupt_vector+0x13c>)
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    1b84:	6824      	ldr	r4, [r4, #0]
	info->hfsr = SCB_HFSR;
    1b86:	6800      	ldr	r0, [r0, #0]
	info->mmfar = SCB_MMFAR;
    1b88:	6809      	ldr	r1, [r1, #0]
	info->bfar = SCB_BFAR;
    1b8a:	6812      	ldr	r2, [r2, #0]
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
    1b8c:	6129      	str	r1, [r5, #16]
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    1b8e:	60ac      	str	r4, [r5, #8]
	info->hfsr = SCB_HFSR;
    1b90:	60e8      	str	r0, [r5, #12]
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
    1b92:	616a      	str	r2, [r5, #20]
	info->ret = stack[6];
    1b94:	699a      	ldr	r2, [r3, #24]
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    1b96:	4c45      	ldr	r4, [pc, #276]	; (1cac <unused_interrupt_vector+0x140>)
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
    1b98:	61aa      	str	r2, [r5, #24]
	info->xpsr = stack[7];
    1b9a:	69db      	ldr	r3, [r3, #28]
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    1b9c:	4f44      	ldr	r7, [pc, #272]	; (1cb0 <unused_interrupt_vector+0x144>)
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
    1b9e:	61eb      	str	r3, [r5, #28]
	info->temp = tempmonGetTemp();
    1ba0:	f000 f8c8 	bl	1d34 <tempmonGetTemp>
    1ba4:	ed85 0a08 	vstr	s0, [r5, #32]
	info->time = rtc_get();
    1ba8:	f7ff ff58 	bl	1a5c <rtc_get>
	info->len = sizeof(*info) / 4;
    1bac:	230b      	movs	r3, #11
	// add CRC to crash report
	crc = 0xFFFFFFFF;
    1bae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
    1bb2:	6268      	str	r0, [r5, #36]	; 0x24
	info->len = sizeof(*info) / 4;
    1bb4:	4619      	mov	r1, r3
    1bb6:	602b      	str	r3, [r5, #0]
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
    1bb8:	404a      	eors	r2, r1
    1bba:	2120      	movs	r1, #32
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    1bbc:	f002 0301 	and.w	r3, r2, #1
    1bc0:	3901      	subs	r1, #1
    1bc2:	fb04 f303 	mul.w	r3, r4, r3
    1bc6:	ea83 0252 	eor.w	r2, r3, r2, lsr #1
    1bca:	d1f7      	bne.n	1bbc <unused_interrupt_vector+0x50>
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    1bcc:	42be      	cmp	r6, r7
    1bce:	d002      	beq.n	1bd6 <unused_interrupt_vector+0x6a>
    1bd0:	f856 1f04 	ldr.w	r1, [r6, #4]!
    1bd4:	e7f0      	b.n	1bb8 <unused_interrupt_vector+0x4c>
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
	}
	info->crc = crc;
    1bd6:	4930      	ldr	r1, [pc, #192]	; (1c98 <unused_interrupt_vector+0x12c>)
    1bd8:	628a      	str	r2, [r1, #40]	; 0x28
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    1bda:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    1bde:	4b35      	ldr	r3, [pc, #212]	; (1cb4 <unused_interrupt_vector+0x148>)
    1be0:	4a35      	ldr	r2, [pc, #212]	; (1cb8 <unused_interrupt_vector+0x14c>)
    1be2:	6019      	str	r1, [r3, #0]
    1be4:	601a      	str	r2, [r3, #0]
		location += 32;
	} while (location < end_addr);
	asm("dsb");
    1be6:	f3bf 8f4f 	dsb	sy
	asm("isb");
    1bea:	f3bf 8f6f 	isb	sy
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1bee:	4a33      	ldr	r2, [pc, #204]	; (1cbc <unused_interrupt_vector+0x150>)
	PIT_MCR = PIT_MCR_MDIS;
    1bf0:	2502      	movs	r5, #2
    1bf2:	4c33      	ldr	r4, [pc, #204]	; (1cc0 <unused_interrupt_vector+0x154>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1bf4:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1bf6:	4933      	ldr	r1, [pc, #204]	; (1cc4 <unused_interrupt_vector+0x158>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1bf8:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1bfc:	4832      	ldr	r0, [pc, #200]	; (1cc8 <unused_interrupt_vector+0x15c>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1bfe:	66d3      	str	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
    1c00:	6025      	str	r5, [r4, #0]
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    1c02:	69d3      	ldr	r3, [r2, #28]
    1c04:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    1c08:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1c0c:	61d3      	str	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1c0e:	680b      	ldr	r3, [r1, #0]
    1c10:	4283      	cmp	r3, r0
    1c12:	d83e      	bhi.n	1c92 <unused_interrupt_vector+0x126>
	PIT_MCR = 0;
    1c14:	4a2a      	ldr	r2, [pc, #168]	; (1cc0 <unused_interrupt_vector+0x154>)
    1c16:	2100      	movs	r1, #0
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    1c18:	2001      	movs	r0, #1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    1c1a:	4e2c      	ldr	r6, [pc, #176]	; (1ccc <unused_interrupt_vector+0x160>)
	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
    1c1c:	6011      	str	r1, [r2, #0]
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    1c1e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
    1c22:	f8c2 1108 	str.w	r1, [r2, #264]	; 0x108
	NVIC_ICER4 = 0xFFFFFFFF;

	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
    1c26:	460c      	mov	r4, r1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    1c28:	f8c2 6100 	str.w	r6, [r2, #256]	; 0x100
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    1c2c:	4615      	mov	r5, r2
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    1c2e:	f8c2 0108 	str.w	r0, [r2, #264]	; 0x108
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    1c32:	4607      	mov	r7, r0
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    1c34:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 1cf8 <unused_interrupt_vector+0x18c>
	NVIC_ICER1 = 0xFFFFFFFF;
    1c38:	4e25      	ldr	r6, [pc, #148]	; (1cd0 <unused_interrupt_vector+0x164>)
	NVIC_ICER2 = 0xFFFFFFFF;
    1c3a:	4826      	ldr	r0, [pc, #152]	; (1cd4 <unused_interrupt_vector+0x168>)
	NVIC_ICER3 = 0xFFFFFFFF;
    1c3c:	4926      	ldr	r1, [pc, #152]	; (1cd8 <unused_interrupt_vector+0x16c>)
	NVIC_ICER4 = 0xFFFFFFFF;
    1c3e:	4a27      	ldr	r2, [pc, #156]	; (1cdc <unused_interrupt_vector+0x170>)
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    1c40:	f8ce 3000 	str.w	r3, [lr]
	NVIC_ICER1 = 0xFFFFFFFF;
    1c44:	6033      	str	r3, [r6, #0]
	NVIC_ICER2 = 0xFFFFFFFF;
    1c46:	6003      	str	r3, [r0, #0]
	NVIC_ICER3 = 0xFFFFFFFF;
    1c48:	600b      	str	r3, [r1, #0]
	NVIC_ICER4 = 0xFFFFFFFF;
    1c4a:	6013      	str	r3, [r2, #0]
    1c4c:	e001      	b.n	1c52 <unused_interrupt_vector+0xe6>
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
		}
		usb_isr();
    1c4e:	f000 f955 	bl	1efc <usb_isr>
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    1c52:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
    1c56:	4b1a      	ldr	r3, [pc, #104]	; (1cc0 <unused_interrupt_vector+0x154>)
    1c58:	2a00      	cmp	r2, #0
    1c5a:	d0f8      	beq.n	1c4e <unused_interrupt_vector+0xe2>
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
    1c5c:	3401      	adds	r4, #1
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    1c5e:	f8c5 710c 	str.w	r7, [r5, #268]	; 0x10c
			if (++count >= 80) break;  // reboot after 8 seconds
    1c62:	2c4f      	cmp	r4, #79	; 0x4f
    1c64:	d9f3      	bls.n	1c4e <unused_interrupt_vector+0xe2>
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    1c66:	4a1e      	ldr	r2, [pc, #120]	; (1ce0 <unused_interrupt_vector+0x174>)
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    1c68:	2402      	movs	r4, #2
    1c6a:	481e      	ldr	r0, [pc, #120]	; (1ce4 <unused_interrupt_vector+0x178>)
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    1c6c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    1c70:	f8c0 4140 	str.w	r4, [r0, #320]	; 0x140
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    1c74:	6351      	str	r1, [r2, #52]	; 0x34
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    1c76:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    1c7a:	b932      	cbnz	r2, 1c8a <unused_interrupt_vector+0x11e>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
    1c7c:	491a      	ldr	r1, [pc, #104]	; (1ce8 <unused_interrupt_vector+0x17c>)
    1c7e:	4a1b      	ldr	r2, [pc, #108]	; (1cec <unused_interrupt_vector+0x180>)
    1c80:	630a      	str	r2, [r1, #48]	; 0x30
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    1c82:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    1c86:	2800      	cmp	r0, #0
    1c88:	d0fa      	beq.n	1c80 <unused_interrupt_vector+0x114>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
	SCB_AIRCR = 0x05FA0004;
    1c8a:	4b19      	ldr	r3, [pc, #100]	; (1cf0 <unused_interrupt_vector+0x184>)
    1c8c:	4a19      	ldr	r2, [pc, #100]	; (1cf4 <unused_interrupt_vector+0x188>)
    1c8e:	601a      	str	r2, [r3, #0]
    1c90:	e7fe      	b.n	1c90 <unused_interrupt_vector+0x124>

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1c92:	f7ff fb57 	bl	1344 <set_arm_clock>
    1c96:	e7bd      	b.n	1c14 <unused_interrupt_vector+0xa8>
    1c98:	2027ff80 	.word	0x2027ff80
    1c9c:	e000ed28 	.word	0xe000ed28
    1ca0:	e000ed2c 	.word	0xe000ed2c
    1ca4:	e000ed34 	.word	0xe000ed34
    1ca8:	e000ed38 	.word	0xe000ed38
    1cac:	edb88320 	.word	0xedb88320
    1cb0:	2027ffa4 	.word	0x2027ffa4
    1cb4:	e000ef70 	.word	0xe000ef70
    1cb8:	2027ffa0 	.word	0x2027ffa0
    1cbc:	400fc000 	.word	0x400fc000
    1cc0:	40084000 	.word	0x40084000
    1cc4:	20001590 	.word	0x20001590
    1cc8:	0bcd3d80 	.word	0x0bcd3d80
    1ccc:	00249f00 	.word	0x00249f00
    1cd0:	e000e184 	.word	0xe000e184
    1cd4:	e000e188 	.word	0xe000e188
    1cd8:	e000e18c 	.word	0xe000e18c
    1cdc:	e000e190 	.word	0xe000e190
    1ce0:	400d9000 	.word	0x400d9000
    1ce4:	402e0000 	.word	0x402e0000
    1ce8:	400f8000 	.word	0x400f8000
    1cec:	0bad00f1 	.word	0x0bad00f1
    1cf0:	e000ed0c 	.word	0xe000ed0c
    1cf4:	05fa0004 	.word	0x05fa0004
    1cf8:	e000e180 	.word	0xe000e180

00001cfc <_sbrk>:

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
        char *prev = __brkval;
    1cfc:	4a09      	ldr	r2, [pc, #36]	; (1d24 <_sbrk+0x28>)
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
    1cfe:	b508      	push	{r3, lr}
        char *prev = __brkval;
    1d00:	6813      	ldr	r3, [r2, #0]
        if (incr != 0) {
    1d02:	b120      	cbz	r0, 1d0e <_sbrk+0x12>
                if (prev + incr > (char *)&_heap_end) {
    1d04:	4418      	add	r0, r3
    1d06:	4908      	ldr	r1, [pc, #32]	; (1d28 <_sbrk+0x2c>)
    1d08:	4288      	cmp	r0, r1
    1d0a:	d802      	bhi.n	1d12 <_sbrk+0x16>
                        errno = ENOMEM;
                        return (void *)-1;
                }
                __brkval = prev + incr;
    1d0c:	6010      	str	r0, [r2, #0]
        }
        return prev;
}
    1d0e:	4618      	mov	r0, r3
    1d10:	bd08      	pop	{r3, pc}
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    1d12:	f004 fc11 	bl	6538 <__errno>
    1d16:	220c      	movs	r2, #12
                        return (void *)-1;
    1d18:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    1d1c:	6002      	str	r2, [r0, #0]
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    1d1e:	4618      	mov	r0, r3
    1d20:	bd08      	pop	{r3, pc}
    1d22:	bf00      	nop
    1d24:	20001970 	.word	0x20001970
    1d28:	20280000 	.word	0x20280000

00001d2c <_exit>:
}

__attribute__((weak))
void _exit(int status)
{
	while (1) asm ("WFI");
    1d2c:	bf30      	wfi
    1d2e:	e7fd      	b.n	1d2c <_exit>

00001d30 <Panic_Temp_isr>:
static float s_hot_ROOM, s_roomC_hotC;

extern void unused_interrupt_vector(void); // startup.c

void Panic_Temp_isr(void) {
  unused_interrupt_vector();
    1d30:	f7ff bf1c 	b.w	1b6c <unused_interrupt_vector>

00001d34 <tempmonGetTemp>:
float tempmonGetTemp(void)
{
    uint32_t nmeas;
    float tmeas;

    while (!(TEMPMON_TEMPSENSE0 & 0x4U))
    1d34:	4912      	ldr	r1, [pc, #72]	; (1d80 <tempmonGetTemp+0x4c>)
    1d36:	680b      	ldr	r3, [r1, #0]
    1d38:	4a11      	ldr	r2, [pc, #68]	; (1d80 <tempmonGetTemp+0x4c>)
    1d3a:	075b      	lsls	r3, r3, #29
    1d3c:	d5fb      	bpl.n	1d36 <tempmonGetTemp+0x2>
    {
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    1d3e:	6813      	ldr	r3, [r2, #0]
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1d40:	4910      	ldr	r1, [pc, #64]	; (1d84 <tempmonGetTemp+0x50>)

    return tmeas;
    1d42:	f3c3 230b 	ubfx	r3, r3, #8, #12
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1d46:	4a10      	ldr	r2, [pc, #64]	; (1d88 <tempmonGetTemp+0x54>)

    return tmeas;
    1d48:	ee07 3a90 	vmov	s15, r3
    1d4c:	680b      	ldr	r3, [r1, #0]
    1d4e:	ed92 6a00 	vldr	s12, [r2]
    1d52:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    1d56:	ee07 3a90 	vmov	s15, r3
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1d5a:	4a0c      	ldr	r2, [pc, #48]	; (1d8c <tempmonGetTemp+0x58>)

    return tmeas;
    1d5c:	eef8 7a67 	vcvt.f32.u32	s15, s15
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1d60:	4b0b      	ldr	r3, [pc, #44]	; (1d90 <tempmonGetTemp+0x5c>)

    return tmeas;
    1d62:	edd2 6a00 	vldr	s13, [r2]
    1d66:	ee77 7a67 	vsub.f32	s15, s14, s15
    1d6a:	ed93 7a00 	vldr	s14, [r3]
    1d6e:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    1d72:	ee67 7a86 	vmul.f32	s15, s15, s12
    1d76:	ee87 0aa6 	vdiv.f32	s0, s15, s13
}
    1d7a:	ee37 0a40 	vsub.f32	s0, s14, s0
    1d7e:	4770      	bx	lr
    1d80:	400d8180 	.word	0x400d8180
    1d84:	20002728 	.word	0x20002728
    1d88:	20002730 	.word	0x20002730
    1d8c:	20002734 	.word	0x20002734
    1d90:	2000272c 	.word	0x2000272c

00001d94 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    1d94:	6b83      	ldr	r3, [r0, #56]	; 0x38
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
    1d96:	b4f0      	push	{r4, r5, r6, r7}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    1d98:	b11b      	cbz	r3, 1da2 <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    1d9a:	6853      	ldr	r3, [r2, #4]
    1d9c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    1da0:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    1da2:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    1da4:	6b44      	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    1da6:	b35c      	cbz	r4, 1e00 <schedule_transfer+0x6c>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    1da8:	4b1c      	ldr	r3, [pc, #112]	; (1e1c <schedule_transfer+0x88>)
	__disable_irq();
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
	if (last) {
		last->next = (uint32_t)transfer;
    1daa:	6022      	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    1dac:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    1db0:	420c      	tst	r4, r1
    1db2:	d115      	bne.n	1de0 <schedule_transfer+0x4c>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    1db4:	4e1a      	ldr	r6, [pc, #104]	; (1e20 <schedule_transfer+0x8c>)
    1db6:	6837      	ldr	r7, [r6, #0]
    1db8:	e004      	b.n	1dc4 <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    1dba:	6834      	ldr	r4, [r6, #0]
    1dbc:	1be4      	subs	r4, r4, r7
    1dbe:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
    1dc2:	d20b      	bcs.n	1ddc <schedule_transfer+0x48>
		if (USB1_ENDPTPRIME & epmask) goto end;
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    1dc4:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    1dc8:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    1dcc:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    1dd0:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    1dd4:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    1dd8:	0464      	lsls	r4, r4, #17
    1dda:	d5ee      	bpl.n	1dba <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    1ddc:	400d      	ands	r5, r1
    1dde:	d003      	beq.n	1de8 <schedule_transfer+0x54>
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    1de0:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    1de2:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1de4:	bcf0      	pop	{r4, r5, r6, r7}
    1de6:	4770      	bx	lr
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
    1de8:	4c0c      	ldr	r4, [pc, #48]	; (1e1c <schedule_transfer+0x88>)
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
    1dea:	6082      	str	r2, [r0, #8]
		endpoint->status = 0;
    1dec:	60c5      	str	r5, [r0, #12]
		USB1_ENDPTPRIME |= epmask;
    1dee:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1df2:	4319      	orrs	r1, r3
    1df4:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    1df8:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    1dfa:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1dfc:	bcf0      	pop	{r4, r5, r6, r7}
    1dfe:	4770      	bx	lr
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
    1e00:	4d06      	ldr	r5, [pc, #24]	; (1e1c <schedule_transfer+0x88>)
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
    1e02:	6082      	str	r2, [r0, #8]
	endpoint->status = 0;
    1e04:	60c4      	str	r4, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
    1e06:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
    1e0a:	4319      	orrs	r1, r3
    1e0c:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    1e10:	6302      	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
    1e12:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    1e14:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1e16:	bcf0      	pop	{r4, r5, r6, r7}
    1e18:	4770      	bx	lr
    1e1a:	bf00      	nop
    1e1c:	402e0000 	.word	0x402e0000
    1e20:	e0001004 	.word	0xe0001004

00001e24 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    1e24:	b570      	push	{r4, r5, r6, lr}
    1e26:	4606      	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    1e28:	6b00      	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
    1e2a:	b190      	cbz	r0, 1e52 <run_callbacks+0x2e>
    1e2c:	4602      	mov	r2, r0
    1e2e:	2400      	movs	r4, #0
    1e30:	e003      	b.n	1e3a <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    1e32:	6812      	ldr	r2, [r2, #0]
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
    1e34:	3401      	adds	r4, #1
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
    1e36:	2a01      	cmp	r2, #1
    1e38:	d00c      	beq.n	1e54 <run_callbacks+0x30>

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
    1e3a:	6853      	ldr	r3, [r2, #4]
    1e3c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    1e40:	d0f7      	beq.n	1e32 <run_callbacks+0xe>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
    1e42:	6332      	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    1e44:	b12c      	cbz	r4, 1e52 <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
    1e46:	6bb3      	ldr	r3, [r6, #56]	; 0x38
			break;
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
    1e48:	6805      	ldr	r5, [r0, #0]
		ep->callback_function(first);
    1e4a:	4798      	blx	r3
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    1e4c:	3c01      	subs	r4, #1
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
    1e4e:	4628      	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    1e50:	d1f9      	bne.n	1e46 <run_callbacks+0x22>
    1e52:	bd70      	pop	{r4, r5, r6, pc}
		count++;
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
    1e54:	6333      	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
    1e56:	6373      	str	r3, [r6, #52]	; 0x34
			break;
    1e58:	e7f4      	b.n	1e44 <run_callbacks+0x20>
    1e5a:	bf00      	nop

00001e5c <endpoint0_transmit.constprop.1>:
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    1e5c:	b5f0      	push	{r4, r5, r6, r7, lr}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
    1e5e:	b9e1      	cbnz	r1, 1e9a <endpoint0_transmit.constprop.1+0x3e>
    1e60:	4c21      	ldr	r4, [pc, #132]	; (1ee8 <endpoint0_transmit.constprop.1+0x8c>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e62:	4922      	ldr	r1, [pc, #136]	; (1eec <endpoint0_transmit.constprop.1+0x90>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1e64:	2000      	movs	r0, #0
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1e66:	4b22      	ldr	r3, [pc, #136]	; (1ef0 <endpoint0_transmit.constprop.1+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e68:	2201      	movs	r2, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1e6a:	f04f 1501 	mov.w	r5, #65537	; 0x10001
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1e6e:	2680      	movs	r6, #128	; 0x80
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e70:	600a      	str	r2, [r1, #0]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
	while (USB1_ENDPTPRIME) ;
    1e72:	461a      	mov	r2, r3
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
    1e74:	60a1      	str	r1, [r4, #8]
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1e76:	604e      	str	r6, [r1, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
    1e78:	60e0      	str	r0, [r4, #12]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1e7a:	f8c3 51bc 	str.w	r5, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    1e7e:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    1e82:	4d1c      	ldr	r5, [pc, #112]	; (1ef4 <endpoint0_transmit.constprop.1+0x98>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    1e84:	f044 0401 	orr.w	r4, r4, #1
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1e88:	6088      	str	r0, [r1, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    1e8a:	f8c3 41b0 	str.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    1e8e:	6028      	str	r0, [r5, #0]
	while (USB1_ENDPTPRIME) ;
    1e90:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    1e94:	2b00      	cmp	r3, #0
    1e96:	d1fb      	bne.n	1e90 <endpoint0_transmit.constprop.1+0x34>
}
    1e98:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1e9a:	0409      	lsls	r1, r1, #16
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1e9c:	4b16      	ldr	r3, [pc, #88]	; (1ef8 <endpoint0_transmit.constprop.1+0x9c>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1e9e:	4d14      	ldr	r5, [pc, #80]	; (1ef0 <endpoint0_transmit.constprop.1+0x94>)
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1ea0:	2601      	movs	r6, #1
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    1ea2:	4c11      	ldr	r4, [pc, #68]	; (1ee8 <endpoint0_transmit.constprop.1+0x8c>)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1ea4:	f041 0180 	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    1ea8:	2200      	movs	r2, #0
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1eaa:	601e      	str	r6, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1eac:	6059      	str	r1, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1eae:	f500 5c80 	add.w	ip, r0, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    1eb2:	64e2      	str	r2, [r4, #76]	; 0x4c
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1eb4:	f500 5e00 	add.w	lr, r0, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    1eb8:	64a3      	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1eba:	f500 5740 	add.w	r7, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1ebe:	f8d5 11b0 	ldr.w	r1, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1ec2:	f500 4680 	add.w	r6, r0, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
    1ec6:	462a      	mov	r2, r5
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    1ec8:	6098      	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1eca:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1ece:	f8c3 c00c 	str.w	ip, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1ed2:	f8c3 e010 	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1ed6:	615f      	str	r7, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1ed8:	619e      	str	r6, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1eda:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    1ede:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    1ee2:	2b00      	cmp	r3, #0
    1ee4:	d1fb      	bne.n	1ede <endpoint0_transmit.constprop.1+0x82>
    1ee6:	e7bc      	b.n	1e62 <endpoint0_transmit.constprop.1+0x6>
    1ee8:	20000000 	.word	0x20000000
    1eec:	20002780 	.word	0x20002780
    1ef0:	402e0000 	.word	0x402e0000
    1ef4:	200026f0 	.word	0x200026f0
    1ef8:	20002760 	.word	0x20002760

00001efc <usb_isr>:
	__builtin_unreachable();
}


void usb_isr(void)
{
    1efc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    1f00:	4cb0      	ldr	r4, [pc, #704]	; (21c4 <usb_isr+0x2c8>)
	__builtin_unreachable();
}


void usb_isr(void)
{
    1f02:	b083      	sub	sp, #12
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    1f04:	f8d4 8144 	ldr.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    1f08:	f018 0f01 	tst.w	r8, #1
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
	USB1_USBSTS = status;
    1f0c:	f8c4 8144 	str.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    1f10:	d06f      	beq.n	1ff2 <usb_isr+0xf6>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    1f12:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1f16:	2b00      	cmp	r3, #0
    1f18:	d066      	beq.n	1fe8 <usb_isr+0xec>
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    1f1a:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
    1f1e:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 21e8 <usb_isr+0x2ec>
    1f22:	4fa9      	ldr	r7, [pc, #676]	; (21c8 <usb_isr+0x2cc>)
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    1f24:	4626      	mov	r6, r4
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    1f26:	46da      	mov	sl, fp
	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
    1f28:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
    1f2c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    1f2e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    1f30:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    1f34:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    1f38:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    1f3c:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    1f40:	049d      	lsls	r5, r3, #18
    1f42:	d5f5      	bpl.n	1f30 <usb_isr+0x34>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    1f44:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
    1f48:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    1f4c:	f8c6 3140 	str.w	r3, [r6, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    1f50:	f8c6 a1b4 	str.w	sl, [r6, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    1f54:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
    1f58:	f013 1301 	ands.w	r3, r3, #65537	; 0x10001
    1f5c:	d1fa      	bne.n	1f54 <usb_isr+0x58>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1f5e:	b281      	uxth	r1, r0
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
    1f60:	f8c9 3000 	str.w	r3, [r9]
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1f64:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    1f68:	f000 8148 	beq.w	21fc <usb_isr+0x300>
    1f6c:	f200 80bb 	bhi.w	20e6 <usb_isr+0x1ea>
    1f70:	2982      	cmp	r1, #130	; 0x82
    1f72:	f000 8193 	beq.w	229c <usb_isr+0x3a0>
    1f76:	f240 80cf 	bls.w	2118 <usb_isr+0x21c>
    1f7a:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    1f7e:	f000 815d 	beq.w	223c <usb_isr+0x340>
    1f82:	f240 3302 	movw	r3, #770	; 0x302
    1f86:	4299      	cmp	r1, r3
    1f88:	f040 80be 	bne.w	2108 <usb_isr+0x20c>
			reply_buffer[0] = 1;
		}
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    1f8c:	b292      	uxth	r2, r2
    1f8e:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    1f92:	2b07      	cmp	r3, #7
    1f94:	f200 80b8 	bhi.w	2108 <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    1f98:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    1f9c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1fa0:	4a8a      	ldr	r2, [pc, #552]	; (21cc <usb_isr+0x2d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1fa2:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1fa6:	f04f 0001 	mov.w	r0, #1
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    1faa:	441a      	add	r2, r3
    1fac:	6813      	ldr	r3, [r2, #0]
    1fae:	bf14      	ite	ne
    1fb0:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    1fb4:	f043 0301 	orreq.w	r3, r3, #1
    1fb8:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1fba:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1fbc:	4b84      	ldr	r3, [pc, #528]	; (21d0 <usb_isr+0x2d4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1fbe:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1fc0:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1fc2:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1fc4:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1fc6:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1fca:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1fce:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1fd0:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    1fd4:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    1fd8:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1fdc:	2b00      	cmp	r3, #0
    1fde:	d1fb      	bne.n	1fd8 <usb_isr+0xdc>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1fe0:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1fe4:	2b00      	cmp	r3, #0
    1fe6:	d19f      	bne.n	1f28 <usb_isr+0x2c>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    1fe8:	4a76      	ldr	r2, [pc, #472]	; (21c4 <usb_isr+0x2c8>)
    1fea:	f8d2 31bc 	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    1fee:	2b00      	cmp	r3, #0
    1ff0:	d147      	bne.n	2082 <usb_isr+0x186>
			}
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
    1ff2:	f018 0f40 	tst.w	r8, #64	; 0x40
    1ff6:	d016      	beq.n	2026 <usb_isr+0x12a>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    1ff8:	4b72      	ldr	r3, [pc, #456]	; (21c4 <usb_isr+0x2c8>)
    1ffa:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    1ffe:	4619      	mov	r1, r3
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    2000:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    2004:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    2008:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    200c:	f8d1 31b0 	ldr.w	r3, [r1, #432]	; 0x1b0
    2010:	4a6c      	ldr	r2, [pc, #432]	; (21c4 <usb_isr+0x2c8>)
    2012:	2b00      	cmp	r3, #0
    2014:	d1fa      	bne.n	200c <usb_isr+0x110>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    2016:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    201a:	496e      	ldr	r1, [pc, #440]	; (21d4 <usb_isr+0x2d8>)
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    201c:	f8c2 01b4 	str.w	r0, [r2, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    2020:	f8d2 2184 	ldr.w	r2, [r2, #388]	; 0x184
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    2024:	600b      	str	r3, [r1, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
    2026:	f018 7f80 	tst.w	r8, #16777216	; 0x1000000
    202a:	d003      	beq.n	2034 <usb_isr+0x138>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    202c:	4b6a      	ldr	r3, [pc, #424]	; (21d8 <usb_isr+0x2dc>)
    202e:	681b      	ldr	r3, [r3, #0]
    2030:	b103      	cbz	r3, 2034 <usb_isr+0x138>
    2032:	4798      	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
    2034:	f018 7f00 	tst.w	r8, #33554432	; 0x2000000
    2038:	d003      	beq.n	2042 <usb_isr+0x146>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    203a:	4b68      	ldr	r3, [pc, #416]	; (21dc <usb_isr+0x2e0>)
    203c:	681b      	ldr	r3, [r3, #0]
    203e:	b103      	cbz	r3, 2042 <usb_isr+0x146>
    2040:	4798      	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
    2042:	f018 0f04 	tst.w	r8, #4
    2046:	d008      	beq.n	205a <usb_isr+0x15e>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    2048:	4b5e      	ldr	r3, [pc, #376]	; (21c4 <usb_isr+0x2c8>)
    204a:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    204e:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    2052:	d045      	beq.n	20e0 <usb_isr+0x1e4>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
    2054:	4b62      	ldr	r3, [pc, #392]	; (21e0 <usb_isr+0x2e4>)
    2056:	2201      	movs	r2, #1
    2058:	701a      	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    205a:	4b5a      	ldr	r3, [pc, #360]	; (21c4 <usb_isr+0x2c8>)
    205c:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    2060:	0612      	lsls	r2, r2, #24
    2062:	d50b      	bpl.n	207c <usb_isr+0x180>
    2064:	f018 0f80 	tst.w	r8, #128	; 0x80
    2068:	d008      	beq.n	207c <usb_isr+0x180>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
    206a:	495e      	ldr	r1, [pc, #376]	; (21e4 <usb_isr+0x2e8>)
    206c:	780a      	ldrb	r2, [r1, #0]
    206e:	b12a      	cbz	r2, 207c <usb_isr+0x180>
			if (--usb_reboot_timer == 0) {
    2070:	3a01      	subs	r2, #1
    2072:	b2d2      	uxtb	r2, r2
    2074:	700a      	strb	r2, [r1, #0]
    2076:	2a00      	cmp	r2, #0
    2078:	f000 8217 	beq.w	24aa <usb_isr+0x5ae>
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
    207c:	b003      	add	sp, #12
    207e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    2082:	4959      	ldr	r1, [pc, #356]	; (21e8 <usb_isr+0x2ec>)
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
    2084:	f8c2 31bc 	str.w	r3, [r2, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    2088:	6808      	ldr	r0, [r1, #0]
    208a:	4203      	tst	r3, r0
    208c:	f040 81b1 	bne.w	23f2 <usb_isr+0x4f6>
				endpoint0_notify_mask = 0;
				endpoint0_complete();
			}
			completestatus &= endpointN_notify_mask;
    2090:	4a50      	ldr	r2, [pc, #320]	; (21d4 <usb_isr+0x2d8>)
    2092:	6815      	ldr	r5, [r2, #0]
#if 1
			if (completestatus) {
    2094:	401d      	ands	r5, r3
    2096:	d0ac      	beq.n	1ff2 <usb_isr+0xf6>

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    2098:	0c2e      	lsrs	r6, r5, #16
    209a:	d00f      	beq.n	20bc <usb_isr+0x1c0>
    209c:	4f4a      	ldr	r7, [pc, #296]	; (21c8 <usb_isr+0x2cc>)
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
    209e:	f04f 0901 	mov.w	r9, #1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
    20a2:	fa96 f4a6 	rbit	r4, r6
    20a6:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    20aa:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					tx &= ~(1<<p);
    20ae:	fa09 f404 	lsl.w	r4, r9, r4

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    20b2:	3040      	adds	r0, #64	; 0x40
    20b4:	f7ff feb6 	bl	1e24 <run_callbacks>
#if 1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    20b8:	43a6      	bics	r6, r4
    20ba:	d1f2      	bne.n	20a2 <usb_isr+0x1a6>
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
    20bc:	b2ad      	uxth	r5, r5
				while(rx) {
    20be:	2d00      	cmp	r5, #0
    20c0:	d097      	beq.n	1ff2 <usb_isr+0xf6>
    20c2:	4f41      	ldr	r7, [pc, #260]	; (21c8 <usb_isr+0x2cc>)
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
					rx &= ~(1<<p);
    20c4:	2601      	movs	r6, #1
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
    20c6:	fa95 f4a5 	rbit	r4, r5
    20ca:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2);
    20ce:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					rx &= ~(1<<p);
    20d2:	fa06 f404 	lsl.w	r4, r6, r4

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
    20d6:	f7ff fea5 	bl	1e24 <run_callbacks>
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
    20da:	43a5      	bics	r5, r4
    20dc:	d1f3      	bne.n	20c6 <usb_isr+0x1ca>
    20de:	e788      	b.n	1ff2 <usb_isr+0xf6>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
    20e0:	4a3f      	ldr	r2, [pc, #252]	; (21e0 <usb_isr+0x2e4>)
    20e2:	7013      	strb	r3, [r2, #0]
    20e4:	e7b9      	b.n	205a <usb_isr+0x15e>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    20e6:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    20ea:	f000 80f5 	beq.w	22d8 <usb_isr+0x3dc>
    20ee:	d922      	bls.n	2136 <usb_isr+0x23a>
    20f0:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    20f4:	f000 80fe 	beq.w	22f4 <usb_isr+0x3f8>
    20f8:	f640 1521 	movw	r5, #2337	; 0x921
    20fc:	42a9      	cmp	r1, r5
    20fe:	d103      	bne.n	2108 <usb_isr+0x20c>
		endpoint0_receive(endpoint0_buffer, 7, 1);
		return;
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
    2100:	0c11      	lsrs	r1, r2, #16
    2102:	2908      	cmp	r1, #8
    2104:	f240 8126 	bls.w	2354 <usb_isr+0x458>
		}
		break;
#endif
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    2108:	f8c4 b1c0 	str.w	fp, [r4, #448]	; 0x1c0
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    210c:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    2110:	2b00      	cmp	r3, #0
    2112:	f47f af09 	bne.w	1f28 <usb_isr+0x2c>
    2116:	e767      	b.n	1fe8 <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    2118:	2980      	cmp	r1, #128	; 0x80
    211a:	d1f5      	bne.n	2108 <usb_isr+0x20c>
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    211c:	4a33      	ldr	r2, [pc, #204]	; (21ec <usb_isr+0x2f0>)
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
    211e:	2102      	movs	r1, #2
    2120:	4610      	mov	r0, r2
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    2122:	7013      	strb	r3, [r2, #0]
		reply_buffer[1] = 0;
    2124:	7053      	strb	r3, [r2, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
    2126:	f7ff fe99 	bl	1e5c <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    212a:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    212e:	2b00      	cmp	r3, #0
    2130:	f47f aefa 	bne.w	1f28 <usb_isr+0x2c>
    2134:	e758      	b.n	1fe8 <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    2136:	f5a1 61d0 	sub.w	r1, r1, #1664	; 0x680
    213a:	2901      	cmp	r1, #1
    213c:	d8e4      	bhi.n	2108 <usb_isr+0x20c>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    213e:	4b2c      	ldr	r3, [pc, #176]	; (21f0 <usb_isr+0x2f4>)
    2140:	6859      	ldr	r1, [r3, #4]
    2142:	2900      	cmp	r1, #0
    2144:	d0e0      	beq.n	2108 <usb_isr+0x20c>
    2146:	0c00      	lsrs	r0, r0, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    2148:	fa1f fe82 	uxth.w	lr, r2
    214c:	e003      	b.n	2156 <usb_isr+0x25a>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    214e:	330c      	adds	r3, #12
    2150:	6859      	ldr	r1, [r3, #4]
    2152:	2900      	cmp	r1, #0
    2154:	d0d8      	beq.n	2108 <usb_isr+0x20c>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    2156:	881d      	ldrh	r5, [r3, #0]
    2158:	4285      	cmp	r5, r0
    215a:	d1f8      	bne.n	214e <usb_isr+0x252>
    215c:	885d      	ldrh	r5, [r3, #2]
    215e:	4575      	cmp	r5, lr
    2160:	d1f5      	bne.n	214e <usb_isr+0x252>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
    2162:	0a05      	lsrs	r5, r0, #8
    2164:	2d03      	cmp	r5, #3
    2166:	f000 817b 	beq.w	2460 <usb_isr+0x564>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
    216a:	891b      	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    216c:	0c12      	lsrs	r2, r2, #16
    216e:	4293      	cmp	r3, r2
    2170:	bf28      	it	cs
    2172:	4613      	movcs	r3, r2

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
    2174:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    2178:	f000 8163 	beq.w	2442 <usb_isr+0x546>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
    217c:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    2180:	f000 814c 	beq.w	241c <usb_isr+0x520>
    2184:	4d1b      	ldr	r5, [pc, #108]	; (21f4 <usb_isr+0x2f8>)
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
					usb_descriptor_buffer[1] = 7;
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    2186:	461a      	mov	r2, r3
    2188:	9301      	str	r3, [sp, #4]
    218a:	4628      	mov	r0, r5
    218c:	f004 fd0a 	bl	6ba4 <memcpy>
    2190:	9b01      	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    2192:	f025 021f 	bic.w	r2, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    2196:	441d      	add	r5, r3
	asm volatile("": : :"memory");
	asm("dsb");
    2198:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    219c:	4916      	ldr	r1, [pc, #88]	; (21f8 <usb_isr+0x2fc>)
    219e:	600a      	str	r2, [r1, #0]
		location += 32;
    21a0:	3220      	adds	r2, #32
	} while (location < end_addr);
    21a2:	4295      	cmp	r5, r2
    21a4:	d8fa      	bhi.n	219c <usb_isr+0x2a0>
	asm("dsb");
    21a6:	f3bf 8f4f 	dsb	sy
	asm("isb");
    21aa:	f3bf 8f6f 	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    21ae:	4811      	ldr	r0, [pc, #68]	; (21f4 <usb_isr+0x2f8>)
    21b0:	4619      	mov	r1, r3
    21b2:	f7ff fe53 	bl	1e5c <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    21b6:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    21ba:	2b00      	cmp	r3, #0
    21bc:	f47f aeb4 	bne.w	1f28 <usb_isr+0x2c>
    21c0:	e712      	b.n	1fe8 <usb_isr+0xec>
    21c2:	bf00      	nop
    21c4:	402e0000 	.word	0x402e0000
    21c8:	20000000 	.word	0x20000000
    21cc:	402e01c0 	.word	0x402e01c0
    21d0:	20002780 	.word	0x20002780
    21d4:	200026f4 	.word	0x200026f4
    21d8:	20002744 	.word	0x20002744
    21dc:	20002748 	.word	0x20002748
    21e0:	2000275d 	.word	0x2000275d
    21e4:	2000275e 	.word	0x2000275e
    21e8:	200026f0 	.word	0x200026f0
    21ec:	200026f8 	.word	0x200026f8
    21f0:	200010b0 	.word	0x200010b0
    21f4:	20200000 	.word	0x20200000
    21f8:	e000ef70 	.word	0xe000ef70
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    21fc:	4ab2      	ldr	r2, [pc, #712]	; (24c8 <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    21fe:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2200:	2501      	movs	r5, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    2202:	64fb      	str	r3, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    2204:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2206:	6015      	str	r5, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    2208:	6051      	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    220a:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    220e:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    2212:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    2214:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
    2218:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    221c:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    2220:	2b00      	cmp	r3, #0
    2222:	d1fb      	bne.n	221c <usb_isr+0x320>

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    2224:	0c03      	lsrs	r3, r0, #16
    2226:	065b      	lsls	r3, r3, #25
    2228:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    222c:	f8c6 3154 	str.w	r3, [r6, #340]	; 0x154
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    2230:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    2234:	2b00      	cmp	r3, #0
    2236:	f47f ae77 	bne.w	1f28 <usb_isr+0x2c>
    223a:	e6d5      	b.n	1fe8 <usb_isr+0xec>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    223c:	b292      	uxth	r2, r2
    223e:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    2242:	2b07      	cmp	r3, #7
    2244:	f63f af60 	bhi.w	2108 <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    2248:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    224c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2250:	4a9e      	ldr	r2, [pc, #632]	; (24cc <usb_isr+0x5d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    2252:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2256:	f04f 0001 	mov.w	r0, #1
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    225a:	441a      	add	r2, r3
    225c:	6813      	ldr	r3, [r2, #0]
    225e:	bf14      	ite	ne
    2260:	f423 3380 	bicne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    2264:	f023 0301 	biceq.w	r3, r3, #1
    2268:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    226a:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    226c:	4b96      	ldr	r3, [pc, #600]	; (24c8 <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    226e:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    2270:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2272:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    2274:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    2276:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    227a:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    227e:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    2280:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    2284:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    2288:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    228c:	2b00      	cmp	r3, #0
    228e:	d1fb      	bne.n	2288 <usb_isr+0x38c>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    2290:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    2294:	2b00      	cmp	r3, #0
    2296:	f47f ae47 	bne.w	1f28 <usb_isr+0x2c>
    229a:	e6a5      	b.n	1fe8 <usb_isr+0xec>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
    229c:	b292      	uxth	r2, r2
    229e:	f002 017f 	and.w	r1, r2, #127	; 0x7f
		if (endpoint > 7) break;
    22a2:	2907      	cmp	r1, #7
    22a4:	f63f af30 	bhi.w	2108 <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    22a8:	0089      	lsls	r1, r1, #2
    22aa:	4888      	ldr	r0, [pc, #544]	; (24cc <usb_isr+0x5d0>)
		reply_buffer[0] = 0;
    22ac:	4d88      	ldr	r5, [pc, #544]	; (24d0 <usb_isr+0x5d4>)
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    22ae:	4408      	add	r0, r1
    22b0:	6801      	ldr	r1, [r0, #0]
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    22b2:	0610      	lsls	r0, r2, #24
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
    22b4:	702b      	strb	r3, [r5, #0]
		reply_buffer[1] = 0;
    22b6:	706b      	strb	r3, [r5, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    22b8:	f140 8097 	bpl.w	23ea <usb_isr+0x4ee>
    22bc:	03ca      	lsls	r2, r1, #15
    22be:	d501      	bpl.n	22c4 <usb_isr+0x3c8>
			reply_buffer[0] = 1;
    22c0:	2301      	movs	r3, #1
    22c2:	702b      	strb	r3, [r5, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
    22c4:	2102      	movs	r1, #2
    22c6:	4882      	ldr	r0, [pc, #520]	; (24d0 <usb_isr+0x5d4>)
    22c8:	f7ff fdc8 	bl	1e5c <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    22cc:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    22d0:	2b00      	cmp	r3, #0
    22d2:	f47f ae29 	bne.w	1f28 <usb_isr+0x2c>
    22d6:	e687      	b.n	1fe8 <usb_isr+0xec>
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    22d8:	4a7e      	ldr	r2, [pc, #504]	; (24d4 <usb_isr+0x5d8>)
		endpoint0_transmit(reply_buffer, 1, 0);
    22da:	2101      	movs	r1, #1
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    22dc:	4b7c      	ldr	r3, [pc, #496]	; (24d0 <usb_isr+0x5d4>)
    22de:	7812      	ldrb	r2, [r2, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    22e0:	4618      	mov	r0, r3
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    22e2:	701a      	strb	r2, [r3, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    22e4:	f7ff fdba 	bl	1e5c <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    22e8:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    22ec:	2b00      	cmp	r3, #0
    22ee:	f47f ae1b 	bne.w	1f28 <usb_isr+0x2c>
    22f2:	e679      	b.n	1fe8 <usb_isr+0xec>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    22f4:	f3c0 4007 	ubfx	r0, r0, #16, #8
    22f8:	4a76      	ldr	r2, [pc, #472]	; (24d4 <usb_isr+0x5d8>)
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    22fa:	4977      	ldr	r1, [pc, #476]	; (24d8 <usb_isr+0x5dc>)
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    22fc:	f04f 15cc 	mov.w	r5, #13369548	; 0xcc00cc
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    2300:	7010      	strb	r0, [r2, #0]
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    2302:	4a76      	ldr	r2, [pc, #472]	; (24dc <usb_isr+0x5e0>)
    2304:	9301      	str	r3, [sp, #4]
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    2306:	f8c6 51c8 	str.w	r5, [r6, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    230a:	f8c6 11cc 	str.w	r1, [r6, #460]	; 0x1cc
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    230e:	f8c6 21d0 	str.w	r2, [r6, #464]	; 0x1d0
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
		#elif defined(SEREMU_INTERFACE)
		usb_seremu_configure();
    2312:	f000 fab3 	bl	287c <usb_seremu_configure>
		#endif
		#if defined(CDC3_STATUS_INTERFACE) && defined(CDC3_DATA_INTERFACE)
		usb_serial3_configure();
		#endif
		#if defined(RAWHID_INTERFACE)
		usb_rawhid_configure();
    2316:	f000 fa19 	bl	274c <usb_rawhid_configure>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    231a:	4a6b      	ldr	r2, [pc, #428]	; (24c8 <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    231c:	9b01      	ldr	r3, [sp, #4]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    231e:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2320:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    2322:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    2324:	6051      	str	r1, [r2, #4]
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2326:	6010      	str	r0, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    2328:	64fb      	str	r3, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    232a:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    232e:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    2332:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    2334:	f441 3280 	orr.w	r2, r1, #65536	; 0x10000
    2338:	f8c6 21b0 	str.w	r2, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    233c:	4a68      	ldr	r2, [pc, #416]	; (24e0 <usb_isr+0x5e4>)
    233e:	6013      	str	r3, [r2, #0]
	while (USB1_ENDPTPRIME) ;
    2340:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    2344:	2b00      	cmp	r3, #0
    2346:	d1fb      	bne.n	2340 <usb_isr+0x444>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    2348:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    234c:	2b00      	cmp	r3, #0
    234e:	f47f adeb 	bne.w	1f28 <usb_isr+0x2c>
    2352:	e649      	b.n	1fe8 <usb_isr+0xec>
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    2354:	f8df e194 	ldr.w	lr, [pc, #404]	; 24ec <usb_isr+0x5f0>
			endpoint0_buffer[0] = 0xE9;
    2358:	f04f 0ce9 	mov.w	ip, #233	; 0xe9
    235c:	4d61      	ldr	r5, [pc, #388]	; (24e4 <usb_isr+0x5e8>)
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    235e:	e88e 0005 	stmia.w	lr, {r0, r2}
			endpoint0_buffer[0] = 0xE9;
    2362:	f885 c000 	strb.w	ip, [r5]
}

static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
    2366:	b301      	cbz	r1, 23aa <usb_isr+0x4ae>
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    2368:	0409      	lsls	r1, r1, #16
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    236a:	4a5f      	ldr	r2, [pc, #380]	; (24e8 <usb_isr+0x5ec>)
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
    236c:	60fb      	str	r3, [r7, #12]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    236e:	2001      	movs	r0, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    2370:	f041 0380 	orr.w	r3, r1, #128	; 0x80
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    2374:	60ba      	str	r2, [r7, #8]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    2376:	6010      	str	r0, [r2, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    2378:	f505 5e00 	add.w	lr, r5, #8192	; 0x2000
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    237c:	6053      	str	r3, [r2, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    237e:	f505 5080 	add.w	r0, r5, #4096	; 0x1000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    2382:	f8d6 31b0 	ldr.w	r3, [r6, #432]	; 0x1b0
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    2386:	f505 5140 	add.w	r1, r5, #12288	; 0x3000
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    238a:	6095      	str	r5, [r2, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    238c:	f505 4580 	add.w	r5, r5, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    2390:	f043 0301 	orr.w	r3, r3, #1
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    2394:	60d0      	str	r0, [r2, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    2396:	f8c2 e010 	str.w	lr, [r2, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    239a:	6151      	str	r1, [r2, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    239c:	6195      	str	r5, [r2, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    239e:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    23a2:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    23a6:	2b00      	cmp	r3, #0
    23a8:	d1fb      	bne.n	23a2 <usb_isr+0x4a6>
	}
	endpoint0_transfer_ack.next = 1;
    23aa:	4b47      	ldr	r3, [pc, #284]	; (24c8 <usb_isr+0x5cc>)
    23ac:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    23ae:	f248 0280 	movw	r2, #32896	; 0x8080
	endpoint0_transfer_ack.pointer0 = 0;
    23b2:	2100      	movs	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    23b4:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    23b6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    23ba:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    23bc:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    23be:	64f9      	str	r1, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    23c0:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    23c4:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    23c8:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    23ca:	ea42 0300 	orr.w	r3, r2, r0
    23ce:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    23d2:	f8c9 0000 	str.w	r0, [r9]
	while (USB1_ENDPTPRIME) ;
    23d6:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    23da:	2b00      	cmp	r3, #0
    23dc:	d1fb      	bne.n	23d6 <usb_isr+0x4da>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    23de:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    23e2:	2b00      	cmp	r3, #0
    23e4:	f47f ada0 	bne.w	1f28 <usb_isr+0x2c>
    23e8:	e5fe      	b.n	1fe8 <usb_isr+0xec>
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    23ea:	07cb      	lsls	r3, r1, #31
    23ec:	f57f af6a 	bpl.w	22c4 <usb_isr+0x3c8>
    23f0:	e766      	b.n	22c0 <usb_isr+0x3c4>

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    23f2:	483e      	ldr	r0, [pc, #248]	; (24ec <usb_isr+0x5f0>)
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    23f4:	2600      	movs	r6, #0
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    23f6:	4c3e      	ldr	r4, [pc, #248]	; (24f0 <usb_isr+0x5f4>)

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    23f8:	6805      	ldr	r5, [r0, #0]
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    23fa:	600e      	str	r6, [r1, #0]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    23fc:	42a5      	cmp	r5, r4

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    23fe:	6840      	ldr	r0, [r0, #4]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    2400:	f47f ae46 	bne.w	2090 <usb_isr+0x194>
    2404:	493b      	ldr	r1, [pc, #236]	; (24f4 <usb_isr+0x5f8>)
    2406:	4288      	cmp	r0, r1
    2408:	f47f ae42 	bne.w	2090 <usb_isr+0x194>
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    240c:	4935      	ldr	r1, [pc, #212]	; (24e4 <usb_isr+0x5e8>)
    240e:	7808      	ldrb	r0, [r1, #0]
    2410:	28a9      	cmp	r0, #169	; 0xa9
    2412:	d02b      	beq.n	246c <usb_isr+0x570>
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
		} else {
			// any other feature report means Arduino Serial Monitor is open
			usb_seremu_online = 1;
    2414:	4a38      	ldr	r2, [pc, #224]	; (24f8 <usb_isr+0x5fc>)
    2416:	2101      	movs	r1, #1
    2418:	7011      	strb	r1, [r2, #0]
    241a:	e639      	b.n	2090 <usb_isr+0x194>
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    241c:	4837      	ldr	r0, [pc, #220]	; (24fc <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    241e:	461a      	mov	r2, r3
    2420:	4d37      	ldr	r5, [pc, #220]	; (2500 <usb_isr+0x604>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    2422:	f890 e000 	ldrb.w	lr, [r0]
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
    2426:	4937      	ldr	r1, [pc, #220]	; (2504 <usb_isr+0x608>)
    2428:	4837      	ldr	r0, [pc, #220]	; (2508 <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
    242a:	9301      	str	r3, [sp, #4]
    242c:	f1be 0f00 	cmp.w	lr, #0
    2430:	bf08      	it	eq
    2432:	4601      	moveq	r1, r0
    2434:	4628      	mov	r0, r5
    2436:	f004 fbb5 	bl	6ba4 <memcpy>
					usb_descriptor_buffer[1] = 7;
    243a:	2207      	movs	r2, #7
    243c:	9b01      	ldr	r3, [sp, #4]
    243e:	706a      	strb	r2, [r5, #1]
    2440:	e6a7      	b.n	2192 <usb_isr+0x296>

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
    2442:	482e      	ldr	r0, [pc, #184]	; (24fc <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    2444:	461a      	mov	r2, r3
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    2446:	4930      	ldr	r1, [pc, #192]	; (2508 <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_480;
    2448:	7805      	ldrb	r5, [r0, #0]
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    244a:	482e      	ldr	r0, [pc, #184]	; (2504 <usb_isr+0x608>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
    244c:	9301      	str	r3, [sp, #4]
    244e:	2d00      	cmp	r5, #0
    2450:	bf08      	it	eq
    2452:	4601      	moveq	r1, r0
    2454:	482a      	ldr	r0, [pc, #168]	; (2500 <usb_isr+0x604>)
    2456:	f004 fba5 	bl	6ba4 <memcpy>
    245a:	4d29      	ldr	r5, [pc, #164]	; (2500 <usb_isr+0x604>)
    245c:	9b01      	ldr	r3, [sp, #4]
    245e:	e698      	b.n	2192 <usb_isr+0x296>
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    2460:	0c12      	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
    2462:	780b      	ldrb	r3, [r1, #0]
    2464:	4293      	cmp	r3, r2
    2466:	bf28      	it	cs
    2468:	4613      	movcs	r3, r2
    246a:	e687      	b.n	217c <usb_isr+0x280>
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    246c:	7848      	ldrb	r0, [r1, #1]
    246e:	2845      	cmp	r0, #69	; 0x45
    2470:	d1d0      	bne.n	2414 <usb_isr+0x518>
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
    2472:	7888      	ldrb	r0, [r1, #2]
    2474:	28c2      	cmp	r0, #194	; 0xc2
    2476:	d1cd      	bne.n	2414 <usb_isr+0x518>
    2478:	78c9      	ldrb	r1, [r1, #3]
    247a:	296b      	cmp	r1, #107	; 0x6b
    247c:	d1ca      	bne.n	2414 <usb_isr+0x518>
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
    247e:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    2480:	4822      	ldr	r0, [pc, #136]	; (250c <usb_isr+0x610>)
    2482:	7801      	ldrb	r1, [r0, #0]
    2484:	f041 0104 	orr.w	r1, r1, #4
    2488:	7001      	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    248a:	f8d2 1148 	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    248e:	0608      	lsls	r0, r1, #24
    2490:	d406      	bmi.n	24a0 <usb_isr+0x5a4>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    2492:	f041 0180 	orr.w	r1, r1, #128	; 0x80
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    2496:	2080      	movs	r0, #128	; 0x80
    2498:	f8c2 0144 	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    249c:	f8c2 1148 	str.w	r1, [r2, #328]	; 0x148
	}
	__enable_irq();
    24a0:	b662      	cpsie	i
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    24a2:	4a1b      	ldr	r2, [pc, #108]	; (2510 <usb_isr+0x614>)
    24a4:	2150      	movs	r1, #80	; 0x50
    24a6:	7011      	strb	r1, [r2, #0]
    24a8:	e5f2      	b.n	2090 <usb_isr+0x194>
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
    24aa:	4918      	ldr	r1, [pc, #96]	; (250c <usb_isr+0x610>)
    24ac:	780a      	ldrb	r2, [r1, #0]
    24ae:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    24b2:	700a      	strb	r2, [r1, #0]
	if (sof_usage == 0) {
    24b4:	b92a      	cbnz	r2, 24c2 <usb_isr+0x5c6>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    24b6:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    24ba:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    24be:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
			if (--usb_reboot_timer == 0) {
				usb_stop_sof_interrupts(NUM_INTERFACE);
				_reboot_Teensyduino_();
    24c2:	f008 f9b1 	bl	a828 <___reboot_Teensyduino__veneer>
    24c6:	bf00      	nop
    24c8:	20002780 	.word	0x20002780
    24cc:	402e01c0 	.word	0x402e01c0
    24d0:	200026f8 	.word	0x200026f8
    24d4:	2000275c 	.word	0x2000275c
    24d8:	00cc0002 	.word	0x00cc0002
    24dc:	000200cc 	.word	0x000200cc
    24e0:	200026f0 	.word	0x200026f0
    24e4:	200026e8 	.word	0x200026e8
    24e8:	20002760 	.word	0x20002760
    24ec:	20002660 	.word	0x20002660
    24f0:	03000921 	.word	0x03000921
    24f4:	00040001 	.word	0x00040001
    24f8:	2000275f 	.word	0x2000275f
    24fc:	2000275d 	.word	0x2000275d
    2500:	20200000 	.word	0x20200000
    2504:	600020e4 	.word	0x600020e4
    2508:	60002130 	.word	0x60002130
    250c:	20002757 	.word	0x20002757
    2510:	2000275e 	.word	0x2000275e

00002514 <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    2514:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    2516:	f1a0 0202 	sub.w	r2, r0, #2
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    251a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    251e:	bf14      	ite	ne
    2520:	2700      	movne	r7, #0
    2522:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    2526:	2a02      	cmp	r2, #2
    2528:	d901      	bls.n	252e <usb_config_rx+0x1a>
    252a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    252e:	ea4f 19c0 	mov.w	r9, r0, lsl #7
    2532:	f8df a040 	ldr.w	sl, [pc, #64]	; 2574 <usb_config_rx+0x60>
    2536:	460d      	mov	r5, r1
    2538:	4604      	mov	r4, r0
    253a:	eb0a 0609 	add.w	r6, sl, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    253e:	2100      	movs	r1, #0
    2540:	2240      	movs	r2, #64	; 0x40
    2542:	4698      	mov	r8, r3
    2544:	4630      	mov	r0, r6
    2546:	f004 fc2b 	bl	6da0 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    254a:	2001      	movs	r0, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    254c:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
    2550:	f84a 1009 	str.w	r1, [sl, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    2554:	f8c6 8038 	str.w	r8, [r6, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    2558:	60b0      	str	r0, [r6, #8]
void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
    255a:	f1b8 0f00 	cmp.w	r8, #0
    255e:	d0e4      	beq.n	252a <usb_config_rx+0x16>
    2560:	4b03      	ldr	r3, [pc, #12]	; (2570 <usb_config_rx+0x5c>)
    2562:	40a0      	lsls	r0, r4
    2564:	681c      	ldr	r4, [r3, #0]
    2566:	4320      	orrs	r0, r4
    2568:	6018      	str	r0, [r3, #0]
    256a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    256e:	bf00      	nop
    2570:	200026f4 	.word	0x200026f4
    2574:	20000000 	.word	0x20000000

00002578 <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    2578:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    257a:	f1a0 0202 	sub.w	r2, r0, #2
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    257e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    2582:	bf14      	ite	ne
    2584:	2700      	movne	r7, #0
    2586:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    258a:	2a02      	cmp	r2, #2
    258c:	d901      	bls.n	2592 <usb_config_tx+0x1a>
    258e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    2592:	2240      	movs	r2, #64	; 0x40

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    2594:	01c5      	lsls	r5, r0, #7
    2596:	f8df 9044 	ldr.w	r9, [pc, #68]	; 25dc <usb_config_tx+0x64>
    259a:	4688      	mov	r8, r1
    259c:	4415      	add	r5, r2
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    259e:	2100      	movs	r1, #0
    25a0:	4604      	mov	r4, r0
    25a2:	461e      	mov	r6, r3

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    25a4:	eb09 0a05 	add.w	sl, r9, r5
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    25a8:	4650      	mov	r0, sl
    25aa:	f004 fbf9 	bl	6da0 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    25ae:	2201      	movs	r2, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    25b0:	ea47 4108 	orr.w	r1, r7, r8, lsl #16
    25b4:	f849 1005 	str.w	r1, [r9, r5]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    25b8:	f8ca 6038 	str.w	r6, [sl, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    25bc:	f8ca 2008 	str.w	r2, [sl, #8]
void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    25c0:	2e00      	cmp	r6, #0
    25c2:	d0e4      	beq.n	258e <usb_config_tx+0x16>
    25c4:	f104 0010 	add.w	r0, r4, #16
    25c8:	4b03      	ldr	r3, [pc, #12]	; (25d8 <usb_config_tx+0x60>)
    25ca:	4082      	lsls	r2, r0
    25cc:	6818      	ldr	r0, [r3, #0]
    25ce:	4302      	orrs	r2, r0
    25d0:	601a      	str	r2, [r3, #0]
    25d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    25d6:	bf00      	nop
    25d8:	200026f4 	.word	0x200026f4
    25dc:	20000000 	.word	0x20000000

000025e0 <usb_prepare_transfer>:


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    25e0:	0412      	lsls	r2, r2, #16
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
    25e2:	6081      	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
	transfer->pointer2 = addr + 8192;
	transfer->pointer3 = addr + 12288;
	transfer->pointer4 = addr + 16384;
	transfer->callback_param = param;
    25e4:	61c3      	str	r3, [r0, #28]


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    25e6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
    25ea:	b4f0      	push	{r4, r5, r6, r7}
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    25ec:	6042      	str	r2, [r0, #4]



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    25ee:	2701      	movs	r7, #1
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    25f0:	f501 5680 	add.w	r6, r1, #4096	; 0x1000
	transfer->pointer2 = addr + 8192;
    25f4:	f501 5500 	add.w	r5, r1, #8192	; 0x2000
	transfer->pointer3 = addr + 12288;
    25f8:	f501 5440 	add.w	r4, r1, #12288	; 0x3000
	transfer->pointer4 = addr + 16384;
    25fc:	f501 4280 	add.w	r2, r1, #16384	; 0x4000



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    2600:	6007      	str	r7, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    2602:	60c6      	str	r6, [r0, #12]
	transfer->pointer2 = addr + 8192;
    2604:	6105      	str	r5, [r0, #16]
	transfer->pointer3 = addr + 12288;
    2606:	6144      	str	r4, [r0, #20]
	transfer->pointer4 = addr + 16384;
    2608:	6182      	str	r2, [r0, #24]
	transfer->callback_param = param;
}
    260a:	bcf0      	pop	{r4, r5, r6, r7}
    260c:	4770      	bx	lr
    260e:	bf00      	nop

00002610 <usb_transmit>:
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    2610:	1e83      	subs	r3, r0, #2
    2612:	2b02      	cmp	r3, #2
    2614:	d900      	bls.n	2618 <usb_transmit+0x8>
    2616:	4770      	bx	lr
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    2618:	4b06      	ldr	r3, [pc, #24]	; (2634 <usb_transmit+0x24>)
    261a:	460a      	mov	r2, r1
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
    261c:	b430      	push	{r4, r5}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    261e:	f100 0410 	add.w	r4, r0, #16
    2622:	2501      	movs	r5, #1
    2624:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    2628:	fa05 f104 	lsl.w	r1, r5, r4
    262c:	3040      	adds	r0, #64	; 0x40
}
    262e:	bc30      	pop	{r4, r5}
void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    2630:	f7ff bbb0 	b.w	1d94 <schedule_transfer>
    2634:	20000000 	.word	0x20000000

00002638 <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    2638:	1e83      	subs	r3, r0, #2
    263a:	2b02      	cmp	r3, #2
    263c:	d900      	bls.n	2640 <usb_receive+0x8>
    263e:	4770      	bx	lr
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
    2640:	b410      	push	{r4}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    2642:	4b05      	ldr	r3, [pc, #20]	; (2658 <usb_receive+0x20>)
    2644:	2401      	movs	r4, #1
    2646:	460a      	mov	r2, r1
    2648:	fa04 f100 	lsl.w	r1, r4, r0
    264c:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
}
    2650:	f85d 4b04 	ldr.w	r4, [sp], #4
void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    2654:	f7ff bb9e 	b.w	1d94 <schedule_transfer>
    2658:	20000000 	.word	0x20000000

0000265c <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    265c:	6840      	ldr	r0, [r0, #4]
#endif
}
    265e:	4770      	bx	lr

00002660 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    2660:	4a12      	ldr	r2, [pc, #72]	; (26ac <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    2662:	4b13      	ldr	r3, [pc, #76]	; (26b0 <usb_init_serialnumber+0x50>)
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    2664:	f8d2 0220 	ldr.w	r0, [r2, #544]	; 0x220
    2668:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    266c:	4298      	cmp	r0, r3
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    266e:	b510      	push	{r4, lr}
    2670:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    2672:	d802      	bhi.n	267a <usb_init_serialnumber+0x1a>
    2674:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    2678:	0040      	lsls	r0, r0, #1
    267a:	4c0e      	ldr	r4, [pc, #56]	; (26b4 <usb_init_serialnumber+0x54>)
	ultoa(num, buf, 10);
    267c:	a901      	add	r1, sp, #4
    267e:	220a      	movs	r2, #10
    2680:	f7ff f868 	bl	1754 <ultoa>
    2684:	a901      	add	r1, sp, #4
	for (i=0; i<10; i++) {
    2686:	2300      	movs	r3, #0
    2688:	4620      	mov	r0, r4
		char c = buf[i];
    268a:	f811 2b01 	ldrb.w	r2, [r1], #1
    268e:	3301      	adds	r3, #1
		if (!c) break;
    2690:	b13a      	cbz	r2, 26a2 <usb_init_serialnumber+0x42>

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    2692:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    2694:	f820 2f02 	strh.w	r2, [r0, #2]!

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    2698:	d1f7      	bne.n	268a <usb_init_serialnumber+0x2a>
    269a:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    269c:	7023      	strb	r3, [r4, #0]
}
    269e:	b004      	add	sp, #16
    26a0:	bd10      	pop	{r4, pc}
    26a2:	005b      	lsls	r3, r3, #1
    26a4:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    26a6:	7023      	strb	r3, [r4, #0]
}
    26a8:	b004      	add	sp, #16
    26aa:	bd10      	pop	{r4, pc}
    26ac:	401f4400 	.word	0x401f4400
    26b0:	0098967f 	.word	0x0098967f
    26b4:	20001f48 	.word	0x20001f48

000026b8 <rx_event>:
static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    26b8:	4a0a      	ldr	r2, [pc, #40]	; (26e4 <rx_event+0x2c>)
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
    26ba:	b410      	push	{r4}
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    26bc:	7813      	ldrb	r3, [r2, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
    26be:	69c4      	ldr	r4, [r0, #28]
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    26c0:	3301      	adds	r3, #1
    26c2:	2b04      	cmp	r3, #4
    26c4:	d907      	bls.n	26d6 <rx_event+0x1e>
    26c6:	2100      	movs	r1, #0
	rx_list[head] = i;
    26c8:	4807      	ldr	r0, [pc, #28]	; (26e8 <rx_event+0x30>)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    26ca:	460b      	mov	r3, r1
	rx_list[head] = i;
	rx_head = head;
    26cc:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    26ce:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    26d0:	f85d 4b04 	ldr.w	r4, [sp], #4
    26d4:	4770      	bx	lr
    26d6:	b2d9      	uxtb	r1, r3
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    26d8:	4803      	ldr	r0, [pc, #12]	; (26e8 <rx_event+0x30>)
	rx_head = head;
    26da:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    26dc:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    26de:	f85d 4b04 	ldr.w	r4, [sp], #4
    26e2:	4770      	bx	lr
    26e4:	20002753 	.word	0x20002753
    26e8:	20002714 	.word	0x20002714

000026ec <rx_queue_transfer>:
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
    26ec:	4912      	ldr	r1, [pc, #72]	; (2738 <rx_queue_transfer+0x4c>)
    26ee:	eb01 1180 	add.w	r1, r1, r0, lsl #6
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    26f2:	b538      	push	{r3, r4, r5, lr}
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    26f4:	f021 021f 	bic.w	r2, r1, #31
    26f8:	4603      	mov	r3, r0
	uint32_t end_addr = (uint32_t)addr + size;
    26fa:	f101 0540 	add.w	r5, r1, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    26fe:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    2702:	4c0e      	ldr	r4, [pc, #56]	; (273c <rx_queue_transfer+0x50>)
    2704:	6022      	str	r2, [r4, #0]
		location += 32;
    2706:	3220      	adds	r2, #32
	} while (location < end_addr);
    2708:	4295      	cmp	r5, r2
    270a:	d8fb      	bhi.n	2704 <rx_queue_transfer+0x18>
	asm("dsb");
    270c:	f3bf 8f4f 	dsb	sy
	asm("isb");
    2710:	f3bf 8f6f 	isb	sy
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    2714:	4c0a      	ldr	r4, [pc, #40]	; (2740 <rx_queue_transfer+0x54>)
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    2716:	f44f 3500 	mov.w	r5, #131072	; 0x20000
    271a:	4a0a      	ldr	r2, [pc, #40]	; (2744 <rx_queue_transfer+0x58>)
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    271c:	eb04 1443 	add.w	r4, r4, r3, lsl #5
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    2720:	6015      	str	r5, [r2, #0]
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    2722:	2240      	movs	r2, #64	; 0x40
    2724:	4620      	mov	r0, r4
    2726:	f7ff ff5b 	bl	25e0 <usb_prepare_transfer>
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
    272a:	4621      	mov	r1, r4
    272c:	2004      	movs	r0, #4
    272e:	f7ff ff83 	bl	2638 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    2732:	4b05      	ldr	r3, [pc, #20]	; (2748 <rx_queue_transfer+0x5c>)
    2734:	601d      	str	r5, [r3, #0]
    2736:	bd38      	pop	{r3, r4, r5, pc}
    2738:	20200060 	.word	0x20200060
    273c:	e000ef5c 	.word	0xe000ef5c
    2740:	200022e0 	.word	0x200022e0
    2744:	e000e18c 	.word	0xe000e18c
    2748:	e000e10c 	.word	0xe000e10c

0000274c <usb_rawhid_configure>:


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    274c:	2100      	movs	r1, #0
    274e:	4816      	ldr	r0, [pc, #88]	; (27a8 <usb_rawhid_configure+0x5c>)
static void rx_event(transfer_t *t);
extern volatile uint8_t usb_configuration;


void usb_rawhid_configure(void)
{
    2750:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    2752:	2580      	movs	r5, #128	; 0x80
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    2754:	460c      	mov	r4, r1
	rx_head = 0;
    2756:	4f15      	ldr	r7, [pc, #84]	; (27ac <usb_rawhid_configure+0x60>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    2758:	462a      	mov	r2, r5
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    275a:	4e15      	ldr	r6, [pc, #84]	; (27b0 <usb_rawhid_configure+0x64>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    275c:	f004 fb20 	bl	6da0 <memset>
	memset(rx_transfer, 0, sizeof(rx_transfer));
    2760:	462a      	mov	r2, r5
    2762:	4621      	mov	r1, r4
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
    2764:	4d13      	ldr	r5, [pc, #76]	; (27b4 <usb_rawhid_configure+0x68>)

void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
    2766:	4814      	ldr	r0, [pc, #80]	; (27b8 <usb_rawhid_configure+0x6c>)
    2768:	f004 fb1a 	bl	6da0 <memset>
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    276c:	4623      	mov	r3, r4
    276e:	4622      	mov	r2, r4
    2770:	2140      	movs	r1, #64	; 0x40
    2772:	2003      	movs	r0, #3
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
	rx_head = 0;
    2774:	703c      	strb	r4, [r7, #0]
void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    2776:	7034      	strb	r4, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
    2778:	702c      	strb	r4, [r5, #0]
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    277a:	f7ff fefd 	bl	2578 <usb_config_tx>
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
    277e:	4622      	mov	r2, r4
    2780:	4b0e      	ldr	r3, [pc, #56]	; (27bc <usb_rawhid_configure+0x70>)
    2782:	2140      	movs	r1, #64	; 0x40
    2784:	2004      	movs	r0, #4
    2786:	f7ff fec5 	bl	2514 <usb_config_rx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    278a:	4620      	mov	r0, r4
    278c:	f7ff ffae 	bl	26ec <rx_queue_transfer>
    2790:	2001      	movs	r0, #1
    2792:	f7ff ffab 	bl	26ec <rx_queue_transfer>
    2796:	2002      	movs	r0, #2
    2798:	f7ff ffa8 	bl	26ec <rx_queue_transfer>
    279c:	2003      	movs	r0, #3
}
    279e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    27a2:	f7ff bfa3 	b.w	26ec <rx_queue_transfer>
    27a6:	bf00      	nop
    27a8:	20002460 	.word	0x20002460
    27ac:	20002753 	.word	0x20002753
    27b0:	20002759 	.word	0x20002759
    27b4:	20002755 	.word	0x20002755
    27b8:	200022e0 	.word	0x200022e0
    27bc:	000026b9 	.word	0x000026b9

000027c0 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    27c0:	b570      	push	{r4, r5, r6, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    27c2:	0141      	lsls	r1, r0, #5
    27c4:	4c12      	ldr	r4, [pc, #72]	; (2810 <rx_queue_transfer+0x50>)
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    27c6:	4d13      	ldr	r5, [pc, #76]	; (2814 <rx_queue_transfer+0x54>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    27c8:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    27ca:	440c      	add	r4, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    27cc:	f44f 3600 	mov.w	r6, #131072	; 0x20000
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    27d0:	440d      	add	r5, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    27d2:	4811      	ldr	r0, [pc, #68]	; (2818 <rx_queue_transfer+0x58>)
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    27d4:	4621      	mov	r1, r4
    27d6:	2220      	movs	r2, #32
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    27d8:	6006      	str	r6, [r0, #0]
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    27da:	4628      	mov	r0, r5
    27dc:	f7ff ff00 	bl	25e0 <usb_prepare_transfer>
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    27e0:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    27e4:	f104 0120 	add.w	r1, r4, #32
	asm volatile("": : :"memory");
	asm("dsb");
    27e8:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    27ec:	4a0b      	ldr	r2, [pc, #44]	; (281c <rx_queue_transfer+0x5c>)
    27ee:	6013      	str	r3, [r2, #0]
		location += 32;
    27f0:	3320      	adds	r3, #32
	} while (location < end_addr);
    27f2:	4299      	cmp	r1, r3
    27f4:	d8fb      	bhi.n	27ee <rx_queue_transfer+0x2e>
	asm("dsb");
    27f6:	f3bf 8f4f 	dsb	sy
	asm("isb");
    27fa:	f3bf 8f6f 	isb	sy
	arm_dcache_delete(buffer, SEREMU_RX_SIZE);
	usb_receive(SEREMU_RX_ENDPOINT, rx_transfer + i);
    27fe:	2002      	movs	r0, #2
    2800:	4629      	mov	r1, r5
    2802:	f7ff ff19 	bl	2638 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    2806:	4b06      	ldr	r3, [pc, #24]	; (2820 <rx_queue_transfer+0x60>)
    2808:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    280c:	601a      	str	r2, [r3, #0]
    280e:	bd70      	pop	{r4, r5, r6, pc}
    2810:	20200260 	.word	0x20200260
    2814:	20002360 	.word	0x20002360
    2818:	e000e18c 	.word	0xe000e18c
    281c:	e000ef5c 	.word	0xe000ef5c
    2820:	e000e10c 	.word	0xe000e10c

00002824 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
    2824:	6843      	ldr	r3, [r0, #4]
	int i = t->callback_param;
    2826:	69c0      	ldr	r0, [r0, #28]
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    2828:	f3c3 430e 	ubfx	r3, r3, #16, #15
    282c:	b10b      	cbz	r3, 2832 <rx_event+0xe>
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
    282e:	f7ff bfc7 	b.w	27c0 <rx_queue_transfer>
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    2832:	490d      	ldr	r1, [pc, #52]	; (2868 <rx_event+0x44>)
    2834:	0142      	lsls	r2, r0, #5
    2836:	5c8a      	ldrb	r2, [r1, r2]
    2838:	2a00      	cmp	r2, #0
    283a:	d0f8      	beq.n	282e <rx_event+0xa>
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
    283c:	490b      	ldr	r1, [pc, #44]	; (286c <rx_event+0x48>)
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
    283e:	b410      	push	{r4}
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    2840:	4c0b      	ldr	r4, [pc, #44]	; (2870 <rx_event+0x4c>)
		rx_index[i] = 0;
    2842:	f821 3010 	strh.w	r3, [r1, r0, lsl #1]
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    2846:	7822      	ldrb	r2, [r4, #0]
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
    2848:	490a      	ldr	r1, [pc, #40]	; (2874 <rx_event+0x50>)
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    284a:	3201      	adds	r2, #1
    284c:	2a08      	cmp	r2, #8
    284e:	bf94      	ite	ls
    2850:	b2d3      	uxtbls	r3, r2
    2852:	461a      	movhi	r2, r3
		rx_list[head] = i;
		rx_head = head;
    2854:	7023      	strb	r3, [r4, #0]
		rx_available += len;
    2856:	680b      	ldr	r3, [r1, #0]
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    2858:	4c07      	ldr	r4, [pc, #28]	; (2878 <rx_event+0x54>)
		rx_head = head;
		rx_available += len;
    285a:	3320      	adds	r3, #32
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    285c:	54a0      	strb	r0, [r4, r2]
		rx_head = head;
		rx_available += len;
    285e:	600b      	str	r3, [r1, #0]
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
	}
}
    2860:	f85d 4b04 	ldr.w	r4, [sp], #4
    2864:	4770      	bx	lr
    2866:	bf00      	nop
    2868:	20200260 	.word	0x20200260
    286c:	20002704 	.word	0x20002704
    2870:	20002754 	.word	0x20002754
    2874:	20002700 	.word	0x20002700
    2878:	2000271c 	.word	0x2000271c

0000287c <usb_seremu_configure>:


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    287c:	2100      	movs	r1, #0
    287e:	f44f 72c0 	mov.w	r2, #384	; 0x180
    2882:	481f      	ldr	r0, [pc, #124]	; (2900 <usb_seremu_configure+0x84>)
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_seremu_configure(void)
{
    2884:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    2886:	460d      	mov	r5, r1
    2888:	4c1e      	ldr	r4, [pc, #120]	; (2904 <usb_seremu_configure+0x88>)


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    288a:	f004 fa89 	bl	6da0 <memset>
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    288e:	4e1e      	ldr	r6, [pc, #120]	; (2908 <usb_seremu_configure+0x8c>)
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    2890:	4b1e      	ldr	r3, [pc, #120]	; (290c <usb_seremu_configure+0x90>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    2892:	4629      	mov	r1, r5
    2894:	f44f 7280 	mov.w	r2, #256	; 0x100
    2898:	481d      	ldr	r0, [pc, #116]	; (2910 <usb_seremu_configure+0x94>)

void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    289a:	7025      	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    289c:	462c      	mov	r4, r5
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    289e:	801d      	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    28a0:	f004 fa7e 	bl	6da0 <memset>
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    28a4:	7035      	strb	r5, [r6, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    28a6:	462a      	mov	r2, r5
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    28a8:	4e1a      	ldr	r6, [pc, #104]	; (2914 <usb_seremu_configure+0x98>)
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    28aa:	2120      	movs	r1, #32
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    28ac:	4b1a      	ldr	r3, [pc, #104]	; (2918 <usb_seremu_configure+0x9c>)
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    28ae:	2002      	movs	r0, #2
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    28b0:	4f1a      	ldr	r7, [pc, #104]	; (291c <usb_seremu_configure+0xa0>)
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    28b2:	701d      	strb	r5, [r3, #0]
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    28b4:	6035      	str	r5, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    28b6:	4b1a      	ldr	r3, [pc, #104]	; (2920 <usb_seremu_configure+0xa4>)
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    28b8:	6075      	str	r5, [r6, #4]
    28ba:	60b5      	str	r5, [r6, #8]
    28bc:	60f5      	str	r5, [r6, #12]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    28be:	603d      	str	r5, [r7, #0]
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    28c0:	f7ff fe28 	bl	2514 <usb_config_rx>
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
    28c4:	462b      	mov	r3, r5
    28c6:	462a      	mov	r2, r5
    28c8:	2140      	movs	r1, #64	; 0x40
    28ca:	2002      	movs	r0, #2
    28cc:	f7ff fe54 	bl	2578 <usb_config_tx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    28d0:	4620      	mov	r0, r4
    28d2:	3401      	adds	r4, #1
    28d4:	f7ff ff74 	bl	27c0 <rx_queue_transfer>
    28d8:	2c08      	cmp	r4, #8
    28da:	d1f9      	bne.n	28d0 <usb_seremu_configure+0x54>
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
	USB1_GPTIMER0CTRL = 0;
    28dc:	4b11      	ldr	r3, [pc, #68]	; (2924 <usb_seremu_configure+0xa8>)
	USB1_GPTIMER0LD = microseconds - 1;
    28de:	224a      	movs	r2, #74	; 0x4a
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    28e0:	4811      	ldr	r0, [pc, #68]	; (2928 <usb_seremu_configure+0xac>)
	USB1_GPTIMER0CTRL = 0;
    28e2:	2100      	movs	r1, #0
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    28e4:	4c11      	ldr	r4, [pc, #68]	; (292c <usb_seremu_configure+0xb0>)
    28e6:	6004      	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    28e8:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    28ec:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    28f0:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    28f4:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    28f8:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    28fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    28fe:	bf00      	nop
    2900:	200024e0 	.word	0x200024e0
    2904:	2000275a 	.word	0x2000275a
    2908:	20002754 	.word	0x20002754
    290c:	2000274c 	.word	0x2000274c
    2910:	20002360 	.word	0x20002360
    2914:	20002704 	.word	0x20002704
    2918:	20002756 	.word	0x20002756
    291c:	20002700 	.word	0x20002700
    2920:	00002825 	.word	0x00002825
    2924:	402e0000 	.word	0x402e0000
    2928:	20002744 	.word	0x20002744
    292c:	00002a99 	.word	0x00002a99

00002930 <usb_seremu_getchar>:
	}
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
    2930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t tail = rx_tail;
    2932:	4d14      	ldr	r5, [pc, #80]	; (2984 <usb_seremu_getchar+0x54>)

	if (tail == rx_head) return -1;
    2934:	4a14      	ldr	r2, [pc, #80]	; (2988 <usb_seremu_getchar+0x58>)
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    2936:	782b      	ldrb	r3, [r5, #0]

	if (tail == rx_head) return -1;
    2938:	7812      	ldrb	r2, [r2, #0]
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    293a:	b2db      	uxtb	r3, r3

	if (tail == rx_head) return -1;
    293c:	4293      	cmp	r3, r2
    293e:	d01d      	beq.n	297c <usb_seremu_getchar+0x4c>
	if (++tail > RX_NUM) tail = 0;
    2940:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    2942:	4a12      	ldr	r2, [pc, #72]	; (298c <usb_seremu_getchar+0x5c>)
	uint32_t index = rx_index[i];
    2944:	4e12      	ldr	r6, [pc, #72]	; (2990 <usb_seremu_getchar+0x60>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    2946:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    2948:	4c12      	ldr	r4, [pc, #72]	; (2994 <usb_seremu_getchar+0x64>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    294a:	bf28      	it	cs
    294c:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    294e:	5cd0      	ldrb	r0, [r2, r3]
	uint32_t index = rx_index[i];
    2950:	f836 2010 	ldrh.w	r2, [r6, r0, lsl #1]
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    2954:	eb02 1140 	add.w	r1, r2, r0, lsl #5
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    2958:	3201      	adds	r2, #1
    295a:	2a1f      	cmp	r2, #31

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    295c:	eb04 0701 	add.w	r7, r4, r1
	int c = *p;
    2960:	5c64      	ldrb	r4, [r4, r1]
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    2962:	d805      	bhi.n	2970 <usb_seremu_getchar+0x40>
    2964:	7879      	ldrb	r1, [r7, #1]
    2966:	b119      	cbz	r1, 2970 <usb_seremu_getchar+0x40>
		rx_tail = tail;
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
    2968:	f826 2010 	strh.w	r2, [r6, r0, lsl #1]
	}
	return c;
    296c:	4620      	mov	r0, r4
    296e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
    2970:	b2db      	uxtb	r3, r3
    2972:	702b      	strb	r3, [r5, #0]
		rx_queue_transfer(i);
    2974:	f7ff ff24 	bl	27c0 <rx_queue_transfer>
	} else {
		rx_index[i] = index;
	}
	return c;
    2978:	4620      	mov	r0, r4
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
		rx_queue_transfer(i);
    297a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
    297c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
	}
	return c;
}
    2980:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2982:	bf00      	nop
    2984:	20002756 	.word	0x20002756
    2988:	20002754 	.word	0x20002754
    298c:	2000271c 	.word	0x2000271c
    2990:	20002704 	.word	0x20002704
    2994:	20200260 	.word	0x20200260

00002998 <usb_seremu_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    2998:	4b0b      	ldr	r3, [pc, #44]	; (29c8 <usb_seremu_peekchar+0x30>)
	if (tail == rx_head) return -1;
    299a:	4a0c      	ldr	r2, [pc, #48]	; (29cc <usb_seremu_peekchar+0x34>)
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    299c:	781b      	ldrb	r3, [r3, #0]
	if (tail == rx_head) return -1;
    299e:	7812      	ldrb	r2, [r2, #0]
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    29a0:	b2db      	uxtb	r3, r3
	if (tail == rx_head) return -1;
    29a2:	4293      	cmp	r3, r2
    29a4:	d00d      	beq.n	29c2 <usb_seremu_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    29a6:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    29a8:	4a09      	ldr	r2, [pc, #36]	; (29d0 <usb_seremu_peekchar+0x38>)
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    29aa:	480a      	ldr	r0, [pc, #40]	; (29d4 <usb_seremu_peekchar+0x3c>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    29ac:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    29ae:	490a      	ldr	r1, [pc, #40]	; (29d8 <usb_seremu_peekchar+0x40>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    29b0:	bf28      	it	cs
    29b2:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    29b4:	5cd2      	ldrb	r2, [r2, r3]
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    29b6:	f830 3012 	ldrh.w	r3, [r0, r2, lsl #1]
    29ba:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    29be:	5cc8      	ldrb	r0, [r1, r3]
    29c0:	4770      	bx	lr

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
    29c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
}
    29c6:	4770      	bx	lr
    29c8:	20002756 	.word	0x20002756
    29cc:	20002754 	.word	0x20002754
    29d0:	2000271c 	.word	0x2000271c
    29d4:	20002704 	.word	0x20002704
    29d8:	20200260 	.word	0x20200260

000029dc <usb_seremu_available>:

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
    29dc:	b508      	push	{r3, lr}
	uint32_t tail = rx_tail;
    29de:	4a06      	ldr	r2, [pc, #24]	; (29f8 <usb_seremu_available+0x1c>)
	if (tail == rx_head) {
    29e0:	4b06      	ldr	r3, [pc, #24]	; (29fc <usb_seremu_available+0x20>)
}

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
    29e2:	7812      	ldrb	r2, [r2, #0]
	if (tail == rx_head) {
    29e4:	781b      	ldrb	r3, [r3, #0]
    29e6:	429a      	cmp	r2, r3
    29e8:	d001      	beq.n	29ee <usb_seremu_available+0x12>
		yield();
		return 0;
	}
	// TODO: how much is actually available?
	return 1;
    29ea:	2001      	movs	r0, #1
}
    29ec:	bd08      	pop	{r3, pc}
// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) {
		yield();
    29ee:	f000 fb2d 	bl	304c <yield>
		return 0;
    29f2:	2000      	movs	r0, #0
    29f4:	bd08      	pop	{r3, pc}
    29f6:	bf00      	nop
    29f8:	20002756 	.word	0x20002756
    29fc:	20002754 	.word	0x20002754

00002a00 <tx_zero_pad>:
	USB1_GPTIMER0CTRL = 0;
}


void tx_zero_pad(void)
{
    2a00:	b538      	push	{r3, r4, r5, lr}
	if (!tx_available) return;
    2a02:	4c08      	ldr	r4, [pc, #32]	; (2a24 <tx_zero_pad+0x24>)
    2a04:	8822      	ldrh	r2, [r4, #0]
    2a06:	b162      	cbz	r2, 2a22 <tx_zero_pad+0x22>
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    2a08:	4907      	ldr	r1, [pc, #28]	; (2a28 <tx_zero_pad+0x28>)
	memset(txdata, 0, tx_available);
    2a0a:	f1c2 0340 	rsb	r3, r2, #64	; 0x40
    2a0e:	4807      	ldr	r0, [pc, #28]	; (2a2c <tx_zero_pad+0x2c>)


void tx_zero_pad(void)
{
	if (!tx_available) return;
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    2a10:	780d      	ldrb	r5, [r1, #0]
	memset(txdata, 0, tx_available);
    2a12:	2100      	movs	r1, #0
    2a14:	eb03 1385 	add.w	r3, r3, r5, lsl #6
    2a18:	4418      	add	r0, r3
    2a1a:	f004 f9c1 	bl	6da0 <memset>
	tx_available = 0;
    2a1e:	2300      	movs	r3, #0
    2a20:	8023      	strh	r3, [r4, #0]
    2a22:	bd38      	pop	{r3, r4, r5, pc}
    2a24:	2000274c 	.word	0x2000274c
    2a28:	2000275a 	.word	0x2000275a
    2a2c:	20200360 	.word	0x20200360

00002a30 <tx_queue_transfer>:
}

void tx_queue_transfer(void)
{
    2a30:	b570      	push	{r4, r5, r6, lr}
	transfer_t *xfer = tx_transfer + tx_head;
    2a32:	4e15      	ldr	r6, [pc, #84]	; (2a88 <tx_queue_transfer+0x58>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    2a34:	2300      	movs	r3, #0
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    2a36:	4d15      	ldr	r5, [pc, #84]	; (2a8c <tx_queue_transfer+0x5c>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    2a38:	2240      	movs	r2, #64	; 0x40
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    2a3a:	7831      	ldrb	r1, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    2a3c:	4c14      	ldr	r4, [pc, #80]	; (2a90 <tx_queue_transfer+0x60>)
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    2a3e:	eb05 1541 	add.w	r5, r5, r1, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    2a42:	eb04 1481 	add.w	r4, r4, r1, lsl #6
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    2a46:	4628      	mov	r0, r5
    2a48:	4621      	mov	r1, r4
    2a4a:	f7ff fdc9 	bl	25e0 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    2a4e:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    2a52:	f104 0140 	add.w	r1, r4, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    2a56:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    2a5a:	4a0e      	ldr	r2, [pc, #56]	; (2a94 <tx_queue_transfer+0x64>)
    2a5c:	6013      	str	r3, [r2, #0]
		location += 32;
    2a5e:	3320      	adds	r3, #32
	} while (location < end_addr);
    2a60:	4299      	cmp	r1, r3
    2a62:	d8fb      	bhi.n	2a5c <tx_queue_transfer+0x2c>
	asm("dsb");
    2a64:	f3bf 8f4f 	dsb	sy
	asm("isb");
    2a68:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
    2a6c:	2002      	movs	r0, #2
    2a6e:	4629      	mov	r1, r5
    2a70:	f7ff fdce 	bl	2610 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    2a74:	7833      	ldrb	r3, [r6, #0]
    2a76:	4a04      	ldr	r2, [pc, #16]	; (2a88 <tx_queue_transfer+0x58>)
    2a78:	3301      	adds	r3, #1
    2a7a:	b2db      	uxtb	r3, r3
    2a7c:	2b0b      	cmp	r3, #11
    2a7e:	bf88      	it	hi
    2a80:	2300      	movhi	r3, #0
    2a82:	7013      	strb	r3, [r2, #0]
    2a84:	bd70      	pop	{r4, r5, r6, pc}
    2a86:	bf00      	nop
    2a88:	2000275a 	.word	0x2000275a
    2a8c:	200024e0 	.word	0x200024e0
    2a90:	20200360 	.word	0x20200360
    2a94:	e000ef70 	.word	0xe000ef70

00002a98 <usb_seremu_flush_callback>:
	timer_stop();
	tx_noautoflush = 0;
}

static void usb_seremu_flush_callback(void)
{
    2a98:	b508      	push	{r3, lr}
	if (tx_noautoflush) return;
    2a9a:	4b08      	ldr	r3, [pc, #32]	; (2abc <usb_seremu_flush_callback+0x24>)
    2a9c:	781b      	ldrb	r3, [r3, #0]
    2a9e:	b92b      	cbnz	r3, 2aac <usb_seremu_flush_callback+0x14>
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
    2aa0:	4b07      	ldr	r3, [pc, #28]	; (2ac0 <usb_seremu_flush_callback+0x28>)
    2aa2:	881b      	ldrh	r3, [r3, #0]
    2aa4:	3b01      	subs	r3, #1
    2aa6:	b29b      	uxth	r3, r3
    2aa8:	2b3e      	cmp	r3, #62	; 0x3e
    2aaa:	d900      	bls.n	2aae <usb_seremu_flush_callback+0x16>
    2aac:	bd08      	pop	{r3, pc}
	tx_zero_pad();
    2aae:	f7ff ffa7 	bl	2a00 <tx_zero_pad>
	tx_queue_transfer();
}
    2ab2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
static void usb_seremu_flush_callback(void)
{
	if (tx_noautoflush) return;
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
	tx_zero_pad();
	tx_queue_transfer();
    2ab6:	f7ff bfbb 	b.w	2a30 <tx_queue_transfer>
    2aba:	bf00      	nop
    2abc:	2000275b 	.word	0x2000275b
    2ac0:	2000274c 	.word	0x2000274c

00002ac4 <usb_seremu_write.part.1>:
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
	if (++tx_head >= TX_NUM) tx_head = 0;
}

int usb_seremu_write(const void *buffer, uint32_t size)
    2ac4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2ac8:	b085      	sub	sp, #20
    2aca:	9002      	str	r0, [sp, #8]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2acc:	9100      	str	r1, [sp, #0]
    2ace:	2900      	cmp	r1, #0
    2ad0:	f000 8084 	beq.w	2bdc <usb_seremu_write.part.1+0x118>
    2ad4:	2300      	movs	r3, #0
    2ad6:	4f42      	ldr	r7, [pc, #264]	; (2be0 <usb_seremu_write.part.1+0x11c>)
    2ad8:	f8df 8120 	ldr.w	r8, [pc, #288]	; 2bfc <usb_seremu_write.part.1+0x138>
    2adc:	f8df a110 	ldr.w	sl, [pc, #272]	; 2bf0 <usb_seremu_write.part.1+0x12c>
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
    2ae0:	4e40      	ldr	r6, [pc, #256]	; (2be4 <usb_seremu_write.part.1+0x120>)
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    2ae2:	f8df b11c 	ldr.w	fp, [pc, #284]	; 2c00 <usb_seremu_write.part.1+0x13c>
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2ae6:	9301      	str	r3, [sp, #4]
		tx_noautoflush = 1;
    2ae8:	2101      	movs	r1, #1
		transfer_t *xfer = tx_transfer + tx_head;
    2aea:	4b3f      	ldr	r3, [pc, #252]	; (2be8 <usb_seremu_write.part.1+0x124>)
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
    2aec:	7039      	strb	r1, [r7, #0]
		transfer_t *xfer = tx_transfer + tx_head;
    2aee:	781a      	ldrb	r2, [r3, #0]
    2af0:	493e      	ldr	r1, [pc, #248]	; (2bec <usb_seremu_write.part.1+0x128>)
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    2af2:	f8b8 3000 	ldrh.w	r3, [r8]
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
    2af6:	eb01 1942 	add.w	r9, r1, r2, lsl #5
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    2afa:	bb0b      	cbnz	r3, 2b40 <usb_seremu_write.part.1+0x7c>
    2afc:	461d      	mov	r5, r3
    2afe:	461c      	mov	r4, r3
			uint32_t status = usb_transfer_status(xfer);
    2b00:	4648      	mov	r0, r9
    2b02:	f7ff fdab 	bl	265c <usb_transfer_status>
			if (!(status & 0x80)) {
    2b06:	f010 0080 	ands.w	r0, r0, #128	; 0x80
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    2b0a:	f04f 0300 	mov.w	r3, #0
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2b0e:	4938      	ldr	r1, [pc, #224]	; (2bf0 <usb_seremu_write.part.1+0x12c>)
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
			uint32_t status = usb_transfer_status(xfer);
			if (!(status & 0x80)) {
    2b10:	d056      	beq.n	2bc0 <usb_seremu_write.part.1+0xfc>
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2b12:	f89a 2000 	ldrb.w	r2, [sl]
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    2b16:	703b      	strb	r3, [r7, #0]
			if (!waiting) {
    2b18:	b904      	cbnz	r4, 2b1c <usb_seremu_write.part.1+0x58>
				wait_begin_at = systick_millis_count;
    2b1a:	6835      	ldr	r5, [r6, #0]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2b1c:	2a00      	cmp	r2, #0
    2b1e:	d134      	bne.n	2b8a <usb_seremu_write.part.1+0xc6>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    2b20:	6833      	ldr	r3, [r6, #0]
    2b22:	2401      	movs	r4, #1
    2b24:	1b5b      	subs	r3, r3, r5
    2b26:	2b32      	cmp	r3, #50	; 0x32
    2b28:	d853      	bhi.n	2bd2 <usb_seremu_write.part.1+0x10e>
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    2b2a:	f89b 3000 	ldrb.w	r3, [fp]
    2b2e:	b363      	cbz	r3, 2b8a <usb_seremu_write.part.1+0xc6>
			yield();
    2b30:	f000 fa8c 	bl	304c <yield>
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    2b34:	f8b8 3000 	ldrh.w	r3, [r8]
    2b38:	2b00      	cmp	r3, #0
    2b3a:	d0e1      	beq.n	2b00 <usb_seremu_write.part.1+0x3c>
    2b3c:	4a2a      	ldr	r2, [pc, #168]	; (2be8 <usb_seremu_write.part.1+0x124>)
    2b3e:	7812      	ldrb	r2, [r2, #0]
    2b40:	461c      	mov	r4, r3
    2b42:	f1c3 0040 	rsb	r0, r3, #64	; 0x40
				return sent;
			}
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    2b46:	eb00 1082 	add.w	r0, r0, r2, lsl #6
    2b4a:	4a2a      	ldr	r2, [pc, #168]	; (2bf4 <usb_seremu_write.part.1+0x130>)
    2b4c:	4410      	add	r0, r2
		if (size >= tx_available) {
    2b4e:	9a00      	ldr	r2, [sp, #0]
    2b50:	42a2      	cmp	r2, r4
    2b52:	d31e      	bcc.n	2b92 <usb_seremu_write.part.1+0xce>
			memcpy(txdata, data, tx_available);
			size -= tx_available;
    2b54:	9b00      	ldr	r3, [sp, #0]
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    2b56:	2500      	movs	r5, #0
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    2b58:	f8dd 9008 	ldr.w	r9, [sp, #8]
    2b5c:	4622      	mov	r2, r4
			size -= tx_available;
    2b5e:	1b1b      	subs	r3, r3, r4
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    2b60:	4649      	mov	r1, r9
			size -= tx_available;
    2b62:	9300      	str	r3, [sp, #0]
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    2b64:	f004 f81e 	bl	6ba4 <memcpy>
			size -= tx_available;
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    2b68:	f8a8 5000 	strh.w	r5, [r8]
			tx_queue_transfer();
    2b6c:	f7ff ff60 	bl	2a30 <tx_queue_transfer>
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    2b70:	9a01      	ldr	r2, [sp, #4]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    2b72:	4b21      	ldr	r3, [pc, #132]	; (2bf8 <usb_seremu_write.part.1+0x134>)
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    2b74:	4422      	add	r2, r4
    2b76:	9201      	str	r2, [sp, #4]
			data += tx_available;
    2b78:	464a      	mov	r2, r9
    2b7a:	4422      	add	r2, r4
    2b7c:	9202      	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    2b7e:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2b82:	9b00      	ldr	r3, [sp, #0]
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    2b84:	703d      	strb	r5, [r7, #0]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2b86:	2b00      	cmp	r3, #0
    2b88:	d1ae      	bne.n	2ae8 <usb_seremu_write.part.1+0x24>
    2b8a:	9801      	ldr	r0, [sp, #4]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    2b8c:	b005      	add	sp, #20
    2b8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    2b92:	9d00      	ldr	r5, [sp, #0]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2b94:	f04f 4440 	mov.w	r4, #3221225472	; 0xc0000000
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    2b98:	9902      	ldr	r1, [sp, #8]
    2b9a:	462a      	mov	r2, r5
    2b9c:	9303      	str	r3, [sp, #12]
    2b9e:	f004 f801 	bl	6ba4 <memcpy>
			tx_available -= size;
    2ba2:	9b03      	ldr	r3, [sp, #12]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2ba4:	4914      	ldr	r1, [pc, #80]	; (2bf8 <usb_seremu_write.part.1+0x134>)
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    2ba6:	2200      	movs	r2, #0
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
			tx_available -= size;
    2ba8:	1b5b      	subs	r3, r3, r5
    2baa:	f8a8 3000 	strh.w	r3, [r8]
    2bae:	9b01      	ldr	r3, [sp, #4]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2bb0:	f8c1 4084 	str.w	r4, [r1, #132]	; 0x84
    2bb4:	4618      	mov	r0, r3
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    2bb6:	703a      	strb	r2, [r7, #0]
    2bb8:	4428      	add	r0, r5
	}
	return sent;
}
    2bba:	b005      	add	sp, #20
    2bbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    2bc0:	2340      	movs	r3, #64	; 0x40
    2bc2:	4a09      	ldr	r2, [pc, #36]	; (2be8 <usb_seremu_write.part.1+0x124>)
				transmit_previous_timeout = 0;
    2bc4:	f88a 0000 	strb.w	r0, [sl]
    2bc8:	7812      	ldrb	r2, [r2, #0]
    2bca:	461c      	mov	r4, r3
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    2bcc:	f8a8 3000 	strh.w	r3, [r8]
    2bd0:	e7b9      	b.n	2b46 <usb_seremu_write.part.1+0x82>
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
    2bd2:	9801      	ldr	r0, [sp, #4]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    2bd4:	700c      	strb	r4, [r1, #0]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    2bd6:	b005      	add	sp, #20
    2bd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2bdc:	9800      	ldr	r0, [sp, #0]
    2bde:	e7d5      	b.n	2b8c <usb_seremu_write.part.1+0xc8>
    2be0:	2000275b 	.word	0x2000275b
    2be4:	20002740 	.word	0x20002740
    2be8:	2000275a 	.word	0x2000275a
    2bec:	200024e0 	.word	0x200024e0
    2bf0:	20002758 	.word	0x20002758
    2bf4:	20200360 	.word	0x20200360
    2bf8:	402e0000 	.word	0x402e0000
    2bfc:	2000274c 	.word	0x2000274c
    2c00:	2000275c 	.word	0x2000275c

00002c04 <usb_seremu_putchar>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2c04:	4b09      	ldr	r3, [pc, #36]	; (2c2c <usb_seremu_putchar+0x28>)
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    2c06:	b500      	push	{lr}
    2c08:	b083      	sub	sp, #12
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2c0a:	781b      	ldrb	r3, [r3, #0]
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    2c0c:	f88d 0007 	strb.w	r0, [sp, #7]
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2c10:	b923      	cbnz	r3, 2c1c <usb_seremu_putchar+0x18>
    2c12:	f003 00ff 	and.w	r0, r3, #255	; 0xff

// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
	return usb_seremu_write(&c, 1);
}
    2c16:	b003      	add	sp, #12
    2c18:	f85d fb04 	ldr.w	pc, [sp], #4
    2c1c:	2101      	movs	r1, #1
    2c1e:	f10d 0007 	add.w	r0, sp, #7
    2c22:	f7ff ff4f 	bl	2ac4 <usb_seremu_write.part.1>
    2c26:	b003      	add	sp, #12
    2c28:	f85d fb04 	ldr.w	pc, [sp], #4
    2c2c:	2000275c 	.word	0x2000275c

00002c30 <usb_seremu_write>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2c30:	4b04      	ldr	r3, [pc, #16]	; (2c44 <usb_seremu_write+0x14>)
    2c32:	781b      	ldrb	r3, [r3, #0]
    2c34:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    2c38:	b10b      	cbz	r3, 2c3e <usb_seremu_write+0xe>
    2c3a:	f7ff bf43 	b.w	2ac4 <usb_seremu_write.part.1>
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    2c3e:	4610      	mov	r0, r2
    2c40:	4770      	bx	lr
    2c42:	bf00      	nop
    2c44:	2000275c 	.word	0x2000275c

00002c48 <usb_seremu_write_buffer_free>:

int usb_seremu_write_buffer_free(void)
{
	return 1;
}
    2c48:	2001      	movs	r0, #1
    2c4a:	4770      	bx	lr

00002c4c <usb_seremu_flush_output>:

void usb_seremu_flush_output(void)
{
	if (!usb_configuration) return;
    2c4c:	4b0a      	ldr	r3, [pc, #40]	; (2c78 <usb_seremu_flush_output+0x2c>)
    2c4e:	781b      	ldrb	r3, [r3, #0]
    2c50:	b113      	cbz	r3, 2c58 <usb_seremu_flush_output+0xc>
	if (tx_available == 0) return;
    2c52:	4b0a      	ldr	r3, [pc, #40]	; (2c7c <usb_seremu_flush_output+0x30>)
    2c54:	881b      	ldrh	r3, [r3, #0]
    2c56:	b903      	cbnz	r3, 2c5a <usb_seremu_flush_output+0xe>
    2c58:	4770      	bx	lr
{
	return 1;
}

void usb_seremu_flush_output(void)
{
    2c5a:	b510      	push	{r4, lr}
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    2c5c:	2301      	movs	r3, #1
    2c5e:	4c08      	ldr	r4, [pc, #32]	; (2c80 <usb_seremu_flush_output+0x34>)
    2c60:	7023      	strb	r3, [r4, #0]
	tx_zero_pad();
    2c62:	f7ff fecd 	bl	2a00 <tx_zero_pad>
	tx_queue_transfer();
    2c66:	f7ff fee3 	bl	2a30 <tx_queue_transfer>
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    2c6a:	2300      	movs	r3, #0
    2c6c:	4a05      	ldr	r2, [pc, #20]	; (2c84 <usb_seremu_flush_output+0x38>)
    2c6e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	tx_zero_pad();
	tx_queue_transfer();
	timer_stop();
	tx_noautoflush = 0;
    2c72:	7023      	strb	r3, [r4, #0]
    2c74:	bd10      	pop	{r4, pc}
    2c76:	bf00      	nop
    2c78:	2000275c 	.word	0x2000275c
    2c7c:	2000274c 	.word	0x2000274c
    2c80:	2000275b 	.word	0x2000275b
    2c84:	402e0000 	.word	0x402e0000

00002c88 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    2c88:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2c8a:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    2c8e:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2c90:	4c0c      	ldr	r4, [pc, #48]	; (2cc4 <EventResponder::runFromInterrupt()+0x3c>)
    2c92:	6823      	ldr	r3, [r4, #0]
		if (first) {
    2c94:	b18b      	cbz	r3, 2cba <EventResponder::runFromInterrupt()+0x32>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    2c96:	4e0c      	ldr	r6, [pc, #48]	; (2cc8 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    2c98:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    2c9a:	695a      	ldr	r2, [r3, #20]
    2c9c:	6022      	str	r2, [r4, #0]
			if (firstInterrupt) {
    2c9e:	b17a      	cbz	r2, 2cc0 <EventResponder::runFromInterrupt()+0x38>
				firstInterrupt->_prev = nullptr;
    2ca0:	6195      	str	r5, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2ca2:	b901      	cbnz	r1, 2ca6 <EventResponder::runFromInterrupt()+0x1e>
    2ca4:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    2ca6:	775d      	strb	r5, [r3, #29]
			(*(first->_function))(*first);
    2ca8:	4618      	mov	r0, r3
    2caa:	689b      	ldr	r3, [r3, #8]
    2cac:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2cae:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    2cb2:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2cb4:	6823      	ldr	r3, [r4, #0]
		if (first) {
    2cb6:	2b00      	cmp	r3, #0
    2cb8:	d1ef      	bne.n	2c9a <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2cba:	b901      	cbnz	r1, 2cbe <EventResponder::runFromInterrupt()+0x36>
    2cbc:	b662      	cpsie	i
    2cbe:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    2cc0:	6032      	str	r2, [r6, #0]
    2cc2:	e7ee      	b.n	2ca2 <EventResponder::runFromInterrupt()+0x1a>
    2cc4:	2000268c 	.word	0x2000268c
    2cc8:	20002688 	.word	0x20002688

00002ccc <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    2ccc:	f7ff bfdc 	b.w	2c88 <EventResponder::runFromInterrupt()>

00002cd0 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    2cd0:	4a04      	ldr	r2, [pc, #16]	; (2ce4 <systick_isr+0x14>)
    2cd2:	4b05      	ldr	r3, [pc, #20]	; (2ce8 <systick_isr+0x18>)
    2cd4:	6811      	ldr	r1, [r2, #0]
	systick_millis_count++;
    2cd6:	4a05      	ldr	r2, [pc, #20]	; (2cec <systick_isr+0x1c>)
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    2cd8:	6019      	str	r1, [r3, #0]
	systick_millis_count++;
    2cda:	6813      	ldr	r3, [r2, #0]
    2cdc:	3301      	adds	r3, #1
    2cde:	6013      	str	r3, [r2, #0]
    2ce0:	4770      	bx	lr
    2ce2:	bf00      	nop
    2ce4:	e0001004 	.word	0xe0001004
    2ce8:	2000273c 	.word	0x2000273c
    2cec:	20002740 	.word	0x20002740

00002cf0 <IntervalTimer::end()>:
}


void IntervalTimer::end() {
#if 1
	if (channel) {
    2cf0:	6802      	ldr	r2, [r0, #0]
    2cf2:	b30a      	cbz	r2, 2d38 <IntervalTimer::end()+0x48>
		int index = channel - IMXRT_PIT_CHANNELS;
    2cf4:	4b11      	ldr	r3, [pc, #68]	; (2d3c <IntervalTimer::end()+0x4c>)
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2cf6:	4912      	ldr	r1, [pc, #72]	; (2d40 <IntervalTimer::end()+0x50>)


void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    2cf8:	4413      	add	r3, r2
	NVIC_ENABLE_IRQ(IRQ_PIT);
	return true;
}


void IntervalTimer::end() {
    2cfa:	b5f0      	push	{r4, r5, r6, r7, lr}
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    2cfc:	111b      	asrs	r3, r3, #4
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2cfe:	25ff      	movs	r5, #255	; 0xff
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    2d00:	2400      	movs	r4, #0
    2d02:	f8df e044 	ldr.w	lr, [pc, #68]	; 2d48 <IntervalTimer::end()+0x58>
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2d06:	54cd      	strb	r5, [r1, r3]
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    2d08:	780e      	ldrb	r6, [r1, #0]
    2d0a:	784d      	ldrb	r5, [r1, #1]
    2d0c:	2eff      	cmp	r6, #255	; 0xff
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
    2d0e:	6094      	str	r4, [r2, #8]
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    2d10:	f84e 4023 	str.w	r4, [lr, r3, lsl #2]
    2d14:	bf28      	it	cs
    2d16:	26ff      	movcs	r6, #255	; 0xff
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    2d18:	788a      	ldrb	r2, [r1, #2]
    2d1a:	78c9      	ldrb	r1, [r1, #3]
    2d1c:	42ae      	cmp	r6, r5
    2d1e:	4633      	mov	r3, r6
		}
		NVIC_SET_PRIORITY(IRQ_PIT, top_priority);
    2d20:	4f08      	ldr	r7, [pc, #32]	; (2d44 <IntervalTimer::end()+0x54>)
    2d22:	bf28      	it	cs
    2d24:	462b      	movcs	r3, r5
    2d26:	4293      	cmp	r3, r2
    2d28:	bf28      	it	cs
    2d2a:	4613      	movcs	r3, r2
    2d2c:	428b      	cmp	r3, r1
    2d2e:	bf28      	it	cs
    2d30:	460b      	movcs	r3, r1
    2d32:	703b      	strb	r3, [r7, #0]
		channel = 0;
    2d34:	6004      	str	r4, [r0, #0]
    2d36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2d38:	4770      	bx	lr
    2d3a:	bf00      	nop
    2d3c:	bff7bf00 	.word	0xbff7bf00
    2d40:	2000196c 	.word	0x2000196c
    2d44:	e000e47a 	.word	0xe000e47a
    2d48:	200022c0 	.word	0x200022c0

00002d4c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
    2d4c:	2000      	movs	r0, #0
    2d4e:	4770      	bx	lr

00002d50 <Print::print(String const&)>:
	return count;
}


size_t Print::print(const String &s)
{
    2d50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2d54:	688c      	ldr	r4, [r1, #8]
    2d56:	b08b      	sub	sp, #44	; 0x2c
	uint8_t buffer[33];
	size_t count = 0;
	unsigned int index = 0;
	unsigned int len = s.length();
	while (len > 0) {
    2d58:	b1ec      	cbz	r4, 2d96 <Print::print(String const&)+0x46>
    2d5a:	2500      	movs	r5, #0
    2d5c:	4606      	mov	r6, r0
    2d5e:	4689      	mov	r9, r1
    2d60:	462f      	mov	r7, r5
		s.getBytes(buffer, sizeof(buffer), index);
    2d62:	462b      	mov	r3, r5
    2d64:	2221      	movs	r2, #33	; 0x21
    2d66:	a901      	add	r1, sp, #4
    2d68:	4648      	mov	r0, r9
    2d6a:	f000 f93b 	bl	2fe4 <String::getBytes(unsigned char*, unsigned int, unsigned int) const>
    2d6e:	2c20      	cmp	r4, #32
    2d70:	4623      	mov	r3, r4
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
		len -= nbytes;
		count += write(buffer, nbytes);
    2d72:	6830      	ldr	r0, [r6, #0]
    2d74:	bf28      	it	cs
    2d76:	2320      	movcs	r3, #32
    2d78:	a901      	add	r1, sp, #4
    2d7a:	f8d0 8004 	ldr.w	r8, [r0, #4]
    2d7e:	4630      	mov	r0, r6
	while (len > 0) {
		s.getBytes(buffer, sizeof(buffer), index);
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
		len -= nbytes;
    2d80:	1ae4      	subs	r4, r4, r3
		count += write(buffer, nbytes);
    2d82:	461a      	mov	r2, r3
	unsigned int len = s.length();
	while (len > 0) {
		s.getBytes(buffer, sizeof(buffer), index);
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
    2d84:	441d      	add	r5, r3
		len -= nbytes;
		count += write(buffer, nbytes);
    2d86:	47c0      	blx	r8
    2d88:	4407      	add	r7, r0
{
	uint8_t buffer[33];
	size_t count = 0;
	unsigned int index = 0;
	unsigned int len = s.length();
	while (len > 0) {
    2d8a:	2c00      	cmp	r4, #0
    2d8c:	d1e9      	bne.n	2d62 <Print::print(String const&)+0x12>
		index += nbytes;
		len -= nbytes;
		count += write(buffer, nbytes);
	}
	return count;
}
    2d8e:	4638      	mov	r0, r7
    2d90:	b00b      	add	sp, #44	; 0x2c
    2d92:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}


size_t Print::print(const String &s)
{
	uint8_t buffer[33];
	size_t count = 0;
    2d96:	4627      	mov	r7, r4
    2d98:	e7f9      	b.n	2d8e <Print::print(String const&)+0x3e>
    2d9a:	bf00      	nop

00002d9c <Print::println()>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    2d9c:	b510      	push	{r4, lr}
	uint8_t buf[2]={'\r', '\n'};
    2d9e:	4c06      	ldr	r4, [pc, #24]	; (2db8 <Print::println()+0x1c>)
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    2da0:	b082      	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    2da2:	6803      	ldr	r3, [r0, #0]
    2da4:	2202      	movs	r2, #2
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    2da6:	8824      	ldrh	r4, [r4, #0]
	return write(buf, 2);
    2da8:	a901      	add	r1, sp, #4
    2daa:	685b      	ldr	r3, [r3, #4]
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    2dac:	f8ad 4004 	strh.w	r4, [sp, #4]
	return write(buf, 2);
    2db0:	4798      	blx	r3
}
    2db2:	b002      	add	sp, #8
    2db4:	bd10      	pop	{r4, pc}
    2db6:	bf00      	nop
    2db8:	200003f0 	.word	0x200003f0

00002dbc <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
	((class Print *)file)->write((uint8_t *)ptr, len);
    2dbc:	6803      	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    2dbe:	b510      	push	{r4, lr}
    2dc0:	4614      	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    2dc2:	685b      	ldr	r3, [r3, #4]
    2dc4:	4798      	blx	r3
	return len;
}
    2dc6:	4620      	mov	r0, r4
    2dc8:	bd10      	pop	{r4, pc}
    2dca:	bf00      	nop

00002dcc <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    2dcc:	b40e      	push	{r1, r2, r3}
    2dce:	b500      	push	{lr}
    2dd0:	b082      	sub	sp, #8
    2dd2:	ab03      	add	r3, sp, #12
    2dd4:	f853 1b04 	ldr.w	r1, [r3], #4
	va_start(ap, format);
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    2dd8:	461a      	mov	r2, r3
}

int Print::printf(const char *format, ...)
{
	va_list ap;
	va_start(ap, format);
    2dda:	9301      	str	r3, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    2ddc:	f004 fd18 	bl	7810 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    2de0:	b002      	add	sp, #8
    2de2:	f85d eb04 	ldr.w	lr, [sp], #4
    2de6:	b003      	add	sp, #12
    2de8:	4770      	bx	lr
    2dea:	bf00      	nop

00002dec <IntervalTimer::~IntervalTimer()>:
private:
	static const uint32_t MAX_PERIOD = UINT32_MAX / (24000000 / 1000000);
public:
	constexpr IntervalTimer() {
	}
	~IntervalTimer() {
    2dec:	b510      	push	{r4, lr}
    2dee:	4604      	mov	r4, r0
		end();
    2df0:	f7ff ff7e 	bl	2cf0 <IntervalTimer::end()>
	}
    2df4:	4620      	mov	r0, r4
    2df6:	bd10      	pop	{r4, pc}

00002df8 <_GLOBAL__sub_I__Z4tonehtm>:
static uint32_t tone_toggle_count;
static volatile uint32_t *tone_reg;
static uint32_t tone_mask;
static float tone_usec=0.0;
static uint32_t tone_new_count=0;
static IntervalTimer tone_timer;
    2df8:	4a02      	ldr	r2, [pc, #8]	; (2e04 <_GLOBAL__sub_I__Z4tonehtm+0xc>)
    2dfa:	4903      	ldr	r1, [pc, #12]	; (2e08 <_GLOBAL__sub_I__Z4tonehtm+0x10>)
    2dfc:	4803      	ldr	r0, [pc, #12]	; (2e0c <_GLOBAL__sub_I__Z4tonehtm+0x14>)
    2dfe:	f003 ba03 	b.w	6208 <__aeabi_atexit>
    2e02:	bf00      	nop
    2e04:	20001588 	.word	0x20001588
    2e08:	00002ded 	.word	0x00002ded
    2e0c:	20001964 	.word	0x20001964

00002e10 <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    2e10:	b510      	push	{r4, lr}
    2e12:	4604      	mov	r4, r0
{
	free(buffer);
    2e14:	6800      	ldr	r0, [r0, #0]
    2e16:	f003 fbef 	bl	65f8 <free>
}
    2e1a:	4620      	mov	r0, r4
    2e1c:	bd10      	pop	{r4, pc}
    2e1e:	bf00      	nop

00002e20 <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    2e20:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    2e22:	6843      	ldr	r3, [r0, #4]
    2e24:	428b      	cmp	r3, r1
    2e26:	d301      	bcc.n	2e2c <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2e28:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    2e2a:	bd38      	pop	{r3, r4, r5, pc}
    2e2c:	460d      	mov	r5, r1
    2e2e:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    2e30:	3101      	adds	r1, #1
    2e32:	6800      	ldr	r0, [r0, #0]
    2e34:	f004 f806 	bl	6e44 <realloc>
	if (newbuffer) {
    2e38:	2800      	cmp	r0, #0
    2e3a:	d0f6      	beq.n	2e2a <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2e3c:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    2e3e:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2e42:	2b00      	cmp	r3, #0
    2e44:	d1f0      	bne.n	2e28 <String::reserve(unsigned int)+0x8>
    2e46:	7003      	strb	r3, [r0, #0]
    2e48:	e7ee      	b.n	2e28 <String::reserve(unsigned int)+0x8>
    2e4a:	bf00      	nop

00002e4c <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    2e4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2e4e:	4604      	mov	r4, r0
	if (length == 0) {
    2e50:	4615      	mov	r5, r2
    2e52:	b932      	cbnz	r2, 2e62 <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    2e54:	6803      	ldr	r3, [r0, #0]
    2e56:	b103      	cbz	r3, 2e5a <String::copy(char const*, unsigned int)+0xe>
    2e58:	701a      	strb	r2, [r3, #0]
		len = 0;
    2e5a:	2300      	movs	r3, #0
    2e5c:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    2e5e:	4620      	mov	r0, r4
    2e60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2e62:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    2e64:	4611      	mov	r1, r2
    2e66:	f7ff ffdb 	bl	2e20 <String::reserve(unsigned int)>
    2e6a:	4607      	mov	r7, r0
    2e6c:	b948      	cbnz	r0, 2e82 <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    2e6e:	6820      	ldr	r0, [r4, #0]
    2e70:	b110      	cbz	r0, 2e78 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    2e72:	f003 fbc1 	bl	65f8 <free>
			buffer = NULL;
    2e76:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    2e78:	2300      	movs	r3, #0
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    2e7a:	4620      	mov	r0, r4
	if (!reserve(length)) {
		if (buffer) {
			free(buffer);
			buffer = NULL;
		}
		len = capacity = 0;
    2e7c:	6063      	str	r3, [r4, #4]
    2e7e:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    2e80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    2e82:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    2e84:	4631      	mov	r1, r6
    2e86:	6820      	ldr	r0, [r4, #0]
    2e88:	f004 fb58 	bl	753c <strcpy>
	return *this;
    2e8c:	e7e7      	b.n	2e5e <String::copy(char const*, unsigned int)+0x12>
    2e8e:	bf00      	nop

00002e90 <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    2e90:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2e92:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    2e94:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2e96:	6003      	str	r3, [r0, #0]
	capacity = 0;
    2e98:	6043      	str	r3, [r0, #4]
	len = 0;
    2e9a:	6083      	str	r3, [r0, #8]
	flags = 0;
    2e9c:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    2e9e:	b141      	cbz	r1, 2eb2 <String::String(char const*)+0x22>
    2ea0:	460d      	mov	r5, r1
    2ea2:	4608      	mov	r0, r1
    2ea4:	f004 fbac 	bl	7600 <strlen>
    2ea8:	4602      	mov	r2, r0
    2eaa:	4629      	mov	r1, r5
    2eac:	4620      	mov	r0, r4
    2eae:	f7ff ffcd 	bl	2e4c <String::copy(char const*, unsigned int)>
}
    2eb2:	4620      	mov	r0, r4
    2eb4:	bd38      	pop	{r3, r4, r5, pc}
    2eb6:	bf00      	nop

00002eb8 <String::String(String const&)>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2eb8:	2300      	movs	r3, #0
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    2eba:	4288      	cmp	r0, r1
{
	init();
	*this = pgmstr;
}

String::String(const String &value)
    2ebc:	b510      	push	{r4, lr}
    2ebe:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2ec0:	6003      	str	r3, [r0, #0]
	capacity = 0;
    2ec2:	6043      	str	r3, [r0, #4]
	len = 0;
    2ec4:	6083      	str	r3, [r0, #8]
	flags = 0;
    2ec6:	7303      	strb	r3, [r0, #12]
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    2ec8:	d003      	beq.n	2ed2 <String::String(String const&)+0x1a>
	return copy(rhs.buffer, rhs.len);
    2eca:	688a      	ldr	r2, [r1, #8]
    2ecc:	6809      	ldr	r1, [r1, #0]
    2ece:	f7ff ffbd 	bl	2e4c <String::copy(char const*, unsigned int)>

String::String(const String &value)
{
	init();
	*this = value;
}
    2ed2:	4620      	mov	r0, r4
    2ed4:	bd10      	pop	{r4, pc}
    2ed6:	bf00      	nop

00002ed8 <String::operator=(char const*) [clone .part.2]>:
	if (this != &rval) move(rval);
	return *this;
}
#endif

String & String::operator = (const char *cstr)
    2ed8:	b538      	push	{r3, r4, r5, lr}
    2eda:	460c      	mov	r4, r1
    2edc:	4605      	mov	r5, r0
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    2ede:	4608      	mov	r0, r1
    2ee0:	f004 fb8e 	bl	7600 <strlen>
    2ee4:	4621      	mov	r1, r4
    2ee6:	4602      	mov	r2, r0
    2ee8:	4628      	mov	r0, r5
	} else {
		len = 0;
	}
	return *this;
}
    2eea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    2eee:	f7ff bfad 	b.w	2e4c <String::copy(char const*, unsigned int)>
    2ef2:	bf00      	nop

00002ef4 <String::String(int, unsigned char)>:
	char buf[4];
	utoa(c, buf, 10);
	*this = buf;
}

String::String(const int value, unsigned char base)
    2ef4:	b510      	push	{r4, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2ef6:	2300      	movs	r3, #0
	char buf[4];
	utoa(c, buf, 10);
	*this = buf;
}

String::String(const int value, unsigned char base)
    2ef8:	4604      	mov	r4, r0
    2efa:	b086      	sub	sp, #24
{
	init();
	char buf[18];
	itoa(value, buf, base);
    2efc:	4608      	mov	r0, r1
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2efe:	6023      	str	r3, [r4, #0]

String::String(const int value, unsigned char base)
{
	init();
	char buf[18];
	itoa(value, buf, base);
    2f00:	a901      	add	r1, sp, #4
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
	capacity = 0;
    2f02:	6063      	str	r3, [r4, #4]
	len = 0;
    2f04:	60a3      	str	r3, [r4, #8]
	flags = 0;
    2f06:	7323      	strb	r3, [r4, #12]

String::String(const int value, unsigned char base)
{
	init();
	char buf[18];
	itoa(value, buf, base);
    2f08:	f003 fb6c 	bl	65e4 <itoa>
    2f0c:	a901      	add	r1, sp, #4
    2f0e:	4620      	mov	r0, r4
    2f10:	f7ff ffe2 	bl	2ed8 <String::operator=(char const*) [clone .part.2]>
	*this = buf;
}
    2f14:	4620      	mov	r0, r4
    2f16:	b006      	add	sp, #24
    2f18:	bd10      	pop	{r4, pc}
    2f1a:	bf00      	nop

00002f1c <String::append(char const*, unsigned int)>:
{
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
    2f1c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2f20:	460f      	mov	r7, r1
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    2f22:	6803      	ldr	r3, [r0, #0]
{
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
    2f24:	4604      	mov	r4, r0
    2f26:	4615      	mov	r5, r2
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    2f28:	42bb      	cmp	r3, r7
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
    2f2a:	6881      	ldr	r1, [r0, #8]
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    2f2c:	d80a      	bhi.n	2f44 <String::append(char const*, unsigned int)+0x28>
    2f2e:	185a      	adds	r2, r3, r1
    2f30:	4297      	cmp	r7, r2
    2f32:	d207      	bcs.n	2f44 <String::append(char const*, unsigned int)+0x28>
		self = true;
		buffer_offset = (unsigned int)(cstr-buffer);
    2f34:	ebc3 0907 	rsb	r9, r3, r7
{
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
		self = true;
    2f38:	f04f 0801 	mov.w	r8, #1
		buffer_offset = (unsigned int)(cstr-buffer);
	}
	if (length == 0 || !reserve(newlen)) return *this;
    2f3c:	b935      	cbnz	r5, 2f4c <String::append(char const*, unsigned int)+0x30>
		}
	else
		strcpy(buffer + len, cstr);
	len = newlen;
	return *this;
}
    2f3e:	4620      	mov	r0, r4
    2f40:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}

String & String::append(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	bool self = false;
    2f44:	f04f 0800 	mov.w	r8, #0
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
		self = true;
		buffer_offset = (unsigned int)(cstr-buffer);
	}
	if (length == 0 || !reserve(newlen)) return *this;
    2f48:	2d00      	cmp	r5, #0
    2f4a:	d0f8      	beq.n	2f3e <String::append(char const*, unsigned int)+0x22>
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
    2f4c:	194e      	adds	r6, r1, r5
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
		self = true;
		buffer_offset = (unsigned int)(cstr-buffer);
	}
	if (length == 0 || !reserve(newlen)) return *this;
    2f4e:	4620      	mov	r0, r4
    2f50:	4631      	mov	r1, r6
    2f52:	f7ff ff65 	bl	2e20 <String::reserve(unsigned int)>
    2f56:	2800      	cmp	r0, #0
    2f58:	d0f1      	beq.n	2f3e <String::append(char const*, unsigned int)+0x22>
	if ( self ) {
    2f5a:	f1b8 0f00 	cmp.w	r8, #0
    2f5e:	d00e      	beq.n	2f7e <String::append(char const*, unsigned int)+0x62>
		memcpy(buffer + len, buffer+buffer_offset, length);
    2f60:	6823      	ldr	r3, [r4, #0]
    2f62:	462a      	mov	r2, r5
    2f64:	68a0      	ldr	r0, [r4, #8]
    2f66:	eb03 0109 	add.w	r1, r3, r9
    2f6a:	4418      	add	r0, r3
    2f6c:	f003 fe1a 	bl	6ba4 <memcpy>
		buffer[newlen] = 0;
    2f70:	6823      	ldr	r3, [r4, #0]
    2f72:	2200      	movs	r2, #0
    2f74:	559a      	strb	r2, [r3, r6]
		}
	else
		strcpy(buffer + len, cstr);
	len = newlen;
    2f76:	60a6      	str	r6, [r4, #8]
	return *this;
}
    2f78:	4620      	mov	r0, r4
    2f7a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ( self ) {
		memcpy(buffer + len, buffer+buffer_offset, length);
		buffer[newlen] = 0;
		}
	else
		strcpy(buffer + len, cstr);
    2f7e:	6820      	ldr	r0, [r4, #0]
    2f80:	4639      	mov	r1, r7
    2f82:	68a3      	ldr	r3, [r4, #8]
    2f84:	4418      	add	r0, r3
    2f86:	f004 fad9 	bl	753c <strcpy>
    2f8a:	e7f4      	b.n	2f76 <String::append(char const*, unsigned int)+0x5a>

00002f8c <operator+(StringSumHelper const&, String const&)>:
/*  Concatenate                              */
/*********************************************/


StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
    2f8c:	b510      	push	{r4, lr}
    2f8e:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	a.append(rhs.buffer, rhs.len);
    2f90:	688a      	ldr	r2, [r1, #8]
    2f92:	6809      	ldr	r1, [r1, #0]
    2f94:	f7ff ffc2 	bl	2f1c <String::append(char const*, unsigned int)>
	return a;
}
    2f98:	4620      	mov	r0, r4
    2f9a:	bd10      	pop	{r4, pc}

00002f9c <operator+(StringSumHelper const&, char const*)>:

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
    2f9c:	b538      	push	{r3, r4, r5, lr}
    2f9e:	4605      	mov	r5, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (cstr) a.append(cstr, strlen(cstr));
    2fa0:	b141      	cbz	r1, 2fb4 <operator+(StringSumHelper const&, char const*)+0x18>
    2fa2:	460c      	mov	r4, r1
    2fa4:	4608      	mov	r0, r1
    2fa6:	f004 fb2b 	bl	7600 <strlen>
    2faa:	4602      	mov	r2, r0
    2fac:	4621      	mov	r1, r4
    2fae:	4628      	mov	r0, r5
    2fb0:	f7ff ffb4 	bl	2f1c <String::append(char const*, unsigned int)>
	return a;
}
    2fb4:	4628      	mov	r0, r5
    2fb6:	bd38      	pop	{r3, r4, r5, pc}

00002fb8 <String::equals(char const*) const>:
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    2fb8:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    2fba:	b508      	push	{r3, lr}
    2fbc:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    2fbe:	b92a      	cbnz	r2, 2fcc <String::equals(char const*) const+0x14>
    2fc0:	b171      	cbz	r1, 2fe0 <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    2fc2:	7818      	ldrb	r0, [r3, #0]
    2fc4:	fab0 f080 	clz	r0, r0
    2fc8:	0940      	lsrs	r0, r0, #5
    2fca:	bd08      	pop	{r3, pc}
    2fcc:	b131      	cbz	r1, 2fdc <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    2fce:	6800      	ldr	r0, [r0, #0]
    2fd0:	f004 f94a 	bl	7268 <strcmp>
    2fd4:	fab0 f080 	clz	r0, r0
    2fd8:	0940      	lsrs	r0, r0, #5
}
    2fda:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    2fdc:	6803      	ldr	r3, [r0, #0]
    2fde:	e7f0      	b.n	2fc2 <String::equals(char const*) const+0xa>
    2fe0:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    2fe2:	bd08      	pop	{r3, pc}

00002fe4 <String::getBytes(unsigned char*, unsigned int, unsigned int) const>:
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
    2fe4:	b1ba      	cbz	r2, 3016 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x32>
	if (index >= len || !buffer) return 0;
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
    2fe6:	b570      	push	{r4, r5, r6, lr}
	if (!bufsize || !buf) return;
    2fe8:	fab1 f481 	clz	r4, r1
    2fec:	0964      	lsrs	r4, r4, #5
    2fee:	b97c      	cbnz	r4, 3010 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x2c>
	if (index >= len) {
    2ff0:	6886      	ldr	r6, [r0, #8]
    2ff2:	429e      	cmp	r6, r3
    2ff4:	d90d      	bls.n	3012 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x2e>
		buf[0] = 0;
		return;
	}
	unsigned int n = bufsize - 1;
	if (n > len - index) n = len - index;
    2ff6:	1af6      	subs	r6, r6, r3
	if (!bufsize || !buf) return;
	if (index >= len) {
		buf[0] = 0;
		return;
	}
	unsigned int n = bufsize - 1;
    2ff8:	3a01      	subs	r2, #1
    2ffa:	460d      	mov	r5, r1
	if (n > len - index) n = len - index;
	strncpy((char *)buf, buffer + index, n);
    2ffc:	6801      	ldr	r1, [r0, #0]
    2ffe:	4296      	cmp	r6, r2
    3000:	4628      	mov	r0, r5
    3002:	4419      	add	r1, r3
    3004:	bf28      	it	cs
    3006:	4616      	movcs	r6, r2
    3008:	4632      	mov	r2, r6
    300a:	f004 fb67 	bl	76dc <strncpy>
	buf[n] = 0;
    300e:	55ac      	strb	r4, [r5, r6]
    3010:	bd70      	pop	{r4, r5, r6, pc}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
	if (index >= len) {
		buf[0] = 0;
    3012:	700c      	strb	r4, [r1, #0]
		return;
    3014:	bd70      	pop	{r4, r5, r6, pc}
    3016:	4770      	bx	lr

00003018 <operator new(unsigned int)>:
    3018:	f003 bae6 	b.w	65e8 <malloc>

0000301c <operator new[](unsigned int)>:
	return malloc(size);
}

void * operator new[](size_t size)
{
	return malloc(size);
    301c:	f003 bae4 	b.w	65e8 <malloc>

00003020 <operator delete(void*, unsigned int)>:
    3020:	f003 baea 	b.w	65f8 <free>

00003024 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    3024:	4770      	bx	lr
    3026:	bf00      	nop

00003028 <usb_seremu_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
    3028:	f7ff bcb6 	b.w	2998 <usb_seremu_peekchar>

0000302c <usb_seremu_class::read()>:
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
    302c:	f7ff bc80 	b.w	2930 <usb_seremu_getchar>

00003030 <usb_seremu_class::available()>:
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    3030:	f7ff bcd4 	b.w	29dc <usb_seremu_available>

00003034 <usb_seremu_class::flush()>:
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
    3034:	f7ff be0a 	b.w	2c4c <usb_seremu_flush_output>

00003038 <usb_seremu_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
        size_t write(unsigned long n) { return write((uint8_t)n); }
        size_t write(long n) { return write((uint8_t)n); }
        size_t write(unsigned int n) { return write((uint8_t)n); }
        size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_seremu_write_buffer_free(); }
    3038:	f7ff be06 	b.w	2c48 <usb_seremu_write_buffer_free>

0000303c <usb_seremu_class::write(unsigned char const*, unsigned int)>:
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
    303c:	4608      	mov	r0, r1
    303e:	4611      	mov	r1, r2
    3040:	f7ff bdf6 	b.w	2c30 <usb_seremu_write>

00003044 <usb_seremu_class::write(unsigned char)>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
    3044:	4608      	mov	r0, r1
    3046:	f7ff bddd 	b.w	2c04 <usb_seremu_putchar>
    304a:	bf00      	nop

0000304c <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    304c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    3050:	4e32      	ldr	r6, [pc, #200]	; (311c <yield+0xd0>)
    3052:	7833      	ldrb	r3, [r6, #0]
    3054:	b193      	cbz	r3, 307c <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    3056:	4f32      	ldr	r7, [pc, #200]	; (3120 <yield+0xd4>)
    3058:	783a      	ldrb	r2, [r7, #0]
    305a:	b97a      	cbnz	r2, 307c <yield+0x30>
	running = 1;
    305c:	2201      	movs	r2, #1


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    305e:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    3060:	703a      	strb	r2, [r7, #0]


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    3062:	d437      	bmi.n	30d4 <yield+0x88>
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
    3064:	079a      	lsls	r2, r3, #30
    3066:	d419      	bmi.n	309c <yield+0x50>

	running = 0;
    3068:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    306a:	075b      	lsls	r3, r3, #29
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();

	running = 0;
    306c:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    306e:	d505      	bpl.n	307c <yield+0x30>
	// Wait for event(s) to occur.  These are most likely to be useful when
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);
	static void runFromYield() {
		if (!firstYield) return;  
    3070:	4b2c      	ldr	r3, [pc, #176]	; (3124 <yield+0xd8>)
    3072:	681a      	ldr	r2, [r3, #0]
    3074:	b112      	cbz	r2, 307c <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    3076:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    307a:	b10a      	cbz	r2, 3080 <yield+0x34>
    307c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    3080:	f3ef 8010 	mrs	r0, PRIMASK
		__disable_irq();
    3084:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    3086:	681a      	ldr	r2, [r3, #0]
		if (first == nullptr) {
    3088:	b11a      	cbz	r2, 3092 <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    308a:	4c27      	ldr	r4, [pc, #156]	; (3128 <yield+0xdc>)
    308c:	7821      	ldrb	r1, [r4, #0]
    308e:	2900      	cmp	r1, #0
    3090:	d02f      	beq.n	30f2 <yield+0xa6>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3092:	2800      	cmp	r0, #0
    3094:	d1f2      	bne.n	307c <yield+0x30>
    3096:	b662      	cpsie	i
    3098:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    309c:	f8df 8094 	ldr.w	r8, [pc, #148]	; 3134 <yield+0xe8>
    30a0:	f898 2000 	ldrb.w	r2, [r8]
    30a4:	2a00      	cmp	r2, #0
    30a6:	d0df      	beq.n	3068 <yield+0x1c>
    30a8:	2400      	movs	r4, #0
    30aa:	f8df 908c 	ldr.w	r9, [pc, #140]	; 3138 <yield+0xec>
    30ae:	e005      	b.n	30bc <yield+0x70>
    30b0:	3401      	adds	r4, #1
    30b2:	f898 3000 	ldrb.w	r3, [r8]
    30b6:	b2e4      	uxtb	r4, r4
    30b8:	42a3      	cmp	r3, r4
    30ba:	d913      	bls.n	30e4 <yield+0x98>
			s_serials_with_serial_events[i]->doYieldCode();
    30bc:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    30c0:	682b      	ldr	r3, [r5, #0]
    30c2:	4628      	mov	r0, r5
    30c4:	691b      	ldr	r3, [r3, #16]
    30c6:	4798      	blx	r3
    30c8:	2800      	cmp	r0, #0
    30ca:	d0f1      	beq.n	30b0 <yield+0x64>
    30cc:	696b      	ldr	r3, [r5, #20]
    30ce:	689b      	ldr	r3, [r3, #8]
    30d0:	4798      	blx	r3
    30d2:	e7ed      	b.n	30b0 <yield+0x64>
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    30d4:	f7ff fc82 	bl	29dc <usb_seremu_available>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    30d8:	b9d0      	cbnz	r0, 3110 <yield+0xc4>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    30da:	4b14      	ldr	r3, [pc, #80]	; (312c <yield+0xe0>)
    30dc:	781b      	ldrb	r3, [r3, #0]
    30de:	b91b      	cbnz	r3, 30e8 <yield+0x9c>
    30e0:	7833      	ldrb	r3, [r6, #0]
    30e2:	e7bf      	b.n	3064 <yield+0x18>
    30e4:	7833      	ldrb	r3, [r6, #0]
    30e6:	e7bf      	b.n	3068 <yield+0x1c>
    30e8:	7833      	ldrb	r3, [r6, #0]
    30ea:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    30ee:	7033      	strb	r3, [r6, #0]
    30f0:	e7b8      	b.n	3064 <yield+0x18>
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    30f2:	2601      	movs	r6, #1
		firstYield = first->_next;
    30f4:	6955      	ldr	r5, [r2, #20]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    30f6:	7026      	strb	r6, [r4, #0]
		firstYield = first->_next;
    30f8:	601d      	str	r5, [r3, #0]
		if (firstYield) {
    30fa:	b165      	cbz	r5, 3116 <yield+0xca>
			firstYield->_prev = nullptr;
    30fc:	61a9      	str	r1, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    30fe:	b900      	cbnz	r0, 3102 <yield+0xb6>
    3100:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    3102:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    3104:	6893      	ldr	r3, [r2, #8]
    3106:	4610      	mov	r0, r2
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    3108:	7755      	strb	r5, [r2, #29]
		(*(first->_function))(*first);
    310a:	4798      	blx	r3
		runningFromYield = false;
    310c:	7025      	strb	r5, [r4, #0]
    310e:	e7b5      	b.n	307c <yield+0x30>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    3110:	f7ff ff88 	bl	3024 <serialEvent()>
    3114:	e7e1      	b.n	30da <yield+0x8e>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    3116:	4b06      	ldr	r3, [pc, #24]	; (3130 <yield+0xe4>)
    3118:	601d      	str	r5, [r3, #0]
    311a:	e7f0      	b.n	30fe <yield+0xb2>
    311c:	20001f5f 	.word	0x20001f5f
    3120:	20002750 	.word	0x20002750
    3124:	20002684 	.word	0x20002684
    3128:	2000274e 	.word	0x2000274e
    312c:	60002186 	.word	0x60002186
    3130:	20002690 	.word	0x20002690
    3134:	2000274f 	.word	0x2000274f
    3138:	20002694 	.word	0x20002694

0000313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>:
 *    @param  byteorder The byte order of the register (used when width is > 1),
 * defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    313c:	b5f0      	push	{r4, r5, r6, r7, lr}
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
  _spidevice = spidevice;
    313e:	6042      	str	r2, [r0, #4]
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
    3140:	f04f 0e00 	mov.w	lr, #0
 *    @param  byteorder The byte order of the register (used when width is > 1),
 * defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    3144:	f89d 7020 	ldrb.w	r7, [sp, #32]
    3148:	f8bd 6014 	ldrh.w	r6, [sp, #20]
    314c:	f89d 501c 	ldrb.w	r5, [sp, #28]
    3150:	f89d 2018 	ldrb.w	r2, [sp, #24]
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
  _spidevice = spidevice;
  _i2cdevice = i2cdevice;
    3154:	6001      	str	r1, [r0, #0]
  _spiregtype = type;
    3156:	7203      	strb	r3, [r0, #8]
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
    3158:	f8c0 e014 	str.w	lr, [r0, #20]
  _spidevice = spidevice;
  _i2cdevice = i2cdevice;
  _spiregtype = type;
  _addrwidth = address_width;
    315c:	7347      	strb	r7, [r0, #13]
  _address = reg_addr;
    315e:	8146      	strh	r6, [r0, #10]
  _byteorder = byteorder;
    3160:	7385      	strb	r5, [r0, #14]
  _width = width;
    3162:	7302      	strb	r2, [r0, #12]
}
    3164:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3166:	bf00      	nop

00003168 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>:
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
    3168:	8943      	ldrh	r3, [r0, #10]
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    316a:	b5f0      	push	{r4, r5, r6, r7, lr}

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    316c:	b2dd      	uxtb	r5, r3
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    316e:	b085      	sub	sp, #20

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    3170:	0a1b      	lsrs	r3, r3, #8

  if (_i2cdevice) {
    3172:	6804      	ldr	r4, [r0, #0]
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    3174:	f88d 500c 	strb.w	r5, [sp, #12]
    3178:	f88d 300d 	strb.w	r3, [sp, #13]

  if (_i2cdevice) {
    317c:	b14c      	cbz	r4, 3192 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x2a>
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
    317e:	7b46      	ldrb	r6, [r0, #13]
    3180:	ad03      	add	r5, sp, #12
    3182:	4620      	mov	r0, r4
    3184:	2301      	movs	r3, #1
    3186:	e88d 0060 	stmia.w	sp, {r5, r6}
    318a:	f000 f949 	bl	3420 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>
      addrbuffer[0] |= 0x40;
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
  }
  return false;
}
    318e:	b005      	add	sp, #20
    3190:	bdf0      	pop	{r4, r5, r6, r7, pc}
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
  }
  if (_spidevice) {
    3192:	f8d0 e004 	ldr.w	lr, [r0, #4]
    3196:	f1be 0f00 	cmp.w	lr, #0
    319a:	d023      	beq.n	31e4 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x7c>
    if (_spiregtype == ADDRESSED_OPCODE_BIT0_LOW_TO_WRITE) {
    319c:	7a04      	ldrb	r4, [r0, #8]
    319e:	2c03      	cmp	r4, #3
    31a0:	d022      	beq.n	31e8 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x80>
    31a2:	460e      	mov	r6, r1
    31a4:	4617      	mov	r7, r2
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    }

    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    31a6:	b96c      	cbnz	r4, 31c4 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x5c>
      addrbuffer[0] &= ~0x80;
    31a8:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    31ac:	f88d 500c 	strb.w	r5, [sp, #12]
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
      addrbuffer[0] &= ~0x80;
      addrbuffer[0] |= 0x40;
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
    31b0:	7b43      	ldrb	r3, [r0, #13]
    31b2:	463a      	mov	r2, r7
    31b4:	4631      	mov	r1, r6
    31b6:	4670      	mov	r0, lr
    31b8:	9300      	str	r3, [sp, #0]
    31ba:	ab03      	add	r3, sp, #12
    31bc:	f000 fb72 	bl	38a4 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>
  }
  return false;
}
    31c0:	b005      	add	sp, #20
    31c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }

    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] &= ~0x80;
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOWRITE) {
    31c4:	2c02      	cmp	r4, #2
    31c6:	d104      	bne.n	31d2 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x6a>
      addrbuffer[0] |= 0x80;
    31c8:	f065 057f 	orn	r5, r5, #127	; 0x7f
    31cc:	f88d 500c 	strb.w	r5, [sp, #12]
    31d0:	e7ee      	b.n	31b0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
    31d2:	2c01      	cmp	r4, #1
    31d4:	d1ec      	bne.n	31b0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
      addrbuffer[0] &= ~0x80;
      addrbuffer[0] |= 0x40;
    31d6:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    31da:	f045 0540 	orr.w	r5, r5, #64	; 0x40
    31de:	f88d 500c 	strb.w	r5, [sp, #12]
    31e2:	e7e5      	b.n	31b0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
  }
  return false;
    31e4:	4670      	mov	r0, lr
    31e6:	e7d2      	b.n	318e <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x26>
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    31e8:	7b46      	ldrb	r6, [r0, #13]
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
    31ea:	f023 0401 	bic.w	r4, r3, #1
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    31ee:	4670      	mov	r0, lr
    31f0:	ab03      	add	r3, sp, #12
    31f2:	3601      	adds	r6, #1
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
    31f4:	f88d 400c 	strb.w	r4, [sp, #12]
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
    31f8:	f88d 500d 	strb.w	r5, [sp, #13]
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    31fc:	9600      	str	r6, [sp, #0]
    31fe:	f000 fb51 	bl	38a4 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>
    3202:	e7c4      	b.n	318e <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x26>

00003204 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>:
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
  if (numbytes == 0) {
    3204:	b902      	cbnz	r2, 3208 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x4>
    numbytes = _width;
    3206:	7b02      	ldrb	r2, [r0, #12]
  }
  if (numbytes > 4) {
    3208:	2a04      	cmp	r2, #4
    320a:	d818      	bhi.n	323e <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x3a>
 *    @param  value Data to write
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
    320c:	b4f0      	push	{r4, r5, r6, r7}
  if (numbytes > 4) {
    return false;
  }

  // store a copy
  _cached = value;
    320e:	6141      	str	r1, [r0, #20]
    3210:	f100 070f 	add.w	r7, r0, #15

  for (int i = 0; i < numbytes; i++) {
    3214:	b16a      	cbz	r2, 3232 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x2e>
    3216:	f102 030e 	add.w	r3, r2, #14
    321a:	7b86      	ldrb	r6, [r0, #14]
    321c:	f100 050e 	add.w	r5, r0, #14
    3220:	463c      	mov	r4, r7
    3222:	4403      	add	r3, r0
    if (_byteorder == LSBFIRST) {
    3224:	b94e      	cbnz	r6, 323a <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x36>
      _buffer[i] = value & 0xFF;
    3226:	7021      	strb	r1, [r4, #0]
    3228:	3b01      	subs	r3, #1
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
    322a:	0a09      	lsrs	r1, r1, #8
    322c:	3401      	adds	r4, #1
  }

  // store a copy
  _cached = value;

  for (int i = 0; i < numbytes; i++) {
    322e:	42ab      	cmp	r3, r5
    3230:	d1f8      	bne.n	3224 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x20>
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    3232:	4639      	mov	r1, r7
}
    3234:	bcf0      	pop	{r4, r5, r6, r7}
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    3236:	f7ff bf97 	b.w	3168 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>

  for (int i = 0; i < numbytes; i++) {
    if (_byteorder == LSBFIRST) {
      _buffer[i] = value & 0xFF;
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    323a:	7019      	strb	r1, [r3, #0]
    323c:	e7f4      	b.n	3228 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x24>
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
}
    323e:	2000      	movs	r0, #0
    3240:	4770      	bx	lr
    3242:	bf00      	nop

00003244 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>:
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    3244:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
    3246:	8944      	ldrh	r4, [r0, #10]
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    3248:	b085      	sub	sp, #20
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    324a:	6805      	ldr	r5, [r0, #0]
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    324c:	b2e6      	uxtb	r6, r4
    324e:	0a24      	lsrs	r4, r4, #8
    3250:	f88d 600c 	strb.w	r6, [sp, #12]
    3254:	f88d 400d 	strb.w	r4, [sp, #13]

  if (_i2cdevice) {
    3258:	b15d      	cbz	r5, 3272 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2e>
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    325a:	7b40      	ldrb	r0, [r0, #13]
    325c:	2400      	movs	r4, #0
    325e:	9200      	str	r2, [sp, #0]
    3260:	460b      	mov	r3, r1
    3262:	4602      	mov	r2, r0
    3264:	9401      	str	r4, [sp, #4]
    3266:	4628      	mov	r0, r5
    3268:	a903      	add	r1, sp, #12
    326a:	f000 f96b 	bl	3544 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>
      addrbuffer[0] |= 0x80 | 0x40;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
}
    326e:	b005      	add	sp, #20
    3270:	bdf0      	pop	{r4, r5, r6, r7, pc}
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  if (_spidevice) {
    3272:	6845      	ldr	r5, [r0, #4]
    3274:	b30d      	cbz	r5, 32ba <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x76>
    if (_spiregtype == ADDRESSED_OPCODE_BIT0_LOW_TO_WRITE) {
    3276:	7a03      	ldrb	r3, [r0, #8]
    3278:	2b03      	cmp	r3, #3
    327a:	d020      	beq.n	32be <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x7a>
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    327c:	b97b      	cbnz	r3, 329e <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x5a>
      addrbuffer[0] |= 0x80;
    327e:	f066 067f 	orn	r6, r6, #127	; 0x7f
    3282:	f88d 600c 	strb.w	r6, [sp, #12]
      addrbuffer[0] &= ~0x80;
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
      addrbuffer[0] |= 0x80 | 0x40;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    3286:	7b40      	ldrb	r0, [r0, #13]
    3288:	24ff      	movs	r4, #255	; 0xff
    328a:	9200      	str	r2, [sp, #0]
    328c:	460b      	mov	r3, r1
    328e:	4602      	mov	r2, r0
    3290:	a903      	add	r1, sp, #12
    3292:	4628      	mov	r0, r5
    3294:	9401      	str	r4, [sp, #4]
    3296:	f000 fb3b 	bl	3910 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>
  }
  return false;
}
    329a:	b005      	add	sp, #20
    329c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         len);
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] |= 0x80;
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOWRITE) {
    329e:	2b02      	cmp	r3, #2
    32a0:	d104      	bne.n	32ac <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x68>
      addrbuffer[0] &= ~0x80;
    32a2:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    32a6:	f88d 600c 	strb.w	r6, [sp, #12]
    32aa:	e7ec      	b.n	3286 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
    32ac:	2b01      	cmp	r3, #1
    32ae:	d1ea      	bne.n	3286 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
      addrbuffer[0] |= 0x80 | 0x40;
    32b0:	f066 063f 	orn	r6, r6, #63	; 0x3f
    32b4:	f88d 600c 	strb.w	r6, [sp, #12]
    32b8:	e7e5      	b.n	3286 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
    32ba:	4628      	mov	r0, r5
    32bc:	e7d7      	b.n	326e <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2a>
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    32be:	7b43      	ldrb	r3, [r0, #13]
    32c0:	27ff      	movs	r7, #255	; 0xff
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
    32c2:	f044 0401 	orr.w	r4, r4, #1
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    32c6:	9200      	str	r2, [sp, #0]
    32c8:	4628      	mov	r0, r5
    32ca:	1c5a      	adds	r2, r3, #1
    32cc:	9701      	str	r7, [sp, #4]
    32ce:	460b      	mov	r3, r1
    32d0:	a903      	add	r1, sp, #12
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
    32d2:	f88d 400c 	strb.w	r4, [sp, #12]
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
    32d6:	f88d 600d 	strb.w	r6, [sp, #13]
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    32da:	f000 fb19 	bl	3910 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>
    32de:	e7c6      	b.n	326e <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2a>

000032e0 <Adafruit_BusIO_Register::read()>:
/*!
 *    @brief  Read data from the register location. This does not do any error
 * checking!
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    32e0:	b538      	push	{r3, r4, r5, lr}
  if (!read(_buffer, _width)) {
    32e2:	f100 040f 	add.w	r4, r0, #15
    32e6:	7b02      	ldrb	r2, [r0, #12]
/*!
 *    @brief  Read data from the register location. This does not do any error
 * checking!
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    32e8:	4605      	mov	r5, r0
  if (!read(_buffer, _width)) {
    32ea:	4621      	mov	r1, r4
    32ec:	f7ff ffaa 	bl	3244 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    32f0:	b910      	cbnz	r0, 32f8 <Adafruit_BusIO_Register::read()+0x18>
    return -1;
    32f2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
      value |= _buffer[i];
    }
  }

  return value;
}
    32f6:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    32f8:	7b28      	ldrb	r0, [r5, #12]
    32fa:	2800      	cmp	r0, #0
    32fc:	d0fb      	beq.n	32f6 <Adafruit_BusIO_Register::read()+0x16>
    32fe:	300e      	adds	r0, #14
    3300:	4621      	mov	r1, r4
    3302:	f105 020e 	add.w	r2, r5, #14
    3306:	7bac      	ldrb	r4, [r5, #14]
    3308:	182b      	adds	r3, r5, r0
    330a:	2000      	movs	r0, #0
    330c:	e006      	b.n	331c <Adafruit_BusIO_Register::read()+0x3c>
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    330e:	781d      	ldrb	r5, [r3, #0]
    3310:	3b01      	subs	r3, #1
    3312:	3101      	adds	r1, #1
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    3314:	4293      	cmp	r3, r2
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    3316:	ea40 0005 	orr.w	r0, r0, r5
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    331a:	d009      	beq.n	3330 <Adafruit_BusIO_Register::read()+0x50>
    value <<= 8;
    331c:	0200      	lsls	r0, r0, #8
    if (_byteorder == LSBFIRST) {
    331e:	2c00      	cmp	r4, #0
    3320:	d0f5      	beq.n	330e <Adafruit_BusIO_Register::read()+0x2e>
    3322:	3b01      	subs	r3, #1
      value |= _buffer[_width - i - 1];
    } else {
      value |= _buffer[i];
    3324:	780d      	ldrb	r5, [r1, #0]
    3326:	3101      	adds	r1, #1
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    3328:	4293      	cmp	r3, r2
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    } else {
      value |= _buffer[i];
    332a:	ea40 0005 	orr.w	r0, r0, r5
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    332e:	d1f5      	bne.n	331c <Adafruit_BusIO_Register::read()+0x3c>
    3330:	bd38      	pop	{r3, r4, r5, pc}
    3332:	bf00      	nop

00003334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>:
 * touching other bits
 *    @param  reg The Adafruit_BusIO_Register which defines the bus/register
 *    @param  bits The number of bits wide we are slicing
 *    @param  shift The number of bits that our bit-slice is shifted from LSB
 */
Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(
    3334:	b410      	push	{r4}
    Adafruit_BusIO_Register *reg, uint8_t bits, uint8_t shift) {
  _register = reg;
    3336:	6001      	str	r1, [r0, #0]
  _bits = bits;
    3338:	7102      	strb	r2, [r0, #4]
  _shift = shift;
    333a:	7143      	strb	r3, [r0, #5]
}
    333c:	f85d 4b04 	ldr.w	r4, [sp], #4
    3340:	4770      	bx	lr
    3342:	bf00      	nop

00003344 <Adafruit_BusIO_RegisterBits::read()>:

/*!
 *    @brief  Read 4 bytes of data from the register
 *    @return  data The 4 bytes to read
 */
uint32_t Adafruit_BusIO_RegisterBits::read(void) {
    3344:	b510      	push	{r4, lr}
    3346:	4604      	mov	r4, r0
  uint32_t val = _register->read();
    3348:	6800      	ldr	r0, [r0, #0]
    334a:	f7ff ffc9 	bl	32e0 <Adafruit_BusIO_Register::read()>
  val >>= _shift;
  return val & ((1 << (_bits)) - 1);
    334e:	2301      	movs	r3, #1
    3350:	7921      	ldrb	r1, [r4, #4]
    3352:	7962      	ldrb	r2, [r4, #5]
    3354:	408b      	lsls	r3, r1
    3356:	40d0      	lsrs	r0, r2
    3358:	3b01      	subs	r3, #1
}
    335a:	4018      	ands	r0, r3
    335c:	bd10      	pop	{r4, pc}
    335e:	bf00      	nop

00003360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>:
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    3360:	b538      	push	{r3, r4, r5, lr}
    3362:	4605      	mov	r5, r0
  uint32_t val = _register->read();
    3364:	6800      	ldr	r0, [r0, #0]
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    3366:	460c      	mov	r4, r1
  uint32_t val = _register->read();
    3368:	f7ff ffba 	bl	32e0 <Adafruit_BusIO_Register::read()>

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    336c:	792a      	ldrb	r2, [r5, #4]
    336e:	2301      	movs	r3, #1
  data &= mask;

  mask <<= _shift;
    3370:	7969      	ldrb	r1, [r5, #5]
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
  uint32_t val = _register->read();

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    3372:	4093      	lsls	r3, r2

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    3374:	682d      	ldr	r5, [r5, #0]
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
  uint32_t val = _register->read();

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    3376:	3b01      	subs	r3, #1

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    3378:	7b2a      	ldrb	r2, [r5, #12]
    337a:	401c      	ands	r4, r3
  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
  data &= mask;

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
    337c:	408b      	lsls	r3, r1
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    337e:	fa04 f101 	lsl.w	r1, r4, r1
  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
  data &= mask;

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
    3382:	ea20 0303 	bic.w	r3, r0, r3
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    3386:	4628      	mov	r0, r5
    3388:	4319      	orrs	r1, r3
}
    338a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    338e:	f7ff bf39 	b.w	3204 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>
    3392:	bf00      	nop

00003394 <TwoWire::read()>:
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    3394:	f890 30a2 	ldrb.w	r3, [r0, #162]	; 0xa2
    3398:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    339c:	429a      	cmp	r2, r3
    339e:	d905      	bls.n	33ac <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    33a0:	1c5a      	adds	r2, r3, #1
    33a2:	4403      	add	r3, r0
    33a4:	f880 20a2 	strb.w	r2, [r0, #162]	; 0xa2
    33a8:	7e98      	ldrb	r0, [r3, #26]
    33aa:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    33ac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    33b0:	4770      	bx	lr
    33b2:	bf00      	nop

000033b4 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>:
/*!
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
    33b4:	b430      	push	{r4, r5}
  _addr = addr;
  _wire = theWire;
  _begun = false;
    33b6:	2500      	movs	r5, #0
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
    33b8:	2420      	movs	r4, #32
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
    33ba:	7001      	strb	r1, [r0, #0]
  _wire = theWire;
  _begun = false;
    33bc:	7205      	strb	r5, [r0, #8]
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
    33be:	60c4      	str	r4, [r0, #12]
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
  _wire = theWire;
    33c0:	6042      	str	r2, [r0, #4]
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
#endif
}
    33c2:	bc30      	pop	{r4, r5}
    33c4:	4770      	bx	lr
    33c6:	bf00      	nop

000033c8 <Adafruit_I2CDevice::detected()>:
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    33c8:	7a03      	ldrb	r3, [r0, #8]
/*!
 *    @brief  Scans I2C for the address - note will give a false-positive
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
    33ca:	b510      	push	{r4, lr}
    33cc:	4604      	mov	r4, r0
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    33ce:	b18b      	cbz	r3, 33f4 <Adafruit_I2CDevice::detected()+0x2c>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    33d0:	7820      	ldrb	r0, [r4, #0]
		transmitting = 1;
    33d2:	2201      	movs	r2, #1
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
    33d4:	6863      	ldr	r3, [r4, #4]
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    33d6:	4090      	lsls	r0, r2
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    33d8:	4611      	mov	r1, r2
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    33da:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    33de:	f883 00a5 	strb.w	r0, [r3, #165]	; 0xa5
		transmitting = 1;
		txBufferLength = 1;
    33e2:	f883 212f 	strb.w	r2, [r3, #303]	; 0x12f
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    33e6:	6860      	ldr	r0, [r4, #4]
    33e8:	f001 fb48 	bl	4a7c <TwoWire::endTransmission(unsigned char)>
  if (_wire->endTransmission() == 0) {
    33ec:	fab0 f080 	clz	r0, r0
    33f0:	0940      	lsrs	r0, r0, #5
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    33f2:	bd10      	pop	{r4, pc}
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    33f4:	2101      	movs	r1, #1
    33f6:	f000 f803 	bl	3400 <Adafruit_I2CDevice::begin(bool)>
    33fa:	2800      	cmp	r0, #0
    33fc:	d1e8      	bne.n	33d0 <Adafruit_I2CDevice::detected()+0x8>
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    33fe:	bd10      	pop	{r4, pc}

00003400 <Adafruit_I2CDevice::begin(bool)>:
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    3400:	b538      	push	{r3, r4, r5, lr}
    3402:	4604      	mov	r4, r0
  _wire->begin();
    3404:	6840      	ldr	r0, [r0, #4]
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    3406:	460d      	mov	r5, r1
  _wire->begin();
    3408:	f007 fa12 	bl	a830 <___ZN7TwoWire5beginEv_veneer>
  _begun = true;
    340c:	2001      	movs	r0, #1
    340e:	7220      	strb	r0, [r4, #8]

  if (addr_detect) {
    3410:	b905      	cbnz	r5, 3414 <Adafruit_I2CDevice::begin(bool)+0x14>
    return detected();
  }
  return true;
}
    3412:	bd38      	pop	{r3, r4, r5, pc}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    3414:	4620      	mov	r0, r4
  }
  return true;
}
    3416:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    341a:	f7ff bfd5 	b.w	33c8 <Adafruit_I2CDevice::detected()>
    341e:	bf00      	nop

00003420 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>:
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    3420:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3424:	9e07      	ldr	r6, [sp, #28]
  if ((len + prefix_len) > maxBufferSize()) {
    3426:	68c4      	ldr	r4, [r0, #12]
    3428:	1995      	adds	r5, r2, r6
    342a:	42a5      	cmp	r5, r4
    342c:	d818      	bhi.n	3460 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x40>
    342e:	4698      	mov	r8, r3
    3430:	460f      	mov	r7, r1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    3432:	7803      	ldrb	r3, [r0, #0]
		transmitting = 1;
    3434:	2101      	movs	r1, #1
    3436:	4615      	mov	r5, r2
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    3438:	6842      	ldr	r2, [r0, #4]
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    343a:	408b      	lsls	r3, r1
    343c:	4604      	mov	r4, r0
		transmitting = 1;
    343e:	f882 1130 	strb.w	r1, [r2, #304]	; 0x130
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    3442:	f882 30a5 	strb.w	r3, [r2, #165]	; 0xa5
		transmitting = 1;
		txBufferLength = 1;
    3446:	f882 112f 	strb.w	r1, [r2, #303]	; 0x12f

  // Write the prefix data (usually an address)
  if ((prefix_len != 0) && (prefix_buffer != nullptr)) {
    344a:	b166      	cbz	r6, 3466 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    344c:	9b06      	ldr	r3, [sp, #24]
    344e:	b153      	cbz	r3, 3466 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {
    3450:	6840      	ldr	r0, [r0, #4]
    3452:	4632      	mov	r2, r6
    3454:	9906      	ldr	r1, [sp, #24]
    3456:	6803      	ldr	r3, [r0, #0]
    3458:	685b      	ldr	r3, [r3, #4]
    345a:	4798      	blx	r3
    345c:	4286      	cmp	r6, r0
    345e:	d002      	beq.n	3466 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    // we will need to find out if some platforms have larger
    // I2C buffer sizes :/
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
    3460:	2000      	movs	r0, #0
    3462:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    3466:	6860      	ldr	r0, [r4, #4]
    3468:	4639      	mov	r1, r7
    346a:	462a      	mov	r2, r5
    346c:	6803      	ldr	r3, [r0, #0]
    346e:	685b      	ldr	r3, [r3, #4]
    3470:	4798      	blx	r3
    3472:	4285      	cmp	r5, r0
    3474:	d1f4      	bne.n	3460 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x40>
  if (stop) {
    DEBUG_SERIAL.print("\tSTOP");
  }
#endif

  if (_wire->endTransmission(stop) == 0) {
    3476:	4641      	mov	r1, r8
    3478:	6860      	ldr	r0, [r4, #4]
    347a:	f001 faff 	bl	4a7c <TwoWire::endTransmission(unsigned char)>
    347e:	fab0 f080 	clz	r0, r0
    3482:	0940      	lsrs	r0, r0, #5
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("\tFailed to send!");
#endif
    return false;
  }
}
    3484:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003488 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>:
    pos += read_len;
  }
  return true;
}

bool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {
    3488:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    348c:	4615      	mov	r5, r2
    348e:	4606      	mov	r6, r0
    3490:	460f      	mov	r7, r1
#if defined(TinyWireM_h)
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#elif defined(ARDUINO_ARCH_MEGAAVR)
  size_t recv = _wire->requestFrom(_addr, len, stop);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
    3492:	b2d2      	uxtb	r2, r2
    3494:	7801      	ldrb	r1, [r0, #0]
    3496:	6840      	ldr	r0, [r0, #4]
    3498:	f001 fb60 	bl	4b5c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
#endif

  if (recv != len) {
    349c:	4285      	cmp	r5, r0
    349e:	d002      	beq.n	34a6 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x1e>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    34a0:	2000      	movs	r0, #0
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    34a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    34a6:	b30d      	cbz	r5, 34ec <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x64>
    34a8:	2300      	movs	r3, #0
    34aa:	f8df 904c 	ldr.w	r9, [pc, #76]	; 34f8 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x70>
    34ae:	461c      	mov	r4, r3
    34b0:	e012      	b.n	34d8 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x50>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    34b2:	f890 20a2 	ldrb.w	r2, [r0, #162]	; 0xa2
    34b6:	f890 30a3 	ldrb.w	r3, [r0, #163]	; 0xa3
		return rxBuffer[rxBufferIndex++];
    34ba:	f102 0e01 	add.w	lr, r2, #1
    34be:	1881      	adds	r1, r0, r2
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    34c0:	4293      	cmp	r3, r2
    34c2:	d916      	bls.n	34f2 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x6a>
		return rxBuffer[rxBufferIndex++];
    34c4:	f880 e0a2 	strb.w	lr, [r0, #162]	; 0xa2
    34c8:	7e88      	ldrb	r0, [r1, #26]
    34ca:	3401      	adds	r4, #1
    buffer[i] = _wire->read();
    34cc:	f888 0000 	strb.w	r0, [r8]
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    34d0:	b2a4      	uxth	r4, r4
    34d2:	42a5      	cmp	r5, r4
    34d4:	4623      	mov	r3, r4
    34d6:	d909      	bls.n	34ec <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x64>
    buffer[i] = _wire->read();
    34d8:	6870      	ldr	r0, [r6, #4]
    34da:	eb07 0803 	add.w	r8, r7, r3
    34de:	6803      	ldr	r3, [r0, #0]
    34e0:	695a      	ldr	r2, [r3, #20]
    34e2:	454a      	cmp	r2, r9
    34e4:	d0e5      	beq.n	34b2 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x2a>
    34e6:	4790      	blx	r2
    34e8:	b2c0      	uxtb	r0, r0
    34ea:	e7ee      	b.n	34ca <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x42>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    34ec:	2001      	movs	r0, #1
    34ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    34f2:	20ff      	movs	r0, #255	; 0xff
    34f4:	e7e9      	b.n	34ca <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x42>
    34f6:	bf00      	nop
    34f8:	00003395 	.word	0x00003395

000034fc <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    34fc:	b302      	cbz	r2, 3540 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x44>
 *    @param  buffer Pointer to buffer of data to read into
 *    @param  len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
    34fe:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3502:	4616      	mov	r6, r2
    3504:	4699      	mov	r9, r3
    3506:	4688      	mov	r8, r1
    3508:	4607      	mov	r7, r0
  size_t pos = 0;
  while (pos < len) {
    350a:	2400      	movs	r4, #0
    350c:	e001      	b.n	3512 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x16>
    350e:	42a6      	cmp	r6, r4
    3510:	d913      	bls.n	353a <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x3e>
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    3512:	1b32      	subs	r2, r6, r4
    3514:	68fd      	ldr	r5, [r7, #12]
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
    3516:	eb08 0104 	add.w	r1, r8, r4
    351a:	4638      	mov	r0, r7
    351c:	42aa      	cmp	r2, r5
    351e:	bf28      	it	cs
    3520:	462a      	movcs	r2, r5
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    3522:	1ab3      	subs	r3, r6, r2
    if (!_read(buffer + pos, read_len, read_stop))
    3524:	42a3      	cmp	r3, r4
    3526:	bf94      	ite	ls
    3528:	464b      	movls	r3, r9
    352a:	2300      	movhi	r3, #0
      return false;
    pos += read_len;
    352c:	4414      	add	r4, r2
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
    352e:	f7ff ffab 	bl	3488 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>
    3532:	2800      	cmp	r0, #0
    3534:	d1eb      	bne.n	350e <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x12>
      return false;
    pos += read_len;
  }
  return true;
}
    3536:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
      return false;
    pos += read_len;
  }
  return true;
    353a:	2001      	movs	r0, #1
    353c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3540:	2001      	movs	r0, #1
}
    3542:	4770      	bx	lr

00003544 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    3544:	b5f0      	push	{r4, r5, r6, r7, lr}
    3546:	b083      	sub	sp, #12
  if (!write(write_buffer, write_len, stop)) {
    3548:	2400      	movs	r4, #0
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    354a:	461f      	mov	r7, r3
    354c:	4606      	mov	r6, r0
    354e:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  if (!write(write_buffer, write_len, stop)) {
    3552:	9401      	str	r4, [sp, #4]
    3554:	9400      	str	r4, [sp, #0]
    3556:	462b      	mov	r3, r5
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    3558:	9c08      	ldr	r4, [sp, #32]
  if (!write(write_buffer, write_len, stop)) {
    355a:	f7ff ff61 	bl	3420 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>
    355e:	b908      	cbnz	r0, 3564 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)+0x20>
    return false;
  }

  return read(read_buffer, read_len);
}
    3560:	b003      	add	sp, #12
    3562:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
    3564:	4622      	mov	r2, r4
    3566:	4639      	mov	r1, r7
    3568:	4630      	mov	r0, r6
    356a:	2301      	movs	r3, #1
}
    356c:	b003      	add	sp, #12
    356e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
    3572:	f7ff bfc3 	b.w	34fc <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>
    3576:	bf00      	nop

00003578 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>:
 *    @brief  Transfer (send/receive) a buffer over hard/soft SPI, without
 * transaction management
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    3578:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // HARDWARE SPI
  //
  if (_spi) {
    357c:	6804      	ldr	r4, [r0, #0]
 *    @brief  Transfer (send/receive) a buffer over hard/soft SPI, without
 * transaction management
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    357e:	4613      	mov	r3, r2
    3580:	b085      	sub	sp, #20
    3582:	460a      	mov	r2, r1
  //
  // HARDWARE SPI
  //
  if (_spi) {
    3584:	b12c      	cbz	r4, 3592 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x1a>
				transfer16(buf, buf, count >> 1);
				return;
			}
		}
#endif
		transfer(buf, buf, count);
    3586:	4620      	mov	r0, r4
        buffer[i] = reply;
      }
    }
  }
  return;
}
    3588:	b005      	add	sp, #20
    358a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    358e:	f001 b97d 	b.w	488c <SPIClass::transfer(void const*, void*, unsigned int)>

  //
  // SOFTWARE SPI
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    3592:	7b04      	ldrb	r4, [r0, #12]
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    3594:	4959      	ldr	r1, [pc, #356]	; (36fc <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x184>)
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    3596:	2c00      	cmp	r4, #0
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    3598:	6886      	ldr	r6, [r0, #8]
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    359a:	7814      	ldrb	r4, [r2, #0]
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    359c:	bf0c      	ite	eq
    359e:	2501      	moveq	r5, #1
    35a0:	2580      	movne	r5, #128	; 0x80
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    35a2:	fbb1 f6f6 	udiv	r6, r1, r6
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    35a6:	4225      	tst	r5, r4
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    35a8:	9502      	str	r5, [sp, #8]
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    35aa:	b2f6      	uxtb	r6, r6
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    35ac:	bf0c      	ite	eq
    35ae:	2101      	moveq	r1, #1
    35b0:	2100      	movne	r1, #0
    35b2:	9100      	str	r1, [sp, #0]
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    35b4:	2b00      	cmp	r3, #0
    35b6:	d063      	beq.n	3680 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x108>
    35b8:	4690      	mov	r8, r2
    35ba:	4683      	mov	fp, r0
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    35bc:	4c50      	ldr	r4, [pc, #320]	; (3700 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x188>)
    35be:	4443      	add	r3, r8
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    35c0:	f8df 9144 	ldr.w	r9, [pc, #324]	; 3708 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x190>
    35c4:	9303      	str	r3, [sp, #12]
    uint8_t reply = 0;
    uint8_t send = buffer[i];
    35c6:	f818 ab01 	ldrb.w	sl, [r8], #1
    35ca:	465b      	mov	r3, fp
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    35cc:	9d02      	ldr	r5, [sp, #8]

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    uint8_t reply = 0;
    35ce:	2700      	movs	r7, #0
    35d0:	46c3      	mov	fp, r8
    35d2:	4698      	mov	r8, r3

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
    35d4:	2e00      	cmp	r6, #0
    35d6:	d05a      	beq.n	368e <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x116>
    35d8:	4a4a      	ldr	r2, [pc, #296]	; (3704 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x18c>)
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    35da:	6823      	ldr	r3, [r4, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    35dc:	6810      	ldr	r0, [r2, #0]
    35de:	fba9 1000 	umull	r1, r0, r9, r0
    35e2:	0c80      	lsrs	r0, r0, #18
    35e4:	fb00 f006 	mul.w	r0, r0, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    35e8:	6821      	ldr	r1, [r4, #0]
    35ea:	1ac9      	subs	r1, r1, r3
    35ec:	4288      	cmp	r0, r1
    35ee:	d8fb      	bhi.n	35e8 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x70>
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    35f0:	f898 100d 	ldrb.w	r1, [r8, #13]
    35f4:	f011 0ff7 	tst.w	r1, #247	; 0xf7
    35f8:	d16c      	bne.n	36d4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x15c>
        towrite = send & b;
    35fa:	ea1a 0f05 	tst.w	sl, r5
        if ((_mosi != -1) && (lastmosi != towrite)) {
    35fe:	f998 0010 	ldrsb.w	r0, [r8, #16]
      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
        towrite = send & b;
    3602:	bf14      	ite	ne
    3604:	2101      	movne	r1, #1
    3606:	2100      	moveq	r1, #0
        if ((_mosi != -1) && (lastmosi != towrite)) {
    3608:	1c43      	adds	r3, r0, #1
    360a:	d006      	beq.n	361a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xa2>
    360c:	9b00      	ldr	r3, [sp, #0]
    360e:	4299      	cmp	r1, r3
    3610:	d003      	beq.n	361a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xa2>
          if (towrite)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
#else
          digitalWrite(_mosi, towrite);
    3612:	b2c0      	uxtb	r0, r0
    3614:	9100      	str	r1, [sp, #0]
    3616:	f7fe f891 	bl	173c <digitalWrite>
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    361a:	2101      	movs	r1, #1
    361c:	f898 000f 	ldrb.w	r0, [r8, #15]
    3620:	f7fe f88c 	bl	173c <digitalWrite>
#endif

        if (bitdelay_us) {
    3624:	b15e      	cbz	r6, 363e <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xc6>
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3626:	4a37      	ldr	r2, [pc, #220]	; (3704 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x18c>)
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3628:	6820      	ldr	r0, [r4, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    362a:	6811      	ldr	r1, [r2, #0]
    362c:	fba9 3101 	umull	r3, r1, r9, r1
    3630:	0c89      	lsrs	r1, r1, #18
    3632:	fb01 f106 	mul.w	r1, r1, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    3636:	6823      	ldr	r3, [r4, #0]
    3638:	1a1b      	subs	r3, r3, r0
    363a:	4299      	cmp	r1, r3
    363c:	d8fb      	bhi.n	3636 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xbe>
          delayMicroseconds(bitdelay_us);
        }

        if (_miso != -1) {
    363e:	f998 0011 	ldrsb.w	r0, [r8, #17]
    3642:	1c41      	adds	r1, r0, #1
    3644:	d004      	beq.n	3650 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xd8>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
#else
          if (digitalRead(_miso)) {
    3646:	b2c0      	uxtb	r0, r0
    3648:	f7fe f87e 	bl	1748 <digitalRead>
    364c:	b100      	cbz	r0, 3650 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xd8>
#endif
            reply |= b;
    364e:	432f      	orrs	r7, r5
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
#else
        digitalWrite(_sck, LOW);
    3650:	2100      	movs	r1, #0
    3652:	f898 000f 	ldrb.w	r0, [r8, #15]
    3656:	f7fe f871 	bl	173c <digitalWrite>
#endif
            reply |= b;
          }
        }
      }
      if (_miso != -1) {
    365a:	f998 2011 	ldrsb.w	r2, [r8, #17]
    365e:	3201      	adds	r2, #1
        buffer[i] = reply;
    3660:	bf18      	it	ne
    3662:	f80b 7c01 	strbne.w	r7, [fp, #-1]
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    3666:	f898 200c 	ldrb.w	r2, [r8, #12]
    366a:	b962      	cbnz	r2, 3686 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x10e>
    366c:	006d      	lsls	r5, r5, #1
    366e:	b2ed      	uxtb	r5, r5
    3670:	2d00      	cmp	r5, #0
    3672:	d1af      	bne.n	35d4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
    3674:	4643      	mov	r3, r8
    3676:	46d8      	mov	r8, fp
    3678:	469b      	mov	fp, r3
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    367a:	9b03      	ldr	r3, [sp, #12]
    367c:	4543      	cmp	r3, r8
    367e:	d1a2      	bne.n	35c6 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x4e>
        buffer[i] = reply;
      }
    }
  }
  return;
}
    3680:	b005      	add	sp, #20
    3682:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    3686:	086d      	lsrs	r5, r5, #1
    3688:	2d00      	cmp	r5, #0
    368a:	d1a3      	bne.n	35d4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
    368c:	e7f2      	b.n	3674 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xfc>

      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    368e:	f898 200d 	ldrb.w	r2, [r8, #13]
    3692:	f012 0ff7 	tst.w	r2, #247	; 0xf7
    3696:	d0b0      	beq.n	35fa <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x82>
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    3698:	2101      	movs	r1, #1
    369a:	f898 000f 	ldrb.w	r0, [r8, #15]
    369e:	f7fe f84d 	bl	173c <digitalWrite>

        if (bitdelay_us) {
          delayMicroseconds(bitdelay_us);
        }

        if (_mosi != -1) {
    36a2:	f998 0010 	ldrsb.w	r0, [r8, #16]
    36a6:	1c42      	adds	r2, r0, #1
    36a8:	d004      	beq.n	36b4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x13c>
          if (send & b)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
#else
          digitalWrite(_mosi, send & b);
    36aa:	b2c0      	uxtb	r0, r0
    36ac:	ea0a 0105 	and.w	r1, sl, r5
    36b0:	f7fe f844 	bl	173c <digitalWrite>
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
#else
        digitalWrite(_sck, LOW);
    36b4:	f898 000f 	ldrb.w	r0, [r8, #15]
    36b8:	2100      	movs	r1, #0
    36ba:	f7fe f83f 	bl	173c <digitalWrite>
#endif

        if (_miso != -1) {
    36be:	f998 0011 	ldrsb.w	r0, [r8, #17]
    36c2:	1c43      	adds	r3, r0, #1
    36c4:	d0cf      	beq.n	3666 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xee>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
#else
          if (digitalRead(_miso)) {
    36c6:	b2c0      	uxtb	r0, r0
    36c8:	f7fe f83e 	bl	1748 <digitalRead>
    36cc:	2800      	cmp	r0, #0
    36ce:	d0c4      	beq.n	365a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xe2>
#endif
            reply |= b;
    36d0:	432f      	orrs	r7, r5
    36d2:	e7c2      	b.n	365a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xe2>
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    36d4:	2101      	movs	r1, #1
    36d6:	f898 000f 	ldrb.w	r0, [r8, #15]
    36da:	9201      	str	r2, [sp, #4]
    36dc:	f7fe f82e 	bl	173c <digitalWrite>
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    36e0:	4b07      	ldr	r3, [pc, #28]	; (3700 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x188>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    36e2:	9a01      	ldr	r2, [sp, #4]
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    36e4:	6818      	ldr	r0, [r3, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    36e6:	6811      	ldr	r1, [r2, #0]
    36e8:	fba9 3101 	umull	r3, r1, r9, r1
    36ec:	0c89      	lsrs	r1, r1, #18
    36ee:	fb01 f106 	mul.w	r1, r1, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    36f2:	6823      	ldr	r3, [r4, #0]
    36f4:	1a1b      	subs	r3, r3, r0
    36f6:	4299      	cmp	r1, r3
    36f8:	d8fb      	bhi.n	36f2 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x17a>
    36fa:	e7d2      	b.n	36a2 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x12a>
    36fc:	0007a120 	.word	0x0007a120
    3700:	e0001004 	.word	0xe0001004
    3704:	20001590 	.word	0x20001590
    3708:	431bde83 	.word	0x431bde83

0000370c <Adafruit_SPIDevice::endTransaction()>:

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 */
void Adafruit_SPIDevice::endTransaction(void) {
  if (_spi) {
    370c:	6802      	ldr	r2, [r0, #0]
    370e:	b1f2      	cbz	r2, 374e <Adafruit_SPIDevice::endTransaction()+0x42>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    3710:	7cd3      	ldrb	r3, [r2, #19]
    3712:	b1e3      	cbz	r3, 374e <Adafruit_SPIDevice::endTransaction()+0x42>
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
    3714:	07d8      	lsls	r0, r3, #31
    3716:	d503      	bpl.n	3720 <Adafruit_SPIDevice::endTransaction()+0x14>
    3718:	4b0d      	ldr	r3, [pc, #52]	; (3750 <Adafruit_SPIDevice::endTransaction()+0x44>)
    371a:	6a91      	ldr	r1, [r2, #40]	; 0x28
    371c:	6019      	str	r1, [r3, #0]
    371e:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
    3720:	0799      	lsls	r1, r3, #30
    3722:	d503      	bpl.n	372c <Adafruit_SPIDevice::endTransaction()+0x20>
    3724:	4b0b      	ldr	r3, [pc, #44]	; (3754 <Adafruit_SPIDevice::endTransaction()+0x48>)
    3726:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    3728:	6019      	str	r1, [r3, #0]
    372a:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
    372c:	0758      	lsls	r0, r3, #29
    372e:	d503      	bpl.n	3738 <Adafruit_SPIDevice::endTransaction()+0x2c>
    3730:	4b09      	ldr	r3, [pc, #36]	; (3758 <Adafruit_SPIDevice::endTransaction()+0x4c>)
    3732:	6b11      	ldr	r1, [r2, #48]	; 0x30
    3734:	6019      	str	r1, [r3, #0]
    3736:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
    3738:	0719      	lsls	r1, r3, #28
    373a:	d503      	bpl.n	3744 <Adafruit_SPIDevice::endTransaction()+0x38>
    373c:	4b07      	ldr	r3, [pc, #28]	; (375c <Adafruit_SPIDevice::endTransaction()+0x50>)
    373e:	6b51      	ldr	r1, [r2, #52]	; 0x34
    3740:	6019      	str	r1, [r3, #0]
    3742:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
    3744:	06db      	lsls	r3, r3, #27
    3746:	d502      	bpl.n	374e <Adafruit_SPIDevice::endTransaction()+0x42>
    3748:	6b92      	ldr	r2, [r2, #56]	; 0x38
    374a:	4b05      	ldr	r3, [pc, #20]	; (3760 <Adafruit_SPIDevice::endTransaction()+0x54>)
    374c:	601a      	str	r2, [r3, #0]
    374e:	4770      	bx	lr
    3750:	e000e100 	.word	0xe000e100
    3754:	e000e104 	.word	0xe000e104
    3758:	e000e108 	.word	0xe000e108
    375c:	e000e10c 	.word	0xe000e10c
    3760:	e000e110 	.word	0xe000e110

00003764 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>:
/*!
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 * SPI)
 */
void Adafruit_SPIDevice::beginTransaction(void) {
  if (_spi) {
    3764:	6803      	ldr	r3, [r0, #0]
 *    @brief  Write a buffer or two to the SPI device, with transaction
 * management.
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
    3766:	b470      	push	{r4, r5, r6}
/*!
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 * SPI)
 */
void Adafruit_SPIDevice::beginTransaction(void) {
  if (_spi) {
    3768:	2b00      	cmp	r3, #0
    376a:	d02d      	beq.n	37c8 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x64>
#ifdef BUSIO_HAS_HW_SPI
    _spi->beginTransaction(*_spiSetting);
    376c:	6842      	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    376e:	7cdc      	ldrb	r4, [r3, #19]
    3770:	e892 0022 	ldmia.w	r2, {r1, r5}
    3774:	2c00      	cmp	r4, #0
    3776:	d130      	bne.n	37da <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x76>
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
    3778:	689a      	ldr	r2, [r3, #8]
    377a:	428a      	cmp	r2, r1
    377c:	d05f      	beq.n	383e <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xda>
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
    377e:	4a39      	ldr	r2, [pc, #228]	; (3864 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x100>)
						     720000000,  // PLL3 PFD0
						     528000000,  // PLL2
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();
    3780:	6099      	str	r1, [r3, #8]

			uint32_t cbcmr = CCM_CBCMR;
    3782:	6992      	ldr	r2, [r2, #24]
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
    3784:	4c38      	ldr	r4, [pc, #224]	; (3868 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x104>)
    3786:	f3c2 1601 	ubfx	r6, r2, #4, #2
    378a:	f3c2 6282 	ubfx	r2, r2, #26, #3
    378e:	f854 4026 	ldr.w	r4, [r4, r6, lsl #2]
    3792:	3201      	adds	r2, #1
    3794:	fbb4 f4f2 	udiv	r4, r4, r2
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
    3798:	2900      	cmp	r1, #0
    379a:	d052      	beq.n	3842 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xde>
    379c:	fbb4 f2f1 	udiv	r2, r4, r1

			if (d && clkhz/d > _clock) d++;
    37a0:	b142      	cbz	r2, 37b4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    37a2:	fbb4 f4f2 	udiv	r4, r4, r2
    37a6:	428c      	cmp	r4, r1
    37a8:	bf88      	it	hi
    37aa:	3201      	addhi	r2, #1
			if (d > 257) d= 257;  // max div
    37ac:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
    37b0:	d34b      	bcc.n	384a <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xe6>
    37b2:	4a2e      	ldr	r2, [pc, #184]	; (386c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x108>)
				div = d-2;
			} else {
				div =0;
			}
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);
    37b4:	60da      	str	r2, [r3, #12]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    37b6:	681b      	ldr	r3, [r3, #0]
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
    37b8:	2600      	movs	r6, #0
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
    37ba:	2403      	movs	r4, #3
		port().CCR = _ccr;
		port().TCR = settings.tcr;
		port().CR = LPSPI_CR_MEN;
    37bc:	2101      	movs	r1, #1
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
    37be:	611e      	str	r6, [r3, #16]
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
    37c0:	625c      	str	r4, [r3, #36]	; 0x24
		port().CCR = _ccr;
    37c2:	641a      	str	r2, [r3, #64]	; 0x40
		port().TCR = settings.tcr;
    37c4:	661d      	str	r5, [r3, #96]	; 0x60
		port().CR = LPSPI_CR_MEN;
    37c6:	6119      	str	r1, [r3, #16]
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    37c8:	f990 000e 	ldrsb.w	r0, [r0, #14]
    37cc:	1c43      	adds	r3, r0, #1
    37ce:	d03a      	beq.n	3846 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xe2>
    digitalWrite(_cs, value);
    37d0:	b2c0      	uxtb	r0, r0
    37d2:	2100      	movs	r1, #0
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    37d4:	bc70      	pop	{r4, r5, r6}
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    digitalWrite(_cs, value);
    37d6:	f7fd bfb1 	b.w	173c <digitalWrite>
	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
			__disable_irq();
    37da:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    37dc:	7cda      	ldrb	r2, [r3, #19]
    37de:	07d6      	lsls	r6, r2, #31
    37e0:	d506      	bpl.n	37f0 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x8c>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    37e2:	4c23      	ldr	r4, [pc, #140]	; (3870 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x10c>)
    37e4:	695a      	ldr	r2, [r3, #20]
    37e6:	6826      	ldr	r6, [r4, #0]
    37e8:	4032      	ands	r2, r6
    37ea:	629a      	str	r2, [r3, #40]	; 0x28
				NVIC_ICER0 = interruptSave[0];
    37ec:	6022      	str	r2, [r4, #0]
    37ee:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x02) {
    37f0:	0794      	lsls	r4, r2, #30
    37f2:	d506      	bpl.n	3802 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x9e>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    37f4:	4c1f      	ldr	r4, [pc, #124]	; (3874 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x110>)
    37f6:	699a      	ldr	r2, [r3, #24]
    37f8:	6826      	ldr	r6, [r4, #0]
    37fa:	4032      	ands	r2, r6
    37fc:	62da      	str	r2, [r3, #44]	; 0x2c
				NVIC_ICER1 = interruptSave[1];
    37fe:	6022      	str	r2, [r4, #0]
    3800:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x04) {
    3802:	0756      	lsls	r6, r2, #29
    3804:	d506      	bpl.n	3814 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xb0>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    3806:	4c1c      	ldr	r4, [pc, #112]	; (3878 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x114>)
    3808:	69da      	ldr	r2, [r3, #28]
    380a:	6826      	ldr	r6, [r4, #0]
    380c:	4032      	ands	r2, r6
    380e:	631a      	str	r2, [r3, #48]	; 0x30
				NVIC_ICER2 = interruptSave[2];
    3810:	6022      	str	r2, [r4, #0]
    3812:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x08) {
    3814:	0714      	lsls	r4, r2, #28
    3816:	d506      	bpl.n	3826 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xc2>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    3818:	4c18      	ldr	r4, [pc, #96]	; (387c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x118>)
    381a:	6a1a      	ldr	r2, [r3, #32]
    381c:	6826      	ldr	r6, [r4, #0]
    381e:	4032      	ands	r2, r6
    3820:	635a      	str	r2, [r3, #52]	; 0x34
				NVIC_ICER3 = interruptSave[3];
    3822:	6022      	str	r2, [r4, #0]
    3824:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x10) {
    3826:	06d2      	lsls	r2, r2, #27
    3828:	d505      	bpl.n	3836 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xd2>
				interruptSave[4] = NVIC_ICER4 & interruptMask[4];
    382a:	4c15      	ldr	r4, [pc, #84]	; (3880 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x11c>)
    382c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    382e:	6826      	ldr	r6, [r4, #0]
    3830:	4032      	ands	r2, r6
    3832:	639a      	str	r2, [r3, #56]	; 0x38
				NVIC_ICER4 = interruptSave[4];
    3834:	6022      	str	r2, [r4, #0]
			}
			__enable_irq();
    3836:	b662      	cpsie	i
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
    3838:	689a      	ldr	r2, [r3, #8]
    383a:	428a      	cmp	r2, r1
    383c:	d19f      	bne.n	377e <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x1a>
    383e:	68da      	ldr	r2, [r3, #12]
    3840:	e7b9      	b.n	37b6 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x52>

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
    3842:	4622      	mov	r2, r4
    3844:	e7ac      	b.n	37a0 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x3c>
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    3846:	bc70      	pop	{r4, r5, r6}
    3848:	4770      	bx	lr

			if (d && clkhz/d > _clock) d++;
			if (d > 257) d= 257;  // max div
			if (d > 2) {
    384a:	2a02      	cmp	r2, #2
    384c:	d908      	bls.n	3860 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xfc>
    384e:	3a02      	subs	r2, #2
    3850:	0854      	lsrs	r4, r2, #1
    3852:	0421      	lsls	r1, r4, #16
    3854:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
    3858:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    385c:	430a      	orrs	r2, r1
    385e:	e7a9      	b.n	37b4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    3860:	2200      	movs	r2, #0
    3862:	e7a7      	b.n	37b4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    3864:	400fc000 	.word	0x400fc000
    3868:	200005b4 	.word	0x200005b4
    386c:	007f7fff 	.word	0x007f7fff
    3870:	e000e180 	.word	0xe000e180
    3874:	e000e184 	.word	0xe000e184
    3878:	e000e188 	.word	0xe000e188
    387c:	e000e18c 	.word	0xe000e18c
    3880:	e000e190 	.word	0xe000e190

00003884 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>:

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
    3884:	b510      	push	{r4, lr}
    3886:	4604      	mov	r4, r0
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    3888:	f990 000e 	ldrsb.w	r0, [r0, #14]
    388c:	1c43      	adds	r3, r0, #1
    388e:	d003      	beq.n	3898 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()+0x14>
    digitalWrite(_cs, value);
    3890:	b2c0      	uxtb	r0, r0
    3892:	2101      	movs	r1, #1
    3894:	f7fd ff52 	bl	173c <digitalWrite>
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
    3898:	4620      	mov	r0, r4
}
    389a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
    389e:	f7ff bf35 	b.w	370c <Adafruit_SPIDevice::endTransaction()>
    38a2:	bf00      	nop

000038a4 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>:
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(const uint8_t *buffer, size_t len,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    38a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    38a8:	b083      	sub	sp, #12
    38aa:	460c      	mov	r4, r1
    38ac:	4690      	mov	r8, r2
    38ae:	461d      	mov	r5, r3
    38b0:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    38b4:	4606      	mov	r6, r0
  beginTransactionWithAssertingCS();
    38b6:	f7ff ff55 	bl	3764 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
      _spi->transferBytes(buffer, nullptr, len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
    38ba:	f1b9 0f00 	cmp.w	r9, #0
    38be:	d00d      	beq.n	38dc <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x38>
    38c0:	f10d 0707 	add.w	r7, sp, #7
    38c4:	44a9      	add	r9, r5
      transfer(prefix_buffer[i]);
    38c6:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    38ca:	2201      	movs	r2, #1
    38cc:	4639      	mov	r1, r7
    38ce:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    38d0:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    38d4:	f7ff fe50 	bl	3578 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
      _spi->transferBytes(buffer, nullptr, len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
    38d8:	454d      	cmp	r5, r9
    38da:	d1f4      	bne.n	38c6 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x22>
      transfer(prefix_buffer[i]);
    }
    for (size_t i = 0; i < len; i++) {
    38dc:	f1b8 0f00 	cmp.w	r8, #0
    38e0:	d00e      	beq.n	3900 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x5c>
    38e2:	f10d 0707 	add.w	r7, sp, #7
    38e6:	eb04 0508 	add.w	r5, r4, r8
      transfer(buffer[i]);
    38ea:	f814 3b01 	ldrb.w	r3, [r4], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    38ee:	2201      	movs	r2, #1
    38f0:	4639      	mov	r1, r7
    38f2:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    38f4:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    38f8:	f7ff fe3e 	bl	3578 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
      transfer(prefix_buffer[i]);
    }
    for (size_t i = 0; i < len; i++) {
    38fc:	42ac      	cmp	r4, r5
    38fe:	d1f4      	bne.n	38ea <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x46>
      transfer(buffer[i]);
    }
  }
  endTransactionWithDeassertingCS();
    3900:	4630      	mov	r0, r6
    3902:	f7ff ffbf 	bl	3884 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    3906:	2001      	movs	r0, #1
    3908:	b003      	add	sp, #12
    390a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    390e:	bf00      	nop

00003910 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>:
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
    3910:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3914:	4692      	mov	sl, r2
    3916:	b082      	sub	sp, #8
    3918:	460d      	mov	r5, r1
    391a:	461c      	mov	r4, r3
    391c:	4606      	mov	r6, r0
    391e:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    3922:	f89d 802c 	ldrb.w	r8, [sp, #44]	; 0x2c
  beginTransactionWithAssertingCS();
    3926:	f7ff ff1d 	bl	3764 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
      _spi->transferBytes(write_buffer, nullptr, write_len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
    392a:	f1ba 0f00 	cmp.w	sl, #0
    392e:	d00d      	beq.n	394c <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x3c>
    3930:	f10d 0707 	add.w	r7, sp, #7
    3934:	44aa      	add	sl, r5
      transfer(write_buffer[i]);
    3936:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    393a:	2201      	movs	r2, #1
    393c:	4639      	mov	r1, r7
    393e:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    3940:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    3944:	f7ff fe18 	bl	3578 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
      _spi->transferBytes(write_buffer, nullptr, write_len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
    3948:	4555      	cmp	r5, sl
    394a:	d1f4      	bne.n	3936 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x26>
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    394c:	f1b9 0f00 	cmp.w	r9, #0
    3950:	d00f      	beq.n	3972 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x62>
    3952:	f10d 0707 	add.w	r7, sp, #7
    3956:	44a1      	add	r9, r4
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    3958:	2201      	movs	r2, #1
    395a:	4639      	mov	r1, r7
    395c:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    395e:	f88d 8007 	strb.w	r8, [sp, #7]
  transfer(&data, 1);
    3962:	f7ff fe09 	bl	3578 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
  return data;
    3966:	f89d 3007 	ldrb.w	r3, [sp, #7]
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    read_buffer[i] = transfer(sendvalue);
    396a:	f804 3b01 	strb.w	r3, [r4], #1
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    396e:	454c      	cmp	r4, r9
    3970:	d1f2      	bne.n	3958 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x48>
    }
  }
  DEBUG_SERIAL.println();
#endif

  endTransactionWithDeassertingCS();
    3972:	4630      	mov	r0, r6
    3974:	f7ff ff86 	bl	3884 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>

  return true;
}
    3978:	2001      	movs	r0, #1
    397a:	b002      	add	sp, #8
    397c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00003980 <Adafruit_LIS3MDL::~Adafruit_LIS3MDL()>:
  LIS3MDL_SINGLEMODE = 0b01,     ///< Single-shot conversion
  LIS3MDL_POWERDOWNMODE = 0b11,  ///< Powered-down mode
} lis3mdl_operationmode_t;

/** Class for hardware interfacing with an LIS3MDL magnetometer */
class Adafruit_LIS3MDL : public Adafruit_Sensor {
    3980:	4770      	bx	lr
    3982:	bf00      	nop

00003984 <Adafruit_LIS3MDL::getSensor(sensor_t*)>:
    @brief  Gets the sensor_t device data, Adafruit Unified Sensor format
    @param  sensor Pointer to an Adafruit Unified sensor_t object that we'll
   fill in
*/
/**************************************************************************/
void Adafruit_LIS3MDL::getSensor(sensor_t *sensor) {
    3984:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3986:	460c      	mov	r4, r1
    3988:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    398a:	2228      	movs	r2, #40	; 0x28
    398c:	2100      	movs	r1, #0
    398e:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3990:	2701      	movs	r7, #1
   fill in
*/
/**************************************************************************/
void Adafruit_LIS3MDL::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3992:	f003 fa05 	bl	6da0 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
    3996:	220b      	movs	r2, #11
    3998:	4909      	ldr	r1, [pc, #36]	; (39c0 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x3c>)
    399a:	4620      	mov	r0, r4
    399c:	f003 fe9e 	bl	76dc <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    39a0:	2300      	movs	r3, #0
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
    39a2:	2502      	movs	r5, #2
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
    39a4:	4807      	ldr	r0, [pc, #28]	; (39c4 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    39a6:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
  sensor->max_value = 1600;   // +16 gauss in uTesla
    39a8:	4907      	ldr	r1, [pc, #28]	; (39c8 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    39aa:	6a76      	ldr	r6, [r6, #36]	; 0x24
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
  sensor->max_value = 1600;   // +16 gauss in uTesla
  sensor->resolution = 0.015; // 100/6842 uTesla per LSB at +-4 gauss range
    39ac:	4a07      	ldr	r2, [pc, #28]	; (39cc <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x48>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    39ae:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    39b0:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
    39b2:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
    39b4:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
    39b6:	61e0      	str	r0, [r4, #28]
  sensor->max_value = 1600;   // +16 gauss in uTesla
    39b8:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 0.015; // 100/6842 uTesla per LSB at +-4 gauss range
    39ba:	6222      	str	r2, [r4, #32]
    39bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    39be:	bf00      	nop
    39c0:	20000ee8 	.word	0x20000ee8
    39c4:	c4c80000 	.word	0xc4c80000
    39c8:	44c80000 	.word	0x44c80000
    39cc:	3c75c28f 	.word	0x3c75c28f

000039d0 <Adafruit_LIS3MDL::~Adafruit_LIS3MDL()>:
    39d0:	b510      	push	{r4, lr}
    39d2:	4604      	mov	r4, r0
    39d4:	2128      	movs	r1, #40	; 0x28
    39d6:	f7ff fb23 	bl	3020 <operator delete(void*, unsigned int)>
    39da:	4620      	mov	r0, r4
    39dc:	bd10      	pop	{r4, pc}
    39de:	bf00      	nop

000039e0 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()>:
/**************************************************************************/
/*!
    @brief  Instantiates a new LIS3MDL class
*/
/**************************************************************************/
Adafruit_LIS3MDL::Adafruit_LIS3MDL() {}
    39e0:	2200      	movs	r2, #0
    39e2:	4903      	ldr	r1, [pc, #12]	; (39f0 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()+0x10>)
    39e4:	7602      	strb	r2, [r0, #24]
    39e6:	6001      	str	r1, [r0, #0]
    39e8:	61c2      	str	r2, [r0, #28]
    39ea:	6202      	str	r2, [r0, #32]
    39ec:	4770      	bx	lr
    39ee:	bf00      	nop
    39f0:	20000468 	.word	0x20000468

000039f4 <Adafruit_LIS3MDL::read()>:
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    39f4:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    39f6:	2301      	movs	r3, #1
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    39f8:	b08d      	sub	sp, #52	; 0x34
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    39fa:	2506      	movs	r5, #6
    39fc:	2700      	movs	r7, #0
    39fe:	2628      	movs	r6, #40	; 0x28
    3a00:	6a02      	ldr	r2, [r0, #32]
    3a02:	69c1      	ldr	r1, [r0, #28]
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    3a04:	4604      	mov	r4, r0
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3a06:	9303      	str	r3, [sp, #12]
    3a08:	a806      	add	r0, sp, #24
    3a0a:	9501      	str	r5, [sp, #4]
    3a0c:	9702      	str	r7, [sp, #8]
    3a0e:	9600      	str	r6, [sp, #0]
    3a10:	f7ff fb94 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  XYZDataReg.read(buffer, 6);
    3a14:	462a      	mov	r2, r5
    3a16:	a904      	add	r1, sp, #16
    3a18:	a806      	add	r0, sp, #24
    3a1a:	f7ff fc13 	bl	3244 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
  x = buffer[0];
  x |= buffer[1] << 8;
    3a1e:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3a22:	f89d 1011 	ldrb.w	r1, [sp, #17]
  y = buffer[2];
  y |= buffer[3] << 8;
    3a26:	f89d 0013 	ldrb.w	r0, [sp, #19]

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    3a2a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
  y = buffer[2];
  y |= buffer[3] << 8;
    3a2e:	f89d 2012 	ldrb.w	r2, [sp, #18]
  z = buffer[4];
  z |= buffer[5] << 8;
    3a32:	f89d 5015 	ldrb.w	r5, [sp, #21]
    3a36:	f89d 3014 	ldrb.w	r3, [sp, #20]
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
  y = buffer[2];
  y |= buffer[3] << 8;
    3a3a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  z = buffer[4];
  z |= buffer[5] << 8;

  float scale = 1; // LSB per gauss
  switch (rangeBuffered) {
    3a3e:	7e20      	ldrb	r0, [r4, #24]

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    3a40:	b209      	sxth	r1, r1
  y = buffer[2];
  y |= buffer[3] << 8;
  z = buffer[4];
  z |= buffer[5] << 8;
    3a42:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
  y = buffer[2];
  y |= buffer[3] << 8;
    3a46:	b212      	sxth	r2, r2
    3a48:	2803      	cmp	r0, #3
  z = buffer[4];
  z |= buffer[5] << 8;
    3a4a:	b21b      	sxth	r3, r3

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    3a4c:	80e1      	strh	r1, [r4, #6]
  y = buffer[2];
  y |= buffer[3] << 8;
    3a4e:	8122      	strh	r2, [r4, #8]
  z = buffer[4];
  z |= buffer[5] << 8;
    3a50:	8163      	strh	r3, [r4, #10]
    3a52:	d81e      	bhi.n	3a92 <Adafruit_LIS3MDL::read()+0x9e>
    3a54:	4d10      	ldr	r5, [pc, #64]	; (3a98 <Adafruit_LIS3MDL::read()+0xa4>)
    3a56:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    3a5a:	ed90 6a00 	vldr	s12, [r0]
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    3a5e:	ee07 1a90 	vmov	s15, r1
    3a62:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  y_gauss = (float)y / scale;
    3a66:	ee07 2a90 	vmov	s15, r2
    3a6a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  z_gauss = (float)z / scale;
    3a6e:	ee07 3a90 	vmov	s15, r3
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    3a72:	eec6 5a86 	vdiv.f32	s11, s13, s12
  y_gauss = (float)y / scale;
  z_gauss = (float)z / scale;
    3a76:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
  y_gauss = (float)y / scale;
    3a7a:	eec7 6a06 	vdiv.f32	s13, s14, s12
  z_gauss = (float)z / scale;
    3a7e:	ee87 7a86 	vdiv.f32	s14, s15, s12
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    3a82:	edc4 5a03 	vstr	s11, [r4, #12]
  y_gauss = (float)y / scale;
    3a86:	edc4 6a04 	vstr	s13, [r4, #16]
  z_gauss = (float)z / scale;
    3a8a:	ed84 7a05 	vstr	s14, [r4, #20]
}
    3a8e:	b00d      	add	sp, #52	; 0x34
    3a90:	bdf0      	pop	{r4, r5, r6, r7, pc}
  y |= buffer[3] << 8;
  z = buffer[4];
  z |= buffer[5] << 8;

  float scale = 1; // LSB per gauss
  switch (rangeBuffered) {
    3a92:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    3a96:	e7e2      	b.n	3a5e <Adafruit_LIS3MDL::read()+0x6a>
    3a98:	20000428 	.word	0x20000428

00003a9c <Adafruit_LIS3MDL::getEvent(sensors_event_t*)>:
    @param  event Pointer to an Adafruit Unified sensor_event_t object that
   we'll fill in
    @returns True on successful read
*/
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
    3a9c:	b570      	push	{r4, r5, r6, lr}
    3a9e:	460c      	mov	r4, r1
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    3aa0:	2624      	movs	r6, #36	; 0x24
    @param  event Pointer to an Adafruit Unified sensor_event_t object that
   we'll fill in
    @returns True on successful read
*/
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
    3aa2:	4605      	mov	r5, r0
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    3aa4:	2100      	movs	r1, #0
    3aa6:	4632      	mov	r2, r6
    3aa8:	4620      	mov	r0, r4
    3aaa:	f003 f979 	bl	6da0 <memset>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
    3aae:	4b10      	ldr	r3, [pc, #64]	; (3af0 <Adafruit_LIS3MDL::getEvent(sensors_event_t*)+0x54>)

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
    3ab0:	6a69      	ldr	r1, [r5, #36]	; 0x24
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
    3ab2:	2202      	movs	r2, #2
    3ab4:	681b      	ldr	r3, [r3, #0]
  event->timestamp = millis();

  read();
    3ab6:	4628      	mov	r0, r5
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));

  event->version = sizeof(sensors_event_t);
    3ab8:	6026      	str	r6, [r4, #0]
  event->sensor_id = _sensorID;
    3aba:	6061      	str	r1, [r4, #4]
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
    3abc:	60a2      	str	r2, [r4, #8]
  event->timestamp = millis();
    3abe:	6123      	str	r3, [r4, #16]

  read();
    3ac0:	f7ff ff98 	bl	39f4 <Adafruit_LIS3MDL::read()>

  event->magnetic.x = x_gauss * 100; // microTesla per gauss
    3ac4:	edd5 7a03 	vldr	s15, [r5, #12]
    3ac8:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 3af4 <Adafruit_LIS3MDL::getEvent(sensors_event_t*)+0x58>
  event->magnetic.y = y_gauss * 100; // microTesla per gauss
  event->magnetic.z = z_gauss * 100; // microTesla per gauss

  return true;
}
    3acc:	2001      	movs	r0, #1
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
  event->timestamp = millis();

  read();

  event->magnetic.x = x_gauss * 100; // microTesla per gauss
    3ace:	ee67 7a87 	vmul.f32	s15, s15, s14
    3ad2:	edc4 7a05 	vstr	s15, [r4, #20]
  event->magnetic.y = y_gauss * 100; // microTesla per gauss
    3ad6:	edd5 7a04 	vldr	s15, [r5, #16]
    3ada:	ee67 7a87 	vmul.f32	s15, s15, s14
    3ade:	edc4 7a06 	vstr	s15, [r4, #24]
  event->magnetic.z = z_gauss * 100; // microTesla per gauss
    3ae2:	edd5 7a05 	vldr	s15, [r5, #20]
    3ae6:	ee67 7a87 	vmul.f32	s15, s15, s14
    3aea:	edc4 7a07 	vstr	s15, [r4, #28]

  return true;
}
    3aee:	bd70      	pop	{r4, r5, r6, pc}
    3af0:	20002740 	.word	0x20002740
    3af4:	42c80000 	.word	0x42c80000

00003af8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>:
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    3af8:	b5f0      	push	{r4, r5, r6, r7, lr}
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3afa:	69c3      	ldr	r3, [r0, #28]
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    3afc:	b095      	sub	sp, #84	; 0x54
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3afe:	f04f 0e20 	mov.w	lr, #32
    3b02:	2401      	movs	r4, #1
    3b04:	2700      	movs	r7, #0
    3b06:	6a02      	ldr	r2, [r0, #32]
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    3b08:	4605      	mov	r5, r0
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3b0a:	f8cd e000 	str.w	lr, [sp]
    3b0e:	eb0d 000e 	add.w	r0, sp, lr
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    3b12:	460e      	mov	r6, r1
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3b14:	9403      	str	r4, [sp, #12]
    3b16:	4619      	mov	r1, r3
    3b18:	9401      	str	r4, [sp, #4]
    3b1a:	4623      	mov	r3, r4
    3b1c:	9702      	str	r7, [sp, #8]
    3b1e:	f7ff fb0d 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits performancemodebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG1, 2, 5);
    3b22:	a908      	add	r1, sp, #32
    3b24:	2305      	movs	r3, #5
    3b26:	2202      	movs	r2, #2
    3b28:	a804      	add	r0, sp, #16
    3b2a:	f7ff fc03 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  performancemodebits.write((uint8_t)mode);
    3b2e:	4631      	mov	r1, r6
    3b30:	a804      	add	r0, sp, #16
    3b32:	f7ff fc15 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // write z
  Adafruit_BusIO_Register CTRL_REG4 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG4, 1);
    3b36:	6a2a      	ldr	r2, [r5, #32]
    3b38:	69e9      	ldr	r1, [r5, #28]
    3b3a:	2523      	movs	r5, #35	; 0x23
    3b3c:	4623      	mov	r3, r4
    3b3e:	9702      	str	r7, [sp, #8]
    3b40:	9403      	str	r4, [sp, #12]
    3b42:	a80e      	add	r0, sp, #56	; 0x38
    3b44:	9401      	str	r4, [sp, #4]
    3b46:	9500      	str	r5, [sp, #0]
    3b48:	f7ff faf8 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits performancemodezbits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG4, 2, 2);
    3b4c:	2302      	movs	r3, #2
    3b4e:	a90e      	add	r1, sp, #56	; 0x38
    3b50:	a806      	add	r0, sp, #24
    3b52:	461a      	mov	r2, r3
    3b54:	f7ff fbee 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  performancemodezbits.write((uint8_t)mode);
    3b58:	4631      	mov	r1, r6
    3b5a:	a806      	add	r0, sp, #24
    3b5c:	f7ff fc00 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3b60:	b015      	add	sp, #84	; 0x54
    3b62:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003b64 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>:
    from 0.625 Hz to 80Hz
    @param dataRate Enumerated lis3mdl_dataRate_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    3b64:	2901      	cmp	r1, #1
    @brief  Sets the data rate for the LIS3MDL (controls power consumption)
    from 0.625 Hz to 80Hz
    @param dataRate Enumerated lis3mdl_dataRate_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
    3b66:	b5f0      	push	{r4, r5, r6, r7, lr}
    3b68:	460c      	mov	r4, r1
    3b6a:	b08d      	sub	sp, #52	; 0x34
    3b6c:	4606      	mov	r6, r0
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    3b6e:	d025      	beq.n	3bbc <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x58>
    // set OP to UHP
    setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_300_HZ) {
    3b70:	2903      	cmp	r1, #3
    3b72:	d027      	beq.n	3bc4 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x60>
    // set OP to HP
    setPerformanceMode(LIS3MDL_HIGHMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_560_HZ) {
    3b74:	2905      	cmp	r1, #5
    3b76:	d029      	beq.n	3bcc <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x68>
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    3b78:	2907      	cmp	r1, #7
    3b7a:	d01b      	beq.n	3bb4 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x50>
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
  }
  delay(10);
    3b7c:	200a      	movs	r0, #10
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3b7e:	2501      	movs	r5, #1
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
  }
  delay(10);
    3b80:	f7fd fd42 	bl	1608 <delay>
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3b84:	2700      	movs	r7, #0
    3b86:	6a32      	ldr	r2, [r6, #32]
    3b88:	462b      	mov	r3, r5
    3b8a:	69f1      	ldr	r1, [r6, #28]
    3b8c:	2620      	movs	r6, #32
    3b8e:	a806      	add	r0, sp, #24
    3b90:	9503      	str	r5, [sp, #12]
    3b92:	9501      	str	r5, [sp, #4]
    3b94:	9702      	str	r7, [sp, #8]
    3b96:	9600      	str	r6, [sp, #0]
    3b98:	f7ff fad0 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits dataratebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG1, 4, 1); // includes FAST_ODR
    3b9c:	462b      	mov	r3, r5
    3b9e:	a906      	add	r1, sp, #24
    3ba0:	2204      	movs	r2, #4
    3ba2:	a804      	add	r0, sp, #16
    3ba4:	f7ff fbc6 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  dataratebits.write((uint8_t)dataRate);
    3ba8:	4621      	mov	r1, r4
    3baa:	a804      	add	r0, sp, #16
    3bac:	f7ff fbd8 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3bb0:	b00d      	add	sp, #52	; 0x34
    3bb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
    3bb4:	2100      	movs	r1, #0
    3bb6:	f7ff ff9f 	bl	3af8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3bba:	e7df      	b.n	3b7c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    // set OP to UHP
    setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
    3bbc:	2103      	movs	r1, #3
    3bbe:	f7ff ff9b 	bl	3af8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3bc2:	e7db      	b.n	3b7c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
  }
  if (dataRate == LIS3MDL_DATARATE_300_HZ) {
    // set OP to HP
    setPerformanceMode(LIS3MDL_HIGHMODE);
    3bc4:	2102      	movs	r1, #2
    3bc6:	f7ff ff97 	bl	3af8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3bca:	e7d7      	b.n	3b7c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
  }
  if (dataRate == LIS3MDL_DATARATE_560_HZ) {
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
    3bcc:	2101      	movs	r1, #1
    3bce:	f7ff ff93 	bl	3af8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3bd2:	e7d3      	b.n	3b7c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>

00003bd4 <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>:
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    3bd4:	b570      	push	{r4, r5, r6, lr}
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    3bd6:	6a02      	ldr	r2, [r0, #32]
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    3bd8:	b08c      	sub	sp, #48	; 0x30
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    3bda:	69c0      	ldr	r0, [r0, #28]
    3bdc:	2301      	movs	r3, #1
    3bde:	2400      	movs	r4, #0
    3be0:	2622      	movs	r6, #34	; 0x22
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    3be2:	460d      	mov	r5, r1
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    3be4:	9303      	str	r3, [sp, #12]
    3be6:	4601      	mov	r1, r0
    3be8:	9301      	str	r3, [sp, #4]
    3bea:	a806      	add	r0, sp, #24
    3bec:	9402      	str	r4, [sp, #8]
    3bee:	9600      	str	r6, [sp, #0]
    3bf0:	f7ff faa4 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits opmodebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG3, 2, 0);
    3bf4:	4623      	mov	r3, r4
    3bf6:	a906      	add	r1, sp, #24
    3bf8:	2202      	movs	r2, #2
    3bfa:	a804      	add	r0, sp, #16
    3bfc:	f7ff fb9a 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  opmodebits.write((uint8_t)mode);
    3c00:	4629      	mov	r1, r5
    3c02:	a804      	add	r0, sp, #16
    3c04:	f7ff fbac 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3c08:	b00c      	add	sp, #48	; 0x30
    3c0a:	bd70      	pop	{r4, r5, r6, pc}

00003c0c <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>:
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    3c0c:	b5f0      	push	{r4, r5, r6, r7, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3c0e:	2301      	movs	r3, #1
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    3c10:	b08d      	sub	sp, #52	; 0x34
    3c12:	4604      	mov	r4, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3c14:	2700      	movs	r7, #0
    3c16:	2621      	movs	r6, #33	; 0x21
    3c18:	6a02      	ldr	r2, [r0, #32]
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    3c1a:	460d      	mov	r5, r1
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3c1c:	a806      	add	r0, sp, #24
    3c1e:	69e1      	ldr	r1, [r4, #28]
    3c20:	9303      	str	r3, [sp, #12]
    3c22:	9301      	str	r3, [sp, #4]
    3c24:	9702      	str	r7, [sp, #8]
    3c26:	9600      	str	r6, [sp, #0]
    3c28:	f7ff fa88 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits rangebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 2, 5);
    3c2c:	a906      	add	r1, sp, #24
    3c2e:	2305      	movs	r3, #5
    3c30:	2202      	movs	r2, #2
    3c32:	a804      	add	r0, sp, #16
    3c34:	f7ff fb7e 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  rangebits.write((uint8_t)range);
    3c38:	4629      	mov	r1, r5
    3c3a:	a804      	add	r0, sp, #16
    3c3c:	f7ff fb90 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  rangeBuffered = range;
    3c40:	7625      	strb	r5, [r4, #24]
}
    3c42:	b00d      	add	sp, #52	; 0x34
    3c44:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3c46:	bf00      	nop

00003c48 <Adafruit_LIS3MDL::getRange()>:
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    3c48:	b570      	push	{r4, r5, r6, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3c4a:	2301      	movs	r3, #1
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    3c4c:	b08c      	sub	sp, #48	; 0x30
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3c4e:	2600      	movs	r6, #0
    3c50:	2521      	movs	r5, #33	; 0x21
    3c52:	6a02      	ldr	r2, [r0, #32]
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    3c54:	4604      	mov	r4, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3c56:	69c1      	ldr	r1, [r0, #28]
    3c58:	a806      	add	r0, sp, #24
    3c5a:	9303      	str	r3, [sp, #12]
    3c5c:	9301      	str	r3, [sp, #4]
    3c5e:	9602      	str	r6, [sp, #8]
    3c60:	9500      	str	r5, [sp, #0]
    3c62:	f7ff fa6b 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits rangebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 2, 5);
    3c66:	a906      	add	r1, sp, #24
    3c68:	2305      	movs	r3, #5
    3c6a:	2202      	movs	r2, #2
    3c6c:	a804      	add	r0, sp, #16
    3c6e:	f7ff fb61 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  rangeBuffered = (lis3mdl_range_t)rangebits.read();
    3c72:	a804      	add	r0, sp, #16
    3c74:	f7ff fb66 	bl	3344 <Adafruit_BusIO_RegisterBits::read()>
    3c78:	b2c0      	uxtb	r0, r0
    3c7a:	7620      	strb	r0, [r4, #24]

  return rangeBuffered;
}
    3c7c:	b00c      	add	sp, #48	; 0x30
    3c7e:	bd70      	pop	{r4, r5, r6, pc}

00003c80 <Adafruit_LIS3MDL::reset()>:
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3c80:	b5f0      	push	{r4, r5, r6, r7, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3c82:	2401      	movs	r4, #1
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3c84:	b08d      	sub	sp, #52	; 0x34
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3c86:	2700      	movs	r7, #0
    3c88:	2621      	movs	r6, #33	; 0x21
    3c8a:	6a02      	ldr	r2, [r0, #32]
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3c8c:	4605      	mov	r5, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3c8e:	69c1      	ldr	r1, [r0, #28]
    3c90:	4623      	mov	r3, r4
    3c92:	a806      	add	r0, sp, #24
    3c94:	9403      	str	r4, [sp, #12]
    3c96:	9401      	str	r4, [sp, #4]
    3c98:	9702      	str	r7, [sp, #8]
    3c9a:	9600      	str	r6, [sp, #0]
    3c9c:	f7ff fa4e 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits resetbits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 1, 2);
    3ca0:	4622      	mov	r2, r4
    3ca2:	2302      	movs	r3, #2
    3ca4:	a906      	add	r1, sp, #24
    3ca6:	a804      	add	r0, sp, #16
    3ca8:	f7ff fb44 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  resetbits.write(0x1);
    3cac:	4621      	mov	r1, r4
    3cae:	a804      	add	r0, sp, #16
    3cb0:	f7ff fb56 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
  delay(10);
    3cb4:	200a      	movs	r0, #10
    3cb6:	f7fd fca7 	bl	1608 <delay>

  getRange();
    3cba:	4628      	mov	r0, r5
    3cbc:	f7ff ffc4 	bl	3c48 <Adafruit_LIS3MDL::getRange()>
}
    3cc0:	b00d      	add	sp, #52	; 0x34
    3cc2:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003cc4 <Adafruit_LIS3MDL::_init()>:

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    3cc4:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    3cc6:	2501      	movs	r5, #1

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    3cc8:	b08b      	sub	sp, #44	; 0x2c
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    3cca:	2400      	movs	r4, #0
    3ccc:	270f      	movs	r7, #15
    3cce:	6a02      	ldr	r2, [r0, #32]
    3cd0:	462b      	mov	r3, r5
    3cd2:	69c1      	ldr	r1, [r0, #28]

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    3cd4:	4606      	mov	r6, r0
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    3cd6:	9503      	str	r5, [sp, #12]
    3cd8:	a804      	add	r0, sp, #16
    3cda:	9501      	str	r5, [sp, #4]
    3cdc:	9402      	str	r4, [sp, #8]
    3cde:	9700      	str	r7, [sp, #0]
    3ce0:	f7ff fa2c 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  // make sure we're talking to the right chip
  if (chip_id.read() != 0x3D) {
    3ce4:	a804      	add	r0, sp, #16
    3ce6:	f7ff fafb 	bl	32e0 <Adafruit_BusIO_Register::read()>
    3cea:	283d      	cmp	r0, #61	; 0x3d
    3cec:	d002      	beq.n	3cf4 <Adafruit_LIS3MDL::_init()+0x30>
    // No LIS3MDL detected ... return false
    return false;
    3cee:	4620      	mov	r0, r4
  setRange(LIS3MDL_RANGE_4_GAUSS);

  setOperationMode(LIS3MDL_CONTINUOUSMODE);

  return true;
}
    3cf0:	b00b      	add	sp, #44	; 0x2c
    3cf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (chip_id.read() != 0x3D) {
    // No LIS3MDL detected ... return false
    return false;
  }

  reset();
    3cf4:	4630      	mov	r0, r6
    3cf6:	f7ff ffc3 	bl	3c80 <Adafruit_LIS3MDL::reset()>

  // set high quality performance mode
  setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
    3cfa:	4630      	mov	r0, r6
    3cfc:	2103      	movs	r1, #3
    3cfe:	f7ff fefb 	bl	3af8 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>

  // 155Hz default rate
  setDataRate(LIS3MDL_DATARATE_155_HZ);
    3d02:	4629      	mov	r1, r5
    3d04:	4630      	mov	r0, r6
    3d06:	f7ff ff2d 	bl	3b64 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>

  // lowest range
  setRange(LIS3MDL_RANGE_4_GAUSS);
    3d0a:	4621      	mov	r1, r4
    3d0c:	4630      	mov	r0, r6
    3d0e:	f7ff ff7d 	bl	3c0c <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>

  setOperationMode(LIS3MDL_CONTINUOUSMODE);
    3d12:	4630      	mov	r0, r6
    3d14:	4621      	mov	r1, r4
    3d16:	f7ff ff5d 	bl	3bd4 <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>
    3d1a:	4628      	mov	r0, r5

  return true;
}
    3d1c:	b00b      	add	sp, #44	; 0x2c
    3d1e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003d20 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)>:
 *            The I2C address to be used.
 *    @param  wire
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
    3d20:	b530      	push	{r4, r5, lr}
    3d22:	4604      	mov	r4, r0
  if (!i2c_dev) {
    3d24:	69c0      	ldr	r0, [r0, #28]
 *            The I2C address to be used.
 *    @param  wire
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
    3d26:	b083      	sub	sp, #12
  if (!i2c_dev) {
    3d28:	b168      	cbz	r0, 3d46 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0x26>
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
  }
  spi_dev = NULL;
    3d2a:	2300      	movs	r3, #0

  if (!i2c_dev->begin()) {
    3d2c:	2101      	movs	r1, #1
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
  if (!i2c_dev) {
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
  }
  spi_dev = NULL;
    3d2e:	6223      	str	r3, [r4, #32]

  if (!i2c_dev->begin()) {
    3d30:	f7ff fb66 	bl	3400 <Adafruit_I2CDevice::begin(bool)>
    3d34:	b908      	cbnz	r0, 3d3a <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0x1a>
    return false;
  }
  return _init();
}
    3d36:	b003      	add	sp, #12
    3d38:	bd30      	pop	{r4, r5, pc}
  spi_dev = NULL;

  if (!i2c_dev->begin()) {
    return false;
  }
  return _init();
    3d3a:	4620      	mov	r0, r4
}
    3d3c:	b003      	add	sp, #12
    3d3e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  spi_dev = NULL;

  if (!i2c_dev->begin()) {
    return false;
  }
  return _init();
    3d42:	f7ff bfbf 	b.w	3cc4 <Adafruit_LIS3MDL::_init()>
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
  if (!i2c_dev) {
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
    3d46:	2010      	movs	r0, #16
    3d48:	e88d 0006 	stmia.w	sp, {r1, r2}
    3d4c:	f7ff f964 	bl	3018 <operator new(unsigned int)>
    3d50:	4605      	mov	r5, r0
    3d52:	e89d 0006 	ldmia.w	sp, {r1, r2}
    3d56:	f7ff fb2d 	bl	33b4 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    3d5a:	4628      	mov	r0, r5
    3d5c:	61e5      	str	r5, [r4, #28]
    3d5e:	e7e4      	b.n	3d2a <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0xa>

00003d60 <Adafruit_LIS3MDL::configInterrupt(bool, bool, bool, bool, bool, bool)>:
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3d60:	b5f0      	push	{r4, r5, r6, r7, lr}
    3d62:	b08b      	sub	sp, #44	; 0x2c
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3d64:	f8d0 e020 	ldr.w	lr, [r0, #32]
    3d68:	69c7      	ldr	r7, [r0, #28]
    3d6a:	2001      	movs	r0, #1
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3d6c:	f89d 4044 	ldrb.w	r4, [sp, #68]	; 0x44
    3d70:	f89d c040 	ldrb.w	ip, [sp, #64]	; 0x40
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3d74:	0065      	lsls	r5, r4, #1
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3d76:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3d7a:	9003      	str	r0, [sp, #12]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3d7c:	f045 0508 	orr.w	r5, r5, #8
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3d80:	9001      	str	r0, [sp, #4]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3d82:	ea45 048c 	orr.w	r4, r5, ip, lsl #2
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3d86:	2500      	movs	r5, #0
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3d88:	ea44 1443 	orr.w	r4, r4, r3, lsl #5
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3d8c:	4603      	mov	r3, r0
    3d8e:	2030      	movs	r0, #48	; 0x30
    3d90:	9502      	str	r5, [sp, #8]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3d92:	ea44 1482 	orr.w	r4, r4, r2, lsl #6
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3d96:	4672      	mov	r2, lr
    3d98:	9000      	str	r0, [sp, #0]
    3d9a:	a804      	add	r0, sp, #16
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3d9c:	ea44 14c1 	orr.w	r4, r4, r1, lsl #7
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3da0:	4639      	mov	r1, r7
    3da2:	f7ff f9cb 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  INT_CFG.write(value);
    3da6:	462a      	mov	r2, r5
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3da8:	b2e4      	uxtb	r4, r4
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
  INT_CFG.write(value);
    3daa:	a804      	add	r0, sp, #16
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;
    3dac:	4334      	orrs	r4, r6

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
  INT_CFG.write(value);
    3dae:	4621      	mov	r1, r4
    3db0:	f7ff fa28 	bl	3204 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>
}
    3db4:	b00b      	add	sp, #44	; 0x2c
    3db6:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003db8 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3db8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3dbc:	f04f 0c00 	mov.w	ip, #0
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3dc0:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3dc2:	f8d0 9020 	ldr.w	r9, [r0, #32]
    3dc6:	2401      	movs	r4, #1
    3dc8:	69c0      	ldr	r0, [r0, #28]
    3dca:	f04f 0806 	mov.w	r8, #6
    3dce:	f04f 0e28 	mov.w	lr, #40	; 0x28
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3dd2:	460f      	mov	r7, r1
    3dd4:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3dd6:	4601      	mov	r1, r0
    3dd8:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3dda:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3ddc:	a806      	add	r0, sp, #24
    3dde:	9403      	str	r4, [sp, #12]
    3de0:	4623      	mov	r3, r4
    3de2:	f8cd c008 	str.w	ip, [sp, #8]
    3de6:	f8cd 8004 	str.w	r8, [sp, #4]
    3dea:	f8cd e000 	str.w	lr, [sp]
    3dee:	f7ff f9a5 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    3df2:	4642      	mov	r2, r8
    3df4:	a806      	add	r0, sp, #24
    3df6:	a904      	add	r1, sp, #16
    3df8:	f7ff fa24 	bl	3244 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    3dfc:	b3c8      	cbz	r0, 3e72 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xba>
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3dfe:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    3e02:	eeb1 6b00 	vmov.f64	d6, #16	; 0x40800000  4.0
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;

  return 1;
    3e06:	4620      	mov	r0, r4
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3e08:	ee04 3a10 	vmov	s8, r3
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3e0c:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    3e10:	ee05 3a10 	vmov	s10, r3
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3e14:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3e18:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3e1c:	ee07 3a10 	vmov	s14, r3
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3e20:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3e24:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3e28:	ee24 4b06 	vmul.f64	d4, d4, d6
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3e2c:	ee25 5b06 	vmul.f64	d5, d5, d6
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3e30:	ee27 6b06 	vmul.f64	d6, d7, d6
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3e34:	ed9f 7b12 	vldr	d7, [pc, #72]	; 3e80 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xc8>
    3e38:	ed9f 3b13 	vldr	d3, [pc, #76]	; 3e88 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xd0>
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3e3c:	ee25 5b07 	vmul.f64	d5, d5, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3e40:	ee24 4b07 	vmul.f64	d4, d4, d7
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3e44:	ee26 7b07 	vmul.f64	d7, d6, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3e48:	ee24 4b03 	vmul.f64	d4, d4, d3
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3e4c:	ee25 6b03 	vmul.f64	d6, d5, d3
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3e50:	ee27 7b03 	vmul.f64	d7, d7, d3
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3e54:	eeb7 4bc4 	vcvt.f32.f64	s8, d4
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3e58:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3e5c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3e60:	ed87 4a00 	vstr	s8, [r7]
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3e64:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3e68:	ed85 7a00 	vstr	s14, [r5]

  return 1;
    3e6c:	b00d      	add	sp, #52	; 0x34
    3e6e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);

  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    3e72:	4b07      	ldr	r3, [pc, #28]	; (3e90 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xd8>)
    3e74:	602b      	str	r3, [r5, #0]
    3e76:	6033      	str	r3, [r6, #0]
    3e78:	603b      	str	r3, [r7, #0]
  x = data[0] * 4.0 * 100.0 / 32768.0;
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;

  return 1;
    3e7a:	b00d      	add	sp, #52	; 0x34
    3e7c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    3e80:	00000000 	.word	0x00000000
    3e84:	40590000 	.word	0x40590000
    3e88:	00000000 	.word	0x00000000
    3e8c:	3f000000 	.word	0x3f000000
    3e90:	7fc00000 	.word	0x7fc00000

00003e94 <Adafruit_LSM6DS::~Adafruit_LSM6DS()>:
Adafruit_LSM6DS::Adafruit_LSM6DS(void) {}

/*!
 *    @brief  Cleans up the LSM6DS
 */
Adafruit_LSM6DS::~Adafruit_LSM6DS(void) { delete temp_sensor; }
    3e94:	b510      	push	{r4, lr}
    3e96:	4b05      	ldr	r3, [pc, #20]	; (3eac <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x18>)
    3e98:	4604      	mov	r4, r0
    3e9a:	6c40      	ldr	r0, [r0, #68]	; 0x44
    3e9c:	6023      	str	r3, [r4, #0]
    3e9e:	b110      	cbz	r0, 3ea6 <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x12>
    3ea0:	6803      	ldr	r3, [r0, #0]
    3ea2:	685b      	ldr	r3, [r3, #4]
    3ea4:	4798      	blx	r3
    3ea6:	4620      	mov	r0, r4
    3ea8:	bd10      	pop	{r4, pc}
    3eaa:	bf00      	nop
    3eac:	20000450 	.word	0x20000450

00003eb0 <Adafruit_LSM6DS_Gyro::~Adafruit_LSM6DS_Gyro()>:
  int _sensorID = 0x6D1;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
    3eb0:	4770      	bx	lr
    3eb2:	bf00      	nop

00003eb4 <Adafruit_LSM6DS_Accelerometer::~Adafruit_LSM6DS_Accelerometer()>:
  int _sensorID = 0x6D0;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for accelerometer component of LSM6DS */
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
    3eb4:	4770      	bx	lr
    3eb6:	bf00      	nop

00003eb8 <Adafruit_LSM6DS_Temp::~Adafruit_LSM6DS_Temp()>:
} lsm6ds_hp_filter_t;

class Adafruit_LSM6DS;

/** Adafruit Unified Sensor interface for temperature component of LSM6DS */
class Adafruit_LSM6DS_Temp : public Adafruit_Sensor {
    3eb8:	4770      	bx	lr
    3eba:	bf00      	nop

00003ebc <Adafruit_LSM6DS::~Adafruit_LSM6DS()>:
    3ebc:	b510      	push	{r4, lr}
    3ebe:	4b07      	ldr	r3, [pc, #28]	; (3edc <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x20>)
    3ec0:	4604      	mov	r4, r0
    3ec2:	6c40      	ldr	r0, [r0, #68]	; 0x44
    3ec4:	6023      	str	r3, [r4, #0]
    3ec6:	b110      	cbz	r0, 3ece <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x12>
    3ec8:	6803      	ldr	r3, [r0, #0]
    3eca:	685b      	ldr	r3, [r3, #4]
    3ecc:	4798      	blx	r3
    3ece:	4620      	mov	r0, r4
    3ed0:	2154      	movs	r1, #84	; 0x54
    3ed2:	f7ff f8a5 	bl	3020 <operator delete(void*, unsigned int)>
    3ed6:	4620      	mov	r0, r4
    3ed8:	bd10      	pop	{r4, pc}
    3eda:	bf00      	nop
    3edc:	20000450 	.word	0x20000450

00003ee0 <Adafruit_LSM6DS_Temp::~Adafruit_LSM6DS_Temp()>:
    3ee0:	b510      	push	{r4, lr}
    3ee2:	4604      	mov	r4, r0
    3ee4:	2110      	movs	r1, #16
    3ee6:	f7ff f89b 	bl	3020 <operator delete(void*, unsigned int)>
    3eea:	4620      	mov	r0, r4
    3eec:	bd10      	pop	{r4, pc}
    3eee:	bf00      	nop

00003ef0 <Adafruit_LSM6DS_Accelerometer::~Adafruit_LSM6DS_Accelerometer()>:
  int _sensorID = 0x6D0;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for accelerometer component of LSM6DS */
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
    3ef0:	b510      	push	{r4, lr}
    3ef2:	4604      	mov	r4, r0
    3ef4:	2110      	movs	r1, #16
    3ef6:	f7ff f893 	bl	3020 <operator delete(void*, unsigned int)>
    3efa:	4620      	mov	r0, r4
    3efc:	bd10      	pop	{r4, pc}
    3efe:	bf00      	nop

00003f00 <Adafruit_LSM6DS_Gyro::~Adafruit_LSM6DS_Gyro()>:
  int _sensorID = 0x6D1;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
    3f00:	b510      	push	{r4, lr}
    3f02:	4604      	mov	r4, r0
    3f04:	2110      	movs	r1, #16
    3f06:	f7ff f88b 	bl	3020 <operator delete(void*, unsigned int)>
    3f0a:	4620      	mov	r0, r4
    3f0c:	bd10      	pop	{r4, pc}
    3f0e:	bf00      	nop

00003f10 <Adafruit_LSM6DS_Temp::getEvent(sensors_event_t*)>:
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
    3f10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3f12:	4606      	mov	r6, r0
  _theLSM6DS->_read();
    3f14:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
    3f16:	460c      	mov	r4, r1
  fillTempEvent(temp, t);
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
    3f18:	2524      	movs	r5, #36	; 0x24
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
    3f1a:	6803      	ldr	r3, [r0, #0]
    3f1c:	689b      	ldr	r3, [r3, #8]
    3f1e:	4798      	blx	r3
  _theLSM6DS->fillTempEvent(event, millis());
    3f20:	68f6      	ldr	r6, [r6, #12]
    3f22:	4b08      	ldr	r3, [pc, #32]	; (3f44 <Adafruit_LSM6DS_Temp::getEvent(sensors_event_t*)+0x34>)
  fillTempEvent(temp, t);
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
    3f24:	462a      	mov	r2, r5
    3f26:	4620      	mov	r0, r4
    3f28:	2100      	movs	r1, #0
    3f2a:	681f      	ldr	r7, [r3, #0]
    3f2c:	f002 ff38 	bl	6da0 <memset>
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
    3f30:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    3f32:	230d      	movs	r3, #13
  temp->timestamp = timestamp;
  temp->temperature = temperature;
    3f34:	6972      	ldr	r2, [r6, #20]
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillTempEvent(event, millis());

  return true;
}
    3f36:	2001      	movs	r0, #1
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
    3f38:	6025      	str	r5, [r4, #0]
  temp->sensor_id = _sensorid_temp;
    3f3a:	6061      	str	r1, [r4, #4]
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  temp->timestamp = timestamp;
  temp->temperature = temperature;
    3f3c:	6162      	str	r2, [r4, #20]
void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  temp->timestamp = timestamp;
    3f3e:	6127      	str	r7, [r4, #16]

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    3f40:	60a3      	str	r3, [r4, #8]
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillTempEvent(event, millis());

  return true;
}
    3f42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3f44:	20002740 	.word	0x20002740

00003f48 <Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t*)>:
    @brief  Gets the gyroscope as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
    3f48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3f4a:	4605      	mov	r5, r0
  _theLSM6DS->_read();
    3f4c:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the gyroscope as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
    3f4e:	460c      	mov	r4, r1
  _theLSM6DS->_read();
    3f50:	6803      	ldr	r3, [r0, #0]
    3f52:	689b      	ldr	r3, [r3, #8]
    3f54:	4798      	blx	r3
  _theLSM6DS->fillGyroEvent(event, millis());
    3f56:	68ed      	ldr	r5, [r5, #12]
    3f58:	4b0a      	ldr	r3, [pc, #40]	; (3f84 <Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t*)+0x3c>)
  temp->timestamp = timestamp;
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
    3f5a:	4620      	mov	r0, r4
    3f5c:	2224      	movs	r2, #36	; 0x24
    3f5e:	2100      	movs	r1, #0
    3f60:	681e      	ldr	r6, [r3, #0]
    3f62:	f002 ff1d 	bl	6da0 <memset>
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
    3f66:	6a69      	ldr	r1, [r5, #36]	; 0x24
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
    3f68:	2301      	movs	r3, #1
  gyro->sensor_id = _sensorid_gyro;
    3f6a:	8e6f      	ldrh	r7, [r5, #50]	; 0x32
  gyro->type = SENSOR_TYPE_GYROSCOPE;
    3f6c:	2204      	movs	r2, #4
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
    3f6e:	6161      	str	r1, [r4, #20]
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillGyroEvent(event, millis());

  return true;
}
    3f70:	4618      	mov	r0, r3
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
    3f72:	6aa9      	ldr	r1, [r5, #40]	; 0x28
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
    3f74:	6067      	str	r7, [r4, #4]
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
    3f76:	61a1      	str	r1, [r4, #24]
  gyro->gyro.z = gyroZ;
    3f78:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
    3f7a:	6126      	str	r6, [r4, #16]
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
  gyro->gyro.z = gyroZ;
    3f7c:	61e1      	str	r1, [r4, #28]

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
    3f7e:	60a2      	str	r2, [r4, #8]
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
    3f80:	6023      	str	r3, [r4, #0]
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillGyroEvent(event, millis());

  return true;
}
    3f82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3f84:	20002740 	.word	0x20002740

00003f88 <Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t*)>:
    @brief  Gets the accelerometer as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
    3f88:	b570      	push	{r4, r5, r6, lr}
    3f8a:	4605      	mov	r5, r0
  _theLSM6DS->_read();
    3f8c:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the accelerometer as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
    3f8e:	460c      	mov	r4, r1
  _theLSM6DS->_read();
    3f90:	6803      	ldr	r3, [r0, #0]
    3f92:	689b      	ldr	r3, [r3, #8]
    3f94:	4798      	blx	r3
  _theLSM6DS->fillAccelEvent(event, millis());
    3f96:	68ed      	ldr	r5, [r5, #12]
    3f98:	4b0a      	ldr	r3, [pc, #40]	; (3fc4 <Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t*)+0x3c>)
  gyro->gyro.z = gyroZ;
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
    3f9a:	4620      	mov	r0, r4
    3f9c:	2224      	movs	r2, #36	; 0x24
    3f9e:	2100      	movs	r1, #0
    3fa0:	681e      	ldr	r6, [r3, #0]
    3fa2:	f002 fefd 	bl	6da0 <memset>
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
    3fa6:	69aa      	ldr	r2, [r5, #24]
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
    3fa8:	2301      	movs	r3, #1
  accel->sensor_id = _sensorid_accel;
    3faa:	8e29      	ldrh	r1, [r5, #48]	; 0x30
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
    3fac:	6162      	str	r2, [r4, #20]
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillAccelEvent(event, millis());

  return true;
}
    3fae:	4618      	mov	r0, r3
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
    3fb0:	69ea      	ldr	r2, [r5, #28]

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
    3fb2:	6061      	str	r1, [r4, #4]
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
    3fb4:	61a2      	str	r2, [r4, #24]
  accel->acceleration.z = accZ;
    3fb6:	6a2a      	ldr	r2, [r5, #32]
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
    3fb8:	6126      	str	r6, [r4, #16]
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
  accel->acceleration.z = accZ;
    3fba:	61e2      	str	r2, [r4, #28]
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
    3fbc:	6023      	str	r3, [r4, #0]
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
    3fbe:	60a3      	str	r3, [r4, #8]
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillAccelEvent(event, millis());

  return true;
}
    3fc0:	bd70      	pop	{r4, r5, r6, pc}
    3fc2:	bf00      	nop
    3fc4:	20002740 	.word	0x20002740

00003fc8 <Adafruit_LSM6DS::_read()>:
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    3fc8:	b5f0      	push	{r4, r5, r6, r7, lr}
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    3fca:	2300      	movs	r3, #0
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    3fcc:	b08f      	sub	sp, #60	; 0x3c
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    3fce:	2620      	movs	r6, #32
    3fd0:	250e      	movs	r5, #14
    3fd2:	2701      	movs	r7, #1
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    3fd4:	4604      	mov	r4, r0
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    3fd6:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    3fd8:	6b81      	ldr	r1, [r0, #56]	; 0x38
    3fda:	eb0d 0006 	add.w	r0, sp, r6
    3fde:	9302      	str	r3, [sp, #8]
    3fe0:	9703      	str	r7, [sp, #12]
    3fe2:	9501      	str	r5, [sp, #4]
    3fe4:	9600      	str	r6, [sp, #0]
    3fe6:	f7ff f8a9 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  uint8_t buffer[14];
  data_reg.read(buffer, 14);
    3fea:	462a      	mov	r2, r5
    3fec:	eb0d 0006 	add.w	r0, sp, r6
    3ff0:	a904      	add	r1, sp, #16
    3ff2:	f7ff f927 	bl	3244 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>

  rawTemp = buffer[1] << 8 | buffer[0];
    3ff6:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3ffa:	f89d 7011 	ldrb.w	r7, [sp, #17]
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3ffe:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
    4002:	edd4 6a10 	vldr	s13, [r4, #64]	; 0x40
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    4006:	ea43 2707 	orr.w	r7, r3, r7, lsl #8
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    400a:	f89d 6013 	ldrb.w	r6, [sp, #19]
    400e:	f89d 3012 	ldrb.w	r3, [sp, #18]
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    4012:	b23f      	sxth	r7, r7
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    4014:	f89d 2014 	ldrb.w	r2, [sp, #20]
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    4018:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    401c:	f89d e019 	ldrb.w	lr, [sp, #25]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    4020:	ee07 7a90 	vmov	s15, r7

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    4024:	f89d 3016 	ldrb.w	r3, [sp, #22]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    4028:	f89d 5015 	ldrb.w	r5, [sp, #21]
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    402c:	b236      	sxth	r6, r6

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    402e:	eeb8 6ae7 	vcvt.f32.s32	s12, s15

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    4032:	f89d 0017 	ldrb.w	r0, [sp, #23]

  rawAccX = buffer[9] << 8 | buffer[8];
    4036:	f89d 1018 	ldrb.w	r1, [sp, #24]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    403a:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
  rawGyroZ = buffer[7] << 8 | buffer[6];
    403e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    4042:	f89d c01b 	ldrb.w	ip, [sp, #27]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    4046:	eec6 7a26 	vdiv.f32	s15, s12, s13

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    404a:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
  rawAccY = buffer[11] << 8 | buffer[10];
    404e:	f89d 201a 	ldrb.w	r2, [sp, #26]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    4052:	b22d      	sxth	r5, r5
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    4054:	f89d e01d 	ldrb.w	lr, [sp, #29]
  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    4058:	b200      	sxth	r0, r0

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    405a:	f89d 301c 	ldrb.w	r3, [sp, #28]
  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    405e:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    4062:	8167      	strh	r7, [r4, #10]

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    4064:	b209      	sxth	r1, r1
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    4066:	ea43 230e 	orr.w	r3, r3, lr, lsl #8

  float gyro_scale = 1; // range is in milli-dps per bit!
  switch (gyroRangeBuffered) {
    406a:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    406e:	b212      	sxth	r2, r2
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    4070:	81a6      	strh	r6, [r4, #12]
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    4072:	b21b      	sxth	r3, r3
    4074:	2f0c      	cmp	r7, #12

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    4076:	81e5      	strh	r5, [r4, #14]
  rawGyroZ = buffer[7] << 8 | buffer[6];
    4078:	8220      	strh	r0, [r4, #16]

  rawAccX = buffer[9] << 8 | buffer[8];
    407a:	80a1      	strh	r1, [r4, #4]
  rawAccY = buffer[11] << 8 | buffer[10];
    407c:	80e2      	strh	r2, [r4, #6]
  rawAccZ = buffer[13] << 8 | buffer[12];
    407e:	8123      	strh	r3, [r4, #8]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    4080:	ee77 7a87 	vadd.f32	s15, s15, s14
    4084:	edc4 7a05 	vstr	s15, [r4, #20]
    4088:	d860      	bhi.n	414c <Adafruit_LSM6DS::_read()+0x184>
    408a:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 4168 <Adafruit_LSM6DS::_read()+0x1a0>
    408e:	eb0e 0787 	add.w	r7, lr, r7, lsl #2
    4092:	edd7 7a00 	vldr	s15, [r7]
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4096:	ee07 6a10 	vmov	s14, r6
    409a:	ed9f 5a2f 	vldr	s10, [pc, #188]	; 4158 <Adafruit_LSM6DS::_read()+0x190>
    409e:	eddf 5a2f 	vldr	s11, [pc, #188]	; 415c <Adafruit_LSM6DS::_read()+0x194>
    40a2:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40a6:	ee07 5a10 	vmov	s14, r5
    40aa:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40ae:	ee07 0a10 	vmov	s14, r0
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40b2:	ee26 6a27 	vmul.f32	s12, s12, s15
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;

  float accel_scale = 1; // range is in milli-g per bit!
  switch (accelRangeBuffered) {
    40b6:	f894 0050 	ldrb.w	r0, [r4, #80]	; 0x50
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40ba:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40be:	ee66 6aa7 	vmul.f32	s13, s13, s15
    40c2:	2803      	cmp	r0, #3
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40c4:	ee26 6a05 	vmul.f32	s12, s12, s10
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40c8:	ee67 7a27 	vmul.f32	s15, s14, s15
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40cc:	ee26 7a85 	vmul.f32	s14, s13, s10
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40d0:	ee67 7a85 	vmul.f32	s15, s15, s10
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40d4:	eec7 6a25 	vdiv.f32	s13, s14, s11
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40d8:	ee86 5a25 	vdiv.f32	s10, s12, s11
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40dc:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40e0:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40e4:	ed84 5a09 	vstr	s10, [r4, #36]	; 0x24
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    40e8:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
    40ec:	d831      	bhi.n	4152 <Adafruit_LSM6DS::_read()+0x18a>
    40ee:	4d1c      	ldr	r5, [pc, #112]	; (4160 <Adafruit_LSM6DS::_read()+0x198>)
    40f0:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    40f4:	edd0 7a00 	vldr	s15, [r0]
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    40f8:	ee07 1a10 	vmov	s14, r1
    40fc:	ed9f 5a19 	vldr	s10, [pc, #100]	; 4164 <Adafruit_LSM6DS::_read()+0x19c>
    4100:	eddf 5a16 	vldr	s11, [pc, #88]	; 415c <Adafruit_LSM6DS::_read()+0x194>
    4104:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4108:	ee07 2a10 	vmov	s14, r2
    410c:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4110:	ee07 3a10 	vmov	s14, r3
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4114:	ee26 6a27 	vmul.f32	s12, s12, s15
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4118:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    411c:	ee66 6aa7 	vmul.f32	s13, s13, s15
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4120:	ee26 6a05 	vmul.f32	s12, s12, s10
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4124:	ee67 7a27 	vmul.f32	s15, s14, s15
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4128:	ee26 7a85 	vmul.f32	s14, s13, s10
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    412c:	ee67 7a85 	vmul.f32	s15, s15, s10
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4130:	eec7 6a25 	vdiv.f32	s13, s14, s11
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4134:	ee86 5a25 	vdiv.f32	s10, s12, s11
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4138:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    413c:	edc4 6a07 	vstr	s13, [r4, #28]
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4140:	ed84 5a06 	vstr	s10, [r4, #24]
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4144:	ed84 7a08 	vstr	s14, [r4, #32]
}
    4148:	b00f      	add	sp, #60	; 0x3c
    414a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];

  float gyro_scale = 1; // range is in milli-dps per bit!
  switch (gyroRangeBuffered) {
    414c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    4150:	e7a1      	b.n	4096 <Adafruit_LSM6DS::_read()+0xce>
  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;

  float accel_scale = 1; // range is in milli-g per bit!
  switch (accelRangeBuffered) {
    4152:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    4156:	e7cf      	b.n	40f8 <Adafruit_LSM6DS::_read()+0x130>
    4158:	3c8efa35 	.word	0x3c8efa35
    415c:	447a0000 	.word	0x447a0000
    4160:	20000438 	.word	0x20000438
    4164:	411ce80a 	.word	0x411ce80a
    4168:	200003f4 	.word	0x200003f4

0000416c <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's gyroscope sensor
*/
/**************************************************************************/
void Adafruit_LSM6DS_Gyro::getSensor(sensor_t *sensor) {
    416c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    416e:	460c      	mov	r4, r1
    4170:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    4172:	2228      	movs	r2, #40	; 0x28
    4174:	2100      	movs	r1, #0
    4176:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    4178:	2701      	movs	r7, #1
    @brief  Gets the sensor_t data for the LSM6DS's gyroscope sensor
*/
/**************************************************************************/
void Adafruit_LSM6DS_Gyro::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    417a:	f002 fe11 	bl	6da0 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
    417e:	220b      	movs	r2, #11
    4180:	4909      	ldr	r1, [pc, #36]	; (41a8 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x3c>)
    4182:	4620      	mov	r0, r4
    4184:	f003 faaa 	bl	76dc <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    4188:	2300      	movs	r3, #0
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
    418a:	2504      	movs	r5, #4
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
    418c:	4807      	ldr	r0, [pc, #28]	; (41ac <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    418e:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
  sensor->max_value = +34.91;
    4190:	4907      	ldr	r1, [pc, #28]	; (41b0 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    4192:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
  sensor->max_value = +34.91;
  sensor->resolution = 7.6358e-5; /* 4.375 mdps -> rad/s */
    4194:	4a07      	ldr	r2, [pc, #28]	; (41b4 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x48>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    4196:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    4198:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
    419a:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
    419c:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
    419e:	61e0      	str	r0, [r4, #28]
  sensor->max_value = +34.91;
    41a0:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 7.6358e-5; /* 4.375 mdps -> rad/s */
    41a2:	6222      	str	r2, [r4, #32]
    41a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    41a6:	bf00      	nop
    41a8:	20000ef0 	.word	0x20000ef0
    41ac:	c20ba3d7 	.word	0xc20ba3d7
    41b0:	420ba3d7 	.word	0x420ba3d7
    41b4:	38a02264 	.word	0x38a02264

000041b8 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's accelerometer
*/
/**************************************************************************/
void Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t *sensor) {
    41b8:	b570      	push	{r4, r5, r6, lr}
    41ba:	460c      	mov	r4, r1
    41bc:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    41be:	2228      	movs	r2, #40	; 0x28
    41c0:	2100      	movs	r1, #0
    41c2:	4620      	mov	r0, r4
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
    41c4:	4d0a      	ldr	r5, [pc, #40]	; (41f0 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x38>)
    @brief  Gets the sensor_t data for the LSM6DS's accelerometer
*/
/**************************************************************************/
void Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    41c6:	f002 fdeb 	bl	6da0 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
    41ca:	220b      	movs	r2, #11
    41cc:	4909      	ldr	r1, [pc, #36]	; (41f4 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x3c>)
    41ce:	4620      	mov	r0, r4
    41d0:	f003 fa84 	bl	76dc <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    41d4:	2200      	movs	r2, #0
  sensor->version = 1;
    41d6:	2301      	movs	r3, #1
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
    41d8:	4807      	ldr	r0, [pc, #28]	; (41f8 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    41da:	72e2      	strb	r2, [r4, #11]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
  sensor->resolution = 0.061;     /* 0.061 mg/LSB at +-2g */
    41dc:	4907      	ldr	r1, [pc, #28]	; (41fc <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    41de:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
    41e0:	6262      	str	r2, [r4, #36]	; 0x24

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    41e2:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
    41e4:	61e5      	str	r5, [r4, #28]
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
    41e6:	61a0      	str	r0, [r4, #24]
  sensor->resolution = 0.061;     /* 0.061 mg/LSB at +-2g */
    41e8:	6221      	str	r1, [r4, #32]
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    41ea:	60e3      	str	r3, [r4, #12]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
    41ec:	6163      	str	r3, [r4, #20]
    41ee:	bd70      	pop	{r4, r5, r6, pc}
    41f0:	c31ce80a 	.word	0xc31ce80a
    41f4:	20000efc 	.word	0x20000efc
    41f8:	431ce80a 	.word	0x431ce80a
    41fc:	3d79db23 	.word	0x3d79db23

00004200 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's tenperature
*/
/**************************************************************************/
void Adafruit_LSM6DS_Temp::getSensor(sensor_t *sensor) {
    4200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4202:	460c      	mov	r4, r1
    4204:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    4206:	2228      	movs	r2, #40	; 0x28
    4208:	2100      	movs	r1, #0
    420a:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    420c:	2701      	movs	r7, #1
    @brief  Gets the sensor_t data for the LSM6DS's tenperature
*/
/**************************************************************************/
void Adafruit_LSM6DS_Temp::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    420e:	f002 fdc7 	bl	6da0 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
    4212:	220b      	movs	r2, #11
    4214:	4909      	ldr	r1, [pc, #36]	; (423c <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x3c>)
    4216:	4620      	mov	r0, r4
    4218:	f003 fa60 	bl	76dc <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    421c:	2300      	movs	r3, #0
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
  sensor->max_value = 85;
  sensor->resolution = 1; /* not a great sensor */
    421e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    4222:	250d      	movs	r5, #13
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    4224:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
    4226:	4806      	ldr	r0, [pc, #24]	; (4240 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x40>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    4228:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
  sensor->max_value = 85;
    422a:	4906      	ldr	r1, [pc, #24]	; (4244 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x44>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    422c:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    422e:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
    4230:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    4232:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -40;
    4234:	61e0      	str	r0, [r4, #28]
  sensor->max_value = 85;
    4236:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 1; /* not a great sensor */
    4238:	6222      	str	r2, [r4, #32]
    423a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    423c:	20000f08 	.word	0x20000f08
    4240:	c2200000 	.word	0xc2200000
    4244:	42aa0000 	.word	0x42aa0000

00004248 <Adafruit_LSM6DS::Adafruit_LSM6DS()>:
};

/*!
 *    @brief  Instantiates a new LSM6DS class
 */
Adafruit_LSM6DS::Adafruit_LSM6DS(void) {}
    4248:	2200      	movs	r2, #0
    424a:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
    424e:	b410      	push	{r4}
    4250:	4c07      	ldr	r4, [pc, #28]	; (4270 <Adafruit_LSM6DS::Adafruit_LSM6DS()+0x28>)
    4252:	6401      	str	r1, [r0, #64]	; 0x40
    4254:	6004      	str	r4, [r0, #0]
    4256:	6382      	str	r2, [r0, #56]	; 0x38
    4258:	63c2      	str	r2, [r0, #60]	; 0x3c
    425a:	6442      	str	r2, [r0, #68]	; 0x44
    425c:	6482      	str	r2, [r0, #72]	; 0x48
    425e:	64c2      	str	r2, [r0, #76]	; 0x4c
    4260:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
    4264:	f880 2051 	strb.w	r2, [r0, #81]	; 0x51
    4268:	f85d 4b04 	ldr.w	r4, [sp], #4
    426c:	4770      	bx	lr
    426e:	bf00      	nop
    4270:	20000450 	.word	0x20000450

00004274 <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)>:
 *    @param  sensor_id
 *            The user-defined ID to differentiate different sensors
 *    @return True if initialization was successful, otherwise false.
 */
boolean Adafruit_LSM6DS::begin_I2C(uint8_t i2c_address, TwoWire *wire,
                                   int32_t sensor_id) {
    4274:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4278:	4604      	mov	r4, r0
    427a:	460e      	mov	r6, r1
  delete i2c_dev; // remove old interface
    427c:	6b80      	ldr	r0, [r0, #56]	; 0x38
    427e:	2110      	movs	r1, #16
 *    @param  sensor_id
 *            The user-defined ID to differentiate different sensors
 *    @return True if initialization was successful, otherwise false.
 */
boolean Adafruit_LSM6DS::begin_I2C(uint8_t i2c_address, TwoWire *wire,
                                   int32_t sensor_id) {
    4280:	4617      	mov	r7, r2
    4282:	4698      	mov	r8, r3
  delete i2c_dev; // remove old interface
    4284:	f7fe fecc 	bl	3020 <operator delete(void*, unsigned int)>

  i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
    4288:	2010      	movs	r0, #16
    428a:	f7fe fec5 	bl	3018 <operator new(unsigned int)>
    428e:	4605      	mov	r5, r0
    4290:	4631      	mov	r1, r6
    4292:	463a      	mov	r2, r7
    4294:	f7ff f88e 	bl	33b4 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    4298:	63a5      	str	r5, [r4, #56]	; 0x38

  if (!i2c_dev->begin()) {
    429a:	4628      	mov	r0, r5
    429c:	2101      	movs	r1, #1
    429e:	f7ff f8af 	bl	3400 <Adafruit_I2CDevice::begin(bool)>
    42a2:	b908      	cbnz	r0, 42a8 <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)+0x34>
    return false;
  }

  return _init(sensor_id);
}
    42a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if (!i2c_dev->begin()) {
    return false;
  }

  return _init(sensor_id);
    42a8:	6823      	ldr	r3, [r4, #0]
    42aa:	4641      	mov	r1, r8
    42ac:	4620      	mov	r0, r4
    42ae:	68db      	ldr	r3, [r3, #12]
}
    42b0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  if (!i2c_dev->begin()) {
    return false;
  }

  return _init(sensor_id);
    42b4:	4718      	bx	r3
    42b6:	bf00      	nop

000042b8 <Adafruit_LSM6DS::reset()>:
/**************************************************************************/
/*!
    @brief Resets the sensor to its power-on state, clearing all registers and
   memory
*/
void Adafruit_LSM6DS::reset(void) {
    42b8:	b570      	push	{r4, r5, r6, lr}

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    42ba:	2401      	movs	r4, #1
/**************************************************************************/
/*!
    @brief Resets the sensor to its power-on state, clearing all registers and
   memory
*/
void Adafruit_LSM6DS::reset(void) {
    42bc:	b08c      	sub	sp, #48	; 0x30

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    42be:	2500      	movs	r5, #0
    42c0:	2612      	movs	r6, #18
    42c2:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    42c4:	6b81      	ldr	r1, [r0, #56]	; 0x38
    42c6:	462b      	mov	r3, r5
    42c8:	a806      	add	r0, sp, #24
    42ca:	9403      	str	r4, [sp, #12]
    42cc:	9401      	str	r4, [sp, #4]
    42ce:	9502      	str	r5, [sp, #8]
    42d0:	9600      	str	r6, [sp, #0]
    42d2:	f7fe ff33 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits sw_reset =
      Adafruit_BusIO_RegisterBits(&ctrl3, 1, 0);
    42d6:	a906      	add	r1, sp, #24
    42d8:	462b      	mov	r3, r5
    42da:	4622      	mov	r2, r4
    42dc:	a804      	add	r0, sp, #16
    42de:	f7ff f829 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  // Adafruit_BusIO_RegisterBits boot = Adafruit_BusIO_RegisterBits(&ctrl3, 1,
  // 7);

  sw_reset.write(true);
    42e2:	4621      	mov	r1, r4
    42e4:	a804      	add	r0, sp, #16
    42e6:	f7ff f83b 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
    42ea:	e002      	b.n	42f2 <Adafruit_LSM6DS::reset()+0x3a>

  while (sw_reset.read()) {
    delay(1);
    42ec:	2001      	movs	r0, #1
    42ee:	f7fd f98b 	bl	1608 <delay>
  // Adafruit_BusIO_RegisterBits boot = Adafruit_BusIO_RegisterBits(&ctrl3, 1,
  // 7);

  sw_reset.write(true);

  while (sw_reset.read()) {
    42f2:	a804      	add	r0, sp, #16
    42f4:	f7ff f826 	bl	3344 <Adafruit_BusIO_RegisterBits::read()>
    42f8:	2800      	cmp	r0, #0
    42fa:	d1f7      	bne.n	42ec <Adafruit_LSM6DS::reset()+0x34>
    delay(1);
  }
}
    42fc:	b00c      	add	sp, #48	; 0x30
    42fe:	bd70      	pop	{r4, r5, r6, pc}

00004300 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>:
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    4300:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    4302:	2301      	movs	r3, #1
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    4304:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    4306:	6b87      	ldr	r7, [r0, #56]	; 0x38
    4308:	2610      	movs	r6, #16
    430a:	2400      	movs	r4, #0
    430c:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    430e:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    4310:	9303      	str	r3, [sp, #12]
    4312:	4639      	mov	r1, r7
    4314:	9301      	str	r3, [sp, #4]
    4316:	a806      	add	r0, sp, #24
    4318:	4623      	mov	r3, r4
    431a:	9402      	str	r4, [sp, #8]
    431c:	9600      	str	r6, [sp, #0]
    431e:	f7fe ff0d 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits accel_data_rate =
      Adafruit_BusIO_RegisterBits(&ctrl1, 4, 4);
    4322:	2304      	movs	r3, #4
    4324:	a906      	add	r1, sp, #24
    4326:	eb0d 0006 	add.w	r0, sp, r6
    432a:	461a      	mov	r2, r3
    432c:	f7ff f802 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  accel_data_rate.write(data_rate);
    4330:	4629      	mov	r1, r5
    4332:	eb0d 0006 	add.w	r0, sp, r6
    4336:	f7ff f813 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    433a:	b00d      	add	sp, #52	; 0x34
    433c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    433e:	bf00      	nop

00004340 <Adafruit_LSM6DS::setAccelRange(accel_range)>:
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    4340:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    4342:	2301      	movs	r3, #1
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    4344:	b08d      	sub	sp, #52	; 0x34
    4346:	4604      	mov	r4, r0

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    4348:	2710      	movs	r7, #16
    434a:	2600      	movs	r6, #0
    434c:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    434e:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    4350:	a806      	add	r0, sp, #24
    4352:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    4354:	9303      	str	r3, [sp, #12]
    4356:	9301      	str	r3, [sp, #4]
    4358:	4633      	mov	r3, r6
    435a:	9602      	str	r6, [sp, #8]
    435c:	9700      	str	r7, [sp, #0]
    435e:	f7fe feed 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits accel_range =
      Adafruit_BusIO_RegisterBits(&ctrl1, 2, 2);
    4362:	2302      	movs	r3, #2
    4364:	a906      	add	r1, sp, #24
    4366:	eb0d 0007 	add.w	r0, sp, r7
    436a:	461a      	mov	r2, r3
    436c:	f7fe ffe2 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  accel_range.write(new_range);
    4370:	4629      	mov	r1, r5
    4372:	eb0d 0007 	add.w	r0, sp, r7
    4376:	f7fe fff3 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  accelRangeBuffered = new_range;
    437a:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
}
    437e:	b00d      	add	sp, #52	; 0x34
    4380:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4382:	bf00      	nop

00004384 <Adafruit_LSM6DS::setGyroDataRate(data_rate)>:
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    4384:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    4386:	2301      	movs	r3, #1
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    4388:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    438a:	6b87      	ldr	r7, [r0, #56]	; 0x38
    438c:	2400      	movs	r4, #0
    438e:	2611      	movs	r6, #17
    4390:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    4392:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    4394:	9303      	str	r3, [sp, #12]
    4396:	4639      	mov	r1, r7
    4398:	9301      	str	r3, [sp, #4]
    439a:	a806      	add	r0, sp, #24
    439c:	4623      	mov	r3, r4
    439e:	9402      	str	r4, [sp, #8]
    43a0:	9600      	str	r6, [sp, #0]
    43a2:	f7fe fecb 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits gyro_data_rate =
      Adafruit_BusIO_RegisterBits(&ctrl2, 4, 4);
    43a6:	2304      	movs	r3, #4
    43a8:	a906      	add	r1, sp, #24
    43aa:	a804      	add	r0, sp, #16
    43ac:	461a      	mov	r2, r3
    43ae:	f7fe ffc1 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  gyro_data_rate.write(data_rate);
    43b2:	4629      	mov	r1, r5
    43b4:	a804      	add	r0, sp, #16
    43b6:	f7fe ffd3 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    43ba:	b00d      	add	sp, #52	; 0x34
    43bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    43be:	bf00      	nop

000043c0 <Adafruit_LSM6DS::setGyroRange(gyro_range)>:
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    43c0:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    43c2:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    43c4:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    43c6:	2500      	movs	r5, #0
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    43c8:	4604      	mov	r4, r0

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    43ca:	2301      	movs	r3, #1
    43cc:	6b80      	ldr	r0, [r0, #56]	; 0x38
    43ce:	2711      	movs	r7, #17
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    43d0:	460e      	mov	r6, r1

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    43d2:	9303      	str	r3, [sp, #12]
    43d4:	4601      	mov	r1, r0
    43d6:	9301      	str	r3, [sp, #4]
    43d8:	a806      	add	r0, sp, #24
    43da:	462b      	mov	r3, r5
    43dc:	9502      	str	r5, [sp, #8]
    43de:	9700      	str	r7, [sp, #0]
    43e0:	f7fe feac 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits gyro_range =
      Adafruit_BusIO_RegisterBits(&ctrl2, 4, 0);
    43e4:	462b      	mov	r3, r5
    43e6:	a906      	add	r1, sp, #24
    43e8:	2204      	movs	r2, #4
    43ea:	a804      	add	r0, sp, #16
    43ec:	f7fe ffa2 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  gyro_range.write(new_range);
    43f0:	4631      	mov	r1, r6
    43f2:	a804      	add	r0, sp, #16
    43f4:	f7fe ffb4 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  gyroRangeBuffered = new_range;
    43f8:	f884 6051 	strb.w	r6, [r4, #81]	; 0x51
}
    43fc:	b00d      	add	sp, #52	; 0x34
    43fe:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004400 <Adafruit_LSM6DS::_init(long)>:

/*!  @brief  Unique subclass initializer post i2c/spi init
 *   @param sensor_id Optional unique ID for the sensor set
 *   @returns True if chip identified and initialized
 */
bool Adafruit_LSM6DS::_init(int32_t sensor_id) {
    4400:	b510      	push	{r4, lr}
    4402:	4604      	mov	r4, r0
  (void)sensor_id;

  // Enable accelerometer with 104 Hz data rate, 4G
  setAccelDataRate(LSM6DS_RATE_104_HZ);
    4404:	2104      	movs	r1, #4
    4406:	f7ff ff7b 	bl	4300 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>
  setAccelRange(LSM6DS_ACCEL_RANGE_4_G);
    440a:	2102      	movs	r1, #2
    440c:	4620      	mov	r0, r4
    440e:	f7ff ff97 	bl	4340 <Adafruit_LSM6DS::setAccelRange(accel_range)>

  // Enable gyro with 104 Hz data rate, 2000 dps
  setGyroDataRate(LSM6DS_RATE_104_HZ);
    4412:	4620      	mov	r0, r4
    4414:	2104      	movs	r1, #4
    4416:	f7ff ffb5 	bl	4384 <Adafruit_LSM6DS::setGyroDataRate(data_rate)>
  setGyroRange(LSM6DS_GYRO_RANGE_2000_DPS);
    441a:	4620      	mov	r0, r4
    441c:	210c      	movs	r1, #12
    441e:	f7ff ffcf 	bl	43c0 <Adafruit_LSM6DS::setGyroRange(gyro_range)>

  delay(10);
    4422:	200a      	movs	r0, #10
    4424:	f7fd f8f0 	bl	1608 <delay>

  // delete objects if sensor is reinitialized
  delete temp_sensor;
    4428:	6c60      	ldr	r0, [r4, #68]	; 0x44
    442a:	b110      	cbz	r0, 4432 <Adafruit_LSM6DS::_init(long)+0x32>
    442c:	6803      	ldr	r3, [r0, #0]
    442e:	685b      	ldr	r3, [r3, #4]
    4430:	4798      	blx	r3
  delete accel_sensor;
    4432:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    4434:	b110      	cbz	r0, 443c <Adafruit_LSM6DS::_init(long)+0x3c>
    4436:	6803      	ldr	r3, [r0, #0]
    4438:	685b      	ldr	r3, [r3, #4]
    443a:	4798      	blx	r3
  delete gyro_sensor;
    443c:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    443e:	b110      	cbz	r0, 4446 <Adafruit_LSM6DS::_init(long)+0x46>
    4440:	6803      	ldr	r3, [r0, #0]
    4442:	685b      	ldr	r3, [r3, #4]
    4444:	4798      	blx	r3

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
    4446:	2010      	movs	r0, #16
    4448:	f7fe fde6 	bl	3018 <operator new(unsigned int)>
/** Adafruit Unified Sensor interface for temperature component of LSM6DS */
class Adafruit_LSM6DS_Temp : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the temp sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Temp(Adafruit_LSM6DS *parent) { _theLSM6DS = parent; }
    444c:	490f      	ldr	r1, [pc, #60]	; (448c <Adafruit_LSM6DS::_init(long)+0x8c>)
    444e:	4603      	mov	r3, r0
    4450:	f44f 62da 	mov.w	r2, #1744	; 0x6d0
    4454:	6460      	str	r0, [r4, #68]	; 0x44
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
    4456:	2010      	movs	r0, #16
    4458:	60dc      	str	r4, [r3, #12]
    445a:	6019      	str	r1, [r3, #0]
    445c:	609a      	str	r2, [r3, #8]
    445e:	f7fe fddb 	bl	3018 <operator new(unsigned int)>
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the accelerometer
     sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Accelerometer(Adafruit_LSM6DS *parent) {
    4462:	490b      	ldr	r1, [pc, #44]	; (4490 <Adafruit_LSM6DS::_init(long)+0x90>)
    4464:	4603      	mov	r3, r0
    4466:	f240 62d1 	movw	r2, #1745	; 0x6d1
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    446a:	2010      	movs	r0, #16
  delete temp_sensor;
  delete accel_sensor;
  delete gyro_sensor;

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
    446c:	64a3      	str	r3, [r4, #72]	; 0x48
    _theLSM6DS = parent;
    446e:	60dc      	str	r4, [r3, #12]
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the accelerometer
     sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Accelerometer(Adafruit_LSM6DS *parent) {
    4470:	6019      	str	r1, [r3, #0]
    4472:	609a      	str	r2, [r3, #8]
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    4474:	f7fe fdd0 	bl	3018 <operator new(unsigned int)>
/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the gyro sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Gyro(Adafruit_LSM6DS *parent) { _theLSM6DS = parent; }
    4478:	4906      	ldr	r1, [pc, #24]	; (4494 <Adafruit_LSM6DS::_init(long)+0x94>)
    447a:	4603      	mov	r3, r0
    447c:	f240 62d2 	movw	r2, #1746	; 0x6d2

  return false;
};
    4480:	2000      	movs	r0, #0
    4482:	60dc      	str	r4, [r3, #12]
  delete accel_sensor;
  delete gyro_sensor;

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    4484:	64e3      	str	r3, [r4, #76]	; 0x4c
    4486:	6019      	str	r1, [r3, #0]
    4488:	609a      	str	r2, [r3, #8]

  return false;
};
    448a:	bd10      	pop	{r4, pc}
    448c:	20000508 	.word	0x20000508
    4490:	20000524 	.word	0x20000524
    4494:	200004ec 	.word	0x200004ec

00004498 <Adafruit_LSM6DS::configIntOutputs(bool, bool)>:
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    4498:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    449a:	f8d0 c03c 	ldr.w	ip, [r0, #60]	; 0x3c
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    449e:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    44a0:	f8d0 e038 	ldr.w	lr, [r0, #56]	; 0x38
    44a4:	2401      	movs	r4, #1
    44a6:	2300      	movs	r3, #0
    44a8:	2712      	movs	r7, #18
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    44aa:	460e      	mov	r6, r1
    44ac:	4615      	mov	r5, r2

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    44ae:	4671      	mov	r1, lr
    44b0:	4662      	mov	r2, ip
    44b2:	9302      	str	r3, [sp, #8]
    44b4:	a806      	add	r0, sp, #24
    44b6:	9403      	str	r4, [sp, #12]
    44b8:	9401      	str	r4, [sp, #4]
    44ba:	9700      	str	r7, [sp, #0]
    44bc:	f7fe fe3e 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits ppod_bits =
      Adafruit_BusIO_RegisterBits(&ctrl3, 2, 4);
    44c0:	a906      	add	r1, sp, #24
    44c2:	2304      	movs	r3, #4
    44c4:	2202      	movs	r2, #2
    44c6:	a804      	add	r0, sp, #16
    44c8:	f7fe ff34 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  ppod_bits.write((active_low << 1) | open_drain);
    44cc:	a804      	add	r0, sp, #16
    44ce:	ea45 0146 	orr.w	r1, r5, r6, lsl #1
    44d2:	f7fe ff45 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    44d6:	b00d      	add	sp, #52	; 0x34
    44d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    44da:	bf00      	nop

000044dc <Adafruit_LSM6DS::configInt1(bool, bool, bool, bool, bool)>:
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    44dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    44e0:	4692      	mov	sl, r2
    44e2:	461e      	mov	r6, r3
    44e4:	b093      	sub	sp, #76	; 0x4c

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    44e6:	2401      	movs	r4, #1
    44e8:	2500      	movs	r5, #0
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    44ea:	4680      	mov	r8, r0

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    44ec:	270d      	movs	r7, #13
    44ee:	6b80      	ldr	r0, [r0, #56]	; 0x38
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    44f0:	4689      	mov	r9, r1

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    44f2:	ea46 064a 	orr.w	r6, r6, sl, lsl #1
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    44f6:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
    44fa:	462b      	mov	r3, r5
    44fc:	4601      	mov	r1, r0
    44fe:	9700      	str	r7, [sp, #0]
    4500:	a806      	add	r0, sp, #24
    4502:	9403      	str	r4, [sp, #12]
    4504:	9401      	str	r4, [sp, #4]
    4506:	9502      	str	r5, [sp, #8]
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    4508:	f89d b070 	ldrb.w	fp, [sp, #112]	; 0x70
    450c:	f89d 7074 	ldrb.w	r7, [sp, #116]	; 0x74

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    4510:	f7fe fe14 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    4514:	ea46 0189 	orr.w	r1, r6, r9, lsl #2

  Adafruit_BusIO_Register md1cfg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_MD1_CFG);
    4518:	265e      	movs	r6, #94	; 0x5e

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    451a:	462a      	mov	r2, r5
    451c:	a806      	add	r0, sp, #24
    451e:	ea41 11cb 	orr.w	r1, r1, fp, lsl #7
    4522:	f7fe fe6f 	bl	3204 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>

  Adafruit_BusIO_Register md1cfg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_MD1_CFG);
    4526:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
    452a:	f8d8 1038 	ldr.w	r1, [r8, #56]	; 0x38
    452e:	462b      	mov	r3, r5
    4530:	9403      	str	r4, [sp, #12]
    4532:	a80c      	add	r0, sp, #48	; 0x30
    4534:	9502      	str	r5, [sp, #8]
    4536:	9401      	str	r4, [sp, #4]
    4538:	9600      	str	r6, [sp, #0]
    453a:	f7fe fdff 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits wu = Adafruit_BusIO_RegisterBits(&md1cfg, 1, 5);
    453e:	4622      	mov	r2, r4
    4540:	a90c      	add	r1, sp, #48	; 0x30
    4542:	2305      	movs	r3, #5
    4544:	a804      	add	r0, sp, #16
    4546:	f7fe fef5 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  wu.write(wakeup);
    454a:	4639      	mov	r1, r7
    454c:	a804      	add	r0, sp, #16
    454e:	f7fe ff07 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    4552:	b013      	add	sp, #76	; 0x4c
    4554:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004558 <Adafruit_LSM6DS::configInt2(bool, bool, bool)>:
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    4558:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    455c:	f8d0 c03c 	ldr.w	ip, [r0, #60]	; 0x3c
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    4560:	b08c      	sub	sp, #48	; 0x30

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    4562:	6b80      	ldr	r0, [r0, #56]	; 0x38
    4564:	f04f 0e0e 	mov.w	lr, #14
    4568:	2500      	movs	r5, #0
    456a:	2601      	movs	r6, #1
    456c:	f8cd e000 	str.w	lr, [sp]
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    4570:	460f      	mov	r7, r1
    4572:	4690      	mov	r8, r2
    4574:	461c      	mov	r4, r3

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    4576:	4662      	mov	r2, ip
    4578:	4601      	mov	r1, r0
    457a:	462b      	mov	r3, r5
    457c:	a806      	add	r0, sp, #24
    457e:	9603      	str	r6, [sp, #12]
    4580:	9601      	str	r6, [sp, #4]
    4582:	9502      	str	r5, [sp, #8]
    4584:	f7fe fdda 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits int2_drdy_bits =
      Adafruit_BusIO_RegisterBits(&int2_ctrl, 3, 0);
    4588:	462b      	mov	r3, r5
    458a:	a906      	add	r1, sp, #24
    458c:	2203      	movs	r2, #3
    458e:	a804      	add	r0, sp, #16
    4590:	f7fe fed0 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  int2_drdy_bits.write((drdy_temp << 2) | (drdy_g << 1) | drdy_xl);
    4594:	a804      	add	r0, sp, #16
    4596:	ea44 0148 	orr.w	r1, r4, r8, lsl #1
    459a:	ea41 0187 	orr.w	r1, r1, r7, lsl #2
    459e:	f7fe fedf 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    45a2:	b00c      	add	sp, #48	; 0x30
    45a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000045a8 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    45a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    45ac:	f04f 0c28 	mov.w	ip, #40	; 0x28
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    45b0:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    45b2:	f8d0 903c 	ldr.w	r9, [r0, #60]	; 0x3c
    45b6:	f04f 0e00 	mov.w	lr, #0
    45ba:	6b80      	ldr	r0, [r0, #56]	; 0x38
    45bc:	f04f 0806 	mov.w	r8, #6
    45c0:	2401      	movs	r4, #1
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    45c2:	460f      	mov	r7, r1
    45c4:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    45c6:	4601      	mov	r1, r0
    45c8:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    45ca:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    45cc:	a806      	add	r0, sp, #24
    45ce:	9403      	str	r4, [sp, #12]
    45d0:	4673      	mov	r3, lr
    45d2:	f8cd e008 	str.w	lr, [sp, #8]
    45d6:	f8cd 8004 	str.w	r8, [sp, #4]
    45da:	f8cd c000 	str.w	ip, [sp]
    45de:	f7fe fdad 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!accel_data.read((uint8_t *)data, sizeof(data))) {
    45e2:	4642      	mov	r2, r8
    45e4:	a806      	add	r0, sp, #24
    45e6:	a904      	add	r1, sp, #16
    45e8:	f7fe fe2c 	bl	3244 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    45ec:	b388      	cbz	r0, 4652 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xaa>
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    45ee:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    45f2:	eeb1 4b00 	vmov.f64	d4, #16	; 0x40800000  4.0
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;

  return 1;
    45f6:	4620      	mov	r0, r4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    45f8:	ee05 3a10 	vmov	s10, r3
  y = data[1] * 4.0 / 32768.0;
    45fc:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    4600:	ee06 3a10 	vmov	s12, r3
  z = data[2] * 4.0 / 32768.0;
    4604:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4608:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;
    460c:	ee07 3a10 	vmov	s14, r3
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
  y = data[1] * 4.0 / 32768.0;
    4610:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
  z = data[2] * 4.0 / 32768.0;
    4614:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4618:	ee25 5b04 	vmul.f64	d5, d5, d4
  y = data[1] * 4.0 / 32768.0;
    461c:	ee26 6b04 	vmul.f64	d6, d6, d4
  z = data[2] * 4.0 / 32768.0;
    4620:	ee27 7b04 	vmul.f64	d7, d7, d4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4624:	ed9f 4b0e 	vldr	d4, [pc, #56]	; 4660 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xb8>
    4628:	ee25 5b04 	vmul.f64	d5, d5, d4
  y = data[1] * 4.0 / 32768.0;
    462c:	ee26 6b04 	vmul.f64	d6, d6, d4
  z = data[2] * 4.0 / 32768.0;
    4630:	ee27 7b04 	vmul.f64	d7, d7, d4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4634:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
  y = data[1] * 4.0 / 32768.0;
    4638:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 4.0 / 32768.0;
    463c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4640:	ed87 5a00 	vstr	s10, [r7]
  y = data[1] * 4.0 / 32768.0;
    4644:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 4.0 / 32768.0;
    4648:	ed85 7a00 	vstr	s14, [r5]

  return 1;
}
    464c:	b00d      	add	sp, #52	; 0x34
    464e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);

  if (!accel_data.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    4652:	4b05      	ldr	r3, [pc, #20]	; (4668 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xc0>)
    4654:	602b      	str	r3, [r5, #0]
    4656:	6033      	str	r3, [r6, #0]
    4658:	603b      	str	r3, [r7, #0]
  x = data[0] * 4.0 / 32768.0;
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;

  return 1;
}
    465a:	b00d      	add	sp, #52	; 0x34
    465c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4660:	00000000 	.word	0x00000000
    4664:	3f000000 	.word	0x3f000000
    4668:	7fc00000 	.word	0x7fc00000
    466c:	00000000 	.word	0x00000000

00004670 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    4670:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    4674:	f04f 0c22 	mov.w	ip, #34	; 0x22
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    4678:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    467a:	f8d0 903c 	ldr.w	r9, [r0, #60]	; 0x3c
    467e:	f04f 0e00 	mov.w	lr, #0
    4682:	6b80      	ldr	r0, [r0, #56]	; 0x38
    4684:	f04f 0806 	mov.w	r8, #6
    4688:	2401      	movs	r4, #1
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    468a:	460f      	mov	r7, r1
    468c:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    468e:	4601      	mov	r1, r0
    4690:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    4692:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    4694:	a806      	add	r0, sp, #24
    4696:	9403      	str	r4, [sp, #12]
    4698:	4673      	mov	r3, lr
    469a:	f8cd e008 	str.w	lr, [sp, #8]
    469e:	f8cd 8004 	str.w	r8, [sp, #4]
    46a2:	f8cd c000 	str.w	ip, [sp]
    46a6:	f7fe fd49 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!gyro_data.read((uint8_t *)data, sizeof(data))) {
    46aa:	4642      	mov	r2, r8
    46ac:	a806      	add	r0, sp, #24
    46ae:	a904      	add	r1, sp, #16
    46b0:	f7fe fdc8 	bl	3244 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    46b4:	b388      	cbz	r0, 471a <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xaa>
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    46b6:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;

  return 1;
    46ba:	4620      	mov	r0, r4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    46bc:	ee04 3a10 	vmov	s8, r3
  y = data[1] * 2000.0 / 32768.0;
    46c0:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    46c4:	ee05 3a10 	vmov	s10, r3
  z = data[2] * 2000.0 / 32768.0;
    46c8:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    46cc:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;
    46d0:	ee07 3a10 	vmov	s14, r3
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
  y = data[1] * 2000.0 / 32768.0;
    46d4:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  z = data[2] * 2000.0 / 32768.0;
    46d8:	eeb8 6bc7 	vcvt.f64.s32	d6, s14
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    46dc:	ed9f 7b12 	vldr	d7, [pc, #72]	; 4728 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xb8>
    46e0:	ed9f 3b13 	vldr	d3, [pc, #76]	; 4730 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xc0>
  y = data[1] * 2000.0 / 32768.0;
    46e4:	ee25 5b07 	vmul.f64	d5, d5, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    46e8:	ee24 4b07 	vmul.f64	d4, d4, d7
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;
    46ec:	ee26 7b07 	vmul.f64	d7, d6, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    46f0:	ee24 4b03 	vmul.f64	d4, d4, d3
  y = data[1] * 2000.0 / 32768.0;
    46f4:	ee25 6b03 	vmul.f64	d6, d5, d3
  z = data[2] * 2000.0 / 32768.0;
    46f8:	ee27 7b03 	vmul.f64	d7, d7, d3
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    46fc:	eeb7 4bc4 	vcvt.f32.f64	s8, d4
  y = data[1] * 2000.0 / 32768.0;
    4700:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 2000.0 / 32768.0;
    4704:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    4708:	ed87 4a00 	vstr	s8, [r7]
  y = data[1] * 2000.0 / 32768.0;
    470c:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 2000.0 / 32768.0;
    4710:	ed85 7a00 	vstr	s14, [r5]

  return 1;
}
    4714:	b00d      	add	sp, #52	; 0x34
    4716:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);

  if (!gyro_data.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    471a:	4b07      	ldr	r3, [pc, #28]	; (4738 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xc8>)
    471c:	602b      	str	r3, [r5, #0]
    471e:	6033      	str	r3, [r6, #0]
    4720:	603b      	str	r3, [r7, #0]
  x = data[0] * 2000.0 / 32768.0;
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;

  return 1;
}
    4722:	b00d      	add	sp, #52	; 0x34
    4724:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4728:	00000000 	.word	0x00000000
    472c:	409f4000 	.word	0x409f4000
    4730:	00000000 	.word	0x00000000
    4734:	3f000000 	.word	0x3f000000
    4738:	7fc00000 	.word	0x7fc00000

0000473c <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()>:
    473c:	4b03      	ldr	r3, [pc, #12]	; (474c <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()+0x10>)
    473e:	b510      	push	{r4, lr}
    4740:	4604      	mov	r4, r0
    4742:	6003      	str	r3, [r0, #0]
    4744:	f7ff fba6 	bl	3e94 <Adafruit_LSM6DS::~Adafruit_LSM6DS()>
    4748:	4620      	mov	r0, r4
    474a:	bd10      	pop	{r4, pc}
    474c:	200004a8 	.word	0x200004a8

00004750 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()>:
    4750:	4b05      	ldr	r3, [pc, #20]	; (4768 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()+0x18>)
    4752:	b510      	push	{r4, lr}
    4754:	4604      	mov	r4, r0
    4756:	6003      	str	r3, [r0, #0]
    4758:	f7ff fb9c 	bl	3e94 <Adafruit_LSM6DS::~Adafruit_LSM6DS()>
    475c:	2154      	movs	r1, #84	; 0x54
    475e:	4620      	mov	r0, r4
    4760:	f7fe fc5e 	bl	3020 <operator delete(void*, unsigned int)>
    4764:	4620      	mov	r0, r4
    4766:	bd10      	pop	{r4, pc}
    4768:	200004a8 	.word	0x200004a8

0000476c <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()>:
#include "Adafruit_LSM6DSOX.h"

/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}
    476c:	b510      	push	{r4, lr}
    476e:	4604      	mov	r4, r0
    4770:	f7ff fd6a 	bl	4248 <Adafruit_LSM6DS::Adafruit_LSM6DS()>
    4774:	4b01      	ldr	r3, [pc, #4]	; (477c <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()+0x10>)
    4776:	4620      	mov	r0, r4
    4778:	6023      	str	r3, [r4, #0]
    477a:	bd10      	pop	{r4, pc}
    477c:	200004a8 	.word	0x200004a8

00004780 <Adafruit_LSM6DSOX::_init(long)>:

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    4780:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    4784:	6b83      	ldr	r3, [r0, #56]	; 0x38
/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    4786:	b09a      	sub	sp, #104	; 0x68
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    4788:	2501      	movs	r5, #1
    478a:	2400      	movs	r4, #0
    478c:	270f      	movs	r7, #15
    478e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    4790:	4606      	mov	r6, r0
    4792:	4688      	mov	r8, r1
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    4794:	a808      	add	r0, sp, #32
    4796:	4619      	mov	r1, r3
    4798:	9503      	str	r5, [sp, #12]
    479a:	4623      	mov	r3, r4
    479c:	9501      	str	r5, [sp, #4]
    479e:	9402      	str	r4, [sp, #8]
    47a0:	9700      	str	r7, [sp, #0]
    47a2:	f7fe fccb 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    47a6:	a808      	add	r0, sp, #32
    47a8:	f7fe fd9a 	bl	32e0 <Adafruit_BusIO_Register::read()>
    47ac:	286c      	cmp	r0, #108	; 0x6c
    47ae:	d003      	beq.n	47b8 <Adafruit_LSM6DSOX::_init(long)+0x38>
    return false;
    47b0:	4620      	mov	r0, r4

  // call base class _init()
  Adafruit_LSM6DS::_init(sensor_id);

  return true;
}
    47b2:	b01a      	add	sp, #104	; 0x68
    47b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
    47b8:	fa1f f388 	uxth.w	r3, r8
  _sensorid_gyro = sensor_id + 1;
  _sensorid_temp = sensor_id + 2;

  reset();
    47bc:	4630      	mov	r0, r6
  Adafruit_BusIO_RegisterBits bdu = Adafruit_BusIO_RegisterBits(&ctrl3, 1, 6);
  bdu.write(true);

  // Disable I3C
  Adafruit_BusIO_Register ctrl_9 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL9_XL);
    47be:	2718      	movs	r7, #24
  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
  _sensorid_gyro = sensor_id + 1;
    47c0:	1959      	adds	r1, r3, r5
  _sensorid_temp = sensor_id + 2;
    47c2:	1c9a      	adds	r2, r3, #2

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
    47c4:	8633      	strh	r3, [r6, #48]	; 0x30
  _sensorid_gyro = sensor_id + 1;
    47c6:	8671      	strh	r1, [r6, #50]	; 0x32
  _sensorid_temp = sensor_id + 2;
    47c8:	86b2      	strh	r2, [r6, #52]	; 0x34

  reset();
    47ca:	f7ff fd75 	bl	42b8 <Adafruit_LSM6DS::reset()>

  // Block Data Update
  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL3_C);
    47ce:	2312      	movs	r3, #18
    47d0:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
    47d2:	a80e      	add	r0, sp, #56	; 0x38
    47d4:	6bb1      	ldr	r1, [r6, #56]	; 0x38
    47d6:	9300      	str	r3, [sp, #0]
    47d8:	4623      	mov	r3, r4
    47da:	9503      	str	r5, [sp, #12]
    47dc:	9402      	str	r4, [sp, #8]
    47de:	9501      	str	r5, [sp, #4]
    47e0:	f7fe fcac 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits bdu = Adafruit_BusIO_RegisterBits(&ctrl3, 1, 6);
    47e4:	462a      	mov	r2, r5
    47e6:	a90e      	add	r1, sp, #56	; 0x38
    47e8:	2306      	movs	r3, #6
    47ea:	a804      	add	r0, sp, #16
    47ec:	f7fe fda2 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  bdu.write(true);
    47f0:	4629      	mov	r1, r5
    47f2:	a804      	add	r0, sp, #16
    47f4:	f7fe fdb4 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // Disable I3C
  Adafruit_BusIO_Register ctrl_9 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL9_XL);
    47f8:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
    47fa:	6bb1      	ldr	r1, [r6, #56]	; 0x38
    47fc:	4623      	mov	r3, r4
    47fe:	9503      	str	r5, [sp, #12]
    4800:	a814      	add	r0, sp, #80	; 0x50
    4802:	9402      	str	r4, [sp, #8]
    4804:	9501      	str	r5, [sp, #4]
    4806:	9700      	str	r7, [sp, #0]
    4808:	f7fe fc98 	bl	313c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits i3c_disable_bit =
      Adafruit_BusIO_RegisterBits(&ctrl_9, 1, 1);
    480c:	462b      	mov	r3, r5
    480e:	462a      	mov	r2, r5
    4810:	a914      	add	r1, sp, #80	; 0x50
    4812:	eb0d 0007 	add.w	r0, sp, r7
    4816:	f7fe fd8d 	bl	3334 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  i3c_disable_bit.write(true);
    481a:	4629      	mov	r1, r5
    481c:	eb0d 0007 	add.w	r0, sp, r7
    4820:	f7fe fd9e 	bl	3360 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // call base class _init()
  Adafruit_LSM6DS::_init(sensor_id);
    4824:	4641      	mov	r1, r8
    4826:	4630      	mov	r0, r6
    4828:	f7ff fdea 	bl	4400 <Adafruit_LSM6DS::_init(long)>
    482c:	4628      	mov	r0, r5

  return true;
}
    482e:	b01a      	add	sp, #104	; 0x68
    4830:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004834 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>:
	if (interruptMask[n >> 5] == 0) {
		interruptMasksUsed &= ~(1 << (n >> 5));
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    4834:	b470      	push	{r4, r5, r6}
    uint8_t *p_read = (uint8_t*)retbuf;
    size_t count_read = count;

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 
    4836:	f240 2501 	movw	r5, #513	; 0x201
    483a:	6804      	ldr	r4, [r0, #0]
    483c:	6125      	str	r5, [r4, #16]

	while (count > 0) {
    483e:	b31b      	cbz	r3, 4888 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
    4840:	461e      	mov	r6, r3
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    4842:	b1f1      	cbz	r1, 4882 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4e>
    4844:	780d      	ldrb	r5, [r1, #0]
    4846:	3101      	adds	r1, #1
		count--; // how many bytes left to output.
    4848:	3b01      	subs	r3, #1
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    484a:	6665      	str	r5, [r4, #100]	; 0x64
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    484c:	6f25      	ldr	r5, [r4, #112]	; 0x70
    484e:	07ad      	lsls	r5, r5, #30
    4850:	d406      	bmi.n	4860 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
				uint8_t b = port().RDR;  // Read any pending RX bytes in
    4852:	6f65      	ldr	r5, [r4, #116]	; 0x74
				if (p_read) *p_read++ = b; 
				count_read--;
    4854:	3e01      	subs	r6, #1
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
				uint8_t b = port().RDR;  // Read any pending RX bytes in
    4856:	b2ed      	uxtb	r5, r5
				if (p_read) *p_read++ = b; 
    4858:	b112      	cbz	r2, 4860 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
    485a:	7015      	strb	r5, [r2, #0]
    485c:	3201      	adds	r2, #1
    485e:	6804      	ldr	r4, [r0, #0]
				count_read--;
			}
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;
    4860:	6965      	ldr	r5, [r4, #20]
	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
    4862:	07ed      	lsls	r5, r5, #31
    4864:	d5f2      	bpl.n	484c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x18>

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
    4866:	2b00      	cmp	r3, #0
    4868:	d1eb      	bne.n	4842 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0xe>
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;

	}

	// now lets wait for all of the read bytes to be returned...
	while (count_read) {
    486a:	b16e      	cbz	r6, 4888 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    486c:	6801      	ldr	r1, [r0, #0]
		if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    486e:	6f0b      	ldr	r3, [r1, #112]	; 0x70
    4870:	079b      	lsls	r3, r3, #30
    4872:	d4fc      	bmi.n	486e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x3a>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
    4874:	6f4b      	ldr	r3, [r1, #116]	; 0x74
    4876:	b2db      	uxtb	r3, r3
			if (p_read) *p_read++ = b; 
    4878:	b10a      	cbz	r2, 487e <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4a>
    487a:	7013      	strb	r3, [r2, #0]
    487c:	3201      	adds	r2, #1
			count_read--;
    487e:	3e01      	subs	r6, #1
    4880:	e7f3      	b.n	486a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x36>
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    4882:	f890 503c 	ldrb.w	r5, [r0, #60]	; 0x3c
    4886:	e7df      	b.n	4848 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x14>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
			if (p_read) *p_read++ = b; 
			count_read--;
		}
	}
}
    4888:	bc70      	pop	{r4, r5, r6}
    488a:	4770      	bx	lr

0000488c <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    488c:	b10b      	cbz	r3, 4892 <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    488e:	f7ff bfd1 	b.w	4834 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>
    4892:	4770      	bx	lr

00004894 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    4894:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    4898:	f890 00a2 	ldrb.w	r0, [r0, #162]	; 0xa2
	}
    489c:	1a10      	subs	r0, r2, r0
    489e:	4770      	bx	lr

000048a0 <TwoWire::peek()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    48a0:	f890 30a2 	ldrb.w	r3, [r0, #162]	; 0xa2
    48a4:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    48a8:	429a      	cmp	r2, r3
    48aa:	d902      	bls.n	48b2 <TwoWire::peek()+0x12>
		return rxBuffer[rxBufferIndex];
    48ac:	4403      	add	r3, r0
    48ae:	7e98      	ldrb	r0, [r3, #26]
    48b0:	4770      	bx	lr
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    48b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    48b6:	4770      	bx	lr

000048b8 <TwoWire::flush()>:
	virtual void flush(void) {
    48b8:	4770      	bx	lr
    48ba:	bf00      	nop

000048bc <TwoWire::write(unsigned char)>:
}


size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    48bc:	f8b0 3130 	ldrh.w	r3, [r0, #304]	; 0x130
    48c0:	b193      	cbz	r3, 48e8 <TwoWire::write(unsigned char)+0x2c>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    48c2:	f890 312f 	ldrb.w	r3, [r0, #303]	; 0x12f
    48c6:	2b88      	cmp	r3, #136	; 0x88
    48c8:	d80b      	bhi.n	48e2 <TwoWire::write(unsigned char)+0x26>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    48ca:	18c2      	adds	r2, r0, r3
{
}


size_t TwoWire::write(uint8_t data)
{
    48cc:	b410      	push	{r4}
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    48ce:	1c5c      	adds	r4, r3, #1
		return 1;
    48d0:	2301      	movs	r3, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    48d2:	f880 412f 	strb.w	r4, [r0, #303]	; 0x12f
		return 1;
	}
	return 0;
}
    48d6:	4618      	mov	r0, r3
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    48d8:	f882 10a5 	strb.w	r1, [r2, #165]	; 0xa5
		return 1;
	}
	return 0;
}
    48dc:	f85d 4b04 	ldr.w	r4, [sp], #4
    48e0:	4770      	bx	lr
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	// int printf(const char *format, ...) __attribute__ ((format (printf, 2, 3)));

  protected:
	void setWriteError(int err = 1) { write_error = err; }
    48e2:	2201      	movs	r2, #1
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    48e4:	2300      	movs	r3, #0
    48e6:	7102      	strb	r2, [r0, #4]
		}
		txBuffer[txBufferLength++] = data;
		return 1;
	}
	return 0;
}
    48e8:	4618      	mov	r0, r3
    48ea:	4770      	bx	lr

000048ec <TwoWire::write(unsigned char const*, unsigned int)>:

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    48ec:	b538      	push	{r3, r4, r5, lr}
    48ee:	4605      	mov	r5, r0
	if (transmitting || slave_mode) {
    48f0:	f8b0 0130 	ldrh.w	r0, [r0, #304]	; 0x130
    48f4:	b190      	cbz	r0, 491c <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    48f6:	f895 312f 	ldrb.w	r3, [r5, #303]	; 0x12f
    48fa:	4614      	mov	r4, r2
    48fc:	f1c3 0289 	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    4900:	4294      	cmp	r4, r2
    4902:	d80c      	bhi.n	491e <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    4904:	f105 00a5 	add.w	r0, r5, #165	; 0xa5
    4908:	4622      	mov	r2, r4
    490a:	4418      	add	r0, r3
    490c:	f002 f94a 	bl	6ba4 <memcpy>
		txBufferLength += quantity;
    4910:	f895 312f 	ldrb.w	r3, [r5, #303]	; 0x12f
    4914:	4620      	mov	r0, r4
    4916:	441c      	add	r4, r3
    4918:	f885 412f 	strb.w	r4, [r5, #303]	; 0x12f
		return quantity;
	}
	return 0;
}
    491c:	bd38      	pop	{r3, r4, r5, pc}
    491e:	4614      	mov	r4, r2
    4920:	2201      	movs	r2, #1
    4922:	712a      	strb	r2, [r5, #4]
    4924:	e7ee      	b.n	4904 <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    4926:	bf00      	nop

00004928 <TwoWire::force_clock()>:
	if (qty > BUFFER_LENGTH) qty = BUFFER_LENGTH;
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
    4928:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    492c:	4683      	mov	fp, r0
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    492e:	4840      	ldr	r0, [pc, #256]	; (4a30 <TwoWire::force_clock()+0x108>)
	if (qty > BUFFER_LENGTH) qty = BUFFER_LENGTH;
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
    4930:	b083      	sub	sp, #12
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    4932:	2515      	movs	r5, #21
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    4934:	f8db a014 	ldr.w	sl, [fp, #20]
    4938:	f89b 6018 	ldrb.w	r6, [fp, #24]
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    493c:	f89b 3019 	ldrb.w	r3, [fp, #25]
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    4940:	eb0a 1606 	add.w	r6, sl, r6, lsl #4
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4944:	493b      	ldr	r1, [pc, #236]	; (4a34 <TwoWire::force_clock()+0x10c>)
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    4946:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    494a:	f8df e0ec 	ldr.w	lr, [pc, #236]	; 4a38 <TwoWire::force_clock()+0x110>
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    494e:	7a36      	ldrb	r6, [r6, #8]
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4950:	460c      	mov	r4, r1
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    4952:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    4956:	0136      	lsls	r6, r6, #4
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4958:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 4a3c <TwoWire::force_clock()+0x114>
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    495c:	011b      	lsls	r3, r3, #4
bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    495e:	1987      	adds	r7, r0, r6
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
    4960:	f850 8006 	ldr.w	r8, [r0, r6]
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    4964:	eb00 0c03 	add.w	ip, r0, r3
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
    4968:	58c6      	ldr	r6, [r0, r3]
bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    496a:	68f8      	ldr	r0, [r7, #12]
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    496c:	687b      	ldr	r3, [r7, #4]
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    496e:	f8dc 700c 	ldr.w	r7, [ip, #12]
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    4972:	9300      	str	r3, [sp, #0]
    4974:	601d      	str	r5, [r3, #0]
	*portSetRegister(sda_pin) = sda_mask;
    4976:	f8c8 0084 	str.w	r0, [r8, #132]	; 0x84
	*portModeRegister(sda_pin) |= sda_mask;
    497a:	f8d8 3004 	ldr.w	r3, [r8, #4]
	*portConfigRegister(scl_pin) = 5 | 0x10;
    497e:	f8dc 2004 	ldr.w	r2, [ip, #4]
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
    4982:	4303      	orrs	r3, r0
	*portConfigRegister(scl_pin) = 5 | 0x10;
    4984:	9201      	str	r2, [sp, #4]
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
    4986:	f8c8 3004 	str.w	r3, [r8, #4]
	*portConfigRegister(scl_pin) = 5 | 0x10;
    498a:	6015      	str	r5, [r2, #0]
	*portSetRegister(scl_pin) = scl_mask;
    498c:	f8c6 7084 	str.w	r7, [r6, #132]	; 0x84
	*portModeRegister(scl_pin) |= scl_mask;
    4990:	6873      	ldr	r3, [r6, #4]
    4992:	433b      	orrs	r3, r7
    4994:	6073      	str	r3, [r6, #4]
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4996:	6809      	ldr	r1, [r1, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4998:	f8de 3000 	ldr.w	r3, [lr]
    499c:	fba9 3203 	umull	r3, r2, r9, r3
    49a0:	0c92      	lsrs	r2, r2, #18
    49a2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    49a6:	0052      	lsls	r2, r2, #1
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    49a8:	6823      	ldr	r3, [r4, #0]
    49aa:	1a5b      	subs	r3, r3, r1
    49ac:	429a      	cmp	r2, r3
    49ae:	d8fb      	bhi.n	49a8 <TwoWire::force_clock()+0x80>
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    49b0:	4a20      	ldr	r2, [pc, #128]	; (4a34 <TwoWire::force_clock()+0x10c>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    49b2:	2509      	movs	r5, #9
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    49b4:	f8df c084 	ldr.w	ip, [pc, #132]	; 4a3c <TwoWire::force_clock()+0x114>
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    49b8:	4691      	mov	r9, r2
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
    49ba:	f8d8 3008 	ldr.w	r3, [r8, #8]
		  && (*portInputRegister(scl_pin) & scl_mask)) {
    49be:	4218      	tst	r0, r3
    49c0:	d002      	beq.n	49c8 <TwoWire::force_clock()+0xa0>
    49c2:	68b3      	ldr	r3, [r6, #8]
    49c4:	421f      	tst	r7, r3
    49c6:	d131      	bne.n	4a2c <TwoWire::force_clock()+0x104>
			// success, both pins are high
			ret = true;
			break;
		}
		*portClearRegister(scl_pin) = scl_mask;
    49c8:	f8c6 7088 	str.w	r7, [r6, #136]	; 0x88
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    49cc:	6814      	ldr	r4, [r2, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    49ce:	f8de 1000 	ldr.w	r1, [lr]
    49d2:	fbac 3101 	umull	r3, r1, ip, r1
    49d6:	0c89      	lsrs	r1, r1, #18
    49d8:	eb01 0181 	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    49dc:	6813      	ldr	r3, [r2, #0]
    49de:	1b1b      	subs	r3, r3, r4
    49e0:	4299      	cmp	r1, r3
    49e2:	d8fb      	bhi.n	49dc <TwoWire::force_clock()+0xb4>
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
    49e4:	f8c6 7084 	str.w	r7, [r6, #132]	; 0x84
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    49e8:	f8d9 4000 	ldr.w	r4, [r9]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    49ec:	f8de 1000 	ldr.w	r1, [lr]
    49f0:	fbac 3101 	umull	r3, r1, ip, r1
    49f4:	0c89      	lsrs	r1, r1, #18
    49f6:	eb01 0181 	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    49fa:	6813      	ldr	r3, [r2, #0]
    49fc:	1b1b      	subs	r3, r3, r4
    49fe:	4299      	cmp	r1, r3
    4a00:	d8fb      	bhi.n	49fa <TwoWire::force_clock()+0xd2>
	*portModeRegister(sda_pin) |= sda_mask;
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
	*portModeRegister(scl_pin) |= scl_mask;
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
    4a02:	3d01      	subs	r5, #1
    4a04:	d1d9      	bne.n	49ba <TwoWire::force_clock()+0x92>
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
	bool ret = false;
    4a06:	4628      	mov	r0, r5
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
		delayMicroseconds(5);
	}
	// return control of pins to I2C
	*(portConfigRegister(sda_pin)) = hardware.sda_pins[sda_pin_index_].mux_val;
    4a08:	f89b 3018 	ldrb.w	r3, [fp, #24]
    4a0c:	9a00      	ldr	r2, [sp, #0]
    4a0e:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
    4a12:	68db      	ldr	r3, [r3, #12]
    4a14:	6013      	str	r3, [r2, #0]
	*(portConfigRegister(scl_pin)) = hardware.scl_pins[scl_pin_index_].mux_val;
    4a16:	f89b 3019 	ldrb.w	r3, [fp, #25]
    4a1a:	9a01      	ldr	r2, [sp, #4]
    4a1c:	eb0a 1a03 	add.w	sl, sl, r3, lsl #4
    4a20:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
    4a24:	6013      	str	r3, [r2, #0]
	return ret;
}
    4a26:	b003      	add	sp, #12
    4a28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
		  && (*portInputRegister(scl_pin) & scl_mask)) {
			// success, both pins are high
			ret = true;
    4a2c:	2001      	movs	r0, #1
    4a2e:	e7eb      	b.n	4a08 <TwoWire::force_clock()+0xe0>
    4a30:	200006dc 	.word	0x200006dc
    4a34:	e0001004 	.word	0xe0001004
    4a38:	20001590 	.word	0x20001590
    4a3c:	431bde83 	.word	0x431bde83

00004a40 <TwoWire::wait_idle()>:
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
    4a40:	490d      	ldr	r1, [pc, #52]	; (4a78 <TwoWire::wait_idle()+0x38>)
    4a42:	6902      	ldr	r2, [r0, #16]
//   01   EPF = End Packet Flag
//      2 RDF = Receive Data Flag
//      1 TDF = Transmit Data Flag

bool TwoWire::wait_idle()
{
    4a44:	b510      	push	{r4, lr}
    4a46:	680c      	ldr	r4, [r1, #0]
    4a48:	e005      	b.n	4a56 <TwoWire::wait_idle()+0x16>
	elapsedMillis timeout = 0;
	while (1) {
		uint32_t status = port->MSR; // pg 2899 & 2892
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
		if (status & LPI2C_MSR_MBF) break; // we already have bus control
    4a4a:	01db      	lsls	r3, r3, #7
    4a4c:	d407      	bmi.n	4a5e <TwoWire::wait_idle()+0x1e>
    4a4e:	680b      	ldr	r3, [r1, #0]
		if (timeout > 16) {
    4a50:	1b1b      	subs	r3, r3, r4
    4a52:	2b10      	cmp	r3, #16
    4a54:	d808      	bhi.n	4a68 <TwoWire::wait_idle()+0x28>

bool TwoWire::wait_idle()
{
	elapsedMillis timeout = 0;
	while (1) {
		uint32_t status = port->MSR; // pg 2899 & 2892
    4a56:	6953      	ldr	r3, [r2, #20]
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
    4a58:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    4a5c:	d1f5      	bne.n	4a4a <TwoWire::wait_idle()+0xa>
			if (force_clock()) break;
			//Serial.printf("unable to get control of I2C bus\n");
			return false;
		}
	}
	port->MSR = 0x00007F00; // clear all prior flags
    4a5e:	f44f 43fe 	mov.w	r3, #32512	; 0x7f00
	return true;
    4a62:	2001      	movs	r0, #1
			if (force_clock()) break;
			//Serial.printf("unable to get control of I2C bus\n");
			return false;
		}
	}
	port->MSR = 0x00007F00; // clear all prior flags
    4a64:	6153      	str	r3, [r2, #20]
	return true;
}
    4a66:	bd10      	pop	{r4, pc}
    4a68:	4604      	mov	r4, r0
		uint32_t status = port->MSR; // pg 2899 & 2892
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
		if (status & LPI2C_MSR_MBF) break; // we already have bus control
		if (timeout > 16) {
			//Serial.printf("timeout waiting for idle, MSR = %x\n", status);
			if (force_clock()) break;
    4a6a:	f7ff ff5d 	bl	4928 <TwoWire::force_clock()>
    4a6e:	2800      	cmp	r0, #0
    4a70:	d0f9      	beq.n	4a66 <TwoWire::wait_idle()+0x26>
    4a72:	6922      	ldr	r2, [r4, #16]
    4a74:	e7f3      	b.n	4a5e <TwoWire::wait_idle()+0x1e>
    4a76:	bf00      	nop
    4a78:	20002740 	.word	0x20002740

00004a7c <TwoWire::endTransmission(unsigned char)>:
	return true;
}


uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    4a7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t tx_len = txBufferLength;
    4a80:	f890 a12f 	ldrb.w	sl, [r0, #303]	; 0x12f
	if (!tx_len) return 4; // no address for transmit
    4a84:	f1ba 0f00 	cmp.w	sl, #0
    4a88:	d102      	bne.n	4a90 <TwoWire::endTransmission(unsigned char)+0x14>
    4a8a:	2004      	movs	r0, #4
    4a8c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4a90:	4605      	mov	r5, r0
    4a92:	460e      	mov	r6, r1
	if (!wait_idle()) return 4;
    4a94:	f7ff ffd4 	bl	4a40 <TwoWire::wait_idle()>
    4a98:	2800      	cmp	r0, #0
    4a9a:	d0f6      	beq.n	4a8a <TwoWire::endTransmission(unsigned char)+0xe>
    4a9c:	4f2e      	ldr	r7, [pc, #184]	; (4b58 <TwoWire::endTransmission(unsigned char)+0xdc>)
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
    4a9e:	2400      	movs	r4, #0
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4aa0:	f44f 7900 	mov.w	r9, #512	; 0x200
    4aa4:	f8d7 8000 	ldr.w	r8, [r7]
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
    4aa8:	4554      	cmp	r4, sl
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
    4aaa:	6929      	ldr	r1, [r5, #16]
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
    4aac:	d81a      	bhi.n	4ae4 <TwoWire::endTransmission(unsigned char)+0x68>
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
    4aae:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
    4ab0:	f003 0307 	and.w	r3, r3, #7
			while (fifo_used < 4) {
    4ab4:	2b03      	cmp	r3, #3
    4ab6:	d909      	bls.n	4acc <TwoWire::endTransmission(unsigned char)+0x50>
    4ab8:	e014      	b.n	4ae4 <TwoWire::endTransmission(unsigned char)+0x68>
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    4aba:	f895 20a5 	ldrb.w	r2, [r5, #165]	; 0xa5
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
					tx_index++;
					break;
				}
				fifo_used++;
    4abe:	3301      	adds	r3, #1
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
    4ac0:	2401      	movs	r4, #1
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    4ac2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4ac6:	2b04      	cmp	r3, #4
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    4ac8:	660a      	str	r2, [r1, #96]	; 0x60
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4aca:	d00b      	beq.n	4ae4 <TwoWire::endTransmission(unsigned char)+0x68>
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    4acc:	192a      	adds	r2, r5, r4
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
    4ace:	2c00      	cmp	r4, #0
    4ad0:	d0f3      	beq.n	4aba <TwoWire::endTransmission(unsigned char)+0x3e>
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
    4ad2:	45a2      	cmp	sl, r4
    4ad4:	d927      	bls.n	4b26 <TwoWire::endTransmission(unsigned char)+0xaa>
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
					tx_index++;
					break;
				}
				fifo_used++;
    4ad6:	3301      	adds	r3, #1
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    4ad8:	f892 20a5 	ldrb.w	r2, [r2, #165]	; 0xa5
    4adc:	3401      	adds	r4, #1
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4ade:	2b04      	cmp	r3, #4
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    4ae0:	660a      	str	r2, [r1, #96]	; 0x60
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4ae2:	d1f3      	bne.n	4acc <TwoWire::endTransmission(unsigned char)+0x50>
				}
				fifo_used++;
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
    4ae4:	694b      	ldr	r3, [r1, #20]
		if (status & LPI2C_MSR_ALF) {
    4ae6:	0518      	lsls	r0, r3, #20
    4ae8:	d422      	bmi.n	4b30 <TwoWire::endTransmission(unsigned char)+0xb4>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			return 4; // we lost bus arbitration to another master
		}
		if (status & LPI2C_MSR_NDF) {
    4aea:	055a      	lsls	r2, r3, #21
    4aec:	d427      	bmi.n	4b3e <TwoWire::endTransmission(unsigned char)+0xc2>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP;
			return 2; // NACK (assume address, TODO: how to tell address from data)
		}
		if ((status & LPI2C_MSR_PLTF) || timeout > 50) {
    4aee:	0498      	lsls	r0, r3, #18
    4af0:	d404      	bmi.n	4afc <TwoWire::endTransmission(unsigned char)+0x80>
    4af2:	683a      	ldr	r2, [r7, #0]
    4af4:	ebc8 0202 	rsb	r2, r8, r2
    4af8:	2a32      	cmp	r2, #50	; 0x32
    4afa:	d909      	bls.n	4b10 <TwoWire::endTransmission(unsigned char)+0x94>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4afc:	690b      	ldr	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    4afe:	f44f 7200 	mov.w	r2, #512	; 0x200
			return 4; // clock stretched too long or generic timeout
    4b02:	2004      	movs	r0, #4
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP;
			return 2; // NACK (assume address, TODO: how to tell address from data)
		}
		if ((status & LPI2C_MSR_PLTF) || timeout > 50) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4b04:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    4b08:	610b      	str	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    4b0a:	660a      	str	r2, [r1, #96]	; 0x60
			return 4; // clock stretched too long or generic timeout
    4b0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
    4b10:	4554      	cmp	r4, sl
    4b12:	d905      	bls.n	4b20 <TwoWire::endTransmission(unsigned char)+0xa4>
			uint32_t tx_fifo = port->MFSR & 0x07;
    4b14:	6dca      	ldr	r2, [r1, #92]	; 0x5c
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
    4b16:	0752      	lsls	r2, r2, #29
    4b18:	d102      	bne.n	4b20 <TwoWire::endTransmission(unsigned char)+0xa4>
    4b1a:	059b      	lsls	r3, r3, #22
    4b1c:	d419      	bmi.n	4b52 <TwoWire::endTransmission(unsigned char)+0xd6>
    4b1e:	b1c6      	cbz	r6, 4b52 <TwoWire::endTransmission(unsigned char)+0xd6>
				return 0;
			}
		}
		yield();
    4b20:	f7fe fa94 	bl	304c <yield>
	uint32_t tx_len = txBufferLength;
	if (!tx_len) return 4; // no address for transmit
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
    4b24:	e7c0      	b.n	4aa8 <TwoWire::endTransmission(unsigned char)+0x2c>
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4b26:	b10e      	cbz	r6, 4b2c <TwoWire::endTransmission(unsigned char)+0xb0>
    4b28:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
					tx_index++;
    4b2c:	3401      	adds	r4, #1
					break;
    4b2e:	e7d9      	b.n	4ae4 <TwoWire::endTransmission(unsigned char)+0x68>
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4b30:	690b      	ldr	r3, [r1, #16]
			return 4; // we lost bus arbitration to another master
    4b32:	2004      	movs	r0, #4
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4b34:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    4b38:	610b      	str	r3, [r1, #16]
			return 4; // we lost bus arbitration to another master
    4b3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		if (status & LPI2C_MSR_NDF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4b3e:	690b      	ldr	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP;
    4b40:	f44f 7200 	mov.w	r2, #512	; 0x200
			return 2; // NACK (assume address, TODO: how to tell address from data)
    4b44:	2002      	movs	r0, #2
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			return 4; // we lost bus arbitration to another master
		}
		if (status & LPI2C_MSR_NDF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4b46:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    4b4a:	610b      	str	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP;
    4b4c:	660a      	str	r2, [r1, #96]	; 0x60
			return 2; // NACK (assume address, TODO: how to tell address from data)
    4b4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
			uint32_t tx_fifo = port->MFSR & 0x07;
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
				return 0;
    4b52:	2000      	movs	r0, #0
    4b54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4b58:	20002740 	.word	0x20002740

00004b5c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
		yield();
	}
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    4b5c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4b60:	460c      	mov	r4, r1
    4b62:	4615      	mov	r5, r2
    4b64:	4698      	mov	r8, r3
    4b66:	4681      	mov	r9, r0
	if (!wait_idle()) return 4;
    4b68:	f7ff ff6a 	bl	4a40 <TwoWire::wait_idle()>
    4b6c:	b910      	cbnz	r0, 4b74 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x18>
    4b6e:	2004      	movs	r0, #4
    4b70:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
    4b74:	2200      	movs	r2, #0
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
    4b76:	0063      	lsls	r3, r4, #1
	if (length < 1) length = 1;
    4b78:	2d00      	cmp	r5, #0
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4b7a:	f240 4a01 	movw	sl, #1025	; 0x401
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
    4b7e:	4614      	mov	r4, r2
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4b80:	b2db      	uxtb	r3, r3
    4b82:	4e3d      	ldr	r6, [pc, #244]	; (4c78 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>)

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
    4b84:	bf08      	it	eq
    4b86:	2501      	moveq	r5, #1
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    4b88:	2c02      	cmp	r4, #2
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4b8a:	ea43 0a0a 	orr.w	sl, r3, sl
    4b8e:	f8d6 b000 	ldr.w	fp, [r6]
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
    4b92:	f889 20a2 	strb.w	r2, [r9, #162]	; 0xa2
	rxBufferLength = 0;
    4b96:	f889 20a3 	strb.w	r2, [r9, #163]	; 0xa3
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    4b9a:	d948      	bls.n	4c2e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xd2>
    4b9c:	f8d9 3010 	ldr.w	r3, [r9, #16]
				tx_state++;
				tx_fifo--;
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
    4ba0:	f899 20a3 	ldrb.w	r2, [r9, #163]	; 0xa3
    4ba4:	2a87      	cmp	r2, #135	; 0x87
    4ba6:	d812      	bhi.n	4bce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
    4ba8:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
    4baa:	f3c1 4102 	ubfx	r1, r1, #16, #3
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    4bae:	b911      	cbnz	r1, 4bb6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x5a>
    4bb0:	e00d      	b.n	4bce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    4bb2:	2a88      	cmp	r2, #136	; 0x88
    4bb4:	d00b      	beq.n	4bce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
				rxBuffer[rxBufferLength++] = port->MRDR;
    4bb6:	f102 0e01 	add.w	lr, r2, #1
    4bba:	eb09 0002 	add.w	r0, r9, r2
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    4bbe:	3901      	subs	r1, #1
				rxBuffer[rxBufferLength++] = port->MRDR;
    4bc0:	fa5f f28e 	uxtb.w	r2, lr
    4bc4:	f889 20a3 	strb.w	r2, [r9, #163]	; 0xa3
    4bc8:	6f1f      	ldr	r7, [r3, #112]	; 0x70
    4bca:	7687      	strb	r7, [r0, #26]
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    4bcc:	d1f1      	bne.n	4bb2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x56>
				rxBuffer[rxBufferLength++] = port->MRDR;
				rx_fifo--;
			}
		}
		// monitor status, check for error conditions
		uint32_t status = port->MSR; // pg 2884 & 2891
    4bce:	695a      	ldr	r2, [r3, #20]
		if (status & LPI2C_MSR_ALF) {
    4bd0:	0510      	lsls	r0, r2, #20
    4bd2:	d44c      	bmi.n	4c6e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x112>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			break;
		}
		if ((status & LPI2C_MSR_NDF) || (status & LPI2C_MSR_PLTF) || timeout > 50) {
    4bd4:	f412 5f10 	tst.w	r2, #9216	; 0x2400
    4bd8:	d104      	bne.n	4be4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x88>
    4bda:	6831      	ldr	r1, [r6, #0]
    4bdc:	ebcb 0101 	rsb	r1, fp, r1
    4be0:	2932      	cmp	r1, #50	; 0x32
    4be2:	d912      	bls.n	4c0a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xae>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4be4:	691a      	ldr	r2, [r3, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    4be6:	f44f 7100 	mov.w	r1, #512	; 0x200
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			break;
		}
		if ((status & LPI2C_MSR_NDF) || (status & LPI2C_MSR_PLTF) || timeout > 50) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4bea:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    4bee:	611a      	str	r2, [r3, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    4bf0:	6619      	str	r1, [r3, #96]	; 0x60
				break;
			}
		}
		yield();
	}
	uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
    4bf2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
	if (rx_fifo > 0) port->MCR |= LPI2C_MCR_RRF;
    4bf4:	f412 2fe0 	tst.w	r2, #458752	; 0x70000
    4bf8:	d003      	beq.n	4c02 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
    4bfa:	691a      	ldr	r2, [r3, #16]
    4bfc:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    4c00:	611a      	str	r2, [r3, #16]
	return rxBufferLength;
    4c02:	f899 00a3 	ldrb.w	r0, [r9, #163]	; 0xa3
    4c06:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
			break;
		}
		// are we done yet?
		if (rxBufferLength >= length && tx_state >= 3) {
    4c0a:	f899 10a3 	ldrb.w	r1, [r9, #163]	; 0xa3
    4c0e:	42a9      	cmp	r1, r5
    4c10:	d309      	bcc.n	4c26 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    4c12:	2c02      	cmp	r4, #2
    4c14:	d907      	bls.n	4c26 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
			uint32_t tx_fifo = port->MFSR & 0x07;
    4c16:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
    4c18:	0749      	lsls	r1, r1, #29
    4c1a:	d104      	bne.n	4c26 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    4c1c:	0592      	lsls	r2, r2, #22
    4c1e:	d4e8      	bmi.n	4bf2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    4c20:	f1b8 0f00 	cmp.w	r8, #0
    4c24:	d0e5      	beq.n	4bf2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
				break;
			}
		}
		yield();
    4c26:	f7fe fa11 	bl	304c <yield>
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    4c2a:	2c02      	cmp	r4, #2
    4c2c:	d8b6      	bhi.n	4b9c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x40>
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
    4c2e:	f8d9 2010 	ldr.w	r2, [r9, #16]
    4c32:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    4c34:	f003 0307 	and.w	r3, r3, #7
			while (tx_fifo < 4 && tx_state < 3) {
    4c38:	2b03      	cmp	r3, #3
    4c3a:	d80d      	bhi.n	4c58 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    4c3c:	1e69      	subs	r1, r5, #1
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4c3e:	f44f 7000 	mov.w	r0, #512	; 0x200
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    4c42:	f441 7180 	orr.w	r1, r1, #256	; 0x100
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
    4c46:	b94c      	cbnz	r4, 4c5c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x100>
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4c48:	f8c2 a060 	str.w	sl, [r2, #96]	; 0x60
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
				}
				tx_state++;
				tx_fifo--;
    4c4c:	3b01      	subs	r3, #1
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
				}
				tx_state++;
    4c4e:	3401      	adds	r4, #1
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
    4c50:	2b03      	cmp	r3, #3
    4c52:	d801      	bhi.n	4c58 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
    4c54:	2c02      	cmp	r4, #2
    4c56:	d9f6      	bls.n	4c46 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
    4c58:	4613      	mov	r3, r2
    4c5a:	e7a1      	b.n	4ba0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
    4c5c:	2c01      	cmp	r4, #1
    4c5e:	d004      	beq.n	4c6a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10e>
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4c60:	f1b8 0f00 	cmp.w	r8, #0
    4c64:	d0f2      	beq.n	4c4c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    4c66:	6610      	str	r0, [r2, #96]	; 0x60
    4c68:	e7f0      	b.n	4c4c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    4c6a:	6611      	str	r1, [r2, #96]	; 0x60
    4c6c:	e7ee      	b.n	4c4c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
			}
		}
		// monitor status, check for error conditions
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4c6e:	691a      	ldr	r2, [r3, #16]
    4c70:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    4c74:	611a      	str	r2, [r3, #16]
    4c76:	e7bc      	b.n	4bf2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    4c78:	20002740 	.word	0x20002740

00004c7c <TwoWire::isr()>:
}


void TwoWire::isr(void)
{
	uint32_t status = port->SSR;
    4c7c:	6903      	ldr	r3, [r0, #16]
	port->SCR = LPI2C_SCR_SEN;
}


void TwoWire::isr(void)
{
    4c7e:	b570      	push	{r4, r5, r6, lr}
	uint32_t status = port->SSR;
    4c80:	f8d3 5114 	ldr.w	r5, [r3, #276]	; 0x114
	port->SCR = LPI2C_SCR_SEN;
}


void TwoWire::isr(void)
{
    4c84:	4604      	mov	r4, r0
	uint32_t status = port->SSR;
	uint32_t w1c_bits = status & 0xF00;
	if (w1c_bits) port->SSR = w1c_bits;
    4c86:	f415 6270 	ands.w	r2, r5, #3840	; 0xf00
    4c8a:	d001      	beq.n	4c90 <TwoWire::isr()+0x14>
    4c8c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

	//Serial.print("isr ");
	//Serial.println(status, HEX);

	if (status & LPI2C_SSR_RDF) { // Receive Data Flag
    4c90:	07ae      	lsls	r6, r5, #30
    4c92:	d50b      	bpl.n	4cac <TwoWire::isr()+0x30>
		int rx = port->SRDR;
    4c94:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
		if (rx & 0x8000) {
    4c98:	0408      	lsls	r0, r1, #16
    4c9a:	d542      	bpl.n	4d22 <TwoWire::isr()+0xa6>
			rxBufferIndex = 0;
    4c9c:	2200      	movs	r2, #0
    4c9e:	2001      	movs	r0, #1
    4ca0:	f884 20a2 	strb.w	r2, [r4, #162]	; 0xa2
			rxBufferLength = 0;
		}
		if (rxBufferLength < BUFFER_LENGTH) {
			rxBuffer[rxBufferLength++] = rx & 255;
    4ca4:	4422      	add	r2, r4
    4ca6:	f884 00a3 	strb.w	r0, [r4, #163]	; 0xa3
    4caa:	7691      	strb	r1, [r2, #26]
		}
		//Serial.print("rx = ");
		//Serial.println(rx, HEX);
	}
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
    4cac:	07ea      	lsls	r2, r5, #31
    4cae:	d510      	bpl.n	4cd2 <TwoWire::isr()+0x56>
		if (!transmitting) {
    4cb0:	f894 6130 	ldrb.w	r6, [r4, #304]	; 0x130
    4cb4:	b316      	cbz	r6, 4cfc <TwoWire::isr()+0x80>
    4cb6:	f894 612e 	ldrb.w	r6, [r4, #302]	; 0x12e
				(*user_onRequest)();
			}
			txBufferIndex = 0;
			transmitting = 1;
		}
		if (txBufferIndex < txBufferLength) {
    4cba:	f894 212f 	ldrb.w	r2, [r4, #303]	; 0x12f
    4cbe:	42b2      	cmp	r2, r6
    4cc0:	d92b      	bls.n	4d1a <TwoWire::isr()+0x9e>
			port->STDR = txBuffer[txBufferIndex++];
    4cc2:	1c72      	adds	r2, r6, #1
    4cc4:	4426      	add	r6, r4
    4cc6:	f884 212e 	strb.w	r2, [r4, #302]	; 0x12e
    4cca:	f896 20a5 	ldrb.w	r2, [r6, #165]	; 0xa5
    4cce:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
			port->STDR = 0;
		}
		//Serial.println("tx");
	}

	if (status & LPI2C_SSR_SDF) { // Stop
    4cd2:	05ab      	lsls	r3, r5, #22
    4cd4:	d511      	bpl.n	4cfa <TwoWire::isr()+0x7e>
		//Serial.println("Stop");
		if (rxBufferLength > 0 && user_onReceive != nullptr) {
    4cd6:	f894 00a3 	ldrb.w	r0, [r4, #163]	; 0xa3
    4cda:	b118      	cbz	r0, 4ce4 <TwoWire::isr()+0x68>
    4cdc:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
    4ce0:	b103      	cbz	r3, 4ce4 <TwoWire::isr()+0x68>
			(*user_onReceive)(rxBufferLength);
    4ce2:	4798      	blx	r3
		}
		rxBufferIndex = 0;
    4ce4:	2300      	movs	r3, #0
    4ce6:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
		rxBufferLength = 0;
    4cea:	f884 30a3 	strb.w	r3, [r4, #163]	; 0xa3
		txBufferIndex = 0;
    4cee:	f884 312e 	strb.w	r3, [r4, #302]	; 0x12e
		txBufferLength = 0;
    4cf2:	f884 312f 	strb.w	r3, [r4, #303]	; 0x12f
		transmitting = 0;
    4cf6:	f884 3130 	strb.w	r3, [r4, #304]	; 0x130
    4cfa:	bd70      	pop	{r4, r5, r6, pc}
		//Serial.print("rx = ");
		//Serial.println(rx, HEX);
	}
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
    4cfc:	f8d4 2138 	ldr.w	r2, [r4, #312]	; 0x138
    4d00:	b10a      	cbz	r2, 4d06 <TwoWire::isr()+0x8a>
				(*user_onRequest)();
    4d02:	4790      	blx	r2
    4d04:	6923      	ldr	r3, [r4, #16]
			}
			txBufferIndex = 0;
			transmitting = 1;
    4d06:	2201      	movs	r2, #1
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
				(*user_onRequest)();
			}
			txBufferIndex = 0;
    4d08:	2100      	movs	r1, #0
			transmitting = 1;
    4d0a:	f884 2130 	strb.w	r2, [r4, #304]	; 0x130
		}
		if (txBufferIndex < txBufferLength) {
    4d0e:	f894 212f 	ldrb.w	r2, [r4, #303]	; 0x12f
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
				(*user_onRequest)();
			}
			txBufferIndex = 0;
    4d12:	f884 112e 	strb.w	r1, [r4, #302]	; 0x12e
			transmitting = 1;
		}
		if (txBufferIndex < txBufferLength) {
    4d16:	42b2      	cmp	r2, r6
    4d18:	d8d3      	bhi.n	4cc2 <TwoWire::isr()+0x46>
			port->STDR = txBuffer[txBufferIndex++];
		} else {
			port->STDR = 0;
    4d1a:	2200      	movs	r2, #0
    4d1c:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
    4d20:	e7d7      	b.n	4cd2 <TwoWire::isr()+0x56>
		int rx = port->SRDR;
		if (rx & 0x8000) {
			rxBufferIndex = 0;
			rxBufferLength = 0;
		}
		if (rxBufferLength < BUFFER_LENGTH) {
    4d22:	f894 20a3 	ldrb.w	r2, [r4, #163]	; 0xa3
    4d26:	2a87      	cmp	r2, #135	; 0x87
    4d28:	d8c0      	bhi.n	4cac <TwoWire::isr()+0x30>
    4d2a:	1c50      	adds	r0, r2, #1
    4d2c:	b2c0      	uxtb	r0, r0
    4d2e:	e7b9      	b.n	4ca4 <TwoWire::isr()+0x28>

00004d30 <lpi2c1_isr()>:
void lpi2c1_isr(void) { Wire.isr(); }
void lpi2c3_isr(void) { Wire2.isr(); }
void lpi2c4_isr(void) { Wire1.isr(); }
void lpi2c2_isr(void) { Wire3.isr(); }
#else
void lpi2c1_isr(void) { Wire.isr(); }
    4d30:	4801      	ldr	r0, [pc, #4]	; (4d38 <lpi2c1_isr()+0x8>)
    4d32:	f7ff bfa3 	b.w	4c7c <TwoWire::isr()>
    4d36:	bf00      	nop
    4d38:	200015a4 	.word	0x200015a4

00004d3c <lpi2c3_isr()>:
void lpi2c3_isr(void) { Wire1.isr(); }
    4d3c:	4801      	ldr	r0, [pc, #4]	; (4d44 <lpi2c3_isr()+0x8>)
    4d3e:	f7ff bf9d 	b.w	4c7c <TwoWire::isr()>
    4d42:	bf00      	nop
    4d44:	200016e4 	.word	0x200016e4

00004d48 <lpi2c4_isr()>:
void lpi2c4_isr(void) { Wire2.isr(); }
    4d48:	4801      	ldr	r0, [pc, #4]	; (4d50 <lpi2c4_isr()+0x8>)
    4d4a:	f7ff bf97 	b.w	4c7c <TwoWire::isr()>
    4d4e:	bf00      	nop
    4d50:	20001824 	.word	0x20001824
    4d54:	00000000 	.word	0x00000000

00004d58 <cos>:
    4d58:	b500      	push	{lr}
    4d5a:	eeb0 7b40 	vmov.f64	d7, d0
    4d5e:	ee17 3a90 	vmov	r3, s15
    4d62:	4a23      	ldr	r2, [pc, #140]	; (4df0 <cos+0x98>)
    4d64:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    4d68:	4293      	cmp	r3, r2
    4d6a:	b085      	sub	sp, #20
    4d6c:	dd19      	ble.n	4da2 <cos+0x4a>
    4d6e:	4a21      	ldr	r2, [pc, #132]	; (4df4 <cos+0x9c>)
    4d70:	4293      	cmp	r3, r2
    4d72:	dd04      	ble.n	4d7e <cos+0x26>
    4d74:	ee30 0b40 	vsub.f64	d0, d0, d0
    4d78:	b005      	add	sp, #20
    4d7a:	f85d fb04 	ldr.w	pc, [sp], #4
    4d7e:	4668      	mov	r0, sp
    4d80:	f000 f9d2 	bl	5128 <__ieee754_rem_pio2>
    4d84:	f000 0003 	and.w	r0, r0, #3
    4d88:	2801      	cmp	r0, #1
    4d8a:	d01a      	beq.n	4dc2 <cos+0x6a>
    4d8c:	2802      	cmp	r0, #2
    4d8e:	d00f      	beq.n	4db0 <cos+0x58>
    4d90:	b300      	cbz	r0, 4dd4 <cos+0x7c>
    4d92:	2001      	movs	r0, #1
    4d94:	ed9d 1b02 	vldr	d1, [sp, #8]
    4d98:	ed9d 0b00 	vldr	d0, [sp]
    4d9c:	f000 ffa4 	bl	5ce8 <__kernel_sin>
    4da0:	e7ea      	b.n	4d78 <cos+0x20>
    4da2:	ed9f 1b11 	vldr	d1, [pc, #68]	; 4de8 <cos+0x90>
    4da6:	f000 fbcf 	bl	5548 <__kernel_cos>
    4daa:	b005      	add	sp, #20
    4dac:	f85d fb04 	ldr.w	pc, [sp], #4
    4db0:	ed9d 1b02 	vldr	d1, [sp, #8]
    4db4:	ed9d 0b00 	vldr	d0, [sp]
    4db8:	f000 fbc6 	bl	5548 <__kernel_cos>
    4dbc:	eeb1 0b40 	vneg.f64	d0, d0
    4dc0:	e7da      	b.n	4d78 <cos+0x20>
    4dc2:	ed9d 1b02 	vldr	d1, [sp, #8]
    4dc6:	ed9d 0b00 	vldr	d0, [sp]
    4dca:	f000 ff8d 	bl	5ce8 <__kernel_sin>
    4dce:	eeb1 0b40 	vneg.f64	d0, d0
    4dd2:	e7d1      	b.n	4d78 <cos+0x20>
    4dd4:	ed9d 1b02 	vldr	d1, [sp, #8]
    4dd8:	ed9d 0b00 	vldr	d0, [sp]
    4ddc:	f000 fbb4 	bl	5548 <__kernel_cos>
    4de0:	e7ca      	b.n	4d78 <cos+0x20>
    4de2:	bf00      	nop
    4de4:	f3af 8000 	nop.w
	...
    4df0:	3fe921fb 	.word	0x3fe921fb
    4df4:	7fefffff 	.word	0x7fefffff

00004df8 <sin>:
    4df8:	b500      	push	{lr}
    4dfa:	eeb0 7b40 	vmov.f64	d7, d0
    4dfe:	ee17 3a90 	vmov	r3, s15
    4e02:	4a23      	ldr	r2, [pc, #140]	; (4e90 <sin+0x98>)
    4e04:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    4e08:	4293      	cmp	r3, r2
    4e0a:	b085      	sub	sp, #20
    4e0c:	dd1a      	ble.n	4e44 <sin+0x4c>
    4e0e:	4a21      	ldr	r2, [pc, #132]	; (4e94 <sin+0x9c>)
    4e10:	4293      	cmp	r3, r2
    4e12:	dd04      	ble.n	4e1e <sin+0x26>
    4e14:	ee30 0b40 	vsub.f64	d0, d0, d0
    4e18:	b005      	add	sp, #20
    4e1a:	f85d fb04 	ldr.w	pc, [sp], #4
    4e1e:	4668      	mov	r0, sp
    4e20:	f000 f982 	bl	5128 <__ieee754_rem_pio2>
    4e24:	f000 0003 	and.w	r0, r0, #3
    4e28:	2801      	cmp	r0, #1
    4e2a:	d01d      	beq.n	4e68 <sin+0x70>
    4e2c:	2802      	cmp	r0, #2
    4e2e:	d011      	beq.n	4e54 <sin+0x5c>
    4e30:	b308      	cbz	r0, 4e76 <sin+0x7e>
    4e32:	ed9d 1b02 	vldr	d1, [sp, #8]
    4e36:	ed9d 0b00 	vldr	d0, [sp]
    4e3a:	f000 fb85 	bl	5548 <__kernel_cos>
    4e3e:	eeb1 0b40 	vneg.f64	d0, d0
    4e42:	e7e9      	b.n	4e18 <sin+0x20>
    4e44:	2000      	movs	r0, #0
    4e46:	ed9f 1b10 	vldr	d1, [pc, #64]	; 4e88 <sin+0x90>
    4e4a:	f000 ff4d 	bl	5ce8 <__kernel_sin>
    4e4e:	b005      	add	sp, #20
    4e50:	f85d fb04 	ldr.w	pc, [sp], #4
    4e54:	2001      	movs	r0, #1
    4e56:	ed9d 1b02 	vldr	d1, [sp, #8]
    4e5a:	ed9d 0b00 	vldr	d0, [sp]
    4e5e:	f000 ff43 	bl	5ce8 <__kernel_sin>
    4e62:	eeb1 0b40 	vneg.f64	d0, d0
    4e66:	e7d7      	b.n	4e18 <sin+0x20>
    4e68:	ed9d 1b02 	vldr	d1, [sp, #8]
    4e6c:	ed9d 0b00 	vldr	d0, [sp]
    4e70:	f000 fb6a 	bl	5548 <__kernel_cos>
    4e74:	e7d0      	b.n	4e18 <sin+0x20>
    4e76:	2001      	movs	r0, #1
    4e78:	ed9d 1b02 	vldr	d1, [sp, #8]
    4e7c:	ed9d 0b00 	vldr	d0, [sp]
    4e80:	f000 ff32 	bl	5ce8 <__kernel_sin>
    4e84:	e7c8      	b.n	4e18 <sin+0x20>
    4e86:	bf00      	nop
	...
    4e90:	3fe921fb 	.word	0x3fe921fb
    4e94:	7fefffff 	.word	0x7fefffff

00004e98 <atan2>:
    4e98:	f000 b856 	b.w	4f48 <__ieee754_atan2>
    4e9c:	0000      	movs	r0, r0
	...

00004ea0 <sqrt>:
    4ea0:	b500      	push	{lr}
    4ea2:	ed2d 8b02 	vpush	{d8}
    4ea6:	eeb0 8b40 	vmov.f64	d8, d0
    4eaa:	b08b      	sub	sp, #44	; 0x2c
    4eac:	f000 fa8a 	bl	53c4 <__ieee754_sqrt>
    4eb0:	4b23      	ldr	r3, [pc, #140]	; (4f40 <sqrt+0xa0>)
    4eb2:	f993 3000 	ldrsb.w	r3, [r3]
    4eb6:	1c5a      	adds	r2, r3, #1
    4eb8:	d00b      	beq.n	4ed2 <sqrt+0x32>
    4eba:	eeb4 8b48 	vcmp.f64	d8, d8
    4ebe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4ec2:	d606      	bvs.n	4ed2 <sqrt+0x32>
    4ec4:	ed9f 7b1c 	vldr	d7, [pc, #112]	; 4f38 <sqrt+0x98>
    4ec8:	eeb4 8bc7 	vcmpe.f64	d8, d7
    4ecc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4ed0:	d404      	bmi.n	4edc <sqrt+0x3c>
    4ed2:	b00b      	add	sp, #44	; 0x2c
    4ed4:	ecbd 8b02 	vpop	{d8}
    4ed8:	f85d fb04 	ldr.w	pc, [sp], #4
    4edc:	2201      	movs	r2, #1
    4ede:	4919      	ldr	r1, [pc, #100]	; (4f44 <sqrt+0xa4>)
    4ee0:	9200      	str	r2, [sp, #0]
    4ee2:	2200      	movs	r2, #0
    4ee4:	ed8d 8b04 	vstr	d8, [sp, #16]
    4ee8:	ed8d 8b02 	vstr	d8, [sp, #8]
    4eec:	9101      	str	r1, [sp, #4]
    4eee:	9208      	str	r2, [sp, #32]
    4ef0:	b193      	cbz	r3, 4f18 <sqrt+0x78>
    4ef2:	ee87 6b07 	vdiv.f64	d6, d7, d7
    4ef6:	2b02      	cmp	r3, #2
    4ef8:	ed8d 6b06 	vstr	d6, [sp, #24]
    4efc:	d10e      	bne.n	4f1c <sqrt+0x7c>
    4efe:	f001 fb1b 	bl	6538 <__errno>
    4f02:	2321      	movs	r3, #33	; 0x21
    4f04:	6003      	str	r3, [r0, #0]
    4f06:	9b08      	ldr	r3, [sp, #32]
    4f08:	b973      	cbnz	r3, 4f28 <sqrt+0x88>
    4f0a:	ed9d 0b06 	vldr	d0, [sp, #24]
    4f0e:	b00b      	add	sp, #44	; 0x2c
    4f10:	ecbd 8b02 	vpop	{d8}
    4f14:	f85d fb04 	ldr.w	pc, [sp], #4
    4f18:	ed8d 7b06 	vstr	d7, [sp, #24]
    4f1c:	4668      	mov	r0, sp
    4f1e:	f001 f8d3 	bl	60c8 <matherr>
    4f22:	2800      	cmp	r0, #0
    4f24:	d1ef      	bne.n	4f06 <sqrt+0x66>
    4f26:	e7ea      	b.n	4efe <sqrt+0x5e>
    4f28:	f001 fb06 	bl	6538 <__errno>
    4f2c:	9b08      	ldr	r3, [sp, #32]
    4f2e:	6003      	str	r3, [r0, #0]
    4f30:	e7eb      	b.n	4f0a <sqrt+0x6a>
    4f32:	bf00      	nop
    4f34:	f3af 8000 	nop.w
	...
    4f40:	20001f5e 	.word	0x20001f5e
    4f44:	20000f14 	.word	0x20000f14

00004f48 <__ieee754_atan2>:
    4f48:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f4a:	b085      	sub	sp, #20
    4f4c:	ed8d 1b02 	vstr	d1, [sp, #8]
    4f50:	9a02      	ldr	r2, [sp, #8]
    4f52:	9803      	ldr	r0, [sp, #12]
    4f54:	4972      	ldr	r1, [pc, #456]	; (5120 <__ieee754_atan2+0x1d8>)
    4f56:	4253      	negs	r3, r2
    4f58:	ed8d 0b00 	vstr	d0, [sp]
    4f5c:	4313      	orrs	r3, r2
    4f5e:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
    4f62:	ea45 73d3 	orr.w	r3, r5, r3, lsr #31
    4f66:	428b      	cmp	r3, r1
    4f68:	e89d 0090 	ldmia.w	sp, {r4, r7}
    4f6c:	d842      	bhi.n	4ff4 <__ieee754_atan2+0xac>
    4f6e:	4263      	negs	r3, r4
    4f70:	4323      	orrs	r3, r4
    4f72:	f027 4e00 	bic.w	lr, r7, #2147483648	; 0x80000000
    4f76:	ea4e 73d3 	orr.w	r3, lr, r3, lsr #31
    4f7a:	428b      	cmp	r3, r1
    4f7c:	d83a      	bhi.n	4ff4 <__ieee754_atan2+0xac>
    4f7e:	f100 4340 	add.w	r3, r0, #3221225472	; 0xc0000000
    4f82:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
    4f86:	4313      	orrs	r3, r2
    4f88:	d053      	beq.n	5032 <__ieee754_atan2+0xea>
    4f8a:	1786      	asrs	r6, r0, #30
    4f8c:	f006 0602 	and.w	r6, r6, #2
    4f90:	ea54 030e 	orrs.w	r3, r4, lr
    4f94:	ea46 76d7 	orr.w	r6, r6, r7, lsr #31
    4f98:	d034      	beq.n	5004 <__ieee754_atan2+0xbc>
    4f9a:	ea52 0305 	orrs.w	r3, r2, r5
    4f9e:	d03e      	beq.n	501e <__ieee754_atan2+0xd6>
    4fa0:	428d      	cmp	r5, r1
    4fa2:	d052      	beq.n	504a <__ieee754_atan2+0x102>
    4fa4:	458e      	cmp	lr, r1
    4fa6:	d03a      	beq.n	501e <__ieee754_atan2+0xd6>
    4fa8:	ebc5 050e 	rsb	r5, r5, lr
    4fac:	152d      	asrs	r5, r5, #20
    4fae:	2d3c      	cmp	r5, #60	; 0x3c
    4fb0:	dc44      	bgt.n	503c <__ieee754_atan2+0xf4>
    4fb2:	2800      	cmp	r0, #0
    4fb4:	db6b      	blt.n	508e <__ieee754_atan2+0x146>
    4fb6:	e9dd 2300 	ldrd	r2, r3, [sp]
    4fba:	ed9d 0b02 	vldr	d0, [sp, #8]
    4fbe:	ec43 2b17 	vmov	d7, r2, r3
    4fc2:	ee87 0b00 	vdiv.f64	d0, d7, d0
    4fc6:	f000 ffe9 	bl	5f9c <fabs>
    4fca:	f000 fee5 	bl	5d98 <atan>
    4fce:	ec53 2b10 	vmov	r2, r3, d0
    4fd2:	2e01      	cmp	r6, #1
    4fd4:	d056      	beq.n	5084 <__ieee754_atan2+0x13c>
    4fd6:	2e02      	cmp	r6, #2
    4fd8:	d049      	beq.n	506e <__ieee754_atan2+0x126>
    4fda:	2e00      	cmp	r6, #0
    4fdc:	d044      	beq.n	5068 <__ieee754_atan2+0x120>
    4fde:	ed9f 7b3a 	vldr	d7, [pc, #232]	; 50c8 <__ieee754_atan2+0x180>
    4fe2:	ed9f 6b3b 	vldr	d6, [pc, #236]	; 50d0 <__ieee754_atan2+0x188>
    4fe6:	ec43 2b15 	vmov	d5, r2, r3
    4fea:	ee35 7b47 	vsub.f64	d7, d5, d7
    4fee:	ee37 0b46 	vsub.f64	d0, d7, d6
    4ff2:	e005      	b.n	5000 <__ieee754_atan2+0xb8>
    4ff4:	ed9d 7b02 	vldr	d7, [sp, #8]
    4ff8:	ed9d 6b00 	vldr	d6, [sp]
    4ffc:	ee37 0b06 	vadd.f64	d0, d7, d6
    5000:	b005      	add	sp, #20
    5002:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5004:	2e02      	cmp	r6, #2
    5006:	d01d      	beq.n	5044 <__ieee754_atan2+0xfc>
    5008:	ed9f 0b33 	vldr	d0, [pc, #204]	; 50d8 <__ieee754_atan2+0x190>
    500c:	ed9d 7b00 	vldr	d7, [sp]
    5010:	2e03      	cmp	r6, #3
    5012:	bf08      	it	eq
    5014:	eeb0 7b40 	vmoveq.f64	d7, d0
    5018:	eeb0 0b47 	vmov.f64	d0, d7
    501c:	e7f0      	b.n	5000 <__ieee754_atan2+0xb8>
    501e:	ed9f 7b30 	vldr	d7, [pc, #192]	; 50e0 <__ieee754_atan2+0x198>
    5022:	ed9f 0b31 	vldr	d0, [pc, #196]	; 50e8 <__ieee754_atan2+0x1a0>
    5026:	2f00      	cmp	r7, #0
    5028:	bfa8      	it	ge
    502a:	eeb0 0b47 	vmovge.f64	d0, d7
    502e:	b005      	add	sp, #20
    5030:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5032:	b005      	add	sp, #20
    5034:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    5038:	f000 beae 	b.w	5d98 <atan>
    503c:	a328      	add	r3, pc, #160	; (adr r3, 50e0 <__ieee754_atan2+0x198>)
    503e:	e9d3 2300 	ldrd	r2, r3, [r3]
    5042:	e7c6      	b.n	4fd2 <__ieee754_atan2+0x8a>
    5044:	ed9f 0b22 	vldr	d0, [pc, #136]	; 50d0 <__ieee754_atan2+0x188>
    5048:	e7da      	b.n	5000 <__ieee754_atan2+0xb8>
    504a:	45ae      	cmp	lr, r5
    504c:	d024      	beq.n	5098 <__ieee754_atan2+0x150>
    504e:	2e02      	cmp	r6, #2
    5050:	d0f8      	beq.n	5044 <__ieee754_atan2+0xfc>
    5052:	2e03      	cmp	r6, #3
    5054:	d02d      	beq.n	50b2 <__ieee754_atan2+0x16a>
    5056:	ed9f 7b26 	vldr	d7, [pc, #152]	; 50f0 <__ieee754_atan2+0x1a8>
    505a:	ed9f 0b27 	vldr	d0, [pc, #156]	; 50f8 <__ieee754_atan2+0x1b0>
    505e:	2e01      	cmp	r6, #1
    5060:	bf08      	it	eq
    5062:	eeb0 0b47 	vmoveq.f64	d0, d7
    5066:	e7cb      	b.n	5000 <__ieee754_atan2+0xb8>
    5068:	ec43 2b10 	vmov	d0, r2, r3
    506c:	e7c8      	b.n	5000 <__ieee754_atan2+0xb8>
    506e:	ed9f 7b16 	vldr	d7, [pc, #88]	; 50c8 <__ieee754_atan2+0x180>
    5072:	ed9f 6b17 	vldr	d6, [pc, #92]	; 50d0 <__ieee754_atan2+0x188>
    5076:	ec43 2b15 	vmov	d5, r2, r3
    507a:	ee35 7b47 	vsub.f64	d7, d5, d7
    507e:	ee36 0b47 	vsub.f64	d0, d6, d7
    5082:	e7bd      	b.n	5000 <__ieee754_atan2+0xb8>
    5084:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
    5088:	ec43 2b10 	vmov	d0, r2, r3
    508c:	e7b8      	b.n	5000 <__ieee754_atan2+0xb8>
    508e:	353c      	adds	r5, #60	; 0x3c
    5090:	da91      	bge.n	4fb6 <__ieee754_atan2+0x6e>
    5092:	2200      	movs	r2, #0
    5094:	2300      	movs	r3, #0
    5096:	e79c      	b.n	4fd2 <__ieee754_atan2+0x8a>
    5098:	2e02      	cmp	r6, #2
    509a:	d010      	beq.n	50be <__ieee754_atan2+0x176>
    509c:	2e03      	cmp	r6, #3
    509e:	d00b      	beq.n	50b8 <__ieee754_atan2+0x170>
    50a0:	ed9f 7b17 	vldr	d7, [pc, #92]	; 5100 <__ieee754_atan2+0x1b8>
    50a4:	ed9f 0b18 	vldr	d0, [pc, #96]	; 5108 <__ieee754_atan2+0x1c0>
    50a8:	2e01      	cmp	r6, #1
    50aa:	bf08      	it	eq
    50ac:	eeb0 0b47 	vmoveq.f64	d0, d7
    50b0:	e7a6      	b.n	5000 <__ieee754_atan2+0xb8>
    50b2:	ed9f 0b09 	vldr	d0, [pc, #36]	; 50d8 <__ieee754_atan2+0x190>
    50b6:	e7a3      	b.n	5000 <__ieee754_atan2+0xb8>
    50b8:	ed9f 0b15 	vldr	d0, [pc, #84]	; 5110 <__ieee754_atan2+0x1c8>
    50bc:	e7a0      	b.n	5000 <__ieee754_atan2+0xb8>
    50be:	ed9f 0b16 	vldr	d0, [pc, #88]	; 5118 <__ieee754_atan2+0x1d0>
    50c2:	e79d      	b.n	5000 <__ieee754_atan2+0xb8>
    50c4:	f3af 8000 	nop.w
    50c8:	33145c07 	.word	0x33145c07
    50cc:	3ca1a626 	.word	0x3ca1a626
    50d0:	54442d18 	.word	0x54442d18
    50d4:	400921fb 	.word	0x400921fb
    50d8:	54442d18 	.word	0x54442d18
    50dc:	c00921fb 	.word	0xc00921fb
    50e0:	54442d18 	.word	0x54442d18
    50e4:	3ff921fb 	.word	0x3ff921fb
    50e8:	54442d18 	.word	0x54442d18
    50ec:	bff921fb 	.word	0xbff921fb
    50f0:	00000000 	.word	0x00000000
    50f4:	80000000 	.word	0x80000000
	...
    5100:	54442d18 	.word	0x54442d18
    5104:	bfe921fb 	.word	0xbfe921fb
    5108:	54442d18 	.word	0x54442d18
    510c:	3fe921fb 	.word	0x3fe921fb
    5110:	7f3321d2 	.word	0x7f3321d2
    5114:	c002d97c 	.word	0xc002d97c
    5118:	7f3321d2 	.word	0x7f3321d2
    511c:	4002d97c 	.word	0x4002d97c
    5120:	7ff00000 	.word	0x7ff00000
    5124:	00000000 	.word	0x00000000

00005128 <__ieee754_rem_pio2>:
    5128:	b570      	push	{r4, r5, r6, lr}
    512a:	ec53 2b10 	vmov	r2, r3, d0
    512e:	499e      	ldr	r1, [pc, #632]	; (53a8 <__ieee754_rem_pio2+0x280>)
    5130:	f023 4600 	bic.w	r6, r3, #2147483648	; 0x80000000
    5134:	428e      	cmp	r6, r1
    5136:	b088      	sub	sp, #32
    5138:	dd62      	ble.n	5200 <__ieee754_rem_pio2+0xd8>
    513a:	499c      	ldr	r1, [pc, #624]	; (53ac <__ieee754_rem_pio2+0x284>)
    513c:	428e      	cmp	r6, r1
    513e:	461d      	mov	r5, r3
    5140:	dc1c      	bgt.n	517c <__ieee754_rem_pio2+0x54>
    5142:	2b00      	cmp	r3, #0
    5144:	ed9f 7b88 	vldr	d7, [pc, #544]	; 5368 <__ieee754_rem_pio2+0x240>
    5148:	f340 80df 	ble.w	530a <__ieee754_rem_pio2+0x1e2>
    514c:	ee30 7b47 	vsub.f64	d7, d0, d7
    5150:	f5a1 211b 	sub.w	r1, r1, #634880	; 0x9b000
    5154:	f5a1 61f0 	sub.w	r1, r1, #1920	; 0x780
    5158:	428e      	cmp	r6, r1
    515a:	d063      	beq.n	5224 <__ieee754_rem_pio2+0xfc>
    515c:	ed9f 6b84 	vldr	d6, [pc, #528]	; 5370 <__ieee754_rem_pio2+0x248>
    5160:	ee37 5b46 	vsub.f64	d5, d7, d6
    5164:	ee37 7b45 	vsub.f64	d7, d7, d5
    5168:	2301      	movs	r3, #1
    516a:	ed80 5b00 	vstr	d5, [r0]
    516e:	ee37 7b46 	vsub.f64	d7, d7, d6
    5172:	ed80 7b02 	vstr	d7, [r0, #8]
    5176:	4618      	mov	r0, r3
    5178:	b008      	add	sp, #32
    517a:	bd70      	pop	{r4, r5, r6, pc}
    517c:	498c      	ldr	r1, [pc, #560]	; (53b0 <__ieee754_rem_pio2+0x288>)
    517e:	428e      	cmp	r6, r1
    5180:	4604      	mov	r4, r0
    5182:	dd56      	ble.n	5232 <__ieee754_rem_pio2+0x10a>
    5184:	498b      	ldr	r1, [pc, #556]	; (53b4 <__ieee754_rem_pio2+0x28c>)
    5186:	428e      	cmp	r6, r1
    5188:	dc44      	bgt.n	5214 <__ieee754_rem_pio2+0xec>
    518a:	4610      	mov	r0, r2
    518c:	1532      	asrs	r2, r6, #20
    518e:	f2a2 4216 	subw	r2, r2, #1046	; 0x416
    5192:	eba6 5102 	sub.w	r1, r6, r2, lsl #20
    5196:	ec41 0b16 	vmov	d6, r0, r1
    519a:	ed9f 7b77 	vldr	d7, [pc, #476]	; 5378 <__ieee754_rem_pio2+0x250>
    519e:	eebd 4bc6 	vcvt.s32.f64	s8, d6
    51a2:	2300      	movs	r3, #0
    51a4:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
    51a8:	ee36 6b44 	vsub.f64	d6, d6, d4
    51ac:	ee26 6b07 	vmul.f64	d6, d6, d7
    51b0:	eebd 5bc6 	vcvt.s32.f64	s10, d6
    51b4:	ed8d 4b02 	vstr	d4, [sp, #8]
    51b8:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
    51bc:	ee36 6b45 	vsub.f64	d6, d6, d5
    51c0:	ee26 7b07 	vmul.f64	d7, d6, d7
    51c4:	eeb5 7b40 	vcmp.f64	d7, #0.0
    51c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    51cc:	ed8d 5b04 	vstr	d5, [sp, #16]
    51d0:	ed8d 7b06 	vstr	d7, [sp, #24]
    51d4:	f040 80bb 	bne.w	534e <__ieee754_rem_pio2+0x226>
    51d8:	eeb5 5b40 	vcmp.f64	d5, #0.0
    51dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    51e0:	bf0c      	ite	eq
    51e2:	2301      	moveq	r3, #1
    51e4:	2302      	movne	r3, #2
    51e6:	4974      	ldr	r1, [pc, #464]	; (53b8 <__ieee754_rem_pio2+0x290>)
    51e8:	9101      	str	r1, [sp, #4]
    51ea:	2102      	movs	r1, #2
    51ec:	9100      	str	r1, [sp, #0]
    51ee:	a802      	add	r0, sp, #8
    51f0:	4621      	mov	r1, r4
    51f2:	f000 fa39 	bl	5668 <__kernel_rem_pio2>
    51f6:	2d00      	cmp	r5, #0
    51f8:	f2c0 809b 	blt.w	5332 <__ieee754_rem_pio2+0x20a>
    51fc:	4603      	mov	r3, r0
    51fe:	e006      	b.n	520e <__ieee754_rem_pio2+0xe6>
    5200:	2400      	movs	r4, #0
    5202:	2500      	movs	r5, #0
    5204:	ed80 0b00 	vstr	d0, [r0]
    5208:	e9c0 4502 	strd	r4, r5, [r0, #8]
    520c:	2300      	movs	r3, #0
    520e:	4618      	mov	r0, r3
    5210:	b008      	add	sp, #32
    5212:	bd70      	pop	{r4, r5, r6, pc}
    5214:	ee30 7b40 	vsub.f64	d7, d0, d0
    5218:	2300      	movs	r3, #0
    521a:	ed80 7b02 	vstr	d7, [r0, #8]
    521e:	ed80 7b00 	vstr	d7, [r0]
    5222:	e7f4      	b.n	520e <__ieee754_rem_pio2+0xe6>
    5224:	ed9f 5b56 	vldr	d5, [pc, #344]	; 5380 <__ieee754_rem_pio2+0x258>
    5228:	ed9f 6b57 	vldr	d6, [pc, #348]	; 5388 <__ieee754_rem_pio2+0x260>
    522c:	ee37 7b45 	vsub.f64	d7, d7, d5
    5230:	e796      	b.n	5160 <__ieee754_rem_pio2+0x38>
    5232:	f000 feb3 	bl	5f9c <fabs>
    5236:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    523a:	ed9f 6b55 	vldr	d6, [pc, #340]	; 5390 <__ieee754_rem_pio2+0x268>
    523e:	eea0 7b06 	vfma.f64	d7, d0, d6
    5242:	eefd 7bc7 	vcvt.s32.f64	s15, d7
    5246:	ed9f 3b48 	vldr	d3, [pc, #288]	; 5368 <__ieee754_rem_pio2+0x240>
    524a:	ee17 3a90 	vmov	r3, s15
    524e:	ed9f 6b48 	vldr	d6, [pc, #288]	; 5370 <__ieee754_rem_pio2+0x248>
    5252:	2b1f      	cmp	r3, #31
    5254:	eeb8 5be7 	vcvt.f64.s32	d5, s15
    5258:	eeb1 4b45 	vneg.f64	d4, d5
    525c:	ee25 7b06 	vmul.f64	d7, d5, d6
    5260:	eea4 0b03 	vfma.f64	d0, d4, d3
    5264:	dc1b      	bgt.n	529e <__ieee754_rem_pio2+0x176>
    5266:	4a55      	ldr	r2, [pc, #340]	; (53bc <__ieee754_rem_pio2+0x294>)
    5268:	1e59      	subs	r1, r3, #1
    526a:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    526e:	4296      	cmp	r6, r2
    5270:	d015      	beq.n	529e <__ieee754_rem_pio2+0x176>
    5272:	ee30 6b47 	vsub.f64	d6, d0, d7
    5276:	ed84 6b00 	vstr	d6, [r4]
    527a:	ee30 0b46 	vsub.f64	d0, d0, d6
    527e:	ee30 0b47 	vsub.f64	d0, d0, d7
    5282:	2d00      	cmp	r5, #0
    5284:	ed84 0b02 	vstr	d0, [r4, #8]
    5288:	dac1      	bge.n	520e <__ieee754_rem_pio2+0xe6>
    528a:	eeb1 6b46 	vneg.f64	d6, d6
    528e:	eeb1 0b40 	vneg.f64	d0, d0
    5292:	ed84 6b00 	vstr	d6, [r4]
    5296:	ed84 0b02 	vstr	d0, [r4, #8]
    529a:	425b      	negs	r3, r3
    529c:	e7b7      	b.n	520e <__ieee754_rem_pio2+0xe6>
    529e:	ee30 6b47 	vsub.f64	d6, d0, d7
    52a2:	ee16 2a90 	vmov	r2, s13
    52a6:	1536      	asrs	r6, r6, #20
    52a8:	f3c2 520a 	ubfx	r2, r2, #20, #11
    52ac:	1ab2      	subs	r2, r6, r2
    52ae:	2a10      	cmp	r2, #16
    52b0:	ed84 6b00 	vstr	d6, [r4]
    52b4:	dde1      	ble.n	527a <__ieee754_rem_pio2+0x152>
    52b6:	eeb0 3b40 	vmov.f64	d3, d0
    52ba:	ed9f 7b31 	vldr	d7, [pc, #196]	; 5380 <__ieee754_rem_pio2+0x258>
    52be:	ed9f 6b32 	vldr	d6, [pc, #200]	; 5388 <__ieee754_rem_pio2+0x260>
    52c2:	eea4 3b07 	vfma.f64	d3, d4, d7
    52c6:	ee30 0b43 	vsub.f64	d0, d0, d3
    52ca:	eea4 0b07 	vfma.f64	d0, d4, d7
    52ce:	eeb0 7b40 	vmov.f64	d7, d0
    52d2:	ee95 7b06 	vfnms.f64	d7, d5, d6
    52d6:	ee33 6b47 	vsub.f64	d6, d3, d7
    52da:	ee16 2a90 	vmov	r2, s13
    52de:	f3c2 520a 	ubfx	r2, r2, #20, #11
    52e2:	1ab6      	subs	r6, r6, r2
    52e4:	2e31      	cmp	r6, #49	; 0x31
    52e6:	ed84 6b00 	vstr	d6, [r4]
    52ea:	dd39      	ble.n	5360 <__ieee754_rem_pio2+0x238>
    52ec:	eeb0 0b43 	vmov.f64	d0, d3
    52f0:	ed9f 6b29 	vldr	d6, [pc, #164]	; 5398 <__ieee754_rem_pio2+0x270>
    52f4:	ed9f 2b2a 	vldr	d2, [pc, #168]	; 53a0 <__ieee754_rem_pio2+0x278>
    52f8:	eea4 0b06 	vfma.f64	d0, d4, d6
    52fc:	ee33 7b40 	vsub.f64	d7, d3, d0
    5300:	eea4 7b06 	vfma.f64	d7, d4, d6
    5304:	ee95 7b02 	vfnms.f64	d7, d5, d2
    5308:	e7b3      	b.n	5272 <__ieee754_rem_pio2+0x14a>
    530a:	492d      	ldr	r1, [pc, #180]	; (53c0 <__ieee754_rem_pio2+0x298>)
    530c:	ee30 7b07 	vadd.f64	d7, d0, d7
    5310:	428e      	cmp	r6, r1
    5312:	d01e      	beq.n	5352 <__ieee754_rem_pio2+0x22a>
    5314:	ed9f 6b16 	vldr	d6, [pc, #88]	; 5370 <__ieee754_rem_pio2+0x248>
    5318:	ee37 5b06 	vadd.f64	d5, d7, d6
    531c:	ee37 7b45 	vsub.f64	d7, d7, d5
    5320:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5324:	ee37 7b06 	vadd.f64	d7, d7, d6
    5328:	ed80 5b00 	vstr	d5, [r0]
    532c:	ed80 7b02 	vstr	d7, [r0, #8]
    5330:	e76d      	b.n	520e <__ieee754_rem_pio2+0xe6>
    5332:	ed94 6b00 	vldr	d6, [r4]
    5336:	ed94 7b02 	vldr	d7, [r4, #8]
    533a:	eeb1 6b46 	vneg.f64	d6, d6
    533e:	eeb1 7b47 	vneg.f64	d7, d7
    5342:	4243      	negs	r3, r0
    5344:	ed84 6b00 	vstr	d6, [r4]
    5348:	ed84 7b02 	vstr	d7, [r4, #8]
    534c:	e75f      	b.n	520e <__ieee754_rem_pio2+0xe6>
    534e:	2303      	movs	r3, #3
    5350:	e749      	b.n	51e6 <__ieee754_rem_pio2+0xbe>
    5352:	ed9f 5b0b 	vldr	d5, [pc, #44]	; 5380 <__ieee754_rem_pio2+0x258>
    5356:	ed9f 6b0c 	vldr	d6, [pc, #48]	; 5388 <__ieee754_rem_pio2+0x260>
    535a:	ee37 7b05 	vadd.f64	d7, d7, d5
    535e:	e7db      	b.n	5318 <__ieee754_rem_pio2+0x1f0>
    5360:	eeb0 0b43 	vmov.f64	d0, d3
    5364:	e789      	b.n	527a <__ieee754_rem_pio2+0x152>
    5366:	bf00      	nop
    5368:	54400000 	.word	0x54400000
    536c:	3ff921fb 	.word	0x3ff921fb
    5370:	1a626331 	.word	0x1a626331
    5374:	3dd0b461 	.word	0x3dd0b461
    5378:	00000000 	.word	0x00000000
    537c:	41700000 	.word	0x41700000
    5380:	1a600000 	.word	0x1a600000
    5384:	3dd0b461 	.word	0x3dd0b461
    5388:	2e037073 	.word	0x2e037073
    538c:	3ba3198a 	.word	0x3ba3198a
    5390:	6dc9c883 	.word	0x6dc9c883
    5394:	3fe45f30 	.word	0x3fe45f30
    5398:	2e000000 	.word	0x2e000000
    539c:	3ba3198a 	.word	0x3ba3198a
    53a0:	252049c1 	.word	0x252049c1
    53a4:	397b839a 	.word	0x397b839a
    53a8:	3fe921fb 	.word	0x3fe921fb
    53ac:	4002d97b 	.word	0x4002d97b
    53b0:	413921fb 	.word	0x413921fb
    53b4:	7fefffff 	.word	0x7fefffff
    53b8:	20000fa8 	.word	0x20000fa8
    53bc:	20000a5c 	.word	0x20000a5c
    53c0:	3ff921fb 	.word	0x3ff921fb

000053c4 <__ieee754_sqrt>:
    53c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    53c8:	b082      	sub	sp, #8
    53ca:	ed8d 0b00 	vstr	d0, [sp]
    53ce:	495d      	ldr	r1, [pc, #372]	; (5544 <__ieee754_sqrt+0x180>)
    53d0:	9b01      	ldr	r3, [sp, #4]
    53d2:	9800      	ldr	r0, [sp, #0]
    53d4:	460c      	mov	r4, r1
    53d6:	4019      	ands	r1, r3
    53d8:	42a1      	cmp	r1, r4
    53da:	f000 8098 	beq.w	550e <__ieee754_sqrt+0x14a>
    53de:	2b00      	cmp	r3, #0
    53e0:	4602      	mov	r2, r0
    53e2:	dd77      	ble.n	54d4 <__ieee754_sqrt+0x110>
    53e4:	151f      	asrs	r7, r3, #20
    53e6:	f000 8082 	beq.w	54ee <__ieee754_sqrt+0x12a>
    53ea:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
    53ee:	f3c3 0313 	ubfx	r3, r3, #0, #20
    53f2:	07f9      	lsls	r1, r7, #31
    53f4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    53f8:	d467      	bmi.n	54ca <__ieee754_sqrt+0x106>
    53fa:	eb03 71d2 	add.w	r1, r3, r2, lsr #31
    53fe:	2600      	movs	r6, #0
    5400:	440b      	add	r3, r1
    5402:	107f      	asrs	r7, r7, #1
    5404:	0052      	lsls	r2, r2, #1
    5406:	46b6      	mov	lr, r6
    5408:	2016      	movs	r0, #22
    540a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    540e:	eb0e 0401 	add.w	r4, lr, r1
    5412:	429c      	cmp	r4, r3
    5414:	ea4f 75d2 	mov.w	r5, r2, lsr #31
    5418:	ea4f 0242 	mov.w	r2, r2, lsl #1
    541c:	dc03      	bgt.n	5426 <__ieee754_sqrt+0x62>
    541e:	1b1b      	subs	r3, r3, r4
    5420:	eb04 0e01 	add.w	lr, r4, r1
    5424:	440e      	add	r6, r1
    5426:	3801      	subs	r0, #1
    5428:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    542c:	ea4f 0151 	mov.w	r1, r1, lsr #1
    5430:	d1ed      	bne.n	540e <__ieee754_sqrt+0x4a>
    5432:	4684      	mov	ip, r0
    5434:	2420      	movs	r4, #32
    5436:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    543a:	e009      	b.n	5450 <__ieee754_sqrt+0x8c>
    543c:	d020      	beq.n	5480 <__ieee754_sqrt+0xbc>
    543e:	eb03 75d2 	add.w	r5, r3, r2, lsr #31
    5442:	3c01      	subs	r4, #1
    5444:	ea4f 0151 	mov.w	r1, r1, lsr #1
    5448:	442b      	add	r3, r5
    544a:	ea4f 0242 	mov.w	r2, r2, lsl #1
    544e:	d020      	beq.n	5492 <__ieee754_sqrt+0xce>
    5450:	459e      	cmp	lr, r3
    5452:	eb01 050c 	add.w	r5, r1, ip
    5456:	daf1      	bge.n	543c <__ieee754_sqrt+0x78>
    5458:	2d00      	cmp	r5, #0
    545a:	eb05 0c01 	add.w	ip, r5, r1
    545e:	db09      	blt.n	5474 <__ieee754_sqrt+0xb0>
    5460:	46f0      	mov	r8, lr
    5462:	4295      	cmp	r5, r2
    5464:	ebce 0303 	rsb	r3, lr, r3
    5468:	d900      	bls.n	546c <__ieee754_sqrt+0xa8>
    546a:	3b01      	subs	r3, #1
    546c:	1b52      	subs	r2, r2, r5
    546e:	4408      	add	r0, r1
    5470:	46c6      	mov	lr, r8
    5472:	e7e4      	b.n	543e <__ieee754_sqrt+0x7a>
    5474:	f1bc 0f00 	cmp.w	ip, #0
    5478:	dbf2      	blt.n	5460 <__ieee754_sqrt+0x9c>
    547a:	f10e 0801 	add.w	r8, lr, #1
    547e:	e7f0      	b.n	5462 <__ieee754_sqrt+0x9e>
    5480:	4295      	cmp	r5, r2
    5482:	d81a      	bhi.n	54ba <__ieee754_sqrt+0xf6>
    5484:	2d00      	cmp	r5, #0
    5486:	eb05 0c01 	add.w	ip, r5, r1
    548a:	db48      	blt.n	551e <__ieee754_sqrt+0x15a>
    548c:	4698      	mov	r8, r3
    548e:	2300      	movs	r3, #0
    5490:	e7ec      	b.n	546c <__ieee754_sqrt+0xa8>
    5492:	4313      	orrs	r3, r2
    5494:	d113      	bne.n	54be <__ieee754_sqrt+0xfa>
    5496:	0840      	lsrs	r0, r0, #1
    5498:	1071      	asrs	r1, r6, #1
    549a:	07f3      	lsls	r3, r6, #31
    549c:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
    54a0:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
    54a4:	bf48      	it	mi
    54a6:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
    54aa:	eb01 5307 	add.w	r3, r1, r7, lsl #20
    54ae:	4602      	mov	r2, r0
    54b0:	ec43 2b10 	vmov	d0, r2, r3
    54b4:	b002      	add	sp, #8
    54b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    54ba:	4673      	mov	r3, lr
    54bc:	e7bf      	b.n	543e <__ieee754_sqrt+0x7a>
    54be:	1c42      	adds	r2, r0, #1
    54c0:	d031      	beq.n	5526 <__ieee754_sqrt+0x162>
    54c2:	f000 0301 	and.w	r3, r0, #1
    54c6:	4418      	add	r0, r3
    54c8:	e7e5      	b.n	5496 <__ieee754_sqrt+0xd2>
    54ca:	005b      	lsls	r3, r3, #1
    54cc:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
    54d0:	0052      	lsls	r2, r2, #1
    54d2:	e792      	b.n	53fa <__ieee754_sqrt+0x36>
    54d4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    54d8:	4301      	orrs	r1, r0
    54da:	d01d      	beq.n	5518 <__ieee754_sqrt+0x154>
    54dc:	bb5b      	cbnz	r3, 5536 <__ieee754_sqrt+0x172>
    54de:	461f      	mov	r7, r3
    54e0:	0ad3      	lsrs	r3, r2, #11
    54e2:	3f15      	subs	r7, #21
    54e4:	0552      	lsls	r2, r2, #21
    54e6:	2b00      	cmp	r3, #0
    54e8:	d0fa      	beq.n	54e0 <__ieee754_sqrt+0x11c>
    54ea:	02dd      	lsls	r5, r3, #11
    54ec:	d41e      	bmi.n	552c <__ieee754_sqrt+0x168>
    54ee:	2100      	movs	r1, #0
    54f0:	e000      	b.n	54f4 <__ieee754_sqrt+0x130>
    54f2:	4601      	mov	r1, r0
    54f4:	005b      	lsls	r3, r3, #1
    54f6:	02dc      	lsls	r4, r3, #11
    54f8:	f101 0001 	add.w	r0, r1, #1
    54fc:	d5f9      	bpl.n	54f2 <__ieee754_sqrt+0x12e>
    54fe:	f1c0 0420 	rsb	r4, r0, #32
    5502:	fa22 f404 	lsr.w	r4, r2, r4
    5506:	4323      	orrs	r3, r4
    5508:	1a7f      	subs	r7, r7, r1
    550a:	4082      	lsls	r2, r0
    550c:	e76d      	b.n	53ea <__ieee754_sqrt+0x26>
    550e:	eea0 0b00 	vfma.f64	d0, d0, d0
    5512:	b002      	add	sp, #8
    5514:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5518:	ed9d 0b00 	vldr	d0, [sp]
    551c:	e7ca      	b.n	54b4 <__ieee754_sqrt+0xf0>
    551e:	f1bc 0f00 	cmp.w	ip, #0
    5522:	daaa      	bge.n	547a <__ieee754_sqrt+0xb6>
    5524:	e7b2      	b.n	548c <__ieee754_sqrt+0xc8>
    5526:	3601      	adds	r6, #1
    5528:	4620      	mov	r0, r4
    552a:	e7b5      	b.n	5498 <__ieee754_sqrt+0xd4>
    552c:	2420      	movs	r4, #32
    552e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    5532:	2000      	movs	r0, #0
    5534:	e7e5      	b.n	5502 <__ieee754_sqrt+0x13e>
    5536:	ed9d 7b00 	vldr	d7, [sp]
    553a:	ee37 7b47 	vsub.f64	d7, d7, d7
    553e:	ee87 0b07 	vdiv.f64	d0, d7, d7
    5542:	e7b7      	b.n	54b4 <__ieee754_sqrt+0xf0>
    5544:	7ff00000 	.word	0x7ff00000

00005548 <__kernel_cos>:
    5548:	ee10 3a90 	vmov	r3, s1
    554c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5550:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
    5554:	da2c      	bge.n	55b0 <__kernel_cos+0x68>
    5556:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    555a:	ee17 3a90 	vmov	r3, s15
    555e:	2b00      	cmp	r3, #0
    5560:	d061      	beq.n	5626 <__kernel_cos+0xde>
    5562:	ee20 7b00 	vmul.f64	d7, d0, d0
    5566:	ed9f 4b32 	vldr	d4, [pc, #200]	; 5630 <__kernel_cos+0xe8>
    556a:	ed9f 5b33 	vldr	d5, [pc, #204]	; 5638 <__kernel_cos+0xf0>
    556e:	ed9f 6b34 	vldr	d6, [pc, #208]	; 5640 <__kernel_cos+0xf8>
    5572:	eea7 5b04 	vfma.f64	d5, d7, d4
    5576:	ed9f 4b34 	vldr	d4, [pc, #208]	; 5648 <__kernel_cos+0x100>
    557a:	eea7 6b05 	vfma.f64	d6, d7, d5
    557e:	ed9f 5b34 	vldr	d5, [pc, #208]	; 5650 <__kernel_cos+0x108>
    5582:	eea7 4b06 	vfma.f64	d4, d7, d6
    5586:	ed9f 6b34 	vldr	d6, [pc, #208]	; 5658 <__kernel_cos+0x110>
    558a:	eea7 5b04 	vfma.f64	d5, d7, d4
    558e:	eea7 6b05 	vfma.f64	d6, d7, d5
    5592:	ee26 6b07 	vmul.f64	d6, d6, d7
    5596:	ee21 0b40 	vnmul.f64	d0, d1, d0
    559a:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
    559e:	eea7 0b06 	vfma.f64	d0, d7, d6
    55a2:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    55a6:	ee97 0b05 	vfnms.f64	d0, d7, d5
    55aa:	ee36 0b40 	vsub.f64	d0, d6, d0
    55ae:	4770      	bx	lr
    55b0:	ed9f 4b1f 	vldr	d4, [pc, #124]	; 5630 <__kernel_cos+0xe8>
    55b4:	ee20 7b00 	vmul.f64	d7, d0, d0
    55b8:	ed9f 5b1f 	vldr	d5, [pc, #124]	; 5638 <__kernel_cos+0xf0>
    55bc:	ed9f 6b20 	vldr	d6, [pc, #128]	; 5640 <__kernel_cos+0xf8>
    55c0:	eea7 5b04 	vfma.f64	d5, d7, d4
    55c4:	ed9f 4b20 	vldr	d4, [pc, #128]	; 5648 <__kernel_cos+0x100>
    55c8:	eea7 6b05 	vfma.f64	d6, d7, d5
    55cc:	4a24      	ldr	r2, [pc, #144]	; (5660 <__kernel_cos+0x118>)
    55ce:	eea7 4b06 	vfma.f64	d4, d7, d6
    55d2:	ed9f 5b1f 	vldr	d5, [pc, #124]	; 5650 <__kernel_cos+0x108>
    55d6:	ed9f 6b20 	vldr	d6, [pc, #128]	; 5658 <__kernel_cos+0x110>
    55da:	eea7 5b04 	vfma.f64	d5, d7, d4
    55de:	4293      	cmp	r3, r2
    55e0:	eea7 6b05 	vfma.f64	d6, d7, d5
    55e4:	ee26 6b07 	vmul.f64	d6, d6, d7
    55e8:	ddd5      	ble.n	5596 <__kernel_cos+0x4e>
    55ea:	4a1e      	ldr	r2, [pc, #120]	; (5664 <__kernel_cos+0x11c>)
    55ec:	4293      	cmp	r3, r2
    55ee:	dc15      	bgt.n	561c <__kernel_cos+0xd4>
    55f0:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
    55f4:	2000      	movs	r0, #0
    55f6:	f5a3 1100 	sub.w	r1, r3, #2097152	; 0x200000
    55fa:	ec41 0b15 	vmov	d5, r0, r1
    55fe:	ee34 4b45 	vsub.f64	d4, d4, d5
    5602:	ee21 1b40 	vnmul.f64	d1, d1, d0
    5606:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    560a:	eea7 1b06 	vfma.f64	d1, d7, d6
    560e:	ee97 5b03 	vfnms.f64	d5, d7, d3
    5612:	ee35 5b41 	vsub.f64	d5, d5, d1
    5616:	ee34 0b45 	vsub.f64	d0, d4, d5
    561a:	4770      	bx	lr
    561c:	eeb6 4b07 	vmov.f64	d4, #103	; 0x3f380000  0.7187500
    5620:	eeb5 5b02 	vmov.f64	d5, #82	; 0x3e900000  0.2812500
    5624:	e7ed      	b.n	5602 <__kernel_cos+0xba>
    5626:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    562a:	4770      	bx	lr
    562c:	f3af 8000 	nop.w
    5630:	be8838d4 	.word	0xbe8838d4
    5634:	bda8fae9 	.word	0xbda8fae9
    5638:	bdb4b1c4 	.word	0xbdb4b1c4
    563c:	3e21ee9e 	.word	0x3e21ee9e
    5640:	809c52ad 	.word	0x809c52ad
    5644:	be927e4f 	.word	0xbe927e4f
    5648:	19cb1590 	.word	0x19cb1590
    564c:	3efa01a0 	.word	0x3efa01a0
    5650:	16c15177 	.word	0x16c15177
    5654:	bf56c16c 	.word	0xbf56c16c
    5658:	5555554c 	.word	0x5555554c
    565c:	3fa55555 	.word	0x3fa55555
    5660:	3fd33332 	.word	0x3fd33332
    5664:	3fe90000 	.word	0x3fe90000

00005668 <__kernel_rem_pio2>:
    5668:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    566c:	ed2d 8b08 	vpush	{d8-d11}
    5670:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
    5674:	4cb0      	ldr	r4, [pc, #704]	; (5938 <__kernel_rem_pio2+0x2d0>)
    5676:	9ea4      	ldr	r6, [sp, #656]	; 0x290
    5678:	4db0      	ldr	r5, [pc, #704]	; (593c <__kernel_rem_pio2+0x2d4>)
    567a:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
    567e:	9301      	str	r3, [sp, #4]
    5680:	1ed4      	subs	r4, r2, #3
    5682:	fb85 7504 	smull	r7, r5, r5, r4
    5686:	17e4      	asrs	r4, r4, #31
    5688:	ebc4 04a5 	rsb	r4, r4, r5, asr #2
    568c:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
    5690:	1e5f      	subs	r7, r3, #1
    5692:	f104 0a01 	add.w	sl, r4, #1
    5696:	ebaa 0a8a 	sub.w	sl, sl, sl, lsl #2
    569a:	468b      	mov	fp, r1
    569c:	19f1      	adds	r1, r6, r7
    569e:	9402      	str	r4, [sp, #8]
    56a0:	4681      	mov	r9, r0
    56a2:	eb02 0aca 	add.w	sl, r2, sl, lsl #3
    56a6:	eba4 0307 	sub.w	r3, r4, r7
    56aa:	d418      	bmi.n	56de <__kernel_rem_pio2+0x76>
    56ac:	4419      	add	r1, r3
    56ae:	3101      	adds	r1, #1
    56b0:	aa1a      	add	r2, sp, #104	; 0x68
    56b2:	98a5      	ldr	r0, [sp, #660]	; 0x294
    56b4:	e00a      	b.n	56cc <__kernel_rem_pio2+0x64>
    56b6:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    56ba:	ee07 4a90 	vmov	s15, r4
    56be:	3301      	adds	r3, #1
    56c0:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    56c4:	428b      	cmp	r3, r1
    56c6:	eca2 7b02 	vstmia	r2!, {d7}
    56ca:	d008      	beq.n	56de <__kernel_rem_pio2+0x76>
    56cc:	2b00      	cmp	r3, #0
    56ce:	daf2      	bge.n	56b6 <__kernel_rem_pio2+0x4e>
    56d0:	ed9f 7b93 	vldr	d7, [pc, #588]	; 5920 <__kernel_rem_pio2+0x2b8>
    56d4:	3301      	adds	r3, #1
    56d6:	428b      	cmp	r3, r1
    56d8:	eca2 7b02 	vstmia	r2!, {d7}
    56dc:	d1f6      	bne.n	56cc <__kernel_rem_pio2+0x64>
    56de:	2e00      	cmp	r6, #0
    56e0:	f2c0 82e2 	blt.w	5ca8 <__kernel_rem_pio2+0x640>
    56e4:	9b01      	ldr	r3, [sp, #4]
    56e6:	a86a      	add	r0, sp, #424	; 0x1a8
    56e8:	f106 0e01 	add.w	lr, r6, #1
    56ec:	00dc      	lsls	r4, r3, #3
    56ee:	eb00 0ece 	add.w	lr, r0, lr, lsl #3
    56f2:	eb09 0104 	add.w	r1, r9, r4
    56f6:	463d      	mov	r5, r7
    56f8:	2f00      	cmp	r7, #0
    56fa:	f2c0 81c8 	blt.w	5a8e <__kernel_rem_pio2+0x426>
    56fe:	ab1a      	add	r3, sp, #104	; 0x68
    5700:	ed9f 7b87 	vldr	d7, [pc, #540]	; 5920 <__kernel_rem_pio2+0x2b8>
    5704:	eb03 02c5 	add.w	r2, r3, r5, lsl #3
    5708:	3208      	adds	r2, #8
    570a:	464b      	mov	r3, r9
    570c:	ecb3 5b02 	vldmia	r3!, {d5}
    5710:	ed32 6b02 	vldmdb	r2!, {d6}
    5714:	428b      	cmp	r3, r1
    5716:	eea5 7b06 	vfma.f64	d7, d5, d6
    571a:	d1f7      	bne.n	570c <__kernel_rem_pio2+0xa4>
    571c:	eca0 7b02 	vstmia	r0!, {d7}
    5720:	4570      	cmp	r0, lr
    5722:	f105 0501 	add.w	r5, r5, #1
    5726:	d1e7      	bne.n	56f8 <__kernel_rem_pio2+0x90>
    5728:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
    572c:	3b02      	subs	r3, #2
    572e:	009b      	lsls	r3, r3, #2
    5730:	aa06      	add	r2, sp, #24
    5732:	ed9f 9b7d 	vldr	d9, [pc, #500]	; 5928 <__kernel_rem_pio2+0x2c0>
    5736:	ed9f 8b7e 	vldr	d8, [pc, #504]	; 5930 <__kernel_rem_pio2+0x2c8>
    573a:	f103 0804 	add.w	r8, r3, #4
    573e:	4413      	add	r3, r2
    5740:	444c      	add	r4, r9
    5742:	4490      	add	r8, r2
    5744:	9303      	str	r3, [sp, #12]
    5746:	4635      	mov	r5, r6
    5748:	f8cd b010 	str.w	fp, [sp, #16]
    574c:	ab92      	add	r3, sp, #584	; 0x248
    574e:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    5752:	2d00      	cmp	r5, #0
    5754:	ed13 0b28 	vldr	d0, [r3, #-160]	; 0xffffff60
    5758:	dd17      	ble.n	578a <__kernel_rem_pio2+0x122>
    575a:	a96a      	add	r1, sp, #424	; 0x1a8
    575c:	eb01 03c5 	add.w	r3, r1, r5, lsl #3
    5760:	aa05      	add	r2, sp, #20
    5762:	ee20 7b09 	vmul.f64	d7, d0, d9
    5766:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    576a:	ed33 6b02 	vldmdb	r3!, {d6}
    576e:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    5772:	eea7 0b48 	vfms.f64	d0, d7, d8
    5776:	eefd 5bc0 	vcvt.s32.f64	s11, d0
    577a:	428b      	cmp	r3, r1
    577c:	ee15 0a90 	vmov	r0, s11
    5780:	ee37 0b06 	vadd.f64	d0, d7, d6
    5784:	f842 0f04 	str.w	r0, [r2, #4]!
    5788:	d1eb      	bne.n	5762 <__kernel_rem_pio2+0xfa>
    578a:	4650      	mov	r0, sl
    578c:	f000 fca0 	bl	60d0 <scalbn>
    5790:	eeb0 ab40 	vmov.f64	d10, d0
    5794:	eeb4 0b00 	vmov.f64	d0, #64	; 0x3e000000  0.125
    5798:	ee2a 0b00 	vmul.f64	d0, d10, d0
    579c:	f000 fc08 	bl	5fb0 <floor>
    57a0:	eeb2 7b00 	vmov.f64	d7, #32	; 0x41000000  8.0
    57a4:	eea0 ab47 	vfms.f64	d10, d0, d7
    57a8:	eefd 7bca 	vcvt.s32.f64	s15, d10
    57ac:	f1ba 0f00 	cmp.w	sl, #0
    57b0:	ee17 ba90 	vmov	fp, s15
    57b4:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    57b8:	ee3a ab47 	vsub.f64	d10, d10, d7
    57bc:	f340 814c 	ble.w	5a58 <__kernel_rem_pio2+0x3f0>
    57c0:	f105 3eff 	add.w	lr, r5, #4294967295	; 0xffffffff
    57c4:	ab06      	add	r3, sp, #24
    57c6:	f1ca 0218 	rsb	r2, sl, #24
    57ca:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
    57ce:	fa43 f002 	asr.w	r0, r3, r2
    57d2:	fa00 f202 	lsl.w	r2, r0, r2
    57d6:	a906      	add	r1, sp, #24
    57d8:	1a9b      	subs	r3, r3, r2
    57da:	f1ca 0217 	rsb	r2, sl, #23
    57de:	f841 302e 	str.w	r3, [r1, lr, lsl #2]
    57e2:	4483      	add	fp, r0
    57e4:	fa43 f102 	asr.w	r1, r3, r2
    57e8:	2900      	cmp	r1, #0
    57ea:	dd39      	ble.n	5860 <__kernel_rem_pio2+0x1f8>
    57ec:	2d00      	cmp	r5, #0
    57ee:	f10b 0b01 	add.w	fp, fp, #1
    57f2:	f340 8224 	ble.w	5c3e <__kernel_rem_pio2+0x5d6>
    57f6:	2200      	movs	r2, #0
    57f8:	4610      	mov	r0, r2
    57fa:	f10d 0e14 	add.w	lr, sp, #20
    57fe:	468c      	mov	ip, r1
    5800:	e008      	b.n	5814 <__kernel_rem_pio2+0x1ac>
    5802:	f1c3 7180 	rsb	r1, r3, #16777216	; 0x1000000
    5806:	b113      	cbz	r3, 580e <__kernel_rem_pio2+0x1a6>
    5808:	f8ce 1000 	str.w	r1, [lr]
    580c:	2001      	movs	r0, #1
    580e:	3201      	adds	r2, #1
    5810:	4295      	cmp	r5, r2
    5812:	dd0e      	ble.n	5832 <__kernel_rem_pio2+0x1ca>
    5814:	f85e 3f04 	ldr.w	r3, [lr, #4]!
    5818:	2800      	cmp	r0, #0
    581a:	d0f2      	beq.n	5802 <__kernel_rem_pio2+0x19a>
    581c:	f1c3 13ff 	rsb	r3, r3, #16711935	; 0xff00ff
    5820:	3201      	adds	r2, #1
    5822:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    5826:	4295      	cmp	r5, r2
    5828:	f8ce 3000 	str.w	r3, [lr]
    582c:	f04f 0001 	mov.w	r0, #1
    5830:	dcf0      	bgt.n	5814 <__kernel_rem_pio2+0x1ac>
    5832:	4661      	mov	r1, ip
    5834:	f1ba 0f00 	cmp.w	sl, #0
    5838:	dd10      	ble.n	585c <__kernel_rem_pio2+0x1f4>
    583a:	f1ba 0f01 	cmp.w	sl, #1
    583e:	f000 8112 	beq.w	5a66 <__kernel_rem_pio2+0x3fe>
    5842:	f1ba 0f02 	cmp.w	sl, #2
    5846:	d109      	bne.n	585c <__kernel_rem_pio2+0x1f4>
    5848:	1e6a      	subs	r2, r5, #1
    584a:	ab06      	add	r3, sp, #24
    584c:	f10d 0e18 	add.w	lr, sp, #24
    5850:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5854:	f3c3 0315 	ubfx	r3, r3, #0, #22
    5858:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    585c:	2902      	cmp	r1, #2
    585e:	d06f      	beq.n	5940 <__kernel_rem_pio2+0x2d8>
    5860:	eeb5 ab40 	vcmp.f64	d10, #0.0
    5864:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5868:	d17c      	bne.n	5964 <__kernel_rem_pio2+0x2fc>
    586a:	f105 3eff 	add.w	lr, r5, #4294967295	; 0xffffffff
    586e:	4576      	cmp	r6, lr
    5870:	dc0f      	bgt.n	5892 <__kernel_rem_pio2+0x22a>
    5872:	f105 4280 	add.w	r2, r5, #1073741824	; 0x40000000
    5876:	3a01      	subs	r2, #1
    5878:	ab06      	add	r3, sp, #24
    587a:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    587e:	2000      	movs	r0, #0
    5880:	f852 3904 	ldr.w	r3, [r2], #-4
    5884:	4542      	cmp	r2, r8
    5886:	ea40 0003 	orr.w	r0, r0, r3
    588a:	d1f9      	bne.n	5880 <__kernel_rem_pio2+0x218>
    588c:	2800      	cmp	r0, #0
    588e:	f040 8115 	bne.w	5abc <__kernel_rem_pio2+0x454>
    5892:	1e73      	subs	r3, r6, #1
    5894:	aa06      	add	r2, sp, #24
    5896:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    589a:	2b00      	cmp	r3, #0
    589c:	f040 81cc 	bne.w	5c38 <__kernel_rem_pio2+0x5d0>
    58a0:	9b03      	ldr	r3, [sp, #12]
    58a2:	f04f 0e01 	mov.w	lr, #1
    58a6:	f853 2904 	ldr.w	r2, [r3], #-4
    58aa:	f10e 0e01 	add.w	lr, lr, #1
    58ae:	2a00      	cmp	r2, #0
    58b0:	d0f9      	beq.n	58a6 <__kernel_rem_pio2+0x23e>
    58b2:	44ae      	add	lr, r5
    58b4:	1c6b      	adds	r3, r5, #1
    58b6:	4573      	cmp	r3, lr
    58b8:	dc2d      	bgt.n	5916 <__kernel_rem_pio2+0x2ae>
    58ba:	9a02      	ldr	r2, [sp, #8]
    58bc:	1898      	adds	r0, r3, r2
    58be:	9a01      	ldr	r2, [sp, #4]
    58c0:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    58c4:	1951      	adds	r1, r2, r5
    58c6:	eb0e 0c02 	add.w	ip, lr, r2
    58ca:	9aa5      	ldr	r2, [sp, #660]	; 0x294
    58cc:	3801      	subs	r0, #1
    58ce:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    58d2:	aa1a      	add	r2, sp, #104	; 0x68
    58d4:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
    58d8:	eb02 0ccc 	add.w	ip, r2, ip, lsl #3
    58dc:	aa6a      	add	r2, sp, #424	; 0x1a8
    58de:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
    58e2:	f850 3f04 	ldr.w	r3, [r0, #4]!
    58e6:	ee07 3a10 	vmov	s14, r3
    58ea:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    58ee:	2f00      	cmp	r7, #0
    58f0:	eca1 7b02 	vstmia	r1!, {d7}
    58f4:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 5920 <__kernel_rem_pio2+0x2b8>
    58f8:	db09      	blt.n	590e <__kernel_rem_pio2+0x2a6>
    58fa:	464b      	mov	r3, r9
    58fc:	460a      	mov	r2, r1
    58fe:	ecb3 5b02 	vldmia	r3!, {d5}
    5902:	ed32 6b02 	vldmdb	r2!, {d6}
    5906:	42a3      	cmp	r3, r4
    5908:	eea5 7b06 	vfma.f64	d7, d5, d6
    590c:	d1f7      	bne.n	58fe <__kernel_rem_pio2+0x296>
    590e:	4561      	cmp	r1, ip
    5910:	eca5 7b02 	vstmia	r5!, {d7}
    5914:	d1e5      	bne.n	58e2 <__kernel_rem_pio2+0x27a>
    5916:	4675      	mov	r5, lr
    5918:	e718      	b.n	574c <__kernel_rem_pio2+0xe4>
    591a:	bf00      	nop
    591c:	f3af 8000 	nop.w
	...
    592c:	3e700000 	.word	0x3e700000
    5930:	00000000 	.word	0x00000000
    5934:	41700000 	.word	0x41700000
    5938:	20000a4c 	.word	0x20000a4c
    593c:	2aaaaaab 	.word	0x2aaaaaab
    5940:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    5944:	ee30 ab4a 	vsub.f64	d10, d0, d10
    5948:	2800      	cmp	r0, #0
    594a:	d089      	beq.n	5860 <__kernel_rem_pio2+0x1f8>
    594c:	4650      	mov	r0, sl
    594e:	9105      	str	r1, [sp, #20]
    5950:	f000 fbbe 	bl	60d0 <scalbn>
    5954:	ee3a ab40 	vsub.f64	d10, d10, d0
    5958:	eeb5 ab40 	vcmp.f64	d10, #0.0
    595c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5960:	9905      	ldr	r1, [sp, #20]
    5962:	d082      	beq.n	586a <__kernel_rem_pio2+0x202>
    5964:	eeb0 0b4a 	vmov.f64	d0, d10
    5968:	f1ca 0000 	rsb	r0, sl, #0
    596c:	ee0b ba10 	vmov	s22, fp
    5970:	4689      	mov	r9, r1
    5972:	f8dd b010 	ldr.w	fp, [sp, #16]
    5976:	f000 fbab 	bl	60d0 <scalbn>
    597a:	ed9f 6bd1 	vldr	d6, [pc, #836]	; 5cc0 <__kernel_rem_pio2+0x658>
    597e:	eeb4 0bc6 	vcmpe.f64	d0, d6
    5982:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5986:	f2c0 8172 	blt.w	5c6e <__kernel_rem_pio2+0x606>
    598a:	ed9f 7bcf 	vldr	d7, [pc, #828]	; 5cc8 <__kernel_rem_pio2+0x660>
    598e:	ee20 7b07 	vmul.f64	d7, d0, d7
    5992:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    5996:	a906      	add	r1, sp, #24
    5998:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
    599c:	eea5 0b46 	vfms.f64	d0, d5, d6
    59a0:	eebd 0bc0 	vcvt.s32.f64	s0, d0
    59a4:	1c6b      	adds	r3, r5, #1
    59a6:	ee10 2a10 	vmov	r2, s0
    59aa:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    59ae:	ee17 2a10 	vmov	r2, s14
    59b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    59b6:	f10a 0a18 	add.w	sl, sl, #24
    59ba:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    59be:	4650      	mov	r0, sl
    59c0:	9301      	str	r3, [sp, #4]
    59c2:	f000 fb85 	bl	60d0 <scalbn>
    59c6:	9b01      	ldr	r3, [sp, #4]
    59c8:	2b00      	cmp	r3, #0
    59ca:	f2c0 815e 	blt.w	5c8a <__kernel_rem_pio2+0x622>
    59ce:	ac6a      	add	r4, sp, #424	; 0x1a8
    59d0:	00df      	lsls	r7, r3, #3
    59d2:	aa06      	add	r2, sp, #24
    59d4:	ed9f 6bbc 	vldr	d6, [pc, #752]	; 5cc8 <__kernel_rem_pio2+0x660>
    59d8:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    59dc:	eb04 0c07 	add.w	ip, r4, r7
    59e0:	3204      	adds	r2, #4
    59e2:	f10c 0008 	add.w	r0, ip, #8
    59e6:	ed32 7a01 	vldmdb	r2!, {s14}
    59ea:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    59ee:	ee27 7b00 	vmul.f64	d7, d7, d0
    59f2:	ed20 7b02 	vstmdb	r0!, {d7}
    59f6:	ee20 0b06 	vmul.f64	d0, d0, d6
    59fa:	42a0      	cmp	r0, r4
    59fc:	d1f3      	bne.n	59e6 <__kernel_rem_pio2+0x37e>
    59fe:	f50d 78d0 	add.w	r8, sp, #416	; 0x1a0
    5a02:	2500      	movs	r5, #0
    5a04:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    5a08:	2e00      	cmp	r6, #0
    5a0a:	f2c0 8112 	blt.w	5c32 <__kernel_rem_pio2+0x5ca>
    5a0e:	48b4      	ldr	r0, [pc, #720]	; (5ce0 <__kernel_rem_pio2+0x678>)
    5a10:	4661      	mov	r1, ip
    5a12:	ed9f 6baf 	vldr	d6, [pc, #700]	; 5cd0 <__kernel_rem_pio2+0x668>
    5a16:	ed9f 7bb0 	vldr	d7, [pc, #704]	; 5cd8 <__kernel_rem_pio2+0x670>
    5a1a:	2200      	movs	r2, #0
    5a1c:	e003      	b.n	5a26 <__kernel_rem_pio2+0x3be>
    5a1e:	4295      	cmp	r5, r2
    5a20:	db08      	blt.n	5a34 <__kernel_rem_pio2+0x3cc>
    5a22:	ecb0 6b02 	vldmia	r0!, {d6}
    5a26:	ecb1 5b02 	vldmia	r1!, {d5}
    5a2a:	3201      	adds	r2, #1
    5a2c:	4296      	cmp	r6, r2
    5a2e:	eea5 7b06 	vfma.f64	d7, d5, d6
    5a32:	daf4      	bge.n	5a1e <__kernel_rem_pio2+0x3b6>
    5a34:	f1ac 0c08 	sub.w	ip, ip, #8
    5a38:	eb0e 02c5 	add.w	r2, lr, r5, lsl #3
    5a3c:	45c4      	cmp	ip, r8
    5a3e:	ed82 7b00 	vstr	d7, [r2]
    5a42:	f105 0501 	add.w	r5, r5, #1
    5a46:	d1df      	bne.n	5a08 <__kernel_rem_pio2+0x3a0>
    5a48:	9aa4      	ldr	r2, [sp, #656]	; 0x290
    5a4a:	2a03      	cmp	r2, #3
    5a4c:	f200 80ad 	bhi.w	5baa <__kernel_rem_pio2+0x542>
    5a50:	e8df f002 	tbb	[pc, r2]
    5a54:	50b5b5dd 	.word	0x50b5b5dd
    5a58:	d110      	bne.n	5a7c <__kernel_rem_pio2+0x414>
    5a5a:	1e6b      	subs	r3, r5, #1
    5a5c:	aa06      	add	r2, sp, #24
    5a5e:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    5a62:	15c9      	asrs	r1, r1, #23
    5a64:	e6c0      	b.n	57e8 <__kernel_rem_pio2+0x180>
    5a66:	1e6a      	subs	r2, r5, #1
    5a68:	ab06      	add	r3, sp, #24
    5a6a:	f10d 0e18 	add.w	lr, sp, #24
    5a6e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5a72:	f3c3 0316 	ubfx	r3, r3, #0, #23
    5a76:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    5a7a:	e6ef      	b.n	585c <__kernel_rem_pio2+0x1f4>
    5a7c:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    5a80:	eeb4 abc7 	vcmpe.f64	d10, d7
    5a84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5a88:	da0b      	bge.n	5aa2 <__kernel_rem_pio2+0x43a>
    5a8a:	2100      	movs	r1, #0
    5a8c:	e6e8      	b.n	5860 <__kernel_rem_pio2+0x1f8>
    5a8e:	ed9f 7b92 	vldr	d7, [pc, #584]	; 5cd8 <__kernel_rem_pio2+0x670>
    5a92:	eca0 7b02 	vstmia	r0!, {d7}
    5a96:	4570      	cmp	r0, lr
    5a98:	f105 0501 	add.w	r5, r5, #1
    5a9c:	f47f ae2c 	bne.w	56f8 <__kernel_rem_pio2+0x90>
    5aa0:	e642      	b.n	5728 <__kernel_rem_pio2+0xc0>
    5aa2:	2d00      	cmp	r5, #0
    5aa4:	f10b 0b01 	add.w	fp, fp, #1
    5aa8:	bfc8      	it	gt
    5aaa:	2102      	movgt	r1, #2
    5aac:	f73f aea3 	bgt.w	57f6 <__kernel_rem_pio2+0x18e>
    5ab0:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    5ab4:	2102      	movs	r1, #2
    5ab6:	ee37 ab4a 	vsub.f64	d10, d7, d10
    5aba:	e6d1      	b.n	5860 <__kernel_rem_pio2+0x1f8>
    5abc:	aa06      	add	r2, sp, #24
    5abe:	ee0b ba10 	vmov	s22, fp
    5ac2:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
    5ac6:	f8dd b010 	ldr.w	fp, [sp, #16]
    5aca:	4673      	mov	r3, lr
    5acc:	4689      	mov	r9, r1
    5ace:	f1aa 0a18 	sub.w	sl, sl, #24
    5ad2:	2a00      	cmp	r2, #0
    5ad4:	f47f af71 	bne.w	59ba <__kernel_rem_pio2+0x352>
    5ad8:	f10e 4280 	add.w	r2, lr, #1073741824	; 0x40000000
    5adc:	3a01      	subs	r2, #1
    5ade:	a906      	add	r1, sp, #24
    5ae0:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    5ae4:	f852 1904 	ldr.w	r1, [r2], #-4
    5ae8:	3b01      	subs	r3, #1
    5aea:	f1aa 0a18 	sub.w	sl, sl, #24
    5aee:	2900      	cmp	r1, #0
    5af0:	d0f8      	beq.n	5ae4 <__kernel_rem_pio2+0x47c>
    5af2:	e762      	b.n	59ba <__kernel_rem_pio2+0x352>
    5af4:	2b00      	cmp	r3, #0
    5af6:	f340 80c5 	ble.w	5c84 <__kernel_rem_pio2+0x61c>
    5afa:	f103 5200 	add.w	r2, r3, #536870912	; 0x20000000
    5afe:	3a01      	subs	r2, #1
    5b00:	eb0e 0407 	add.w	r4, lr, r7
    5b04:	00d0      	lsls	r0, r2, #3
    5b06:	ed94 7b00 	vldr	d7, [r4]
    5b0a:	f100 0408 	add.w	r4, r0, #8
    5b0e:	3010      	adds	r0, #16
    5b10:	4474      	add	r4, lr
    5b12:	4470      	add	r0, lr
    5b14:	ad44      	add	r5, sp, #272	; 0x110
    5b16:	ed34 6b02 	vldmdb	r4!, {d6}
    5b1a:	ee36 5b07 	vadd.f64	d5, d6, d7
    5b1e:	ee36 6b45 	vsub.f64	d6, d6, d5
    5b22:	ee36 7b07 	vadd.f64	d7, d6, d7
    5b26:	ed20 7b02 	vstmdb	r0!, {d7}
    5b2a:	eeb0 7b45 	vmov.f64	d7, d5
    5b2e:	42a8      	cmp	r0, r5
    5b30:	ed84 5b00 	vstr	d5, [r4]
    5b34:	d1ef      	bne.n	5b16 <__kernel_rem_pio2+0x4ae>
    5b36:	2b01      	cmp	r3, #1
    5b38:	f340 80a4 	ble.w	5c84 <__kernel_rem_pio2+0x61c>
    5b3c:	00d2      	lsls	r2, r2, #3
    5b3e:	4477      	add	r7, lr
    5b40:	f102 0010 	add.w	r0, r2, #16
    5b44:	ed97 7b00 	vldr	d7, [r7]
    5b48:	3208      	adds	r2, #8
    5b4a:	4470      	add	r0, lr
    5b4c:	eb0e 0302 	add.w	r3, lr, r2
    5b50:	ac46      	add	r4, sp, #280	; 0x118
    5b52:	4602      	mov	r2, r0
    5b54:	ed33 6b02 	vldmdb	r3!, {d6}
    5b58:	ee37 5b06 	vadd.f64	d5, d7, d6
    5b5c:	ee36 6b45 	vsub.f64	d6, d6, d5
    5b60:	ee36 7b07 	vadd.f64	d7, d6, d7
    5b64:	ed22 7b02 	vstmdb	r2!, {d7}
    5b68:	eeb0 7b45 	vmov.f64	d7, d5
    5b6c:	4294      	cmp	r4, r2
    5b6e:	ed83 5b00 	vstr	d5, [r3]
    5b72:	d1ef      	bne.n	5b54 <__kernel_rem_pio2+0x4ec>
    5b74:	ed9f 7b58 	vldr	d7, [pc, #352]	; 5cd8 <__kernel_rem_pio2+0x670>
    5b78:	ed30 6b02 	vldmdb	r0!, {d6}
    5b7c:	4284      	cmp	r4, r0
    5b7e:	ee37 7b06 	vadd.f64	d7, d7, d6
    5b82:	d1f9      	bne.n	5b78 <__kernel_rem_pio2+0x510>
    5b84:	464b      	mov	r3, r9
    5b86:	2b00      	cmp	r3, #0
    5b88:	d066      	beq.n	5c58 <__kernel_rem_pio2+0x5f0>
    5b8a:	eeb1 7b47 	vneg.f64	d7, d7
    5b8e:	ed9e 5b00 	vldr	d5, [lr]
    5b92:	ed9e 6b02 	vldr	d6, [lr, #8]
    5b96:	eeb1 5b45 	vneg.f64	d5, d5
    5b9a:	ed8b 5b00 	vstr	d5, [fp]
    5b9e:	ed8b 7b04 	vstr	d7, [fp, #16]
    5ba2:	eeb1 7b46 	vneg.f64	d7, d6
    5ba6:	ed8b 7b02 	vstr	d7, [fp, #8]
    5baa:	ee1b 3a10 	vmov	r3, s22
    5bae:	f003 0007 	and.w	r0, r3, #7
    5bb2:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
    5bb6:	ecbd 8b08 	vpop	{d8-d11}
    5bba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5bbe:	ed9f 7b46 	vldr	d7, [pc, #280]	; 5cd8 <__kernel_rem_pio2+0x670>
    5bc2:	f107 0208 	add.w	r2, r7, #8
    5bc6:	4472      	add	r2, lr
    5bc8:	ed32 6b02 	vldmdb	r2!, {d6}
    5bcc:	4572      	cmp	r2, lr
    5bce:	ee37 7b06 	vadd.f64	d7, d7, d6
    5bd2:	d1f9      	bne.n	5bc8 <__kernel_rem_pio2+0x560>
    5bd4:	464a      	mov	r2, r9
    5bd6:	b3a2      	cbz	r2, 5c42 <__kernel_rem_pio2+0x5da>
    5bd8:	eeb1 5b47 	vneg.f64	d5, d7
    5bdc:	ed9e 6b00 	vldr	d6, [lr]
    5be0:	2b00      	cmp	r3, #0
    5be2:	ed8b 5b00 	vstr	d5, [fp]
    5be6:	ee36 7b47 	vsub.f64	d7, d6, d7
    5bea:	dd0b      	ble.n	5c04 <__kernel_rem_pio2+0x59c>
    5bec:	a844      	add	r0, sp, #272	; 0x110
    5bee:	2201      	movs	r2, #1
    5bf0:	ecb0 6b02 	vldmia	r0!, {d6}
    5bf4:	3201      	adds	r2, #1
    5bf6:	4293      	cmp	r3, r2
    5bf8:	ee37 7b06 	vadd.f64	d7, d7, d6
    5bfc:	daf8      	bge.n	5bf0 <__kernel_rem_pio2+0x588>
    5bfe:	464b      	mov	r3, r9
    5c00:	2b00      	cmp	r3, #0
    5c02:	d0d0      	beq.n	5ba6 <__kernel_rem_pio2+0x53e>
    5c04:	eeb1 7b47 	vneg.f64	d7, d7
    5c08:	ed8b 7b02 	vstr	d7, [fp, #8]
    5c0c:	e7cd      	b.n	5baa <__kernel_rem_pio2+0x542>
    5c0e:	ed9f 7b32 	vldr	d7, [pc, #200]	; 5cd8 <__kernel_rem_pio2+0x670>
    5c12:	3708      	adds	r7, #8
    5c14:	44be      	add	lr, r7
    5c16:	ed3e 6b02 	vldmdb	lr!, {d6}
    5c1a:	3b01      	subs	r3, #1
    5c1c:	1c5a      	adds	r2, r3, #1
    5c1e:	ee37 7b06 	vadd.f64	d7, d7, d6
    5c22:	d1f8      	bne.n	5c16 <__kernel_rem_pio2+0x5ae>
    5c24:	464b      	mov	r3, r9
    5c26:	b10b      	cbz	r3, 5c2c <__kernel_rem_pio2+0x5c4>
    5c28:	eeb1 7b47 	vneg.f64	d7, d7
    5c2c:	ed8b 7b00 	vstr	d7, [fp]
    5c30:	e7bb      	b.n	5baa <__kernel_rem_pio2+0x542>
    5c32:	ed9f 7b29 	vldr	d7, [pc, #164]	; 5cd8 <__kernel_rem_pio2+0x670>
    5c36:	e6fd      	b.n	5a34 <__kernel_rem_pio2+0x3cc>
    5c38:	f04f 0e01 	mov.w	lr, #1
    5c3c:	e639      	b.n	58b2 <__kernel_rem_pio2+0x24a>
    5c3e:	2000      	movs	r0, #0
    5c40:	e5f8      	b.n	5834 <__kernel_rem_pio2+0x1cc>
    5c42:	ed9e 6b00 	vldr	d6, [lr]
    5c46:	2b00      	cmp	r3, #0
    5c48:	ed8b 7b00 	vstr	d7, [fp]
    5c4c:	ee36 7b47 	vsub.f64	d7, d6, d7
    5c50:	dccc      	bgt.n	5bec <__kernel_rem_pio2+0x584>
    5c52:	ed8b 7b02 	vstr	d7, [fp, #8]
    5c56:	e7a8      	b.n	5baa <__kernel_rem_pio2+0x542>
    5c58:	e9de 0100 	ldrd	r0, r1, [lr]
    5c5c:	e9de 2302 	ldrd	r2, r3, [lr, #8]
    5c60:	ed8b 7b04 	vstr	d7, [fp, #16]
    5c64:	e9cb 0100 	strd	r0, r1, [fp]
    5c68:	e9cb 2302 	strd	r2, r3, [fp, #8]
    5c6c:	e79d      	b.n	5baa <__kernel_rem_pio2+0x542>
    5c6e:	eebd 0bc0 	vcvt.s32.f64	s0, d0
    5c72:	a906      	add	r1, sp, #24
    5c74:	ee10 2a10 	vmov	r2, s0
    5c78:	462b      	mov	r3, r5
    5c7a:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    5c7e:	e69c      	b.n	59ba <__kernel_rem_pio2+0x352>
    5c80:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    5c84:	ed9f 7b14 	vldr	d7, [pc, #80]	; 5cd8 <__kernel_rem_pio2+0x670>
    5c88:	e77c      	b.n	5b84 <__kernel_rem_pio2+0x51c>
    5c8a:	9aa4      	ldr	r2, [sp, #656]	; 0x290
    5c8c:	2a03      	cmp	r2, #3
    5c8e:	d88c      	bhi.n	5baa <__kernel_rem_pio2+0x542>
    5c90:	a101      	add	r1, pc, #4	; (adr r1, 5c98 <__kernel_rem_pio2+0x630>)
    5c92:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    5c96:	bf00      	nop
    5c98:	00005cb9 	.word	0x00005cb9
    5c9c:	00005caf 	.word	0x00005caf
    5ca0:	00005caf 	.word	0x00005caf
    5ca4:	00005c81 	.word	0x00005c81
    5ca8:	9b01      	ldr	r3, [sp, #4]
    5caa:	00dc      	lsls	r4, r3, #3
    5cac:	e53c      	b.n	5728 <__kernel_rem_pio2+0xc0>
    5cae:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 5cd8 <__kernel_rem_pio2+0x670>
    5cb2:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    5cb6:	e78d      	b.n	5bd4 <__kernel_rem_pio2+0x56c>
    5cb8:	ed9f 7b07 	vldr	d7, [pc, #28]	; 5cd8 <__kernel_rem_pio2+0x670>
    5cbc:	e7b2      	b.n	5c24 <__kernel_rem_pio2+0x5bc>
    5cbe:	bf00      	nop
    5cc0:	00000000 	.word	0x00000000
    5cc4:	41700000 	.word	0x41700000
    5cc8:	00000000 	.word	0x00000000
    5ccc:	3e700000 	.word	0x3e700000
    5cd0:	40000000 	.word	0x40000000
    5cd4:	3ff921fb 	.word	0x3ff921fb
	...
    5ce0:	20000288 	.word	0x20000288
    5ce4:	00000000 	.word	0x00000000

00005ce8 <__kernel_sin>:
    5ce8:	ee10 3a90 	vmov	r3, s1
    5cec:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5cf0:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
    5cf4:	da04      	bge.n	5d00 <__kernel_sin+0x18>
    5cf6:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    5cfa:	ee17 3a90 	vmov	r3, s15
    5cfe:	b323      	cbz	r3, 5d4a <__kernel_sin+0x62>
    5d00:	ee20 7b00 	vmul.f64	d7, d0, d0
    5d04:	ee20 4b07 	vmul.f64	d4, d0, d7
    5d08:	ed9f 5b15 	vldr	d5, [pc, #84]	; 5d60 <__kernel_sin+0x78>
    5d0c:	ed9f 6b16 	vldr	d6, [pc, #88]	; 5d68 <__kernel_sin+0x80>
    5d10:	ed9f 3b17 	vldr	d3, [pc, #92]	; 5d70 <__kernel_sin+0x88>
    5d14:	eea7 6b05 	vfma.f64	d6, d7, d5
    5d18:	ed9f 5b17 	vldr	d5, [pc, #92]	; 5d78 <__kernel_sin+0x90>
    5d1c:	eea7 3b06 	vfma.f64	d3, d7, d6
    5d20:	ed9f 6b17 	vldr	d6, [pc, #92]	; 5d80 <__kernel_sin+0x98>
    5d24:	eea7 5b03 	vfma.f64	d5, d7, d3
    5d28:	eea7 6b05 	vfma.f64	d6, d7, d5
    5d2c:	b170      	cbz	r0, 5d4c <__kernel_sin+0x64>
    5d2e:	ee26 6b44 	vnmul.f64	d6, d6, d4
    5d32:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    5d36:	ed9f 5b14 	vldr	d5, [pc, #80]	; 5d88 <__kernel_sin+0xa0>
    5d3a:	eea1 6b03 	vfma.f64	d6, d1, d3
    5d3e:	ee97 1b06 	vfnms.f64	d1, d7, d6
    5d42:	eea4 1b05 	vfma.f64	d1, d4, d5
    5d46:	ee30 0b41 	vsub.f64	d0, d0, d1
    5d4a:	4770      	bx	lr
    5d4c:	ed9f 5b10 	vldr	d5, [pc, #64]	; 5d90 <__kernel_sin+0xa8>
    5d50:	eea7 5b06 	vfma.f64	d5, d7, d6
    5d54:	eea4 0b05 	vfma.f64	d0, d4, d5
    5d58:	4770      	bx	lr
    5d5a:	bf00      	nop
    5d5c:	f3af 8000 	nop.w
    5d60:	5acfd57c 	.word	0x5acfd57c
    5d64:	3de5d93a 	.word	0x3de5d93a
    5d68:	8a2b9ceb 	.word	0x8a2b9ceb
    5d6c:	be5ae5e6 	.word	0xbe5ae5e6
    5d70:	57b1fe7d 	.word	0x57b1fe7d
    5d74:	3ec71de3 	.word	0x3ec71de3
    5d78:	19c161d5 	.word	0x19c161d5
    5d7c:	bf2a01a0 	.word	0xbf2a01a0
    5d80:	1110f8a6 	.word	0x1110f8a6
    5d84:	3f811111 	.word	0x3f811111
    5d88:	55555549 	.word	0x55555549
    5d8c:	3fc55555 	.word	0x3fc55555
    5d90:	55555549 	.word	0x55555549
    5d94:	bfc55555 	.word	0xbfc55555

00005d98 <atan>:
    5d98:	b538      	push	{r3, r4, r5, lr}
    5d9a:	eeb0 7b40 	vmov.f64	d7, d0
    5d9e:	ee17 5a90 	vmov	r5, s15
    5da2:	4b77      	ldr	r3, [pc, #476]	; (5f80 <atan+0x1e8>)
    5da4:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
    5da8:	429c      	cmp	r4, r3
    5daa:	dd0e      	ble.n	5dca <atan+0x32>
    5dac:	4b75      	ldr	r3, [pc, #468]	; (5f84 <atan+0x1ec>)
    5dae:	429c      	cmp	r4, r3
    5db0:	ee10 2a10 	vmov	r2, s0
    5db4:	dc5c      	bgt.n	5e70 <atan+0xd8>
    5db6:	d059      	beq.n	5e6c <atan+0xd4>
    5db8:	ed9f 7b55 	vldr	d7, [pc, #340]	; 5f10 <atan+0x178>
    5dbc:	ed9f 0b56 	vldr	d0, [pc, #344]	; 5f18 <atan+0x180>
    5dc0:	2d00      	cmp	r5, #0
    5dc2:	bfc8      	it	gt
    5dc4:	eeb0 0b47 	vmovgt.f64	d0, d7
    5dc8:	bd38      	pop	{r3, r4, r5, pc}
    5dca:	4b6f      	ldr	r3, [pc, #444]	; (5f88 <atan+0x1f0>)
    5dcc:	429c      	cmp	r4, r3
    5dce:	dc60      	bgt.n	5e92 <atan+0xfa>
    5dd0:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
    5dd4:	429c      	cmp	r4, r3
    5dd6:	dd4e      	ble.n	5e76 <atan+0xde>
    5dd8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5ddc:	ed9f 2b50 	vldr	d2, [pc, #320]	; 5f20 <atan+0x188>
    5de0:	ee27 4b07 	vmul.f64	d4, d7, d7
    5de4:	ee24 6b04 	vmul.f64	d6, d4, d4
    5de8:	ed9f 3b4f 	vldr	d3, [pc, #316]	; 5f28 <atan+0x190>
    5dec:	ed9f 5b50 	vldr	d5, [pc, #320]	; 5f30 <atan+0x198>
    5df0:	eea6 3b02 	vfma.f64	d3, d6, d2
    5df4:	ed9f 2b50 	vldr	d2, [pc, #320]	; 5f38 <atan+0x1a0>
    5df8:	eea6 5b03 	vfma.f64	d5, d6, d3
    5dfc:	ed9f 3b50 	vldr	d3, [pc, #320]	; 5f40 <atan+0x1a8>
    5e00:	eea6 2b05 	vfma.f64	d2, d6, d5
    5e04:	ed9f 5b50 	vldr	d5, [pc, #320]	; 5f48 <atan+0x1b0>
    5e08:	eea6 3b02 	vfma.f64	d3, d6, d2
    5e0c:	ed9f 1b50 	vldr	d1, [pc, #320]	; 5f50 <atan+0x1b8>
    5e10:	eea6 5b03 	vfma.f64	d5, d6, d3
    5e14:	ee25 5b04 	vmul.f64	d5, d5, d4
    5e18:	ed9f 2b4f 	vldr	d2, [pc, #316]	; 5f58 <atan+0x1c0>
    5e1c:	ed9f 4b50 	vldr	d4, [pc, #320]	; 5f60 <atan+0x1c8>
    5e20:	ed9f 3b51 	vldr	d3, [pc, #324]	; 5f68 <atan+0x1d0>
    5e24:	eea6 4b01 	vfma.f64	d4, d6, d1
    5e28:	eea6 2b04 	vfma.f64	d2, d6, d4
    5e2c:	ed9f 4b50 	vldr	d4, [pc, #320]	; 5f70 <atan+0x1d8>
    5e30:	eea6 3b02 	vfma.f64	d3, d6, d2
    5e34:	1c5a      	adds	r2, r3, #1
    5e36:	eea6 4b03 	vfma.f64	d4, d6, d3
    5e3a:	ee24 6b06 	vmul.f64	d6, d4, d6
    5e3e:	d040      	beq.n	5ec2 <atan+0x12a>
    5e40:	ee35 5b06 	vadd.f64	d5, d5, d6
    5e44:	4a51      	ldr	r2, [pc, #324]	; (5f8c <atan+0x1f4>)
    5e46:	4952      	ldr	r1, [pc, #328]	; (5f90 <atan+0x1f8>)
    5e48:	00db      	lsls	r3, r3, #3
    5e4a:	441a      	add	r2, r3
    5e4c:	440b      	add	r3, r1
    5e4e:	ed92 6b00 	vldr	d6, [r2]
    5e52:	ed93 0b00 	vldr	d0, [r3]
    5e56:	ee97 6b05 	vfnms.f64	d6, d7, d5
    5e5a:	ee36 7b47 	vsub.f64	d7, d6, d7
    5e5e:	2d00      	cmp	r5, #0
    5e60:	ee30 7b47 	vsub.f64	d7, d0, d7
    5e64:	db2a      	blt.n	5ebc <atan+0x124>
    5e66:	eeb0 0b47 	vmov.f64	d0, d7
    5e6a:	bd38      	pop	{r3, r4, r5, pc}
    5e6c:	2a00      	cmp	r2, #0
    5e6e:	d0a3      	beq.n	5db8 <atan+0x20>
    5e70:	ee37 0b07 	vadd.f64	d0, d7, d7
    5e74:	bd38      	pop	{r3, r4, r5, pc}
    5e76:	ed9f 6b40 	vldr	d6, [pc, #256]	; 5f78 <atan+0x1e0>
    5e7a:	eeb7 5b00 	vmov.f64	d5, #112	; 0x3f800000  1.0
    5e7e:	ee30 6b06 	vadd.f64	d6, d0, d6
    5e82:	eeb4 6bc5 	vcmpe.f64	d6, d5
    5e86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5e8a:	dda5      	ble.n	5dd8 <atan+0x40>
    5e8c:	eeb0 0b47 	vmov.f64	d0, d7
    5e90:	bd38      	pop	{r3, r4, r5, pc}
    5e92:	f000 f883 	bl	5f9c <fabs>
    5e96:	4b3f      	ldr	r3, [pc, #252]	; (5f94 <atan+0x1fc>)
    5e98:	429c      	cmp	r4, r3
    5e9a:	dc19      	bgt.n	5ed0 <atan+0x138>
    5e9c:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
    5ea0:	429c      	cmp	r4, r3
    5ea2:	dc2a      	bgt.n	5efa <atan+0x162>
    5ea4:	eeb0 7b00 	vmov.f64	d7, #0	; 0x40000000  2.0
    5ea8:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
    5eac:	ee30 5b07 	vadd.f64	d5, d0, d7
    5eb0:	eea0 6b07 	vfma.f64	d6, d0, d7
    5eb4:	2300      	movs	r3, #0
    5eb6:	ee86 7b05 	vdiv.f64	d7, d6, d5
    5eba:	e78f      	b.n	5ddc <atan+0x44>
    5ebc:	eeb1 0b47 	vneg.f64	d0, d7
    5ec0:	bd38      	pop	{r3, r4, r5, pc}
    5ec2:	ee35 6b06 	vadd.f64	d6, d5, d6
    5ec6:	eea7 7b46 	vfms.f64	d7, d7, d6
    5eca:	eeb0 0b47 	vmov.f64	d0, d7
    5ece:	bd38      	pop	{r3, r4, r5, pc}
    5ed0:	4b31      	ldr	r3, [pc, #196]	; (5f98 <atan+0x200>)
    5ed2:	429c      	cmp	r4, r3
    5ed4:	dc0b      	bgt.n	5eee <atan+0x156>
    5ed6:	eeb7 7b08 	vmov.f64	d7, #120	; 0x3fc00000  1.5
    5eda:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    5ede:	ee30 5b47 	vsub.f64	d5, d0, d7
    5ee2:	eea0 6b07 	vfma.f64	d6, d0, d7
    5ee6:	2302      	movs	r3, #2
    5ee8:	ee85 7b06 	vdiv.f64	d7, d5, d6
    5eec:	e776      	b.n	5ddc <atan+0x44>
    5eee:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
    5ef2:	2303      	movs	r3, #3
    5ef4:	ee86 7b00 	vdiv.f64	d7, d6, d0
    5ef8:	e770      	b.n	5ddc <atan+0x44>
    5efa:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    5efe:	2301      	movs	r3, #1
    5f00:	ee30 6b47 	vsub.f64	d6, d0, d7
    5f04:	ee30 0b07 	vadd.f64	d0, d0, d7
    5f08:	ee86 7b00 	vdiv.f64	d7, d6, d0
    5f0c:	e766      	b.n	5ddc <atan+0x44>
    5f0e:	bf00      	nop
    5f10:	54442d18 	.word	0x54442d18
    5f14:	3ff921fb 	.word	0x3ff921fb
    5f18:	54442d18 	.word	0x54442d18
    5f1c:	bff921fb 	.word	0xbff921fb
    5f20:	e322da11 	.word	0xe322da11
    5f24:	3f90ad3a 	.word	0x3f90ad3a
    5f28:	24760deb 	.word	0x24760deb
    5f2c:	3fa97b4b 	.word	0x3fa97b4b
    5f30:	a0d03d51 	.word	0xa0d03d51
    5f34:	3fb10d66 	.word	0x3fb10d66
    5f38:	c54c206e 	.word	0xc54c206e
    5f3c:	3fb745cd 	.word	0x3fb745cd
    5f40:	920083ff 	.word	0x920083ff
    5f44:	3fc24924 	.word	0x3fc24924
    5f48:	5555550d 	.word	0x5555550d
    5f4c:	3fd55555 	.word	0x3fd55555
    5f50:	2c6a6c2f 	.word	0x2c6a6c2f
    5f54:	bfa2b444 	.word	0xbfa2b444
    5f58:	af749a6d 	.word	0xaf749a6d
    5f5c:	bfb3b0f2 	.word	0xbfb3b0f2
    5f60:	52defd9a 	.word	0x52defd9a
    5f64:	bfadde2d 	.word	0xbfadde2d
    5f68:	fe231671 	.word	0xfe231671
    5f6c:	bfbc71c6 	.word	0xbfbc71c6
    5f70:	9998ebc4 	.word	0x9998ebc4
    5f74:	bfc99999 	.word	0xbfc99999
    5f78:	8800759c 	.word	0x8800759c
    5f7c:	7e37e43c 	.word	0x7e37e43c
    5f80:	440fffff 	.word	0x440fffff
    5f84:	7ff00000 	.word	0x7ff00000
    5f88:	3fdbffff 	.word	0x3fdbffff
    5f8c:	200003d0 	.word	0x200003d0
    5f90:	200003b0 	.word	0x200003b0
    5f94:	3ff2ffff 	.word	0x3ff2ffff
    5f98:	40037fff 	.word	0x40037fff

00005f9c <fabs>:
    5f9c:	ec53 2b10 	vmov	r2, r3, d0
    5fa0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5fa4:	ec43 2b10 	vmov	d0, r2, r3
    5fa8:	4770      	bx	lr
    5faa:	bf00      	nop
    5fac:	0000      	movs	r0, r0
	...

00005fb0 <floor>:
    5fb0:	b470      	push	{r4, r5, r6}
    5fb2:	b083      	sub	sp, #12
    5fb4:	ed8d 0b00 	vstr	d0, [sp]
    5fb8:	9901      	ldr	r1, [sp, #4]
    5fba:	9c00      	ldr	r4, [sp, #0]
    5fbc:	f3c1 520a 	ubfx	r2, r1, #20, #11
    5fc0:	f2a2 33ff 	subw	r3, r2, #1023	; 0x3ff
    5fc4:	2b13      	cmp	r3, #19
    5fc6:	460d      	mov	r5, r1
    5fc8:	4620      	mov	r0, r4
    5fca:	dc1e      	bgt.n	600a <floor+0x5a>
    5fcc:	2b00      	cmp	r3, #0
    5fce:	db43      	blt.n	6058 <floor+0xa8>
    5fd0:	4a3b      	ldr	r2, [pc, #236]	; (60c0 <floor+0x110>)
    5fd2:	411a      	asrs	r2, r3
    5fd4:	ea01 0602 	and.w	r6, r1, r2
    5fd8:	4334      	orrs	r4, r6
    5fda:	d01b      	beq.n	6014 <floor+0x64>
    5fdc:	ed9f 7b36 	vldr	d7, [pc, #216]	; 60b8 <floor+0x108>
    5fe0:	ed9d 6b00 	vldr	d6, [sp]
    5fe4:	ee36 7b07 	vadd.f64	d7, d6, d7
    5fe8:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    5fec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5ff0:	dd04      	ble.n	5ffc <floor+0x4c>
    5ff2:	2900      	cmp	r1, #0
    5ff4:	db43      	blt.n	607e <floor+0xce>
    5ff6:	ea25 0102 	bic.w	r1, r5, r2
    5ffa:	2000      	movs	r0, #0
    5ffc:	460b      	mov	r3, r1
    5ffe:	4602      	mov	r2, r0
    6000:	ec43 2b10 	vmov	d0, r2, r3
    6004:	b003      	add	sp, #12
    6006:	bc70      	pop	{r4, r5, r6}
    6008:	4770      	bx	lr
    600a:	2b33      	cmp	r3, #51	; 0x33
    600c:	dd07      	ble.n	601e <floor+0x6e>
    600e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    6012:	d02f      	beq.n	6074 <floor+0xc4>
    6014:	ed9d 0b00 	vldr	d0, [sp]
    6018:	b003      	add	sp, #12
    601a:	bc70      	pop	{r4, r5, r6}
    601c:	4770      	bx	lr
    601e:	f2a2 4213 	subw	r2, r2, #1043	; 0x413
    6022:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    6026:	fa24 f202 	lsr.w	r2, r4, r2
    602a:	4210      	tst	r0, r2
    602c:	d0f2      	beq.n	6014 <floor+0x64>
    602e:	ed9f 7b22 	vldr	d7, [pc, #136]	; 60b8 <floor+0x108>
    6032:	ed9d 6b00 	vldr	d6, [sp]
    6036:	ee36 7b07 	vadd.f64	d7, d6, d7
    603a:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    603e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    6042:	dddb      	ble.n	5ffc <floor+0x4c>
    6044:	2900      	cmp	r1, #0
    6046:	db20      	blt.n	608a <floor+0xda>
    6048:	4629      	mov	r1, r5
    604a:	ea20 0002 	bic.w	r0, r0, r2
    604e:	460b      	mov	r3, r1
    6050:	4602      	mov	r2, r0
    6052:	ec43 2b10 	vmov	d0, r2, r3
    6056:	e7d5      	b.n	6004 <floor+0x54>
    6058:	ed9f 7b17 	vldr	d7, [pc, #92]	; 60b8 <floor+0x108>
    605c:	ee30 7b07 	vadd.f64	d7, d0, d7
    6060:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    6064:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    6068:	ddc8      	ble.n	5ffc <floor+0x4c>
    606a:	2900      	cmp	r1, #0
    606c:	db18      	blt.n	60a0 <floor+0xf0>
    606e:	2000      	movs	r0, #0
    6070:	4601      	mov	r1, r0
    6072:	e7c3      	b.n	5ffc <floor+0x4c>
    6074:	ed9d 7b00 	vldr	d7, [sp]
    6078:	ee37 0b07 	vadd.f64	d0, d7, d7
    607c:	e7cc      	b.n	6018 <floor+0x68>
    607e:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    6082:	fa41 f303 	asr.w	r3, r1, r3
    6086:	441d      	add	r5, r3
    6088:	e7b5      	b.n	5ff6 <floor+0x46>
    608a:	2b14      	cmp	r3, #20
    608c:	d010      	beq.n	60b0 <floor+0x100>
    608e:	2101      	movs	r1, #1
    6090:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
    6094:	fa01 f303 	lsl.w	r3, r1, r3
    6098:	1818      	adds	r0, r3, r0
    609a:	bf28      	it	cs
    609c:	186d      	addcs	r5, r5, r1
    609e:	e7d3      	b.n	6048 <floor+0x98>
    60a0:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
    60a4:	4b07      	ldr	r3, [pc, #28]	; (60c4 <floor+0x114>)
    60a6:	4322      	orrs	r2, r4
    60a8:	bf18      	it	ne
    60aa:	4619      	movne	r1, r3
    60ac:	2000      	movs	r0, #0
    60ae:	e7a5      	b.n	5ffc <floor+0x4c>
    60b0:	3501      	adds	r5, #1
    60b2:	e7c9      	b.n	6048 <floor+0x98>
    60b4:	f3af 8000 	nop.w
    60b8:	8800759c 	.word	0x8800759c
    60bc:	7e37e43c 	.word	0x7e37e43c
    60c0:	000fffff 	.word	0x000fffff
    60c4:	bff00000 	.word	0xbff00000

000060c8 <matherr>:
    60c8:	2000      	movs	r0, #0
    60ca:	4770      	bx	lr
    60cc:	0000      	movs	r0, r0
	...

000060d0 <scalbn>:
    60d0:	b510      	push	{r4, lr}
    60d2:	ed2d 8b02 	vpush	{d8}
    60d6:	b082      	sub	sp, #8
    60d8:	ed8d 0b00 	vstr	d0, [sp]
    60dc:	9b01      	ldr	r3, [sp, #4]
    60de:	9900      	ldr	r1, [sp, #0]
    60e0:	f3c3 520a 	ubfx	r2, r3, #20, #11
    60e4:	bb2a      	cbnz	r2, 6132 <scalbn+0x62>
    60e6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    60ea:	430b      	orrs	r3, r1
    60ec:	d02d      	beq.n	614a <scalbn+0x7a>
    60ee:	ed9f 7b36 	vldr	d7, [pc, #216]	; 61c8 <scalbn+0xf8>
    60f2:	4a3d      	ldr	r2, [pc, #244]	; (61e8 <scalbn+0x118>)
    60f4:	ee20 7b07 	vmul.f64	d7, d0, d7
    60f8:	4290      	cmp	r0, r2
    60fa:	ed8d 7b00 	vstr	d7, [sp]
    60fe:	9b01      	ldr	r3, [sp, #4]
    6100:	db29      	blt.n	6156 <scalbn+0x86>
    6102:	f3c3 520a 	ubfx	r2, r3, #20, #11
    6106:	3a36      	subs	r2, #54	; 0x36
    6108:	1884      	adds	r4, r0, r2
    610a:	f240 72fe 	movw	r2, #2046	; 0x7fe
    610e:	4294      	cmp	r4, r2
    6110:	dc30      	bgt.n	6174 <scalbn+0xa4>
    6112:	2c00      	cmp	r4, #0
    6114:	dd27      	ble.n	6166 <scalbn+0x96>
    6116:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
    611a:	e9dd 2300 	ldrd	r2, r3, [sp]
    611e:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    6122:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    6126:	ec43 2b10 	vmov	d0, r2, r3
    612a:	b002      	add	sp, #8
    612c:	ecbd 8b02 	vpop	{d8}
    6130:	bd10      	pop	{r4, pc}
    6132:	f240 71ff 	movw	r1, #2047	; 0x7ff
    6136:	428a      	cmp	r2, r1
    6138:	d1e6      	bne.n	6108 <scalbn+0x38>
    613a:	ed9d 7b00 	vldr	d7, [sp]
    613e:	ee37 0b07 	vadd.f64	d0, d7, d7
    6142:	b002      	add	sp, #8
    6144:	ecbd 8b02 	vpop	{d8}
    6148:	bd10      	pop	{r4, pc}
    614a:	ed9d 0b00 	vldr	d0, [sp]
    614e:	b002      	add	sp, #8
    6150:	ecbd 8b02 	vpop	{d8}
    6154:	bd10      	pop	{r4, pc}
    6156:	ed9f 0b1e 	vldr	d0, [pc, #120]	; 61d0 <scalbn+0x100>
    615a:	ee27 0b00 	vmul.f64	d0, d7, d0
    615e:	b002      	add	sp, #8
    6160:	ecbd 8b02 	vpop	{d8}
    6164:	bd10      	pop	{r4, pc}
    6166:	f114 0f35 	cmn.w	r4, #53	; 0x35
    616a:	da11      	bge.n	6190 <scalbn+0xc0>
    616c:	f24c 3350 	movw	r3, #50000	; 0xc350
    6170:	4298      	cmp	r0, r3
    6172:	dd1d      	ble.n	61b0 <scalbn+0xe0>
    6174:	ed9f 8b18 	vldr	d8, [pc, #96]	; 61d8 <scalbn+0x108>
    6178:	ed9d 1b00 	vldr	d1, [sp]
    617c:	eeb0 0b48 	vmov.f64	d0, d8
    6180:	f000 f834 	bl	61ec <copysign>
    6184:	ee20 0b08 	vmul.f64	d0, d0, d8
    6188:	b002      	add	sp, #8
    618a:	ecbd 8b02 	vpop	{d8}
    618e:	bd10      	pop	{r4, pc}
    6190:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
    6194:	e9dd 2300 	ldrd	r2, r3, [sp]
    6198:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    619c:	3436      	adds	r4, #54	; 0x36
    619e:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    61a2:	ed9f 0b0f 	vldr	d0, [pc, #60]	; 61e0 <scalbn+0x110>
    61a6:	ec43 2b17 	vmov	d7, r2, r3
    61aa:	ee27 0b00 	vmul.f64	d0, d7, d0
    61ae:	e7bc      	b.n	612a <scalbn+0x5a>
    61b0:	ed9f 8b07 	vldr	d8, [pc, #28]	; 61d0 <scalbn+0x100>
    61b4:	ed9d 1b00 	vldr	d1, [sp]
    61b8:	eeb0 0b48 	vmov.f64	d0, d8
    61bc:	f000 f816 	bl	61ec <copysign>
    61c0:	ee20 0b08 	vmul.f64	d0, d0, d8
    61c4:	e7b1      	b.n	612a <scalbn+0x5a>
    61c6:	bf00      	nop
    61c8:	00000000 	.word	0x00000000
    61cc:	43500000 	.word	0x43500000
    61d0:	c2f8f359 	.word	0xc2f8f359
    61d4:	01a56e1f 	.word	0x01a56e1f
    61d8:	8800759c 	.word	0x8800759c
    61dc:	7e37e43c 	.word	0x7e37e43c
    61e0:	00000000 	.word	0x00000000
    61e4:	3c900000 	.word	0x3c900000
    61e8:	ffff3cb0 	.word	0xffff3cb0

000061ec <copysign>:
    61ec:	ec53 2b10 	vmov	r2, r3, d0
    61f0:	ee11 0a90 	vmov	r0, s3
    61f4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    61f8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    61fc:	ea41 0300 	orr.w	r3, r1, r0
    6200:	ec43 2b10 	vmov	d0, r2, r3
    6204:	4770      	bx	lr
    6206:	bf00      	nop

00006208 <__aeabi_atexit>:
    6208:	460b      	mov	r3, r1
    620a:	4601      	mov	r1, r0
    620c:	4618      	mov	r0, r3
    620e:	f000 b98d 	b.w	652c <__cxa_atexit>
    6212:	bf00      	nop

00006214 <__aeabi_uldivmod>:
    6214:	b953      	cbnz	r3, 622c <__aeabi_uldivmod+0x18>
    6216:	b94a      	cbnz	r2, 622c <__aeabi_uldivmod+0x18>
    6218:	2900      	cmp	r1, #0
    621a:	bf08      	it	eq
    621c:	2800      	cmpeq	r0, #0
    621e:	bf1c      	itt	ne
    6220:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    6224:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    6228:	f000 b97e 	b.w	6528 <__aeabi_idiv0>
    622c:	f1ad 0c08 	sub.w	ip, sp, #8
    6230:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    6234:	f000 f806 	bl	6244 <__udivmoddi4>
    6238:	f8dd e004 	ldr.w	lr, [sp, #4]
    623c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    6240:	b004      	add	sp, #16
    6242:	4770      	bx	lr

00006244 <__udivmoddi4>:
    6244:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6248:	468c      	mov	ip, r1
    624a:	460e      	mov	r6, r1
    624c:	4604      	mov	r4, r0
    624e:	9d08      	ldr	r5, [sp, #32]
    6250:	2b00      	cmp	r3, #0
    6252:	d150      	bne.n	62f6 <__udivmoddi4+0xb2>
    6254:	428a      	cmp	r2, r1
    6256:	4617      	mov	r7, r2
    6258:	d96c      	bls.n	6334 <__udivmoddi4+0xf0>
    625a:	fab2 fe82 	clz	lr, r2
    625e:	f1be 0f00 	cmp.w	lr, #0
    6262:	d00b      	beq.n	627c <__udivmoddi4+0x38>
    6264:	f1ce 0420 	rsb	r4, lr, #32
    6268:	fa20 f404 	lsr.w	r4, r0, r4
    626c:	fa01 f60e 	lsl.w	r6, r1, lr
    6270:	ea44 0c06 	orr.w	ip, r4, r6
    6274:	fa02 f70e 	lsl.w	r7, r2, lr
    6278:	fa00 f40e 	lsl.w	r4, r0, lr
    627c:	ea4f 4917 	mov.w	r9, r7, lsr #16
    6280:	0c22      	lsrs	r2, r4, #16
    6282:	fbbc f0f9 	udiv	r0, ip, r9
    6286:	fa1f f887 	uxth.w	r8, r7
    628a:	fb09 c610 	mls	r6, r9, r0, ip
    628e:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    6292:	fb00 f308 	mul.w	r3, r0, r8
    6296:	42b3      	cmp	r3, r6
    6298:	d909      	bls.n	62ae <__udivmoddi4+0x6a>
    629a:	19f6      	adds	r6, r6, r7
    629c:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    62a0:	f080 8122 	bcs.w	64e8 <__udivmoddi4+0x2a4>
    62a4:	42b3      	cmp	r3, r6
    62a6:	f240 811f 	bls.w	64e8 <__udivmoddi4+0x2a4>
    62aa:	3802      	subs	r0, #2
    62ac:	443e      	add	r6, r7
    62ae:	1af6      	subs	r6, r6, r3
    62b0:	b2a2      	uxth	r2, r4
    62b2:	fbb6 f3f9 	udiv	r3, r6, r9
    62b6:	fb09 6613 	mls	r6, r9, r3, r6
    62ba:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    62be:	fb03 f808 	mul.w	r8, r3, r8
    62c2:	45a0      	cmp	r8, r4
    62c4:	d909      	bls.n	62da <__udivmoddi4+0x96>
    62c6:	19e4      	adds	r4, r4, r7
    62c8:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    62cc:	f080 810a 	bcs.w	64e4 <__udivmoddi4+0x2a0>
    62d0:	45a0      	cmp	r8, r4
    62d2:	f240 8107 	bls.w	64e4 <__udivmoddi4+0x2a0>
    62d6:	3b02      	subs	r3, #2
    62d8:	443c      	add	r4, r7
    62da:	ebc8 0404 	rsb	r4, r8, r4
    62de:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    62e2:	2100      	movs	r1, #0
    62e4:	2d00      	cmp	r5, #0
    62e6:	d062      	beq.n	63ae <__udivmoddi4+0x16a>
    62e8:	fa24 f40e 	lsr.w	r4, r4, lr
    62ec:	2300      	movs	r3, #0
    62ee:	602c      	str	r4, [r5, #0]
    62f0:	606b      	str	r3, [r5, #4]
    62f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    62f6:	428b      	cmp	r3, r1
    62f8:	d907      	bls.n	630a <__udivmoddi4+0xc6>
    62fa:	2d00      	cmp	r5, #0
    62fc:	d055      	beq.n	63aa <__udivmoddi4+0x166>
    62fe:	2100      	movs	r1, #0
    6300:	e885 0041 	stmia.w	r5, {r0, r6}
    6304:	4608      	mov	r0, r1
    6306:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    630a:	fab3 f183 	clz	r1, r3
    630e:	2900      	cmp	r1, #0
    6310:	f040 8090 	bne.w	6434 <__udivmoddi4+0x1f0>
    6314:	42b3      	cmp	r3, r6
    6316:	d302      	bcc.n	631e <__udivmoddi4+0xda>
    6318:	4282      	cmp	r2, r0
    631a:	f200 80f8 	bhi.w	650e <__udivmoddi4+0x2ca>
    631e:	1a84      	subs	r4, r0, r2
    6320:	eb66 0603 	sbc.w	r6, r6, r3
    6324:	2001      	movs	r0, #1
    6326:	46b4      	mov	ip, r6
    6328:	2d00      	cmp	r5, #0
    632a:	d040      	beq.n	63ae <__udivmoddi4+0x16a>
    632c:	e885 1010 	stmia.w	r5, {r4, ip}
    6330:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6334:	b912      	cbnz	r2, 633c <__udivmoddi4+0xf8>
    6336:	2701      	movs	r7, #1
    6338:	fbb7 f7f2 	udiv	r7, r7, r2
    633c:	fab7 fe87 	clz	lr, r7
    6340:	f1be 0f00 	cmp.w	lr, #0
    6344:	d135      	bne.n	63b2 <__udivmoddi4+0x16e>
    6346:	1bf3      	subs	r3, r6, r7
    6348:	ea4f 4817 	mov.w	r8, r7, lsr #16
    634c:	fa1f fc87 	uxth.w	ip, r7
    6350:	2101      	movs	r1, #1
    6352:	fbb3 f0f8 	udiv	r0, r3, r8
    6356:	0c22      	lsrs	r2, r4, #16
    6358:	fb08 3610 	mls	r6, r8, r0, r3
    635c:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    6360:	fb0c f300 	mul.w	r3, ip, r0
    6364:	42b3      	cmp	r3, r6
    6366:	d907      	bls.n	6378 <__udivmoddi4+0x134>
    6368:	19f6      	adds	r6, r6, r7
    636a:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    636e:	d202      	bcs.n	6376 <__udivmoddi4+0x132>
    6370:	42b3      	cmp	r3, r6
    6372:	f200 80ce 	bhi.w	6512 <__udivmoddi4+0x2ce>
    6376:	4610      	mov	r0, r2
    6378:	1af6      	subs	r6, r6, r3
    637a:	b2a2      	uxth	r2, r4
    637c:	fbb6 f3f8 	udiv	r3, r6, r8
    6380:	fb08 6613 	mls	r6, r8, r3, r6
    6384:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    6388:	fb0c fc03 	mul.w	ip, ip, r3
    638c:	45a4      	cmp	ip, r4
    638e:	d907      	bls.n	63a0 <__udivmoddi4+0x15c>
    6390:	19e4      	adds	r4, r4, r7
    6392:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    6396:	d202      	bcs.n	639e <__udivmoddi4+0x15a>
    6398:	45a4      	cmp	ip, r4
    639a:	f200 80b5 	bhi.w	6508 <__udivmoddi4+0x2c4>
    639e:	4613      	mov	r3, r2
    63a0:	ebcc 0404 	rsb	r4, ip, r4
    63a4:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    63a8:	e79c      	b.n	62e4 <__udivmoddi4+0xa0>
    63aa:	4629      	mov	r1, r5
    63ac:	4628      	mov	r0, r5
    63ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    63b2:	f1ce 0120 	rsb	r1, lr, #32
    63b6:	fa06 f30e 	lsl.w	r3, r6, lr
    63ba:	fa07 f70e 	lsl.w	r7, r7, lr
    63be:	fa20 f901 	lsr.w	r9, r0, r1
    63c2:	ea4f 4817 	mov.w	r8, r7, lsr #16
    63c6:	40ce      	lsrs	r6, r1
    63c8:	ea49 0903 	orr.w	r9, r9, r3
    63cc:	fbb6 faf8 	udiv	sl, r6, r8
    63d0:	ea4f 4419 	mov.w	r4, r9, lsr #16
    63d4:	fb08 661a 	mls	r6, r8, sl, r6
    63d8:	fa1f fc87 	uxth.w	ip, r7
    63dc:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
    63e0:	fb0a f20c 	mul.w	r2, sl, ip
    63e4:	429a      	cmp	r2, r3
    63e6:	fa00 f40e 	lsl.w	r4, r0, lr
    63ea:	d90a      	bls.n	6402 <__udivmoddi4+0x1be>
    63ec:	19db      	adds	r3, r3, r7
    63ee:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    63f2:	f080 8087 	bcs.w	6504 <__udivmoddi4+0x2c0>
    63f6:	429a      	cmp	r2, r3
    63f8:	f240 8084 	bls.w	6504 <__udivmoddi4+0x2c0>
    63fc:	f1aa 0a02 	sub.w	sl, sl, #2
    6400:	443b      	add	r3, r7
    6402:	1a9b      	subs	r3, r3, r2
    6404:	fa1f f989 	uxth.w	r9, r9
    6408:	fbb3 f1f8 	udiv	r1, r3, r8
    640c:	fb08 3311 	mls	r3, r8, r1, r3
    6410:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
    6414:	fb01 f60c 	mul.w	r6, r1, ip
    6418:	429e      	cmp	r6, r3
    641a:	d907      	bls.n	642c <__udivmoddi4+0x1e8>
    641c:	19db      	adds	r3, r3, r7
    641e:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    6422:	d26b      	bcs.n	64fc <__udivmoddi4+0x2b8>
    6424:	429e      	cmp	r6, r3
    6426:	d969      	bls.n	64fc <__udivmoddi4+0x2b8>
    6428:	3902      	subs	r1, #2
    642a:	443b      	add	r3, r7
    642c:	1b9b      	subs	r3, r3, r6
    642e:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
    6432:	e78e      	b.n	6352 <__udivmoddi4+0x10e>
    6434:	f1c1 0e20 	rsb	lr, r1, #32
    6438:	fa22 f40e 	lsr.w	r4, r2, lr
    643c:	408b      	lsls	r3, r1
    643e:	4323      	orrs	r3, r4
    6440:	fa20 f70e 	lsr.w	r7, r0, lr
    6444:	fa06 f401 	lsl.w	r4, r6, r1
    6448:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    644c:	fa26 f60e 	lsr.w	r6, r6, lr
    6450:	433c      	orrs	r4, r7
    6452:	fbb6 f9fc 	udiv	r9, r6, ip
    6456:	0c27      	lsrs	r7, r4, #16
    6458:	fb0c 6619 	mls	r6, ip, r9, r6
    645c:	fa1f f883 	uxth.w	r8, r3
    6460:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
    6464:	fb09 f708 	mul.w	r7, r9, r8
    6468:	42b7      	cmp	r7, r6
    646a:	fa02 f201 	lsl.w	r2, r2, r1
    646e:	fa00 fa01 	lsl.w	sl, r0, r1
    6472:	d908      	bls.n	6486 <__udivmoddi4+0x242>
    6474:	18f6      	adds	r6, r6, r3
    6476:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    647a:	d241      	bcs.n	6500 <__udivmoddi4+0x2bc>
    647c:	42b7      	cmp	r7, r6
    647e:	d93f      	bls.n	6500 <__udivmoddi4+0x2bc>
    6480:	f1a9 0902 	sub.w	r9, r9, #2
    6484:	441e      	add	r6, r3
    6486:	1bf6      	subs	r6, r6, r7
    6488:	b2a0      	uxth	r0, r4
    648a:	fbb6 f4fc 	udiv	r4, r6, ip
    648e:	fb0c 6614 	mls	r6, ip, r4, r6
    6492:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
    6496:	fb04 f808 	mul.w	r8, r4, r8
    649a:	45b8      	cmp	r8, r7
    649c:	d907      	bls.n	64ae <__udivmoddi4+0x26a>
    649e:	18ff      	adds	r7, r7, r3
    64a0:	f104 30ff 	add.w	r0, r4, #4294967295	; 0xffffffff
    64a4:	d228      	bcs.n	64f8 <__udivmoddi4+0x2b4>
    64a6:	45b8      	cmp	r8, r7
    64a8:	d926      	bls.n	64f8 <__udivmoddi4+0x2b4>
    64aa:	3c02      	subs	r4, #2
    64ac:	441f      	add	r7, r3
    64ae:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
    64b2:	ebc8 0707 	rsb	r7, r8, r7
    64b6:	fba0 8902 	umull	r8, r9, r0, r2
    64ba:	454f      	cmp	r7, r9
    64bc:	4644      	mov	r4, r8
    64be:	464e      	mov	r6, r9
    64c0:	d314      	bcc.n	64ec <__udivmoddi4+0x2a8>
    64c2:	d029      	beq.n	6518 <__udivmoddi4+0x2d4>
    64c4:	b365      	cbz	r5, 6520 <__udivmoddi4+0x2dc>
    64c6:	ebba 0304 	subs.w	r3, sl, r4
    64ca:	eb67 0706 	sbc.w	r7, r7, r6
    64ce:	fa07 fe0e 	lsl.w	lr, r7, lr
    64d2:	40cb      	lsrs	r3, r1
    64d4:	40cf      	lsrs	r7, r1
    64d6:	ea4e 0303 	orr.w	r3, lr, r3
    64da:	e885 0088 	stmia.w	r5, {r3, r7}
    64de:	2100      	movs	r1, #0
    64e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    64e4:	4613      	mov	r3, r2
    64e6:	e6f8      	b.n	62da <__udivmoddi4+0x96>
    64e8:	4610      	mov	r0, r2
    64ea:	e6e0      	b.n	62ae <__udivmoddi4+0x6a>
    64ec:	ebb8 0402 	subs.w	r4, r8, r2
    64f0:	eb69 0603 	sbc.w	r6, r9, r3
    64f4:	3801      	subs	r0, #1
    64f6:	e7e5      	b.n	64c4 <__udivmoddi4+0x280>
    64f8:	4604      	mov	r4, r0
    64fa:	e7d8      	b.n	64ae <__udivmoddi4+0x26a>
    64fc:	4611      	mov	r1, r2
    64fe:	e795      	b.n	642c <__udivmoddi4+0x1e8>
    6500:	4681      	mov	r9, r0
    6502:	e7c0      	b.n	6486 <__udivmoddi4+0x242>
    6504:	468a      	mov	sl, r1
    6506:	e77c      	b.n	6402 <__udivmoddi4+0x1be>
    6508:	3b02      	subs	r3, #2
    650a:	443c      	add	r4, r7
    650c:	e748      	b.n	63a0 <__udivmoddi4+0x15c>
    650e:	4608      	mov	r0, r1
    6510:	e70a      	b.n	6328 <__udivmoddi4+0xe4>
    6512:	3802      	subs	r0, #2
    6514:	443e      	add	r6, r7
    6516:	e72f      	b.n	6378 <__udivmoddi4+0x134>
    6518:	45c2      	cmp	sl, r8
    651a:	d3e7      	bcc.n	64ec <__udivmoddi4+0x2a8>
    651c:	463e      	mov	r6, r7
    651e:	e7d1      	b.n	64c4 <__udivmoddi4+0x280>
    6520:	4629      	mov	r1, r5
    6522:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6526:	bf00      	nop

00006528 <__aeabi_idiv0>:
    6528:	4770      	bx	lr
    652a:	bf00      	nop

0000652c <__cxa_atexit>:
    652c:	4613      	mov	r3, r2
    652e:	460a      	mov	r2, r1
    6530:	4601      	mov	r1, r0
    6532:	2002      	movs	r0, #2
    6534:	f001 b99c 	b.w	7870 <__register_exitproc>

00006538 <__errno>:
    6538:	4b01      	ldr	r3, [pc, #4]	; (6540 <__errno+0x8>)
    653a:	6818      	ldr	r0, [r3, #0]
    653c:	4770      	bx	lr
    653e:	bf00      	nop
    6540:	20001ef0 	.word	0x20001ef0

00006544 <exit>:
    6544:	b508      	push	{r3, lr}
    6546:	2100      	movs	r1, #0
    6548:	4604      	mov	r4, r0
    654a:	f001 f9e3 	bl	7914 <__call_exitprocs>
    654e:	4b04      	ldr	r3, [pc, #16]	; (6560 <exit+0x1c>)
    6550:	6818      	ldr	r0, [r3, #0]
    6552:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    6554:	b103      	cbz	r3, 6558 <exit+0x14>
    6556:	4798      	blx	r3
    6558:	4620      	mov	r0, r4
    655a:	f7fb fbe7 	bl	1d2c <_exit>
    655e:	bf00      	nop
    6560:	200006c8 	.word	0x200006c8

00006564 <__libc_init_array>:
    6564:	b570      	push	{r4, r5, r6, lr}
    6566:	4e0f      	ldr	r6, [pc, #60]	; (65a4 <__libc_init_array+0x40>)
    6568:	4d0f      	ldr	r5, [pc, #60]	; (65a8 <__libc_init_array+0x44>)
    656a:	1b76      	subs	r6, r6, r5
    656c:	10b6      	asrs	r6, r6, #2
    656e:	bf18      	it	ne
    6570:	2400      	movne	r4, #0
    6572:	d005      	beq.n	6580 <__libc_init_array+0x1c>
    6574:	3401      	adds	r4, #1
    6576:	f855 3b04 	ldr.w	r3, [r5], #4
    657a:	4798      	blx	r3
    657c:	42a6      	cmp	r6, r4
    657e:	d1f9      	bne.n	6574 <__libc_init_array+0x10>
    6580:	4e0a      	ldr	r6, [pc, #40]	; (65ac <__libc_init_array+0x48>)
    6582:	4d0b      	ldr	r5, [pc, #44]	; (65b0 <__libc_init_array+0x4c>)
    6584:	1b76      	subs	r6, r6, r5
    6586:	f004 f957 	bl	a838 <___init_veneer>
    658a:	10b6      	asrs	r6, r6, #2
    658c:	bf18      	it	ne
    658e:	2400      	movne	r4, #0
    6590:	d006      	beq.n	65a0 <__libc_init_array+0x3c>
    6592:	3401      	adds	r4, #1
    6594:	f855 3b04 	ldr.w	r3, [r5], #4
    6598:	4798      	blx	r3
    659a:	42a6      	cmp	r6, r4
    659c:	d1f9      	bne.n	6592 <__libc_init_array+0x2e>
    659e:	bd70      	pop	{r4, r5, r6, pc}
    65a0:	bd70      	pop	{r4, r5, r6, pc}
    65a2:	bf00      	nop
    65a4:	60002098 	.word	0x60002098
    65a8:	60002098 	.word	0x60002098
    65ac:	600020a0 	.word	0x600020a0
    65b0:	60002098 	.word	0x60002098

000065b4 <__itoa>:
    65b4:	1e93      	subs	r3, r2, #2
    65b6:	2b22      	cmp	r3, #34	; 0x22
    65b8:	d810      	bhi.n	65dc <__itoa+0x28>
    65ba:	2a0a      	cmp	r2, #10
    65bc:	b510      	push	{r4, lr}
    65be:	d006      	beq.n	65ce <__itoa+0x1a>
    65c0:	2300      	movs	r3, #0
    65c2:	460c      	mov	r4, r1
    65c4:	4419      	add	r1, r3
    65c6:	f001 f8bd 	bl	7744 <__utoa>
    65ca:	4620      	mov	r0, r4
    65cc:	bd10      	pop	{r4, pc}
    65ce:	2800      	cmp	r0, #0
    65d0:	daf6      	bge.n	65c0 <__itoa+0xc>
    65d2:	232d      	movs	r3, #45	; 0x2d
    65d4:	700b      	strb	r3, [r1, #0]
    65d6:	4240      	negs	r0, r0
    65d8:	2301      	movs	r3, #1
    65da:	e7f2      	b.n	65c2 <__itoa+0xe>
    65dc:	2000      	movs	r0, #0
    65de:	7008      	strb	r0, [r1, #0]
    65e0:	4770      	bx	lr
    65e2:	bf00      	nop

000065e4 <itoa>:
    65e4:	f7ff bfe6 	b.w	65b4 <__itoa>

000065e8 <malloc>:
    65e8:	4b02      	ldr	r3, [pc, #8]	; (65f4 <malloc+0xc>)
    65ea:	4601      	mov	r1, r0
    65ec:	6818      	ldr	r0, [r3, #0]
    65ee:	f000 b80b 	b.w	6608 <_malloc_r>
    65f2:	bf00      	nop
    65f4:	20001ef0 	.word	0x20001ef0

000065f8 <free>:
    65f8:	4b02      	ldr	r3, [pc, #8]	; (6604 <free+0xc>)
    65fa:	4601      	mov	r1, r0
    65fc:	6818      	ldr	r0, [r3, #0]
    65fe:	f001 ba43 	b.w	7a88 <_free_r>
    6602:	bf00      	nop
    6604:	20001ef0 	.word	0x20001ef0

00006608 <_malloc_r>:
    6608:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    660c:	f101 050b 	add.w	r5, r1, #11
    6610:	2d16      	cmp	r5, #22
    6612:	b083      	sub	sp, #12
    6614:	4606      	mov	r6, r0
    6616:	f240 809f 	bls.w	6758 <_malloc_r+0x150>
    661a:	f035 0507 	bics.w	r5, r5, #7
    661e:	f100 80bf 	bmi.w	67a0 <_malloc_r+0x198>
    6622:	42a9      	cmp	r1, r5
    6624:	f200 80bc 	bhi.w	67a0 <_malloc_r+0x198>
    6628:	f000 fc08 	bl	6e3c <__malloc_lock>
    662c:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    6630:	f0c0 829c 	bcc.w	6b6c <_malloc_r+0x564>
    6634:	0a6b      	lsrs	r3, r5, #9
    6636:	f000 80ba 	beq.w	67ae <_malloc_r+0x1a6>
    663a:	2b04      	cmp	r3, #4
    663c:	f200 8183 	bhi.w	6946 <_malloc_r+0x33e>
    6640:	09a8      	lsrs	r0, r5, #6
    6642:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    6646:	ea4f 034e 	mov.w	r3, lr, lsl #1
    664a:	3038      	adds	r0, #56	; 0x38
    664c:	4fc4      	ldr	r7, [pc, #784]	; (6960 <_malloc_r+0x358>)
    664e:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    6652:	f1a3 0108 	sub.w	r1, r3, #8
    6656:	685c      	ldr	r4, [r3, #4]
    6658:	42a1      	cmp	r1, r4
    665a:	d107      	bne.n	666c <_malloc_r+0x64>
    665c:	e0ac      	b.n	67b8 <_malloc_r+0x1b0>
    665e:	2a00      	cmp	r2, #0
    6660:	f280 80ac 	bge.w	67bc <_malloc_r+0x1b4>
    6664:	68e4      	ldr	r4, [r4, #12]
    6666:	42a1      	cmp	r1, r4
    6668:	f000 80a6 	beq.w	67b8 <_malloc_r+0x1b0>
    666c:	6863      	ldr	r3, [r4, #4]
    666e:	f023 0303 	bic.w	r3, r3, #3
    6672:	1b5a      	subs	r2, r3, r5
    6674:	2a0f      	cmp	r2, #15
    6676:	ddf2      	ble.n	665e <_malloc_r+0x56>
    6678:	49b9      	ldr	r1, [pc, #740]	; (6960 <_malloc_r+0x358>)
    667a:	693c      	ldr	r4, [r7, #16]
    667c:	f101 0e08 	add.w	lr, r1, #8
    6680:	4574      	cmp	r4, lr
    6682:	f000 81b3 	beq.w	69ec <_malloc_r+0x3e4>
    6686:	6863      	ldr	r3, [r4, #4]
    6688:	f023 0303 	bic.w	r3, r3, #3
    668c:	1b5a      	subs	r2, r3, r5
    668e:	2a0f      	cmp	r2, #15
    6690:	f300 8199 	bgt.w	69c6 <_malloc_r+0x3be>
    6694:	2a00      	cmp	r2, #0
    6696:	f8c1 e014 	str.w	lr, [r1, #20]
    669a:	f8c1 e010 	str.w	lr, [r1, #16]
    669e:	f280 809e 	bge.w	67de <_malloc_r+0x1d6>
    66a2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    66a6:	f080 8167 	bcs.w	6978 <_malloc_r+0x370>
    66aa:	08db      	lsrs	r3, r3, #3
    66ac:	f103 0c01 	add.w	ip, r3, #1
    66b0:	2201      	movs	r2, #1
    66b2:	109b      	asrs	r3, r3, #2
    66b4:	fa02 f303 	lsl.w	r3, r2, r3
    66b8:	684a      	ldr	r2, [r1, #4]
    66ba:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    66be:	f8c4 8008 	str.w	r8, [r4, #8]
    66c2:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    66c6:	431a      	orrs	r2, r3
    66c8:	f1a9 0308 	sub.w	r3, r9, #8
    66cc:	60e3      	str	r3, [r4, #12]
    66ce:	604a      	str	r2, [r1, #4]
    66d0:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    66d4:	f8c8 400c 	str.w	r4, [r8, #12]
    66d8:	1083      	asrs	r3, r0, #2
    66da:	2401      	movs	r4, #1
    66dc:	409c      	lsls	r4, r3
    66de:	4294      	cmp	r4, r2
    66e0:	f200 808a 	bhi.w	67f8 <_malloc_r+0x1f0>
    66e4:	4214      	tst	r4, r2
    66e6:	d106      	bne.n	66f6 <_malloc_r+0xee>
    66e8:	f020 0003 	bic.w	r0, r0, #3
    66ec:	0064      	lsls	r4, r4, #1
    66ee:	4214      	tst	r4, r2
    66f0:	f100 0004 	add.w	r0, r0, #4
    66f4:	d0fa      	beq.n	66ec <_malloc_r+0xe4>
    66f6:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    66fa:	46cc      	mov	ip, r9
    66fc:	4680      	mov	r8, r0
    66fe:	f8dc 100c 	ldr.w	r1, [ip, #12]
    6702:	458c      	cmp	ip, r1
    6704:	d107      	bne.n	6716 <_malloc_r+0x10e>
    6706:	e173      	b.n	69f0 <_malloc_r+0x3e8>
    6708:	2a00      	cmp	r2, #0
    670a:	f280 8181 	bge.w	6a10 <_malloc_r+0x408>
    670e:	68c9      	ldr	r1, [r1, #12]
    6710:	458c      	cmp	ip, r1
    6712:	f000 816d 	beq.w	69f0 <_malloc_r+0x3e8>
    6716:	684b      	ldr	r3, [r1, #4]
    6718:	f023 0303 	bic.w	r3, r3, #3
    671c:	1b5a      	subs	r2, r3, r5
    671e:	2a0f      	cmp	r2, #15
    6720:	ddf2      	ble.n	6708 <_malloc_r+0x100>
    6722:	460c      	mov	r4, r1
    6724:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    6728:	f854 8f08 	ldr.w	r8, [r4, #8]!
    672c:	194b      	adds	r3, r1, r5
    672e:	f045 0501 	orr.w	r5, r5, #1
    6732:	604d      	str	r5, [r1, #4]
    6734:	f042 0101 	orr.w	r1, r2, #1
    6738:	f8c8 c00c 	str.w	ip, [r8, #12]
    673c:	4630      	mov	r0, r6
    673e:	f8cc 8008 	str.w	r8, [ip, #8]
    6742:	617b      	str	r3, [r7, #20]
    6744:	613b      	str	r3, [r7, #16]
    6746:	f8c3 e00c 	str.w	lr, [r3, #12]
    674a:	f8c3 e008 	str.w	lr, [r3, #8]
    674e:	6059      	str	r1, [r3, #4]
    6750:	509a      	str	r2, [r3, r2]
    6752:	f000 fb75 	bl	6e40 <__malloc_unlock>
    6756:	e01f      	b.n	6798 <_malloc_r+0x190>
    6758:	2910      	cmp	r1, #16
    675a:	d821      	bhi.n	67a0 <_malloc_r+0x198>
    675c:	f000 fb6e 	bl	6e3c <__malloc_lock>
    6760:	2510      	movs	r5, #16
    6762:	2306      	movs	r3, #6
    6764:	2002      	movs	r0, #2
    6766:	4f7e      	ldr	r7, [pc, #504]	; (6960 <_malloc_r+0x358>)
    6768:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    676c:	f1a3 0208 	sub.w	r2, r3, #8
    6770:	685c      	ldr	r4, [r3, #4]
    6772:	4294      	cmp	r4, r2
    6774:	f000 8145 	beq.w	6a02 <_malloc_r+0x3fa>
    6778:	6863      	ldr	r3, [r4, #4]
    677a:	68e1      	ldr	r1, [r4, #12]
    677c:	68a5      	ldr	r5, [r4, #8]
    677e:	f023 0303 	bic.w	r3, r3, #3
    6782:	4423      	add	r3, r4
    6784:	4630      	mov	r0, r6
    6786:	685a      	ldr	r2, [r3, #4]
    6788:	60e9      	str	r1, [r5, #12]
    678a:	f042 0201 	orr.w	r2, r2, #1
    678e:	608d      	str	r5, [r1, #8]
    6790:	605a      	str	r2, [r3, #4]
    6792:	f000 fb55 	bl	6e40 <__malloc_unlock>
    6796:	3408      	adds	r4, #8
    6798:	4620      	mov	r0, r4
    679a:	b003      	add	sp, #12
    679c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    67a0:	2400      	movs	r4, #0
    67a2:	230c      	movs	r3, #12
    67a4:	4620      	mov	r0, r4
    67a6:	6033      	str	r3, [r6, #0]
    67a8:	b003      	add	sp, #12
    67aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    67ae:	2380      	movs	r3, #128	; 0x80
    67b0:	f04f 0e40 	mov.w	lr, #64	; 0x40
    67b4:	203f      	movs	r0, #63	; 0x3f
    67b6:	e749      	b.n	664c <_malloc_r+0x44>
    67b8:	4670      	mov	r0, lr
    67ba:	e75d      	b.n	6678 <_malloc_r+0x70>
    67bc:	4423      	add	r3, r4
    67be:	68e1      	ldr	r1, [r4, #12]
    67c0:	685a      	ldr	r2, [r3, #4]
    67c2:	68a5      	ldr	r5, [r4, #8]
    67c4:	f042 0201 	orr.w	r2, r2, #1
    67c8:	60e9      	str	r1, [r5, #12]
    67ca:	4630      	mov	r0, r6
    67cc:	608d      	str	r5, [r1, #8]
    67ce:	605a      	str	r2, [r3, #4]
    67d0:	f000 fb36 	bl	6e40 <__malloc_unlock>
    67d4:	3408      	adds	r4, #8
    67d6:	4620      	mov	r0, r4
    67d8:	b003      	add	sp, #12
    67da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    67de:	4423      	add	r3, r4
    67e0:	4630      	mov	r0, r6
    67e2:	685a      	ldr	r2, [r3, #4]
    67e4:	f042 0201 	orr.w	r2, r2, #1
    67e8:	605a      	str	r2, [r3, #4]
    67ea:	f000 fb29 	bl	6e40 <__malloc_unlock>
    67ee:	3408      	adds	r4, #8
    67f0:	4620      	mov	r0, r4
    67f2:	b003      	add	sp, #12
    67f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    67f8:	68bc      	ldr	r4, [r7, #8]
    67fa:	6863      	ldr	r3, [r4, #4]
    67fc:	f023 0803 	bic.w	r8, r3, #3
    6800:	45a8      	cmp	r8, r5
    6802:	d304      	bcc.n	680e <_malloc_r+0x206>
    6804:	ebc5 0308 	rsb	r3, r5, r8
    6808:	2b0f      	cmp	r3, #15
    680a:	f300 808c 	bgt.w	6926 <_malloc_r+0x31e>
    680e:	4b55      	ldr	r3, [pc, #340]	; (6964 <_malloc_r+0x35c>)
    6810:	f8df 9160 	ldr.w	r9, [pc, #352]	; 6974 <_malloc_r+0x36c>
    6814:	681a      	ldr	r2, [r3, #0]
    6816:	f8d9 3000 	ldr.w	r3, [r9]
    681a:	3301      	adds	r3, #1
    681c:	442a      	add	r2, r5
    681e:	eb04 0a08 	add.w	sl, r4, r8
    6822:	f000 8160 	beq.w	6ae6 <_malloc_r+0x4de>
    6826:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    682a:	320f      	adds	r2, #15
    682c:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    6830:	f022 020f 	bic.w	r2, r2, #15
    6834:	4611      	mov	r1, r2
    6836:	4630      	mov	r0, r6
    6838:	9201      	str	r2, [sp, #4]
    683a:	f000 fcfb 	bl	7234 <_sbrk_r>
    683e:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    6842:	4683      	mov	fp, r0
    6844:	9a01      	ldr	r2, [sp, #4]
    6846:	f000 8158 	beq.w	6afa <_malloc_r+0x4f2>
    684a:	4582      	cmp	sl, r0
    684c:	f200 80fc 	bhi.w	6a48 <_malloc_r+0x440>
    6850:	4b45      	ldr	r3, [pc, #276]	; (6968 <_malloc_r+0x360>)
    6852:	6819      	ldr	r1, [r3, #0]
    6854:	45da      	cmp	sl, fp
    6856:	4411      	add	r1, r2
    6858:	6019      	str	r1, [r3, #0]
    685a:	f000 8153 	beq.w	6b04 <_malloc_r+0x4fc>
    685e:	f8d9 0000 	ldr.w	r0, [r9]
    6862:	f8df e110 	ldr.w	lr, [pc, #272]	; 6974 <_malloc_r+0x36c>
    6866:	3001      	adds	r0, #1
    6868:	bf1b      	ittet	ne
    686a:	ebca 0a0b 	rsbne	sl, sl, fp
    686e:	4451      	addne	r1, sl
    6870:	f8ce b000 	streq.w	fp, [lr]
    6874:	6019      	strne	r1, [r3, #0]
    6876:	f01b 0107 	ands.w	r1, fp, #7
    687a:	f000 8117 	beq.w	6aac <_malloc_r+0x4a4>
    687e:	f1c1 0008 	rsb	r0, r1, #8
    6882:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    6886:	4483      	add	fp, r0
    6888:	3108      	adds	r1, #8
    688a:	445a      	add	r2, fp
    688c:	f3c2 020b 	ubfx	r2, r2, #0, #12
    6890:	ebc2 0901 	rsb	r9, r2, r1
    6894:	4649      	mov	r1, r9
    6896:	4630      	mov	r0, r6
    6898:	9301      	str	r3, [sp, #4]
    689a:	f000 fccb 	bl	7234 <_sbrk_r>
    689e:	1c43      	adds	r3, r0, #1
    68a0:	9b01      	ldr	r3, [sp, #4]
    68a2:	f000 813f 	beq.w	6b24 <_malloc_r+0x51c>
    68a6:	ebcb 0200 	rsb	r2, fp, r0
    68aa:	444a      	add	r2, r9
    68ac:	f042 0201 	orr.w	r2, r2, #1
    68b0:	6819      	ldr	r1, [r3, #0]
    68b2:	f8c7 b008 	str.w	fp, [r7, #8]
    68b6:	4449      	add	r1, r9
    68b8:	42bc      	cmp	r4, r7
    68ba:	f8cb 2004 	str.w	r2, [fp, #4]
    68be:	6019      	str	r1, [r3, #0]
    68c0:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 6968 <_malloc_r+0x360>
    68c4:	d016      	beq.n	68f4 <_malloc_r+0x2ec>
    68c6:	f1b8 0f0f 	cmp.w	r8, #15
    68ca:	f240 80fd 	bls.w	6ac8 <_malloc_r+0x4c0>
    68ce:	6862      	ldr	r2, [r4, #4]
    68d0:	f1a8 030c 	sub.w	r3, r8, #12
    68d4:	f023 0307 	bic.w	r3, r3, #7
    68d8:	18e0      	adds	r0, r4, r3
    68da:	f002 0201 	and.w	r2, r2, #1
    68de:	f04f 0e05 	mov.w	lr, #5
    68e2:	431a      	orrs	r2, r3
    68e4:	2b0f      	cmp	r3, #15
    68e6:	6062      	str	r2, [r4, #4]
    68e8:	f8c0 e004 	str.w	lr, [r0, #4]
    68ec:	f8c0 e008 	str.w	lr, [r0, #8]
    68f0:	f200 811c 	bhi.w	6b2c <_malloc_r+0x524>
    68f4:	4b1d      	ldr	r3, [pc, #116]	; (696c <_malloc_r+0x364>)
    68f6:	68bc      	ldr	r4, [r7, #8]
    68f8:	681a      	ldr	r2, [r3, #0]
    68fa:	4291      	cmp	r1, r2
    68fc:	bf88      	it	hi
    68fe:	6019      	strhi	r1, [r3, #0]
    6900:	4b1b      	ldr	r3, [pc, #108]	; (6970 <_malloc_r+0x368>)
    6902:	681a      	ldr	r2, [r3, #0]
    6904:	4291      	cmp	r1, r2
    6906:	6862      	ldr	r2, [r4, #4]
    6908:	bf88      	it	hi
    690a:	6019      	strhi	r1, [r3, #0]
    690c:	f022 0203 	bic.w	r2, r2, #3
    6910:	4295      	cmp	r5, r2
    6912:	eba2 0305 	sub.w	r3, r2, r5
    6916:	d801      	bhi.n	691c <_malloc_r+0x314>
    6918:	2b0f      	cmp	r3, #15
    691a:	dc04      	bgt.n	6926 <_malloc_r+0x31e>
    691c:	4630      	mov	r0, r6
    691e:	f000 fa8f 	bl	6e40 <__malloc_unlock>
    6922:	2400      	movs	r4, #0
    6924:	e738      	b.n	6798 <_malloc_r+0x190>
    6926:	1962      	adds	r2, r4, r5
    6928:	f043 0301 	orr.w	r3, r3, #1
    692c:	f045 0501 	orr.w	r5, r5, #1
    6930:	6065      	str	r5, [r4, #4]
    6932:	4630      	mov	r0, r6
    6934:	60ba      	str	r2, [r7, #8]
    6936:	6053      	str	r3, [r2, #4]
    6938:	f000 fa82 	bl	6e40 <__malloc_unlock>
    693c:	3408      	adds	r4, #8
    693e:	4620      	mov	r0, r4
    6940:	b003      	add	sp, #12
    6942:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6946:	2b14      	cmp	r3, #20
    6948:	d971      	bls.n	6a2e <_malloc_r+0x426>
    694a:	2b54      	cmp	r3, #84	; 0x54
    694c:	f200 80a4 	bhi.w	6a98 <_malloc_r+0x490>
    6950:	0b28      	lsrs	r0, r5, #12
    6952:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    6956:	ea4f 034e 	mov.w	r3, lr, lsl #1
    695a:	306e      	adds	r0, #110	; 0x6e
    695c:	e676      	b.n	664c <_malloc_r+0x44>
    695e:	bf00      	nop
    6960:	20001ae0 	.word	0x20001ae0
    6964:	200026e4 	.word	0x200026e4
    6968:	200026b4 	.word	0x200026b4
    696c:	200026dc 	.word	0x200026dc
    6970:	200026e0 	.word	0x200026e0
    6974:	20001ee8 	.word	0x20001ee8
    6978:	0a5a      	lsrs	r2, r3, #9
    697a:	2a04      	cmp	r2, #4
    697c:	d95e      	bls.n	6a3c <_malloc_r+0x434>
    697e:	2a14      	cmp	r2, #20
    6980:	f200 80b3 	bhi.w	6aea <_malloc_r+0x4e2>
    6984:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    6988:	0049      	lsls	r1, r1, #1
    698a:	325b      	adds	r2, #91	; 0x5b
    698c:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    6990:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    6994:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 6b74 <_malloc_r+0x56c>
    6998:	f1ac 0c08 	sub.w	ip, ip, #8
    699c:	458c      	cmp	ip, r1
    699e:	f000 8088 	beq.w	6ab2 <_malloc_r+0x4aa>
    69a2:	684a      	ldr	r2, [r1, #4]
    69a4:	f022 0203 	bic.w	r2, r2, #3
    69a8:	4293      	cmp	r3, r2
    69aa:	d202      	bcs.n	69b2 <_malloc_r+0x3aa>
    69ac:	6889      	ldr	r1, [r1, #8]
    69ae:	458c      	cmp	ip, r1
    69b0:	d1f7      	bne.n	69a2 <_malloc_r+0x39a>
    69b2:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    69b6:	687a      	ldr	r2, [r7, #4]
    69b8:	f8c4 c00c 	str.w	ip, [r4, #12]
    69bc:	60a1      	str	r1, [r4, #8]
    69be:	f8cc 4008 	str.w	r4, [ip, #8]
    69c2:	60cc      	str	r4, [r1, #12]
    69c4:	e688      	b.n	66d8 <_malloc_r+0xd0>
    69c6:	1963      	adds	r3, r4, r5
    69c8:	f042 0701 	orr.w	r7, r2, #1
    69cc:	f045 0501 	orr.w	r5, r5, #1
    69d0:	6065      	str	r5, [r4, #4]
    69d2:	4630      	mov	r0, r6
    69d4:	614b      	str	r3, [r1, #20]
    69d6:	610b      	str	r3, [r1, #16]
    69d8:	f8c3 e00c 	str.w	lr, [r3, #12]
    69dc:	f8c3 e008 	str.w	lr, [r3, #8]
    69e0:	605f      	str	r7, [r3, #4]
    69e2:	509a      	str	r2, [r3, r2]
    69e4:	3408      	adds	r4, #8
    69e6:	f000 fa2b 	bl	6e40 <__malloc_unlock>
    69ea:	e6d5      	b.n	6798 <_malloc_r+0x190>
    69ec:	684a      	ldr	r2, [r1, #4]
    69ee:	e673      	b.n	66d8 <_malloc_r+0xd0>
    69f0:	f108 0801 	add.w	r8, r8, #1
    69f4:	f018 0f03 	tst.w	r8, #3
    69f8:	f10c 0c08 	add.w	ip, ip, #8
    69fc:	f47f ae7f 	bne.w	66fe <_malloc_r+0xf6>
    6a00:	e030      	b.n	6a64 <_malloc_r+0x45c>
    6a02:	68dc      	ldr	r4, [r3, #12]
    6a04:	42a3      	cmp	r3, r4
    6a06:	bf08      	it	eq
    6a08:	3002      	addeq	r0, #2
    6a0a:	f43f ae35 	beq.w	6678 <_malloc_r+0x70>
    6a0e:	e6b3      	b.n	6778 <_malloc_r+0x170>
    6a10:	440b      	add	r3, r1
    6a12:	460c      	mov	r4, r1
    6a14:	685a      	ldr	r2, [r3, #4]
    6a16:	68c9      	ldr	r1, [r1, #12]
    6a18:	f854 5f08 	ldr.w	r5, [r4, #8]!
    6a1c:	f042 0201 	orr.w	r2, r2, #1
    6a20:	605a      	str	r2, [r3, #4]
    6a22:	4630      	mov	r0, r6
    6a24:	60e9      	str	r1, [r5, #12]
    6a26:	608d      	str	r5, [r1, #8]
    6a28:	f000 fa0a 	bl	6e40 <__malloc_unlock>
    6a2c:	e6b4      	b.n	6798 <_malloc_r+0x190>
    6a2e:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    6a32:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    6a36:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6a3a:	e607      	b.n	664c <_malloc_r+0x44>
    6a3c:	099a      	lsrs	r2, r3, #6
    6a3e:	f102 0139 	add.w	r1, r2, #57	; 0x39
    6a42:	0049      	lsls	r1, r1, #1
    6a44:	3238      	adds	r2, #56	; 0x38
    6a46:	e7a1      	b.n	698c <_malloc_r+0x384>
    6a48:	42bc      	cmp	r4, r7
    6a4a:	4b4a      	ldr	r3, [pc, #296]	; (6b74 <_malloc_r+0x56c>)
    6a4c:	f43f af00 	beq.w	6850 <_malloc_r+0x248>
    6a50:	689c      	ldr	r4, [r3, #8]
    6a52:	6862      	ldr	r2, [r4, #4]
    6a54:	f022 0203 	bic.w	r2, r2, #3
    6a58:	e75a      	b.n	6910 <_malloc_r+0x308>
    6a5a:	f859 3908 	ldr.w	r3, [r9], #-8
    6a5e:	4599      	cmp	r9, r3
    6a60:	f040 8082 	bne.w	6b68 <_malloc_r+0x560>
    6a64:	f010 0f03 	tst.w	r0, #3
    6a68:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    6a6c:	d1f5      	bne.n	6a5a <_malloc_r+0x452>
    6a6e:	687b      	ldr	r3, [r7, #4]
    6a70:	ea23 0304 	bic.w	r3, r3, r4
    6a74:	607b      	str	r3, [r7, #4]
    6a76:	0064      	lsls	r4, r4, #1
    6a78:	429c      	cmp	r4, r3
    6a7a:	f63f aebd 	bhi.w	67f8 <_malloc_r+0x1f0>
    6a7e:	2c00      	cmp	r4, #0
    6a80:	f43f aeba 	beq.w	67f8 <_malloc_r+0x1f0>
    6a84:	421c      	tst	r4, r3
    6a86:	4640      	mov	r0, r8
    6a88:	f47f ae35 	bne.w	66f6 <_malloc_r+0xee>
    6a8c:	0064      	lsls	r4, r4, #1
    6a8e:	421c      	tst	r4, r3
    6a90:	f100 0004 	add.w	r0, r0, #4
    6a94:	d0fa      	beq.n	6a8c <_malloc_r+0x484>
    6a96:	e62e      	b.n	66f6 <_malloc_r+0xee>
    6a98:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    6a9c:	d818      	bhi.n	6ad0 <_malloc_r+0x4c8>
    6a9e:	0be8      	lsrs	r0, r5, #15
    6aa0:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    6aa4:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6aa8:	3077      	adds	r0, #119	; 0x77
    6aaa:	e5cf      	b.n	664c <_malloc_r+0x44>
    6aac:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    6ab0:	e6eb      	b.n	688a <_malloc_r+0x282>
    6ab2:	2101      	movs	r1, #1
    6ab4:	f8d8 3004 	ldr.w	r3, [r8, #4]
    6ab8:	1092      	asrs	r2, r2, #2
    6aba:	fa01 f202 	lsl.w	r2, r1, r2
    6abe:	431a      	orrs	r2, r3
    6ac0:	f8c8 2004 	str.w	r2, [r8, #4]
    6ac4:	4661      	mov	r1, ip
    6ac6:	e777      	b.n	69b8 <_malloc_r+0x3b0>
    6ac8:	2301      	movs	r3, #1
    6aca:	f8cb 3004 	str.w	r3, [fp, #4]
    6ace:	e725      	b.n	691c <_malloc_r+0x314>
    6ad0:	f240 5254 	movw	r2, #1364	; 0x554
    6ad4:	4293      	cmp	r3, r2
    6ad6:	d820      	bhi.n	6b1a <_malloc_r+0x512>
    6ad8:	0ca8      	lsrs	r0, r5, #18
    6ada:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    6ade:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6ae2:	307c      	adds	r0, #124	; 0x7c
    6ae4:	e5b2      	b.n	664c <_malloc_r+0x44>
    6ae6:	3210      	adds	r2, #16
    6ae8:	e6a4      	b.n	6834 <_malloc_r+0x22c>
    6aea:	2a54      	cmp	r2, #84	; 0x54
    6aec:	d826      	bhi.n	6b3c <_malloc_r+0x534>
    6aee:	0b1a      	lsrs	r2, r3, #12
    6af0:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    6af4:	0049      	lsls	r1, r1, #1
    6af6:	326e      	adds	r2, #110	; 0x6e
    6af8:	e748      	b.n	698c <_malloc_r+0x384>
    6afa:	68bc      	ldr	r4, [r7, #8]
    6afc:	6862      	ldr	r2, [r4, #4]
    6afe:	f022 0203 	bic.w	r2, r2, #3
    6b02:	e705      	b.n	6910 <_malloc_r+0x308>
    6b04:	f3ca 000b 	ubfx	r0, sl, #0, #12
    6b08:	2800      	cmp	r0, #0
    6b0a:	f47f aea8 	bne.w	685e <_malloc_r+0x256>
    6b0e:	4442      	add	r2, r8
    6b10:	68bb      	ldr	r3, [r7, #8]
    6b12:	f042 0201 	orr.w	r2, r2, #1
    6b16:	605a      	str	r2, [r3, #4]
    6b18:	e6ec      	b.n	68f4 <_malloc_r+0x2ec>
    6b1a:	23fe      	movs	r3, #254	; 0xfe
    6b1c:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    6b20:	207e      	movs	r0, #126	; 0x7e
    6b22:	e593      	b.n	664c <_malloc_r+0x44>
    6b24:	2201      	movs	r2, #1
    6b26:	f04f 0900 	mov.w	r9, #0
    6b2a:	e6c1      	b.n	68b0 <_malloc_r+0x2a8>
    6b2c:	f104 0108 	add.w	r1, r4, #8
    6b30:	4630      	mov	r0, r6
    6b32:	f000 ffa9 	bl	7a88 <_free_r>
    6b36:	f8d9 1000 	ldr.w	r1, [r9]
    6b3a:	e6db      	b.n	68f4 <_malloc_r+0x2ec>
    6b3c:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    6b40:	d805      	bhi.n	6b4e <_malloc_r+0x546>
    6b42:	0bda      	lsrs	r2, r3, #15
    6b44:	f102 0178 	add.w	r1, r2, #120	; 0x78
    6b48:	0049      	lsls	r1, r1, #1
    6b4a:	3277      	adds	r2, #119	; 0x77
    6b4c:	e71e      	b.n	698c <_malloc_r+0x384>
    6b4e:	f240 5154 	movw	r1, #1364	; 0x554
    6b52:	428a      	cmp	r2, r1
    6b54:	d805      	bhi.n	6b62 <_malloc_r+0x55a>
    6b56:	0c9a      	lsrs	r2, r3, #18
    6b58:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    6b5c:	0049      	lsls	r1, r1, #1
    6b5e:	327c      	adds	r2, #124	; 0x7c
    6b60:	e714      	b.n	698c <_malloc_r+0x384>
    6b62:	21fe      	movs	r1, #254	; 0xfe
    6b64:	227e      	movs	r2, #126	; 0x7e
    6b66:	e711      	b.n	698c <_malloc_r+0x384>
    6b68:	687b      	ldr	r3, [r7, #4]
    6b6a:	e784      	b.n	6a76 <_malloc_r+0x46e>
    6b6c:	08e8      	lsrs	r0, r5, #3
    6b6e:	1c43      	adds	r3, r0, #1
    6b70:	005b      	lsls	r3, r3, #1
    6b72:	e5f8      	b.n	6766 <_malloc_r+0x15e>
    6b74:	20001ae0 	.word	0x20001ae0

00006b78 <__ascii_mbtowc>:
    6b78:	b082      	sub	sp, #8
    6b7a:	b149      	cbz	r1, 6b90 <__ascii_mbtowc+0x18>
    6b7c:	b15a      	cbz	r2, 6b96 <__ascii_mbtowc+0x1e>
    6b7e:	b16b      	cbz	r3, 6b9c <__ascii_mbtowc+0x24>
    6b80:	7813      	ldrb	r3, [r2, #0]
    6b82:	600b      	str	r3, [r1, #0]
    6b84:	7812      	ldrb	r2, [r2, #0]
    6b86:	1c10      	adds	r0, r2, #0
    6b88:	bf18      	it	ne
    6b8a:	2001      	movne	r0, #1
    6b8c:	b002      	add	sp, #8
    6b8e:	4770      	bx	lr
    6b90:	a901      	add	r1, sp, #4
    6b92:	2a00      	cmp	r2, #0
    6b94:	d1f3      	bne.n	6b7e <__ascii_mbtowc+0x6>
    6b96:	4610      	mov	r0, r2
    6b98:	b002      	add	sp, #8
    6b9a:	4770      	bx	lr
    6b9c:	f06f 0001 	mvn.w	r0, #1
    6ba0:	e7f4      	b.n	6b8c <__ascii_mbtowc+0x14>
    6ba2:	bf00      	nop

00006ba4 <memcpy>:
    6ba4:	4684      	mov	ip, r0
    6ba6:	ea41 0300 	orr.w	r3, r1, r0
    6baa:	f013 0303 	ands.w	r3, r3, #3
    6bae:	d16d      	bne.n	6c8c <memcpy+0xe8>
    6bb0:	3a40      	subs	r2, #64	; 0x40
    6bb2:	d341      	bcc.n	6c38 <memcpy+0x94>
    6bb4:	f851 3b04 	ldr.w	r3, [r1], #4
    6bb8:	f840 3b04 	str.w	r3, [r0], #4
    6bbc:	f851 3b04 	ldr.w	r3, [r1], #4
    6bc0:	f840 3b04 	str.w	r3, [r0], #4
    6bc4:	f851 3b04 	ldr.w	r3, [r1], #4
    6bc8:	f840 3b04 	str.w	r3, [r0], #4
    6bcc:	f851 3b04 	ldr.w	r3, [r1], #4
    6bd0:	f840 3b04 	str.w	r3, [r0], #4
    6bd4:	f851 3b04 	ldr.w	r3, [r1], #4
    6bd8:	f840 3b04 	str.w	r3, [r0], #4
    6bdc:	f851 3b04 	ldr.w	r3, [r1], #4
    6be0:	f840 3b04 	str.w	r3, [r0], #4
    6be4:	f851 3b04 	ldr.w	r3, [r1], #4
    6be8:	f840 3b04 	str.w	r3, [r0], #4
    6bec:	f851 3b04 	ldr.w	r3, [r1], #4
    6bf0:	f840 3b04 	str.w	r3, [r0], #4
    6bf4:	f851 3b04 	ldr.w	r3, [r1], #4
    6bf8:	f840 3b04 	str.w	r3, [r0], #4
    6bfc:	f851 3b04 	ldr.w	r3, [r1], #4
    6c00:	f840 3b04 	str.w	r3, [r0], #4
    6c04:	f851 3b04 	ldr.w	r3, [r1], #4
    6c08:	f840 3b04 	str.w	r3, [r0], #4
    6c0c:	f851 3b04 	ldr.w	r3, [r1], #4
    6c10:	f840 3b04 	str.w	r3, [r0], #4
    6c14:	f851 3b04 	ldr.w	r3, [r1], #4
    6c18:	f840 3b04 	str.w	r3, [r0], #4
    6c1c:	f851 3b04 	ldr.w	r3, [r1], #4
    6c20:	f840 3b04 	str.w	r3, [r0], #4
    6c24:	f851 3b04 	ldr.w	r3, [r1], #4
    6c28:	f840 3b04 	str.w	r3, [r0], #4
    6c2c:	f851 3b04 	ldr.w	r3, [r1], #4
    6c30:	f840 3b04 	str.w	r3, [r0], #4
    6c34:	3a40      	subs	r2, #64	; 0x40
    6c36:	d2bd      	bcs.n	6bb4 <memcpy+0x10>
    6c38:	3230      	adds	r2, #48	; 0x30
    6c3a:	d311      	bcc.n	6c60 <memcpy+0xbc>
    6c3c:	f851 3b04 	ldr.w	r3, [r1], #4
    6c40:	f840 3b04 	str.w	r3, [r0], #4
    6c44:	f851 3b04 	ldr.w	r3, [r1], #4
    6c48:	f840 3b04 	str.w	r3, [r0], #4
    6c4c:	f851 3b04 	ldr.w	r3, [r1], #4
    6c50:	f840 3b04 	str.w	r3, [r0], #4
    6c54:	f851 3b04 	ldr.w	r3, [r1], #4
    6c58:	f840 3b04 	str.w	r3, [r0], #4
    6c5c:	3a10      	subs	r2, #16
    6c5e:	d2ed      	bcs.n	6c3c <memcpy+0x98>
    6c60:	320c      	adds	r2, #12
    6c62:	d305      	bcc.n	6c70 <memcpy+0xcc>
    6c64:	f851 3b04 	ldr.w	r3, [r1], #4
    6c68:	f840 3b04 	str.w	r3, [r0], #4
    6c6c:	3a04      	subs	r2, #4
    6c6e:	d2f9      	bcs.n	6c64 <memcpy+0xc0>
    6c70:	3204      	adds	r2, #4
    6c72:	d008      	beq.n	6c86 <memcpy+0xe2>
    6c74:	07d2      	lsls	r2, r2, #31
    6c76:	bf1c      	itt	ne
    6c78:	f811 3b01 	ldrbne.w	r3, [r1], #1
    6c7c:	f800 3b01 	strbne.w	r3, [r0], #1
    6c80:	d301      	bcc.n	6c86 <memcpy+0xe2>
    6c82:	880b      	ldrh	r3, [r1, #0]
    6c84:	8003      	strh	r3, [r0, #0]
    6c86:	4660      	mov	r0, ip
    6c88:	4770      	bx	lr
    6c8a:	bf00      	nop
    6c8c:	2a08      	cmp	r2, #8
    6c8e:	d313      	bcc.n	6cb8 <memcpy+0x114>
    6c90:	078b      	lsls	r3, r1, #30
    6c92:	d08d      	beq.n	6bb0 <memcpy+0xc>
    6c94:	f010 0303 	ands.w	r3, r0, #3
    6c98:	d08a      	beq.n	6bb0 <memcpy+0xc>
    6c9a:	f1c3 0304 	rsb	r3, r3, #4
    6c9e:	1ad2      	subs	r2, r2, r3
    6ca0:	07db      	lsls	r3, r3, #31
    6ca2:	bf1c      	itt	ne
    6ca4:	f811 3b01 	ldrbne.w	r3, [r1], #1
    6ca8:	f800 3b01 	strbne.w	r3, [r0], #1
    6cac:	d380      	bcc.n	6bb0 <memcpy+0xc>
    6cae:	f831 3b02 	ldrh.w	r3, [r1], #2
    6cb2:	f820 3b02 	strh.w	r3, [r0], #2
    6cb6:	e77b      	b.n	6bb0 <memcpy+0xc>
    6cb8:	3a04      	subs	r2, #4
    6cba:	d3d9      	bcc.n	6c70 <memcpy+0xcc>
    6cbc:	3a01      	subs	r2, #1
    6cbe:	f811 3b01 	ldrb.w	r3, [r1], #1
    6cc2:	f800 3b01 	strb.w	r3, [r0], #1
    6cc6:	d2f9      	bcs.n	6cbc <memcpy+0x118>
    6cc8:	780b      	ldrb	r3, [r1, #0]
    6cca:	7003      	strb	r3, [r0, #0]
    6ccc:	784b      	ldrb	r3, [r1, #1]
    6cce:	7043      	strb	r3, [r0, #1]
    6cd0:	788b      	ldrb	r3, [r1, #2]
    6cd2:	7083      	strb	r3, [r0, #2]
    6cd4:	4660      	mov	r0, ip
    6cd6:	4770      	bx	lr

00006cd8 <memmove>:
    6cd8:	4288      	cmp	r0, r1
    6cda:	b5f0      	push	{r4, r5, r6, r7, lr}
    6cdc:	d90d      	bls.n	6cfa <memmove+0x22>
    6cde:	188b      	adds	r3, r1, r2
    6ce0:	4298      	cmp	r0, r3
    6ce2:	d20a      	bcs.n	6cfa <memmove+0x22>
    6ce4:	1881      	adds	r1, r0, r2
    6ce6:	2a00      	cmp	r2, #0
    6ce8:	d051      	beq.n	6d8e <memmove+0xb6>
    6cea:	1a9a      	subs	r2, r3, r2
    6cec:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    6cf0:	f801 4d01 	strb.w	r4, [r1, #-1]!
    6cf4:	4293      	cmp	r3, r2
    6cf6:	d1f9      	bne.n	6cec <memmove+0x14>
    6cf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6cfa:	2a0f      	cmp	r2, #15
    6cfc:	d948      	bls.n	6d90 <memmove+0xb8>
    6cfe:	ea41 0300 	orr.w	r3, r1, r0
    6d02:	079b      	lsls	r3, r3, #30
    6d04:	d146      	bne.n	6d94 <memmove+0xbc>
    6d06:	f100 0410 	add.w	r4, r0, #16
    6d0a:	f101 0310 	add.w	r3, r1, #16
    6d0e:	4615      	mov	r5, r2
    6d10:	f853 6c10 	ldr.w	r6, [r3, #-16]
    6d14:	f844 6c10 	str.w	r6, [r4, #-16]
    6d18:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    6d1c:	f844 6c0c 	str.w	r6, [r4, #-12]
    6d20:	f853 6c08 	ldr.w	r6, [r3, #-8]
    6d24:	f844 6c08 	str.w	r6, [r4, #-8]
    6d28:	3d10      	subs	r5, #16
    6d2a:	f853 6c04 	ldr.w	r6, [r3, #-4]
    6d2e:	f844 6c04 	str.w	r6, [r4, #-4]
    6d32:	2d0f      	cmp	r5, #15
    6d34:	f103 0310 	add.w	r3, r3, #16
    6d38:	f104 0410 	add.w	r4, r4, #16
    6d3c:	d8e8      	bhi.n	6d10 <memmove+0x38>
    6d3e:	f1a2 0310 	sub.w	r3, r2, #16
    6d42:	f023 030f 	bic.w	r3, r3, #15
    6d46:	f002 0e0f 	and.w	lr, r2, #15
    6d4a:	3310      	adds	r3, #16
    6d4c:	f1be 0f03 	cmp.w	lr, #3
    6d50:	4419      	add	r1, r3
    6d52:	4403      	add	r3, r0
    6d54:	d921      	bls.n	6d9a <memmove+0xc2>
    6d56:	1f1e      	subs	r6, r3, #4
    6d58:	460d      	mov	r5, r1
    6d5a:	4674      	mov	r4, lr
    6d5c:	3c04      	subs	r4, #4
    6d5e:	f855 7b04 	ldr.w	r7, [r5], #4
    6d62:	f846 7f04 	str.w	r7, [r6, #4]!
    6d66:	2c03      	cmp	r4, #3
    6d68:	d8f8      	bhi.n	6d5c <memmove+0x84>
    6d6a:	f1ae 0404 	sub.w	r4, lr, #4
    6d6e:	f024 0403 	bic.w	r4, r4, #3
    6d72:	3404      	adds	r4, #4
    6d74:	4423      	add	r3, r4
    6d76:	4421      	add	r1, r4
    6d78:	f002 0203 	and.w	r2, r2, #3
    6d7c:	b162      	cbz	r2, 6d98 <memmove+0xc0>
    6d7e:	3b01      	subs	r3, #1
    6d80:	440a      	add	r2, r1
    6d82:	f811 4b01 	ldrb.w	r4, [r1], #1
    6d86:	f803 4f01 	strb.w	r4, [r3, #1]!
    6d8a:	428a      	cmp	r2, r1
    6d8c:	d1f9      	bne.n	6d82 <memmove+0xaa>
    6d8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6d90:	4603      	mov	r3, r0
    6d92:	e7f3      	b.n	6d7c <memmove+0xa4>
    6d94:	4603      	mov	r3, r0
    6d96:	e7f2      	b.n	6d7e <memmove+0xa6>
    6d98:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6d9a:	4672      	mov	r2, lr
    6d9c:	e7ee      	b.n	6d7c <memmove+0xa4>
    6d9e:	bf00      	nop

00006da0 <memset>:
    6da0:	b470      	push	{r4, r5, r6}
    6da2:	0784      	lsls	r4, r0, #30
    6da4:	d046      	beq.n	6e34 <memset+0x94>
    6da6:	1e54      	subs	r4, r2, #1
    6da8:	2a00      	cmp	r2, #0
    6daa:	d041      	beq.n	6e30 <memset+0x90>
    6dac:	b2cd      	uxtb	r5, r1
    6dae:	4603      	mov	r3, r0
    6db0:	e002      	b.n	6db8 <memset+0x18>
    6db2:	1e62      	subs	r2, r4, #1
    6db4:	b3e4      	cbz	r4, 6e30 <memset+0x90>
    6db6:	4614      	mov	r4, r2
    6db8:	f803 5b01 	strb.w	r5, [r3], #1
    6dbc:	079a      	lsls	r2, r3, #30
    6dbe:	d1f8      	bne.n	6db2 <memset+0x12>
    6dc0:	2c03      	cmp	r4, #3
    6dc2:	d92e      	bls.n	6e22 <memset+0x82>
    6dc4:	b2cd      	uxtb	r5, r1
    6dc6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    6dca:	2c0f      	cmp	r4, #15
    6dcc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    6dd0:	d919      	bls.n	6e06 <memset+0x66>
    6dd2:	f103 0210 	add.w	r2, r3, #16
    6dd6:	4626      	mov	r6, r4
    6dd8:	3e10      	subs	r6, #16
    6dda:	2e0f      	cmp	r6, #15
    6ddc:	f842 5c10 	str.w	r5, [r2, #-16]
    6de0:	f842 5c0c 	str.w	r5, [r2, #-12]
    6de4:	f842 5c08 	str.w	r5, [r2, #-8]
    6de8:	f842 5c04 	str.w	r5, [r2, #-4]
    6dec:	f102 0210 	add.w	r2, r2, #16
    6df0:	d8f2      	bhi.n	6dd8 <memset+0x38>
    6df2:	f1a4 0210 	sub.w	r2, r4, #16
    6df6:	f022 020f 	bic.w	r2, r2, #15
    6dfa:	f004 040f 	and.w	r4, r4, #15
    6dfe:	3210      	adds	r2, #16
    6e00:	2c03      	cmp	r4, #3
    6e02:	4413      	add	r3, r2
    6e04:	d90d      	bls.n	6e22 <memset+0x82>
    6e06:	461e      	mov	r6, r3
    6e08:	4622      	mov	r2, r4
    6e0a:	3a04      	subs	r2, #4
    6e0c:	2a03      	cmp	r2, #3
    6e0e:	f846 5b04 	str.w	r5, [r6], #4
    6e12:	d8fa      	bhi.n	6e0a <memset+0x6a>
    6e14:	1f22      	subs	r2, r4, #4
    6e16:	f022 0203 	bic.w	r2, r2, #3
    6e1a:	3204      	adds	r2, #4
    6e1c:	4413      	add	r3, r2
    6e1e:	f004 0403 	and.w	r4, r4, #3
    6e22:	b12c      	cbz	r4, 6e30 <memset+0x90>
    6e24:	b2c9      	uxtb	r1, r1
    6e26:	441c      	add	r4, r3
    6e28:	f803 1b01 	strb.w	r1, [r3], #1
    6e2c:	42a3      	cmp	r3, r4
    6e2e:	d1fb      	bne.n	6e28 <memset+0x88>
    6e30:	bc70      	pop	{r4, r5, r6}
    6e32:	4770      	bx	lr
    6e34:	4614      	mov	r4, r2
    6e36:	4603      	mov	r3, r0
    6e38:	e7c2      	b.n	6dc0 <memset+0x20>
    6e3a:	bf00      	nop

00006e3c <__malloc_lock>:
    6e3c:	4770      	bx	lr
    6e3e:	bf00      	nop

00006e40 <__malloc_unlock>:
    6e40:	4770      	bx	lr
    6e42:	bf00      	nop

00006e44 <realloc>:
    6e44:	4b02      	ldr	r3, [pc, #8]	; (6e50 <realloc+0xc>)
    6e46:	460a      	mov	r2, r1
    6e48:	4601      	mov	r1, r0
    6e4a:	6818      	ldr	r0, [r3, #0]
    6e4c:	f000 b802 	b.w	6e54 <_realloc_r>
    6e50:	20001ef0 	.word	0x20001ef0

00006e54 <_realloc_r>:
    6e54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6e58:	4617      	mov	r7, r2
    6e5a:	b083      	sub	sp, #12
    6e5c:	2900      	cmp	r1, #0
    6e5e:	f000 80c1 	beq.w	6fe4 <_realloc_r+0x190>
    6e62:	460e      	mov	r6, r1
    6e64:	4681      	mov	r9, r0
    6e66:	f107 050b 	add.w	r5, r7, #11
    6e6a:	f7ff ffe7 	bl	6e3c <__malloc_lock>
    6e6e:	f856 ec04 	ldr.w	lr, [r6, #-4]
    6e72:	2d16      	cmp	r5, #22
    6e74:	f02e 0403 	bic.w	r4, lr, #3
    6e78:	f1a6 0808 	sub.w	r8, r6, #8
    6e7c:	d840      	bhi.n	6f00 <_realloc_r+0xac>
    6e7e:	2210      	movs	r2, #16
    6e80:	4615      	mov	r5, r2
    6e82:	42af      	cmp	r7, r5
    6e84:	d841      	bhi.n	6f0a <_realloc_r+0xb6>
    6e86:	4294      	cmp	r4, r2
    6e88:	da75      	bge.n	6f76 <_realloc_r+0x122>
    6e8a:	4bc9      	ldr	r3, [pc, #804]	; (71b0 <_realloc_r+0x35c>)
    6e8c:	6899      	ldr	r1, [r3, #8]
    6e8e:	eb08 0004 	add.w	r0, r8, r4
    6e92:	4288      	cmp	r0, r1
    6e94:	6841      	ldr	r1, [r0, #4]
    6e96:	f000 80d9 	beq.w	704c <_realloc_r+0x1f8>
    6e9a:	f021 0301 	bic.w	r3, r1, #1
    6e9e:	4403      	add	r3, r0
    6ea0:	685b      	ldr	r3, [r3, #4]
    6ea2:	07db      	lsls	r3, r3, #31
    6ea4:	d57d      	bpl.n	6fa2 <_realloc_r+0x14e>
    6ea6:	f01e 0f01 	tst.w	lr, #1
    6eaa:	d035      	beq.n	6f18 <_realloc_r+0xc4>
    6eac:	4639      	mov	r1, r7
    6eae:	4648      	mov	r0, r9
    6eb0:	f7ff fbaa 	bl	6608 <_malloc_r>
    6eb4:	4607      	mov	r7, r0
    6eb6:	b1e0      	cbz	r0, 6ef2 <_realloc_r+0x9e>
    6eb8:	f856 3c04 	ldr.w	r3, [r6, #-4]
    6ebc:	f023 0301 	bic.w	r3, r3, #1
    6ec0:	4443      	add	r3, r8
    6ec2:	f1a0 0208 	sub.w	r2, r0, #8
    6ec6:	429a      	cmp	r2, r3
    6ec8:	f000 8144 	beq.w	7154 <_realloc_r+0x300>
    6ecc:	1f22      	subs	r2, r4, #4
    6ece:	2a24      	cmp	r2, #36	; 0x24
    6ed0:	f200 8131 	bhi.w	7136 <_realloc_r+0x2e2>
    6ed4:	2a13      	cmp	r2, #19
    6ed6:	f200 8104 	bhi.w	70e2 <_realloc_r+0x28e>
    6eda:	4603      	mov	r3, r0
    6edc:	4632      	mov	r2, r6
    6ede:	6811      	ldr	r1, [r2, #0]
    6ee0:	6019      	str	r1, [r3, #0]
    6ee2:	6851      	ldr	r1, [r2, #4]
    6ee4:	6059      	str	r1, [r3, #4]
    6ee6:	6892      	ldr	r2, [r2, #8]
    6ee8:	609a      	str	r2, [r3, #8]
    6eea:	4631      	mov	r1, r6
    6eec:	4648      	mov	r0, r9
    6eee:	f000 fdcb 	bl	7a88 <_free_r>
    6ef2:	4648      	mov	r0, r9
    6ef4:	f7ff ffa4 	bl	6e40 <__malloc_unlock>
    6ef8:	4638      	mov	r0, r7
    6efa:	b003      	add	sp, #12
    6efc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6f00:	f025 0507 	bic.w	r5, r5, #7
    6f04:	2d00      	cmp	r5, #0
    6f06:	462a      	mov	r2, r5
    6f08:	dabb      	bge.n	6e82 <_realloc_r+0x2e>
    6f0a:	230c      	movs	r3, #12
    6f0c:	2000      	movs	r0, #0
    6f0e:	f8c9 3000 	str.w	r3, [r9]
    6f12:	b003      	add	sp, #12
    6f14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6f18:	f856 3c08 	ldr.w	r3, [r6, #-8]
    6f1c:	ebc3 0a08 	rsb	sl, r3, r8
    6f20:	f8da 3004 	ldr.w	r3, [sl, #4]
    6f24:	f023 0c03 	bic.w	ip, r3, #3
    6f28:	eb04 030c 	add.w	r3, r4, ip
    6f2c:	4293      	cmp	r3, r2
    6f2e:	dbbd      	blt.n	6eac <_realloc_r+0x58>
    6f30:	4657      	mov	r7, sl
    6f32:	f8da 100c 	ldr.w	r1, [sl, #12]
    6f36:	f857 0f08 	ldr.w	r0, [r7, #8]!
    6f3a:	1f22      	subs	r2, r4, #4
    6f3c:	2a24      	cmp	r2, #36	; 0x24
    6f3e:	60c1      	str	r1, [r0, #12]
    6f40:	6088      	str	r0, [r1, #8]
    6f42:	f200 8117 	bhi.w	7174 <_realloc_r+0x320>
    6f46:	2a13      	cmp	r2, #19
    6f48:	f240 8112 	bls.w	7170 <_realloc_r+0x31c>
    6f4c:	6831      	ldr	r1, [r6, #0]
    6f4e:	f8ca 1008 	str.w	r1, [sl, #8]
    6f52:	6871      	ldr	r1, [r6, #4]
    6f54:	f8ca 100c 	str.w	r1, [sl, #12]
    6f58:	2a1b      	cmp	r2, #27
    6f5a:	f200 812b 	bhi.w	71b4 <_realloc_r+0x360>
    6f5e:	3608      	adds	r6, #8
    6f60:	f10a 0210 	add.w	r2, sl, #16
    6f64:	6831      	ldr	r1, [r6, #0]
    6f66:	6011      	str	r1, [r2, #0]
    6f68:	6871      	ldr	r1, [r6, #4]
    6f6a:	6051      	str	r1, [r2, #4]
    6f6c:	68b1      	ldr	r1, [r6, #8]
    6f6e:	6091      	str	r1, [r2, #8]
    6f70:	463e      	mov	r6, r7
    6f72:	461c      	mov	r4, r3
    6f74:	46d0      	mov	r8, sl
    6f76:	1b63      	subs	r3, r4, r5
    6f78:	2b0f      	cmp	r3, #15
    6f7a:	d81d      	bhi.n	6fb8 <_realloc_r+0x164>
    6f7c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    6f80:	f003 0301 	and.w	r3, r3, #1
    6f84:	4323      	orrs	r3, r4
    6f86:	4444      	add	r4, r8
    6f88:	f8c8 3004 	str.w	r3, [r8, #4]
    6f8c:	6863      	ldr	r3, [r4, #4]
    6f8e:	f043 0301 	orr.w	r3, r3, #1
    6f92:	6063      	str	r3, [r4, #4]
    6f94:	4648      	mov	r0, r9
    6f96:	f7ff ff53 	bl	6e40 <__malloc_unlock>
    6f9a:	4630      	mov	r0, r6
    6f9c:	b003      	add	sp, #12
    6f9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6fa2:	f021 0103 	bic.w	r1, r1, #3
    6fa6:	4421      	add	r1, r4
    6fa8:	4291      	cmp	r1, r2
    6faa:	db21      	blt.n	6ff0 <_realloc_r+0x19c>
    6fac:	68c3      	ldr	r3, [r0, #12]
    6fae:	6882      	ldr	r2, [r0, #8]
    6fb0:	460c      	mov	r4, r1
    6fb2:	60d3      	str	r3, [r2, #12]
    6fb4:	609a      	str	r2, [r3, #8]
    6fb6:	e7de      	b.n	6f76 <_realloc_r+0x122>
    6fb8:	f8d8 2004 	ldr.w	r2, [r8, #4]
    6fbc:	eb08 0105 	add.w	r1, r8, r5
    6fc0:	f002 0201 	and.w	r2, r2, #1
    6fc4:	4315      	orrs	r5, r2
    6fc6:	f043 0201 	orr.w	r2, r3, #1
    6fca:	440b      	add	r3, r1
    6fcc:	f8c8 5004 	str.w	r5, [r8, #4]
    6fd0:	604a      	str	r2, [r1, #4]
    6fd2:	685a      	ldr	r2, [r3, #4]
    6fd4:	f042 0201 	orr.w	r2, r2, #1
    6fd8:	3108      	adds	r1, #8
    6fda:	605a      	str	r2, [r3, #4]
    6fdc:	4648      	mov	r0, r9
    6fde:	f000 fd53 	bl	7a88 <_free_r>
    6fe2:	e7d7      	b.n	6f94 <_realloc_r+0x140>
    6fe4:	4611      	mov	r1, r2
    6fe6:	b003      	add	sp, #12
    6fe8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6fec:	f7ff bb0c 	b.w	6608 <_malloc_r>
    6ff0:	f01e 0f01 	tst.w	lr, #1
    6ff4:	f47f af5a 	bne.w	6eac <_realloc_r+0x58>
    6ff8:	f856 3c08 	ldr.w	r3, [r6, #-8]
    6ffc:	ebc3 0a08 	rsb	sl, r3, r8
    7000:	f8da 3004 	ldr.w	r3, [sl, #4]
    7004:	f023 0c03 	bic.w	ip, r3, #3
    7008:	eb01 0e0c 	add.w	lr, r1, ip
    700c:	4596      	cmp	lr, r2
    700e:	db8b      	blt.n	6f28 <_realloc_r+0xd4>
    7010:	68c3      	ldr	r3, [r0, #12]
    7012:	6882      	ldr	r2, [r0, #8]
    7014:	4657      	mov	r7, sl
    7016:	60d3      	str	r3, [r2, #12]
    7018:	609a      	str	r2, [r3, #8]
    701a:	f857 1f08 	ldr.w	r1, [r7, #8]!
    701e:	f8da 300c 	ldr.w	r3, [sl, #12]
    7022:	60cb      	str	r3, [r1, #12]
    7024:	1f22      	subs	r2, r4, #4
    7026:	2a24      	cmp	r2, #36	; 0x24
    7028:	6099      	str	r1, [r3, #8]
    702a:	f200 8099 	bhi.w	7160 <_realloc_r+0x30c>
    702e:	2a13      	cmp	r2, #19
    7030:	d962      	bls.n	70f8 <_realloc_r+0x2a4>
    7032:	6833      	ldr	r3, [r6, #0]
    7034:	f8ca 3008 	str.w	r3, [sl, #8]
    7038:	6873      	ldr	r3, [r6, #4]
    703a:	f8ca 300c 	str.w	r3, [sl, #12]
    703e:	2a1b      	cmp	r2, #27
    7040:	f200 80a0 	bhi.w	7184 <_realloc_r+0x330>
    7044:	3608      	adds	r6, #8
    7046:	f10a 0310 	add.w	r3, sl, #16
    704a:	e056      	b.n	70fa <_realloc_r+0x2a6>
    704c:	f021 0b03 	bic.w	fp, r1, #3
    7050:	44a3      	add	fp, r4
    7052:	f105 0010 	add.w	r0, r5, #16
    7056:	4583      	cmp	fp, r0
    7058:	da59      	bge.n	710e <_realloc_r+0x2ba>
    705a:	f01e 0f01 	tst.w	lr, #1
    705e:	f47f af25 	bne.w	6eac <_realloc_r+0x58>
    7062:	f856 1c08 	ldr.w	r1, [r6, #-8]
    7066:	ebc1 0a08 	rsb	sl, r1, r8
    706a:	f8da 1004 	ldr.w	r1, [sl, #4]
    706e:	f021 0c03 	bic.w	ip, r1, #3
    7072:	44e3      	add	fp, ip
    7074:	4558      	cmp	r0, fp
    7076:	f73f af57 	bgt.w	6f28 <_realloc_r+0xd4>
    707a:	4657      	mov	r7, sl
    707c:	f8da 100c 	ldr.w	r1, [sl, #12]
    7080:	f857 0f08 	ldr.w	r0, [r7, #8]!
    7084:	1f22      	subs	r2, r4, #4
    7086:	2a24      	cmp	r2, #36	; 0x24
    7088:	60c1      	str	r1, [r0, #12]
    708a:	6088      	str	r0, [r1, #8]
    708c:	f200 80b4 	bhi.w	71f8 <_realloc_r+0x3a4>
    7090:	2a13      	cmp	r2, #19
    7092:	f240 80a5 	bls.w	71e0 <_realloc_r+0x38c>
    7096:	6831      	ldr	r1, [r6, #0]
    7098:	f8ca 1008 	str.w	r1, [sl, #8]
    709c:	6871      	ldr	r1, [r6, #4]
    709e:	f8ca 100c 	str.w	r1, [sl, #12]
    70a2:	2a1b      	cmp	r2, #27
    70a4:	f200 80af 	bhi.w	7206 <_realloc_r+0x3b2>
    70a8:	3608      	adds	r6, #8
    70aa:	f10a 0210 	add.w	r2, sl, #16
    70ae:	6831      	ldr	r1, [r6, #0]
    70b0:	6011      	str	r1, [r2, #0]
    70b2:	6871      	ldr	r1, [r6, #4]
    70b4:	6051      	str	r1, [r2, #4]
    70b6:	68b1      	ldr	r1, [r6, #8]
    70b8:	6091      	str	r1, [r2, #8]
    70ba:	eb0a 0105 	add.w	r1, sl, r5
    70be:	ebc5 020b 	rsb	r2, r5, fp
    70c2:	f042 0201 	orr.w	r2, r2, #1
    70c6:	6099      	str	r1, [r3, #8]
    70c8:	604a      	str	r2, [r1, #4]
    70ca:	f8da 3004 	ldr.w	r3, [sl, #4]
    70ce:	f003 0301 	and.w	r3, r3, #1
    70d2:	431d      	orrs	r5, r3
    70d4:	4648      	mov	r0, r9
    70d6:	f8ca 5004 	str.w	r5, [sl, #4]
    70da:	f7ff feb1 	bl	6e40 <__malloc_unlock>
    70de:	4638      	mov	r0, r7
    70e0:	e75c      	b.n	6f9c <_realloc_r+0x148>
    70e2:	6833      	ldr	r3, [r6, #0]
    70e4:	6003      	str	r3, [r0, #0]
    70e6:	6873      	ldr	r3, [r6, #4]
    70e8:	6043      	str	r3, [r0, #4]
    70ea:	2a1b      	cmp	r2, #27
    70ec:	d827      	bhi.n	713e <_realloc_r+0x2ea>
    70ee:	f100 0308 	add.w	r3, r0, #8
    70f2:	f106 0208 	add.w	r2, r6, #8
    70f6:	e6f2      	b.n	6ede <_realloc_r+0x8a>
    70f8:	463b      	mov	r3, r7
    70fa:	6832      	ldr	r2, [r6, #0]
    70fc:	601a      	str	r2, [r3, #0]
    70fe:	6872      	ldr	r2, [r6, #4]
    7100:	605a      	str	r2, [r3, #4]
    7102:	68b2      	ldr	r2, [r6, #8]
    7104:	609a      	str	r2, [r3, #8]
    7106:	463e      	mov	r6, r7
    7108:	4674      	mov	r4, lr
    710a:	46d0      	mov	r8, sl
    710c:	e733      	b.n	6f76 <_realloc_r+0x122>
    710e:	eb08 0105 	add.w	r1, r8, r5
    7112:	ebc5 0b0b 	rsb	fp, r5, fp
    7116:	f04b 0201 	orr.w	r2, fp, #1
    711a:	6099      	str	r1, [r3, #8]
    711c:	604a      	str	r2, [r1, #4]
    711e:	f856 3c04 	ldr.w	r3, [r6, #-4]
    7122:	f003 0301 	and.w	r3, r3, #1
    7126:	431d      	orrs	r5, r3
    7128:	4648      	mov	r0, r9
    712a:	f846 5c04 	str.w	r5, [r6, #-4]
    712e:	f7ff fe87 	bl	6e40 <__malloc_unlock>
    7132:	4630      	mov	r0, r6
    7134:	e732      	b.n	6f9c <_realloc_r+0x148>
    7136:	4631      	mov	r1, r6
    7138:	f7ff fdce 	bl	6cd8 <memmove>
    713c:	e6d5      	b.n	6eea <_realloc_r+0x96>
    713e:	68b3      	ldr	r3, [r6, #8]
    7140:	6083      	str	r3, [r0, #8]
    7142:	68f3      	ldr	r3, [r6, #12]
    7144:	60c3      	str	r3, [r0, #12]
    7146:	2a24      	cmp	r2, #36	; 0x24
    7148:	d028      	beq.n	719c <_realloc_r+0x348>
    714a:	f100 0310 	add.w	r3, r0, #16
    714e:	f106 0210 	add.w	r2, r6, #16
    7152:	e6c4      	b.n	6ede <_realloc_r+0x8a>
    7154:	f850 3c04 	ldr.w	r3, [r0, #-4]
    7158:	f023 0303 	bic.w	r3, r3, #3
    715c:	441c      	add	r4, r3
    715e:	e70a      	b.n	6f76 <_realloc_r+0x122>
    7160:	4631      	mov	r1, r6
    7162:	4638      	mov	r0, r7
    7164:	4674      	mov	r4, lr
    7166:	46d0      	mov	r8, sl
    7168:	f7ff fdb6 	bl	6cd8 <memmove>
    716c:	463e      	mov	r6, r7
    716e:	e702      	b.n	6f76 <_realloc_r+0x122>
    7170:	463a      	mov	r2, r7
    7172:	e6f7      	b.n	6f64 <_realloc_r+0x110>
    7174:	4631      	mov	r1, r6
    7176:	4638      	mov	r0, r7
    7178:	461c      	mov	r4, r3
    717a:	46d0      	mov	r8, sl
    717c:	f7ff fdac 	bl	6cd8 <memmove>
    7180:	463e      	mov	r6, r7
    7182:	e6f8      	b.n	6f76 <_realloc_r+0x122>
    7184:	68b3      	ldr	r3, [r6, #8]
    7186:	f8ca 3010 	str.w	r3, [sl, #16]
    718a:	68f3      	ldr	r3, [r6, #12]
    718c:	f8ca 3014 	str.w	r3, [sl, #20]
    7190:	2a24      	cmp	r2, #36	; 0x24
    7192:	d01b      	beq.n	71cc <_realloc_r+0x378>
    7194:	3610      	adds	r6, #16
    7196:	f10a 0318 	add.w	r3, sl, #24
    719a:	e7ae      	b.n	70fa <_realloc_r+0x2a6>
    719c:	6933      	ldr	r3, [r6, #16]
    719e:	6103      	str	r3, [r0, #16]
    71a0:	6973      	ldr	r3, [r6, #20]
    71a2:	6143      	str	r3, [r0, #20]
    71a4:	f106 0218 	add.w	r2, r6, #24
    71a8:	f100 0318 	add.w	r3, r0, #24
    71ac:	e697      	b.n	6ede <_realloc_r+0x8a>
    71ae:	bf00      	nop
    71b0:	20001ae0 	.word	0x20001ae0
    71b4:	68b1      	ldr	r1, [r6, #8]
    71b6:	f8ca 1010 	str.w	r1, [sl, #16]
    71ba:	68f1      	ldr	r1, [r6, #12]
    71bc:	f8ca 1014 	str.w	r1, [sl, #20]
    71c0:	2a24      	cmp	r2, #36	; 0x24
    71c2:	d00f      	beq.n	71e4 <_realloc_r+0x390>
    71c4:	3610      	adds	r6, #16
    71c6:	f10a 0218 	add.w	r2, sl, #24
    71ca:	e6cb      	b.n	6f64 <_realloc_r+0x110>
    71cc:	6933      	ldr	r3, [r6, #16]
    71ce:	f8ca 3018 	str.w	r3, [sl, #24]
    71d2:	6973      	ldr	r3, [r6, #20]
    71d4:	f8ca 301c 	str.w	r3, [sl, #28]
    71d8:	3618      	adds	r6, #24
    71da:	f10a 0320 	add.w	r3, sl, #32
    71de:	e78c      	b.n	70fa <_realloc_r+0x2a6>
    71e0:	463a      	mov	r2, r7
    71e2:	e764      	b.n	70ae <_realloc_r+0x25a>
    71e4:	6932      	ldr	r2, [r6, #16]
    71e6:	f8ca 2018 	str.w	r2, [sl, #24]
    71ea:	6972      	ldr	r2, [r6, #20]
    71ec:	f8ca 201c 	str.w	r2, [sl, #28]
    71f0:	3618      	adds	r6, #24
    71f2:	f10a 0220 	add.w	r2, sl, #32
    71f6:	e6b5      	b.n	6f64 <_realloc_r+0x110>
    71f8:	4631      	mov	r1, r6
    71fa:	4638      	mov	r0, r7
    71fc:	9301      	str	r3, [sp, #4]
    71fe:	f7ff fd6b 	bl	6cd8 <memmove>
    7202:	9b01      	ldr	r3, [sp, #4]
    7204:	e759      	b.n	70ba <_realloc_r+0x266>
    7206:	68b1      	ldr	r1, [r6, #8]
    7208:	f8ca 1010 	str.w	r1, [sl, #16]
    720c:	68f1      	ldr	r1, [r6, #12]
    720e:	f8ca 1014 	str.w	r1, [sl, #20]
    7212:	2a24      	cmp	r2, #36	; 0x24
    7214:	d003      	beq.n	721e <_realloc_r+0x3ca>
    7216:	3610      	adds	r6, #16
    7218:	f10a 0218 	add.w	r2, sl, #24
    721c:	e747      	b.n	70ae <_realloc_r+0x25a>
    721e:	6932      	ldr	r2, [r6, #16]
    7220:	f8ca 2018 	str.w	r2, [sl, #24]
    7224:	6972      	ldr	r2, [r6, #20]
    7226:	f8ca 201c 	str.w	r2, [sl, #28]
    722a:	3618      	adds	r6, #24
    722c:	f10a 0220 	add.w	r2, sl, #32
    7230:	e73d      	b.n	70ae <_realloc_r+0x25a>
    7232:	bf00      	nop

00007234 <_sbrk_r>:
    7234:	b538      	push	{r3, r4, r5, lr}
    7236:	4c07      	ldr	r4, [pc, #28]	; (7254 <_sbrk_r+0x20>)
    7238:	2300      	movs	r3, #0
    723a:	4605      	mov	r5, r0
    723c:	4608      	mov	r0, r1
    723e:	6023      	str	r3, [r4, #0]
    7240:	f7fa fd5c 	bl	1cfc <_sbrk>
    7244:	1c43      	adds	r3, r0, #1
    7246:	d000      	beq.n	724a <_sbrk_r+0x16>
    7248:	bd38      	pop	{r3, r4, r5, pc}
    724a:	6823      	ldr	r3, [r4, #0]
    724c:	2b00      	cmp	r3, #0
    724e:	d0fb      	beq.n	7248 <_sbrk_r+0x14>
    7250:	602b      	str	r3, [r5, #0]
    7252:	bd38      	pop	{r3, r4, r5, pc}
    7254:	200027b4 	.word	0x200027b4
	...
    7260:	eba2 0003 	sub.w	r0, r2, r3
    7264:	4770      	bx	lr
    7266:	bf00      	nop

00007268 <strcmp>:
    7268:	7802      	ldrb	r2, [r0, #0]
    726a:	780b      	ldrb	r3, [r1, #0]
    726c:	2a01      	cmp	r2, #1
    726e:	bf28      	it	cs
    7270:	429a      	cmpcs	r2, r3
    7272:	d1f5      	bne.n	7260 <_sbrk_r+0x2c>
    7274:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    7278:	ea40 0401 	orr.w	r4, r0, r1
    727c:	e9cd 6702 	strd	r6, r7, [sp, #8]
    7280:	f06f 0c00 	mvn.w	ip, #0
    7284:	ea4f 7244 	mov.w	r2, r4, lsl #29
    7288:	b312      	cbz	r2, 72d0 <strcmp+0x68>
    728a:	ea80 0401 	eor.w	r4, r0, r1
    728e:	f014 0f07 	tst.w	r4, #7
    7292:	d16a      	bne.n	736a <strcmp+0x102>
    7294:	f000 0407 	and.w	r4, r0, #7
    7298:	f020 0007 	bic.w	r0, r0, #7
    729c:	f004 0503 	and.w	r5, r4, #3
    72a0:	f021 0107 	bic.w	r1, r1, #7
    72a4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    72a8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    72ac:	f014 0f04 	tst.w	r4, #4
    72b0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    72b4:	fa0c f405 	lsl.w	r4, ip, r5
    72b8:	ea62 0204 	orn	r2, r2, r4
    72bc:	ea66 0604 	orn	r6, r6, r4
    72c0:	d00a      	beq.n	72d8 <strcmp+0x70>
    72c2:	ea63 0304 	orn	r3, r3, r4
    72c6:	4662      	mov	r2, ip
    72c8:	ea67 0704 	orn	r7, r7, r4
    72cc:	4666      	mov	r6, ip
    72ce:	e003      	b.n	72d8 <strcmp+0x70>
    72d0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    72d4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    72d8:	fa82 f54c 	uadd8	r5, r2, ip
    72dc:	ea82 0406 	eor.w	r4, r2, r6
    72e0:	faa4 f48c 	sel	r4, r4, ip
    72e4:	bb6c      	cbnz	r4, 7342 <strcmp+0xda>
    72e6:	fa83 f54c 	uadd8	r5, r3, ip
    72ea:	ea83 0507 	eor.w	r5, r3, r7
    72ee:	faa5 f58c 	sel	r5, r5, ip
    72f2:	b995      	cbnz	r5, 731a <strcmp+0xb2>
    72f4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    72f8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    72fc:	fa82 f54c 	uadd8	r5, r2, ip
    7300:	ea82 0406 	eor.w	r4, r2, r6
    7304:	faa4 f48c 	sel	r4, r4, ip
    7308:	fa83 f54c 	uadd8	r5, r3, ip
    730c:	ea83 0507 	eor.w	r5, r3, r7
    7310:	faa5 f58c 	sel	r5, r5, ip
    7314:	4325      	orrs	r5, r4
    7316:	d0db      	beq.n	72d0 <strcmp+0x68>
    7318:	b99c      	cbnz	r4, 7342 <strcmp+0xda>
    731a:	ba2d      	rev	r5, r5
    731c:	fab5 f485 	clz	r4, r5
    7320:	f024 0407 	bic.w	r4, r4, #7
    7324:	fa27 f104 	lsr.w	r1, r7, r4
    7328:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    732c:	fa23 f304 	lsr.w	r3, r3, r4
    7330:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    7334:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    7338:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    733c:	eba0 0001 	sub.w	r0, r0, r1
    7340:	4770      	bx	lr
    7342:	ba24      	rev	r4, r4
    7344:	fab4 f484 	clz	r4, r4
    7348:	f024 0407 	bic.w	r4, r4, #7
    734c:	fa26 f104 	lsr.w	r1, r6, r4
    7350:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    7354:	fa22 f204 	lsr.w	r2, r2, r4
    7358:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    735c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    7360:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    7364:	eba0 0001 	sub.w	r0, r0, r1
    7368:	4770      	bx	lr
    736a:	f014 0f03 	tst.w	r4, #3
    736e:	d13c      	bne.n	73ea <strcmp+0x182>
    7370:	f010 0403 	ands.w	r4, r0, #3
    7374:	d128      	bne.n	73c8 <strcmp+0x160>
    7376:	f850 2b08 	ldr.w	r2, [r0], #8
    737a:	f851 3b08 	ldr.w	r3, [r1], #8
    737e:	fa82 f54c 	uadd8	r5, r2, ip
    7382:	ea82 0503 	eor.w	r5, r2, r3
    7386:	faa5 f58c 	sel	r5, r5, ip
    738a:	b95d      	cbnz	r5, 73a4 <strcmp+0x13c>
    738c:	f850 2c04 	ldr.w	r2, [r0, #-4]
    7390:	f851 3c04 	ldr.w	r3, [r1, #-4]
    7394:	fa82 f54c 	uadd8	r5, r2, ip
    7398:	ea82 0503 	eor.w	r5, r2, r3
    739c:	faa5 f58c 	sel	r5, r5, ip
    73a0:	2d00      	cmp	r5, #0
    73a2:	d0e8      	beq.n	7376 <strcmp+0x10e>
    73a4:	ba2d      	rev	r5, r5
    73a6:	fab5 f485 	clz	r4, r5
    73aa:	f024 0407 	bic.w	r4, r4, #7
    73ae:	fa23 f104 	lsr.w	r1, r3, r4
    73b2:	fa22 f204 	lsr.w	r2, r2, r4
    73b6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    73ba:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    73be:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    73c2:	eba0 0001 	sub.w	r0, r0, r1
    73c6:	4770      	bx	lr
    73c8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    73cc:	f020 0003 	bic.w	r0, r0, #3
    73d0:	f850 2b08 	ldr.w	r2, [r0], #8
    73d4:	f021 0103 	bic.w	r1, r1, #3
    73d8:	f851 3b08 	ldr.w	r3, [r1], #8
    73dc:	fa0c f404 	lsl.w	r4, ip, r4
    73e0:	ea62 0204 	orn	r2, r2, r4
    73e4:	ea63 0304 	orn	r3, r3, r4
    73e8:	e7c9      	b.n	737e <strcmp+0x116>
    73ea:	f010 0403 	ands.w	r4, r0, #3
    73ee:	d01a      	beq.n	7426 <strcmp+0x1be>
    73f0:	eba1 0104 	sub.w	r1, r1, r4
    73f4:	f020 0003 	bic.w	r0, r0, #3
    73f8:	07e4      	lsls	r4, r4, #31
    73fa:	f850 2b04 	ldr.w	r2, [r0], #4
    73fe:	d006      	beq.n	740e <strcmp+0x1a6>
    7400:	d20f      	bcs.n	7422 <strcmp+0x1ba>
    7402:	788b      	ldrb	r3, [r1, #2]
    7404:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    7408:	1ae4      	subs	r4, r4, r3
    740a:	d106      	bne.n	741a <strcmp+0x1b2>
    740c:	b12b      	cbz	r3, 741a <strcmp+0x1b2>
    740e:	78cb      	ldrb	r3, [r1, #3]
    7410:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    7414:	1ae4      	subs	r4, r4, r3
    7416:	d100      	bne.n	741a <strcmp+0x1b2>
    7418:	b91b      	cbnz	r3, 7422 <strcmp+0x1ba>
    741a:	4620      	mov	r0, r4
    741c:	f85d 4b10 	ldr.w	r4, [sp], #16
    7420:	4770      	bx	lr
    7422:	f101 0104 	add.w	r1, r1, #4
    7426:	f850 2b04 	ldr.w	r2, [r0], #4
    742a:	07cc      	lsls	r4, r1, #31
    742c:	f021 0103 	bic.w	r1, r1, #3
    7430:	f851 3b04 	ldr.w	r3, [r1], #4
    7434:	d848      	bhi.n	74c8 <strcmp+0x260>
    7436:	d224      	bcs.n	7482 <strcmp+0x21a>
    7438:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    743c:	fa82 f54c 	uadd8	r5, r2, ip
    7440:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    7444:	faa5 f58c 	sel	r5, r5, ip
    7448:	d10a      	bne.n	7460 <strcmp+0x1f8>
    744a:	b965      	cbnz	r5, 7466 <strcmp+0x1fe>
    744c:	f851 3b04 	ldr.w	r3, [r1], #4
    7450:	ea84 0402 	eor.w	r4, r4, r2
    7454:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    7458:	d10e      	bne.n	7478 <strcmp+0x210>
    745a:	f850 2b04 	ldr.w	r2, [r0], #4
    745e:	e7eb      	b.n	7438 <strcmp+0x1d0>
    7460:	ea4f 2313 	mov.w	r3, r3, lsr #8
    7464:	e055      	b.n	7512 <strcmp+0x2aa>
    7466:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    746a:	d14d      	bne.n	7508 <strcmp+0x2a0>
    746c:	7808      	ldrb	r0, [r1, #0]
    746e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    7472:	f1c0 0000 	rsb	r0, r0, #0
    7476:	4770      	bx	lr
    7478:	ea4f 6212 	mov.w	r2, r2, lsr #24
    747c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    7480:	e047      	b.n	7512 <strcmp+0x2aa>
    7482:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    7486:	fa82 f54c 	uadd8	r5, r2, ip
    748a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    748e:	faa5 f58c 	sel	r5, r5, ip
    7492:	d10a      	bne.n	74aa <strcmp+0x242>
    7494:	b965      	cbnz	r5, 74b0 <strcmp+0x248>
    7496:	f851 3b04 	ldr.w	r3, [r1], #4
    749a:	ea84 0402 	eor.w	r4, r4, r2
    749e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    74a2:	d10c      	bne.n	74be <strcmp+0x256>
    74a4:	f850 2b04 	ldr.w	r2, [r0], #4
    74a8:	e7eb      	b.n	7482 <strcmp+0x21a>
    74aa:	ea4f 4313 	mov.w	r3, r3, lsr #16
    74ae:	e030      	b.n	7512 <strcmp+0x2aa>
    74b0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    74b4:	d128      	bne.n	7508 <strcmp+0x2a0>
    74b6:	880b      	ldrh	r3, [r1, #0]
    74b8:	ea4f 4212 	mov.w	r2, r2, lsr #16
    74bc:	e029      	b.n	7512 <strcmp+0x2aa>
    74be:	ea4f 4212 	mov.w	r2, r2, lsr #16
    74c2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    74c6:	e024      	b.n	7512 <strcmp+0x2aa>
    74c8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    74cc:	fa82 f54c 	uadd8	r5, r2, ip
    74d0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    74d4:	faa5 f58c 	sel	r5, r5, ip
    74d8:	d10a      	bne.n	74f0 <strcmp+0x288>
    74da:	b965      	cbnz	r5, 74f6 <strcmp+0x28e>
    74dc:	f851 3b04 	ldr.w	r3, [r1], #4
    74e0:	ea84 0402 	eor.w	r4, r4, r2
    74e4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    74e8:	d109      	bne.n	74fe <strcmp+0x296>
    74ea:	f850 2b04 	ldr.w	r2, [r0], #4
    74ee:	e7eb      	b.n	74c8 <strcmp+0x260>
    74f0:	ea4f 6313 	mov.w	r3, r3, lsr #24
    74f4:	e00d      	b.n	7512 <strcmp+0x2aa>
    74f6:	f015 0fff 	tst.w	r5, #255	; 0xff
    74fa:	d105      	bne.n	7508 <strcmp+0x2a0>
    74fc:	680b      	ldr	r3, [r1, #0]
    74fe:	ea4f 2212 	mov.w	r2, r2, lsr #8
    7502:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    7506:	e004      	b.n	7512 <strcmp+0x2aa>
    7508:	f04f 0000 	mov.w	r0, #0
    750c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    7510:	4770      	bx	lr
    7512:	ba12      	rev	r2, r2
    7514:	ba1b      	rev	r3, r3
    7516:	fa82 f44c 	uadd8	r4, r2, ip
    751a:	ea82 0403 	eor.w	r4, r2, r3
    751e:	faa4 f58c 	sel	r5, r4, ip
    7522:	fab5 f485 	clz	r4, r5
    7526:	fa02 f204 	lsl.w	r2, r2, r4
    752a:	fa03 f304 	lsl.w	r3, r3, r4
    752e:	ea4f 6012 	mov.w	r0, r2, lsr #24
    7532:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    7536:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    753a:	4770      	bx	lr

0000753c <strcpy>:
    753c:	ea80 0201 	eor.w	r2, r0, r1
    7540:	4684      	mov	ip, r0
    7542:	f012 0f03 	tst.w	r2, #3
    7546:	d14f      	bne.n	75e8 <strcpy+0xac>
    7548:	f011 0f03 	tst.w	r1, #3
    754c:	d132      	bne.n	75b4 <strcpy+0x78>
    754e:	f84d 4d04 	str.w	r4, [sp, #-4]!
    7552:	f011 0f04 	tst.w	r1, #4
    7556:	f851 3b04 	ldr.w	r3, [r1], #4
    755a:	d00b      	beq.n	7574 <strcpy+0x38>
    755c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    7560:	439a      	bics	r2, r3
    7562:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    7566:	bf04      	itt	eq
    7568:	f84c 3b04 	streq.w	r3, [ip], #4
    756c:	f851 3b04 	ldreq.w	r3, [r1], #4
    7570:	d116      	bne.n	75a0 <strcpy+0x64>
    7572:	bf00      	nop
    7574:	f851 4b04 	ldr.w	r4, [r1], #4
    7578:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    757c:	439a      	bics	r2, r3
    757e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    7582:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    7586:	d10b      	bne.n	75a0 <strcpy+0x64>
    7588:	f84c 3b04 	str.w	r3, [ip], #4
    758c:	43a2      	bics	r2, r4
    758e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    7592:	bf04      	itt	eq
    7594:	f851 3b04 	ldreq.w	r3, [r1], #4
    7598:	f84c 4b04 	streq.w	r4, [ip], #4
    759c:	d0ea      	beq.n	7574 <strcpy+0x38>
    759e:	4623      	mov	r3, r4
    75a0:	f80c 3b01 	strb.w	r3, [ip], #1
    75a4:	f013 0fff 	tst.w	r3, #255	; 0xff
    75a8:	ea4f 2333 	mov.w	r3, r3, ror #8
    75ac:	d1f8      	bne.n	75a0 <strcpy+0x64>
    75ae:	f85d 4b04 	ldr.w	r4, [sp], #4
    75b2:	4770      	bx	lr
    75b4:	f011 0f01 	tst.w	r1, #1
    75b8:	d006      	beq.n	75c8 <strcpy+0x8c>
    75ba:	f811 2b01 	ldrb.w	r2, [r1], #1
    75be:	f80c 2b01 	strb.w	r2, [ip], #1
    75c2:	2a00      	cmp	r2, #0
    75c4:	bf08      	it	eq
    75c6:	4770      	bxeq	lr
    75c8:	f011 0f02 	tst.w	r1, #2
    75cc:	d0bf      	beq.n	754e <strcpy+0x12>
    75ce:	f831 2b02 	ldrh.w	r2, [r1], #2
    75d2:	f012 0fff 	tst.w	r2, #255	; 0xff
    75d6:	bf16      	itet	ne
    75d8:	f82c 2b02 	strhne.w	r2, [ip], #2
    75dc:	f88c 2000 	strbeq.w	r2, [ip]
    75e0:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    75e4:	d1b3      	bne.n	754e <strcpy+0x12>
    75e6:	4770      	bx	lr
    75e8:	f811 2b01 	ldrb.w	r2, [r1], #1
    75ec:	f80c 2b01 	strb.w	r2, [ip], #1
    75f0:	2a00      	cmp	r2, #0
    75f2:	d1f9      	bne.n	75e8 <strcpy+0xac>
    75f4:	4770      	bx	lr
    75f6:	bf00      	nop
	...

00007600 <strlen>:
    7600:	f890 f000 	pld	[r0]
    7604:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    7608:	f020 0107 	bic.w	r1, r0, #7
    760c:	f06f 0c00 	mvn.w	ip, #0
    7610:	f010 0407 	ands.w	r4, r0, #7
    7614:	f891 f020 	pld	[r1, #32]
    7618:	f040 8049 	bne.w	76ae <strlen+0xae>
    761c:	f04f 0400 	mov.w	r4, #0
    7620:	f06f 0007 	mvn.w	r0, #7
    7624:	e9d1 2300 	ldrd	r2, r3, [r1]
    7628:	f891 f040 	pld	[r1, #64]	; 0x40
    762c:	f100 0008 	add.w	r0, r0, #8
    7630:	fa82 f24c 	uadd8	r2, r2, ip
    7634:	faa4 f28c 	sel	r2, r4, ip
    7638:	fa83 f34c 	uadd8	r3, r3, ip
    763c:	faa2 f38c 	sel	r3, r2, ip
    7640:	bb4b      	cbnz	r3, 7696 <strlen+0x96>
    7642:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    7646:	fa82 f24c 	uadd8	r2, r2, ip
    764a:	f100 0008 	add.w	r0, r0, #8
    764e:	faa4 f28c 	sel	r2, r4, ip
    7652:	fa83 f34c 	uadd8	r3, r3, ip
    7656:	faa2 f38c 	sel	r3, r2, ip
    765a:	b9e3      	cbnz	r3, 7696 <strlen+0x96>
    765c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    7660:	fa82 f24c 	uadd8	r2, r2, ip
    7664:	f100 0008 	add.w	r0, r0, #8
    7668:	faa4 f28c 	sel	r2, r4, ip
    766c:	fa83 f34c 	uadd8	r3, r3, ip
    7670:	faa2 f38c 	sel	r3, r2, ip
    7674:	b97b      	cbnz	r3, 7696 <strlen+0x96>
    7676:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    767a:	f101 0120 	add.w	r1, r1, #32
    767e:	fa82 f24c 	uadd8	r2, r2, ip
    7682:	f100 0008 	add.w	r0, r0, #8
    7686:	faa4 f28c 	sel	r2, r4, ip
    768a:	fa83 f34c 	uadd8	r3, r3, ip
    768e:	faa2 f38c 	sel	r3, r2, ip
    7692:	2b00      	cmp	r3, #0
    7694:	d0c6      	beq.n	7624 <strlen+0x24>
    7696:	2a00      	cmp	r2, #0
    7698:	bf04      	itt	eq
    769a:	3004      	addeq	r0, #4
    769c:	461a      	moveq	r2, r3
    769e:	ba12      	rev	r2, r2
    76a0:	fab2 f282 	clz	r2, r2
    76a4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    76a8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    76ac:	4770      	bx	lr
    76ae:	e9d1 2300 	ldrd	r2, r3, [r1]
    76b2:	f004 0503 	and.w	r5, r4, #3
    76b6:	f1c4 0000 	rsb	r0, r4, #0
    76ba:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    76be:	f014 0f04 	tst.w	r4, #4
    76c2:	f891 f040 	pld	[r1, #64]	; 0x40
    76c6:	fa0c f505 	lsl.w	r5, ip, r5
    76ca:	ea62 0205 	orn	r2, r2, r5
    76ce:	bf1c      	itt	ne
    76d0:	ea63 0305 	ornne	r3, r3, r5
    76d4:	4662      	movne	r2, ip
    76d6:	f04f 0400 	mov.w	r4, #0
    76da:	e7a9      	b.n	7630 <strlen+0x30>

000076dc <strncpy>:
    76dc:	ea40 0301 	orr.w	r3, r0, r1
    76e0:	079b      	lsls	r3, r3, #30
    76e2:	b470      	push	{r4, r5, r6}
    76e4:	d12b      	bne.n	773e <strncpy+0x62>
    76e6:	2a03      	cmp	r2, #3
    76e8:	d929      	bls.n	773e <strncpy+0x62>
    76ea:	460c      	mov	r4, r1
    76ec:	4603      	mov	r3, r0
    76ee:	4621      	mov	r1, r4
    76f0:	f854 6b04 	ldr.w	r6, [r4], #4
    76f4:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
    76f8:	ea25 0506 	bic.w	r5, r5, r6
    76fc:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
    7700:	d106      	bne.n	7710 <strncpy+0x34>
    7702:	3a04      	subs	r2, #4
    7704:	2a03      	cmp	r2, #3
    7706:	f843 6b04 	str.w	r6, [r3], #4
    770a:	4621      	mov	r1, r4
    770c:	d8ef      	bhi.n	76ee <strncpy+0x12>
    770e:	b1a2      	cbz	r2, 773a <strncpy+0x5e>
    7710:	780c      	ldrb	r4, [r1, #0]
    7712:	701c      	strb	r4, [r3, #0]
    7714:	3a01      	subs	r2, #1
    7716:	3301      	adds	r3, #1
    7718:	3101      	adds	r1, #1
    771a:	b13c      	cbz	r4, 772c <strncpy+0x50>
    771c:	b16a      	cbz	r2, 773a <strncpy+0x5e>
    771e:	f811 4b01 	ldrb.w	r4, [r1], #1
    7722:	f803 4b01 	strb.w	r4, [r3], #1
    7726:	3a01      	subs	r2, #1
    7728:	2c00      	cmp	r4, #0
    772a:	d1f7      	bne.n	771c <strncpy+0x40>
    772c:	b12a      	cbz	r2, 773a <strncpy+0x5e>
    772e:	441a      	add	r2, r3
    7730:	2100      	movs	r1, #0
    7732:	f803 1b01 	strb.w	r1, [r3], #1
    7736:	429a      	cmp	r2, r3
    7738:	d1fb      	bne.n	7732 <strncpy+0x56>
    773a:	bc70      	pop	{r4, r5, r6}
    773c:	4770      	bx	lr
    773e:	4603      	mov	r3, r0
    7740:	e7e5      	b.n	770e <strncpy+0x32>
    7742:	bf00      	nop

00007744 <__utoa>:
    7744:	b5f0      	push	{r4, r5, r6, r7, lr}
    7746:	f8df e078 	ldr.w	lr, [pc, #120]	; 77c0 <__utoa+0x7c>
    774a:	4616      	mov	r6, r2
    774c:	4604      	mov	r4, r0
    774e:	460f      	mov	r7, r1
    7750:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    7754:	b08b      	sub	sp, #44	; 0x2c
    7756:	466d      	mov	r5, sp
    7758:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    775a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    775e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    7760:	e89e 0003 	ldmia.w	lr, {r0, r1}
    7764:	1eb3      	subs	r3, r6, #2
    7766:	f845 0b04 	str.w	r0, [r5], #4
    776a:	2b22      	cmp	r3, #34	; 0x22
    776c:	7029      	strb	r1, [r5, #0]
    776e:	d822      	bhi.n	77b6 <__utoa+0x72>
    7770:	1e7d      	subs	r5, r7, #1
    7772:	4628      	mov	r0, r5
    7774:	2200      	movs	r2, #0
    7776:	e000      	b.n	777a <__utoa+0x36>
    7778:	461a      	mov	r2, r3
    777a:	fbb4 f1f6 	udiv	r1, r4, r6
    777e:	ab0a      	add	r3, sp, #40	; 0x28
    7780:	fb06 4411 	mls	r4, r6, r1, r4
    7784:	4423      	add	r3, r4
    7786:	460c      	mov	r4, r1
    7788:	f813 3c28 	ldrb.w	r3, [r3, #-40]
    778c:	f800 3f01 	strb.w	r3, [r0, #1]!
    7790:	1c53      	adds	r3, r2, #1
    7792:	2900      	cmp	r1, #0
    7794:	d1f0      	bne.n	7778 <__utoa+0x34>
    7796:	54f9      	strb	r1, [r7, r3]
    7798:	18bb      	adds	r3, r7, r2
    779a:	b14a      	cbz	r2, 77b0 <__utoa+0x6c>
    779c:	7819      	ldrb	r1, [r3, #0]
    779e:	f815 0f01 	ldrb.w	r0, [r5, #1]!
    77a2:	7029      	strb	r1, [r5, #0]
    77a4:	3401      	adds	r4, #1
    77a6:	1b11      	subs	r1, r2, r4
    77a8:	428c      	cmp	r4, r1
    77aa:	f803 0901 	strb.w	r0, [r3], #-1
    77ae:	dbf5      	blt.n	779c <__utoa+0x58>
    77b0:	4638      	mov	r0, r7
    77b2:	b00b      	add	sp, #44	; 0x2c
    77b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    77b6:	2000      	movs	r0, #0
    77b8:	7038      	strb	r0, [r7, #0]
    77ba:	b00b      	add	sp, #44	; 0x2c
    77bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    77be:	bf00      	nop
    77c0:	20000f2c 	.word	0x20000f2c

000077c4 <_vdprintf_r>:
    77c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    77c6:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
    77ca:	ad04      	add	r5, sp, #16
    77cc:	9300      	str	r3, [sp, #0]
    77ce:	460f      	mov	r7, r1
    77d0:	4613      	mov	r3, r2
    77d2:	f44f 7400 	mov.w	r4, #512	; 0x200
    77d6:	aa03      	add	r2, sp, #12
    77d8:	4629      	mov	r1, r5
    77da:	9403      	str	r4, [sp, #12]
    77dc:	4606      	mov	r6, r0
    77de:	f000 fdb1 	bl	8344 <_vasnprintf_r>
    77e2:	b188      	cbz	r0, 7808 <_vdprintf_r+0x44>
    77e4:	4604      	mov	r4, r0
    77e6:	4602      	mov	r2, r0
    77e8:	4639      	mov	r1, r7
    77ea:	9b03      	ldr	r3, [sp, #12]
    77ec:	4630      	mov	r0, r6
    77ee:	f000 f829 	bl	7844 <_write_r>
    77f2:	42ac      	cmp	r4, r5
    77f4:	9003      	str	r0, [sp, #12]
    77f6:	d004      	beq.n	7802 <_vdprintf_r+0x3e>
    77f8:	4630      	mov	r0, r6
    77fa:	4621      	mov	r1, r4
    77fc:	f000 f944 	bl	7a88 <_free_r>
    7800:	9803      	ldr	r0, [sp, #12]
    7802:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
    7806:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7808:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    780c:	e7f9      	b.n	7802 <_vdprintf_r+0x3e>
    780e:	bf00      	nop

00007810 <vdprintf>:
    7810:	b410      	push	{r4}
    7812:	4c04      	ldr	r4, [pc, #16]	; (7824 <vdprintf+0x14>)
    7814:	4613      	mov	r3, r2
    7816:	460a      	mov	r2, r1
    7818:	4601      	mov	r1, r0
    781a:	6820      	ldr	r0, [r4, #0]
    781c:	f85d 4b04 	ldr.w	r4, [sp], #4
    7820:	f7ff bfd0 	b.w	77c4 <_vdprintf_r>
    7824:	20001ef0 	.word	0x20001ef0

00007828 <__ascii_wctomb>:
    7828:	b121      	cbz	r1, 7834 <__ascii_wctomb+0xc>
    782a:	2aff      	cmp	r2, #255	; 0xff
    782c:	d804      	bhi.n	7838 <__ascii_wctomb+0x10>
    782e:	700a      	strb	r2, [r1, #0]
    7830:	2001      	movs	r0, #1
    7832:	4770      	bx	lr
    7834:	4608      	mov	r0, r1
    7836:	4770      	bx	lr
    7838:	238a      	movs	r3, #138	; 0x8a
    783a:	6003      	str	r3, [r0, #0]
    783c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7840:	4770      	bx	lr
    7842:	bf00      	nop

00007844 <_write_r>:
    7844:	b570      	push	{r4, r5, r6, lr}
    7846:	460d      	mov	r5, r1
    7848:	4c08      	ldr	r4, [pc, #32]	; (786c <_write_r+0x28>)
    784a:	4611      	mov	r1, r2
    784c:	4606      	mov	r6, r0
    784e:	461a      	mov	r2, r3
    7850:	4628      	mov	r0, r5
    7852:	2300      	movs	r3, #0
    7854:	6023      	str	r3, [r4, #0]
    7856:	f7fb fab1 	bl	2dbc <_write>
    785a:	1c43      	adds	r3, r0, #1
    785c:	d000      	beq.n	7860 <_write_r+0x1c>
    785e:	bd70      	pop	{r4, r5, r6, pc}
    7860:	6823      	ldr	r3, [r4, #0]
    7862:	2b00      	cmp	r3, #0
    7864:	d0fb      	beq.n	785e <_write_r+0x1a>
    7866:	6033      	str	r3, [r6, #0]
    7868:	bd70      	pop	{r4, r5, r6, pc}
    786a:	bf00      	nop
    786c:	200027b4 	.word	0x200027b4

00007870 <__register_exitproc>:
    7870:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7874:	4c25      	ldr	r4, [pc, #148]	; (790c <__register_exitproc+0x9c>)
    7876:	6825      	ldr	r5, [r4, #0]
    7878:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    787c:	4606      	mov	r6, r0
    787e:	4688      	mov	r8, r1
    7880:	4692      	mov	sl, r2
    7882:	4699      	mov	r9, r3
    7884:	b3c4      	cbz	r4, 78f8 <__register_exitproc+0x88>
    7886:	6860      	ldr	r0, [r4, #4]
    7888:	281f      	cmp	r0, #31
    788a:	dc17      	bgt.n	78bc <__register_exitproc+0x4c>
    788c:	1c43      	adds	r3, r0, #1
    788e:	b176      	cbz	r6, 78ae <__register_exitproc+0x3e>
    7890:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    7894:	2201      	movs	r2, #1
    7896:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    789a:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    789e:	4082      	lsls	r2, r0
    78a0:	4311      	orrs	r1, r2
    78a2:	2e02      	cmp	r6, #2
    78a4:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    78a8:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    78ac:	d01e      	beq.n	78ec <__register_exitproc+0x7c>
    78ae:	3002      	adds	r0, #2
    78b0:	6063      	str	r3, [r4, #4]
    78b2:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    78b6:	2000      	movs	r0, #0
    78b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    78bc:	4b14      	ldr	r3, [pc, #80]	; (7910 <__register_exitproc+0xa0>)
    78be:	b303      	cbz	r3, 7902 <__register_exitproc+0x92>
    78c0:	f44f 70c8 	mov.w	r0, #400	; 0x190
    78c4:	f7fe fe90 	bl	65e8 <malloc>
    78c8:	4604      	mov	r4, r0
    78ca:	b1d0      	cbz	r0, 7902 <__register_exitproc+0x92>
    78cc:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    78d0:	2700      	movs	r7, #0
    78d2:	e880 0088 	stmia.w	r0, {r3, r7}
    78d6:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    78da:	4638      	mov	r0, r7
    78dc:	2301      	movs	r3, #1
    78de:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    78e2:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    78e6:	2e00      	cmp	r6, #0
    78e8:	d0e1      	beq.n	78ae <__register_exitproc+0x3e>
    78ea:	e7d1      	b.n	7890 <__register_exitproc+0x20>
    78ec:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    78f0:	430a      	orrs	r2, r1
    78f2:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    78f6:	e7da      	b.n	78ae <__register_exitproc+0x3e>
    78f8:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    78fc:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    7900:	e7c1      	b.n	7886 <__register_exitproc+0x16>
    7902:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7906:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    790a:	bf00      	nop
    790c:	200006c8 	.word	0x200006c8
    7910:	000065e9 	.word	0x000065e9

00007914 <__call_exitprocs>:
    7914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7918:	4b32      	ldr	r3, [pc, #200]	; (79e4 <__call_exitprocs+0xd0>)
    791a:	b085      	sub	sp, #20
    791c:	681b      	ldr	r3, [r3, #0]
    791e:	9302      	str	r3, [sp, #8]
    7920:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    7924:	9001      	str	r0, [sp, #4]
    7926:	460e      	mov	r6, r1
    7928:	9303      	str	r3, [sp, #12]
    792a:	9b02      	ldr	r3, [sp, #8]
    792c:	f8d3 7148 	ldr.w	r7, [r3, #328]	; 0x148
    7930:	b33f      	cbz	r7, 7982 <__call_exitprocs+0x6e>
    7932:	f8dd a00c 	ldr.w	sl, [sp, #12]
    7936:	f04f 0901 	mov.w	r9, #1
    793a:	46d3      	mov	fp, sl
    793c:	687c      	ldr	r4, [r7, #4]
    793e:	1e65      	subs	r5, r4, #1
    7940:	d40e      	bmi.n	7960 <__call_exitprocs+0x4c>
    7942:	3401      	adds	r4, #1
    7944:	eb07 0484 	add.w	r4, r7, r4, lsl #2
    7948:	f04f 0800 	mov.w	r8, #0
    794c:	b1e6      	cbz	r6, 7988 <__call_exitprocs+0x74>
    794e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    7952:	429e      	cmp	r6, r3
    7954:	d018      	beq.n	7988 <__call_exitprocs+0x74>
    7956:	3d01      	subs	r5, #1
    7958:	1c6b      	adds	r3, r5, #1
    795a:	f1a4 0404 	sub.w	r4, r4, #4
    795e:	d1f5      	bne.n	794c <__call_exitprocs+0x38>
    7960:	4b21      	ldr	r3, [pc, #132]	; (79e8 <__call_exitprocs+0xd4>)
    7962:	b173      	cbz	r3, 7982 <__call_exitprocs+0x6e>
    7964:	687b      	ldr	r3, [r7, #4]
    7966:	2b00      	cmp	r3, #0
    7968:	d136      	bne.n	79d8 <__call_exitprocs+0xc4>
    796a:	683b      	ldr	r3, [r7, #0]
    796c:	2b00      	cmp	r3, #0
    796e:	d034      	beq.n	79da <__call_exitprocs+0xc6>
    7970:	4638      	mov	r0, r7
    7972:	f8cb 3000 	str.w	r3, [fp]
    7976:	f7fe fe3f 	bl	65f8 <free>
    797a:	f8db 7000 	ldr.w	r7, [fp]
    797e:	2f00      	cmp	r7, #0
    7980:	d1dc      	bne.n	793c <__call_exitprocs+0x28>
    7982:	b005      	add	sp, #20
    7984:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7988:	687b      	ldr	r3, [r7, #4]
    798a:	6822      	ldr	r2, [r4, #0]
    798c:	3b01      	subs	r3, #1
    798e:	42ab      	cmp	r3, r5
    7990:	bf0c      	ite	eq
    7992:	607d      	streq	r5, [r7, #4]
    7994:	f8c4 8000 	strne.w	r8, [r4]
    7998:	2a00      	cmp	r2, #0
    799a:	d0dc      	beq.n	7956 <__call_exitprocs+0x42>
    799c:	f8d7 1188 	ldr.w	r1, [r7, #392]	; 0x188
    79a0:	f8d7 a004 	ldr.w	sl, [r7, #4]
    79a4:	fa09 f305 	lsl.w	r3, r9, r5
    79a8:	420b      	tst	r3, r1
    79aa:	d00f      	beq.n	79cc <__call_exitprocs+0xb8>
    79ac:	f8d7 118c 	ldr.w	r1, [r7, #396]	; 0x18c
    79b0:	420b      	tst	r3, r1
    79b2:	d10d      	bne.n	79d0 <__call_exitprocs+0xbc>
    79b4:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
    79b8:	9801      	ldr	r0, [sp, #4]
    79ba:	4790      	blx	r2
    79bc:	687b      	ldr	r3, [r7, #4]
    79be:	4553      	cmp	r3, sl
    79c0:	d1b3      	bne.n	792a <__call_exitprocs+0x16>
    79c2:	f8db 3000 	ldr.w	r3, [fp]
    79c6:	42bb      	cmp	r3, r7
    79c8:	d0c5      	beq.n	7956 <__call_exitprocs+0x42>
    79ca:	e7ae      	b.n	792a <__call_exitprocs+0x16>
    79cc:	4790      	blx	r2
    79ce:	e7f5      	b.n	79bc <__call_exitprocs+0xa8>
    79d0:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
    79d4:	4790      	blx	r2
    79d6:	e7f1      	b.n	79bc <__call_exitprocs+0xa8>
    79d8:	683b      	ldr	r3, [r7, #0]
    79da:	46bb      	mov	fp, r7
    79dc:	461f      	mov	r7, r3
    79de:	2f00      	cmp	r7, #0
    79e0:	d1ac      	bne.n	793c <__call_exitprocs+0x28>
    79e2:	e7ce      	b.n	7982 <__call_exitprocs+0x6e>
    79e4:	200006c8 	.word	0x200006c8
    79e8:	000065f9 	.word	0x000065f9

000079ec <_malloc_trim_r>:
    79ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    79ee:	4f23      	ldr	r7, [pc, #140]	; (7a7c <_malloc_trim_r+0x90>)
    79f0:	460c      	mov	r4, r1
    79f2:	4606      	mov	r6, r0
    79f4:	f7ff fa22 	bl	6e3c <__malloc_lock>
    79f8:	68bb      	ldr	r3, [r7, #8]
    79fa:	685d      	ldr	r5, [r3, #4]
    79fc:	f025 0503 	bic.w	r5, r5, #3
    7a00:	1b29      	subs	r1, r5, r4
    7a02:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    7a06:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    7a0a:	f021 010f 	bic.w	r1, r1, #15
    7a0e:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    7a12:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    7a16:	db07      	blt.n	7a28 <_malloc_trim_r+0x3c>
    7a18:	2100      	movs	r1, #0
    7a1a:	4630      	mov	r0, r6
    7a1c:	f7ff fc0a 	bl	7234 <_sbrk_r>
    7a20:	68bb      	ldr	r3, [r7, #8]
    7a22:	442b      	add	r3, r5
    7a24:	4298      	cmp	r0, r3
    7a26:	d004      	beq.n	7a32 <_malloc_trim_r+0x46>
    7a28:	4630      	mov	r0, r6
    7a2a:	f7ff fa09 	bl	6e40 <__malloc_unlock>
    7a2e:	2000      	movs	r0, #0
    7a30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7a32:	4261      	negs	r1, r4
    7a34:	4630      	mov	r0, r6
    7a36:	f7ff fbfd 	bl	7234 <_sbrk_r>
    7a3a:	3001      	adds	r0, #1
    7a3c:	d00d      	beq.n	7a5a <_malloc_trim_r+0x6e>
    7a3e:	4b10      	ldr	r3, [pc, #64]	; (7a80 <_malloc_trim_r+0x94>)
    7a40:	68ba      	ldr	r2, [r7, #8]
    7a42:	6819      	ldr	r1, [r3, #0]
    7a44:	1b2d      	subs	r5, r5, r4
    7a46:	f045 0501 	orr.w	r5, r5, #1
    7a4a:	4630      	mov	r0, r6
    7a4c:	1b09      	subs	r1, r1, r4
    7a4e:	6055      	str	r5, [r2, #4]
    7a50:	6019      	str	r1, [r3, #0]
    7a52:	f7ff f9f5 	bl	6e40 <__malloc_unlock>
    7a56:	2001      	movs	r0, #1
    7a58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7a5a:	2100      	movs	r1, #0
    7a5c:	4630      	mov	r0, r6
    7a5e:	f7ff fbe9 	bl	7234 <_sbrk_r>
    7a62:	68ba      	ldr	r2, [r7, #8]
    7a64:	1a83      	subs	r3, r0, r2
    7a66:	2b0f      	cmp	r3, #15
    7a68:	ddde      	ble.n	7a28 <_malloc_trim_r+0x3c>
    7a6a:	4c06      	ldr	r4, [pc, #24]	; (7a84 <_malloc_trim_r+0x98>)
    7a6c:	4904      	ldr	r1, [pc, #16]	; (7a80 <_malloc_trim_r+0x94>)
    7a6e:	6824      	ldr	r4, [r4, #0]
    7a70:	f043 0301 	orr.w	r3, r3, #1
    7a74:	1b00      	subs	r0, r0, r4
    7a76:	6053      	str	r3, [r2, #4]
    7a78:	6008      	str	r0, [r1, #0]
    7a7a:	e7d5      	b.n	7a28 <_malloc_trim_r+0x3c>
    7a7c:	20001ae0 	.word	0x20001ae0
    7a80:	200026b4 	.word	0x200026b4
    7a84:	20001ee8 	.word	0x20001ee8

00007a88 <_free_r>:
    7a88:	2900      	cmp	r1, #0
    7a8a:	d045      	beq.n	7b18 <_free_r+0x90>
    7a8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7a90:	460d      	mov	r5, r1
    7a92:	4680      	mov	r8, r0
    7a94:	f7ff f9d2 	bl	6e3c <__malloc_lock>
    7a98:	f855 7c04 	ldr.w	r7, [r5, #-4]
    7a9c:	496a      	ldr	r1, [pc, #424]	; (7c48 <_free_r+0x1c0>)
    7a9e:	f027 0301 	bic.w	r3, r7, #1
    7aa2:	f1a5 0408 	sub.w	r4, r5, #8
    7aa6:	18e2      	adds	r2, r4, r3
    7aa8:	688e      	ldr	r6, [r1, #8]
    7aaa:	6850      	ldr	r0, [r2, #4]
    7aac:	42b2      	cmp	r2, r6
    7aae:	f020 0003 	bic.w	r0, r0, #3
    7ab2:	d062      	beq.n	7b7a <_free_r+0xf2>
    7ab4:	07fe      	lsls	r6, r7, #31
    7ab6:	6050      	str	r0, [r2, #4]
    7ab8:	d40b      	bmi.n	7ad2 <_free_r+0x4a>
    7aba:	f855 7c08 	ldr.w	r7, [r5, #-8]
    7abe:	1be4      	subs	r4, r4, r7
    7ac0:	f101 0e08 	add.w	lr, r1, #8
    7ac4:	68a5      	ldr	r5, [r4, #8]
    7ac6:	4575      	cmp	r5, lr
    7ac8:	443b      	add	r3, r7
    7aca:	d06f      	beq.n	7bac <_free_r+0x124>
    7acc:	68e7      	ldr	r7, [r4, #12]
    7ace:	60ef      	str	r7, [r5, #12]
    7ad0:	60bd      	str	r5, [r7, #8]
    7ad2:	1815      	adds	r5, r2, r0
    7ad4:	686d      	ldr	r5, [r5, #4]
    7ad6:	07ed      	lsls	r5, r5, #31
    7ad8:	d542      	bpl.n	7b60 <_free_r+0xd8>
    7ada:	f043 0201 	orr.w	r2, r3, #1
    7ade:	6062      	str	r2, [r4, #4]
    7ae0:	50e3      	str	r3, [r4, r3]
    7ae2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    7ae6:	d218      	bcs.n	7b1a <_free_r+0x92>
    7ae8:	08db      	lsrs	r3, r3, #3
    7aea:	1c5a      	adds	r2, r3, #1
    7aec:	684d      	ldr	r5, [r1, #4]
    7aee:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    7af2:	60a7      	str	r7, [r4, #8]
    7af4:	2001      	movs	r0, #1
    7af6:	109b      	asrs	r3, r3, #2
    7af8:	fa00 f303 	lsl.w	r3, r0, r3
    7afc:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    7b00:	431d      	orrs	r5, r3
    7b02:	3808      	subs	r0, #8
    7b04:	60e0      	str	r0, [r4, #12]
    7b06:	604d      	str	r5, [r1, #4]
    7b08:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    7b0c:	60fc      	str	r4, [r7, #12]
    7b0e:	4640      	mov	r0, r8
    7b10:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7b14:	f7ff b994 	b.w	6e40 <__malloc_unlock>
    7b18:	4770      	bx	lr
    7b1a:	0a5a      	lsrs	r2, r3, #9
    7b1c:	2a04      	cmp	r2, #4
    7b1e:	d853      	bhi.n	7bc8 <_free_r+0x140>
    7b20:	099a      	lsrs	r2, r3, #6
    7b22:	f102 0739 	add.w	r7, r2, #57	; 0x39
    7b26:	007f      	lsls	r7, r7, #1
    7b28:	f102 0538 	add.w	r5, r2, #56	; 0x38
    7b2c:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    7b30:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    7b34:	4944      	ldr	r1, [pc, #272]	; (7c48 <_free_r+0x1c0>)
    7b36:	3808      	subs	r0, #8
    7b38:	4290      	cmp	r0, r2
    7b3a:	d04d      	beq.n	7bd8 <_free_r+0x150>
    7b3c:	6851      	ldr	r1, [r2, #4]
    7b3e:	f021 0103 	bic.w	r1, r1, #3
    7b42:	428b      	cmp	r3, r1
    7b44:	d202      	bcs.n	7b4c <_free_r+0xc4>
    7b46:	6892      	ldr	r2, [r2, #8]
    7b48:	4290      	cmp	r0, r2
    7b4a:	d1f7      	bne.n	7b3c <_free_r+0xb4>
    7b4c:	68d0      	ldr	r0, [r2, #12]
    7b4e:	60e0      	str	r0, [r4, #12]
    7b50:	60a2      	str	r2, [r4, #8]
    7b52:	6084      	str	r4, [r0, #8]
    7b54:	60d4      	str	r4, [r2, #12]
    7b56:	4640      	mov	r0, r8
    7b58:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7b5c:	f7ff b970 	b.w	6e40 <__malloc_unlock>
    7b60:	6895      	ldr	r5, [r2, #8]
    7b62:	4f3a      	ldr	r7, [pc, #232]	; (7c4c <_free_r+0x1c4>)
    7b64:	42bd      	cmp	r5, r7
    7b66:	4403      	add	r3, r0
    7b68:	d03f      	beq.n	7bea <_free_r+0x162>
    7b6a:	68d0      	ldr	r0, [r2, #12]
    7b6c:	60e8      	str	r0, [r5, #12]
    7b6e:	f043 0201 	orr.w	r2, r3, #1
    7b72:	6085      	str	r5, [r0, #8]
    7b74:	6062      	str	r2, [r4, #4]
    7b76:	50e3      	str	r3, [r4, r3]
    7b78:	e7b3      	b.n	7ae2 <_free_r+0x5a>
    7b7a:	07ff      	lsls	r7, r7, #31
    7b7c:	4403      	add	r3, r0
    7b7e:	d407      	bmi.n	7b90 <_free_r+0x108>
    7b80:	f855 2c08 	ldr.w	r2, [r5, #-8]
    7b84:	1aa4      	subs	r4, r4, r2
    7b86:	4413      	add	r3, r2
    7b88:	68a0      	ldr	r0, [r4, #8]
    7b8a:	68e2      	ldr	r2, [r4, #12]
    7b8c:	60c2      	str	r2, [r0, #12]
    7b8e:	6090      	str	r0, [r2, #8]
    7b90:	4a2f      	ldr	r2, [pc, #188]	; (7c50 <_free_r+0x1c8>)
    7b92:	6812      	ldr	r2, [r2, #0]
    7b94:	f043 0001 	orr.w	r0, r3, #1
    7b98:	4293      	cmp	r3, r2
    7b9a:	6060      	str	r0, [r4, #4]
    7b9c:	608c      	str	r4, [r1, #8]
    7b9e:	d3b6      	bcc.n	7b0e <_free_r+0x86>
    7ba0:	4b2c      	ldr	r3, [pc, #176]	; (7c54 <_free_r+0x1cc>)
    7ba2:	4640      	mov	r0, r8
    7ba4:	6819      	ldr	r1, [r3, #0]
    7ba6:	f7ff ff21 	bl	79ec <_malloc_trim_r>
    7baa:	e7b0      	b.n	7b0e <_free_r+0x86>
    7bac:	1811      	adds	r1, r2, r0
    7bae:	6849      	ldr	r1, [r1, #4]
    7bb0:	07c9      	lsls	r1, r1, #31
    7bb2:	d444      	bmi.n	7c3e <_free_r+0x1b6>
    7bb4:	6891      	ldr	r1, [r2, #8]
    7bb6:	68d2      	ldr	r2, [r2, #12]
    7bb8:	60ca      	str	r2, [r1, #12]
    7bba:	4403      	add	r3, r0
    7bbc:	f043 0001 	orr.w	r0, r3, #1
    7bc0:	6091      	str	r1, [r2, #8]
    7bc2:	6060      	str	r0, [r4, #4]
    7bc4:	50e3      	str	r3, [r4, r3]
    7bc6:	e7a2      	b.n	7b0e <_free_r+0x86>
    7bc8:	2a14      	cmp	r2, #20
    7bca:	d817      	bhi.n	7bfc <_free_r+0x174>
    7bcc:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    7bd0:	007f      	lsls	r7, r7, #1
    7bd2:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    7bd6:	e7a9      	b.n	7b2c <_free_r+0xa4>
    7bd8:	10aa      	asrs	r2, r5, #2
    7bda:	684b      	ldr	r3, [r1, #4]
    7bdc:	2501      	movs	r5, #1
    7bde:	fa05 f202 	lsl.w	r2, r5, r2
    7be2:	4313      	orrs	r3, r2
    7be4:	604b      	str	r3, [r1, #4]
    7be6:	4602      	mov	r2, r0
    7be8:	e7b1      	b.n	7b4e <_free_r+0xc6>
    7bea:	f043 0201 	orr.w	r2, r3, #1
    7bee:	614c      	str	r4, [r1, #20]
    7bf0:	610c      	str	r4, [r1, #16]
    7bf2:	60e5      	str	r5, [r4, #12]
    7bf4:	60a5      	str	r5, [r4, #8]
    7bf6:	6062      	str	r2, [r4, #4]
    7bf8:	50e3      	str	r3, [r4, r3]
    7bfa:	e788      	b.n	7b0e <_free_r+0x86>
    7bfc:	2a54      	cmp	r2, #84	; 0x54
    7bfe:	d806      	bhi.n	7c0e <_free_r+0x186>
    7c00:	0b1a      	lsrs	r2, r3, #12
    7c02:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    7c06:	007f      	lsls	r7, r7, #1
    7c08:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    7c0c:	e78e      	b.n	7b2c <_free_r+0xa4>
    7c0e:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    7c12:	d806      	bhi.n	7c22 <_free_r+0x19a>
    7c14:	0bda      	lsrs	r2, r3, #15
    7c16:	f102 0778 	add.w	r7, r2, #120	; 0x78
    7c1a:	007f      	lsls	r7, r7, #1
    7c1c:	f102 0577 	add.w	r5, r2, #119	; 0x77
    7c20:	e784      	b.n	7b2c <_free_r+0xa4>
    7c22:	f240 5054 	movw	r0, #1364	; 0x554
    7c26:	4282      	cmp	r2, r0
    7c28:	d806      	bhi.n	7c38 <_free_r+0x1b0>
    7c2a:	0c9a      	lsrs	r2, r3, #18
    7c2c:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    7c30:	007f      	lsls	r7, r7, #1
    7c32:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    7c36:	e779      	b.n	7b2c <_free_r+0xa4>
    7c38:	27fe      	movs	r7, #254	; 0xfe
    7c3a:	257e      	movs	r5, #126	; 0x7e
    7c3c:	e776      	b.n	7b2c <_free_r+0xa4>
    7c3e:	f043 0201 	orr.w	r2, r3, #1
    7c42:	6062      	str	r2, [r4, #4]
    7c44:	50e3      	str	r3, [r4, r3]
    7c46:	e762      	b.n	7b0e <_free_r+0x86>
    7c48:	20001ae0 	.word	0x20001ae0
    7c4c:	20001ae8 	.word	0x20001ae8
    7c50:	20001eec 	.word	0x20001eec
    7c54:	200026e4 	.word	0x200026e4

00007c58 <_localeconv_r>:
    7c58:	4a04      	ldr	r2, [pc, #16]	; (7c6c <_localeconv_r+0x14>)
    7c5a:	4b05      	ldr	r3, [pc, #20]	; (7c70 <_localeconv_r+0x18>)
    7c5c:	6812      	ldr	r2, [r2, #0]
    7c5e:	6b50      	ldr	r0, [r2, #52]	; 0x34
    7c60:	2800      	cmp	r0, #0
    7c62:	bf08      	it	eq
    7c64:	4618      	moveq	r0, r3
    7c66:	30f0      	adds	r0, #240	; 0xf0
    7c68:	4770      	bx	lr
    7c6a:	bf00      	nop
    7c6c:	20001ef0 	.word	0x20001ef0
    7c70:	20001974 	.word	0x20001974
	...

00007c80 <memchr>:
    7c80:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    7c84:	2a10      	cmp	r2, #16
    7c86:	db2b      	blt.n	7ce0 <memchr+0x60>
    7c88:	f010 0f07 	tst.w	r0, #7
    7c8c:	d008      	beq.n	7ca0 <memchr+0x20>
    7c8e:	f810 3b01 	ldrb.w	r3, [r0], #1
    7c92:	3a01      	subs	r2, #1
    7c94:	428b      	cmp	r3, r1
    7c96:	d02d      	beq.n	7cf4 <memchr+0x74>
    7c98:	f010 0f07 	tst.w	r0, #7
    7c9c:	b342      	cbz	r2, 7cf0 <memchr+0x70>
    7c9e:	d1f6      	bne.n	7c8e <memchr+0xe>
    7ca0:	b4f0      	push	{r4, r5, r6, r7}
    7ca2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    7ca6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    7caa:	f022 0407 	bic.w	r4, r2, #7
    7cae:	f07f 0700 	mvns.w	r7, #0
    7cb2:	2300      	movs	r3, #0
    7cb4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    7cb8:	3c08      	subs	r4, #8
    7cba:	ea85 0501 	eor.w	r5, r5, r1
    7cbe:	ea86 0601 	eor.w	r6, r6, r1
    7cc2:	fa85 f547 	uadd8	r5, r5, r7
    7cc6:	faa3 f587 	sel	r5, r3, r7
    7cca:	fa86 f647 	uadd8	r6, r6, r7
    7cce:	faa5 f687 	sel	r6, r5, r7
    7cd2:	b98e      	cbnz	r6, 7cf8 <memchr+0x78>
    7cd4:	d1ee      	bne.n	7cb4 <memchr+0x34>
    7cd6:	bcf0      	pop	{r4, r5, r6, r7}
    7cd8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    7cdc:	f002 0207 	and.w	r2, r2, #7
    7ce0:	b132      	cbz	r2, 7cf0 <memchr+0x70>
    7ce2:	f810 3b01 	ldrb.w	r3, [r0], #1
    7ce6:	3a01      	subs	r2, #1
    7ce8:	ea83 0301 	eor.w	r3, r3, r1
    7cec:	b113      	cbz	r3, 7cf4 <memchr+0x74>
    7cee:	d1f8      	bne.n	7ce2 <memchr+0x62>
    7cf0:	2000      	movs	r0, #0
    7cf2:	4770      	bx	lr
    7cf4:	3801      	subs	r0, #1
    7cf6:	4770      	bx	lr
    7cf8:	2d00      	cmp	r5, #0
    7cfa:	bf06      	itte	eq
    7cfc:	4635      	moveq	r5, r6
    7cfe:	3803      	subeq	r0, #3
    7d00:	3807      	subne	r0, #7
    7d02:	f015 0f01 	tst.w	r5, #1
    7d06:	d107      	bne.n	7d18 <memchr+0x98>
    7d08:	3001      	adds	r0, #1
    7d0a:	f415 7f80 	tst.w	r5, #256	; 0x100
    7d0e:	bf02      	ittt	eq
    7d10:	3001      	addeq	r0, #1
    7d12:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    7d16:	3001      	addeq	r0, #1
    7d18:	bcf0      	pop	{r4, r5, r6, r7}
    7d1a:	3801      	subs	r0, #1
    7d1c:	4770      	bx	lr
    7d1e:	bf00      	nop

00007d20 <_Balloc>:
    7d20:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    7d22:	b570      	push	{r4, r5, r6, lr}
    7d24:	4605      	mov	r5, r0
    7d26:	460c      	mov	r4, r1
    7d28:	b14b      	cbz	r3, 7d3e <_Balloc+0x1e>
    7d2a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    7d2e:	b180      	cbz	r0, 7d52 <_Balloc+0x32>
    7d30:	6802      	ldr	r2, [r0, #0]
    7d32:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    7d36:	2300      	movs	r3, #0
    7d38:	6103      	str	r3, [r0, #16]
    7d3a:	60c3      	str	r3, [r0, #12]
    7d3c:	bd70      	pop	{r4, r5, r6, pc}
    7d3e:	2221      	movs	r2, #33	; 0x21
    7d40:	2104      	movs	r1, #4
    7d42:	f000 fb2f 	bl	83a4 <_calloc_r>
    7d46:	64e8      	str	r0, [r5, #76]	; 0x4c
    7d48:	4603      	mov	r3, r0
    7d4a:	2800      	cmp	r0, #0
    7d4c:	d1ed      	bne.n	7d2a <_Balloc+0xa>
    7d4e:	2000      	movs	r0, #0
    7d50:	bd70      	pop	{r4, r5, r6, pc}
    7d52:	2101      	movs	r1, #1
    7d54:	fa01 f604 	lsl.w	r6, r1, r4
    7d58:	1d72      	adds	r2, r6, #5
    7d5a:	4628      	mov	r0, r5
    7d5c:	0092      	lsls	r2, r2, #2
    7d5e:	f000 fb21 	bl	83a4 <_calloc_r>
    7d62:	2800      	cmp	r0, #0
    7d64:	d0f3      	beq.n	7d4e <_Balloc+0x2e>
    7d66:	6044      	str	r4, [r0, #4]
    7d68:	6086      	str	r6, [r0, #8]
    7d6a:	e7e4      	b.n	7d36 <_Balloc+0x16>

00007d6c <_Bfree>:
    7d6c:	b131      	cbz	r1, 7d7c <_Bfree+0x10>
    7d6e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    7d70:	684a      	ldr	r2, [r1, #4]
    7d72:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    7d76:	6008      	str	r0, [r1, #0]
    7d78:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    7d7c:	4770      	bx	lr
    7d7e:	bf00      	nop

00007d80 <__multadd>:
    7d80:	b5f0      	push	{r4, r5, r6, r7, lr}
    7d82:	690c      	ldr	r4, [r1, #16]
    7d84:	b083      	sub	sp, #12
    7d86:	460d      	mov	r5, r1
    7d88:	4606      	mov	r6, r0
    7d8a:	f101 0e14 	add.w	lr, r1, #20
    7d8e:	2700      	movs	r7, #0
    7d90:	f8de 0000 	ldr.w	r0, [lr]
    7d94:	b281      	uxth	r1, r0
    7d96:	fb02 3101 	mla	r1, r2, r1, r3
    7d9a:	0c0b      	lsrs	r3, r1, #16
    7d9c:	0c00      	lsrs	r0, r0, #16
    7d9e:	fb02 3300 	mla	r3, r2, r0, r3
    7da2:	b289      	uxth	r1, r1
    7da4:	3701      	adds	r7, #1
    7da6:	eb01 4103 	add.w	r1, r1, r3, lsl #16
    7daa:	42bc      	cmp	r4, r7
    7dac:	f84e 1b04 	str.w	r1, [lr], #4
    7db0:	ea4f 4313 	mov.w	r3, r3, lsr #16
    7db4:	dcec      	bgt.n	7d90 <__multadd+0x10>
    7db6:	b13b      	cbz	r3, 7dc8 <__multadd+0x48>
    7db8:	68aa      	ldr	r2, [r5, #8]
    7dba:	4294      	cmp	r4, r2
    7dbc:	da07      	bge.n	7dce <__multadd+0x4e>
    7dbe:	eb05 0284 	add.w	r2, r5, r4, lsl #2
    7dc2:	3401      	adds	r4, #1
    7dc4:	6153      	str	r3, [r2, #20]
    7dc6:	612c      	str	r4, [r5, #16]
    7dc8:	4628      	mov	r0, r5
    7dca:	b003      	add	sp, #12
    7dcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7dce:	6869      	ldr	r1, [r5, #4]
    7dd0:	9301      	str	r3, [sp, #4]
    7dd2:	3101      	adds	r1, #1
    7dd4:	4630      	mov	r0, r6
    7dd6:	f7ff ffa3 	bl	7d20 <_Balloc>
    7dda:	692a      	ldr	r2, [r5, #16]
    7ddc:	3202      	adds	r2, #2
    7dde:	f105 010c 	add.w	r1, r5, #12
    7de2:	4607      	mov	r7, r0
    7de4:	0092      	lsls	r2, r2, #2
    7de6:	300c      	adds	r0, #12
    7de8:	f7fe fedc 	bl	6ba4 <memcpy>
    7dec:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
    7dee:	6869      	ldr	r1, [r5, #4]
    7df0:	9b01      	ldr	r3, [sp, #4]
    7df2:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
    7df6:	6028      	str	r0, [r5, #0]
    7df8:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
    7dfc:	463d      	mov	r5, r7
    7dfe:	e7de      	b.n	7dbe <__multadd+0x3e>

00007e00 <__hi0bits>:
    7e00:	0c03      	lsrs	r3, r0, #16
    7e02:	041b      	lsls	r3, r3, #16
    7e04:	b9b3      	cbnz	r3, 7e34 <__hi0bits+0x34>
    7e06:	0400      	lsls	r0, r0, #16
    7e08:	2310      	movs	r3, #16
    7e0a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
    7e0e:	bf04      	itt	eq
    7e10:	0200      	lsleq	r0, r0, #8
    7e12:	3308      	addeq	r3, #8
    7e14:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
    7e18:	bf04      	itt	eq
    7e1a:	0100      	lsleq	r0, r0, #4
    7e1c:	3304      	addeq	r3, #4
    7e1e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
    7e22:	bf04      	itt	eq
    7e24:	0080      	lsleq	r0, r0, #2
    7e26:	3302      	addeq	r3, #2
    7e28:	2800      	cmp	r0, #0
    7e2a:	db07      	blt.n	7e3c <__hi0bits+0x3c>
    7e2c:	0042      	lsls	r2, r0, #1
    7e2e:	d403      	bmi.n	7e38 <__hi0bits+0x38>
    7e30:	2020      	movs	r0, #32
    7e32:	4770      	bx	lr
    7e34:	2300      	movs	r3, #0
    7e36:	e7e8      	b.n	7e0a <__hi0bits+0xa>
    7e38:	1c58      	adds	r0, r3, #1
    7e3a:	4770      	bx	lr
    7e3c:	4618      	mov	r0, r3
    7e3e:	4770      	bx	lr

00007e40 <__lo0bits>:
    7e40:	6803      	ldr	r3, [r0, #0]
    7e42:	f013 0207 	ands.w	r2, r3, #7
    7e46:	d007      	beq.n	7e58 <__lo0bits+0x18>
    7e48:	07d9      	lsls	r1, r3, #31
    7e4a:	d420      	bmi.n	7e8e <__lo0bits+0x4e>
    7e4c:	079a      	lsls	r2, r3, #30
    7e4e:	d420      	bmi.n	7e92 <__lo0bits+0x52>
    7e50:	089b      	lsrs	r3, r3, #2
    7e52:	6003      	str	r3, [r0, #0]
    7e54:	2002      	movs	r0, #2
    7e56:	4770      	bx	lr
    7e58:	b299      	uxth	r1, r3
    7e5a:	b909      	cbnz	r1, 7e60 <__lo0bits+0x20>
    7e5c:	0c1b      	lsrs	r3, r3, #16
    7e5e:	2210      	movs	r2, #16
    7e60:	f013 0fff 	tst.w	r3, #255	; 0xff
    7e64:	bf04      	itt	eq
    7e66:	0a1b      	lsreq	r3, r3, #8
    7e68:	3208      	addeq	r2, #8
    7e6a:	0719      	lsls	r1, r3, #28
    7e6c:	bf04      	itt	eq
    7e6e:	091b      	lsreq	r3, r3, #4
    7e70:	3204      	addeq	r2, #4
    7e72:	0799      	lsls	r1, r3, #30
    7e74:	bf04      	itt	eq
    7e76:	089b      	lsreq	r3, r3, #2
    7e78:	3202      	addeq	r2, #2
    7e7a:	07d9      	lsls	r1, r3, #31
    7e7c:	d404      	bmi.n	7e88 <__lo0bits+0x48>
    7e7e:	085b      	lsrs	r3, r3, #1
    7e80:	d101      	bne.n	7e86 <__lo0bits+0x46>
    7e82:	2020      	movs	r0, #32
    7e84:	4770      	bx	lr
    7e86:	3201      	adds	r2, #1
    7e88:	6003      	str	r3, [r0, #0]
    7e8a:	4610      	mov	r0, r2
    7e8c:	4770      	bx	lr
    7e8e:	2000      	movs	r0, #0
    7e90:	4770      	bx	lr
    7e92:	085b      	lsrs	r3, r3, #1
    7e94:	6003      	str	r3, [r0, #0]
    7e96:	2001      	movs	r0, #1
    7e98:	4770      	bx	lr
    7e9a:	bf00      	nop

00007e9c <__i2b>:
    7e9c:	b510      	push	{r4, lr}
    7e9e:	460c      	mov	r4, r1
    7ea0:	2101      	movs	r1, #1
    7ea2:	f7ff ff3d 	bl	7d20 <_Balloc>
    7ea6:	2201      	movs	r2, #1
    7ea8:	6144      	str	r4, [r0, #20]
    7eaa:	6102      	str	r2, [r0, #16]
    7eac:	bd10      	pop	{r4, pc}
    7eae:	bf00      	nop

00007eb0 <__multiply>:
    7eb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7eb4:	690d      	ldr	r5, [r1, #16]
    7eb6:	6917      	ldr	r7, [r2, #16]
    7eb8:	42bd      	cmp	r5, r7
    7eba:	b083      	sub	sp, #12
    7ebc:	460c      	mov	r4, r1
    7ebe:	4616      	mov	r6, r2
    7ec0:	da04      	bge.n	7ecc <__multiply+0x1c>
    7ec2:	462a      	mov	r2, r5
    7ec4:	4634      	mov	r4, r6
    7ec6:	463d      	mov	r5, r7
    7ec8:	460e      	mov	r6, r1
    7eca:	4617      	mov	r7, r2
    7ecc:	68a3      	ldr	r3, [r4, #8]
    7ece:	6861      	ldr	r1, [r4, #4]
    7ed0:	eb05 0807 	add.w	r8, r5, r7
    7ed4:	4598      	cmp	r8, r3
    7ed6:	bfc8      	it	gt
    7ed8:	3101      	addgt	r1, #1
    7eda:	f7ff ff21 	bl	7d20 <_Balloc>
    7ede:	f100 0c14 	add.w	ip, r0, #20
    7ee2:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
    7ee6:	45cc      	cmp	ip, r9
    7ee8:	9000      	str	r0, [sp, #0]
    7eea:	d205      	bcs.n	7ef8 <__multiply+0x48>
    7eec:	4663      	mov	r3, ip
    7eee:	2100      	movs	r1, #0
    7ef0:	f843 1b04 	str.w	r1, [r3], #4
    7ef4:	4599      	cmp	r9, r3
    7ef6:	d8fb      	bhi.n	7ef0 <__multiply+0x40>
    7ef8:	f106 0214 	add.w	r2, r6, #20
    7efc:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
    7f00:	f104 0314 	add.w	r3, r4, #20
    7f04:	4552      	cmp	r2, sl
    7f06:	eb03 0e85 	add.w	lr, r3, r5, lsl #2
    7f0a:	d254      	bcs.n	7fb6 <__multiply+0x106>
    7f0c:	f8cd 9004 	str.w	r9, [sp, #4]
    7f10:	4699      	mov	r9, r3
    7f12:	f852 3b04 	ldr.w	r3, [r2], #4
    7f16:	fa1f fb83 	uxth.w	fp, r3
    7f1a:	f1bb 0f00 	cmp.w	fp, #0
    7f1e:	d020      	beq.n	7f62 <__multiply+0xb2>
    7f20:	2000      	movs	r0, #0
    7f22:	464f      	mov	r7, r9
    7f24:	4666      	mov	r6, ip
    7f26:	4605      	mov	r5, r0
    7f28:	e000      	b.n	7f2c <__multiply+0x7c>
    7f2a:	461e      	mov	r6, r3
    7f2c:	f857 4b04 	ldr.w	r4, [r7], #4
    7f30:	6830      	ldr	r0, [r6, #0]
    7f32:	b2a1      	uxth	r1, r4
    7f34:	b283      	uxth	r3, r0
    7f36:	fb0b 3101 	mla	r1, fp, r1, r3
    7f3a:	0c24      	lsrs	r4, r4, #16
    7f3c:	0c00      	lsrs	r0, r0, #16
    7f3e:	194b      	adds	r3, r1, r5
    7f40:	fb0b 0004 	mla	r0, fp, r4, r0
    7f44:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    7f48:	b299      	uxth	r1, r3
    7f4a:	4633      	mov	r3, r6
    7f4c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    7f50:	45be      	cmp	lr, r7
    7f52:	ea4f 4510 	mov.w	r5, r0, lsr #16
    7f56:	f843 1b04 	str.w	r1, [r3], #4
    7f5a:	d8e6      	bhi.n	7f2a <__multiply+0x7a>
    7f5c:	6075      	str	r5, [r6, #4]
    7f5e:	f852 3c04 	ldr.w	r3, [r2, #-4]
    7f62:	ea5f 4b13 	movs.w	fp, r3, lsr #16
    7f66:	d020      	beq.n	7faa <__multiply+0xfa>
    7f68:	f8dc 3000 	ldr.w	r3, [ip]
    7f6c:	4667      	mov	r7, ip
    7f6e:	4618      	mov	r0, r3
    7f70:	464d      	mov	r5, r9
    7f72:	2100      	movs	r1, #0
    7f74:	e000      	b.n	7f78 <__multiply+0xc8>
    7f76:	4637      	mov	r7, r6
    7f78:	882c      	ldrh	r4, [r5, #0]
    7f7a:	0c00      	lsrs	r0, r0, #16
    7f7c:	fb0b 0004 	mla	r0, fp, r4, r0
    7f80:	4401      	add	r1, r0
    7f82:	b29c      	uxth	r4, r3
    7f84:	463e      	mov	r6, r7
    7f86:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
    7f8a:	f846 3b04 	str.w	r3, [r6], #4
    7f8e:	6878      	ldr	r0, [r7, #4]
    7f90:	f855 4b04 	ldr.w	r4, [r5], #4
    7f94:	b283      	uxth	r3, r0
    7f96:	0c24      	lsrs	r4, r4, #16
    7f98:	fb0b 3404 	mla	r4, fp, r4, r3
    7f9c:	eb04 4311 	add.w	r3, r4, r1, lsr #16
    7fa0:	45ae      	cmp	lr, r5
    7fa2:	ea4f 4113 	mov.w	r1, r3, lsr #16
    7fa6:	d8e6      	bhi.n	7f76 <__multiply+0xc6>
    7fa8:	607b      	str	r3, [r7, #4]
    7faa:	4592      	cmp	sl, r2
    7fac:	f10c 0c04 	add.w	ip, ip, #4
    7fb0:	d8af      	bhi.n	7f12 <__multiply+0x62>
    7fb2:	f8dd 9004 	ldr.w	r9, [sp, #4]
    7fb6:	f1b8 0f00 	cmp.w	r8, #0
    7fba:	dd0b      	ble.n	7fd4 <__multiply+0x124>
    7fbc:	f859 3c04 	ldr.w	r3, [r9, #-4]
    7fc0:	f1a9 0904 	sub.w	r9, r9, #4
    7fc4:	b11b      	cbz	r3, 7fce <__multiply+0x11e>
    7fc6:	e005      	b.n	7fd4 <__multiply+0x124>
    7fc8:	f859 3d04 	ldr.w	r3, [r9, #-4]!
    7fcc:	b913      	cbnz	r3, 7fd4 <__multiply+0x124>
    7fce:	f1b8 0801 	subs.w	r8, r8, #1
    7fd2:	d1f9      	bne.n	7fc8 <__multiply+0x118>
    7fd4:	9800      	ldr	r0, [sp, #0]
    7fd6:	f8c0 8010 	str.w	r8, [r0, #16]
    7fda:	b003      	add	sp, #12
    7fdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00007fe0 <__pow5mult>:
    7fe0:	f012 0303 	ands.w	r3, r2, #3
    7fe4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7fe8:	4614      	mov	r4, r2
    7fea:	4607      	mov	r7, r0
    7fec:	d12e      	bne.n	804c <__pow5mult+0x6c>
    7fee:	460e      	mov	r6, r1
    7ff0:	10a4      	asrs	r4, r4, #2
    7ff2:	d01c      	beq.n	802e <__pow5mult+0x4e>
    7ff4:	6cbd      	ldr	r5, [r7, #72]	; 0x48
    7ff6:	b395      	cbz	r5, 805e <__pow5mult+0x7e>
    7ff8:	07e3      	lsls	r3, r4, #31
    7ffa:	f04f 0800 	mov.w	r8, #0
    7ffe:	d406      	bmi.n	800e <__pow5mult+0x2e>
    8000:	1064      	asrs	r4, r4, #1
    8002:	d014      	beq.n	802e <__pow5mult+0x4e>
    8004:	6828      	ldr	r0, [r5, #0]
    8006:	b1a8      	cbz	r0, 8034 <__pow5mult+0x54>
    8008:	4605      	mov	r5, r0
    800a:	07e3      	lsls	r3, r4, #31
    800c:	d5f8      	bpl.n	8000 <__pow5mult+0x20>
    800e:	462a      	mov	r2, r5
    8010:	4631      	mov	r1, r6
    8012:	4638      	mov	r0, r7
    8014:	f7ff ff4c 	bl	7eb0 <__multiply>
    8018:	b1b6      	cbz	r6, 8048 <__pow5mult+0x68>
    801a:	6872      	ldr	r2, [r6, #4]
    801c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    801e:	1064      	asrs	r4, r4, #1
    8020:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    8024:	6031      	str	r1, [r6, #0]
    8026:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    802a:	4606      	mov	r6, r0
    802c:	d1ea      	bne.n	8004 <__pow5mult+0x24>
    802e:	4630      	mov	r0, r6
    8030:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8034:	462a      	mov	r2, r5
    8036:	4629      	mov	r1, r5
    8038:	4638      	mov	r0, r7
    803a:	f7ff ff39 	bl	7eb0 <__multiply>
    803e:	6028      	str	r0, [r5, #0]
    8040:	f8c0 8000 	str.w	r8, [r0]
    8044:	4605      	mov	r5, r0
    8046:	e7e0      	b.n	800a <__pow5mult+0x2a>
    8048:	4606      	mov	r6, r0
    804a:	e7d9      	b.n	8000 <__pow5mult+0x20>
    804c:	1e5a      	subs	r2, r3, #1
    804e:	4d0b      	ldr	r5, [pc, #44]	; (807c <__pow5mult+0x9c>)
    8050:	2300      	movs	r3, #0
    8052:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
    8056:	f7ff fe93 	bl	7d80 <__multadd>
    805a:	4606      	mov	r6, r0
    805c:	e7c8      	b.n	7ff0 <__pow5mult+0x10>
    805e:	2101      	movs	r1, #1
    8060:	4638      	mov	r0, r7
    8062:	f7ff fe5d 	bl	7d20 <_Balloc>
    8066:	f240 2171 	movw	r1, #625	; 0x271
    806a:	2201      	movs	r2, #1
    806c:	2300      	movs	r3, #0
    806e:	6141      	str	r1, [r0, #20]
    8070:	6102      	str	r2, [r0, #16]
    8072:	4605      	mov	r5, r0
    8074:	64b8      	str	r0, [r7, #72]	; 0x48
    8076:	6003      	str	r3, [r0, #0]
    8078:	e7be      	b.n	7ff8 <__pow5mult+0x18>
    807a:	bf00      	nop
    807c:	20000adc 	.word	0x20000adc

00008080 <__lshift>:
    8080:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8084:	4691      	mov	r9, r2
    8086:	690a      	ldr	r2, [r1, #16]
    8088:	688b      	ldr	r3, [r1, #8]
    808a:	ea4f 1469 	mov.w	r4, r9, asr #5
    808e:	eb04 0802 	add.w	r8, r4, r2
    8092:	f108 0501 	add.w	r5, r8, #1
    8096:	429d      	cmp	r5, r3
    8098:	460e      	mov	r6, r1
    809a:	4682      	mov	sl, r0
    809c:	6849      	ldr	r1, [r1, #4]
    809e:	dd04      	ble.n	80aa <__lshift+0x2a>
    80a0:	005b      	lsls	r3, r3, #1
    80a2:	429d      	cmp	r5, r3
    80a4:	f101 0101 	add.w	r1, r1, #1
    80a8:	dcfa      	bgt.n	80a0 <__lshift+0x20>
    80aa:	4650      	mov	r0, sl
    80ac:	f7ff fe38 	bl	7d20 <_Balloc>
    80b0:	2c00      	cmp	r4, #0
    80b2:	f100 0214 	add.w	r2, r0, #20
    80b6:	dd38      	ble.n	812a <__lshift+0xaa>
    80b8:	eb02 0384 	add.w	r3, r2, r4, lsl #2
    80bc:	2100      	movs	r1, #0
    80be:	f842 1b04 	str.w	r1, [r2], #4
    80c2:	4293      	cmp	r3, r2
    80c4:	d1fb      	bne.n	80be <__lshift+0x3e>
    80c6:	6934      	ldr	r4, [r6, #16]
    80c8:	f106 0114 	add.w	r1, r6, #20
    80cc:	f019 091f 	ands.w	r9, r9, #31
    80d0:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
    80d4:	d021      	beq.n	811a <__lshift+0x9a>
    80d6:	f1c9 0220 	rsb	r2, r9, #32
    80da:	2400      	movs	r4, #0
    80dc:	680f      	ldr	r7, [r1, #0]
    80de:	fa07 fc09 	lsl.w	ip, r7, r9
    80e2:	ea4c 0404 	orr.w	r4, ip, r4
    80e6:	469c      	mov	ip, r3
    80e8:	f843 4b04 	str.w	r4, [r3], #4
    80ec:	f851 4b04 	ldr.w	r4, [r1], #4
    80f0:	458e      	cmp	lr, r1
    80f2:	fa24 f402 	lsr.w	r4, r4, r2
    80f6:	d8f1      	bhi.n	80dc <__lshift+0x5c>
    80f8:	f8cc 4004 	str.w	r4, [ip, #4]
    80fc:	b10c      	cbz	r4, 8102 <__lshift+0x82>
    80fe:	f108 0502 	add.w	r5, r8, #2
    8102:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    8106:	6872      	ldr	r2, [r6, #4]
    8108:	3d01      	subs	r5, #1
    810a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    810e:	6105      	str	r5, [r0, #16]
    8110:	6031      	str	r1, [r6, #0]
    8112:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    8116:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    811a:	3b04      	subs	r3, #4
    811c:	f851 2b04 	ldr.w	r2, [r1], #4
    8120:	f843 2f04 	str.w	r2, [r3, #4]!
    8124:	458e      	cmp	lr, r1
    8126:	d8f9      	bhi.n	811c <__lshift+0x9c>
    8128:	e7eb      	b.n	8102 <__lshift+0x82>
    812a:	4613      	mov	r3, r2
    812c:	e7cb      	b.n	80c6 <__lshift+0x46>
    812e:	bf00      	nop

00008130 <__mcmp>:
    8130:	6902      	ldr	r2, [r0, #16]
    8132:	690b      	ldr	r3, [r1, #16]
    8134:	1ad2      	subs	r2, r2, r3
    8136:	d113      	bne.n	8160 <__mcmp+0x30>
    8138:	009b      	lsls	r3, r3, #2
    813a:	3014      	adds	r0, #20
    813c:	3114      	adds	r1, #20
    813e:	4419      	add	r1, r3
    8140:	b410      	push	{r4}
    8142:	4403      	add	r3, r0
    8144:	e001      	b.n	814a <__mcmp+0x1a>
    8146:	4298      	cmp	r0, r3
    8148:	d20c      	bcs.n	8164 <__mcmp+0x34>
    814a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
    814e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
    8152:	4294      	cmp	r4, r2
    8154:	d0f7      	beq.n	8146 <__mcmp+0x16>
    8156:	d309      	bcc.n	816c <__mcmp+0x3c>
    8158:	2001      	movs	r0, #1
    815a:	f85d 4b04 	ldr.w	r4, [sp], #4
    815e:	4770      	bx	lr
    8160:	4610      	mov	r0, r2
    8162:	4770      	bx	lr
    8164:	2000      	movs	r0, #0
    8166:	f85d 4b04 	ldr.w	r4, [sp], #4
    816a:	4770      	bx	lr
    816c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8170:	e7f3      	b.n	815a <__mcmp+0x2a>
    8172:	bf00      	nop

00008174 <__mdiff>:
    8174:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8178:	690b      	ldr	r3, [r1, #16]
    817a:	460f      	mov	r7, r1
    817c:	6911      	ldr	r1, [r2, #16]
    817e:	1a5b      	subs	r3, r3, r1
    8180:	2b00      	cmp	r3, #0
    8182:	4690      	mov	r8, r2
    8184:	d117      	bne.n	81b6 <__mdiff+0x42>
    8186:	0089      	lsls	r1, r1, #2
    8188:	f107 0214 	add.w	r2, r7, #20
    818c:	f108 0514 	add.w	r5, r8, #20
    8190:	1853      	adds	r3, r2, r1
    8192:	4429      	add	r1, r5
    8194:	e001      	b.n	819a <__mdiff+0x26>
    8196:	429a      	cmp	r2, r3
    8198:	d25e      	bcs.n	8258 <__mdiff+0xe4>
    819a:	f853 6d04 	ldr.w	r6, [r3, #-4]!
    819e:	f851 4d04 	ldr.w	r4, [r1, #-4]!
    81a2:	42a6      	cmp	r6, r4
    81a4:	d0f7      	beq.n	8196 <__mdiff+0x22>
    81a6:	d260      	bcs.n	826a <__mdiff+0xf6>
    81a8:	463b      	mov	r3, r7
    81aa:	4614      	mov	r4, r2
    81ac:	4647      	mov	r7, r8
    81ae:	f04f 0901 	mov.w	r9, #1
    81b2:	4698      	mov	r8, r3
    81b4:	e006      	b.n	81c4 <__mdiff+0x50>
    81b6:	db5d      	blt.n	8274 <__mdiff+0x100>
    81b8:	f107 0514 	add.w	r5, r7, #20
    81bc:	f102 0414 	add.w	r4, r2, #20
    81c0:	f04f 0900 	mov.w	r9, #0
    81c4:	6879      	ldr	r1, [r7, #4]
    81c6:	f7ff fdab 	bl	7d20 <_Balloc>
    81ca:	f8d8 3010 	ldr.w	r3, [r8, #16]
    81ce:	693e      	ldr	r6, [r7, #16]
    81d0:	f8c0 900c 	str.w	r9, [r0, #12]
    81d4:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
    81d8:	46a6      	mov	lr, r4
    81da:	eb05 0786 	add.w	r7, r5, r6, lsl #2
    81de:	f100 0414 	add.w	r4, r0, #20
    81e2:	2300      	movs	r3, #0
    81e4:	f85e 1b04 	ldr.w	r1, [lr], #4
    81e8:	f855 8b04 	ldr.w	r8, [r5], #4
    81ec:	b28a      	uxth	r2, r1
    81ee:	fa13 f388 	uxtah	r3, r3, r8
    81f2:	0c09      	lsrs	r1, r1, #16
    81f4:	1a9a      	subs	r2, r3, r2
    81f6:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
    81fa:	eb03 4322 	add.w	r3, r3, r2, asr #16
    81fe:	b292      	uxth	r2, r2
    8200:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    8204:	45f4      	cmp	ip, lr
    8206:	f844 2b04 	str.w	r2, [r4], #4
    820a:	ea4f 4323 	mov.w	r3, r3, asr #16
    820e:	d8e9      	bhi.n	81e4 <__mdiff+0x70>
    8210:	42af      	cmp	r7, r5
    8212:	d917      	bls.n	8244 <__mdiff+0xd0>
    8214:	46a4      	mov	ip, r4
    8216:	4629      	mov	r1, r5
    8218:	f851 eb04 	ldr.w	lr, [r1], #4
    821c:	fa13 f28e 	uxtah	r2, r3, lr
    8220:	1413      	asrs	r3, r2, #16
    8222:	eb03 431e 	add.w	r3, r3, lr, lsr #16
    8226:	b292      	uxth	r2, r2
    8228:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    822c:	428f      	cmp	r7, r1
    822e:	f84c 2b04 	str.w	r2, [ip], #4
    8232:	ea4f 4323 	mov.w	r3, r3, asr #16
    8236:	d8ef      	bhi.n	8218 <__mdiff+0xa4>
    8238:	43ed      	mvns	r5, r5
    823a:	443d      	add	r5, r7
    823c:	f025 0503 	bic.w	r5, r5, #3
    8240:	3504      	adds	r5, #4
    8242:	442c      	add	r4, r5
    8244:	3c04      	subs	r4, #4
    8246:	b922      	cbnz	r2, 8252 <__mdiff+0xde>
    8248:	f854 3d04 	ldr.w	r3, [r4, #-4]!
    824c:	3e01      	subs	r6, #1
    824e:	2b00      	cmp	r3, #0
    8250:	d0fa      	beq.n	8248 <__mdiff+0xd4>
    8252:	6106      	str	r6, [r0, #16]
    8254:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8258:	2100      	movs	r1, #0
    825a:	f7ff fd61 	bl	7d20 <_Balloc>
    825e:	2201      	movs	r2, #1
    8260:	2300      	movs	r3, #0
    8262:	6102      	str	r2, [r0, #16]
    8264:	6143      	str	r3, [r0, #20]
    8266:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    826a:	462c      	mov	r4, r5
    826c:	f04f 0900 	mov.w	r9, #0
    8270:	4615      	mov	r5, r2
    8272:	e7a7      	b.n	81c4 <__mdiff+0x50>
    8274:	463b      	mov	r3, r7
    8276:	f107 0414 	add.w	r4, r7, #20
    827a:	f108 0514 	add.w	r5, r8, #20
    827e:	4647      	mov	r7, r8
    8280:	f04f 0901 	mov.w	r9, #1
    8284:	4698      	mov	r8, r3
    8286:	e79d      	b.n	81c4 <__mdiff+0x50>

00008288 <__d2b>:
    8288:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    828c:	ec57 6b10 	vmov	r6, r7, d0
    8290:	b083      	sub	sp, #12
    8292:	4688      	mov	r8, r1
    8294:	2101      	movs	r1, #1
    8296:	463c      	mov	r4, r7
    8298:	f3c7 550a 	ubfx	r5, r7, #20, #11
    829c:	4617      	mov	r7, r2
    829e:	f7ff fd3f 	bl	7d20 <_Balloc>
    82a2:	f3c4 0413 	ubfx	r4, r4, #0, #20
    82a6:	4681      	mov	r9, r0
    82a8:	b10d      	cbz	r5, 82ae <__d2b+0x26>
    82aa:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
    82ae:	9401      	str	r4, [sp, #4]
    82b0:	b31e      	cbz	r6, 82fa <__d2b+0x72>
    82b2:	a802      	add	r0, sp, #8
    82b4:	f840 6d08 	str.w	r6, [r0, #-8]!
    82b8:	f7ff fdc2 	bl	7e40 <__lo0bits>
    82bc:	2800      	cmp	r0, #0
    82be:	d134      	bne.n	832a <__d2b+0xa2>
    82c0:	e89d 000c 	ldmia.w	sp, {r2, r3}
    82c4:	f8c9 2014 	str.w	r2, [r9, #20]
    82c8:	2b00      	cmp	r3, #0
    82ca:	bf0c      	ite	eq
    82cc:	2101      	moveq	r1, #1
    82ce:	2102      	movne	r1, #2
    82d0:	f8c9 3018 	str.w	r3, [r9, #24]
    82d4:	f8c9 1010 	str.w	r1, [r9, #16]
    82d8:	b9dd      	cbnz	r5, 8312 <__d2b+0x8a>
    82da:	eb09 0381 	add.w	r3, r9, r1, lsl #2
    82de:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
    82e2:	f8c8 0000 	str.w	r0, [r8]
    82e6:	6918      	ldr	r0, [r3, #16]
    82e8:	f7ff fd8a 	bl	7e00 <__hi0bits>
    82ec:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
    82f0:	6038      	str	r0, [r7, #0]
    82f2:	4648      	mov	r0, r9
    82f4:	b003      	add	sp, #12
    82f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    82fa:	a801      	add	r0, sp, #4
    82fc:	f7ff fda0 	bl	7e40 <__lo0bits>
    8300:	9b01      	ldr	r3, [sp, #4]
    8302:	f8c9 3014 	str.w	r3, [r9, #20]
    8306:	2101      	movs	r1, #1
    8308:	3020      	adds	r0, #32
    830a:	f8c9 1010 	str.w	r1, [r9, #16]
    830e:	2d00      	cmp	r5, #0
    8310:	d0e3      	beq.n	82da <__d2b+0x52>
    8312:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
    8316:	4405      	add	r5, r0
    8318:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
    831c:	f8c8 5000 	str.w	r5, [r8]
    8320:	6038      	str	r0, [r7, #0]
    8322:	4648      	mov	r0, r9
    8324:	b003      	add	sp, #12
    8326:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    832a:	e89d 000c 	ldmia.w	sp, {r2, r3}
    832e:	f1c0 0120 	rsb	r1, r0, #32
    8332:	fa03 f101 	lsl.w	r1, r3, r1
    8336:	430a      	orrs	r2, r1
    8338:	40c3      	lsrs	r3, r0
    833a:	9301      	str	r3, [sp, #4]
    833c:	f8c9 2014 	str.w	r2, [r9, #20]
    8340:	e7c2      	b.n	82c8 <__d2b+0x40>
    8342:	bf00      	nop

00008344 <_vasnprintf_r>:
    8344:	b570      	push	{r4, r5, r6, lr}
    8346:	4615      	mov	r5, r2
    8348:	b09a      	sub	sp, #104	; 0x68
    834a:	6814      	ldr	r4, [r2, #0]
    834c:	b109      	cbz	r1, 8352 <_vasnprintf_r+0xe>
    834e:	2c00      	cmp	r4, #0
    8350:	d11a      	bne.n	8388 <_vasnprintf_r+0x44>
    8352:	2400      	movs	r4, #0
    8354:	f44f 7222 	mov.w	r2, #648	; 0x288
    8358:	f8ad 200c 	strh.w	r2, [sp, #12]
    835c:	9400      	str	r4, [sp, #0]
    835e:	9404      	str	r4, [sp, #16]
    8360:	461a      	mov	r2, r3
    8362:	f64f 76ff 	movw	r6, #65535	; 0xffff
    8366:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    8368:	9402      	str	r4, [sp, #8]
    836a:	4669      	mov	r1, sp
    836c:	9405      	str	r4, [sp, #20]
    836e:	f8ad 600e 	strh.w	r6, [sp, #14]
    8372:	f000 ff21 	bl	91b8 <_svfprintf_r>
    8376:	2800      	cmp	r0, #0
    8378:	db11      	blt.n	839e <_vasnprintf_r+0x5a>
    837a:	9b00      	ldr	r3, [sp, #0]
    837c:	6028      	str	r0, [r5, #0]
    837e:	2200      	movs	r2, #0
    8380:	701a      	strb	r2, [r3, #0]
    8382:	9804      	ldr	r0, [sp, #16]
    8384:	b01a      	add	sp, #104	; 0x68
    8386:	bd70      	pop	{r4, r5, r6, pc}
    8388:	f44f 62c1 	mov.w	r2, #1544	; 0x608
    838c:	9100      	str	r1, [sp, #0]
    838e:	9104      	str	r1, [sp, #16]
    8390:	f8ad 200c 	strh.w	r2, [sp, #12]
    8394:	dae4      	bge.n	8360 <_vasnprintf_r+0x1c>
    8396:	238b      	movs	r3, #139	; 0x8b
    8398:	6003      	str	r3, [r0, #0]
    839a:	2000      	movs	r0, #0
    839c:	e7f2      	b.n	8384 <_vasnprintf_r+0x40>
    839e:	2000      	movs	r0, #0
    83a0:	e7f0      	b.n	8384 <_vasnprintf_r+0x40>
    83a2:	bf00      	nop

000083a4 <_calloc_r>:
    83a4:	b510      	push	{r4, lr}
    83a6:	fb02 f101 	mul.w	r1, r2, r1
    83aa:	f7fe f92d 	bl	6608 <_malloc_r>
    83ae:	4604      	mov	r4, r0
    83b0:	b1d8      	cbz	r0, 83ea <_calloc_r+0x46>
    83b2:	f850 2c04 	ldr.w	r2, [r0, #-4]
    83b6:	f022 0203 	bic.w	r2, r2, #3
    83ba:	3a04      	subs	r2, #4
    83bc:	2a24      	cmp	r2, #36	; 0x24
    83be:	d818      	bhi.n	83f2 <_calloc_r+0x4e>
    83c0:	2a13      	cmp	r2, #19
    83c2:	d914      	bls.n	83ee <_calloc_r+0x4a>
    83c4:	2300      	movs	r3, #0
    83c6:	2a1b      	cmp	r2, #27
    83c8:	6003      	str	r3, [r0, #0]
    83ca:	6043      	str	r3, [r0, #4]
    83cc:	d916      	bls.n	83fc <_calloc_r+0x58>
    83ce:	2a24      	cmp	r2, #36	; 0x24
    83d0:	6083      	str	r3, [r0, #8]
    83d2:	60c3      	str	r3, [r0, #12]
    83d4:	bf11      	iteee	ne
    83d6:	f100 0210 	addne.w	r2, r0, #16
    83da:	6103      	streq	r3, [r0, #16]
    83dc:	6143      	streq	r3, [r0, #20]
    83de:	f100 0218 	addeq.w	r2, r0, #24
    83e2:	2300      	movs	r3, #0
    83e4:	6013      	str	r3, [r2, #0]
    83e6:	6053      	str	r3, [r2, #4]
    83e8:	6093      	str	r3, [r2, #8]
    83ea:	4620      	mov	r0, r4
    83ec:	bd10      	pop	{r4, pc}
    83ee:	4602      	mov	r2, r0
    83f0:	e7f7      	b.n	83e2 <_calloc_r+0x3e>
    83f2:	2100      	movs	r1, #0
    83f4:	f7fe fcd4 	bl	6da0 <memset>
    83f8:	4620      	mov	r0, r4
    83fa:	bd10      	pop	{r4, pc}
    83fc:	f100 0208 	add.w	r2, r0, #8
    8400:	e7ef      	b.n	83e2 <_calloc_r+0x3e>
    8402:	bf00      	nop

00008404 <quorem>:
    8404:	6902      	ldr	r2, [r0, #16]
    8406:	690b      	ldr	r3, [r1, #16]
    8408:	4293      	cmp	r3, r2
    840a:	f300 808d 	bgt.w	8528 <quorem+0x124>
    840e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8412:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    8416:	f101 0714 	add.w	r7, r1, #20
    841a:	f100 0b14 	add.w	fp, r0, #20
    841e:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
    8422:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    8426:	ea4f 0488 	mov.w	r4, r8, lsl #2
    842a:	b083      	sub	sp, #12
    842c:	3201      	adds	r2, #1
    842e:	fbb3 f9f2 	udiv	r9, r3, r2
    8432:	eb0b 0304 	add.w	r3, fp, r4
    8436:	9400      	str	r4, [sp, #0]
    8438:	eb07 0a04 	add.w	sl, r7, r4
    843c:	9301      	str	r3, [sp, #4]
    843e:	f1b9 0f00 	cmp.w	r9, #0
    8442:	d039      	beq.n	84b8 <quorem+0xb4>
    8444:	2500      	movs	r5, #0
    8446:	46bc      	mov	ip, r7
    8448:	46de      	mov	lr, fp
    844a:	462b      	mov	r3, r5
    844c:	f85c 6b04 	ldr.w	r6, [ip], #4
    8450:	f8de 2000 	ldr.w	r2, [lr]
    8454:	b2b4      	uxth	r4, r6
    8456:	fb09 5504 	mla	r5, r9, r4, r5
    845a:	0c36      	lsrs	r6, r6, #16
    845c:	0c2c      	lsrs	r4, r5, #16
    845e:	fb09 4406 	mla	r4, r9, r6, r4
    8462:	b2ad      	uxth	r5, r5
    8464:	1b5b      	subs	r3, r3, r5
    8466:	b2a6      	uxth	r6, r4
    8468:	fa13 f382 	uxtah	r3, r3, r2
    846c:	ebc6 4612 	rsb	r6, r6, r2, lsr #16
    8470:	eb06 4623 	add.w	r6, r6, r3, asr #16
    8474:	b29b      	uxth	r3, r3
    8476:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    847a:	45e2      	cmp	sl, ip
    847c:	f84e 3b04 	str.w	r3, [lr], #4
    8480:	ea4f 4514 	mov.w	r5, r4, lsr #16
    8484:	ea4f 4326 	mov.w	r3, r6, asr #16
    8488:	d2e0      	bcs.n	844c <quorem+0x48>
    848a:	9b00      	ldr	r3, [sp, #0]
    848c:	f85b 3003 	ldr.w	r3, [fp, r3]
    8490:	b993      	cbnz	r3, 84b8 <quorem+0xb4>
    8492:	9c01      	ldr	r4, [sp, #4]
    8494:	1f23      	subs	r3, r4, #4
    8496:	459b      	cmp	fp, r3
    8498:	d20c      	bcs.n	84b4 <quorem+0xb0>
    849a:	f854 3c04 	ldr.w	r3, [r4, #-4]
    849e:	b94b      	cbnz	r3, 84b4 <quorem+0xb0>
    84a0:	f1a4 0308 	sub.w	r3, r4, #8
    84a4:	e002      	b.n	84ac <quorem+0xa8>
    84a6:	681a      	ldr	r2, [r3, #0]
    84a8:	3b04      	subs	r3, #4
    84aa:	b91a      	cbnz	r2, 84b4 <quorem+0xb0>
    84ac:	459b      	cmp	fp, r3
    84ae:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    84b2:	d3f8      	bcc.n	84a6 <quorem+0xa2>
    84b4:	f8c0 8010 	str.w	r8, [r0, #16]
    84b8:	4604      	mov	r4, r0
    84ba:	f7ff fe39 	bl	8130 <__mcmp>
    84be:	2800      	cmp	r0, #0
    84c0:	db2e      	blt.n	8520 <quorem+0x11c>
    84c2:	f109 0901 	add.w	r9, r9, #1
    84c6:	465d      	mov	r5, fp
    84c8:	2300      	movs	r3, #0
    84ca:	f857 1b04 	ldr.w	r1, [r7], #4
    84ce:	6828      	ldr	r0, [r5, #0]
    84d0:	b28a      	uxth	r2, r1
    84d2:	1a9a      	subs	r2, r3, r2
    84d4:	0c09      	lsrs	r1, r1, #16
    84d6:	fa12 f280 	uxtah	r2, r2, r0
    84da:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
    84de:	eb03 4322 	add.w	r3, r3, r2, asr #16
    84e2:	b291      	uxth	r1, r2
    84e4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    84e8:	45ba      	cmp	sl, r7
    84ea:	f845 1b04 	str.w	r1, [r5], #4
    84ee:	ea4f 4323 	mov.w	r3, r3, asr #16
    84f2:	d2ea      	bcs.n	84ca <quorem+0xc6>
    84f4:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
    84f8:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
    84fc:	b982      	cbnz	r2, 8520 <quorem+0x11c>
    84fe:	1f1a      	subs	r2, r3, #4
    8500:	4593      	cmp	fp, r2
    8502:	d20b      	bcs.n	851c <quorem+0x118>
    8504:	f853 2c04 	ldr.w	r2, [r3, #-4]
    8508:	b942      	cbnz	r2, 851c <quorem+0x118>
    850a:	3b08      	subs	r3, #8
    850c:	e002      	b.n	8514 <quorem+0x110>
    850e:	681a      	ldr	r2, [r3, #0]
    8510:	3b04      	subs	r3, #4
    8512:	b91a      	cbnz	r2, 851c <quorem+0x118>
    8514:	459b      	cmp	fp, r3
    8516:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    851a:	d3f8      	bcc.n	850e <quorem+0x10a>
    851c:	f8c4 8010 	str.w	r8, [r4, #16]
    8520:	4648      	mov	r0, r9
    8522:	b003      	add	sp, #12
    8524:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8528:	2000      	movs	r0, #0
    852a:	4770      	bx	lr
    852c:	0000      	movs	r0, r0
	...

00008530 <_dtoa_r>:
    8530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8534:	ec57 6b10 	vmov	r6, r7, d0
    8538:	b093      	sub	sp, #76	; 0x4c
    853a:	6c05      	ldr	r5, [r0, #64]	; 0x40
    853c:	9101      	str	r1, [sp, #4]
    853e:	4604      	mov	r4, r0
    8540:	4690      	mov	r8, r2
    8542:	9304      	str	r3, [sp, #16]
    8544:	ee10 aa10 	vmov	sl, s0
    8548:	46bb      	mov	fp, r7
    854a:	b14d      	cbz	r5, 8560 <_dtoa_r+0x30>
    854c:	6c42      	ldr	r2, [r0, #68]	; 0x44
    854e:	606a      	str	r2, [r5, #4]
    8550:	2301      	movs	r3, #1
    8552:	4093      	lsls	r3, r2
    8554:	60ab      	str	r3, [r5, #8]
    8556:	4629      	mov	r1, r5
    8558:	f7ff fc08 	bl	7d6c <_Bfree>
    855c:	2300      	movs	r3, #0
    855e:	6423      	str	r3, [r4, #64]	; 0x40
    8560:	f1bb 0f00 	cmp.w	fp, #0
    8564:	465e      	mov	r6, fp
    8566:	db34      	blt.n	85d2 <_dtoa_r+0xa2>
    8568:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    856a:	2300      	movs	r3, #0
    856c:	6013      	str	r3, [r2, #0]
    856e:	4bc4      	ldr	r3, [pc, #784]	; (8880 <_dtoa_r+0x350>)
    8570:	461a      	mov	r2, r3
    8572:	4033      	ands	r3, r6
    8574:	4293      	cmp	r3, r2
    8576:	d015      	beq.n	85a4 <_dtoa_r+0x74>
    8578:	ec4b ab17 	vmov	d7, sl, fp
    857c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    8580:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8584:	e9cd ab02 	strd	sl, fp, [sp, #8]
    8588:	d12a      	bne.n	85e0 <_dtoa_r+0xb0>
    858a:	9a04      	ldr	r2, [sp, #16]
    858c:	2301      	movs	r3, #1
    858e:	6013      	str	r3, [r2, #0]
    8590:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    8592:	2b00      	cmp	r3, #0
    8594:	f000 80b7 	beq.w	8706 <_dtoa_r+0x1d6>
    8598:	48ba      	ldr	r0, [pc, #744]	; (8884 <_dtoa_r+0x354>)
    859a:	6018      	str	r0, [r3, #0]
    859c:	3801      	subs	r0, #1
    859e:	b013      	add	sp, #76	; 0x4c
    85a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    85a4:	9a04      	ldr	r2, [sp, #16]
    85a6:	f242 730f 	movw	r3, #9999	; 0x270f
    85aa:	6013      	str	r3, [r2, #0]
    85ac:	f1ba 0f00 	cmp.w	sl, #0
    85b0:	f000 8092 	beq.w	86d8 <_dtoa_r+0x1a8>
    85b4:	48b4      	ldr	r0, [pc, #720]	; (8888 <_dtoa_r+0x358>)
    85b6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    85b8:	2b00      	cmp	r3, #0
    85ba:	d0f0      	beq.n	859e <_dtoa_r+0x6e>
    85bc:	78c3      	ldrb	r3, [r0, #3]
    85be:	2b00      	cmp	r3, #0
    85c0:	f000 80a3 	beq.w	870a <_dtoa_r+0x1da>
    85c4:	f100 0308 	add.w	r3, r0, #8
    85c8:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    85ca:	6013      	str	r3, [r2, #0]
    85cc:	b013      	add	sp, #76	; 0x4c
    85ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    85d2:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    85d4:	2301      	movs	r3, #1
    85d6:	f02b 4600 	bic.w	r6, fp, #2147483648	; 0x80000000
    85da:	6013      	str	r3, [r2, #0]
    85dc:	46b3      	mov	fp, r6
    85de:	e7c6      	b.n	856e <_dtoa_r+0x3e>
    85e0:	a911      	add	r1, sp, #68	; 0x44
    85e2:	aa10      	add	r2, sp, #64	; 0x40
    85e4:	ed9d 0b02 	vldr	d0, [sp, #8]
    85e8:	4620      	mov	r0, r4
    85ea:	f7ff fe4d 	bl	8288 <__d2b>
    85ee:	0d31      	lsrs	r1, r6, #20
    85f0:	9007      	str	r0, [sp, #28]
    85f2:	d17a      	bne.n	86ea <_dtoa_r+0x1ba>
    85f4:	9810      	ldr	r0, [sp, #64]	; 0x40
    85f6:	9911      	ldr	r1, [sp, #68]	; 0x44
    85f8:	4401      	add	r1, r0
    85fa:	f201 4332 	addw	r3, r1, #1074	; 0x432
    85fe:	2b20      	cmp	r3, #32
    8600:	f340 8241 	ble.w	8a86 <_dtoa_r+0x556>
    8604:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    8608:	f201 4212 	addw	r2, r1, #1042	; 0x412
    860c:	409e      	lsls	r6, r3
    860e:	fa2a f302 	lsr.w	r3, sl, r2
    8612:	4333      	orrs	r3, r6
    8614:	ee07 3a90 	vmov	s15, r3
    8618:	eeb8 7b67 	vcvt.f64.u32	d7, s15
    861c:	2501      	movs	r5, #1
    861e:	ec53 2b17 	vmov	r2, r3, d7
    8622:	3901      	subs	r1, #1
    8624:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
    8628:	950a      	str	r5, [sp, #40]	; 0x28
    862a:	ec43 2b17 	vmov	d7, r2, r3
    862e:	eeb7 6b08 	vmov.f64	d6, #120	; 0x3fc00000  1.5
    8632:	ed9f 4b8d 	vldr	d4, [pc, #564]	; 8868 <_dtoa_r+0x338>
    8636:	ee37 6b46 	vsub.f64	d6, d7, d6
    863a:	ed9f 7b8d 	vldr	d7, [pc, #564]	; 8870 <_dtoa_r+0x340>
    863e:	ed9f 5b8e 	vldr	d5, [pc, #568]	; 8878 <_dtoa_r+0x348>
    8642:	eea6 7b04 	vfma.f64	d7, d6, d4
    8646:	ee06 1a90 	vmov	s13, r1
    864a:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    864e:	eea6 7b05 	vfma.f64	d7, d6, d5
    8652:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    8656:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    865a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    865e:	edcd 6a02 	vstr	s13, [sp, #8]
    8662:	f100 811c 	bmi.w	889e <_dtoa_r+0x36e>
    8666:	9d02      	ldr	r5, [sp, #8]
    8668:	2d16      	cmp	r5, #22
    866a:	f200 8115 	bhi.w	8898 <_dtoa_r+0x368>
    866e:	4b87      	ldr	r3, [pc, #540]	; (888c <_dtoa_r+0x35c>)
    8670:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    8674:	ed93 7b00 	vldr	d7, [r3]
    8678:	ec4b ab16 	vmov	d6, sl, fp
    867c:	eeb4 7bc6 	vcmpe.f64	d7, d6
    8680:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8684:	f340 8206 	ble.w	8a94 <_dtoa_r+0x564>
    8688:	1e6b      	subs	r3, r5, #1
    868a:	9302      	str	r3, [sp, #8]
    868c:	2300      	movs	r3, #0
    868e:	930c      	str	r3, [sp, #48]	; 0x30
    8690:	1a41      	subs	r1, r0, r1
    8692:	f1b1 0901 	subs.w	r9, r1, #1
    8696:	f100 8117 	bmi.w	88c8 <_dtoa_r+0x398>
    869a:	2300      	movs	r3, #0
    869c:	9306      	str	r3, [sp, #24]
    869e:	9b02      	ldr	r3, [sp, #8]
    86a0:	2b00      	cmp	r3, #0
    86a2:	f2c0 8108 	blt.w	88b6 <_dtoa_r+0x386>
    86a6:	4499      	add	r9, r3
    86a8:	930b      	str	r3, [sp, #44]	; 0x2c
    86aa:	2300      	movs	r3, #0
    86ac:	9305      	str	r3, [sp, #20]
    86ae:	9b01      	ldr	r3, [sp, #4]
    86b0:	2b09      	cmp	r3, #9
    86b2:	d82c      	bhi.n	870e <_dtoa_r+0x1de>
    86b4:	2b05      	cmp	r3, #5
    86b6:	f340 855f 	ble.w	9178 <_dtoa_r+0xc48>
    86ba:	3b04      	subs	r3, #4
    86bc:	9301      	str	r3, [sp, #4]
    86be:	2300      	movs	r3, #0
    86c0:	930e      	str	r3, [sp, #56]	; 0x38
    86c2:	9b01      	ldr	r3, [sp, #4]
    86c4:	3b02      	subs	r3, #2
    86c6:	2b03      	cmp	r3, #3
    86c8:	f200 855f 	bhi.w	918a <_dtoa_r+0xc5a>
    86cc:	e8df f013 	tbh	[pc, r3, lsl #1]
    86d0:	01e502a9 	.word	0x01e502a9
    86d4:	03c802b5 	.word	0x03c802b5
    86d8:	4b6b      	ldr	r3, [pc, #428]	; (8888 <_dtoa_r+0x358>)
    86da:	4a6d      	ldr	r2, [pc, #436]	; (8890 <_dtoa_r+0x360>)
    86dc:	f3c6 0013 	ubfx	r0, r6, #0, #20
    86e0:	2800      	cmp	r0, #0
    86e2:	bf14      	ite	ne
    86e4:	4618      	movne	r0, r3
    86e6:	4610      	moveq	r0, r2
    86e8:	e765      	b.n	85b6 <_dtoa_r+0x86>
    86ea:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    86ee:	f3c3 0013 	ubfx	r0, r3, #0, #20
    86f2:	f040 537f 	orr.w	r3, r0, #1069547520	; 0x3fc00000
    86f6:	2500      	movs	r5, #0
    86f8:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
    86fc:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    8700:	9810      	ldr	r0, [sp, #64]	; 0x40
    8702:	950a      	str	r5, [sp, #40]	; 0x28
    8704:	e791      	b.n	862a <_dtoa_r+0xfa>
    8706:	4863      	ldr	r0, [pc, #396]	; (8894 <_dtoa_r+0x364>)
    8708:	e749      	b.n	859e <_dtoa_r+0x6e>
    870a:	1cc3      	adds	r3, r0, #3
    870c:	e75c      	b.n	85c8 <_dtoa_r+0x98>
    870e:	2100      	movs	r1, #0
    8710:	6461      	str	r1, [r4, #68]	; 0x44
    8712:	4620      	mov	r0, r4
    8714:	4688      	mov	r8, r1
    8716:	9101      	str	r1, [sp, #4]
    8718:	f7ff fb02 	bl	7d20 <_Balloc>
    871c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    8720:	2301      	movs	r3, #1
    8722:	9008      	str	r0, [sp, #32]
    8724:	6420      	str	r0, [r4, #64]	; 0x40
    8726:	970d      	str	r7, [sp, #52]	; 0x34
    8728:	9309      	str	r3, [sp, #36]	; 0x24
    872a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    872c:	2b00      	cmp	r3, #0
    872e:	db7a      	blt.n	8826 <_dtoa_r+0x2f6>
    8730:	9a02      	ldr	r2, [sp, #8]
    8732:	2a0e      	cmp	r2, #14
    8734:	dc77      	bgt.n	8826 <_dtoa_r+0x2f6>
    8736:	4b55      	ldr	r3, [pc, #340]	; (888c <_dtoa_r+0x35c>)
    8738:	f1b8 0f00 	cmp.w	r8, #0
    873c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    8740:	ed93 4b00 	vldr	d4, [r3]
    8744:	f2c0 8284 	blt.w	8c50 <_dtoa_r+0x720>
    8748:	eeb1 2b44 	vneg.f64	d2, d4
    874c:	ec4b ab17 	vmov	d7, sl, fp
    8750:	ee87 6b04 	vdiv.f64	d6, d7, d4
    8754:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    8758:	9a08      	ldr	r2, [sp, #32]
    875a:	ee16 3a10 	vmov	r3, s12
    875e:	2f01      	cmp	r7, #1
    8760:	f103 0330 	add.w	r3, r3, #48	; 0x30
    8764:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    8768:	f102 0b01 	add.w	fp, r2, #1
    876c:	7013      	strb	r3, [r2, #0]
    876e:	eea2 7b05 	vfma.f64	d7, d2, d5
    8772:	d022      	beq.n	87ba <_dtoa_r+0x28a>
    8774:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
    8778:	ee27 7b03 	vmul.f64	d7, d7, d3
    877c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    8780:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8784:	d03a      	beq.n	87fc <_dtoa_r+0x2cc>
    8786:	9a08      	ldr	r2, [sp, #32]
    8788:	e006      	b.n	8798 <_dtoa_r+0x268>
    878a:	ee27 7b03 	vmul.f64	d7, d7, d3
    878e:	eeb5 7b40 	vcmp.f64	d7, #0.0
    8792:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8796:	d031      	beq.n	87fc <_dtoa_r+0x2cc>
    8798:	ee87 6b04 	vdiv.f64	d6, d7, d4
    879c:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    87a0:	ee16 3a10 	vmov	r3, s12
    87a4:	3330      	adds	r3, #48	; 0x30
    87a6:	f80b 3b01 	strb.w	r3, [fp], #1
    87aa:	ebc2 030b 	rsb	r3, r2, fp
    87ae:	42bb      	cmp	r3, r7
    87b0:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    87b4:	eea2 7b05 	vfma.f64	d7, d2, d5
    87b8:	d1e7      	bne.n	878a <_dtoa_r+0x25a>
    87ba:	ee37 7b07 	vadd.f64	d7, d7, d7
    87be:	eeb4 4bc7 	vcmpe.f64	d4, d7
    87c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    87c6:	d408      	bmi.n	87da <_dtoa_r+0x2aa>
    87c8:	eeb4 4b47 	vcmp.f64	d4, d7
    87cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    87d0:	d114      	bne.n	87fc <_dtoa_r+0x2cc>
    87d2:	ee16 3a10 	vmov	r3, s12
    87d6:	07db      	lsls	r3, r3, #31
    87d8:	d510      	bpl.n	87fc <_dtoa_r+0x2cc>
    87da:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    87de:	9a08      	ldr	r2, [sp, #32]
    87e0:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    87e4:	e004      	b.n	87f0 <_dtoa_r+0x2c0>
    87e6:	429a      	cmp	r2, r3
    87e8:	f000 83e5 	beq.w	8fb6 <_dtoa_r+0xa86>
    87ec:	f813 0d01 	ldrb.w	r0, [r3, #-1]!
    87f0:	2839      	cmp	r0, #57	; 0x39
    87f2:	f103 0b01 	add.w	fp, r3, #1
    87f6:	d0f6      	beq.n	87e6 <_dtoa_r+0x2b6>
    87f8:	3001      	adds	r0, #1
    87fa:	7018      	strb	r0, [r3, #0]
    87fc:	9907      	ldr	r1, [sp, #28]
    87fe:	4620      	mov	r0, r4
    8800:	f7ff fab4 	bl	7d6c <_Bfree>
    8804:	2200      	movs	r2, #0
    8806:	9b02      	ldr	r3, [sp, #8]
    8808:	f88b 2000 	strb.w	r2, [fp]
    880c:	9a04      	ldr	r2, [sp, #16]
    880e:	3301      	adds	r3, #1
    8810:	6013      	str	r3, [r2, #0]
    8812:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    8814:	2b00      	cmp	r3, #0
    8816:	f000 8366 	beq.w	8ee6 <_dtoa_r+0x9b6>
    881a:	9808      	ldr	r0, [sp, #32]
    881c:	f8c3 b000 	str.w	fp, [r3]
    8820:	b013      	add	sp, #76	; 0x4c
    8822:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8826:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8828:	2a00      	cmp	r2, #0
    882a:	d053      	beq.n	88d4 <_dtoa_r+0x3a4>
    882c:	9a01      	ldr	r2, [sp, #4]
    882e:	2a01      	cmp	r2, #1
    8830:	f340 822e 	ble.w	8c90 <_dtoa_r+0x760>
    8834:	9905      	ldr	r1, [sp, #20]
    8836:	1e7a      	subs	r2, r7, #1
    8838:	4291      	cmp	r1, r2
    883a:	f2c0 8357 	blt.w	8eec <_dtoa_r+0x9bc>
    883e:	1a8b      	subs	r3, r1, r2
    8840:	930e      	str	r3, [sp, #56]	; 0x38
    8842:	2f00      	cmp	r7, #0
    8844:	9b06      	ldr	r3, [sp, #24]
    8846:	f2c0 8424 	blt.w	9092 <_dtoa_r+0xb62>
    884a:	930a      	str	r3, [sp, #40]	; 0x28
    884c:	463b      	mov	r3, r7
    884e:	9a06      	ldr	r2, [sp, #24]
    8850:	2101      	movs	r1, #1
    8852:	441a      	add	r2, r3
    8854:	4620      	mov	r0, r4
    8856:	9206      	str	r2, [sp, #24]
    8858:	4499      	add	r9, r3
    885a:	f7ff fb1f 	bl	7e9c <__i2b>
    885e:	4606      	mov	r6, r0
    8860:	e03d      	b.n	88de <_dtoa_r+0x3ae>
    8862:	bf00      	nop
    8864:	f3af 8000 	nop.w
    8868:	636f4361 	.word	0x636f4361
    886c:	3fd287a7 	.word	0x3fd287a7
    8870:	8b60c8b3 	.word	0x8b60c8b3
    8874:	3fc68a28 	.word	0x3fc68a28
    8878:	509f79fb 	.word	0x509f79fb
    887c:	3fd34413 	.word	0x3fd34413
    8880:	7ff00000 	.word	0x7ff00000
    8884:	20000f65 	.word	0x20000f65
    8888:	20000f60 	.word	0x20000f60
    888c:	200002e8 	.word	0x200002e8
    8890:	20000f54 	.word	0x20000f54
    8894:	20000f64 	.word	0x20000f64
    8898:	2301      	movs	r3, #1
    889a:	930c      	str	r3, [sp, #48]	; 0x30
    889c:	e6f8      	b.n	8690 <_dtoa_r+0x160>
    889e:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    88a2:	eeb4 7b46 	vcmp.f64	d7, d6
    88a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    88aa:	f43f aedc 	beq.w	8666 <_dtoa_r+0x136>
    88ae:	9b02      	ldr	r3, [sp, #8]
    88b0:	3b01      	subs	r3, #1
    88b2:	9302      	str	r3, [sp, #8]
    88b4:	e6d7      	b.n	8666 <_dtoa_r+0x136>
    88b6:	9a06      	ldr	r2, [sp, #24]
    88b8:	9b02      	ldr	r3, [sp, #8]
    88ba:	1ad2      	subs	r2, r2, r3
    88bc:	425b      	negs	r3, r3
    88be:	9305      	str	r3, [sp, #20]
    88c0:	2300      	movs	r3, #0
    88c2:	9206      	str	r2, [sp, #24]
    88c4:	930b      	str	r3, [sp, #44]	; 0x2c
    88c6:	e6f2      	b.n	86ae <_dtoa_r+0x17e>
    88c8:	f1c9 0300 	rsb	r3, r9, #0
    88cc:	9306      	str	r3, [sp, #24]
    88ce:	f04f 0900 	mov.w	r9, #0
    88d2:	e6e4      	b.n	869e <_dtoa_r+0x16e>
    88d4:	9b05      	ldr	r3, [sp, #20]
    88d6:	930e      	str	r3, [sp, #56]	; 0x38
    88d8:	9e09      	ldr	r6, [sp, #36]	; 0x24
    88da:	9b06      	ldr	r3, [sp, #24]
    88dc:	930a      	str	r3, [sp, #40]	; 0x28
    88de:	990a      	ldr	r1, [sp, #40]	; 0x28
    88e0:	460b      	mov	r3, r1
    88e2:	b161      	cbz	r1, 88fe <_dtoa_r+0x3ce>
    88e4:	f1b9 0f00 	cmp.w	r9, #0
    88e8:	dd09      	ble.n	88fe <_dtoa_r+0x3ce>
    88ea:	4549      	cmp	r1, r9
    88ec:	9a06      	ldr	r2, [sp, #24]
    88ee:	bfa8      	it	ge
    88f0:	464b      	movge	r3, r9
    88f2:	1ad2      	subs	r2, r2, r3
    88f4:	9206      	str	r2, [sp, #24]
    88f6:	1aca      	subs	r2, r1, r3
    88f8:	920a      	str	r2, [sp, #40]	; 0x28
    88fa:	ebc3 0909 	rsb	r9, r3, r9
    88fe:	9b05      	ldr	r3, [sp, #20]
    8900:	2b00      	cmp	r3, #0
    8902:	f340 8280 	ble.w	8e06 <_dtoa_r+0x8d6>
    8906:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8908:	2a00      	cmp	r2, #0
    890a:	f000 819a 	beq.w	8c42 <_dtoa_r+0x712>
    890e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    8910:	2a00      	cmp	r2, #0
    8912:	f000 8196 	beq.w	8c42 <_dtoa_r+0x712>
    8916:	4631      	mov	r1, r6
    8918:	4620      	mov	r0, r4
    891a:	f7ff fb61 	bl	7fe0 <__pow5mult>
    891e:	9a07      	ldr	r2, [sp, #28]
    8920:	4601      	mov	r1, r0
    8922:	4606      	mov	r6, r0
    8924:	4620      	mov	r0, r4
    8926:	f7ff fac3 	bl	7eb0 <__multiply>
    892a:	9907      	ldr	r1, [sp, #28]
    892c:	4605      	mov	r5, r0
    892e:	4620      	mov	r0, r4
    8930:	f7ff fa1c 	bl	7d6c <_Bfree>
    8934:	9b05      	ldr	r3, [sp, #20]
    8936:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    8938:	1a9b      	subs	r3, r3, r2
    893a:	9305      	str	r3, [sp, #20]
    893c:	f040 8180 	bne.w	8c40 <_dtoa_r+0x710>
    8940:	2101      	movs	r1, #1
    8942:	4620      	mov	r0, r4
    8944:	f7ff faaa 	bl	7e9c <__i2b>
    8948:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    894a:	9005      	str	r0, [sp, #20]
    894c:	2b00      	cmp	r3, #0
    894e:	f000 81ac 	beq.w	8caa <_dtoa_r+0x77a>
    8952:	4601      	mov	r1, r0
    8954:	461a      	mov	r2, r3
    8956:	4620      	mov	r0, r4
    8958:	f7ff fb42 	bl	7fe0 <__pow5mult>
    895c:	9b01      	ldr	r3, [sp, #4]
    895e:	9005      	str	r0, [sp, #20]
    8960:	2b01      	cmp	r3, #1
    8962:	f340 8280 	ble.w	8e66 <_dtoa_r+0x936>
    8966:	2300      	movs	r3, #0
    8968:	9307      	str	r3, [sp, #28]
    896a:	9a05      	ldr	r2, [sp, #20]
    896c:	6913      	ldr	r3, [r2, #16]
    896e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    8972:	6918      	ldr	r0, [r3, #16]
    8974:	f7ff fa44 	bl	7e00 <__hi0bits>
    8978:	f1c0 0020 	rsb	r0, r0, #32
    897c:	4448      	add	r0, r9
    897e:	f010 001f 	ands.w	r0, r0, #31
    8982:	f000 8190 	beq.w	8ca6 <_dtoa_r+0x776>
    8986:	f1c0 0320 	rsb	r3, r0, #32
    898a:	2b04      	cmp	r3, #4
    898c:	f340 83f8 	ble.w	9180 <_dtoa_r+0xc50>
    8990:	f1c0 001c 	rsb	r0, r0, #28
    8994:	9b06      	ldr	r3, [sp, #24]
    8996:	4403      	add	r3, r0
    8998:	9306      	str	r3, [sp, #24]
    899a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    899c:	4403      	add	r3, r0
    899e:	930a      	str	r3, [sp, #40]	; 0x28
    89a0:	4481      	add	r9, r0
    89a2:	9b06      	ldr	r3, [sp, #24]
    89a4:	2b00      	cmp	r3, #0
    89a6:	dd05      	ble.n	89b4 <_dtoa_r+0x484>
    89a8:	4629      	mov	r1, r5
    89aa:	461a      	mov	r2, r3
    89ac:	4620      	mov	r0, r4
    89ae:	f7ff fb67 	bl	8080 <__lshift>
    89b2:	4605      	mov	r5, r0
    89b4:	f1b9 0f00 	cmp.w	r9, #0
    89b8:	dd05      	ble.n	89c6 <_dtoa_r+0x496>
    89ba:	464a      	mov	r2, r9
    89bc:	9905      	ldr	r1, [sp, #20]
    89be:	4620      	mov	r0, r4
    89c0:	f7ff fb5e 	bl	8080 <__lshift>
    89c4:	9005      	str	r0, [sp, #20]
    89c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    89c8:	2b00      	cmp	r3, #0
    89ca:	f040 8201 	bne.w	8dd0 <_dtoa_r+0x8a0>
    89ce:	2f00      	cmp	r7, #0
    89d0:	f340 8220 	ble.w	8e14 <_dtoa_r+0x8e4>
    89d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    89d6:	2b00      	cmp	r3, #0
    89d8:	f040 817b 	bne.w	8cd2 <_dtoa_r+0x7a2>
    89dc:	f8dd b020 	ldr.w	fp, [sp, #32]
    89e0:	f8dd a014 	ldr.w	sl, [sp, #20]
    89e4:	46d8      	mov	r8, fp
    89e6:	e002      	b.n	89ee <_dtoa_r+0x4be>
    89e8:	f7ff f9ca 	bl	7d80 <__multadd>
    89ec:	4605      	mov	r5, r0
    89ee:	4651      	mov	r1, sl
    89f0:	4628      	mov	r0, r5
    89f2:	f7ff fd07 	bl	8404 <quorem>
    89f6:	f100 0930 	add.w	r9, r0, #48	; 0x30
    89fa:	f808 9b01 	strb.w	r9, [r8], #1
    89fe:	ebcb 0308 	rsb	r3, fp, r8
    8a02:	42bb      	cmp	r3, r7
    8a04:	f04f 020a 	mov.w	r2, #10
    8a08:	f04f 0300 	mov.w	r3, #0
    8a0c:	4629      	mov	r1, r5
    8a0e:	4620      	mov	r0, r4
    8a10:	dbea      	blt.n	89e8 <_dtoa_r+0x4b8>
    8a12:	9b08      	ldr	r3, [sp, #32]
    8a14:	2f01      	cmp	r7, #1
    8a16:	bfac      	ite	ge
    8a18:	19db      	addge	r3, r3, r7
    8a1a:	3301      	addlt	r3, #1
    8a1c:	469b      	mov	fp, r3
    8a1e:	f04f 0a00 	mov.w	sl, #0
    8a22:	4629      	mov	r1, r5
    8a24:	2201      	movs	r2, #1
    8a26:	4620      	mov	r0, r4
    8a28:	f7ff fb2a 	bl	8080 <__lshift>
    8a2c:	9905      	ldr	r1, [sp, #20]
    8a2e:	9007      	str	r0, [sp, #28]
    8a30:	f7ff fb7e 	bl	8130 <__mcmp>
    8a34:	2800      	cmp	r0, #0
    8a36:	f340 828c 	ble.w	8f52 <_dtoa_r+0xa22>
    8a3a:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
    8a3e:	9908      	ldr	r1, [sp, #32]
    8a40:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    8a44:	e004      	b.n	8a50 <_dtoa_r+0x520>
    8a46:	428b      	cmp	r3, r1
    8a48:	f000 8203 	beq.w	8e52 <_dtoa_r+0x922>
    8a4c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    8a50:	2a39      	cmp	r2, #57	; 0x39
    8a52:	f103 0b01 	add.w	fp, r3, #1
    8a56:	d0f6      	beq.n	8a46 <_dtoa_r+0x516>
    8a58:	3201      	adds	r2, #1
    8a5a:	701a      	strb	r2, [r3, #0]
    8a5c:	9905      	ldr	r1, [sp, #20]
    8a5e:	4620      	mov	r0, r4
    8a60:	f7ff f984 	bl	7d6c <_Bfree>
    8a64:	2e00      	cmp	r6, #0
    8a66:	f43f aec9 	beq.w	87fc <_dtoa_r+0x2cc>
    8a6a:	f1ba 0f00 	cmp.w	sl, #0
    8a6e:	d005      	beq.n	8a7c <_dtoa_r+0x54c>
    8a70:	45b2      	cmp	sl, r6
    8a72:	d003      	beq.n	8a7c <_dtoa_r+0x54c>
    8a74:	4651      	mov	r1, sl
    8a76:	4620      	mov	r0, r4
    8a78:	f7ff f978 	bl	7d6c <_Bfree>
    8a7c:	4631      	mov	r1, r6
    8a7e:	4620      	mov	r0, r4
    8a80:	f7ff f974 	bl	7d6c <_Bfree>
    8a84:	e6ba      	b.n	87fc <_dtoa_r+0x2cc>
    8a86:	f1c3 0320 	rsb	r3, r3, #32
    8a8a:	fa0a f303 	lsl.w	r3, sl, r3
    8a8e:	ee07 3a90 	vmov	s15, r3
    8a92:	e5c1      	b.n	8618 <_dtoa_r+0xe8>
    8a94:	2300      	movs	r3, #0
    8a96:	930c      	str	r3, [sp, #48]	; 0x30
    8a98:	e5fa      	b.n	8690 <_dtoa_r+0x160>
    8a9a:	2300      	movs	r3, #0
    8a9c:	9309      	str	r3, [sp, #36]	; 0x24
    8a9e:	9b02      	ldr	r3, [sp, #8]
    8aa0:	4443      	add	r3, r8
    8aa2:	1c5f      	adds	r7, r3, #1
    8aa4:	2f00      	cmp	r7, #0
    8aa6:	930d      	str	r3, [sp, #52]	; 0x34
    8aa8:	f340 822d 	ble.w	8f06 <_dtoa_r+0x9d6>
    8aac:	463e      	mov	r6, r7
    8aae:	463d      	mov	r5, r7
    8ab0:	2100      	movs	r1, #0
    8ab2:	2e17      	cmp	r6, #23
    8ab4:	6461      	str	r1, [r4, #68]	; 0x44
    8ab6:	d90a      	bls.n	8ace <_dtoa_r+0x59e>
    8ab8:	2201      	movs	r2, #1
    8aba:	2304      	movs	r3, #4
    8abc:	005b      	lsls	r3, r3, #1
    8abe:	f103 0014 	add.w	r0, r3, #20
    8ac2:	42b0      	cmp	r0, r6
    8ac4:	4611      	mov	r1, r2
    8ac6:	f102 0201 	add.w	r2, r2, #1
    8aca:	d9f7      	bls.n	8abc <_dtoa_r+0x58c>
    8acc:	6461      	str	r1, [r4, #68]	; 0x44
    8ace:	4620      	mov	r0, r4
    8ad0:	f7ff f926 	bl	7d20 <_Balloc>
    8ad4:	2d0e      	cmp	r5, #14
    8ad6:	9008      	str	r0, [sp, #32]
    8ad8:	6420      	str	r0, [r4, #64]	; 0x40
    8ada:	f63f ae26 	bhi.w	872a <_dtoa_r+0x1fa>
    8ade:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8ae0:	2b00      	cmp	r3, #0
    8ae2:	f43f ae22 	beq.w	872a <_dtoa_r+0x1fa>
    8ae6:	9902      	ldr	r1, [sp, #8]
    8ae8:	2900      	cmp	r1, #0
    8aea:	e9cd ab0e 	strd	sl, fp, [sp, #56]	; 0x38
    8aee:	f340 8241 	ble.w	8f74 <_dtoa_r+0xa44>
    8af2:	4bc6      	ldr	r3, [pc, #792]	; (8e0c <_dtoa_r+0x8dc>)
    8af4:	f001 020f 	and.w	r2, r1, #15
    8af8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    8afc:	110b      	asrs	r3, r1, #4
    8afe:	06de      	lsls	r6, r3, #27
    8b00:	ed92 6b00 	vldr	d6, [r2]
    8b04:	f140 81fb 	bpl.w	8efe <_dtoa_r+0x9ce>
    8b08:	4ac1      	ldr	r2, [pc, #772]	; (8e10 <_dtoa_r+0x8e0>)
    8b0a:	ed92 7b08 	vldr	d7, [r2, #32]
    8b0e:	ec4b ab14 	vmov	d4, sl, fp
    8b12:	f003 030f 	and.w	r3, r3, #15
    8b16:	2103      	movs	r1, #3
    8b18:	ee84 5b07 	vdiv.f64	d5, d4, d7
    8b1c:	b15b      	cbz	r3, 8b36 <_dtoa_r+0x606>
    8b1e:	4abc      	ldr	r2, [pc, #752]	; (8e10 <_dtoa_r+0x8e0>)
    8b20:	07dd      	lsls	r5, r3, #31
    8b22:	d504      	bpl.n	8b2e <_dtoa_r+0x5fe>
    8b24:	ed92 7b00 	vldr	d7, [r2]
    8b28:	3101      	adds	r1, #1
    8b2a:	ee26 6b07 	vmul.f64	d6, d6, d7
    8b2e:	105b      	asrs	r3, r3, #1
    8b30:	f102 0208 	add.w	r2, r2, #8
    8b34:	d1f4      	bne.n	8b20 <_dtoa_r+0x5f0>
    8b36:	ee85 4b06 	vdiv.f64	d4, d5, d6
    8b3a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    8b3c:	b13b      	cbz	r3, 8b4e <_dtoa_r+0x61e>
    8b3e:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    8b42:	eeb4 4bc7 	vcmpe.f64	d4, d7
    8b46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8b4a:	f100 82b7 	bmi.w	90bc <_dtoa_r+0xb8c>
    8b4e:	ee07 1a90 	vmov	s15, r1
    8b52:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    8b56:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    8b5a:	eea6 7b04 	vfma.f64	d7, d6, d4
    8b5e:	ec53 2b17 	vmov	r2, r3, d7
    8b62:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    8b66:	2f00      	cmp	r7, #0
    8b68:	f000 81a6 	beq.w	8eb8 <_dtoa_r+0x988>
    8b6c:	9e02      	ldr	r6, [sp, #8]
    8b6e:	4639      	mov	r1, r7
    8b70:	9809      	ldr	r0, [sp, #36]	; 0x24
    8b72:	2800      	cmp	r0, #0
    8b74:	f000 824d 	beq.w	9012 <_dtoa_r+0xae2>
    8b78:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    8b7c:	48a3      	ldr	r0, [pc, #652]	; (8e0c <_dtoa_r+0x8dc>)
    8b7e:	9d08      	ldr	r5, [sp, #32]
    8b80:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
    8b84:	ed10 6b02 	vldr	d6, [r0, #-8]
    8b88:	eebd 7bc4 	vcvt.s32.f64	s14, d4
    8b8c:	ee83 5b06 	vdiv.f64	d5, d3, d6
    8b90:	ee17 0a10 	vmov	r0, s14
    8b94:	ec43 2b16 	vmov	d6, r2, r3
    8b98:	3030      	adds	r0, #48	; 0x30
    8b9a:	b2c0      	uxtb	r0, r0
    8b9c:	ee35 5b46 	vsub.f64	d5, d5, d6
    8ba0:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    8ba4:	ee34 7b47 	vsub.f64	d7, d4, d7
    8ba8:	eeb4 5bc7 	vcmpe.f64	d5, d7
    8bac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8bb0:	7028      	strb	r0, [r5, #0]
    8bb2:	f105 0b01 	add.w	fp, r5, #1
    8bb6:	dc32      	bgt.n	8c1e <_dtoa_r+0x6ee>
    8bb8:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
    8bbc:	ee33 6b47 	vsub.f64	d6, d3, d7
    8bc0:	eeb4 5bc6 	vcmpe.f64	d5, d6
    8bc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8bc8:	f300 82ae 	bgt.w	9128 <_dtoa_r+0xbf8>
    8bcc:	2901      	cmp	r1, #1
    8bce:	f340 81cd 	ble.w	8f6c <_dtoa_r+0xa3c>
    8bd2:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    8bd6:	9b08      	ldr	r3, [sp, #32]
    8bd8:	4419      	add	r1, r3
    8bda:	e00a      	b.n	8bf2 <_dtoa_r+0x6c2>
    8bdc:	ee33 6b47 	vsub.f64	d6, d3, d7
    8be0:	eeb4 6bc5 	vcmpe.f64	d6, d5
    8be4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8be8:	f100 829e 	bmi.w	9128 <_dtoa_r+0xbf8>
    8bec:	458b      	cmp	fp, r1
    8bee:	f000 81bd 	beq.w	8f6c <_dtoa_r+0xa3c>
    8bf2:	ee27 7b04 	vmul.f64	d7, d7, d4
    8bf6:	ee25 5b04 	vmul.f64	d5, d5, d4
    8bfa:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    8bfe:	ee16 3a10 	vmov	r3, s12
    8c02:	f103 0030 	add.w	r0, r3, #48	; 0x30
    8c06:	b2c0      	uxtb	r0, r0
    8c08:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    8c0c:	ee37 7b46 	vsub.f64	d7, d7, d6
    8c10:	eeb4 7bc5 	vcmpe.f64	d7, d5
    8c14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8c18:	f80b 0b01 	strb.w	r0, [fp], #1
    8c1c:	d5de      	bpl.n	8bdc <_dtoa_r+0x6ac>
    8c1e:	9602      	str	r6, [sp, #8]
    8c20:	e5ec      	b.n	87fc <_dtoa_r+0x2cc>
    8c22:	2300      	movs	r3, #0
    8c24:	9309      	str	r3, [sp, #36]	; 0x24
    8c26:	f1b8 0f00 	cmp.w	r8, #0
    8c2a:	f340 8170 	ble.w	8f0e <_dtoa_r+0x9de>
    8c2e:	4646      	mov	r6, r8
    8c30:	4645      	mov	r5, r8
    8c32:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    8c36:	4647      	mov	r7, r8
    8c38:	e73a      	b.n	8ab0 <_dtoa_r+0x580>
    8c3a:	2301      	movs	r3, #1
    8c3c:	9309      	str	r3, [sp, #36]	; 0x24
    8c3e:	e7f2      	b.n	8c26 <_dtoa_r+0x6f6>
    8c40:	9507      	str	r5, [sp, #28]
    8c42:	9a05      	ldr	r2, [sp, #20]
    8c44:	9907      	ldr	r1, [sp, #28]
    8c46:	4620      	mov	r0, r4
    8c48:	f7ff f9ca 	bl	7fe0 <__pow5mult>
    8c4c:	4605      	mov	r5, r0
    8c4e:	e677      	b.n	8940 <_dtoa_r+0x410>
    8c50:	2f00      	cmp	r7, #0
    8c52:	f73f ad79 	bgt.w	8748 <_dtoa_r+0x218>
    8c56:	f040 8142 	bne.w	8ede <_dtoa_r+0x9ae>
    8c5a:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    8c5e:	ee24 4b07 	vmul.f64	d4, d4, d7
    8c62:	ec4b ab17 	vmov	d7, sl, fp
    8c66:	eeb4 4bc7 	vcmpe.f64	d4, d7
    8c6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8c6e:	463e      	mov	r6, r7
    8c70:	9705      	str	r7, [sp, #20]
    8c72:	f2c0 80e5 	blt.w	8e40 <_dtoa_r+0x910>
    8c76:	ea6f 0308 	mvn.w	r3, r8
    8c7a:	f8dd b020 	ldr.w	fp, [sp, #32]
    8c7e:	9302      	str	r3, [sp, #8]
    8c80:	9905      	ldr	r1, [sp, #20]
    8c82:	4620      	mov	r0, r4
    8c84:	f7ff f872 	bl	7d6c <_Bfree>
    8c88:	2e00      	cmp	r6, #0
    8c8a:	f43f adb7 	beq.w	87fc <_dtoa_r+0x2cc>
    8c8e:	e6f5      	b.n	8a7c <_dtoa_r+0x54c>
    8c90:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    8c92:	2a00      	cmp	r2, #0
    8c94:	f000 8202 	beq.w	909c <_dtoa_r+0xb6c>
    8c98:	9a05      	ldr	r2, [sp, #20]
    8c9a:	920e      	str	r2, [sp, #56]	; 0x38
    8c9c:	9a06      	ldr	r2, [sp, #24]
    8c9e:	920a      	str	r2, [sp, #40]	; 0x28
    8ca0:	f203 4333 	addw	r3, r3, #1075	; 0x433
    8ca4:	e5d3      	b.n	884e <_dtoa_r+0x31e>
    8ca6:	201c      	movs	r0, #28
    8ca8:	e674      	b.n	8994 <_dtoa_r+0x464>
    8caa:	9b01      	ldr	r3, [sp, #4]
    8cac:	2b01      	cmp	r3, #1
    8cae:	f340 8240 	ble.w	9132 <_dtoa_r+0xc02>
    8cb2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8cb4:	9307      	str	r3, [sp, #28]
    8cb6:	2001      	movs	r0, #1
    8cb8:	e660      	b.n	897c <_dtoa_r+0x44c>
    8cba:	4631      	mov	r1, r6
    8cbc:	2300      	movs	r3, #0
    8cbe:	220a      	movs	r2, #10
    8cc0:	4620      	mov	r0, r4
    8cc2:	f7ff f85d 	bl	7d80 <__multadd>
    8cc6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    8cc8:	2b00      	cmp	r3, #0
    8cca:	4606      	mov	r6, r0
    8ccc:	f340 824d 	ble.w	916a <_dtoa_r+0xc3a>
    8cd0:	461f      	mov	r7, r3
    8cd2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8cd4:	2b00      	cmp	r3, #0
    8cd6:	dd05      	ble.n	8ce4 <_dtoa_r+0x7b4>
    8cd8:	4631      	mov	r1, r6
    8cda:	461a      	mov	r2, r3
    8cdc:	4620      	mov	r0, r4
    8cde:	f7ff f9cf 	bl	8080 <__lshift>
    8ce2:	4606      	mov	r6, r0
    8ce4:	9b07      	ldr	r3, [sp, #28]
    8ce6:	2b00      	cmp	r3, #0
    8ce8:	f040 816e 	bne.w	8fc8 <_dtoa_r+0xa98>
    8cec:	46b0      	mov	r8, r6
    8cee:	9b08      	ldr	r3, [sp, #32]
    8cf0:	3f01      	subs	r7, #1
    8cf2:	19da      	adds	r2, r3, r7
    8cf4:	9209      	str	r2, [sp, #36]	; 0x24
    8cf6:	f00a 0201 	and.w	r2, sl, #1
    8cfa:	920a      	str	r2, [sp, #40]	; 0x28
    8cfc:	461f      	mov	r7, r3
    8cfe:	f8dd b014 	ldr.w	fp, [sp, #20]
    8d02:	4628      	mov	r0, r5
    8d04:	4659      	mov	r1, fp
    8d06:	f7ff fb7d 	bl	8404 <quorem>
    8d0a:	4631      	mov	r1, r6
    8d0c:	4682      	mov	sl, r0
    8d0e:	4628      	mov	r0, r5
    8d10:	f7ff fa0e 	bl	8130 <__mcmp>
    8d14:	4642      	mov	r2, r8
    8d16:	4659      	mov	r1, fp
    8d18:	4681      	mov	r9, r0
    8d1a:	4620      	mov	r0, r4
    8d1c:	f7ff fa2a 	bl	8174 <__mdiff>
    8d20:	68c3      	ldr	r3, [r0, #12]
    8d22:	4683      	mov	fp, r0
    8d24:	f10a 0230 	add.w	r2, sl, #48	; 0x30
    8d28:	2b00      	cmp	r3, #0
    8d2a:	d149      	bne.n	8dc0 <_dtoa_r+0x890>
    8d2c:	4601      	mov	r1, r0
    8d2e:	4628      	mov	r0, r5
    8d30:	9207      	str	r2, [sp, #28]
    8d32:	f7ff f9fd 	bl	8130 <__mcmp>
    8d36:	4659      	mov	r1, fp
    8d38:	9006      	str	r0, [sp, #24]
    8d3a:	4620      	mov	r0, r4
    8d3c:	f7ff f816 	bl	7d6c <_Bfree>
    8d40:	9b06      	ldr	r3, [sp, #24]
    8d42:	9a07      	ldr	r2, [sp, #28]
    8d44:	b92b      	cbnz	r3, 8d52 <_dtoa_r+0x822>
    8d46:	9901      	ldr	r1, [sp, #4]
    8d48:	b919      	cbnz	r1, 8d52 <_dtoa_r+0x822>
    8d4a:	990a      	ldr	r1, [sp, #40]	; 0x28
    8d4c:	2900      	cmp	r1, #0
    8d4e:	f000 81f5 	beq.w	913c <_dtoa_r+0xc0c>
    8d52:	f1b9 0f00 	cmp.w	r9, #0
    8d56:	f2c0 80df 	blt.w	8f18 <_dtoa_r+0x9e8>
    8d5a:	d105      	bne.n	8d68 <_dtoa_r+0x838>
    8d5c:	9901      	ldr	r1, [sp, #4]
    8d5e:	b919      	cbnz	r1, 8d68 <_dtoa_r+0x838>
    8d60:	990a      	ldr	r1, [sp, #40]	; 0x28
    8d62:	2900      	cmp	r1, #0
    8d64:	f000 80d8 	beq.w	8f18 <_dtoa_r+0x9e8>
    8d68:	2b00      	cmp	r3, #0
    8d6a:	f300 8141 	bgt.w	8ff0 <_dtoa_r+0xac0>
    8d6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8d70:	703a      	strb	r2, [r7, #0]
    8d72:	f107 0901 	add.w	r9, r7, #1
    8d76:	429f      	cmp	r7, r3
    8d78:	46cb      	mov	fp, r9
    8d7a:	f000 8146 	beq.w	900a <_dtoa_r+0xada>
    8d7e:	4629      	mov	r1, r5
    8d80:	2300      	movs	r3, #0
    8d82:	220a      	movs	r2, #10
    8d84:	4620      	mov	r0, r4
    8d86:	f7fe fffb 	bl	7d80 <__multadd>
    8d8a:	4546      	cmp	r6, r8
    8d8c:	4605      	mov	r5, r0
    8d8e:	4631      	mov	r1, r6
    8d90:	f04f 0300 	mov.w	r3, #0
    8d94:	f04f 020a 	mov.w	r2, #10
    8d98:	4620      	mov	r0, r4
    8d9a:	d00b      	beq.n	8db4 <_dtoa_r+0x884>
    8d9c:	f7fe fff0 	bl	7d80 <__multadd>
    8da0:	4641      	mov	r1, r8
    8da2:	4606      	mov	r6, r0
    8da4:	2300      	movs	r3, #0
    8da6:	220a      	movs	r2, #10
    8da8:	4620      	mov	r0, r4
    8daa:	f7fe ffe9 	bl	7d80 <__multadd>
    8dae:	464f      	mov	r7, r9
    8db0:	4680      	mov	r8, r0
    8db2:	e7a4      	b.n	8cfe <_dtoa_r+0x7ce>
    8db4:	f7fe ffe4 	bl	7d80 <__multadd>
    8db8:	464f      	mov	r7, r9
    8dba:	4606      	mov	r6, r0
    8dbc:	4680      	mov	r8, r0
    8dbe:	e79e      	b.n	8cfe <_dtoa_r+0x7ce>
    8dc0:	4601      	mov	r1, r0
    8dc2:	4620      	mov	r0, r4
    8dc4:	9206      	str	r2, [sp, #24]
    8dc6:	f7fe ffd1 	bl	7d6c <_Bfree>
    8dca:	2301      	movs	r3, #1
    8dcc:	9a06      	ldr	r2, [sp, #24]
    8dce:	e7c0      	b.n	8d52 <_dtoa_r+0x822>
    8dd0:	9905      	ldr	r1, [sp, #20]
    8dd2:	4628      	mov	r0, r5
    8dd4:	f7ff f9ac 	bl	8130 <__mcmp>
    8dd8:	2800      	cmp	r0, #0
    8dda:	f6bf adf8 	bge.w	89ce <_dtoa_r+0x49e>
    8dde:	4629      	mov	r1, r5
    8de0:	9d02      	ldr	r5, [sp, #8]
    8de2:	2300      	movs	r3, #0
    8de4:	3d01      	subs	r5, #1
    8de6:	220a      	movs	r2, #10
    8de8:	4620      	mov	r0, r4
    8dea:	9502      	str	r5, [sp, #8]
    8dec:	f7fe ffc8 	bl	7d80 <__multadd>
    8df0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8df2:	4605      	mov	r5, r0
    8df4:	2b00      	cmp	r3, #0
    8df6:	f47f af60 	bne.w	8cba <_dtoa_r+0x78a>
    8dfa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    8dfc:	2b00      	cmp	r3, #0
    8dfe:	f340 81ad 	ble.w	915c <_dtoa_r+0xc2c>
    8e02:	461f      	mov	r7, r3
    8e04:	e5ea      	b.n	89dc <_dtoa_r+0x4ac>
    8e06:	9d07      	ldr	r5, [sp, #28]
    8e08:	e59a      	b.n	8940 <_dtoa_r+0x410>
    8e0a:	bf00      	nop
    8e0c:	200002e8 	.word	0x200002e8
    8e10:	200002c0 	.word	0x200002c0
    8e14:	9b01      	ldr	r3, [sp, #4]
    8e16:	2b02      	cmp	r3, #2
    8e18:	f77f addc 	ble.w	89d4 <_dtoa_r+0x4a4>
    8e1c:	2f00      	cmp	r7, #0
    8e1e:	f040 8169 	bne.w	90f4 <_dtoa_r+0xbc4>
    8e22:	463b      	mov	r3, r7
    8e24:	9905      	ldr	r1, [sp, #20]
    8e26:	2205      	movs	r2, #5
    8e28:	4620      	mov	r0, r4
    8e2a:	f7fe ffa9 	bl	7d80 <__multadd>
    8e2e:	4601      	mov	r1, r0
    8e30:	9005      	str	r0, [sp, #20]
    8e32:	4628      	mov	r0, r5
    8e34:	f7ff f97c 	bl	8130 <__mcmp>
    8e38:	2800      	cmp	r0, #0
    8e3a:	9507      	str	r5, [sp, #28]
    8e3c:	f77f af1b 	ble.w	8c76 <_dtoa_r+0x746>
    8e40:	9a02      	ldr	r2, [sp, #8]
    8e42:	9908      	ldr	r1, [sp, #32]
    8e44:	2331      	movs	r3, #49	; 0x31
    8e46:	3201      	adds	r2, #1
    8e48:	9202      	str	r2, [sp, #8]
    8e4a:	700b      	strb	r3, [r1, #0]
    8e4c:	f101 0b01 	add.w	fp, r1, #1
    8e50:	e716      	b.n	8c80 <_dtoa_r+0x750>
    8e52:	9a02      	ldr	r2, [sp, #8]
    8e54:	3201      	adds	r2, #1
    8e56:	9202      	str	r2, [sp, #8]
    8e58:	9a08      	ldr	r2, [sp, #32]
    8e5a:	2331      	movs	r3, #49	; 0x31
    8e5c:	7013      	strb	r3, [r2, #0]
    8e5e:	e5fd      	b.n	8a5c <_dtoa_r+0x52c>
    8e60:	2301      	movs	r3, #1
    8e62:	9309      	str	r3, [sp, #36]	; 0x24
    8e64:	e61b      	b.n	8a9e <_dtoa_r+0x56e>
    8e66:	f1ba 0f00 	cmp.w	sl, #0
    8e6a:	f47f ad7c 	bne.w	8966 <_dtoa_r+0x436>
    8e6e:	f3cb 0313 	ubfx	r3, fp, #0, #20
    8e72:	2b00      	cmp	r3, #0
    8e74:	f040 811b 	bne.w	90ae <_dtoa_r+0xb7e>
    8e78:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
    8e7c:	0d1b      	lsrs	r3, r3, #20
    8e7e:	051b      	lsls	r3, r3, #20
    8e80:	2b00      	cmp	r3, #0
    8e82:	f000 8154 	beq.w	912e <_dtoa_r+0xbfe>
    8e86:	9b06      	ldr	r3, [sp, #24]
    8e88:	3301      	adds	r3, #1
    8e8a:	9306      	str	r3, [sp, #24]
    8e8c:	2301      	movs	r3, #1
    8e8e:	f109 0901 	add.w	r9, r9, #1
    8e92:	9307      	str	r3, [sp, #28]
    8e94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8e96:	2001      	movs	r0, #1
    8e98:	2b00      	cmp	r3, #0
    8e9a:	f43f ad6f 	beq.w	897c <_dtoa_r+0x44c>
    8e9e:	e564      	b.n	896a <_dtoa_r+0x43a>
    8ea0:	ee07 1a90 	vmov	s15, r1
    8ea4:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    8ea8:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    8eac:	eea4 7b06 	vfma.f64	d7, d4, d6
    8eb0:	ec53 2b17 	vmov	r2, r3, d7
    8eb4:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    8eb8:	ec43 2b16 	vmov	d6, r2, r3
    8ebc:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    8ec0:	ee34 7b47 	vsub.f64	d7, d4, d7
    8ec4:	eeb4 7bc6 	vcmpe.f64	d7, d6
    8ec8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8ecc:	f300 80dd 	bgt.w	908a <_dtoa_r+0xb5a>
    8ed0:	eeb1 6b46 	vneg.f64	d6, d6
    8ed4:	eeb4 7bc6 	vcmpe.f64	d7, d6
    8ed8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8edc:	d546      	bpl.n	8f6c <_dtoa_r+0xa3c>
    8ede:	2300      	movs	r3, #0
    8ee0:	9305      	str	r3, [sp, #20]
    8ee2:	461e      	mov	r6, r3
    8ee4:	e6c7      	b.n	8c76 <_dtoa_r+0x746>
    8ee6:	9808      	ldr	r0, [sp, #32]
    8ee8:	f7ff bb59 	b.w	859e <_dtoa_r+0x6e>
    8eec:	9b05      	ldr	r3, [sp, #20]
    8eee:	990b      	ldr	r1, [sp, #44]	; 0x2c
    8ef0:	9205      	str	r2, [sp, #20]
    8ef2:	1ad3      	subs	r3, r2, r3
    8ef4:	4419      	add	r1, r3
    8ef6:	2300      	movs	r3, #0
    8ef8:	910b      	str	r1, [sp, #44]	; 0x2c
    8efa:	930e      	str	r3, [sp, #56]	; 0x38
    8efc:	e4a1      	b.n	8842 <_dtoa_r+0x312>
    8efe:	ed9d 5b0e 	vldr	d5, [sp, #56]	; 0x38
    8f02:	2102      	movs	r1, #2
    8f04:	e60a      	b.n	8b1c <_dtoa_r+0x5ec>
    8f06:	463d      	mov	r5, r7
    8f08:	2100      	movs	r1, #0
    8f0a:	6461      	str	r1, [r4, #68]	; 0x44
    8f0c:	e5df      	b.n	8ace <_dtoa_r+0x59e>
    8f0e:	2501      	movs	r5, #1
    8f10:	950d      	str	r5, [sp, #52]	; 0x34
    8f12:	462f      	mov	r7, r5
    8f14:	46a8      	mov	r8, r5
    8f16:	e7f7      	b.n	8f08 <_dtoa_r+0x9d8>
    8f18:	2b00      	cmp	r3, #0
    8f1a:	4691      	mov	r9, r2
    8f1c:	dd11      	ble.n	8f42 <_dtoa_r+0xa12>
    8f1e:	4629      	mov	r1, r5
    8f20:	2201      	movs	r2, #1
    8f22:	4620      	mov	r0, r4
    8f24:	f7ff f8ac 	bl	8080 <__lshift>
    8f28:	9905      	ldr	r1, [sp, #20]
    8f2a:	4605      	mov	r5, r0
    8f2c:	f7ff f900 	bl	8130 <__mcmp>
    8f30:	2800      	cmp	r0, #0
    8f32:	f340 810c 	ble.w	914e <_dtoa_r+0xc1e>
    8f36:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
    8f3a:	f000 80dd 	beq.w	90f8 <_dtoa_r+0xbc8>
    8f3e:	f10a 0931 	add.w	r9, sl, #49	; 0x31
    8f42:	46b2      	mov	sl, r6
    8f44:	f887 9000 	strb.w	r9, [r7]
    8f48:	f107 0b01 	add.w	fp, r7, #1
    8f4c:	4646      	mov	r6, r8
    8f4e:	9507      	str	r5, [sp, #28]
    8f50:	e584      	b.n	8a5c <_dtoa_r+0x52c>
    8f52:	d104      	bne.n	8f5e <_dtoa_r+0xa2e>
    8f54:	f019 0f01 	tst.w	r9, #1
    8f58:	d001      	beq.n	8f5e <_dtoa_r+0xa2e>
    8f5a:	e56e      	b.n	8a3a <_dtoa_r+0x50a>
    8f5c:	4693      	mov	fp, r2
    8f5e:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    8f62:	2b30      	cmp	r3, #48	; 0x30
    8f64:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    8f68:	d0f8      	beq.n	8f5c <_dtoa_r+0xa2c>
    8f6a:	e577      	b.n	8a5c <_dtoa_r+0x52c>
    8f6c:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
    8f70:	f7ff bbdb 	b.w	872a <_dtoa_r+0x1fa>
    8f74:	9b02      	ldr	r3, [sp, #8]
    8f76:	425b      	negs	r3, r3
    8f78:	2b00      	cmp	r3, #0
    8f7a:	f000 809b 	beq.w	90b4 <_dtoa_r+0xb84>
    8f7e:	4a8b      	ldr	r2, [pc, #556]	; (91ac <_dtoa_r+0xc7c>)
    8f80:	f003 010f 	and.w	r1, r3, #15
    8f84:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
    8f88:	ed92 7b00 	vldr	d7, [r2]
    8f8c:	ed9d 6b0e 	vldr	d6, [sp, #56]	; 0x38
    8f90:	111b      	asrs	r3, r3, #4
    8f92:	ee26 4b07 	vmul.f64	d4, d6, d7
    8f96:	f000 80e6 	beq.w	9166 <_dtoa_r+0xc36>
    8f9a:	4a85      	ldr	r2, [pc, #532]	; (91b0 <_dtoa_r+0xc80>)
    8f9c:	2102      	movs	r1, #2
    8f9e:	07d8      	lsls	r0, r3, #31
    8fa0:	d504      	bpl.n	8fac <_dtoa_r+0xa7c>
    8fa2:	ed92 7b00 	vldr	d7, [r2]
    8fa6:	3101      	adds	r1, #1
    8fa8:	ee24 4b07 	vmul.f64	d4, d4, d7
    8fac:	105b      	asrs	r3, r3, #1
    8fae:	f102 0208 	add.w	r2, r2, #8
    8fb2:	d1f4      	bne.n	8f9e <_dtoa_r+0xa6e>
    8fb4:	e5c1      	b.n	8b3a <_dtoa_r+0x60a>
    8fb6:	9908      	ldr	r1, [sp, #32]
    8fb8:	2230      	movs	r2, #48	; 0x30
    8fba:	700a      	strb	r2, [r1, #0]
    8fbc:	9a02      	ldr	r2, [sp, #8]
    8fbe:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    8fc2:	3201      	adds	r2, #1
    8fc4:	9202      	str	r2, [sp, #8]
    8fc6:	e417      	b.n	87f8 <_dtoa_r+0x2c8>
    8fc8:	6871      	ldr	r1, [r6, #4]
    8fca:	4620      	mov	r0, r4
    8fcc:	f7fe fea8 	bl	7d20 <_Balloc>
    8fd0:	6933      	ldr	r3, [r6, #16]
    8fd2:	1c9a      	adds	r2, r3, #2
    8fd4:	4680      	mov	r8, r0
    8fd6:	0092      	lsls	r2, r2, #2
    8fd8:	f106 010c 	add.w	r1, r6, #12
    8fdc:	300c      	adds	r0, #12
    8fde:	f7fd fde1 	bl	6ba4 <memcpy>
    8fe2:	4641      	mov	r1, r8
    8fe4:	2201      	movs	r2, #1
    8fe6:	4620      	mov	r0, r4
    8fe8:	f7ff f84a 	bl	8080 <__lshift>
    8fec:	4680      	mov	r8, r0
    8fee:	e67e      	b.n	8cee <_dtoa_r+0x7be>
    8ff0:	2a39      	cmp	r2, #57	; 0x39
    8ff2:	f000 8081 	beq.w	90f8 <_dtoa_r+0xbc8>
    8ff6:	f102 0901 	add.w	r9, r2, #1
    8ffa:	46b2      	mov	sl, r6
    8ffc:	f887 9000 	strb.w	r9, [r7]
    9000:	f107 0b01 	add.w	fp, r7, #1
    9004:	4646      	mov	r6, r8
    9006:	9507      	str	r5, [sp, #28]
    9008:	e528      	b.n	8a5c <_dtoa_r+0x52c>
    900a:	46b2      	mov	sl, r6
    900c:	4691      	mov	r9, r2
    900e:	4646      	mov	r6, r8
    9010:	e507      	b.n	8a22 <_dtoa_r+0x4f2>
    9012:	4866      	ldr	r0, [pc, #408]	; (91ac <_dtoa_r+0xc7c>)
    9014:	eebd 6bc4 	vcvt.s32.f64	s12, d4
    9018:	1e4d      	subs	r5, r1, #1
    901a:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
    901e:	ec43 2b17 	vmov	d7, r2, r3
    9022:	ed90 3b00 	vldr	d3, [r0]
    9026:	ee16 3a10 	vmov	r3, s12
    902a:	ee23 3b07 	vmul.f64	d3, d3, d7
    902e:	9808      	ldr	r0, [sp, #32]
    9030:	3330      	adds	r3, #48	; 0x30
    9032:	2901      	cmp	r1, #1
    9034:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    9038:	7003      	strb	r3, [r0, #0]
    903a:	f100 0b01 	add.w	fp, r0, #1
    903e:	ee34 7b46 	vsub.f64	d7, d4, d6
    9042:	d014      	beq.n	906e <_dtoa_r+0xb3e>
    9044:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    9048:	9b08      	ldr	r3, [sp, #32]
    904a:	4419      	add	r1, r3
    904c:	465b      	mov	r3, fp
    904e:	ee27 7b05 	vmul.f64	d7, d7, d5
    9052:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    9056:	ee16 2a10 	vmov	r2, s12
    905a:	3230      	adds	r2, #48	; 0x30
    905c:	f803 2b01 	strb.w	r2, [r3], #1
    9060:	4299      	cmp	r1, r3
    9062:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    9066:	ee37 7b46 	vsub.f64	d7, d7, d6
    906a:	d1f0      	bne.n	904e <_dtoa_r+0xb1e>
    906c:	44ab      	add	fp, r5
    906e:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
    9072:	ee33 5b06 	vadd.f64	d5, d3, d6
    9076:	eeb4 5bc7 	vcmpe.f64	d5, d7
    907a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    907e:	d543      	bpl.n	9108 <_dtoa_r+0xbd8>
    9080:	9602      	str	r6, [sp, #8]
    9082:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    9086:	f7ff bbaa 	b.w	87de <_dtoa_r+0x2ae>
    908a:	2300      	movs	r3, #0
    908c:	9305      	str	r3, [sp, #20]
    908e:	461e      	mov	r6, r3
    9090:	e6d6      	b.n	8e40 <_dtoa_r+0x910>
    9092:	1bdb      	subs	r3, r3, r7
    9094:	930a      	str	r3, [sp, #40]	; 0x28
    9096:	2300      	movs	r3, #0
    9098:	f7ff bbd9 	b.w	884e <_dtoa_r+0x31e>
    909c:	9a05      	ldr	r2, [sp, #20]
    909e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    90a0:	920e      	str	r2, [sp, #56]	; 0x38
    90a2:	9a06      	ldr	r2, [sp, #24]
    90a4:	920a      	str	r2, [sp, #40]	; 0x28
    90a6:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    90aa:	f7ff bbd0 	b.w	884e <_dtoa_r+0x31e>
    90ae:	2300      	movs	r3, #0
    90b0:	9307      	str	r3, [sp, #28]
    90b2:	e6ef      	b.n	8e94 <_dtoa_r+0x964>
    90b4:	ed9d 4b0e 	vldr	d4, [sp, #56]	; 0x38
    90b8:	2102      	movs	r1, #2
    90ba:	e53e      	b.n	8b3a <_dtoa_r+0x60a>
    90bc:	2f00      	cmp	r7, #0
    90be:	f43f aeef 	beq.w	8ea0 <_dtoa_r+0x970>
    90c2:	980d      	ldr	r0, [sp, #52]	; 0x34
    90c4:	2800      	cmp	r0, #0
    90c6:	f77f af51 	ble.w	8f6c <_dtoa_r+0xa3c>
    90ca:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    90ce:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    90d2:	3101      	adds	r1, #1
    90d4:	ee06 1a90 	vmov	s13, r1
    90d8:	ee24 4b05 	vmul.f64	d4, d4, d5
    90dc:	9b02      	ldr	r3, [sp, #8]
    90de:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    90e2:	1e5e      	subs	r6, r3, #1
    90e4:	eea4 7b06 	vfma.f64	d7, d4, d6
    90e8:	ec53 2b17 	vmov	r2, r3, d7
    90ec:	4601      	mov	r1, r0
    90ee:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    90f2:	e53d      	b.n	8b70 <_dtoa_r+0x640>
    90f4:	9507      	str	r5, [sp, #28]
    90f6:	e5be      	b.n	8c76 <_dtoa_r+0x746>
    90f8:	2239      	movs	r2, #57	; 0x39
    90fa:	46b2      	mov	sl, r6
    90fc:	9507      	str	r5, [sp, #28]
    90fe:	4646      	mov	r6, r8
    9100:	703a      	strb	r2, [r7, #0]
    9102:	f107 0b01 	add.w	fp, r7, #1
    9106:	e49a      	b.n	8a3e <_dtoa_r+0x50e>
    9108:	ee36 6b43 	vsub.f64	d6, d6, d3
    910c:	eeb4 6bc7 	vcmpe.f64	d6, d7
    9110:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9114:	dc01      	bgt.n	911a <_dtoa_r+0xbea>
    9116:	e729      	b.n	8f6c <_dtoa_r+0xa3c>
    9118:	4693      	mov	fp, r2
    911a:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    911e:	2b30      	cmp	r3, #48	; 0x30
    9120:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    9124:	d0f8      	beq.n	9118 <_dtoa_r+0xbe8>
    9126:	e57a      	b.n	8c1e <_dtoa_r+0x6ee>
    9128:	9602      	str	r6, [sp, #8]
    912a:	f7ff bb58 	b.w	87de <_dtoa_r+0x2ae>
    912e:	9307      	str	r3, [sp, #28]
    9130:	e6b0      	b.n	8e94 <_dtoa_r+0x964>
    9132:	f1ba 0f00 	cmp.w	sl, #0
    9136:	f47f adbc 	bne.w	8cb2 <_dtoa_r+0x782>
    913a:	e698      	b.n	8e6e <_dtoa_r+0x93e>
    913c:	2a39      	cmp	r2, #57	; 0x39
    913e:	46cb      	mov	fp, r9
    9140:	4691      	mov	r9, r2
    9142:	d0d9      	beq.n	90f8 <_dtoa_r+0xbc8>
    9144:	f1bb 0f00 	cmp.w	fp, #0
    9148:	f73f aef9 	bgt.w	8f3e <_dtoa_r+0xa0e>
    914c:	e6f9      	b.n	8f42 <_dtoa_r+0xa12>
    914e:	f47f aef8 	bne.w	8f42 <_dtoa_r+0xa12>
    9152:	f019 0f01 	tst.w	r9, #1
    9156:	f43f aef4 	beq.w	8f42 <_dtoa_r+0xa12>
    915a:	e6ec      	b.n	8f36 <_dtoa_r+0xa06>
    915c:	9b01      	ldr	r3, [sp, #4]
    915e:	2b02      	cmp	r3, #2
    9160:	dc08      	bgt.n	9174 <_dtoa_r+0xc44>
    9162:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    9164:	e43a      	b.n	89dc <_dtoa_r+0x4ac>
    9166:	2102      	movs	r1, #2
    9168:	e4e7      	b.n	8b3a <_dtoa_r+0x60a>
    916a:	9b01      	ldr	r3, [sp, #4]
    916c:	2b02      	cmp	r3, #2
    916e:	dc01      	bgt.n	9174 <_dtoa_r+0xc44>
    9170:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    9172:	e5ae      	b.n	8cd2 <_dtoa_r+0x7a2>
    9174:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    9176:	e651      	b.n	8e1c <_dtoa_r+0x8ec>
    9178:	2301      	movs	r3, #1
    917a:	930e      	str	r3, [sp, #56]	; 0x38
    917c:	f7ff baa1 	b.w	86c2 <_dtoa_r+0x192>
    9180:	f43f ac0f 	beq.w	89a2 <_dtoa_r+0x472>
    9184:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
    9188:	e404      	b.n	8994 <_dtoa_r+0x464>
    918a:	2500      	movs	r5, #0
    918c:	6465      	str	r5, [r4, #68]	; 0x44
    918e:	4629      	mov	r1, r5
    9190:	4620      	mov	r0, r4
    9192:	f7fe fdc5 	bl	7d20 <_Balloc>
    9196:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    919a:	2301      	movs	r3, #1
    919c:	9008      	str	r0, [sp, #32]
    919e:	46a8      	mov	r8, r5
    91a0:	6420      	str	r0, [r4, #64]	; 0x40
    91a2:	970d      	str	r7, [sp, #52]	; 0x34
    91a4:	9309      	str	r3, [sp, #36]	; 0x24
    91a6:	f7ff bac0 	b.w	872a <_dtoa_r+0x1fa>
    91aa:	bf00      	nop
    91ac:	200002e8 	.word	0x200002e8
    91b0:	200002c0 	.word	0x200002c0
    91b4:	00000000 	.word	0x00000000

000091b8 <_svfprintf_r>:
    91b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    91bc:	ed2d 8b06 	vpush	{d8-d10}
    91c0:	b0b9      	sub	sp, #228	; 0xe4
    91c2:	460c      	mov	r4, r1
    91c4:	9103      	str	r1, [sp, #12]
    91c6:	4692      	mov	sl, r2
    91c8:	9309      	str	r3, [sp, #36]	; 0x24
    91ca:	9005      	str	r0, [sp, #20]
    91cc:	f7fe fd44 	bl	7c58 <_localeconv_r>
    91d0:	6803      	ldr	r3, [r0, #0]
    91d2:	9310      	str	r3, [sp, #64]	; 0x40
    91d4:	4618      	mov	r0, r3
    91d6:	f7fe fa13 	bl	7600 <strlen>
    91da:	89a3      	ldrh	r3, [r4, #12]
    91dc:	900f      	str	r0, [sp, #60]	; 0x3c
    91de:	0619      	lsls	r1, r3, #24
    91e0:	d503      	bpl.n	91ea <_svfprintf_r+0x32>
    91e2:	6923      	ldr	r3, [r4, #16]
    91e4:	2b00      	cmp	r3, #0
    91e6:	f001 807d 	beq.w	a2e4 <_svfprintf_r+0x112c>
    91ea:	2300      	movs	r3, #0
    91ec:	ed9f 8ba4 	vldr	d8, [pc, #656]	; 9480 <_svfprintf_r+0x2c8>
    91f0:	ed9f 9ba5 	vldr	d9, [pc, #660]	; 9488 <_svfprintf_r+0x2d0>
    91f4:	930d      	str	r3, [sp, #52]	; 0x34
    91f6:	931d      	str	r3, [sp, #116]	; 0x74
    91f8:	931c      	str	r3, [sp, #112]	; 0x70
    91fa:	9311      	str	r3, [sp, #68]	; 0x44
    91fc:	9306      	str	r3, [sp, #24]
    91fe:	ab28      	add	r3, sp, #160	; 0xa0
    9200:	931b      	str	r3, [sp, #108]	; 0x6c
    9202:	4699      	mov	r9, r3
    9204:	f89a 3000 	ldrb.w	r3, [sl]
    9208:	4654      	mov	r4, sl
    920a:	b1eb      	cbz	r3, 9248 <_svfprintf_r+0x90>
    920c:	2b25      	cmp	r3, #37	; 0x25
    920e:	d102      	bne.n	9216 <_svfprintf_r+0x5e>
    9210:	e01a      	b.n	9248 <_svfprintf_r+0x90>
    9212:	2b25      	cmp	r3, #37	; 0x25
    9214:	d003      	beq.n	921e <_svfprintf_r+0x66>
    9216:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    921a:	2b00      	cmp	r3, #0
    921c:	d1f9      	bne.n	9212 <_svfprintf_r+0x5a>
    921e:	ebca 0504 	rsb	r5, sl, r4
    9222:	b18d      	cbz	r5, 9248 <_svfprintf_r+0x90>
    9224:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    9226:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    9228:	f8c9 a000 	str.w	sl, [r9]
    922c:	3301      	adds	r3, #1
    922e:	442a      	add	r2, r5
    9230:	2b07      	cmp	r3, #7
    9232:	f8c9 5004 	str.w	r5, [r9, #4]
    9236:	921d      	str	r2, [sp, #116]	; 0x74
    9238:	931c      	str	r3, [sp, #112]	; 0x70
    923a:	f300 80a3 	bgt.w	9384 <_svfprintf_r+0x1cc>
    923e:	f109 0908 	add.w	r9, r9, #8
    9242:	9b06      	ldr	r3, [sp, #24]
    9244:	442b      	add	r3, r5
    9246:	9306      	str	r3, [sp, #24]
    9248:	7823      	ldrb	r3, [r4, #0]
    924a:	2b00      	cmp	r3, #0
    924c:	f000 80a3 	beq.w	9396 <_svfprintf_r+0x1de>
    9250:	2300      	movs	r3, #0
    9252:	461a      	mov	r2, r3
    9254:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9258:	4619      	mov	r1, r3
    925a:	9307      	str	r3, [sp, #28]
    925c:	469b      	mov	fp, r3
    925e:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    9262:	7863      	ldrb	r3, [r4, #1]
    9264:	f104 0a01 	add.w	sl, r4, #1
    9268:	4645      	mov	r5, r8
    926a:	f10a 0a01 	add.w	sl, sl, #1
    926e:	f1a3 0020 	sub.w	r0, r3, #32
    9272:	2858      	cmp	r0, #88	; 0x58
    9274:	f200 83f8 	bhi.w	9a68 <_svfprintf_r+0x8b0>
    9278:	e8df f010 	tbh	[pc, r0, lsl #1]
    927c:	03f60363 	.word	0x03f60363
    9280:	036b03f6 	.word	0x036b03f6
    9284:	03f603f6 	.word	0x03f603f6
    9288:	03f603f6 	.word	0x03f603f6
    928c:	03f603f6 	.word	0x03f603f6
    9290:	037e0370 	.word	0x037e0370
    9294:	005d03f6 	.word	0x005d03f6
    9298:	03f600df 	.word	0x03f600df
    929c:	010c00fb 	.word	0x010c00fb
    92a0:	010c010c 	.word	0x010c010c
    92a4:	010c010c 	.word	0x010c010c
    92a8:	010c010c 	.word	0x010c010c
    92ac:	010c010c 	.word	0x010c010c
    92b0:	03f603f6 	.word	0x03f603f6
    92b4:	03f603f6 	.word	0x03f603f6
    92b8:	03f603f6 	.word	0x03f603f6
    92bc:	03f603f6 	.word	0x03f603f6
    92c0:	03f603f6 	.word	0x03f603f6
    92c4:	015e011c 	.word	0x015e011c
    92c8:	015e03f6 	.word	0x015e03f6
    92cc:	03f603f6 	.word	0x03f603f6
    92d0:	03f603f6 	.word	0x03f603f6
    92d4:	03f602a1 	.word	0x03f602a1
    92d8:	02a603f6 	.word	0x02a603f6
    92dc:	03f603f6 	.word	0x03f603f6
    92e0:	03f603f6 	.word	0x03f603f6
    92e4:	02d803f6 	.word	0x02d803f6
    92e8:	03f603f6 	.word	0x03f603f6
    92ec:	03f60305 	.word	0x03f60305
    92f0:	03f603f6 	.word	0x03f603f6
    92f4:	03f603f6 	.word	0x03f603f6
    92f8:	03f603f6 	.word	0x03f603f6
    92fc:	03f603f6 	.word	0x03f603f6
    9300:	034303f6 	.word	0x034303f6
    9304:	015e0356 	.word	0x015e0356
    9308:	015e015e 	.word	0x015e015e
    930c:	0356035e 	.word	0x0356035e
    9310:	03f603f6 	.word	0x03f603f6
    9314:	03f603a4 	.word	0x03f603a4
    9318:	00a203b1 	.word	0x00a203b1
    931c:	03c30062 	.word	0x03c30062
    9320:	03c803f6 	.word	0x03c803f6
    9324:	038303f6 	.word	0x038303f6
    9328:	03f603f6 	.word	0x03f603f6
    932c:	038b      	.short	0x038b
    932e:	9807      	ldr	r0, [sp, #28]
    9330:	9309      	str	r3, [sp, #36]	; 0x24
    9332:	4240      	negs	r0, r0
    9334:	9007      	str	r0, [sp, #28]
    9336:	f04b 0b04 	orr.w	fp, fp, #4
    933a:	f89a 3000 	ldrb.w	r3, [sl]
    933e:	e794      	b.n	926a <_svfprintf_r+0xb2>
    9340:	46a8      	mov	r8, r5
    9342:	9809      	ldr	r0, [sp, #36]	; 0x24
    9344:	2100      	movs	r1, #0
    9346:	2330      	movs	r3, #48	; 0x30
    9348:	2278      	movs	r2, #120	; 0x78
    934a:	4588      	cmp	r8, r1
    934c:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    9350:	6804      	ldr	r4, [r0, #0]
    9352:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    9356:	f100 0704 	add.w	r7, r0, #4
    935a:	f04f 0500 	mov.w	r5, #0
    935e:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    9362:	f04b 0302 	orr.w	r3, fp, #2
    9366:	f2c0 839c 	blt.w	9aa2 <_svfprintf_r+0x8ea>
    936a:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    936e:	f043 0b02 	orr.w	fp, r3, #2
    9372:	ea54 0305 	orrs.w	r3, r4, r5
    9376:	9709      	str	r7, [sp, #36]	; 0x24
    9378:	f000 8369 	beq.w	9a4e <_svfprintf_r+0x896>
    937c:	460f      	mov	r7, r1
    937e:	920c      	str	r2, [sp, #48]	; 0x30
    9380:	4843      	ldr	r0, [pc, #268]	; (9490 <_svfprintf_r+0x2d8>)
    9382:	e2ae      	b.n	98e2 <_svfprintf_r+0x72a>
    9384:	aa1b      	add	r2, sp, #108	; 0x6c
    9386:	9903      	ldr	r1, [sp, #12]
    9388:	9805      	ldr	r0, [sp, #20]
    938a:	f001 f9cd 	bl	a728 <__ssprint_r>
    938e:	b948      	cbnz	r0, 93a4 <_svfprintf_r+0x1ec>
    9390:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9394:	e755      	b.n	9242 <_svfprintf_r+0x8a>
    9396:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9398:	b123      	cbz	r3, 93a4 <_svfprintf_r+0x1ec>
    939a:	9805      	ldr	r0, [sp, #20]
    939c:	9903      	ldr	r1, [sp, #12]
    939e:	aa1b      	add	r2, sp, #108	; 0x6c
    93a0:	f001 f9c2 	bl	a728 <__ssprint_r>
    93a4:	9b03      	ldr	r3, [sp, #12]
    93a6:	899b      	ldrh	r3, [r3, #12]
    93a8:	f013 0f40 	tst.w	r3, #64	; 0x40
    93ac:	9b06      	ldr	r3, [sp, #24]
    93ae:	bf18      	it	ne
    93b0:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    93b4:	4618      	mov	r0, r3
    93b6:	b039      	add	sp, #228	; 0xe4
    93b8:	ecbd 8b06 	vpop	{d8-d10}
    93bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    93c0:	930c      	str	r3, [sp, #48]	; 0x30
    93c2:	46a8      	mov	r8, r5
    93c4:	2a00      	cmp	r2, #0
    93c6:	f041 819a 	bne.w	a6fe <_svfprintf_r+0x1546>
    93ca:	f01b 0320 	ands.w	r3, fp, #32
    93ce:	f000 8206 	beq.w	97de <_svfprintf_r+0x626>
    93d2:	9f09      	ldr	r7, [sp, #36]	; 0x24
    93d4:	3707      	adds	r7, #7
    93d6:	f027 0307 	bic.w	r3, r7, #7
    93da:	2700      	movs	r7, #0
    93dc:	f103 0208 	add.w	r2, r3, #8
    93e0:	45b8      	cmp	r8, r7
    93e2:	9209      	str	r2, [sp, #36]	; 0x24
    93e4:	e9d3 4500 	ldrd	r4, r5, [r3]
    93e8:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    93ec:	f2c0 865e 	blt.w	a0ac <_svfprintf_r+0xef4>
    93f0:	ea54 0305 	orrs.w	r3, r4, r5
    93f4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    93f8:	f000 834b 	beq.w	9a92 <_svfprintf_r+0x8da>
    93fc:	ae28      	add	r6, sp, #160	; 0xa0
    93fe:	08e2      	lsrs	r2, r4, #3
    9400:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
    9404:	08e9      	lsrs	r1, r5, #3
    9406:	f004 0307 	and.w	r3, r4, #7
    940a:	460d      	mov	r5, r1
    940c:	4614      	mov	r4, r2
    940e:	3330      	adds	r3, #48	; 0x30
    9410:	ea54 0205 	orrs.w	r2, r4, r5
    9414:	f806 3d01 	strb.w	r3, [r6, #-1]!
    9418:	d1f1      	bne.n	93fe <_svfprintf_r+0x246>
    941a:	f01b 0f01 	tst.w	fp, #1
    941e:	f000 8227 	beq.w	9870 <_svfprintf_r+0x6b8>
    9422:	2b30      	cmp	r3, #48	; 0x30
    9424:	f000 8224 	beq.w	9870 <_svfprintf_r+0x6b8>
    9428:	2230      	movs	r2, #48	; 0x30
    942a:	1e73      	subs	r3, r6, #1
    942c:	f806 2c01 	strb.w	r2, [r6, #-1]
    9430:	aa28      	add	r2, sp, #160	; 0xa0
    9432:	1ad2      	subs	r2, r2, r3
    9434:	9208      	str	r2, [sp, #32]
    9436:	461e      	mov	r6, r3
    9438:	e21d      	b.n	9876 <_svfprintf_r+0x6be>
    943a:	f89a 3000 	ldrb.w	r3, [sl]
    943e:	2b2a      	cmp	r3, #42	; 0x2a
    9440:	f10a 0401 	add.w	r4, sl, #1
    9444:	f001 812f 	beq.w	a6a6 <_svfprintf_r+0x14ee>
    9448:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    944c:	2809      	cmp	r0, #9
    944e:	bf98      	it	ls
    9450:	2500      	movls	r5, #0
    9452:	f201 80d5 	bhi.w	a600 <_svfprintf_r+0x1448>
    9456:	f814 3b01 	ldrb.w	r3, [r4], #1
    945a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    945e:	eb00 0545 	add.w	r5, r0, r5, lsl #1
    9462:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    9466:	2809      	cmp	r0, #9
    9468:	d9f5      	bls.n	9456 <_svfprintf_r+0x29e>
    946a:	ea45 75e5 	orr.w	r5, r5, r5, asr #31
    946e:	46a2      	mov	sl, r4
    9470:	e6fd      	b.n	926e <_svfprintf_r+0xb6>
    9472:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
    9476:	f89a 3000 	ldrb.w	r3, [sl]
    947a:	e6f6      	b.n	926a <_svfprintf_r+0xb2>
    947c:	f3af 8000 	nop.w
	...
    9488:	ffffffff 	.word	0xffffffff
    948c:	7fefffff 	.word	0x7fefffff
    9490:	20000f8c 	.word	0x20000f8c
    9494:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    9498:	2300      	movs	r3, #0
    949a:	461c      	mov	r4, r3
    949c:	f81a 3b01 	ldrb.w	r3, [sl], #1
    94a0:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    94a4:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    94a8:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    94ac:	2809      	cmp	r0, #9
    94ae:	d9f5      	bls.n	949c <_svfprintf_r+0x2e4>
    94b0:	9407      	str	r4, [sp, #28]
    94b2:	e6dc      	b.n	926e <_svfprintf_r+0xb6>
    94b4:	930c      	str	r3, [sp, #48]	; 0x30
    94b6:	46a8      	mov	r8, r5
    94b8:	2a00      	cmp	r2, #0
    94ba:	f041 812c 	bne.w	a716 <_svfprintf_r+0x155e>
    94be:	f04b 0b10 	orr.w	fp, fp, #16
    94c2:	f01b 0f20 	tst.w	fp, #32
    94c6:	f000 8503 	beq.w	9ed0 <_svfprintf_r+0xd18>
    94ca:	9f09      	ldr	r7, [sp, #36]	; 0x24
    94cc:	3707      	adds	r7, #7
    94ce:	f027 0707 	bic.w	r7, r7, #7
    94d2:	e9d7 2300 	ldrd	r2, r3, [r7]
    94d6:	f107 0108 	add.w	r1, r7, #8
    94da:	9109      	str	r1, [sp, #36]	; 0x24
    94dc:	4614      	mov	r4, r2
    94de:	461d      	mov	r5, r3
    94e0:	2a00      	cmp	r2, #0
    94e2:	f173 0300 	sbcs.w	r3, r3, #0
    94e6:	f2c0 8537 	blt.w	9f58 <_svfprintf_r+0xda0>
    94ea:	f1b8 0f00 	cmp.w	r8, #0
    94ee:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    94f2:	f2c0 81b5 	blt.w	9860 <_svfprintf_r+0x6a8>
    94f6:	ea54 0305 	orrs.w	r3, r4, r5
    94fa:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    94fe:	f000 83f6 	beq.w	9cee <_svfprintf_r+0xb36>
    9502:	2d00      	cmp	r5, #0
    9504:	bf08      	it	eq
    9506:	2c0a      	cmpeq	r4, #10
    9508:	f0c0 81ae 	bcc.w	9868 <_svfprintf_r+0x6b0>
    950c:	ae28      	add	r6, sp, #160	; 0xa0
    950e:	4620      	mov	r0, r4
    9510:	4629      	mov	r1, r5
    9512:	220a      	movs	r2, #10
    9514:	2300      	movs	r3, #0
    9516:	f7fc fe7d 	bl	6214 <__aeabi_uldivmod>
    951a:	3230      	adds	r2, #48	; 0x30
    951c:	f806 2d01 	strb.w	r2, [r6, #-1]!
    9520:	4620      	mov	r0, r4
    9522:	4629      	mov	r1, r5
    9524:	2300      	movs	r3, #0
    9526:	220a      	movs	r2, #10
    9528:	f7fc fe74 	bl	6214 <__aeabi_uldivmod>
    952c:	4604      	mov	r4, r0
    952e:	460d      	mov	r5, r1
    9530:	ea54 0305 	orrs.w	r3, r4, r5
    9534:	d1eb      	bne.n	950e <_svfprintf_r+0x356>
    9536:	e19b      	b.n	9870 <_svfprintf_r+0x6b8>
    9538:	930c      	str	r3, [sp, #48]	; 0x30
    953a:	46a8      	mov	r8, r5
    953c:	2a00      	cmp	r2, #0
    953e:	f041 80e6 	bne.w	a70e <_svfprintf_r+0x1556>
    9542:	9f09      	ldr	r7, [sp, #36]	; 0x24
    9544:	f01b 0f08 	tst.w	fp, #8
    9548:	f107 0707 	add.w	r7, r7, #7
    954c:	f000 8640 	beq.w	a1d0 <_svfprintf_r+0x1018>
    9550:	f027 0307 	bic.w	r3, r7, #7
    9554:	ed93 8b00 	vldr	d8, [r3]
    9558:	f103 0208 	add.w	r2, r3, #8
    955c:	9209      	str	r2, [sp, #36]	; 0x24
    955e:	eeb0 7bc8 	vabs.f64	d7, d8
    9562:	eeb4 7b49 	vcmp.f64	d7, d9
    9566:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    956a:	f340 85bc 	ble.w	a0e6 <_svfprintf_r+0xf2e>
    956e:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
    9572:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9576:	f100 87ca 	bmi.w	a50e <_svfprintf_r+0x1356>
    957a:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    957e:	4ea7      	ldr	r6, [pc, #668]	; (981c <_svfprintf_r+0x664>)
    9580:	4ba7      	ldr	r3, [pc, #668]	; (9820 <_svfprintf_r+0x668>)
    9582:	990c      	ldr	r1, [sp, #48]	; 0x30
    9584:	2203      	movs	r2, #3
    9586:	f04f 0800 	mov.w	r8, #0
    958a:	9204      	str	r2, [sp, #16]
    958c:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9590:	2947      	cmp	r1, #71	; 0x47
    9592:	bfd8      	it	le
    9594:	461e      	movle	r6, r3
    9596:	9208      	str	r2, [sp, #32]
    9598:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    959c:	b117      	cbz	r7, 95a4 <_svfprintf_r+0x3ec>
    959e:	9b04      	ldr	r3, [sp, #16]
    95a0:	3301      	adds	r3, #1
    95a2:	9304      	str	r3, [sp, #16]
    95a4:	f01b 0302 	ands.w	r3, fp, #2
    95a8:	930a      	str	r3, [sp, #40]	; 0x28
    95aa:	d002      	beq.n	95b2 <_svfprintf_r+0x3fa>
    95ac:	9b04      	ldr	r3, [sp, #16]
    95ae:	3302      	adds	r3, #2
    95b0:	9304      	str	r3, [sp, #16]
    95b2:	f01b 0384 	ands.w	r3, fp, #132	; 0x84
    95b6:	930b      	str	r3, [sp, #44]	; 0x2c
    95b8:	f040 8280 	bne.w	9abc <_svfprintf_r+0x904>
    95bc:	9b07      	ldr	r3, [sp, #28]
    95be:	9a04      	ldr	r2, [sp, #16]
    95c0:	1a9c      	subs	r4, r3, r2
    95c2:	2c00      	cmp	r4, #0
    95c4:	f340 827a 	ble.w	9abc <_svfprintf_r+0x904>
    95c8:	2c10      	cmp	r4, #16
    95ca:	991d      	ldr	r1, [sp, #116]	; 0x74
    95cc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    95ce:	4f95      	ldr	r7, [pc, #596]	; (9824 <_svfprintf_r+0x66c>)
    95d0:	dd23      	ble.n	961a <_svfprintf_r+0x462>
    95d2:	4648      	mov	r0, r9
    95d4:	2510      	movs	r5, #16
    95d6:	46c1      	mov	r9, r8
    95d8:	46b0      	mov	r8, r6
    95da:	9e05      	ldr	r6, [sp, #20]
    95dc:	e004      	b.n	95e8 <_svfprintf_r+0x430>
    95de:	3c10      	subs	r4, #16
    95e0:	2c10      	cmp	r4, #16
    95e2:	f100 0008 	add.w	r0, r0, #8
    95e6:	dd15      	ble.n	9614 <_svfprintf_r+0x45c>
    95e8:	3201      	adds	r2, #1
    95ea:	3110      	adds	r1, #16
    95ec:	2a07      	cmp	r2, #7
    95ee:	911d      	str	r1, [sp, #116]	; 0x74
    95f0:	921c      	str	r2, [sp, #112]	; 0x70
    95f2:	6007      	str	r7, [r0, #0]
    95f4:	6045      	str	r5, [r0, #4]
    95f6:	ddf2      	ble.n	95de <_svfprintf_r+0x426>
    95f8:	aa1b      	add	r2, sp, #108	; 0x6c
    95fa:	9903      	ldr	r1, [sp, #12]
    95fc:	4630      	mov	r0, r6
    95fe:	f001 f893 	bl	a728 <__ssprint_r>
    9602:	2800      	cmp	r0, #0
    9604:	f47f aece 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9608:	3c10      	subs	r4, #16
    960a:	2c10      	cmp	r4, #16
    960c:	991d      	ldr	r1, [sp, #116]	; 0x74
    960e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9610:	a828      	add	r0, sp, #160	; 0xa0
    9612:	dce9      	bgt.n	95e8 <_svfprintf_r+0x430>
    9614:	4646      	mov	r6, r8
    9616:	46c8      	mov	r8, r9
    9618:	4681      	mov	r9, r0
    961a:	3201      	adds	r2, #1
    961c:	1863      	adds	r3, r4, r1
    961e:	2a07      	cmp	r2, #7
    9620:	931d      	str	r3, [sp, #116]	; 0x74
    9622:	921c      	str	r2, [sp, #112]	; 0x70
    9624:	f8c9 7000 	str.w	r7, [r9]
    9628:	f8c9 4004 	str.w	r4, [r9, #4]
    962c:	f300 83e2 	bgt.w	9df4 <_svfprintf_r+0xc3c>
    9630:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9634:	f109 0908 	add.w	r9, r9, #8
    9638:	b177      	cbz	r7, 9658 <_svfprintf_r+0x4a0>
    963a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    963c:	3201      	adds	r2, #1
    963e:	3301      	adds	r3, #1
    9640:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
    9644:	2101      	movs	r1, #1
    9646:	2a07      	cmp	r2, #7
    9648:	931d      	str	r3, [sp, #116]	; 0x74
    964a:	921c      	str	r2, [sp, #112]	; 0x70
    964c:	e889 0003 	stmia.w	r9, {r0, r1}
    9650:	f300 835f 	bgt.w	9d12 <_svfprintf_r+0xb5a>
    9654:	f109 0908 	add.w	r9, r9, #8
    9658:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    965a:	b16a      	cbz	r2, 9678 <_svfprintf_r+0x4c0>
    965c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    965e:	3201      	adds	r2, #1
    9660:	3302      	adds	r3, #2
    9662:	a814      	add	r0, sp, #80	; 0x50
    9664:	2102      	movs	r1, #2
    9666:	2a07      	cmp	r2, #7
    9668:	931d      	str	r3, [sp, #116]	; 0x74
    966a:	921c      	str	r2, [sp, #112]	; 0x70
    966c:	e889 0003 	stmia.w	r9, {r0, r1}
    9670:	f300 835b 	bgt.w	9d2a <_svfprintf_r+0xb72>
    9674:	f109 0908 	add.w	r9, r9, #8
    9678:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    967a:	2a80      	cmp	r2, #128	; 0x80
    967c:	f000 827e 	beq.w	9b7c <_svfprintf_r+0x9c4>
    9680:	9a08      	ldr	r2, [sp, #32]
    9682:	ebc2 0408 	rsb	r4, r2, r8
    9686:	2c00      	cmp	r4, #0
    9688:	dd34      	ble.n	96f4 <_svfprintf_r+0x53c>
    968a:	2c10      	cmp	r4, #16
    968c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    968e:	4f66      	ldr	r7, [pc, #408]	; (9828 <_svfprintf_r+0x670>)
    9690:	dd23      	ble.n	96da <_svfprintf_r+0x522>
    9692:	4649      	mov	r1, r9
    9694:	f04f 0810 	mov.w	r8, #16
    9698:	46b1      	mov	r9, r6
    969a:	9d05      	ldr	r5, [sp, #20]
    969c:	9e03      	ldr	r6, [sp, #12]
    969e:	e004      	b.n	96aa <_svfprintf_r+0x4f2>
    96a0:	3c10      	subs	r4, #16
    96a2:	2c10      	cmp	r4, #16
    96a4:	f101 0108 	add.w	r1, r1, #8
    96a8:	dd15      	ble.n	96d6 <_svfprintf_r+0x51e>
    96aa:	3201      	adds	r2, #1
    96ac:	3310      	adds	r3, #16
    96ae:	2a07      	cmp	r2, #7
    96b0:	931d      	str	r3, [sp, #116]	; 0x74
    96b2:	921c      	str	r2, [sp, #112]	; 0x70
    96b4:	e881 0180 	stmia.w	r1, {r7, r8}
    96b8:	ddf2      	ble.n	96a0 <_svfprintf_r+0x4e8>
    96ba:	aa1b      	add	r2, sp, #108	; 0x6c
    96bc:	4631      	mov	r1, r6
    96be:	4628      	mov	r0, r5
    96c0:	f001 f832 	bl	a728 <__ssprint_r>
    96c4:	2800      	cmp	r0, #0
    96c6:	f47f ae6d 	bne.w	93a4 <_svfprintf_r+0x1ec>
    96ca:	3c10      	subs	r4, #16
    96cc:	2c10      	cmp	r4, #16
    96ce:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    96d0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    96d2:	a928      	add	r1, sp, #160	; 0xa0
    96d4:	dce9      	bgt.n	96aa <_svfprintf_r+0x4f2>
    96d6:	464e      	mov	r6, r9
    96d8:	4689      	mov	r9, r1
    96da:	3201      	adds	r2, #1
    96dc:	4423      	add	r3, r4
    96de:	2a07      	cmp	r2, #7
    96e0:	931d      	str	r3, [sp, #116]	; 0x74
    96e2:	921c      	str	r2, [sp, #112]	; 0x70
    96e4:	f8c9 7000 	str.w	r7, [r9]
    96e8:	f8c9 4004 	str.w	r4, [r9, #4]
    96ec:	f300 8305 	bgt.w	9cfa <_svfprintf_r+0xb42>
    96f0:	f109 0908 	add.w	r9, r9, #8
    96f4:	f41b 7f80 	tst.w	fp, #256	; 0x100
    96f8:	f040 81e2 	bne.w	9ac0 <_svfprintf_r+0x908>
    96fc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    96fe:	9808      	ldr	r0, [sp, #32]
    9700:	f8c9 6000 	str.w	r6, [r9]
    9704:	3201      	adds	r2, #1
    9706:	4403      	add	r3, r0
    9708:	2a07      	cmp	r2, #7
    970a:	931d      	str	r3, [sp, #116]	; 0x74
    970c:	f8c9 0004 	str.w	r0, [r9, #4]
    9710:	921c      	str	r2, [sp, #112]	; 0x70
    9712:	f300 82c2 	bgt.w	9c9a <_svfprintf_r+0xae2>
    9716:	f109 0908 	add.w	r9, r9, #8
    971a:	f01b 0f04 	tst.w	fp, #4
    971e:	d03e      	beq.n	979e <_svfprintf_r+0x5e6>
    9720:	9a07      	ldr	r2, [sp, #28]
    9722:	9904      	ldr	r1, [sp, #16]
    9724:	1a54      	subs	r4, r2, r1
    9726:	2c00      	cmp	r4, #0
    9728:	dd39      	ble.n	979e <_svfprintf_r+0x5e6>
    972a:	2c10      	cmp	r4, #16
    972c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    972e:	4f3d      	ldr	r7, [pc, #244]	; (9824 <_svfprintf_r+0x66c>)
    9730:	dd22      	ble.n	9778 <_svfprintf_r+0x5c0>
    9732:	2510      	movs	r5, #16
    9734:	9e05      	ldr	r6, [sp, #20]
    9736:	f8dd 800c 	ldr.w	r8, [sp, #12]
    973a:	e004      	b.n	9746 <_svfprintf_r+0x58e>
    973c:	3c10      	subs	r4, #16
    973e:	2c10      	cmp	r4, #16
    9740:	f109 0908 	add.w	r9, r9, #8
    9744:	dd18      	ble.n	9778 <_svfprintf_r+0x5c0>
    9746:	3201      	adds	r2, #1
    9748:	3310      	adds	r3, #16
    974a:	2a07      	cmp	r2, #7
    974c:	931d      	str	r3, [sp, #116]	; 0x74
    974e:	921c      	str	r2, [sp, #112]	; 0x70
    9750:	f8c9 7000 	str.w	r7, [r9]
    9754:	f8c9 5004 	str.w	r5, [r9, #4]
    9758:	ddf0      	ble.n	973c <_svfprintf_r+0x584>
    975a:	aa1b      	add	r2, sp, #108	; 0x6c
    975c:	4641      	mov	r1, r8
    975e:	4630      	mov	r0, r6
    9760:	f000 ffe2 	bl	a728 <__ssprint_r>
    9764:	2800      	cmp	r0, #0
    9766:	f47f ae1d 	bne.w	93a4 <_svfprintf_r+0x1ec>
    976a:	3c10      	subs	r4, #16
    976c:	2c10      	cmp	r4, #16
    976e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9770:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9772:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9776:	dce6      	bgt.n	9746 <_svfprintf_r+0x58e>
    9778:	3201      	adds	r2, #1
    977a:	4423      	add	r3, r4
    977c:	2a07      	cmp	r2, #7
    977e:	931d      	str	r3, [sp, #116]	; 0x74
    9780:	921c      	str	r2, [sp, #112]	; 0x70
    9782:	f8c9 7000 	str.w	r7, [r9]
    9786:	f8c9 4004 	str.w	r4, [r9, #4]
    978a:	dd08      	ble.n	979e <_svfprintf_r+0x5e6>
    978c:	aa1b      	add	r2, sp, #108	; 0x6c
    978e:	9903      	ldr	r1, [sp, #12]
    9790:	9805      	ldr	r0, [sp, #20]
    9792:	f000 ffc9 	bl	a728 <__ssprint_r>
    9796:	2800      	cmp	r0, #0
    9798:	f47f ae04 	bne.w	93a4 <_svfprintf_r+0x1ec>
    979c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    979e:	9a06      	ldr	r2, [sp, #24]
    97a0:	9907      	ldr	r1, [sp, #28]
    97a2:	9804      	ldr	r0, [sp, #16]
    97a4:	4281      	cmp	r1, r0
    97a6:	bfac      	ite	ge
    97a8:	1852      	addge	r2, r2, r1
    97aa:	1812      	addlt	r2, r2, r0
    97ac:	9206      	str	r2, [sp, #24]
    97ae:	2b00      	cmp	r3, #0
    97b0:	f040 827f 	bne.w	9cb2 <_svfprintf_r+0xafa>
    97b4:	2300      	movs	r3, #0
    97b6:	931c      	str	r3, [sp, #112]	; 0x70
    97b8:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    97bc:	e522      	b.n	9204 <_svfprintf_r+0x4c>
    97be:	f04b 0b08 	orr.w	fp, fp, #8
    97c2:	f89a 3000 	ldrb.w	r3, [sl]
    97c6:	e550      	b.n	926a <_svfprintf_r+0xb2>
    97c8:	930c      	str	r3, [sp, #48]	; 0x30
    97ca:	46a8      	mov	r8, r5
    97cc:	2a00      	cmp	r2, #0
    97ce:	f040 879a 	bne.w	a706 <_svfprintf_r+0x154e>
    97d2:	f04b 0b10 	orr.w	fp, fp, #16
    97d6:	f01b 0320 	ands.w	r3, fp, #32
    97da:	f47f adfa 	bne.w	93d2 <_svfprintf_r+0x21a>
    97de:	f01b 0210 	ands.w	r2, fp, #16
    97e2:	f040 8391 	bne.w	9f08 <_svfprintf_r+0xd50>
    97e6:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    97ea:	f000 838d 	beq.w	9f08 <_svfprintf_r+0xd50>
    97ee:	9909      	ldr	r1, [sp, #36]	; 0x24
    97f0:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    97f4:	460b      	mov	r3, r1
    97f6:	f1b8 0f00 	cmp.w	r8, #0
    97fa:	f103 0304 	add.w	r3, r3, #4
    97fe:	880c      	ldrh	r4, [r1, #0]
    9800:	f04f 0500 	mov.w	r5, #0
    9804:	f2c0 85ab 	blt.w	a35e <_svfprintf_r+0x11a6>
    9808:	ea54 0105 	orrs.w	r1, r4, r5
    980c:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9810:	9309      	str	r3, [sp, #36]	; 0x24
    9812:	f000 813e 	beq.w	9a92 <_svfprintf_r+0x8da>
    9816:	4617      	mov	r7, r2
    9818:	e5f0      	b.n	93fc <_svfprintf_r+0x244>
    981a:	bf00      	nop
    981c:	20000f6c 	.word	0x20000f6c
    9820:	20000f68 	.word	0x20000f68
    9824:	200006cc 	.word	0x200006cc
    9828:	2000114c 	.word	0x2000114c
    982c:	930c      	str	r3, [sp, #48]	; 0x30
    982e:	46a8      	mov	r8, r5
    9830:	2a00      	cmp	r2, #0
    9832:	f040 8759 	bne.w	a6e8 <_svfprintf_r+0x1530>
    9836:	f04b 0b10 	orr.w	fp, fp, #16
    983a:	f01b 0320 	ands.w	r3, fp, #32
    983e:	f000 82e7 	beq.w	9e10 <_svfprintf_r+0xc58>
    9842:	9f09      	ldr	r7, [sp, #36]	; 0x24
    9844:	3707      	adds	r7, #7
    9846:	f027 0307 	bic.w	r3, r7, #7
    984a:	2700      	movs	r7, #0
    984c:	f103 0208 	add.w	r2, r3, #8
    9850:	45b8      	cmp	r8, r7
    9852:	9209      	str	r2, [sp, #36]	; 0x24
    9854:	e9d3 4500 	ldrd	r4, r5, [r3]
    9858:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    985c:	f6bf ae4b 	bge.w	94f6 <_svfprintf_r+0x33e>
    9860:	ea54 0305 	orrs.w	r3, r4, r5
    9864:	f47f ae4d 	bne.w	9502 <_svfprintf_r+0x34a>
    9868:	ae38      	add	r6, sp, #224	; 0xe0
    986a:	3430      	adds	r4, #48	; 0x30
    986c:	f806 4d41 	strb.w	r4, [r6, #-65]!
    9870:	ab28      	add	r3, sp, #160	; 0xa0
    9872:	1b9b      	subs	r3, r3, r6
    9874:	9308      	str	r3, [sp, #32]
    9876:	9b08      	ldr	r3, [sp, #32]
    9878:	4543      	cmp	r3, r8
    987a:	bfb8      	it	lt
    987c:	4643      	movlt	r3, r8
    987e:	9304      	str	r3, [sp, #16]
    9880:	2300      	movs	r3, #0
    9882:	930e      	str	r3, [sp, #56]	; 0x38
    9884:	e68a      	b.n	959c <_svfprintf_r+0x3e4>
    9886:	930c      	str	r3, [sp, #48]	; 0x30
    9888:	46a8      	mov	r8, r5
    988a:	2a00      	cmp	r2, #0
    988c:	f040 8728 	bne.w	a6e0 <_svfprintf_r+0x1528>
    9890:	f01b 0f20 	tst.w	fp, #32
    9894:	48c2      	ldr	r0, [pc, #776]	; (9ba0 <_svfprintf_r+0x9e8>)
    9896:	f000 8086 	beq.w	99a6 <_svfprintf_r+0x7ee>
    989a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    989c:	3707      	adds	r7, #7
    989e:	f027 0307 	bic.w	r3, r7, #7
    98a2:	e9d3 4500 	ldrd	r4, r5, [r3]
    98a6:	f103 0208 	add.w	r2, r3, #8
    98aa:	9209      	str	r2, [sp, #36]	; 0x24
    98ac:	f01b 0701 	ands.w	r7, fp, #1
    98b0:	f000 8247 	beq.w	9d42 <_svfprintf_r+0xb8a>
    98b4:	ea54 0305 	orrs.w	r3, r4, r5
    98b8:	f000 84a3 	beq.w	a202 <_svfprintf_r+0x104a>
    98bc:	2700      	movs	r7, #0
    98be:	2330      	movs	r3, #48	; 0x30
    98c0:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    98c4:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    98c8:	45b8      	cmp	r8, r7
    98ca:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    98ce:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    98d2:	f04b 0302 	orr.w	r3, fp, #2
    98d6:	f2c0 8617 	blt.w	a508 <_svfprintf_r+0x1350>
    98da:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    98de:	f043 0b02 	orr.w	fp, r3, #2
    98e2:	ae28      	add	r6, sp, #160	; 0xa0
    98e4:	0923      	lsrs	r3, r4, #4
    98e6:	f004 010f 	and.w	r1, r4, #15
    98ea:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
    98ee:	092a      	lsrs	r2, r5, #4
    98f0:	461c      	mov	r4, r3
    98f2:	4615      	mov	r5, r2
    98f4:	5c43      	ldrb	r3, [r0, r1]
    98f6:	f806 3d01 	strb.w	r3, [r6, #-1]!
    98fa:	ea54 0305 	orrs.w	r3, r4, r5
    98fe:	d1f1      	bne.n	98e4 <_svfprintf_r+0x72c>
    9900:	e7b6      	b.n	9870 <_svfprintf_r+0x6b8>
    9902:	9909      	ldr	r1, [sp, #36]	; 0x24
    9904:	930c      	str	r3, [sp, #48]	; 0x30
    9906:	680a      	ldr	r2, [r1, #0]
    9908:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    990c:	2300      	movs	r3, #0
    990e:	460a      	mov	r2, r1
    9910:	461f      	mov	r7, r3
    9912:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9916:	3204      	adds	r2, #4
    9918:	2301      	movs	r3, #1
    991a:	9304      	str	r3, [sp, #16]
    991c:	46b8      	mov	r8, r7
    991e:	970e      	str	r7, [sp, #56]	; 0x38
    9920:	9209      	str	r2, [sp, #36]	; 0x24
    9922:	9308      	str	r3, [sp, #32]
    9924:	ae1e      	add	r6, sp, #120	; 0x78
    9926:	e63d      	b.n	95a4 <_svfprintf_r+0x3ec>
    9928:	930c      	str	r3, [sp, #48]	; 0x30
    992a:	46a8      	mov	r8, r5
    992c:	2a00      	cmp	r2, #0
    992e:	f43f adc8 	beq.w	94c2 <_svfprintf_r+0x30a>
    9932:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    9936:	e5c4      	b.n	94c2 <_svfprintf_r+0x30a>
    9938:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
    993c:	f89a 3000 	ldrb.w	r3, [sl]
    9940:	e493      	b.n	926a <_svfprintf_r+0xb2>
    9942:	f89a 3000 	ldrb.w	r3, [sl]
    9946:	2900      	cmp	r1, #0
    9948:	f47f ac8f 	bne.w	926a <_svfprintf_r+0xb2>
    994c:	2201      	movs	r2, #1
    994e:	2120      	movs	r1, #32
    9950:	e48b      	b.n	926a <_svfprintf_r+0xb2>
    9952:	f04b 0b01 	orr.w	fp, fp, #1
    9956:	f89a 3000 	ldrb.w	r3, [sl]
    995a:	e486      	b.n	926a <_svfprintf_r+0xb2>
    995c:	9c09      	ldr	r4, [sp, #36]	; 0x24
    995e:	6823      	ldr	r3, [r4, #0]
    9960:	9307      	str	r3, [sp, #28]
    9962:	4618      	mov	r0, r3
    9964:	2800      	cmp	r0, #0
    9966:	4623      	mov	r3, r4
    9968:	f103 0304 	add.w	r3, r3, #4
    996c:	f6ff acdf 	blt.w	932e <_svfprintf_r+0x176>
    9970:	9309      	str	r3, [sp, #36]	; 0x24
    9972:	f89a 3000 	ldrb.w	r3, [sl]
    9976:	e478      	b.n	926a <_svfprintf_r+0xb2>
    9978:	f89a 3000 	ldrb.w	r3, [sl]
    997c:	2201      	movs	r2, #1
    997e:	212b      	movs	r1, #43	; 0x2b
    9980:	e473      	b.n	926a <_svfprintf_r+0xb2>
    9982:	930c      	str	r3, [sp, #48]	; 0x30
    9984:	46a8      	mov	r8, r5
    9986:	2a00      	cmp	r2, #0
    9988:	f43f af57 	beq.w	983a <_svfprintf_r+0x682>
    998c:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    9990:	e753      	b.n	983a <_svfprintf_r+0x682>
    9992:	930c      	str	r3, [sp, #48]	; 0x30
    9994:	46a8      	mov	r8, r5
    9996:	2a00      	cmp	r2, #0
    9998:	f040 86aa 	bne.w	a6f0 <_svfprintf_r+0x1538>
    999c:	f01b 0f20 	tst.w	fp, #32
    99a0:	4880      	ldr	r0, [pc, #512]	; (9ba4 <_svfprintf_r+0x9ec>)
    99a2:	f47f af7a 	bne.w	989a <_svfprintf_r+0x6e2>
    99a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    99a8:	f01b 0f10 	tst.w	fp, #16
    99ac:	4613      	mov	r3, r2
    99ae:	f040 82c1 	bne.w	9f34 <_svfprintf_r+0xd7c>
    99b2:	f01b 0f40 	tst.w	fp, #64	; 0x40
    99b6:	f000 82bd 	beq.w	9f34 <_svfprintf_r+0xd7c>
    99ba:	3304      	adds	r3, #4
    99bc:	8814      	ldrh	r4, [r2, #0]
    99be:	9309      	str	r3, [sp, #36]	; 0x24
    99c0:	2500      	movs	r5, #0
    99c2:	e773      	b.n	98ac <_svfprintf_r+0x6f4>
    99c4:	f89a 3000 	ldrb.w	r3, [sl]
    99c8:	2b6c      	cmp	r3, #108	; 0x6c
    99ca:	bf03      	ittte	eq
    99cc:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
    99d0:	f04b 0b20 	orreq.w	fp, fp, #32
    99d4:	f10a 0a01 	addeq.w	sl, sl, #1
    99d8:	f04b 0b10 	orrne.w	fp, fp, #16
    99dc:	e445      	b.n	926a <_svfprintf_r+0xb2>
    99de:	2a00      	cmp	r2, #0
    99e0:	f040 866f 	bne.w	a6c2 <_svfprintf_r+0x150a>
    99e4:	f01b 0f20 	tst.w	fp, #32
    99e8:	f000 8366 	beq.w	a0b8 <_svfprintf_r+0xf00>
    99ec:	9a09      	ldr	r2, [sp, #36]	; 0x24
    99ee:	9906      	ldr	r1, [sp, #24]
    99f0:	6813      	ldr	r3, [r2, #0]
    99f2:	17cd      	asrs	r5, r1, #31
    99f4:	4608      	mov	r0, r1
    99f6:	3204      	adds	r2, #4
    99f8:	4629      	mov	r1, r5
    99fa:	9209      	str	r2, [sp, #36]	; 0x24
    99fc:	e9c3 0100 	strd	r0, r1, [r3]
    9a00:	e400      	b.n	9204 <_svfprintf_r+0x4c>
    9a02:	f04b 0b20 	orr.w	fp, fp, #32
    9a06:	f89a 3000 	ldrb.w	r3, [sl]
    9a0a:	e42e      	b.n	926a <_svfprintf_r+0xb2>
    9a0c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9a0e:	930c      	str	r3, [sp, #48]	; 0x30
    9a10:	6816      	ldr	r6, [r2, #0]
    9a12:	2400      	movs	r4, #0
    9a14:	f88d 404f 	strb.w	r4, [sp, #79]	; 0x4f
    9a18:	1d17      	adds	r7, r2, #4
    9a1a:	2e00      	cmp	r6, #0
    9a1c:	f000 8565 	beq.w	a4ea <_svfprintf_r+0x1332>
    9a20:	2d00      	cmp	r5, #0
    9a22:	f2c0 84a2 	blt.w	a36a <_svfprintf_r+0x11b2>
    9a26:	462a      	mov	r2, r5
    9a28:	4621      	mov	r1, r4
    9a2a:	4630      	mov	r0, r6
    9a2c:	f7fe f928 	bl	7c80 <memchr>
    9a30:	2800      	cmp	r0, #0
    9a32:	f000 85cc 	beq.w	a5ce <_svfprintf_r+0x1416>
    9a36:	1b83      	subs	r3, r0, r6
    9a38:	9308      	str	r3, [sp, #32]
    9a3a:	46a0      	mov	r8, r4
    9a3c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9a40:	9709      	str	r7, [sp, #36]	; 0x24
    9a42:	9304      	str	r3, [sp, #16]
    9a44:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    9a48:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9a4c:	e5a6      	b.n	959c <_svfprintf_r+0x3e4>
    9a4e:	4855      	ldr	r0, [pc, #340]	; (9ba4 <_svfprintf_r+0x9ec>)
    9a50:	920c      	str	r2, [sp, #48]	; 0x30
    9a52:	f1b8 0f00 	cmp.w	r8, #0
    9a56:	f040 8184 	bne.w	9d62 <_svfprintf_r+0xbaa>
    9a5a:	4647      	mov	r7, r8
    9a5c:	f04f 0800 	mov.w	r8, #0
    9a60:	f8cd 8020 	str.w	r8, [sp, #32]
    9a64:	ae28      	add	r6, sp, #160	; 0xa0
    9a66:	e706      	b.n	9876 <_svfprintf_r+0x6be>
    9a68:	930c      	str	r3, [sp, #48]	; 0x30
    9a6a:	2a00      	cmp	r2, #0
    9a6c:	f040 862d 	bne.w	a6ca <_svfprintf_r+0x1512>
    9a70:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9a72:	2a00      	cmp	r2, #0
    9a74:	f43f ac8f 	beq.w	9396 <_svfprintf_r+0x1de>
    9a78:	2300      	movs	r3, #0
    9a7a:	2101      	movs	r1, #1
    9a7c:	461f      	mov	r7, r3
    9a7e:	9104      	str	r1, [sp, #16]
    9a80:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    9a84:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9a88:	4698      	mov	r8, r3
    9a8a:	930e      	str	r3, [sp, #56]	; 0x38
    9a8c:	9108      	str	r1, [sp, #32]
    9a8e:	ae1e      	add	r6, sp, #120	; 0x78
    9a90:	e588      	b.n	95a4 <_svfprintf_r+0x3ec>
    9a92:	f1b8 0f00 	cmp.w	r8, #0
    9a96:	f000 858b 	beq.w	a5b0 <_svfprintf_r+0x13f8>
    9a9a:	2700      	movs	r7, #0
    9a9c:	2400      	movs	r4, #0
    9a9e:	2500      	movs	r5, #0
    9aa0:	e4ac      	b.n	93fc <_svfprintf_r+0x244>
    9aa2:	4840      	ldr	r0, [pc, #256]	; (9ba4 <_svfprintf_r+0x9ec>)
    9aa4:	920c      	str	r2, [sp, #48]	; 0x30
    9aa6:	469b      	mov	fp, r3
    9aa8:	ea54 0305 	orrs.w	r3, r4, r5
    9aac:	9709      	str	r7, [sp, #36]	; 0x24
    9aae:	f04f 0700 	mov.w	r7, #0
    9ab2:	f47f af16 	bne.w	98e2 <_svfprintf_r+0x72a>
    9ab6:	2400      	movs	r4, #0
    9ab8:	2500      	movs	r5, #0
    9aba:	e712      	b.n	98e2 <_svfprintf_r+0x72a>
    9abc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9abe:	e5bb      	b.n	9638 <_svfprintf_r+0x480>
    9ac0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9ac2:	2a65      	cmp	r2, #101	; 0x65
    9ac4:	f340 80a1 	ble.w	9c0a <_svfprintf_r+0xa52>
    9ac8:	eeb5 8b40 	vcmp.f64	d8, #0.0
    9acc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9ad0:	f040 8149 	bne.w	9d66 <_svfprintf_r+0xbae>
    9ad4:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9ad6:	4934      	ldr	r1, [pc, #208]	; (9ba8 <_svfprintf_r+0x9f0>)
    9ad8:	f8c9 1000 	str.w	r1, [r9]
    9adc:	3201      	adds	r2, #1
    9ade:	3301      	adds	r3, #1
    9ae0:	2101      	movs	r1, #1
    9ae2:	2a07      	cmp	r2, #7
    9ae4:	931d      	str	r3, [sp, #116]	; 0x74
    9ae6:	921c      	str	r2, [sp, #112]	; 0x70
    9ae8:	f8c9 1004 	str.w	r1, [r9, #4]
    9aec:	f300 8392 	bgt.w	a214 <_svfprintf_r+0x105c>
    9af0:	f109 0908 	add.w	r9, r9, #8
    9af4:	9a15      	ldr	r2, [sp, #84]	; 0x54
    9af6:	990d      	ldr	r1, [sp, #52]	; 0x34
    9af8:	428a      	cmp	r2, r1
    9afa:	db03      	blt.n	9b04 <_svfprintf_r+0x94c>
    9afc:	f01b 0f01 	tst.w	fp, #1
    9b00:	f43f ae0b 	beq.w	971a <_svfprintf_r+0x562>
    9b04:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9b06:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9b08:	9910      	ldr	r1, [sp, #64]	; 0x40
    9b0a:	f8c9 1000 	str.w	r1, [r9]
    9b0e:	3201      	adds	r2, #1
    9b10:	4403      	add	r3, r0
    9b12:	2a07      	cmp	r2, #7
    9b14:	931d      	str	r3, [sp, #116]	; 0x74
    9b16:	f8c9 0004 	str.w	r0, [r9, #4]
    9b1a:	921c      	str	r2, [sp, #112]	; 0x70
    9b1c:	f300 83d6 	bgt.w	a2cc <_svfprintf_r+0x1114>
    9b20:	f109 0908 	add.w	r9, r9, #8
    9b24:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9b26:	1e54      	subs	r4, r2, #1
    9b28:	2c00      	cmp	r4, #0
    9b2a:	f77f adf6 	ble.w	971a <_svfprintf_r+0x562>
    9b2e:	2c10      	cmp	r4, #16
    9b30:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9b32:	4f1e      	ldr	r7, [pc, #120]	; (9bac <_svfprintf_r+0x9f4>)
    9b34:	f340 81dc 	ble.w	9ef0 <_svfprintf_r+0xd38>
    9b38:	2510      	movs	r5, #16
    9b3a:	9e05      	ldr	r6, [sp, #20]
    9b3c:	f8dd 800c 	ldr.w	r8, [sp, #12]
    9b40:	e005      	b.n	9b4e <_svfprintf_r+0x996>
    9b42:	f109 0908 	add.w	r9, r9, #8
    9b46:	3c10      	subs	r4, #16
    9b48:	2c10      	cmp	r4, #16
    9b4a:	f340 81d1 	ble.w	9ef0 <_svfprintf_r+0xd38>
    9b4e:	3201      	adds	r2, #1
    9b50:	3310      	adds	r3, #16
    9b52:	2a07      	cmp	r2, #7
    9b54:	931d      	str	r3, [sp, #116]	; 0x74
    9b56:	921c      	str	r2, [sp, #112]	; 0x70
    9b58:	f8c9 7000 	str.w	r7, [r9]
    9b5c:	f8c9 5004 	str.w	r5, [r9, #4]
    9b60:	ddef      	ble.n	9b42 <_svfprintf_r+0x98a>
    9b62:	aa1b      	add	r2, sp, #108	; 0x6c
    9b64:	4641      	mov	r1, r8
    9b66:	4630      	mov	r0, r6
    9b68:	f000 fdde 	bl	a728 <__ssprint_r>
    9b6c:	2800      	cmp	r0, #0
    9b6e:	f47f ac19 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9b72:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9b74:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9b76:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9b7a:	e7e4      	b.n	9b46 <_svfprintf_r+0x98e>
    9b7c:	9a07      	ldr	r2, [sp, #28]
    9b7e:	9904      	ldr	r1, [sp, #16]
    9b80:	1a54      	subs	r4, r2, r1
    9b82:	2c00      	cmp	r4, #0
    9b84:	f77f ad7c 	ble.w	9680 <_svfprintf_r+0x4c8>
    9b88:	2c10      	cmp	r4, #16
    9b8a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9b8c:	4f07      	ldr	r7, [pc, #28]	; (9bac <_svfprintf_r+0x9f4>)
    9b8e:	dd2e      	ble.n	9bee <_svfprintf_r+0xa36>
    9b90:	4649      	mov	r1, r9
    9b92:	2510      	movs	r5, #16
    9b94:	46c1      	mov	r9, r8
    9b96:	4618      	mov	r0, r3
    9b98:	46b0      	mov	r8, r6
    9b9a:	9e05      	ldr	r6, [sp, #20]
    9b9c:	e00d      	b.n	9bba <_svfprintf_r+0xa02>
    9b9e:	bf00      	nop
    9ba0:	20000f78 	.word	0x20000f78
    9ba4:	20000f8c 	.word	0x20000f8c
    9ba8:	20000f64 	.word	0x20000f64
    9bac:	2000114c 	.word	0x2000114c
    9bb0:	3c10      	subs	r4, #16
    9bb2:	2c10      	cmp	r4, #16
    9bb4:	f101 0108 	add.w	r1, r1, #8
    9bb8:	dd15      	ble.n	9be6 <_svfprintf_r+0xa2e>
    9bba:	3201      	adds	r2, #1
    9bbc:	3010      	adds	r0, #16
    9bbe:	2a07      	cmp	r2, #7
    9bc0:	901d      	str	r0, [sp, #116]	; 0x74
    9bc2:	921c      	str	r2, [sp, #112]	; 0x70
    9bc4:	600f      	str	r7, [r1, #0]
    9bc6:	604d      	str	r5, [r1, #4]
    9bc8:	ddf2      	ble.n	9bb0 <_svfprintf_r+0x9f8>
    9bca:	aa1b      	add	r2, sp, #108	; 0x6c
    9bcc:	9903      	ldr	r1, [sp, #12]
    9bce:	4630      	mov	r0, r6
    9bd0:	f000 fdaa 	bl	a728 <__ssprint_r>
    9bd4:	2800      	cmp	r0, #0
    9bd6:	f47f abe5 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9bda:	3c10      	subs	r4, #16
    9bdc:	2c10      	cmp	r4, #16
    9bde:	981d      	ldr	r0, [sp, #116]	; 0x74
    9be0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9be2:	a928      	add	r1, sp, #160	; 0xa0
    9be4:	dce9      	bgt.n	9bba <_svfprintf_r+0xa02>
    9be6:	4646      	mov	r6, r8
    9be8:	4603      	mov	r3, r0
    9bea:	46c8      	mov	r8, r9
    9bec:	4689      	mov	r9, r1
    9bee:	3201      	adds	r2, #1
    9bf0:	4423      	add	r3, r4
    9bf2:	2a07      	cmp	r2, #7
    9bf4:	931d      	str	r3, [sp, #116]	; 0x74
    9bf6:	921c      	str	r2, [sp, #112]	; 0x70
    9bf8:	f8c9 7000 	str.w	r7, [r9]
    9bfc:	f8c9 4004 	str.w	r4, [r9, #4]
    9c00:	f300 8246 	bgt.w	a090 <_svfprintf_r+0xed8>
    9c04:	f109 0908 	add.w	r9, r9, #8
    9c08:	e53a      	b.n	9680 <_svfprintf_r+0x4c8>
    9c0a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9c0c:	f8c9 6000 	str.w	r6, [r9]
    9c10:	2a01      	cmp	r2, #1
    9c12:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9c14:	f103 0301 	add.w	r3, r3, #1
    9c18:	f102 0201 	add.w	r2, r2, #1
    9c1c:	f04f 0101 	mov.w	r1, #1
    9c20:	931d      	str	r3, [sp, #116]	; 0x74
    9c22:	921c      	str	r2, [sp, #112]	; 0x70
    9c24:	f8c9 1004 	str.w	r1, [r9, #4]
    9c28:	f340 8210 	ble.w	a04c <_svfprintf_r+0xe94>
    9c2c:	2a07      	cmp	r2, #7
    9c2e:	f300 8215 	bgt.w	a05c <_svfprintf_r+0xea4>
    9c32:	f109 0908 	add.w	r9, r9, #8
    9c36:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9c38:	9910      	ldr	r1, [sp, #64]	; 0x40
    9c3a:	f8c9 1000 	str.w	r1, [r9]
    9c3e:	3201      	adds	r2, #1
    9c40:	4403      	add	r3, r0
    9c42:	2a07      	cmp	r2, #7
    9c44:	931d      	str	r3, [sp, #116]	; 0x74
    9c46:	921c      	str	r2, [sp, #112]	; 0x70
    9c48:	f8c9 0004 	str.w	r0, [r9, #4]
    9c4c:	f300 8213 	bgt.w	a076 <_svfprintf_r+0xebe>
    9c50:	f109 0908 	add.w	r9, r9, #8
    9c54:	eeb5 8b40 	vcmp.f64	d8, #0.0
    9c58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9c5c:	990d      	ldr	r1, [sp, #52]	; 0x34
    9c5e:	f000 80f5 	beq.w	9e4c <_svfprintf_r+0xc94>
    9c62:	3901      	subs	r1, #1
    9c64:	3201      	adds	r2, #1
    9c66:	3601      	adds	r6, #1
    9c68:	440b      	add	r3, r1
    9c6a:	2a07      	cmp	r2, #7
    9c6c:	f8c9 6000 	str.w	r6, [r9]
    9c70:	921c      	str	r2, [sp, #112]	; 0x70
    9c72:	931d      	str	r3, [sp, #116]	; 0x74
    9c74:	f8c9 1004 	str.w	r1, [r9, #4]
    9c78:	f300 811d 	bgt.w	9eb6 <_svfprintf_r+0xcfe>
    9c7c:	f109 0908 	add.w	r9, r9, #8
    9c80:	9811      	ldr	r0, [sp, #68]	; 0x44
    9c82:	f8c9 0004 	str.w	r0, [r9, #4]
    9c86:	3201      	adds	r2, #1
    9c88:	4403      	add	r3, r0
    9c8a:	a917      	add	r1, sp, #92	; 0x5c
    9c8c:	2a07      	cmp	r2, #7
    9c8e:	931d      	str	r3, [sp, #116]	; 0x74
    9c90:	921c      	str	r2, [sp, #112]	; 0x70
    9c92:	f8c9 1000 	str.w	r1, [r9]
    9c96:	f77f ad3e 	ble.w	9716 <_svfprintf_r+0x55e>
    9c9a:	aa1b      	add	r2, sp, #108	; 0x6c
    9c9c:	9903      	ldr	r1, [sp, #12]
    9c9e:	9805      	ldr	r0, [sp, #20]
    9ca0:	f000 fd42 	bl	a728 <__ssprint_r>
    9ca4:	2800      	cmp	r0, #0
    9ca6:	f47f ab7d 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9caa:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9cac:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9cb0:	e533      	b.n	971a <_svfprintf_r+0x562>
    9cb2:	aa1b      	add	r2, sp, #108	; 0x6c
    9cb4:	9903      	ldr	r1, [sp, #12]
    9cb6:	9805      	ldr	r0, [sp, #20]
    9cb8:	f000 fd36 	bl	a728 <__ssprint_r>
    9cbc:	2800      	cmp	r0, #0
    9cbe:	f43f ad79 	beq.w	97b4 <_svfprintf_r+0x5fc>
    9cc2:	f7ff bb6f 	b.w	93a4 <_svfprintf_r+0x1ec>
    9cc6:	9909      	ldr	r1, [sp, #36]	; 0x24
    9cc8:	f1b8 0f00 	cmp.w	r8, #0
    9ccc:	680c      	ldr	r4, [r1, #0]
    9cce:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9cd2:	f101 0704 	add.w	r7, r1, #4
    9cd6:	f04f 0500 	mov.w	r5, #0
    9cda:	f2c0 8371 	blt.w	a3c0 <_svfprintf_r+0x1208>
    9cde:	ea54 0205 	orrs.w	r2, r4, r5
    9ce2:	9709      	str	r7, [sp, #36]	; 0x24
    9ce4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9ce8:	461f      	mov	r7, r3
    9cea:	f47f ac0a 	bne.w	9502 <_svfprintf_r+0x34a>
    9cee:	f1b8 0f00 	cmp.w	r8, #0
    9cf2:	f43f aeb3 	beq.w	9a5c <_svfprintf_r+0x8a4>
    9cf6:	2400      	movs	r4, #0
    9cf8:	e5b6      	b.n	9868 <_svfprintf_r+0x6b0>
    9cfa:	aa1b      	add	r2, sp, #108	; 0x6c
    9cfc:	9903      	ldr	r1, [sp, #12]
    9cfe:	9805      	ldr	r0, [sp, #20]
    9d00:	f000 fd12 	bl	a728 <__ssprint_r>
    9d04:	2800      	cmp	r0, #0
    9d06:	f47f ab4d 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9d0a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9d0c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9d10:	e4f0      	b.n	96f4 <_svfprintf_r+0x53c>
    9d12:	aa1b      	add	r2, sp, #108	; 0x6c
    9d14:	9903      	ldr	r1, [sp, #12]
    9d16:	9805      	ldr	r0, [sp, #20]
    9d18:	f000 fd06 	bl	a728 <__ssprint_r>
    9d1c:	2800      	cmp	r0, #0
    9d1e:	f47f ab41 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9d22:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9d24:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9d28:	e496      	b.n	9658 <_svfprintf_r+0x4a0>
    9d2a:	aa1b      	add	r2, sp, #108	; 0x6c
    9d2c:	9903      	ldr	r1, [sp, #12]
    9d2e:	9805      	ldr	r0, [sp, #20]
    9d30:	f000 fcfa 	bl	a728 <__ssprint_r>
    9d34:	2800      	cmp	r0, #0
    9d36:	f47f ab35 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9d3a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9d3c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9d40:	e49a      	b.n	9678 <_svfprintf_r+0x4c0>
    9d42:	f1b8 0f00 	cmp.w	r8, #0
    9d46:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9d4a:	f2c0 826f 	blt.w	a22c <_svfprintf_r+0x1074>
    9d4e:	ea54 0305 	orrs.w	r3, r4, r5
    9d52:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9d56:	f47f adc4 	bne.w	98e2 <_svfprintf_r+0x72a>
    9d5a:	f1b8 0f00 	cmp.w	r8, #0
    9d5e:	f43f ae7c 	beq.w	9a5a <_svfprintf_r+0x8a2>
    9d62:	2700      	movs	r7, #0
    9d64:	e6a7      	b.n	9ab6 <_svfprintf_r+0x8fe>
    9d66:	9c15      	ldr	r4, [sp, #84]	; 0x54
    9d68:	2c00      	cmp	r4, #0
    9d6a:	f340 8261 	ble.w	a230 <_svfprintf_r+0x1078>
    9d6e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    9d70:	990d      	ldr	r1, [sp, #52]	; 0x34
    9d72:	428a      	cmp	r2, r1
    9d74:	bfa8      	it	ge
    9d76:	460a      	movge	r2, r1
    9d78:	2a00      	cmp	r2, #0
    9d7a:	4614      	mov	r4, r2
    9d7c:	dd0d      	ble.n	9d9a <_svfprintf_r+0xbe2>
    9d7e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9d80:	f8c9 6000 	str.w	r6, [r9]
    9d84:	3201      	adds	r2, #1
    9d86:	4423      	add	r3, r4
    9d88:	2a07      	cmp	r2, #7
    9d8a:	931d      	str	r3, [sp, #116]	; 0x74
    9d8c:	f8c9 4004 	str.w	r4, [r9, #4]
    9d90:	921c      	str	r2, [sp, #112]	; 0x70
    9d92:	f300 8372 	bgt.w	a47a <_svfprintf_r+0x12c2>
    9d96:	f109 0908 	add.w	r9, r9, #8
    9d9a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    9d9c:	2c00      	cmp	r4, #0
    9d9e:	bfa8      	it	ge
    9da0:	1b12      	subge	r2, r2, r4
    9da2:	2a00      	cmp	r2, #0
    9da4:	4614      	mov	r4, r2
    9da6:	f340 80f1 	ble.w	9f8c <_svfprintf_r+0xdd4>
    9daa:	2c10      	cmp	r4, #16
    9dac:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9dae:	4fc1      	ldr	r7, [pc, #772]	; (a0b4 <_svfprintf_r+0xefc>)
    9db0:	f340 8219 	ble.w	a1e6 <_svfprintf_r+0x102e>
    9db4:	4649      	mov	r1, r9
    9db6:	2510      	movs	r5, #16
    9db8:	46b1      	mov	r9, r6
    9dba:	f8dd 8014 	ldr.w	r8, [sp, #20]
    9dbe:	9e03      	ldr	r6, [sp, #12]
    9dc0:	e004      	b.n	9dcc <_svfprintf_r+0xc14>
    9dc2:	3108      	adds	r1, #8
    9dc4:	3c10      	subs	r4, #16
    9dc6:	2c10      	cmp	r4, #16
    9dc8:	f340 820b 	ble.w	a1e2 <_svfprintf_r+0x102a>
    9dcc:	3201      	adds	r2, #1
    9dce:	3310      	adds	r3, #16
    9dd0:	2a07      	cmp	r2, #7
    9dd2:	931d      	str	r3, [sp, #116]	; 0x74
    9dd4:	921c      	str	r2, [sp, #112]	; 0x70
    9dd6:	600f      	str	r7, [r1, #0]
    9dd8:	604d      	str	r5, [r1, #4]
    9dda:	ddf2      	ble.n	9dc2 <_svfprintf_r+0xc0a>
    9ddc:	aa1b      	add	r2, sp, #108	; 0x6c
    9dde:	4631      	mov	r1, r6
    9de0:	4640      	mov	r0, r8
    9de2:	f000 fca1 	bl	a728 <__ssprint_r>
    9de6:	2800      	cmp	r0, #0
    9de8:	f47f aadc 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9dec:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9dee:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9df0:	a928      	add	r1, sp, #160	; 0xa0
    9df2:	e7e7      	b.n	9dc4 <_svfprintf_r+0xc0c>
    9df4:	aa1b      	add	r2, sp, #108	; 0x6c
    9df6:	9903      	ldr	r1, [sp, #12]
    9df8:	9805      	ldr	r0, [sp, #20]
    9dfa:	f000 fc95 	bl	a728 <__ssprint_r>
    9dfe:	2800      	cmp	r0, #0
    9e00:	f47f aad0 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9e04:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9e08:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9e0a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9e0e:	e413      	b.n	9638 <_svfprintf_r+0x480>
    9e10:	f01b 0210 	ands.w	r2, fp, #16
    9e14:	f47f af57 	bne.w	9cc6 <_svfprintf_r+0xb0e>
    9e18:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    9e1c:	f43f af53 	beq.w	9cc6 <_svfprintf_r+0xb0e>
    9e20:	9909      	ldr	r1, [sp, #36]	; 0x24
    9e22:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    9e26:	460b      	mov	r3, r1
    9e28:	f1b8 0f00 	cmp.w	r8, #0
    9e2c:	f103 0304 	add.w	r3, r3, #4
    9e30:	880c      	ldrh	r4, [r1, #0]
    9e32:	f04f 0500 	mov.w	r5, #0
    9e36:	f2c0 8294 	blt.w	a362 <_svfprintf_r+0x11aa>
    9e3a:	ea54 0105 	orrs.w	r1, r4, r5
    9e3e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9e42:	9309      	str	r3, [sp, #36]	; 0x24
    9e44:	4617      	mov	r7, r2
    9e46:	f47f ab5c 	bne.w	9502 <_svfprintf_r+0x34a>
    9e4a:	e750      	b.n	9cee <_svfprintf_r+0xb36>
    9e4c:	1e4c      	subs	r4, r1, #1
    9e4e:	2c00      	cmp	r4, #0
    9e50:	f77f af16 	ble.w	9c80 <_svfprintf_r+0xac8>
    9e54:	2c10      	cmp	r4, #16
    9e56:	4f97      	ldr	r7, [pc, #604]	; (a0b4 <_svfprintf_r+0xefc>)
    9e58:	dd22      	ble.n	9ea0 <_svfprintf_r+0xce8>
    9e5a:	2510      	movs	r5, #16
    9e5c:	9e05      	ldr	r6, [sp, #20]
    9e5e:	f8dd 800c 	ldr.w	r8, [sp, #12]
    9e62:	e004      	b.n	9e6e <_svfprintf_r+0xcb6>
    9e64:	3c10      	subs	r4, #16
    9e66:	2c10      	cmp	r4, #16
    9e68:	f109 0908 	add.w	r9, r9, #8
    9e6c:	dd18      	ble.n	9ea0 <_svfprintf_r+0xce8>
    9e6e:	3201      	adds	r2, #1
    9e70:	3310      	adds	r3, #16
    9e72:	2a07      	cmp	r2, #7
    9e74:	931d      	str	r3, [sp, #116]	; 0x74
    9e76:	921c      	str	r2, [sp, #112]	; 0x70
    9e78:	f8c9 7000 	str.w	r7, [r9]
    9e7c:	f8c9 5004 	str.w	r5, [r9, #4]
    9e80:	ddf0      	ble.n	9e64 <_svfprintf_r+0xcac>
    9e82:	aa1b      	add	r2, sp, #108	; 0x6c
    9e84:	4641      	mov	r1, r8
    9e86:	4630      	mov	r0, r6
    9e88:	f000 fc4e 	bl	a728 <__ssprint_r>
    9e8c:	2800      	cmp	r0, #0
    9e8e:	f47f aa89 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9e92:	3c10      	subs	r4, #16
    9e94:	2c10      	cmp	r4, #16
    9e96:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9e98:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9e9a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9e9e:	dce6      	bgt.n	9e6e <_svfprintf_r+0xcb6>
    9ea0:	3201      	adds	r2, #1
    9ea2:	4423      	add	r3, r4
    9ea4:	2a07      	cmp	r2, #7
    9ea6:	931d      	str	r3, [sp, #116]	; 0x74
    9ea8:	921c      	str	r2, [sp, #112]	; 0x70
    9eaa:	f8c9 7000 	str.w	r7, [r9]
    9eae:	f8c9 4004 	str.w	r4, [r9, #4]
    9eb2:	f77f aee3 	ble.w	9c7c <_svfprintf_r+0xac4>
    9eb6:	aa1b      	add	r2, sp, #108	; 0x6c
    9eb8:	9903      	ldr	r1, [sp, #12]
    9eba:	9805      	ldr	r0, [sp, #20]
    9ebc:	f000 fc34 	bl	a728 <__ssprint_r>
    9ec0:	2800      	cmp	r0, #0
    9ec2:	f47f aa6f 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9ec6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9ec8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9eca:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9ece:	e6d7      	b.n	9c80 <_svfprintf_r+0xac8>
    9ed0:	f01b 0f10 	tst.w	fp, #16
    9ed4:	d133      	bne.n	9f3e <_svfprintf_r+0xd86>
    9ed6:	f01b 0f40 	tst.w	fp, #64	; 0x40
    9eda:	d030      	beq.n	9f3e <_svfprintf_r+0xd86>
    9edc:	9909      	ldr	r1, [sp, #36]	; 0x24
    9ede:	f9b1 4000 	ldrsh.w	r4, [r1]
    9ee2:	3104      	adds	r1, #4
    9ee4:	17e5      	asrs	r5, r4, #31
    9ee6:	4622      	mov	r2, r4
    9ee8:	462b      	mov	r3, r5
    9eea:	9109      	str	r1, [sp, #36]	; 0x24
    9eec:	f7ff baf8 	b.w	94e0 <_svfprintf_r+0x328>
    9ef0:	3201      	adds	r2, #1
    9ef2:	4423      	add	r3, r4
    9ef4:	2a07      	cmp	r2, #7
    9ef6:	931d      	str	r3, [sp, #116]	; 0x74
    9ef8:	921c      	str	r2, [sp, #112]	; 0x70
    9efa:	f8c9 7000 	str.w	r7, [r9]
    9efe:	f8c9 4004 	str.w	r4, [r9, #4]
    9f02:	f77f ac08 	ble.w	9716 <_svfprintf_r+0x55e>
    9f06:	e6c8      	b.n	9c9a <_svfprintf_r+0xae2>
    9f08:	9909      	ldr	r1, [sp, #36]	; 0x24
    9f0a:	f1b8 0f00 	cmp.w	r8, #0
    9f0e:	680c      	ldr	r4, [r1, #0]
    9f10:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9f14:	f101 0704 	add.w	r7, r1, #4
    9f18:	f04f 0500 	mov.w	r5, #0
    9f1c:	f2c0 80c5 	blt.w	a0aa <_svfprintf_r+0xef2>
    9f20:	ea54 0205 	orrs.w	r2, r4, r5
    9f24:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9f28:	9709      	str	r7, [sp, #36]	; 0x24
    9f2a:	f43f adb2 	beq.w	9a92 <_svfprintf_r+0x8da>
    9f2e:	461f      	mov	r7, r3
    9f30:	f7ff ba64 	b.w	93fc <_svfprintf_r+0x244>
    9f34:	681c      	ldr	r4, [r3, #0]
    9f36:	3304      	adds	r3, #4
    9f38:	9309      	str	r3, [sp, #36]	; 0x24
    9f3a:	2500      	movs	r5, #0
    9f3c:	e4b6      	b.n	98ac <_svfprintf_r+0x6f4>
    9f3e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9f40:	6814      	ldr	r4, [r2, #0]
    9f42:	4613      	mov	r3, r2
    9f44:	3304      	adds	r3, #4
    9f46:	17e5      	asrs	r5, r4, #31
    9f48:	4622      	mov	r2, r4
    9f4a:	9309      	str	r3, [sp, #36]	; 0x24
    9f4c:	2a00      	cmp	r2, #0
    9f4e:	462b      	mov	r3, r5
    9f50:	f173 0300 	sbcs.w	r3, r3, #0
    9f54:	f6bf aac9 	bge.w	94ea <_svfprintf_r+0x332>
    9f58:	4264      	negs	r4, r4
    9f5a:	f04f 072d 	mov.w	r7, #45	; 0x2d
    9f5e:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
    9f62:	f1b8 0f00 	cmp.w	r8, #0
    9f66:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9f6a:	f6ff aaca 	blt.w	9502 <_svfprintf_r+0x34a>
    9f6e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9f72:	f7ff bac6 	b.w	9502 <_svfprintf_r+0x34a>
    9f76:	aa1b      	add	r2, sp, #108	; 0x6c
    9f78:	9903      	ldr	r1, [sp, #12]
    9f7a:	9805      	ldr	r0, [sp, #20]
    9f7c:	f000 fbd4 	bl	a728 <__ssprint_r>
    9f80:	2800      	cmp	r0, #0
    9f82:	f47f aa0f 	bne.w	93a4 <_svfprintf_r+0x1ec>
    9f86:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9f88:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9f8c:	990e      	ldr	r1, [sp, #56]	; 0x38
    9f8e:	9a15      	ldr	r2, [sp, #84]	; 0x54
    9f90:	4431      	add	r1, r6
    9f92:	460d      	mov	r5, r1
    9f94:	990d      	ldr	r1, [sp, #52]	; 0x34
    9f96:	428a      	cmp	r2, r1
    9f98:	db47      	blt.n	a02a <_svfprintf_r+0xe72>
    9f9a:	f01b 0f01 	tst.w	fp, #1
    9f9e:	d144      	bne.n	a02a <_svfprintf_r+0xe72>
    9fa0:	980d      	ldr	r0, [sp, #52]	; 0x34
    9fa2:	4406      	add	r6, r0
    9fa4:	1b74      	subs	r4, r6, r5
    9fa6:	1a82      	subs	r2, r0, r2
    9fa8:	4294      	cmp	r4, r2
    9faa:	bfa8      	it	ge
    9fac:	4614      	movge	r4, r2
    9fae:	2c00      	cmp	r4, #0
    9fb0:	4626      	mov	r6, r4
    9fb2:	dd0d      	ble.n	9fd0 <_svfprintf_r+0xe18>
    9fb4:	991c      	ldr	r1, [sp, #112]	; 0x70
    9fb6:	f8c9 5000 	str.w	r5, [r9]
    9fba:	3101      	adds	r1, #1
    9fbc:	4423      	add	r3, r4
    9fbe:	2907      	cmp	r1, #7
    9fc0:	931d      	str	r3, [sp, #116]	; 0x74
    9fc2:	f8c9 4004 	str.w	r4, [r9, #4]
    9fc6:	911c      	str	r1, [sp, #112]	; 0x70
    9fc8:	f300 8280 	bgt.w	a4cc <_svfprintf_r+0x1314>
    9fcc:	f109 0908 	add.w	r9, r9, #8
    9fd0:	2e00      	cmp	r6, #0
    9fd2:	bfac      	ite	ge
    9fd4:	1b94      	subge	r4, r2, r6
    9fd6:	4614      	movlt	r4, r2
    9fd8:	2c00      	cmp	r4, #0
    9fda:	f77f ab9e 	ble.w	971a <_svfprintf_r+0x562>
    9fde:	2c10      	cmp	r4, #16
    9fe0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9fe2:	4f34      	ldr	r7, [pc, #208]	; (a0b4 <_svfprintf_r+0xefc>)
    9fe4:	dd84      	ble.n	9ef0 <_svfprintf_r+0xd38>
    9fe6:	2510      	movs	r5, #16
    9fe8:	9e05      	ldr	r6, [sp, #20]
    9fea:	f8dd 800c 	ldr.w	r8, [sp, #12]
    9fee:	e005      	b.n	9ffc <_svfprintf_r+0xe44>
    9ff0:	f109 0908 	add.w	r9, r9, #8
    9ff4:	3c10      	subs	r4, #16
    9ff6:	2c10      	cmp	r4, #16
    9ff8:	f77f af7a 	ble.w	9ef0 <_svfprintf_r+0xd38>
    9ffc:	3201      	adds	r2, #1
    9ffe:	3310      	adds	r3, #16
    a000:	2a07      	cmp	r2, #7
    a002:	931d      	str	r3, [sp, #116]	; 0x74
    a004:	921c      	str	r2, [sp, #112]	; 0x70
    a006:	f8c9 7000 	str.w	r7, [r9]
    a00a:	f8c9 5004 	str.w	r5, [r9, #4]
    a00e:	ddef      	ble.n	9ff0 <_svfprintf_r+0xe38>
    a010:	aa1b      	add	r2, sp, #108	; 0x6c
    a012:	4641      	mov	r1, r8
    a014:	4630      	mov	r0, r6
    a016:	f000 fb87 	bl	a728 <__ssprint_r>
    a01a:	2800      	cmp	r0, #0
    a01c:	f47f a9c2 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a020:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a022:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a024:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a028:	e7e4      	b.n	9ff4 <_svfprintf_r+0xe3c>
    a02a:	991c      	ldr	r1, [sp, #112]	; 0x70
    a02c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    a02e:	9810      	ldr	r0, [sp, #64]	; 0x40
    a030:	f8c9 0000 	str.w	r0, [r9]
    a034:	3101      	adds	r1, #1
    a036:	4423      	add	r3, r4
    a038:	2907      	cmp	r1, #7
    a03a:	931d      	str	r3, [sp, #116]	; 0x74
    a03c:	f8c9 4004 	str.w	r4, [r9, #4]
    a040:	911c      	str	r1, [sp, #112]	; 0x70
    a042:	f300 8226 	bgt.w	a492 <_svfprintf_r+0x12da>
    a046:	f109 0908 	add.w	r9, r9, #8
    a04a:	e7a9      	b.n	9fa0 <_svfprintf_r+0xde8>
    a04c:	f01b 0f01 	tst.w	fp, #1
    a050:	f47f adec 	bne.w	9c2c <_svfprintf_r+0xa74>
    a054:	2a07      	cmp	r2, #7
    a056:	f77f ae11 	ble.w	9c7c <_svfprintf_r+0xac4>
    a05a:	e72c      	b.n	9eb6 <_svfprintf_r+0xcfe>
    a05c:	aa1b      	add	r2, sp, #108	; 0x6c
    a05e:	9903      	ldr	r1, [sp, #12]
    a060:	9805      	ldr	r0, [sp, #20]
    a062:	f000 fb61 	bl	a728 <__ssprint_r>
    a066:	2800      	cmp	r0, #0
    a068:	f47f a99c 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a06c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a06e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a070:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a074:	e5df      	b.n	9c36 <_svfprintf_r+0xa7e>
    a076:	aa1b      	add	r2, sp, #108	; 0x6c
    a078:	9903      	ldr	r1, [sp, #12]
    a07a:	9805      	ldr	r0, [sp, #20]
    a07c:	f000 fb54 	bl	a728 <__ssprint_r>
    a080:	2800      	cmp	r0, #0
    a082:	f47f a98f 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a086:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a088:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a08a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a08e:	e5e1      	b.n	9c54 <_svfprintf_r+0xa9c>
    a090:	aa1b      	add	r2, sp, #108	; 0x6c
    a092:	9903      	ldr	r1, [sp, #12]
    a094:	9805      	ldr	r0, [sp, #20]
    a096:	f000 fb47 	bl	a728 <__ssprint_r>
    a09a:	2800      	cmp	r0, #0
    a09c:	f47f a982 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a0a0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a0a2:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a0a6:	f7ff baeb 	b.w	9680 <_svfprintf_r+0x4c8>
    a0aa:	9709      	str	r7, [sp, #36]	; 0x24
    a0ac:	2700      	movs	r7, #0
    a0ae:	f7ff b9a5 	b.w	93fc <_svfprintf_r+0x244>
    a0b2:	bf00      	nop
    a0b4:	2000114c 	.word	0x2000114c
    a0b8:	f01b 0f10 	tst.w	fp, #16
    a0bc:	d10b      	bne.n	a0d6 <_svfprintf_r+0xf1e>
    a0be:	f01b 0f40 	tst.w	fp, #64	; 0x40
    a0c2:	d008      	beq.n	a0d6 <_svfprintf_r+0xf1e>
    a0c4:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a0c6:	6813      	ldr	r3, [r2, #0]
    a0c8:	3204      	adds	r2, #4
    a0ca:	9209      	str	r2, [sp, #36]	; 0x24
    a0cc:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    a0d0:	801a      	strh	r2, [r3, #0]
    a0d2:	f7ff b897 	b.w	9204 <_svfprintf_r+0x4c>
    a0d6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a0d8:	6813      	ldr	r3, [r2, #0]
    a0da:	3204      	adds	r2, #4
    a0dc:	9209      	str	r2, [sp, #36]	; 0x24
    a0de:	9a06      	ldr	r2, [sp, #24]
    a0e0:	601a      	str	r2, [r3, #0]
    a0e2:	f7ff b88f 	b.w	9204 <_svfprintf_r+0x4c>
    a0e6:	eeb4 8b48 	vcmp.f64	d8, d8
    a0ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a0ee:	f180 829e 	bvs.w	a62e <_svfprintf_r+0x1476>
    a0f2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a0f4:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    a0f8:	f023 0520 	bic.w	r5, r3, #32
    a0fc:	f000 8225 	beq.w	a54a <_svfprintf_r+0x1392>
    a100:	2d47      	cmp	r5, #71	; 0x47
    a102:	f000 8126 	beq.w	a352 <_svfprintf_r+0x119a>
    a106:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
    a10a:	930a      	str	r3, [sp, #40]	; 0x28
    a10c:	ee18 3a90 	vmov	r3, s17
    a110:	2b00      	cmp	r3, #0
    a112:	f2c0 821d 	blt.w	a550 <_svfprintf_r+0x1398>
    a116:	eeb0 ab48 	vmov.f64	d10, d8
    a11a:	2700      	movs	r7, #0
    a11c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a11e:	2b66      	cmp	r3, #102	; 0x66
    a120:	f000 8202 	beq.w	a528 <_svfprintf_r+0x1370>
    a124:	2b46      	cmp	r3, #70	; 0x46
    a126:	f000 80ec 	beq.w	a302 <_svfprintf_r+0x114a>
    a12a:	eeb0 0b4a 	vmov.f64	d0, d10
    a12e:	2d45      	cmp	r5, #69	; 0x45
    a130:	bf0c      	ite	eq
    a132:	f108 0401 	addeq.w	r4, r8, #1
    a136:	4644      	movne	r4, r8
    a138:	aa19      	add	r2, sp, #100	; 0x64
    a13a:	ab16      	add	r3, sp, #88	; 0x58
    a13c:	9201      	str	r2, [sp, #4]
    a13e:	9300      	str	r3, [sp, #0]
    a140:	4622      	mov	r2, r4
    a142:	ab15      	add	r3, sp, #84	; 0x54
    a144:	2102      	movs	r1, #2
    a146:	9805      	ldr	r0, [sp, #20]
    a148:	f7fe f9f2 	bl	8530 <_dtoa_r>
    a14c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a14e:	2b67      	cmp	r3, #103	; 0x67
    a150:	4606      	mov	r6, r0
    a152:	f040 820e 	bne.w	a572 <_svfprintf_r+0x13ba>
    a156:	f01b 0f01 	tst.w	fp, #1
    a15a:	f000 8266 	beq.w	a62a <_svfprintf_r+0x1472>
    a15e:	1931      	adds	r1, r6, r4
    a160:	eeb5 ab40 	vcmp.f64	d10, #0.0
    a164:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a168:	f000 8185 	beq.w	a476 <_svfprintf_r+0x12be>
    a16c:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a16e:	4299      	cmp	r1, r3
    a170:	d906      	bls.n	a180 <_svfprintf_r+0xfc8>
    a172:	2030      	movs	r0, #48	; 0x30
    a174:	1c5a      	adds	r2, r3, #1
    a176:	9219      	str	r2, [sp, #100]	; 0x64
    a178:	7018      	strb	r0, [r3, #0]
    a17a:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a17c:	4299      	cmp	r1, r3
    a17e:	d8f9      	bhi.n	a174 <_svfprintf_r+0xfbc>
    a180:	1b9b      	subs	r3, r3, r6
    a182:	2d47      	cmp	r5, #71	; 0x47
    a184:	930d      	str	r3, [sp, #52]	; 0x34
    a186:	f000 811f 	beq.w	a3c8 <_svfprintf_r+0x1210>
    a18a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a18c:	2b65      	cmp	r3, #101	; 0x65
    a18e:	f340 81ff 	ble.w	a590 <_svfprintf_r+0x13d8>
    a192:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a194:	2b66      	cmp	r3, #102	; 0x66
    a196:	9b15      	ldr	r3, [sp, #84]	; 0x54
    a198:	f000 81fc 	beq.w	a594 <_svfprintf_r+0x13dc>
    a19c:	930e      	str	r3, [sp, #56]	; 0x38
    a19e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    a1a0:	990d      	ldr	r1, [sp, #52]	; 0x34
    a1a2:	428a      	cmp	r2, r1
    a1a4:	f2c0 81d8 	blt.w	a558 <_svfprintf_r+0x13a0>
    a1a8:	f01b 0f01 	tst.w	fp, #1
    a1ac:	f040 8234 	bne.w	a618 <_svfprintf_r+0x1460>
    a1b0:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    a1b4:	9208      	str	r2, [sp, #32]
    a1b6:	2267      	movs	r2, #103	; 0x67
    a1b8:	920c      	str	r2, [sp, #48]	; 0x30
    a1ba:	2f00      	cmp	r7, #0
    a1bc:	f040 80f6 	bne.w	a3ac <_svfprintf_r+0x11f4>
    a1c0:	46b8      	mov	r8, r7
    a1c2:	9304      	str	r3, [sp, #16]
    a1c4:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    a1c8:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    a1cc:	f7ff b9e6 	b.w	959c <_svfprintf_r+0x3e4>
    a1d0:	f027 0707 	bic.w	r7, r7, #7
    a1d4:	f107 0308 	add.w	r3, r7, #8
    a1d8:	ed97 8b00 	vldr	d8, [r7]
    a1dc:	9309      	str	r3, [sp, #36]	; 0x24
    a1de:	f7ff b9be 	b.w	955e <_svfprintf_r+0x3a6>
    a1e2:	464e      	mov	r6, r9
    a1e4:	4689      	mov	r9, r1
    a1e6:	3201      	adds	r2, #1
    a1e8:	4423      	add	r3, r4
    a1ea:	2a07      	cmp	r2, #7
    a1ec:	931d      	str	r3, [sp, #116]	; 0x74
    a1ee:	921c      	str	r2, [sp, #112]	; 0x70
    a1f0:	f8c9 7000 	str.w	r7, [r9]
    a1f4:	f8c9 4004 	str.w	r4, [r9, #4]
    a1f8:	f73f aebd 	bgt.w	9f76 <_svfprintf_r+0xdbe>
    a1fc:	f109 0908 	add.w	r9, r9, #8
    a200:	e6c4      	b.n	9f8c <_svfprintf_r+0xdd4>
    a202:	2700      	movs	r7, #0
    a204:	45b8      	cmp	r8, r7
    a206:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    a20a:	f6ff ac54 	blt.w	9ab6 <_svfprintf_r+0x8fe>
    a20e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    a212:	e41e      	b.n	9a52 <_svfprintf_r+0x89a>
    a214:	aa1b      	add	r2, sp, #108	; 0x6c
    a216:	9903      	ldr	r1, [sp, #12]
    a218:	9805      	ldr	r0, [sp, #20]
    a21a:	f000 fa85 	bl	a728 <__ssprint_r>
    a21e:	2800      	cmp	r0, #0
    a220:	f47f a8c0 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a224:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a226:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a22a:	e463      	b.n	9af4 <_svfprintf_r+0x93c>
    a22c:	9f09      	ldr	r7, [sp, #36]	; 0x24
    a22e:	e43b      	b.n	9aa8 <_svfprintf_r+0x8f0>
    a230:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a232:	49b9      	ldr	r1, [pc, #740]	; (a518 <_svfprintf_r+0x1360>)
    a234:	f8c9 1000 	str.w	r1, [r9]
    a238:	3201      	adds	r2, #1
    a23a:	3301      	adds	r3, #1
    a23c:	2101      	movs	r1, #1
    a23e:	2a07      	cmp	r2, #7
    a240:	931d      	str	r3, [sp, #116]	; 0x74
    a242:	921c      	str	r2, [sp, #112]	; 0x70
    a244:	f8c9 1004 	str.w	r1, [r9, #4]
    a248:	dc76      	bgt.n	a338 <_svfprintf_r+0x1180>
    a24a:	f109 0908 	add.w	r9, r9, #8
    a24e:	b92c      	cbnz	r4, a25c <_svfprintf_r+0x10a4>
    a250:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    a252:	b91a      	cbnz	r2, a25c <_svfprintf_r+0x10a4>
    a254:	f01b 0f01 	tst.w	fp, #1
    a258:	f43f aa5f 	beq.w	971a <_svfprintf_r+0x562>
    a25c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a25e:	980f      	ldr	r0, [sp, #60]	; 0x3c
    a260:	9910      	ldr	r1, [sp, #64]	; 0x40
    a262:	f8c9 1000 	str.w	r1, [r9]
    a266:	3201      	adds	r2, #1
    a268:	4403      	add	r3, r0
    a26a:	2a07      	cmp	r2, #7
    a26c:	931d      	str	r3, [sp, #116]	; 0x74
    a26e:	f8c9 0004 	str.w	r0, [r9, #4]
    a272:	921c      	str	r2, [sp, #112]	; 0x70
    a274:	f300 81b6 	bgt.w	a5e4 <_svfprintf_r+0x142c>
    a278:	f109 0908 	add.w	r9, r9, #8
    a27c:	4264      	negs	r4, r4
    a27e:	2c00      	cmp	r4, #0
    a280:	f340 8087 	ble.w	a392 <_svfprintf_r+0x11da>
    a284:	2c10      	cmp	r4, #16
    a286:	4fa5      	ldr	r7, [pc, #660]	; (a51c <_svfprintf_r+0x1364>)
    a288:	f340 8112 	ble.w	a4b0 <_svfprintf_r+0x12f8>
    a28c:	4649      	mov	r1, r9
    a28e:	2510      	movs	r5, #16
    a290:	46b1      	mov	r9, r6
    a292:	f8dd 8014 	ldr.w	r8, [sp, #20]
    a296:	9e03      	ldr	r6, [sp, #12]
    a298:	e004      	b.n	a2a4 <_svfprintf_r+0x10ec>
    a29a:	3108      	adds	r1, #8
    a29c:	3c10      	subs	r4, #16
    a29e:	2c10      	cmp	r4, #16
    a2a0:	f340 8104 	ble.w	a4ac <_svfprintf_r+0x12f4>
    a2a4:	3201      	adds	r2, #1
    a2a6:	3310      	adds	r3, #16
    a2a8:	2a07      	cmp	r2, #7
    a2aa:	931d      	str	r3, [sp, #116]	; 0x74
    a2ac:	921c      	str	r2, [sp, #112]	; 0x70
    a2ae:	600f      	str	r7, [r1, #0]
    a2b0:	604d      	str	r5, [r1, #4]
    a2b2:	ddf2      	ble.n	a29a <_svfprintf_r+0x10e2>
    a2b4:	aa1b      	add	r2, sp, #108	; 0x6c
    a2b6:	4631      	mov	r1, r6
    a2b8:	4640      	mov	r0, r8
    a2ba:	f000 fa35 	bl	a728 <__ssprint_r>
    a2be:	2800      	cmp	r0, #0
    a2c0:	f47f a870 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a2c4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a2c6:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a2c8:	a928      	add	r1, sp, #160	; 0xa0
    a2ca:	e7e7      	b.n	a29c <_svfprintf_r+0x10e4>
    a2cc:	aa1b      	add	r2, sp, #108	; 0x6c
    a2ce:	9903      	ldr	r1, [sp, #12]
    a2d0:	9805      	ldr	r0, [sp, #20]
    a2d2:	f000 fa29 	bl	a728 <__ssprint_r>
    a2d6:	2800      	cmp	r0, #0
    a2d8:	f47f a864 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a2dc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a2de:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a2e2:	e41f      	b.n	9b24 <_svfprintf_r+0x96c>
    a2e4:	2140      	movs	r1, #64	; 0x40
    a2e6:	9805      	ldr	r0, [sp, #20]
    a2e8:	f7fc f98e 	bl	6608 <_malloc_r>
    a2ec:	9a03      	ldr	r2, [sp, #12]
    a2ee:	6010      	str	r0, [r2, #0]
    a2f0:	6110      	str	r0, [r2, #16]
    a2f2:	2800      	cmp	r0, #0
    a2f4:	f000 81ed 	beq.w	a6d2 <_svfprintf_r+0x151a>
    a2f8:	9a03      	ldr	r2, [sp, #12]
    a2fa:	2340      	movs	r3, #64	; 0x40
    a2fc:	6153      	str	r3, [r2, #20]
    a2fe:	f7fe bf74 	b.w	91ea <_svfprintf_r+0x32>
    a302:	aa19      	add	r2, sp, #100	; 0x64
    a304:	ab16      	add	r3, sp, #88	; 0x58
    a306:	9201      	str	r2, [sp, #4]
    a308:	9300      	str	r3, [sp, #0]
    a30a:	4642      	mov	r2, r8
    a30c:	ab15      	add	r3, sp, #84	; 0x54
    a30e:	2103      	movs	r1, #3
    a310:	eeb0 0b4a 	vmov.f64	d0, d10
    a314:	9805      	ldr	r0, [sp, #20]
    a316:	f7fe f90b 	bl	8530 <_dtoa_r>
    a31a:	4644      	mov	r4, r8
    a31c:	4606      	mov	r6, r0
    a31e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a320:	2b46      	cmp	r3, #70	; 0x46
    a322:	eb06 0104 	add.w	r1, r6, r4
    a326:	f47f af1b 	bne.w	a160 <_svfprintf_r+0xfa8>
    a32a:	7833      	ldrb	r3, [r6, #0]
    a32c:	2b30      	cmp	r3, #48	; 0x30
    a32e:	f000 818d 	beq.w	a64c <_svfprintf_r+0x1494>
    a332:	9c15      	ldr	r4, [sp, #84]	; 0x54
    a334:	4421      	add	r1, r4
    a336:	e713      	b.n	a160 <_svfprintf_r+0xfa8>
    a338:	aa1b      	add	r2, sp, #108	; 0x6c
    a33a:	9903      	ldr	r1, [sp, #12]
    a33c:	9805      	ldr	r0, [sp, #20]
    a33e:	f000 f9f3 	bl	a728 <__ssprint_r>
    a342:	2800      	cmp	r0, #0
    a344:	f47f a82e 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a348:	9c15      	ldr	r4, [sp, #84]	; 0x54
    a34a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a34c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a350:	e77d      	b.n	a24e <_svfprintf_r+0x1096>
    a352:	f1b8 0f00 	cmp.w	r8, #0
    a356:	bf08      	it	eq
    a358:	f04f 0801 	moveq.w	r8, #1
    a35c:	e6d3      	b.n	a106 <_svfprintf_r+0xf4e>
    a35e:	9309      	str	r3, [sp, #36]	; 0x24
    a360:	e6a4      	b.n	a0ac <_svfprintf_r+0xef4>
    a362:	9309      	str	r3, [sp, #36]	; 0x24
    a364:	4617      	mov	r7, r2
    a366:	f7ff ba7b 	b.w	9860 <_svfprintf_r+0x6a8>
    a36a:	4630      	mov	r0, r6
    a36c:	f7fd f948 	bl	7600 <strlen>
    a370:	46a0      	mov	r8, r4
    a372:	4603      	mov	r3, r0
    a374:	9008      	str	r0, [sp, #32]
    a376:	f7ff bb61 	b.w	9a3c <_svfprintf_r+0x884>
    a37a:	aa1b      	add	r2, sp, #108	; 0x6c
    a37c:	9903      	ldr	r1, [sp, #12]
    a37e:	9805      	ldr	r0, [sp, #20]
    a380:	f000 f9d2 	bl	a728 <__ssprint_r>
    a384:	2800      	cmp	r0, #0
    a386:	f47f a80d 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a38a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a38c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a38e:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a392:	980d      	ldr	r0, [sp, #52]	; 0x34
    a394:	f8c9 6000 	str.w	r6, [r9]
    a398:	3201      	adds	r2, #1
    a39a:	4403      	add	r3, r0
    a39c:	2a07      	cmp	r2, #7
    a39e:	931d      	str	r3, [sp, #116]	; 0x74
    a3a0:	921c      	str	r2, [sp, #112]	; 0x70
    a3a2:	f8c9 0004 	str.w	r0, [r9, #4]
    a3a6:	f77f a9b6 	ble.w	9716 <_svfprintf_r+0x55e>
    a3aa:	e476      	b.n	9c9a <_svfprintf_r+0xae2>
    a3ac:	272d      	movs	r7, #45	; 0x2d
    a3ae:	9304      	str	r3, [sp, #16]
    a3b0:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    a3b4:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    a3b8:	f04f 0800 	mov.w	r8, #0
    a3bc:	f7ff b8ef 	b.w	959e <_svfprintf_r+0x3e6>
    a3c0:	9709      	str	r7, [sp, #36]	; 0x24
    a3c2:	461f      	mov	r7, r3
    a3c4:	f7ff ba4c 	b.w	9860 <_svfprintf_r+0x6a8>
    a3c8:	9b15      	ldr	r3, [sp, #84]	; 0x54
    a3ca:	1cda      	adds	r2, r3, #3
    a3cc:	db02      	blt.n	a3d4 <_svfprintf_r+0x121c>
    a3ce:	4598      	cmp	r8, r3
    a3d0:	f6bf aee4 	bge.w	a19c <_svfprintf_r+0xfe4>
    a3d4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    a3d6:	3a02      	subs	r2, #2
    a3d8:	920c      	str	r2, [sp, #48]	; 0x30
    a3da:	3b01      	subs	r3, #1
    a3dc:	2b00      	cmp	r3, #0
    a3de:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    a3e2:	9315      	str	r3, [sp, #84]	; 0x54
    a3e4:	bfb8      	it	lt
    a3e6:	425b      	neglt	r3, r3
    a3e8:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
    a3ec:	bfb4      	ite	lt
    a3ee:	222d      	movlt	r2, #45	; 0x2d
    a3f0:	222b      	movge	r2, #43	; 0x2b
    a3f2:	2b09      	cmp	r3, #9
    a3f4:	f88d 205d 	strb.w	r2, [sp, #93]	; 0x5d
    a3f8:	f340 8106 	ble.w	a608 <_svfprintf_r+0x1450>
    a3fc:	f10d 006b 	add.w	r0, sp, #107	; 0x6b
    a400:	4604      	mov	r4, r0
    a402:	4a47      	ldr	r2, [pc, #284]	; (a520 <_svfprintf_r+0x1368>)
    a404:	fb82 2103 	smull	r2, r1, r2, r3
    a408:	17da      	asrs	r2, r3, #31
    a40a:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
    a40e:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    a412:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
    a416:	f103 0130 	add.w	r1, r3, #48	; 0x30
    a41a:	2a09      	cmp	r2, #9
    a41c:	4613      	mov	r3, r2
    a41e:	f804 1d01 	strb.w	r1, [r4, #-1]!
    a422:	dcee      	bgt.n	a402 <_svfprintf_r+0x124a>
    a424:	4621      	mov	r1, r4
    a426:	3330      	adds	r3, #48	; 0x30
    a428:	b2da      	uxtb	r2, r3
    a42a:	f801 2d01 	strb.w	r2, [r1, #-1]!
    a42e:	4288      	cmp	r0, r1
    a430:	f240 8162 	bls.w	a6f8 <_svfprintf_r+0x1540>
    a434:	f10d 015e 	add.w	r1, sp, #94	; 0x5e
    a438:	4623      	mov	r3, r4
    a43a:	e001      	b.n	a440 <_svfprintf_r+0x1288>
    a43c:	f813 2b01 	ldrb.w	r2, [r3], #1
    a440:	f801 2b01 	strb.w	r2, [r1], #1
    a444:	4298      	cmp	r0, r3
    a446:	d1f9      	bne.n	a43c <_svfprintf_r+0x1284>
    a448:	1c43      	adds	r3, r0, #1
    a44a:	1b1b      	subs	r3, r3, r4
    a44c:	f10d 025e 	add.w	r2, sp, #94	; 0x5e
    a450:	4413      	add	r3, r2
    a452:	aa17      	add	r2, sp, #92	; 0x5c
    a454:	1a9b      	subs	r3, r3, r2
    a456:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    a458:	9311      	str	r3, [sp, #68]	; 0x44
    a45a:	2a01      	cmp	r2, #1
    a45c:	4413      	add	r3, r2
    a45e:	9308      	str	r3, [sp, #32]
    a460:	f340 80ff 	ble.w	a662 <_svfprintf_r+0x14aa>
    a464:	9b08      	ldr	r3, [sp, #32]
    a466:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a468:	4413      	add	r3, r2
    a46a:	2200      	movs	r2, #0
    a46c:	9308      	str	r3, [sp, #32]
    a46e:	920e      	str	r2, [sp, #56]	; 0x38
    a470:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a474:	e6a1      	b.n	a1ba <_svfprintf_r+0x1002>
    a476:	460b      	mov	r3, r1
    a478:	e682      	b.n	a180 <_svfprintf_r+0xfc8>
    a47a:	aa1b      	add	r2, sp, #108	; 0x6c
    a47c:	9903      	ldr	r1, [sp, #12]
    a47e:	9805      	ldr	r0, [sp, #20]
    a480:	f000 f952 	bl	a728 <__ssprint_r>
    a484:	2800      	cmp	r0, #0
    a486:	f47e af8d 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a48a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a48c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a490:	e483      	b.n	9d9a <_svfprintf_r+0xbe2>
    a492:	aa1b      	add	r2, sp, #108	; 0x6c
    a494:	9903      	ldr	r1, [sp, #12]
    a496:	9805      	ldr	r0, [sp, #20]
    a498:	f000 f946 	bl	a728 <__ssprint_r>
    a49c:	2800      	cmp	r0, #0
    a49e:	f47e af81 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a4a2:	9a15      	ldr	r2, [sp, #84]	; 0x54
    a4a4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a4a6:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a4aa:	e579      	b.n	9fa0 <_svfprintf_r+0xde8>
    a4ac:	464e      	mov	r6, r9
    a4ae:	4689      	mov	r9, r1
    a4b0:	3201      	adds	r2, #1
    a4b2:	4423      	add	r3, r4
    a4b4:	2a07      	cmp	r2, #7
    a4b6:	931d      	str	r3, [sp, #116]	; 0x74
    a4b8:	921c      	str	r2, [sp, #112]	; 0x70
    a4ba:	f8c9 7000 	str.w	r7, [r9]
    a4be:	f8c9 4004 	str.w	r4, [r9, #4]
    a4c2:	f73f af5a 	bgt.w	a37a <_svfprintf_r+0x11c2>
    a4c6:	f109 0908 	add.w	r9, r9, #8
    a4ca:	e762      	b.n	a392 <_svfprintf_r+0x11da>
    a4cc:	aa1b      	add	r2, sp, #108	; 0x6c
    a4ce:	9903      	ldr	r1, [sp, #12]
    a4d0:	9805      	ldr	r0, [sp, #20]
    a4d2:	f000 f929 	bl	a728 <__ssprint_r>
    a4d6:	2800      	cmp	r0, #0
    a4d8:	f47e af64 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a4dc:	9a15      	ldr	r2, [sp, #84]	; 0x54
    a4de:	990d      	ldr	r1, [sp, #52]	; 0x34
    a4e0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a4e2:	1a8a      	subs	r2, r1, r2
    a4e4:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a4e8:	e572      	b.n	9fd0 <_svfprintf_r+0xe18>
    a4ea:	2d06      	cmp	r5, #6
    a4ec:	462b      	mov	r3, r5
    a4ee:	bf28      	it	cs
    a4f0:	2306      	movcs	r3, #6
    a4f2:	9308      	str	r3, [sp, #32]
    a4f4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a4f8:	46b0      	mov	r8, r6
    a4fa:	9709      	str	r7, [sp, #36]	; 0x24
    a4fc:	960e      	str	r6, [sp, #56]	; 0x38
    a4fe:	4637      	mov	r7, r6
    a500:	9304      	str	r3, [sp, #16]
    a502:	4e08      	ldr	r6, [pc, #32]	; (a524 <_svfprintf_r+0x136c>)
    a504:	f7ff b84a 	b.w	959c <_svfprintf_r+0x3e4>
    a508:	469b      	mov	fp, r3
    a50a:	f7ff b9ea 	b.w	98e2 <_svfprintf_r+0x72a>
    a50e:	272d      	movs	r7, #45	; 0x2d
    a510:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    a514:	f7ff b833 	b.w	957e <_svfprintf_r+0x3c6>
    a518:	20000f64 	.word	0x20000f64
    a51c:	2000114c 	.word	0x2000114c
    a520:	66666667 	.word	0x66666667
    a524:	20000fa0 	.word	0x20000fa0
    a528:	aa19      	add	r2, sp, #100	; 0x64
    a52a:	ab16      	add	r3, sp, #88	; 0x58
    a52c:	9201      	str	r2, [sp, #4]
    a52e:	9300      	str	r3, [sp, #0]
    a530:	2103      	movs	r1, #3
    a532:	ab15      	add	r3, sp, #84	; 0x54
    a534:	4642      	mov	r2, r8
    a536:	eeb0 0b4a 	vmov.f64	d0, d10
    a53a:	9805      	ldr	r0, [sp, #20]
    a53c:	f7fd fff8 	bl	8530 <_dtoa_r>
    a540:	4644      	mov	r4, r8
    a542:	4606      	mov	r6, r0
    a544:	eb00 0108 	add.w	r1, r0, r8
    a548:	e6ef      	b.n	a32a <_svfprintf_r+0x1172>
    a54a:	f04f 0806 	mov.w	r8, #6
    a54e:	e5da      	b.n	a106 <_svfprintf_r+0xf4e>
    a550:	eeb1 ab48 	vneg.f64	d10, d8
    a554:	272d      	movs	r7, #45	; 0x2d
    a556:	e5e1      	b.n	a11c <_svfprintf_r+0xf64>
    a558:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a55a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a55c:	4413      	add	r3, r2
    a55e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    a560:	9308      	str	r3, [sp, #32]
    a562:	2a00      	cmp	r2, #0
    a564:	f340 8086 	ble.w	a674 <_svfprintf_r+0x14bc>
    a568:	2267      	movs	r2, #103	; 0x67
    a56a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a56e:	920c      	str	r2, [sp, #48]	; 0x30
    a570:	e623      	b.n	a1ba <_svfprintf_r+0x1002>
    a572:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a574:	2b47      	cmp	r3, #71	; 0x47
    a576:	f47f adf2 	bne.w	a15e <_svfprintf_r+0xfa6>
    a57a:	f01b 0f01 	tst.w	fp, #1
    a57e:	f47f aece 	bne.w	a31e <_svfprintf_r+0x1166>
    a582:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a584:	2d47      	cmp	r5, #71	; 0x47
    a586:	eba3 0306 	sub.w	r3, r3, r6
    a58a:	930d      	str	r3, [sp, #52]	; 0x34
    a58c:	f43f af1c 	beq.w	a3c8 <_svfprintf_r+0x1210>
    a590:	9b15      	ldr	r3, [sp, #84]	; 0x54
    a592:	e722      	b.n	a3da <_svfprintf_r+0x1222>
    a594:	2b00      	cmp	r3, #0
    a596:	461a      	mov	r2, r3
    a598:	930e      	str	r3, [sp, #56]	; 0x38
    a59a:	dd73      	ble.n	a684 <_svfprintf_r+0x14cc>
    a59c:	f1b8 0f00 	cmp.w	r8, #0
    a5a0:	d14b      	bne.n	a63a <_svfprintf_r+0x1482>
    a5a2:	f01b 0f01 	tst.w	fp, #1
    a5a6:	d148      	bne.n	a63a <_svfprintf_r+0x1482>
    a5a8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a5ac:	9208      	str	r2, [sp, #32]
    a5ae:	e604      	b.n	a1ba <_svfprintf_r+0x1002>
    a5b0:	f01b 0f01 	tst.w	fp, #1
    a5b4:	4647      	mov	r7, r8
    a5b6:	d005      	beq.n	a5c4 <_svfprintf_r+0x140c>
    a5b8:	ae38      	add	r6, sp, #224	; 0xe0
    a5ba:	2330      	movs	r3, #48	; 0x30
    a5bc:	f806 3d41 	strb.w	r3, [r6, #-65]!
    a5c0:	f7ff b956 	b.w	9870 <_svfprintf_r+0x6b8>
    a5c4:	f8cd 8020 	str.w	r8, [sp, #32]
    a5c8:	ae28      	add	r6, sp, #160	; 0xa0
    a5ca:	f7ff b954 	b.w	9876 <_svfprintf_r+0x6be>
    a5ce:	ea25 73e5 	bic.w	r3, r5, r5, asr #31
    a5d2:	9709      	str	r7, [sp, #36]	; 0x24
    a5d4:	9304      	str	r3, [sp, #16]
    a5d6:	9508      	str	r5, [sp, #32]
    a5d8:	4680      	mov	r8, r0
    a5da:	900e      	str	r0, [sp, #56]	; 0x38
    a5dc:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    a5e0:	f7fe bfdc 	b.w	959c <_svfprintf_r+0x3e4>
    a5e4:	aa1b      	add	r2, sp, #108	; 0x6c
    a5e6:	9903      	ldr	r1, [sp, #12]
    a5e8:	9805      	ldr	r0, [sp, #20]
    a5ea:	f000 f89d 	bl	a728 <__ssprint_r>
    a5ee:	2800      	cmp	r0, #0
    a5f0:	f47e aed8 	bne.w	93a4 <_svfprintf_r+0x1ec>
    a5f4:	9c15      	ldr	r4, [sp, #84]	; 0x54
    a5f6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a5f8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a5fa:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a5fe:	e63d      	b.n	a27c <_svfprintf_r+0x10c4>
    a600:	46a2      	mov	sl, r4
    a602:	2500      	movs	r5, #0
    a604:	f7fe be33 	b.w	926e <_svfprintf_r+0xb6>
    a608:	3330      	adds	r3, #48	; 0x30
    a60a:	2230      	movs	r2, #48	; 0x30
    a60c:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    a610:	f88d 205e 	strb.w	r2, [sp, #94]	; 0x5e
    a614:	ab18      	add	r3, sp, #96	; 0x60
    a616:	e71c      	b.n	a452 <_svfprintf_r+0x129a>
    a618:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a61a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a61c:	4413      	add	r3, r2
    a61e:	2267      	movs	r2, #103	; 0x67
    a620:	9308      	str	r3, [sp, #32]
    a622:	920c      	str	r2, [sp, #48]	; 0x30
    a624:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a628:	e5c7      	b.n	a1ba <_svfprintf_r+0x1002>
    a62a:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a62c:	e5a8      	b.n	a180 <_svfprintf_r+0xfc8>
    a62e:	4e3c      	ldr	r6, [pc, #240]	; (a720 <_svfprintf_r+0x1568>)
    a630:	4b3c      	ldr	r3, [pc, #240]	; (a724 <_svfprintf_r+0x156c>)
    a632:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    a636:	f7fe bfa4 	b.w	9582 <_svfprintf_r+0x3ca>
    a63a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a63c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a63e:	189d      	adds	r5, r3, r2
    a640:	eb05 0308 	add.w	r3, r5, r8
    a644:	9308      	str	r3, [sp, #32]
    a646:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a64a:	e5b6      	b.n	a1ba <_svfprintf_r+0x1002>
    a64c:	eeb5 ab40 	vcmp.f64	d10, #0.0
    a650:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a654:	f43f ae6d 	beq.w	a332 <_svfprintf_r+0x117a>
    a658:	f1c4 0401 	rsb	r4, r4, #1
    a65c:	9415      	str	r4, [sp, #84]	; 0x54
    a65e:	4421      	add	r1, r4
    a660:	e57e      	b.n	a160 <_svfprintf_r+0xfa8>
    a662:	f01b 0301 	ands.w	r3, fp, #1
    a666:	f47f aefd 	bne.w	a464 <_svfprintf_r+0x12ac>
    a66a:	930e      	str	r3, [sp, #56]	; 0x38
    a66c:	9b08      	ldr	r3, [sp, #32]
    a66e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a672:	e5a2      	b.n	a1ba <_svfprintf_r+0x1002>
    a674:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a676:	9a08      	ldr	r2, [sp, #32]
    a678:	f1c3 0301 	rsb	r3, r3, #1
    a67c:	441a      	add	r2, r3
    a67e:	4613      	mov	r3, r2
    a680:	9208      	str	r2, [sp, #32]
    a682:	e771      	b.n	a568 <_svfprintf_r+0x13b0>
    a684:	f1b8 0f00 	cmp.w	r8, #0
    a688:	d102      	bne.n	a690 <_svfprintf_r+0x14d8>
    a68a:	f01b 0f01 	tst.w	fp, #1
    a68e:	d007      	beq.n	a6a0 <_svfprintf_r+0x14e8>
    a690:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    a692:	1c5d      	adds	r5, r3, #1
    a694:	eb05 0308 	add.w	r3, r5, r8
    a698:	9308      	str	r3, [sp, #32]
    a69a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a69e:	e58c      	b.n	a1ba <_svfprintf_r+0x1002>
    a6a0:	2301      	movs	r3, #1
    a6a2:	9308      	str	r3, [sp, #32]
    a6a4:	e589      	b.n	a1ba <_svfprintf_r+0x1002>
    a6a6:	9809      	ldr	r0, [sp, #36]	; 0x24
    a6a8:	f89a 3001 	ldrb.w	r3, [sl, #1]
    a6ac:	6805      	ldr	r5, [r0, #0]
    a6ae:	3004      	adds	r0, #4
    a6b0:	2d00      	cmp	r5, #0
    a6b2:	9009      	str	r0, [sp, #36]	; 0x24
    a6b4:	46a2      	mov	sl, r4
    a6b6:	f6be add8 	bge.w	926a <_svfprintf_r+0xb2>
    a6ba:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    a6be:	f7fe bdd4 	b.w	926a <_svfprintf_r+0xb2>
    a6c2:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a6c6:	f7ff b98d 	b.w	99e4 <_svfprintf_r+0x82c>
    a6ca:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a6ce:	f7ff b9cf 	b.w	9a70 <_svfprintf_r+0x8b8>
    a6d2:	9a05      	ldr	r2, [sp, #20]
    a6d4:	230c      	movs	r3, #12
    a6d6:	6013      	str	r3, [r2, #0]
    a6d8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a6dc:	f7fe be6b 	b.w	93b6 <_svfprintf_r+0x1fe>
    a6e0:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a6e4:	f7ff b8d4 	b.w	9890 <_svfprintf_r+0x6d8>
    a6e8:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a6ec:	f7ff b8a3 	b.w	9836 <_svfprintf_r+0x67e>
    a6f0:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a6f4:	f7ff b952 	b.w	999c <_svfprintf_r+0x7e4>
    a6f8:	f10d 035e 	add.w	r3, sp, #94	; 0x5e
    a6fc:	e6a9      	b.n	a452 <_svfprintf_r+0x129a>
    a6fe:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a702:	f7fe be62 	b.w	93ca <_svfprintf_r+0x212>
    a706:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a70a:	f7ff b862 	b.w	97d2 <_svfprintf_r+0x61a>
    a70e:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a712:	f7fe bf16 	b.w	9542 <_svfprintf_r+0x38a>
    a716:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a71a:	f7fe bed0 	b.w	94be <_svfprintf_r+0x306>
    a71e:	bf00      	nop
    a720:	20000f74 	.word	0x20000f74
    a724:	20000f70 	.word	0x20000f70

0000a728 <__ssprint_r>:
    a728:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a72c:	6893      	ldr	r3, [r2, #8]
    a72e:	b083      	sub	sp, #12
    a730:	4690      	mov	r8, r2
    a732:	2b00      	cmp	r3, #0
    a734:	d072      	beq.n	a81c <__ssprint_r+0xf4>
    a736:	4683      	mov	fp, r0
    a738:	f04f 0900 	mov.w	r9, #0
    a73c:	6816      	ldr	r6, [r2, #0]
    a73e:	6808      	ldr	r0, [r1, #0]
    a740:	688b      	ldr	r3, [r1, #8]
    a742:	460d      	mov	r5, r1
    a744:	464c      	mov	r4, r9
    a746:	2c00      	cmp	r4, #0
    a748:	d045      	beq.n	a7d6 <__ssprint_r+0xae>
    a74a:	429c      	cmp	r4, r3
    a74c:	461f      	mov	r7, r3
    a74e:	469a      	mov	sl, r3
    a750:	d346      	bcc.n	a7e0 <__ssprint_r+0xb8>
    a752:	89ab      	ldrh	r3, [r5, #12]
    a754:	f413 6f90 	tst.w	r3, #1152	; 0x480
    a758:	d02d      	beq.n	a7b6 <__ssprint_r+0x8e>
    a75a:	696f      	ldr	r7, [r5, #20]
    a75c:	6929      	ldr	r1, [r5, #16]
    a75e:	eb07 0747 	add.w	r7, r7, r7, lsl #1
    a762:	ebc1 0a00 	rsb	sl, r1, r0
    a766:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
    a76a:	1c60      	adds	r0, r4, #1
    a76c:	107f      	asrs	r7, r7, #1
    a76e:	4450      	add	r0, sl
    a770:	42b8      	cmp	r0, r7
    a772:	463a      	mov	r2, r7
    a774:	bf84      	itt	hi
    a776:	4607      	movhi	r7, r0
    a778:	463a      	movhi	r2, r7
    a77a:	055b      	lsls	r3, r3, #21
    a77c:	d533      	bpl.n	a7e6 <__ssprint_r+0xbe>
    a77e:	4611      	mov	r1, r2
    a780:	4658      	mov	r0, fp
    a782:	f7fb ff41 	bl	6608 <_malloc_r>
    a786:	2800      	cmp	r0, #0
    a788:	d037      	beq.n	a7fa <__ssprint_r+0xd2>
    a78a:	4652      	mov	r2, sl
    a78c:	6929      	ldr	r1, [r5, #16]
    a78e:	9001      	str	r0, [sp, #4]
    a790:	f7fc fa08 	bl	6ba4 <memcpy>
    a794:	89aa      	ldrh	r2, [r5, #12]
    a796:	9b01      	ldr	r3, [sp, #4]
    a798:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    a79c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    a7a0:	81aa      	strh	r2, [r5, #12]
    a7a2:	ebca 0207 	rsb	r2, sl, r7
    a7a6:	eb03 000a 	add.w	r0, r3, sl
    a7aa:	616f      	str	r7, [r5, #20]
    a7ac:	612b      	str	r3, [r5, #16]
    a7ae:	6028      	str	r0, [r5, #0]
    a7b0:	60aa      	str	r2, [r5, #8]
    a7b2:	4627      	mov	r7, r4
    a7b4:	46a2      	mov	sl, r4
    a7b6:	4652      	mov	r2, sl
    a7b8:	4649      	mov	r1, r9
    a7ba:	f7fc fa8d 	bl	6cd8 <memmove>
    a7be:	f8d8 2008 	ldr.w	r2, [r8, #8]
    a7c2:	68ab      	ldr	r3, [r5, #8]
    a7c4:	6828      	ldr	r0, [r5, #0]
    a7c6:	1bdb      	subs	r3, r3, r7
    a7c8:	4450      	add	r0, sl
    a7ca:	1b14      	subs	r4, r2, r4
    a7cc:	60ab      	str	r3, [r5, #8]
    a7ce:	6028      	str	r0, [r5, #0]
    a7d0:	f8c8 4008 	str.w	r4, [r8, #8]
    a7d4:	b314      	cbz	r4, a81c <__ssprint_r+0xf4>
    a7d6:	f8d6 9000 	ldr.w	r9, [r6]
    a7da:	6874      	ldr	r4, [r6, #4]
    a7dc:	3608      	adds	r6, #8
    a7de:	e7b2      	b.n	a746 <__ssprint_r+0x1e>
    a7e0:	4627      	mov	r7, r4
    a7e2:	46a2      	mov	sl, r4
    a7e4:	e7e7      	b.n	a7b6 <__ssprint_r+0x8e>
    a7e6:	4658      	mov	r0, fp
    a7e8:	f7fc fb34 	bl	6e54 <_realloc_r>
    a7ec:	4603      	mov	r3, r0
    a7ee:	2800      	cmp	r0, #0
    a7f0:	d1d7      	bne.n	a7a2 <__ssprint_r+0x7a>
    a7f2:	6929      	ldr	r1, [r5, #16]
    a7f4:	4658      	mov	r0, fp
    a7f6:	f7fd f947 	bl	7a88 <_free_r>
    a7fa:	230c      	movs	r3, #12
    a7fc:	f8cb 3000 	str.w	r3, [fp]
    a800:	89ab      	ldrh	r3, [r5, #12]
    a802:	2200      	movs	r2, #0
    a804:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a808:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a80c:	81ab      	strh	r3, [r5, #12]
    a80e:	f8c8 2008 	str.w	r2, [r8, #8]
    a812:	f8c8 2004 	str.w	r2, [r8, #4]
    a816:	b003      	add	sp, #12
    a818:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a81c:	2000      	movs	r0, #0
    a81e:	f8c8 0004 	str.w	r0, [r8, #4]
    a822:	b003      	add	sp, #12
    a824:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000a828 <___reboot_Teensyduino__veneer>:
    a828:	f85f f000 	ldr.w	pc, [pc]	; a82c <___reboot_Teensyduino__veneer+0x4>
    a82c:	60001dc5 	.word	0x60001dc5

0000a830 <___ZN7TwoWire5beginEv_veneer>:
    a830:	f85f f000 	ldr.w	pc, [pc]	; a834 <___ZN7TwoWire5beginEv_veneer+0x4>
    a834:	60001e19 	.word	0x60001e19

0000a838 <___init_veneer>:
    a838:	f85f f000 	ldr.w	pc, [pc]	; a83c <___init_veneer+0x4>
    a83c:	6000204d 	.word	0x6000204d

Disassembly of section .fini:

0000a840 <_fini>:
    a840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a842:	bf00      	nop

Disassembly of section .text.csf:

6000ed84 <_heap_end+0x3fd8ed84>:
6000ed84:	ffffffff 	.word	0xffffffff
6000ed88:	ffffffff 	.word	0xffffffff
6000ed8c:	ffffffff 	.word	0xffffffff
6000ed90:	ffffffff 	.word	0xffffffff
6000ed94:	ffffffff 	.word	0xffffffff
6000ed98:	ffffffff 	.word	0xffffffff
6000ed9c:	ffffffff 	.word	0xffffffff
6000eda0:	ffffffff 	.word	0xffffffff
6000eda4:	ffffffff 	.word	0xffffffff
6000eda8:	ffffffff 	.word	0xffffffff
6000edac:	ffffffff 	.word	0xffffffff
6000edb0:	ffffffff 	.word	0xffffffff
6000edb4:	ffffffff 	.word	0xffffffff
6000edb8:	ffffffff 	.word	0xffffffff
6000edbc:	ffffffff 	.word	0xffffffff
6000edc0:	ffffffff 	.word	0xffffffff
6000edc4:	ffffffff 	.word	0xffffffff
6000edc8:	ffffffff 	.word	0xffffffff
6000edcc:	ffffffff 	.word	0xffffffff
6000edd0:	ffffffff 	.word	0xffffffff
6000edd4:	ffffffff 	.word	0xffffffff
6000edd8:	ffffffff 	.word	0xffffffff
6000eddc:	ffffffff 	.word	0xffffffff
6000ede0:	ffffffff 	.word	0xffffffff
6000ede4:	ffffffff 	.word	0xffffffff
6000ede8:	ffffffff 	.word	0xffffffff
6000edec:	ffffffff 	.word	0xffffffff
6000edf0:	ffffffff 	.word	0xffffffff
6000edf4:	ffffffff 	.word	0xffffffff
6000edf8:	ffffffff 	.word	0xffffffff
6000edfc:	ffffffff 	.word	0xffffffff
6000ee00:	ffffffff 	.word	0xffffffff
6000ee04:	ffffffff 	.word	0xffffffff
6000ee08:	ffffffff 	.word	0xffffffff
6000ee0c:	ffffffff 	.word	0xffffffff
6000ee10:	ffffffff 	.word	0xffffffff
6000ee14:	ffffffff 	.word	0xffffffff
6000ee18:	ffffffff 	.word	0xffffffff
6000ee1c:	ffffffff 	.word	0xffffffff
6000ee20:	ffffffff 	.word	0xffffffff
6000ee24:	ffffffff 	.word	0xffffffff
6000ee28:	ffffffff 	.word	0xffffffff
6000ee2c:	ffffffff 	.word	0xffffffff
6000ee30:	ffffffff 	.word	0xffffffff
6000ee34:	ffffffff 	.word	0xffffffff
6000ee38:	ffffffff 	.word	0xffffffff
6000ee3c:	ffffffff 	.word	0xffffffff
6000ee40:	ffffffff 	.word	0xffffffff
6000ee44:	ffffffff 	.word	0xffffffff
6000ee48:	ffffffff 	.word	0xffffffff
6000ee4c:	ffffffff 	.word	0xffffffff
6000ee50:	ffffffff 	.word	0xffffffff
6000ee54:	ffffffff 	.word	0xffffffff
6000ee58:	ffffffff 	.word	0xffffffff
6000ee5c:	ffffffff 	.word	0xffffffff
6000ee60:	ffffffff 	.word	0xffffffff
6000ee64:	ffffffff 	.word	0xffffffff
6000ee68:	ffffffff 	.word	0xffffffff
6000ee6c:	ffffffff 	.word	0xffffffff
6000ee70:	ffffffff 	.word	0xffffffff
6000ee74:	ffffffff 	.word	0xffffffff
6000ee78:	ffffffff 	.word	0xffffffff
6000ee7c:	ffffffff 	.word	0xffffffff
6000ee80:	ffffffff 	.word	0xffffffff
6000ee84:	ffffffff 	.word	0xffffffff
6000ee88:	ffffffff 	.word	0xffffffff
6000ee8c:	ffffffff 	.word	0xffffffff
6000ee90:	ffffffff 	.word	0xffffffff
6000ee94:	ffffffff 	.word	0xffffffff
6000ee98:	ffffffff 	.word	0xffffffff
6000ee9c:	ffffffff 	.word	0xffffffff
6000eea0:	ffffffff 	.word	0xffffffff
6000eea4:	ffffffff 	.word	0xffffffff
6000eea8:	ffffffff 	.word	0xffffffff
6000eeac:	ffffffff 	.word	0xffffffff
6000eeb0:	ffffffff 	.word	0xffffffff
6000eeb4:	ffffffff 	.word	0xffffffff
6000eeb8:	ffffffff 	.word	0xffffffff
6000eebc:	ffffffff 	.word	0xffffffff
6000eec0:	ffffffff 	.word	0xffffffff
6000eec4:	ffffffff 	.word	0xffffffff
6000eec8:	ffffffff 	.word	0xffffffff
6000eecc:	ffffffff 	.word	0xffffffff
6000eed0:	ffffffff 	.word	0xffffffff
6000eed4:	ffffffff 	.word	0xffffffff
6000eed8:	ffffffff 	.word	0xffffffff
6000eedc:	ffffffff 	.word	0xffffffff
6000eee0:	ffffffff 	.word	0xffffffff
6000eee4:	ffffffff 	.word	0xffffffff
6000eee8:	ffffffff 	.word	0xffffffff
6000eeec:	ffffffff 	.word	0xffffffff
6000eef0:	ffffffff 	.word	0xffffffff
6000eef4:	ffffffff 	.word	0xffffffff
6000eef8:	ffffffff 	.word	0xffffffff
6000eefc:	ffffffff 	.word	0xffffffff
6000ef00:	ffffffff 	.word	0xffffffff
6000ef04:	ffffffff 	.word	0xffffffff
6000ef08:	ffffffff 	.word	0xffffffff
6000ef0c:	ffffffff 	.word	0xffffffff
6000ef10:	ffffffff 	.word	0xffffffff
6000ef14:	ffffffff 	.word	0xffffffff
6000ef18:	ffffffff 	.word	0xffffffff
6000ef1c:	ffffffff 	.word	0xffffffff
6000ef20:	ffffffff 	.word	0xffffffff
6000ef24:	ffffffff 	.word	0xffffffff
6000ef28:	ffffffff 	.word	0xffffffff
6000ef2c:	ffffffff 	.word	0xffffffff
6000ef30:	ffffffff 	.word	0xffffffff
6000ef34:	ffffffff 	.word	0xffffffff
6000ef38:	ffffffff 	.word	0xffffffff
6000ef3c:	ffffffff 	.word	0xffffffff
6000ef40:	ffffffff 	.word	0xffffffff
6000ef44:	ffffffff 	.word	0xffffffff
6000ef48:	ffffffff 	.word	0xffffffff
6000ef4c:	ffffffff 	.word	0xffffffff
6000ef50:	ffffffff 	.word	0xffffffff
6000ef54:	ffffffff 	.word	0xffffffff
6000ef58:	ffffffff 	.word	0xffffffff
6000ef5c:	ffffffff 	.word	0xffffffff
6000ef60:	ffffffff 	.word	0xffffffff
6000ef64:	ffffffff 	.word	0xffffffff
6000ef68:	ffffffff 	.word	0xffffffff
6000ef6c:	ffffffff 	.word	0xffffffff
6000ef70:	ffffffff 	.word	0xffffffff
6000ef74:	ffffffff 	.word	0xffffffff
6000ef78:	ffffffff 	.word	0xffffffff
6000ef7c:	ffffffff 	.word	0xffffffff
6000ef80:	ffffffff 	.word	0xffffffff
6000ef84:	ffffffff 	.word	0xffffffff
6000ef88:	ffffffff 	.word	0xffffffff
6000ef8c:	ffffffff 	.word	0xffffffff
6000ef90:	ffffffff 	.word	0xffffffff
6000ef94:	ffffffff 	.word	0xffffffff
6000ef98:	ffffffff 	.word	0xffffffff
6000ef9c:	ffffffff 	.word	0xffffffff
6000efa0:	ffffffff 	.word	0xffffffff
6000efa4:	ffffffff 	.word	0xffffffff
6000efa8:	ffffffff 	.word	0xffffffff
6000efac:	ffffffff 	.word	0xffffffff
6000efb0:	ffffffff 	.word	0xffffffff
6000efb4:	ffffffff 	.word	0xffffffff
6000efb8:	ffffffff 	.word	0xffffffff
6000efbc:	ffffffff 	.word	0xffffffff
6000efc0:	ffffffff 	.word	0xffffffff
6000efc4:	ffffffff 	.word	0xffffffff
6000efc8:	ffffffff 	.word	0xffffffff
6000efcc:	ffffffff 	.word	0xffffffff
6000efd0:	ffffffff 	.word	0xffffffff
6000efd4:	ffffffff 	.word	0xffffffff
6000efd8:	ffffffff 	.word	0xffffffff
6000efdc:	ffffffff 	.word	0xffffffff
6000efe0:	ffffffff 	.word	0xffffffff
6000efe4:	ffffffff 	.word	0xffffffff
6000efe8:	ffffffff 	.word	0xffffffff
6000efec:	ffffffff 	.word	0xffffffff
6000eff0:	ffffffff 	.word	0xffffffff
6000eff4:	ffffffff 	.word	0xffffffff
6000eff8:	ffffffff 	.word	0xffffffff
6000effc:	ffffffff 	.word	0xffffffff

6000f000 <hab_csf>:
	...
