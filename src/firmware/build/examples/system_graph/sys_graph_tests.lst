
/Users/mitchellscott/Desktop/rufous/src/firmware/build/examples/system_graph/sys_graph_tests.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001400:	4288      	cmp	r0, r1
60001402:	d007      	beq.n	60001414 <memory_copy+0x14>
	while (dest < dest_end) {
60001404:	4290      	cmp	r0, r2
60001406:	d205      	bcs.n	60001414 <memory_copy+0x14>
		*dest++ = *src++;
60001408:	f851 3b04 	ldr.w	r3, [r1], #4
6000140c:	f840 3b04 	str.w	r3, [r0], #4

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001410:	4282      	cmp	r2, r0
60001412:	d8f9      	bhi.n	60001408 <memory_copy+0x8>
60001414:	4770      	bx	lr
60001416:	bf00      	nop

60001418 <memory_clear>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001418:	4288      	cmp	r0, r1
6000141a:	d204      	bcs.n	60001426 <memory_clear+0xe>
		*dest++ = 0;
6000141c:	2300      	movs	r3, #0
6000141e:	f840 3b04 	str.w	r3, [r0], #4
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001422:	4281      	cmp	r1, r0
60001424:	d8fb      	bhi.n	6000141e <memory_clear+0x6>
60001426:	4770      	bx	lr

60001428 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001428:	4b66      	ldr	r3, [pc, #408]	; (600015c4 <ResetHandler+0x19c>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000142a:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000142e:	4a66      	ldr	r2, [pc, #408]	; (600015c8 <ResetHandler+0x1a0>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001430:	4866      	ldr	r0, [pc, #408]	; (600015cc <ResetHandler+0x1a4>)
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
void startup_late_hook(void)	__attribute__ ((weak, alias("startup_default_late_hook")));
__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
void ResetHandler(void)
{
60001432:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001436:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001438:	6418      	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143a:	4a65      	ldr	r2, [pc, #404]	; (600015d0 <ResetHandler+0x1a8>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000143c:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143e:	4695      	mov	sp, r2
	__asm__ volatile("dsb":::"memory");
60001440:	f3bf 8f4f 	dsb	sy
	__asm__ volatile("isb":::"memory");
60001444:	f3bf 8f6f 	isb	sy
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
60001448:	f000 f930 	bl	600016ac <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000144c:	4b61      	ldr	r3, [pc, #388]	; (600015d4 <ResetHandler+0x1ac>)
6000144e:	2008      	movs	r0, #8
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001450:	4a61      	ldr	r2, [pc, #388]	; (600015d8 <ResetHandler+0x1b0>)
60001452:	4962      	ldr	r1, [pc, #392]	; (600015dc <ResetHandler+0x1b4>)
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
	__asm__ volatile("dsb":::"memory");
	__asm__ volatile("isb":::"memory");
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001454:	f8c3 0154 	str.w	r0, [r3, #340]	; 0x154
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001458:	4861      	ldr	r0, [pc, #388]	; (600015e0 <ResetHandler+0x1b8>)
6000145a:	f7ff ffd1 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
6000145e:	4a61      	ldr	r2, [pc, #388]	; (600015e4 <ResetHandler+0x1bc>)
60001460:	4961      	ldr	r1, [pc, #388]	; (600015e8 <ResetHandler+0x1c0>)
60001462:	4862      	ldr	r0, [pc, #392]	; (600015ec <ResetHandler+0x1c4>)
60001464:	f7ff ffcc 	bl	60001400 <memory_copy>
	memory_clear(&_sbss, &_ebss);
60001468:	4961      	ldr	r1, [pc, #388]	; (600015f0 <ResetHandler+0x1c8>)
6000146a:	4862      	ldr	r0, [pc, #392]	; (600015f4 <ResetHandler+0x1cc>)
6000146c:	f7ff ffd4 	bl	60001418 <memory_clear>
60001470:	4c61      	ldr	r4, [pc, #388]	; (600015f8 <ResetHandler+0x1d0>)

	// enable FPU
	SCB_CPACR = 0x00F00000;
60001472:	4962      	ldr	r1, [pc, #392]	; (600015fc <ResetHandler+0x1d4>)
60001474:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001478:	2300      	movs	r3, #0
6000147a:	4a61      	ldr	r2, [pc, #388]	; (60001600 <ResetHandler+0x1d8>)
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
6000147c:	6008      	str	r0, [r1, #0]

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000147e:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
60001482:	3301      	adds	r3, #1
60001484:	2bb0      	cmp	r3, #176	; 0xb0
60001486:	d1fa      	bne.n	6000147e <ResetHandler+0x56>
60001488:	4b5e      	ldr	r3, [pc, #376]	; (60001604 <ResetHandler+0x1dc>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
6000148a:	2180      	movs	r1, #128	; 0x80
6000148c:	4a5e      	ldr	r2, [pc, #376]	; (60001608 <ResetHandler+0x1e0>)
6000148e:	f803 1b01 	strb.w	r1, [r3], #1
60001492:	4293      	cmp	r3, r2
60001494:	d1fb      	bne.n	6000148e <ResetHandler+0x66>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001496:	4d4f      	ldr	r5, [pc, #316]	; (600015d4 <ResetHandler+0x1ac>)
60001498:	f04f 3880 	mov.w	r8, #2155905152	; 0x80808080
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
6000149c:	495b      	ldr	r1, [pc, #364]	; (6000160c <ResetHandler+0x1e4>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
6000149e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014a2:	4b5b      	ldr	r3, [pc, #364]	; (60001610 <ResetHandler+0x1e8>)
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600014a4:	2600      	movs	r6, #0

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014a6:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 6000164c <ResetHandler+0x224>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014aa:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 60001650 <ResetHandler+0x228>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014ae:	601c      	str	r4, [r3, #0]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014b0:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014b4:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014b8:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014bc:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c0:	680b      	ldr	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014c2:	4f54      	ldr	r7, [pc, #336]	; (60001614 <ResetHandler+0x1ec>)
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c4:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
600014c8:	600b      	str	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ca:	69fb      	ldr	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014cc:	493d      	ldr	r1, [pc, #244]	; (600015c4 <ResetHandler+0x19c>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ce:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014d6:	61fb      	str	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
600014da:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014e2:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014e4:	668a      	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
600014e6:	66ca      	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
600014e8:	670a      	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
600014ea:	674a      	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
600014ec:	f000 f8e4 	bl	600016b8 <configure_cache>
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f0:	4a49      	ldr	r2, [pc, #292]	; (60001618 <ResetHandler+0x1f0>)
	_VectorsRam[15] = systick_isr;
600014f2:	4b4a      	ldr	r3, [pc, #296]	; (6000161c <ResetHandler+0x1f4>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014f4:	2063      	movs	r0, #99	; 0x63
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f6:	63a2      	str	r2, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
600014f8:	2103      	movs	r1, #3

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
600014fa:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014fc:	4a48      	ldr	r2, [pc, #288]	; (60001620 <ResetHandler+0x1f8>)
	SYST_CVR = 0;
600014fe:	4b49      	ldr	r3, [pc, #292]	; (60001624 <ResetHandler+0x1fc>)
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001500:	6010      	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001502:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
60001506:	601e      	str	r6, [r3, #0]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001508:	f842 1c04 	str.w	r1, [r2, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000150c:	f600 70a1 	addw	r0, r0, #4001	; 0xfa1
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001510:	4945      	ldr	r1, [pc, #276]	; (60001628 <ResetHandler+0x200>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001512:	4a46      	ldr	r2, [pc, #280]	; (6000162c <ResetHandler+0x204>)
60001514:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001518:	680b      	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000151a:	4a45      	ldr	r2, [pc, #276]	; (60001630 <ResetHandler+0x208>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000151c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
60001520:	600b      	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001522:	6813      	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001524:	4943      	ldr	r1, [pc, #268]	; (60001634 <ResetHandler+0x20c>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001526:	f043 0301 	orr.w	r3, r3, #1
6000152a:	6013      	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000152c:	6803      	ldr	r3, [r0, #0]
6000152e:	600b      	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
60001530:	f000 fb12 	bl	60001b58 <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001534:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001538:	483f      	ldr	r0, [pc, #252]	; (60001638 <ResetHandler+0x210>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000153a:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000153e:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001542:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001546:	f000 fd93 	bl	60002070 <__set_arm_clock_veneer>
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154a:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
6000154c:	4a3b      	ldr	r2, [pc, #236]	; (6000163c <ResetHandler+0x214>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154e:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001552:	4b3b      	ldr	r3, [pc, #236]	; (60001640 <ResetHandler+0x218>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001554:	66f9      	str	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
60001556:	6016      	str	r6, [r2, #0]
	PIT_TCTRL0 = 0;
60001558:	f8c2 6108 	str.w	r6, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000155c:	f8c2 6118 	str.w	r6, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001560:	f8c2 6128 	str.w	r6, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001564:	f8c2 6138 	str.w	r6, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001568:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000156a:	07d2      	lsls	r2, r2, #31
6000156c:	d408      	bmi.n	60001580 <ResetHandler+0x158>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000156e:	f642 6215 	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
60001572:	4934      	ldr	r1, [pc, #208]	; (60001644 <ResetHandler+0x21c>)
60001574:	6559      	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001576:	651a      	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001578:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000157a:	f042 0201 	orr.w	r2, r2, #1
6000157e:	639a      	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
60001580:	4a2f      	ldr	r2, [pc, #188]	; (60001640 <ResetHandler+0x218>)
60001582:	4c31      	ldr	r4, [pc, #196]	; (60001648 <ResetHandler+0x220>)
60001584:	6893      	ldr	r3, [r2, #8]
60001586:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
6000158a:	6093      	str	r3, [r2, #8]

#ifdef ARDUINO_TEENSY41
	configure_external_ram();
6000158c:	f000 f906 	bl	6000179c <configure_external_ram>
#endif
	analog_init();
60001590:	f000 f860 	bl	60001654 <analog_init>
	pwm_init();
60001594:	f000 fd7c 	bl	60002090 <__pwm_init_veneer>
	tempmon_init();
60001598:	f000 fb10 	bl	60001bbc <tempmon_init>
	startup_middle_hook();
6000159c:	f000 f888 	bl	600016b0 <startup_default_middle_hook>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
600015a0:	6823      	ldr	r3, [r4, #0]
#endif
	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290?p=87273&viewfull=1#post87273

	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015a2:	2b13      	cmp	r3, #19
600015a4:	d9fc      	bls.n	600015a0 <ResetHandler+0x178>
	usb_init();
600015a6:	f000 fb97 	bl	60001cd8 <usb_init>
600015aa:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015ac:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
600015b0:	d3fb      	bcc.n	600015aa <ResetHandler+0x182>
	//printf("before C++ constructors\n");
	startup_late_hook();
600015b2:	f000 f87f 	bl	600016b4 <startup_default_late_hook>
	__libc_init_array();
600015b6:	f000 fd57 	bl	60002068 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
600015ba:	f000 fd4d 	bl	60002058 <__main_veneer>
	
	while (1) asm("WFI");
600015be:	bf30      	wfi
600015c0:	e7fd      	b.n	600015be <ResetHandler+0x196>
600015c2:	bf00      	nop
600015c4:	400ac000 	.word	0x400ac000
600015c8:	aaaaaaaf 	.word	0xaaaaaaaf
600015cc:	00200007 	.word	0x00200007
600015d0:	20070000 	.word	0x20070000
600015d4:	400d8000 	.word	0x400d8000
600015d8:	0000a908 	.word	0x0000a908
600015dc:	6000227c 	.word	0x6000227c
600015e0:	00000000 	.word	0x00000000
600015e4:	200022c0 	.word	0x200022c0
600015e8:	6000cb88 	.word	0x6000cb88
600015ec:	20000000 	.word	0x20000000
600015f0:	20002820 	.word	0x20002820
600015f4:	200022c0 	.word	0x200022c0
600015f8:	20002000 	.word	0x20002000
600015fc:	e000ed88 	.word	0xe000ed88
60001600:	00001d8d 	.word	0x00001d8d
60001604:	e000e400 	.word	0xe000e400
60001608:	e000e4a0 	.word	0xe000e4a0
6000160c:	e000ed24 	.word	0xe000ed24
60001610:	e000ed08 	.word	0xe000ed08
60001614:	400fc000 	.word	0x400fc000
60001618:	00002eed 	.word	0x00002eed
6000161c:	00002ef1 	.word	0x00002ef1
60001620:	e000e014 	.word	0xe000e014
60001624:	e000e018 	.word	0xe000e018
60001628:	e000edfc 	.word	0xe000edfc
6000162c:	20200000 	.word	0x20200000
60001630:	e0001000 	.word	0xe0001000
60001634:	20002740 	.word	0x20002740
60001638:	23c34600 	.word	0x23c34600
6000163c:	40084000 	.word	0x40084000
60001640:	400d4000 	.word	0x400d4000
60001644:	56c00000 	.word	0x56c00000
60001648:	20002744 	.word	0x20002744
6000164c:	2018101b 	.word	0x2018101b
60001650:	13110d0c 	.word	0x13110d0c

60001654 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001654:	4b11      	ldr	r3, [pc, #68]	; (6000169c <analog_init+0x48>)
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001656:	4912      	ldr	r1, [pc, #72]	; (600016a0 <analog_init+0x4c>)
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001658:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
6000165a:	460a      	mov	r2, r1
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
6000165c:	f440 3040 	orr.w	r0, r0, #196608	; 0x30000
}

#define MAX_ADC_CLOCK 20000000

FLASHMEM void analog_init(void)
{
60001660:	b430      	push	{r4, r5}
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001662:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001664:	f240 6537 	movw	r5, #1591	; 0x637
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001668:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
6000166a:	24a0      	movs	r4, #160	; 0xa0
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
6000166c:	f440 7040 	orr.w	r0, r0, #768	; 0x300
60001670:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001672:	644d      	str	r5, [r1, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001674:	648c      	str	r4, [r1, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
60001676:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001678:	061b      	lsls	r3, r3, #24
6000167a:	d4fc      	bmi.n	60001676 <analog_init+0x22>
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
6000167c:	4b09      	ldr	r3, [pc, #36]	; (600016a4 <analog_init+0x50>)
6000167e:	f240 6037 	movw	r0, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001682:	21a0      	movs	r1, #160	; 0xa0
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
60001684:	461a      	mov	r2, r3
	while (ADC1_GC & ADC_GC_CAL) {
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001686:	6458      	str	r0, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001688:	6499      	str	r1, [r3, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
6000168a:	6c93      	ldr	r3, [r2, #72]	; 0x48
6000168c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
60001690:	d1fb      	bne.n	6000168a <analog_init+0x36>
		//yield();
	}
	calibrating = 0;
60001692:	4a05      	ldr	r2, [pc, #20]	; (600016a8 <analog_init+0x54>)
60001694:	7013      	strb	r3, [r2, #0]
}
60001696:	bc30      	pop	{r4, r5}
60001698:	4770      	bx	lr
6000169a:	bf00      	nop
6000169c:	400fc000 	.word	0x400fc000
600016a0:	400c4000 	.word	0x400c4000
600016a4:	400c8000 	.word	0x400c8000
600016a8:	2000277e 	.word	0x2000277e

600016ac <startup_default_early_hook>:
600016ac:	4770      	bx	lr
600016ae:	bf00      	nop

600016b0 <startup_default_middle_hook>:
600016b0:	4770      	bx	lr
600016b2:	bf00      	nop

600016b4 <startup_default_late_hook>:
extern int main (void);
FLASHMEM void startup_default_early_hook(void) {}
void startup_early_hook(void)	__attribute__ ((weak, alias("startup_default_early_hook")));
FLASHMEM void startup_default_middle_hook(void) {}
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
600016b4:	4770      	bx	lr
600016b6:	bf00      	nop

600016b8 <configure_cache>:
#define SIZE_2G		(SCB_MPU_RASR_SIZE(30) | SCB_MPU_RASR_ENABLE)
#define SIZE_4G		(SCB_MPU_RASR_SIZE(31) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
600016b8:	b5f0      	push	{r4, r5, r6, r7, lr}
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016ba:	4a24      	ldr	r2, [pc, #144]	; (6000174c <configure_cache+0x94>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016bc:	2000      	movs	r0, #0

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016be:	4b24      	ldr	r3, [pc, #144]	; (60001750 <configure_cache+0x98>)
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016c0:	f04f 0c10 	mov.w	ip, #16
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016c4:	4c23      	ldr	r4, [pc, #140]	; (60001754 <configure_cache+0x9c>)

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016c6:	2611      	movs	r6, #17

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016c8:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 60001794 <configure_cache+0xdc>
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016cc:	2712      	movs	r7, #18
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016ce:	6020      	str	r0, [r4, #0]
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600016d0:	2501      	movs	r5, #1
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016d2:	f8c2 c000 	str.w	ip, [r2]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016d6:	f8c3 e000 	str.w	lr, [r3]
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016da:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016dc:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 60001798 <configure_cache+0xe0>

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016e0:	4e1d      	ldr	r6, [pc, #116]	; (60001758 <configure_cache+0xa0>)
	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016e2:	f8c3 e000 	str.w	lr, [r3]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016e6:	491d      	ldr	r1, [pc, #116]	; (6000175c <configure_cache+0xa4>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016e8:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016ea:	601e      	str	r6, [r3, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016ec:	f041 0115 	orr.w	r1, r1, #21
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f0:	4f1b      	ldr	r7, [pc, #108]	; (60001760 <configure_cache+0xa8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f2:	4e1c      	ldr	r6, [pc, #112]	; (60001764 <configure_cache+0xac>)
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f4:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f6:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016f8:	4f1b      	ldr	r7, [pc, #108]	; (60001768 <configure_cache+0xb0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fa:	4e1c      	ldr	r6, [pc, #112]	; (6000176c <configure_cache+0xb4>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016fc:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fe:	601e      	str	r6, [r3, #0]
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001700:	4f1b      	ldr	r7, [pc, #108]	; (60001770 <configure_cache+0xb8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
60001702:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
60001704:	4e1b      	ldr	r6, [pc, #108]	; (60001774 <configure_cache+0xbc>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
60001706:	491c      	ldr	r1, [pc, #112]	; (60001778 <configure_cache+0xc0>)

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001708:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
6000170a:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
6000170c:	4f1b      	ldr	r7, [pc, #108]	; (6000177c <configure_cache+0xc4>)
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
6000170e:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001710:	4e1b      	ldr	r6, [pc, #108]	; (60001780 <configure_cache+0xc8>)

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
60001712:	491c      	ldr	r1, [pc, #112]	; (60001784 <configure_cache+0xcc>)
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
60001714:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001716:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001718:	4f1b      	ldr	r7, [pc, #108]	; (60001788 <configure_cache+0xd0>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
6000171a:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
6000171c:	4e1b      	ldr	r6, [pc, #108]	; (6000178c <configure_cache+0xd4>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
6000171e:	491c      	ldr	r1, [pc, #112]	; (60001790 <configure_cache+0xd8>)

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001720:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
60001722:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
60001724:	6019      	str	r1, [r3, #0]

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
60001726:	6025      	str	r5, [r4, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
60001728:	f3bf 8f4f 	dsb	sy
	asm("isb");
6000172c:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
60001730:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0

	asm("dsb");
60001734:	f3bf 8f4f 	dsb	sy
	asm("isb");
60001738:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000173c:	f852 3c88 	ldr.w	r3, [r2, #-136]
60001740:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
60001744:	f842 3c88 	str.w	r3, [r2, #-136]
60001748:	bdf0      	pop	{r4, r5, r6, r7, pc}
6000174a:	bf00      	nop
6000174c:	e000ed9c 	.word	0xe000ed9c
60001750:	e000eda0 	.word	0xe000eda0
60001754:	e000ed94 	.word	0xe000ed94
60001758:	00100009 	.word	0x00100009
6000175c:	20002820 	.word	0x20002820
60001760:	00200013 	.word	0x00200013
60001764:	07020021 	.word	0x07020021
60001768:	20000014 	.word	0x20000014
6000176c:	13080025 	.word	0x13080025
60001770:	10000009 	.word	0x10000009
60001774:	20200016 	.word	0x20200016
60001778:	130b0027 	.word	0x130b0027
6000177c:	40000017 	.word	0x40000017
60001780:	13100033 	.word	0x13100033
60001784:	60000018 	.word	0x60000018
60001788:	070b002f 	.word	0x070b002f
6000178c:	70000019 	.word	0x70000019
60001790:	130b002f 	.word	0x130b002f
60001794:	1000003f 	.word	0x1000003f
60001798:	03080025 	.word	0x03080025

6000179c <configure_external_ram>:
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
6000179c:	b5f0      	push	{r4, r5, r6, r7, lr}
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
6000179e:	4b8d      	ldr	r3, [pc, #564]	; (600019d4 <configure_external_ram+0x238>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017a0:	2218      	movs	r2, #24
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017a2:	4e8d      	ldr	r6, [pc, #564]	; (600019d8 <configure_external_ram+0x23c>)
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017a4:	2001      	movs	r0, #1
}

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017a6:	498d      	ldr	r1, [pc, #564]	; (600019dc <configure_external_ram+0x240>)
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
600017a8:	f248 7e0c 	movw	lr, #34572	; 0x870c

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ac:	4d8c      	ldr	r5, [pc, #560]	; (600019e0 <configure_external_ram+0x244>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
600017ae:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017b2:	4c8c      	ldr	r4, [pc, #560]	; (600019e4 <configure_external_ram+0x248>)
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
600017b4:	b083      	sub	sp, #12
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017b6:	f8c3 125c 	str.w	r1, [r3, #604]	; 0x25c
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ba:	f8c3 5260 	str.w	r5, [r3, #608]	; 0x260
	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
600017be:	2500      	movs	r5, #0
FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017c0:	f8c3 1264 	str.w	r1, [r3, #612]	; 0x264
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017c4:	f8c3 4268 	str.w	r4, [r3, #616]	; 0x268
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600017c8:	f44f 5400 	mov.w	r4, #8192	; 0x2000
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017cc:	f8c3 626c 	str.w	r6, [r3, #620]	; 0x26c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017d0:	4985      	ldr	r1, [pc, #532]	; (600019e8 <configure_external_ram+0x24c>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d2:	f8c3 6270 	str.w	r6, [r3, #624]	; 0x270
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d6:	f8c3 6274 	str.w	r6, [r3, #628]	; 0x274
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017da:	f8c3 6278 	str.w	r6, [r3, #632]	; 0x278
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
600017de:	4e83      	ldr	r6, [pc, #524]	; (600019ec <configure_external_ram+0x250>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017e0:	66da      	str	r2, [r3, #108]	; 0x6c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DQS
600017e2:	671a      	str	r2, [r3, #112]	; 0x70
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS0_B (RAM)
600017e4:	675a      	str	r2, [r3, #116]	; 0x74
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SCLK
600017e6:	679a      	str	r2, [r3, #120]	; 0x78
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
600017e8:	67da      	str	r2, [r3, #124]	; 0x7c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
600017ea:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
600017ee:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3
600017f2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600017f6:	f240 6205 	movw	r2, #1541	; 0x605
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017fa:	f8c1 032c 	str.w	r0, [r1, #812]	; 0x32c
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT = 1; // GPIO_EMC_26 for Mode: ALT8
600017fe:	f8c1 0330 	str.w	r0, [r1, #816]	; 0x330
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT = 1; // GPIO_EMC_27 for Mode: ALT8
60001802:	f8c1 0334 	str.w	r0, [r1, #820]	; 0x334
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
60001806:	f8c1 0338 	str.w	r0, [r1, #824]	; 0x338
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
6000180a:	f8c1 033c 	str.w	r0, [r1, #828]	; 0x33c
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8
6000180e:	f8c1 0350 	str.w	r0, [r1, #848]	; 0x350
	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
60001812:	4629      	mov	r1, r5
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001814:	69b3      	ldr	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
60001816:	4876      	ldr	r0, [pc, #472]	; (600019f0 <configure_external_ram+0x254>)
60001818:	4018      	ands	r0, r3
6000181a:	4b76      	ldr	r3, [pc, #472]	; (600019f4 <configure_external_ram+0x258>)
6000181c:	4303      	orrs	r3, r0
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
6000181e:	4876      	ldr	r0, [pc, #472]	; (600019f8 <configure_external_ram+0x25c>)
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001820:	61b3      	str	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);
60001822:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
60001826:	f043 030c 	orr.w	r3, r3, #12
6000182a:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
6000182e:	2602      	movs	r6, #2
	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
60001830:	6803      	ldr	r3, [r0, #0]
60001832:	4333      	orrs	r3, r6
60001834:	6003      	str	r3, [r0, #0]
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001836:	6803      	ldr	r3, [r0, #0]
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
60001838:	ea03 0e0e 	and.w	lr, r3, lr
6000183c:	4b6f      	ldr	r3, [pc, #444]	; (600019fc <configure_external_ram+0x260>)
6000183e:	ea4e 0303 	orr.w	r3, lr, r3
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001842:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 60001a34 <configure_external_ram+0x298>
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001846:	6003      	str	r3, [r0, #0]
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001848:	4b6d      	ldr	r3, [pc, #436]	; (60001a00 <configure_external_ram+0x264>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
6000184a:	6047      	str	r7, [r0, #4]
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
6000184c:	f8de 7008 	ldr.w	r7, [lr, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001850:	403b      	ands	r3, r7
	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001852:	4f6c      	ldr	r7, [pc, #432]	; (60001a04 <configure_external_ram+0x268>)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001854:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001858:	6083      	str	r3, [r0, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
6000185a:	68c3      	ldr	r3, [r0, #12]
6000185c:	f023 0378 	bic.w	r3, r3, #120	; 0x78
60001860:	60c3      	str	r3, [r0, #12]
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001862:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001864:	401f      	ands	r7, r3
60001866:	4b68      	ldr	r3, [pc, #416]	; (60001a08 <configure_external_ram+0x26c>)
60001868:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
6000186a:	4f66      	ldr	r7, [pc, #408]	; (60001a04 <configure_external_ram+0x268>)

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186c:	6203      	str	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186e:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001870:	401f      	ands	r7, r3
60001872:	4b65      	ldr	r3, [pc, #404]	; (60001a08 <configure_external_ram+0x26c>)
60001874:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF2CR0 = mask;
60001876:	4f65      	ldr	r7, [pc, #404]	; (60001a0c <configure_external_ram+0x270>)
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001878:	6243      	str	r3, [r0, #36]	; 0x24
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
6000187a:	6287      	str	r7, [r0, #40]	; 0x28
	FLEXSPI2_AHBRXBUF3CR0 = mask;
6000187c:	62c7      	str	r7, [r0, #44]	; 0x2c

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
6000187e:	f8de 30b8 	ldr.w	r3, [lr, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
60001882:	4f63      	ldr	r7, [pc, #396]	; (60001a10 <configure_external_ram+0x274>)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
60001884:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
60001888:	f043 0301 	orr.w	r3, r3, #1
6000188c:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001890:	f8de 30bc 	ldr.w	r3, [lr, #188]	; 0xbc
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
60001894:	f8df e184 	ldr.w	lr, [pc, #388]	; 60001a1c <configure_external_ram+0x280>
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001898:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
6000189c:	f043 0301 	orr.w	r3, r3, #1
600018a0:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc

	FLEXSPI2_INTEN = 0;
600018a4:	6105      	str	r5, [r0, #16]
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600018a6:	6604      	str	r4, [r0, #96]	; 0x60
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018a8:	6707      	str	r7, [r0, #112]	; 0x70
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018aa:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_FLSHA2CR0 = 0x2000; // 8 MByte
600018ae:	6644      	str	r4, [r0, #100]	; 0x64
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018b0:	6747      	str	r7, [r0, #116]	; 0x74
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018b2:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018b6:	6804      	ldr	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018b8:	4b56      	ldr	r3, [pc, #344]	; (60001a14 <configure_external_ram+0x278>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018ba:	f024 0402 	bic.w	r4, r4, #2

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018be:	4a56      	ldr	r2, [pc, #344]	; (60001a18 <configure_external_ram+0x27c>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018c0:	6004      	str	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018c2:	f8c0 e018 	str.w	lr, [r0, #24]
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018c6:	61c6      	str	r6, [r0, #28]
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018c8:	f843 1b04 	str.w	r1, [r3], #4
600018cc:	4293      	cmp	r3, r2
600018ce:	d1fb      	bne.n	600018c8 <configure_external_ram+0x12c>
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d0:	4b49      	ldr	r3, [pc, #292]	; (600019f8 <configure_external_ram+0x25c>)
600018d2:	681a      	ldr	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018d4:	4619      	mov	r1, r3

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d6:	f042 0201 	orr.w	r2, r2, #1
600018da:	601a      	str	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018dc:	680b      	ldr	r3, [r1, #0]
600018de:	4a46      	ldr	r2, [pc, #280]	; (600019f8 <configure_external_ram+0x25c>)
600018e0:	f013 0301 	ands.w	r3, r3, #1
600018e4:	d1fa      	bne.n	600018dc <configure_external_ram+0x140>

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018e6:	4e4d      	ldr	r6, [pc, #308]	; (60001a1c <configure_external_ram+0x280>)
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018e8:	2502      	movs	r5, #2

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
600018ea:	f240 64f5 	movw	r4, #1781	; 0x6f5
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
600018ee:	f240 4066 	movw	r0, #1126	; 0x466
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
600018f2:	f240 4199 	movw	r1, #1177	; 0x499
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
600018f6:	4f4a      	ldr	r7, [pc, #296]	; (60001a20 <configure_external_ram+0x284>)
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018f8:	6196      	str	r6, [r2, #24]
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
600018fa:	f242 4601 	movw	r6, #9217	; 0x2401
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018fe:	61d5      	str	r5, [r2, #28]
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001900:	f240 4535 	movw	r5, #1077	; 0x435

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
60001904:	f8c2 4200 	str.w	r4, [r2, #512]	; 0x200
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
60001908:	f242 2401 	movw	r4, #8705	; 0x2201
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
6000190c:	f8c2 0210 	str.w	r0, [r2, #528]	; 0x210

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001910:	2001      	movs	r0, #1
	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
60001912:	f8c2 1220 	str.w	r1, [r2, #544]	; 0x220
FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001916:	4611      	mov	r1, r2
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
60001918:	f8c2 7230 	str.w	r7, [r2, #560]	; 0x230
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
6000191c:	f107 475a 	add.w	r7, r7, #3657433088	; 0xda000000
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
60001920:	f8c2 6234 	str.w	r6, [r2, #564]	; 0x234
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001924:	f507 7713 	add.w	r7, r7, #588	; 0x24c
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001928:	f8c2 5240 	str.w	r5, [r2, #576]	; 0x240
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
6000192c:	4e3d      	ldr	r6, [pc, #244]	; (60001a24 <configure_external_ram+0x288>)
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
6000192e:	4d3e      	ldr	r5, [pc, #248]	; (60001a28 <configure_external_ram+0x28c>)
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001930:	f8c2 7250 	str.w	r7, [r2, #592]	; 0x250
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
60001934:	f8c2 6254 	str.w	r6, [r2, #596]	; 0x254
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
60001938:	f8c2 5260 	str.w	r5, [r2, #608]	; 0x260
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
6000193c:	f8c2 4264 	str.w	r4, [r2, #612]	; 0x264
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001940:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001944:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001948:	f8c2 00b0 	str.w	r0, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000194c:	694b      	ldr	r3, [r1, #20]
6000194e:	4a2a      	ldr	r2, [pc, #168]	; (600019f8 <configure_external_ram+0x25c>)
60001950:	07dd      	lsls	r5, r3, #31
60001952:	d5fb      	bpl.n	6000194c <configure_external_ram+0x1b0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001954:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001956:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001958:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000195c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000195e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001960:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001964:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001968:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000196c:	694b      	ldr	r3, [r1, #20]
6000196e:	4a22      	ldr	r2, [pc, #136]	; (600019f8 <configure_external_ram+0x25c>)
60001970:	07dc      	lsls	r4, r3, #31
60001972:	d5fb      	bpl.n	6000196c <configure_external_ram+0x1d0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001974:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001976:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001978:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000197c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000197e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001980:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001984:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001988:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000198c:	694b      	ldr	r3, [r1, #20]
6000198e:	4a1a      	ldr	r2, [pc, #104]	; (600019f8 <configure_external_ram+0x25c>)
60001990:	07d8      	lsls	r0, r3, #31
60001992:	d5fb      	bpl.n	6000198c <configure_external_ram+0x1f0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001994:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001996:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001998:	4824      	ldr	r0, [pc, #144]	; (60001a2c <configure_external_ram+0x290>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000199a:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000199c:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000199e:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
600019a2:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
600019a6:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
600019aa:	694b      	ldr	r3, [r1, #20]
600019ac:	4a12      	ldr	r2, [pc, #72]	; (600019f8 <configure_external_ram+0x25c>)
600019ae:	07db      	lsls	r3, r3, #31
600019b0:	d5fb      	bpl.n	600019aa <configure_external_ram+0x20e>
	uint32_t id = FLEXSPI2_RFDR0;
600019b2:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019b6:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019ba:	2021      	movs	r0, #33	; 0x21

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019bc:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019be:	6150      	str	r0, [r2, #20]

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019c0:	428b      	cmp	r3, r1
600019c2:	d039      	beq.n	60001a38 <configure_external_ram+0x29c>
			external_psram_size * 0x100000 -
			((uint32_t)&_extram_end - (uint32_t)&_extram_start),
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
600019c4:	4b1a      	ldr	r3, [pc, #104]	; (60001a30 <configure_external_ram+0x294>)
600019c6:	2200      	movs	r2, #0
600019c8:	601a      	str	r2, [r3, #0]
600019ca:	605a      	str	r2, [r3, #4]
600019cc:	609a      	str	r2, [r3, #8]
600019ce:	60da      	str	r2, [r3, #12]
	}
}
600019d0:	b003      	add	sp, #12
600019d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
600019d4:	401f8000 	.word	0x401f8000
600019d8:	000170f9 	.word	0x000170f9
600019dc:	0001b0f9 	.word	0x0001b0f9
600019e0:	000110f9 	.word	0x000110f9
600019e4:	000100f9 	.word	0x000100f9
600019e8:	401f8400 	.word	0x401f8400
600019ec:	400fc000 	.word	0x400fc000
600019f0:	1ffffcff 	.word	0x1ffffcff
600019f4:	a0000300 	.word	0xa0000300
600019f8:	402a4000 	.word	0x402a4000
600019fc:	ffff0012 	.word	0xffff0012
60001a00:	00f737ff 	.word	0x00f737ff
60001a04:	7cf0ff00 	.word	0x7cf0ff00
60001a08:	80000040 	.word	0x80000040
60001a0c:	830f00ff 	.word	0x830f00ff
60001a10:	00020063 	.word	0x00020063
60001a14:	402a4200 	.word	0x402a4200
60001a18:	402a4300 	.word	0x402a4300
60001a1c:	5af05af0 	.word	0x5af05af0
60001a20:	3018049f 	.word	0x3018049f
60001a24:	26013206 	.word	0x26013206
60001a28:	0a180638 	.word	0x0a180638
60001a2c:	00030004 	.word	0x00030004
60001a30:	200027e4 	.word	0x200027e4
60001a34:	402a8000 	.word	0x402a8000
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a38:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a3a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a3e:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a40:	4611      	mov	r1, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a42:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a46:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a4a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a4e:	694b      	ldr	r3, [r1, #20]
60001a50:	4a3b      	ldr	r2, [pc, #236]	; (60001b40 <configure_external_ram+0x3a4>)
60001a52:	07df      	lsls	r7, r3, #31
60001a54:	d5fb      	bpl.n	60001a4e <configure_external_ram+0x2b2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a56:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a58:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a5c:	2000      	movs	r0, #0
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a5e:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a60:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a62:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a66:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a6a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a6e:	694b      	ldr	r3, [r1, #20]
60001a70:	4a33      	ldr	r2, [pc, #204]	; (60001b40 <configure_external_ram+0x3a4>)
60001a72:	07de      	lsls	r6, r3, #31
60001a74:	d5fb      	bpl.n	60001a6e <configure_external_ram+0x2d2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a76:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a78:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a7c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a80:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a82:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a84:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a88:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a8c:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a90:	694b      	ldr	r3, [r1, #20]
60001a92:	4a2b      	ldr	r2, [pc, #172]	; (60001b40 <configure_external_ram+0x3a4>)
60001a94:	07dd      	lsls	r5, r3, #31
60001a96:	d5fb      	bpl.n	60001a90 <configure_external_ram+0x2f4>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a98:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a9a:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a9e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001aa2:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aa4:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001aa6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001aaa:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001aae:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ab2:	694b      	ldr	r3, [r1, #20]
60001ab4:	4a22      	ldr	r2, [pc, #136]	; (60001b40 <configure_external_ram+0x3a4>)
60001ab6:	07dc      	lsls	r4, r3, #31
60001ab8:	d5fb      	bpl.n	60001ab2 <configure_external_ram+0x316>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aba:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001abc:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001ac0:	4820      	ldr	r0, [pc, #128]	; (60001b44 <configure_external_ram+0x3a8>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ac2:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001ac4:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001ac6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001aca:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001ace:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ad2:	694b      	ldr	r3, [r1, #20]
60001ad4:	4a1a      	ldr	r2, [pc, #104]	; (60001b40 <configure_external_ram+0x3a4>)
60001ad6:	07d8      	lsls	r0, r3, #31
60001ad8:	d5fb      	bpl.n	60001ad2 <configure_external_ram+0x336>
	uint32_t id = FLEXSPI2_RFDR0;
60001ada:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ade:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae2:	2021      	movs	r0, #33	; 0x21
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae4:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae6:	6150      	str	r0, [r2, #20]
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae8:	428b      	cmp	r3, r1
60001aea:	d010      	beq.n	60001b0e <configure_external_ram+0x372>
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
		} else {
			// One PSRAM chip is present, 8 MByte
			external_psram_size = 8;
60001aec:	4b16      	ldr	r3, [pc, #88]	; (60001b48 <configure_external_ram+0x3ac>)
60001aee:	2208      	movs	r2, #8
60001af0:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
60001af4:	701a      	strb	r2, [r3, #0]
		}
		// TODO: zero uninitialized EXTMEM variables
		// TODO: copy from flash to initialize EXTMEM variables
		sm_set_pool(&extmem_smalloc_pool, &_extram_end,
60001af6:	4915      	ldr	r1, [pc, #84]	; (60001b4c <configure_external_ram+0x3b0>)
60001af8:	2000      	movs	r0, #0
60001afa:	4a15      	ldr	r2, [pc, #84]	; (60001b50 <configure_external_ram+0x3b4>)
60001afc:	2301      	movs	r3, #1
60001afe:	9000      	str	r0, [sp, #0]
60001b00:	1a52      	subs	r2, r2, r1
60001b02:	4814      	ldr	r0, [pc, #80]	; (60001b54 <configure_external_ram+0x3b8>)
60001b04:	4422      	add	r2, r4
60001b06:	f000 fabf 	bl	60002088 <__sm_set_pool_veneer>
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
	}
}
60001b0a:	b003      	add	sp, #12
60001b0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b0e:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b12:	f44f 2180 	mov.w	r1, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b16:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b18:	4610      	mov	r0, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b1a:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b1e:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b22:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b26:	6943      	ldr	r3, [r0, #20]
60001b28:	4905      	ldr	r1, [pc, #20]	; (60001b40 <configure_external_ram+0x3a4>)
60001b2a:	07db      	lsls	r3, r3, #31
60001b2c:	d5fb      	bpl.n	60001b26 <configure_external_ram+0x38a>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b2e:	2001      	movs	r0, #1
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b30:	4b05      	ldr	r3, [pc, #20]	; (60001b48 <configure_external_ram+0x3ac>)
60001b32:	2210      	movs	r2, #16
60001b34:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b38:	6148      	str	r0, [r1, #20]
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b3a:	701a      	strb	r2, [r3, #0]
60001b3c:	e7db      	b.n	60001af6 <configure_external_ram+0x35a>
60001b3e:	bf00      	nop
60001b40:	402a4000 	.word	0x402a4000
60001b44:	00030004 	.word	0x00030004
60001b48:	2000277f 	.word	0x2000277f
60001b4c:	70000000 	.word	0x70000000
60001b50:	70000000 	.word	0x70000000
60001b54:	200027e4 	.word	0x200027e4

60001b58 <usb_pll_start>:

#endif // ARDUINO_TEENSY41


FLASHMEM void usb_pll_start()
{
60001b58:	b4f0      	push	{r4, r5, r6, r7}
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b5a:	4a17      	ldr	r2, [pc, #92]	; (60001bb8 <usb_pll_start+0x60>)
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001b5c:	2740      	movs	r7, #64	; 0x40
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001b5e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b62:	f44f 5680 	mov.w	r6, #4096	; 0x1000
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b66:	f44f 5500 	mov.w	r5, #8192	; 0x2000
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b6a:	f44f 4440 	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b6e:	f243 0042 	movw	r0, #12354	; 0x3042


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b72:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b74:	f013 0f02 	tst.w	r3, #2
60001b78:	d006      	beq.n	60001b88 <usb_pll_start+0x30>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b7a:	6194      	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001b7c:	6151      	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b7e:	6190      	str	r0, [r2, #24]


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b80:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b82:	f013 0f02 	tst.w	r3, #2
60001b86:	d1f8      	bne.n	60001b7a <usb_pll_start+0x22>
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
60001b88:	f413 5f00 	tst.w	r3, #8192	; 0x2000
60001b8c:	d101      	bne.n	60001b92 <usb_pll_start+0x3a>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b8e:	6155      	str	r5, [r2, #20]
			continue;
60001b90:	e7ef      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001b92:	f413 5f80 	tst.w	r3, #4096	; 0x1000
60001b96:	d101      	bne.n	60001b9c <usb_pll_start+0x44>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b98:	6156      	str	r6, [r2, #20]
			continue;
60001b9a:	e7ea      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
60001b9c:	2b00      	cmp	r3, #0
60001b9e:	dae8      	bge.n	60001b72 <usb_pll_start+0x1a>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
60001ba0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
60001ba4:	d001      	beq.n	60001baa <usb_pll_start+0x52>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001ba6:	6191      	str	r1, [r2, #24]
			continue;
60001ba8:	e7e3      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
60001baa:	065b      	lsls	r3, r3, #25
60001bac:	d401      	bmi.n	60001bb2 <usb_pll_start+0x5a>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001bae:	6157      	str	r7, [r2, #20]
			continue;
60001bb0:	e7df      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		return; // everything is as it should be  :-)
	}
}
60001bb2:	bcf0      	pop	{r4, r5, r6, r7}
60001bb4:	4770      	bx	lr
60001bb6:	bf00      	nop
60001bb8:	400d8000 	.word	0x400d8000

60001bbc <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bbc:	4a39      	ldr	r2, [pc, #228]	; (60001ca4 <tempmon_init+0xe8>)

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bbe:	2003      	movs	r0, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bc0:	4939      	ldr	r1, [pc, #228]	; (60001ca8 <tempmon_init+0xec>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bc2:	eef3 5a09 	vmov.f32	s11, #57	; 0x41c80000  25.0
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bc6:	6813      	ldr	r3, [r2, #0]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001bc8:	ed9f 6a38 	vldr	s12, [pc, #224]	; 60001cac <tempmon_init+0xf0>
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bcc:	f023 0301 	bic.w	r3, r3, #1
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001bd0:	eddf 6a37 	vldr	s13, [pc, #220]	; 60001cb0 <tempmon_init+0xf4>
  //asm volatile ("dsb":::"memory");
  //while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
60001bd4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bd6:	6013      	str	r3, [r2, #0]
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001bd8:	2400      	movs	r4, #0
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bda:	6110      	str	r0, [r2, #16]
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bdc:	f8d1 30e0 	ldr.w	r3, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be0:	4f34      	ldr	r7, [pc, #208]	; (60001cb4 <tempmon_init+0xf8>)
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001be2:	b2d8      	uxtb	r0, r3
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001be4:	f3c3 210b 	ubfx	r1, r3, #8, #12
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be8:	0d1b      	lsrs	r3, r3, #20
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001bea:	4e33      	ldr	r6, [pc, #204]	; (60001cb8 <tempmon_init+0xfc>)
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bec:	ee07 0a10 	vmov	s14, r0
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bf0:	ee05 1a10 	vmov	s10, r1
60001bf4:	ee07 3a90 	vmov	s15, r3
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bf8:	4b30      	ldr	r3, [pc, #192]	; (60001cbc <tempmon_init+0x100>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bfa:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001bfe:	4d30      	ldr	r5, [pc, #192]	; (60001cc0 <tempmon_init+0x104>)
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c00:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001c04:	6030      	str	r0, [r6, #0]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001c0a:	6029      	str	r1, [r5, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c0c:	492d      	ldr	r1, [pc, #180]	; (60001cc4 <tempmon_init+0x108>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c0e:	ee37 6a46 	vsub.f32	s12, s14, s12
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c12:	4e2d      	ldr	r6, [pc, #180]	; (60001cc8 <tempmon_init+0x10c>)
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c14:	ee77 7ac5 	vsub.f32	s15, s15, s10
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
60001c18:	482c      	ldr	r0, [pc, #176]	; (60001ccc <tempmon_init+0x110>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c1a:	ee77 6a66 	vsub.f32	s13, s14, s13
60001c1e:	4d2c      	ldr	r5, [pc, #176]	; (60001cd0 <tempmon_init+0x114>)
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c20:	ee37 7a65 	vsub.f32	s14, s14, s11
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c24:	ee26 6a27 	vmul.f32	s12, s12, s15
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c28:	edc7 7a00 	vstr	s15, [r7]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c2c:	ee66 6aa7 	vmul.f32	s13, s13, s15
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c30:	6817      	ldr	r7, [r2, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c32:	ee67 7a27 	vmul.f32	s15, s14, s15
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c36:	ed83 7a00 	vstr	s14, [r3]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c3a:	eec6 5a07 	vdiv.f32	s11, s12, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c3e:	ee86 6a87 	vdiv.f32	s12, s13, s14
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c42:	eec7 6a87 	vdiv.f32	s13, s15, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c46:	ee35 7a85 	vadd.f32	s14, s11, s10
60001c4a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c4e:	ee36 7a05 	vadd.f32	s14, s12, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c52:	ee17 3a90 	vmov	r3, s15
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c56:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c5a:	ea47 5303 	orr.w	r3, r7, r3, lsl #20
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c5e:	ee76 7a85 	vadd.f32	s15, s13, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c62:	6013      	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c64:	ee17 3a10 	vmov	r3, s14
60001c68:	f8d2 7110 	ldr.w	r7, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c6c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c70:	ea01 4103 	and.w	r1, r1, r3, lsl #16
60001c74:	4339      	orrs	r1, r7
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c76:	ee17 3a90 	vmov	r3, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c7a:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c7e:	f3c3 030b 	ubfx	r3, r3, #0, #12
60001c82:	f8d2 1110 	ldr.w	r1, [r2, #272]	; 0x110
60001c86:	430b      	orrs	r3, r1
60001c88:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
60001c8c:	6813      	ldr	r3, [r2, #0]
60001c8e:	f043 0302 	orr.w	r3, r3, #2
60001c92:	6013      	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c94:	7034      	strb	r4, [r6, #0]
60001c96:	f8c0 5140 	str.w	r5, [r0, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001c9a:	4b0e      	ldr	r3, [pc, #56]	; (60001cd4 <tempmon_init+0x118>)
60001c9c:	2201      	movs	r2, #1
}
60001c9e:	bcf0      	pop	{r4, r5, r6, r7}
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001ca0:	601a      	str	r2, [r3, #0]
}
60001ca2:	4770      	bx	lr
60001ca4:	400d8180 	.word	0x400d8180
60001ca8:	401f4400 	.word	0x401f4400
60001cac:	42aa0000 	.word	0x42aa0000
60001cb0:	42b40000 	.word	0x42b40000
60001cb4:	20002738 	.word	0x20002738
60001cb8:	20002730 	.word	0x20002730
60001cbc:	20002734 	.word	0x20002734
60001cc0:	2000272c 	.word	0x2000272c
60001cc4:	0fff0000 	.word	0x0fff0000
60001cc8:	e000e440 	.word	0xe000e440
60001ccc:	20002000 	.word	0x20002000
60001cd0:	00001f51 	.word	0x00001f51
60001cd4:	e000e108 	.word	0xe000e108

60001cd8 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001cd8:	4b30      	ldr	r3, [pc, #192]	; (60001d9c <usb_init+0xc4>)
60001cda:	f640 7261 	movw	r2, #3937	; 0xf61

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
60001cde:	b570      	push	{r4, r5, r6, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001ce0:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001ce4:	f240 4504 	movw	r5, #1028	; 0x404
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
60001ce8:	f000 f9ba 	bl	60002060 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cec:	492c      	ldr	r1, [pc, #176]	; (60001da0 <usb_init+0xc8>)
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001cee:	482d      	ldr	r0, [pc, #180]	; (60001da4 <usb_init+0xcc>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf0:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cf4:	4c2c      	ldr	r4, [pc, #176]	; (60001da8 <usb_init+0xd0>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf6:	f042 0203 	orr.w	r2, r2, #3
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cfa:	4b2c      	ldr	r3, [pc, #176]	; (60001dac <usb_init+0xd4>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cfc:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001d00:	f8c0 5160 	str.w	r5, [r0, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001d04:	6822      	ldr	r2, [r4, #0]
60001d06:	4013      	ands	r3, r2
60001d08:	b91b      	cbnz	r3, 60001d12 <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
60001d0a:	f8d0 31a8 	ldr.w	r3, [r0, #424]	; 0x1a8
60001d0e:	079a      	lsls	r2, r3, #30
60001d10:	d01a      	beq.n	60001d48 <usb_init+0x70>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d12:	4b24      	ldr	r3, [pc, #144]	; (60001da4 <usb_init+0xcc>)
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001d14:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
60001d18:	4a23      	ldr	r2, [pc, #140]	; (60001da8 <usb_init+0xd0>)
60001d1a:	6351      	str	r1, [r2, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d1c:	461a      	mov	r2, r3
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d1e:	f8d3 1140 	ldr.w	r1, [r3, #320]	; 0x140
60001d22:	f041 0102 	orr.w	r1, r1, #2
60001d26:	f8c3 1140 	str.w	r1, [r3, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d2a:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001d2e:	079b      	lsls	r3, r3, #30
60001d30:	d4fb      	bmi.n	60001d2a <usb_init+0x52>
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d32:	f44f 3000 	mov.w	r0, #131072	; 0x20000
60001d36:	491e      	ldr	r1, [pc, #120]	; (60001db0 <usb_init+0xd8>)
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d38:	4b1b      	ldr	r3, [pc, #108]	; (60001da8 <usb_init+0xd0>)
60001d3a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d3e:	6008      	str	r0, [r1, #0]
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d40:	2019      	movs	r0, #25
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d42:	639a      	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d44:	f000 f998 	bl	60002078 <__delay_veneer>
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d48:	4d1a      	ldr	r5, [pc, #104]	; (60001db4 <usb_init+0xdc>)
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d4a:	2200      	movs	r2, #0
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d4c:	4b16      	ldr	r3, [pc, #88]	; (60001da8 <usb_init+0xd0>)
60001d4e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d52:	4c14      	ldr	r4, [pc, #80]	; (60001da4 <usb_init+0xcc>)
60001d54:	260a      	movs	r6, #10
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d56:	6399      	str	r1, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d58:	4628      	mov	r0, r5
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d5a:	601a      	str	r2, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d5c:	4611      	mov	r1, r2
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d5e:	f8c4 61a8 	str.w	r6, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d62:	f44f 7220 	mov.w	r2, #640	; 0x280
60001d66:	f000 f98b 	bl	60002080 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d6a:	f44f 0681 	mov.w	r6, #4227072	; 0x408000
	endpoint_queue_head[1].config = (64 << 16);
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d6e:	f240 1143 	movw	r1, #323	; 0x143
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
	endpoint_queue_head[1].config = (64 << 16);
60001d72:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
60001d76:	4b10      	ldr	r3, [pc, #64]	; (60001db8 <usb_init+0xe0>)
60001d78:	4a10      	ldr	r2, [pc, #64]	; (60001dbc <usb_init+0xe4>)
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d7a:	602e      	str	r6, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
60001d7c:	6428      	str	r0, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001d7e:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d82:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
60001d86:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d8a:	4a0d      	ldr	r2, [pc, #52]	; (60001dc0 <usb_init+0xe8>)
60001d8c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d90:	2301      	movs	r3, #1
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d92:	6011      	str	r1, [r2, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d94:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
60001d98:	bd70      	pop	{r4, r5, r6, pc}
60001d9a:	bf00      	nop
60001d9c:	400d8000 	.word	0x400d8000
60001da0:	400fc000 	.word	0x400fc000
60001da4:	402e0000 	.word	0x402e0000
60001da8:	400d9000 	.word	0x400d9000
60001dac:	001e1c00 	.word	0x001e1c00
60001db0:	e000e28c 	.word	0xe000e28c
60001db4:	20000000 	.word	0x20000000
60001db8:	20002000 	.word	0x20002000
60001dbc:	0000211d 	.word	0x0000211d
60001dc0:	e000e10c 	.word	0xe000e10c

60001dc4 <_reboot_Teensyduino_>:
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


FLASHMEM void _reboot_Teensyduino_(void)
{
60001dc4:	b508      	push	{r3, lr}
	if (!(HW_OCOTP_CFG5 & 0x02)) {
60001dc6:	4b0e      	ldr	r3, [pc, #56]	; (60001e00 <_reboot_Teensyduino_+0x3c>)
60001dc8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
60001dca:	079b      	lsls	r3, r3, #30
60001dcc:	d400      	bmi.n	60001dd0 <_reboot_Teensyduino_+0xc>
		asm("bkpt #251"); // run bootloader
60001dce:	befb      	bkpt	0x00fb
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
60001dd0:	b672      	cpsid	i
		USB1_USBCMD = 0;
60001dd2:	4b0c      	ldr	r3, [pc, #48]	; (60001e04 <_reboot_Teensyduino_+0x40>)
60001dd4:	2000      	movs	r0, #0
		IOMUXC_GPR_GPR16 = 0x00200003;
60001dd6:	4a0c      	ldr	r2, [pc, #48]	; (60001e08 <_reboot_Teensyduino_+0x44>)
{
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
60001dd8:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001ddc:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de0:	490a      	ldr	r1, [pc, #40]	; (60001e0c <_reboot_Teensyduino_+0x48>)
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de2:	f5a3 235f 	sub.w	r3, r3, #913408	; 0xdf000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de6:	6411      	str	r1, [r2, #64]	; 0x40
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de8:	469d      	mov	sp, r3
		__asm__ volatile("dsb":::"memory");
60001dea:	f3bf 8f4f 	dsb	sy
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dee:	4a08      	ldr	r2, [pc, #32]	; (60001e10 <_reboot_Teensyduino_+0x4c>)
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001df0:	f503 43e0 	add.w	r3, r3, #28672	; 0x7000
60001df4:	4907      	ldr	r1, [pc, #28]	; (60001e14 <_reboot_Teensyduino_+0x50>)
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001df6:	6812      	ldr	r2, [r2, #0]
60001df8:	4618      	mov	r0, r3
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001dfa:	6019      	str	r1, [r3, #0]
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dfc:	6893      	ldr	r3, [r2, #8]
60001dfe:	4798      	blx	r3
60001e00:	401f4400 	.word	0x401f4400
60001e04:	402e0000 	.word	0x402e0000
60001e08:	400ac000 	.word	0x400ac000
60001e0c:	00200003 	.word	0x00200003
60001e10:	0020001c 	.word	0x0020001c
60001e14:	eb120000 	.word	0xeb120000

60001e18 <TwoWire::begin()>:
//***************************************************
//  Master Mode
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
60001e18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e1c:	4f29      	ldr	r7, [pc, #164]	; (60001ec4 <TwoWire::begin()+0xac>)
#define CLOCK_STRETCH_TIMEOUT 15000


void TwoWire::setClock(uint32_t frequency)
{
	port->MCR = 0;
60001e1e:	2500      	movs	r5, #0

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e20:	6942      	ldr	r2, [r0, #20]
	port->MCR = 0;
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
60001e22:	2401      	movs	r4, #1
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e24:	6bb9      	ldr	r1, [r7, #56]	; 0x38
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e26:	f04f 0e02 	mov.w	lr, #2

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e2a:	6816      	ldr	r6, [r2, #0]
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1);
60001e2c:	f44f 3830 	mov.w	r8, #180224	; 0x2c000
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e30:	f421 017c 	bic.w	r1, r1, #16515072	; 0xfc0000
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e34:	6903      	ldr	r3, [r0, #16]
{
	port->MCR = 0;
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
60001e36:	f8df c09c 	ldr.w	ip, [pc, #156]	; 60001ed4 <TwoWire::begin()+0xbc>
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e3a:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
60001e3e:	63b9      	str	r1, [r7, #56]	; 0x38
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e40:	6831      	ldr	r1, [r6, #0]
60001e42:	6857      	ldr	r7, [r2, #4]
60001e44:	4339      	orrs	r1, r7
60001e46:	6031      	str	r1, [r6, #0]
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
	port->MCFGR0 = 0;
	port->MFCR = LPI2C_MFCR_RXWATER(1) | LPI2C_MFCR_TXWATER(1);
60001e48:	f04f 1601 	mov.w	r6, #65537	; 0x10001
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
60001e4c:	491e      	ldr	r1, [pc, #120]	; (60001ec8 <TwoWire::begin()+0xb0>)
FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e4e:	f8c3 e010 	str.w	lr, [r3, #16]
#define CLOCK_STRETCH_TIMEOUT 15000


void TwoWire::setClock(uint32_t frequency)
{
	port->MCR = 0;
60001e52:	611d      	str	r5, [r3, #16]
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
60001e54:	f8c3 c048 	str.w	ip, [r3, #72]	; 0x48
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
60001e58:	625c      	str	r4, [r3, #36]	; 0x24
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
60001e5a:	6299      	str	r1, [r3, #40]	; 0x28
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1);
60001e5c:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | LPI2C_MCFGR2_FILTSCL(1) |
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
60001e60:	6c9f      	ldr	r7, [r3, #72]	; 0x48
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001e62:	491a      	ldr	r1, [pc, #104]	; (60001ecc <TwoWire::begin()+0xb4>)
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | LPI2C_MCFGR2_FILTSCL(1) |
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
60001e64:	651f      	str	r7, [r3, #80]	; 0x50
	port->MCFGR0 = 0;
60001e66:	621d      	str	r5, [r3, #32]
	port->MFCR = LPI2C_MFCR_RXWATER(1) | LPI2C_MFCR_TXWATER(1);
60001e68:	659e      	str	r6, [r3, #88]	; 0x58
	port->MCR = LPI2C_MCR_MEN;
60001e6a:	611c      	str	r4, [r3, #16]
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
	setClock(100000);
	// setSDA() & setSCL() may be called before or after begin()
	configSDApin(sda_pin_index_); // Setup SDA register
60001e6c:	7e03      	ldrb	r3, [r0, #24]
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001e6e:	4e18      	ldr	r6, [pc, #96]	; (60001ed0 <TwoWire::begin()+0xb8>)
60001e70:	eb02 1503 	add.w	r5, r2, r3, lsl #4
60001e74:	7a2c      	ldrb	r4, [r5, #8]
60001e76:	462b      	mov	r3, r5
60001e78:	eb01 1404 	add.w	r4, r1, r4, lsl #4
60001e7c:	68a4      	ldr	r4, [r4, #8]
60001e7e:	6026      	str	r6, [r4, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001e80:	7a2c      	ldrb	r4, [r5, #8]
60001e82:	68ed      	ldr	r5, [r5, #12]
60001e84:	eb01 1404 	add.w	r4, r1, r4, lsl #4
60001e88:	6864      	ldr	r4, [r4, #4]
60001e8a:	6025      	str	r5, [r4, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001e8c:	691c      	ldr	r4, [r3, #16]
60001e8e:	b10c      	cbz	r4, 60001e94 <TwoWire::begin()+0x7c>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001e90:	695b      	ldr	r3, [r3, #20]
60001e92:	6023      	str	r3, [r4, #0]
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
	setClock(100000);
	// setSDA() & setSCL() may be called before or after begin()
	configSDApin(sda_pin_index_); // Setup SDA register
	configSCLpin(scl_pin_index_); // setup SCL register
60001e94:	7e40      	ldrb	r0, [r0, #25]
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001e96:	4c0e      	ldr	r4, [pc, #56]	; (60001ed0 <TwoWire::begin()+0xb8>)
60001e98:	eb02 1300 	add.w	r3, r2, r0, lsl #4
60001e9c:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
60001ea0:	461a      	mov	r2, r3
60001ea2:	eb01 1000 	add.w	r0, r1, r0, lsl #4
60001ea6:	6880      	ldr	r0, [r0, #8]
60001ea8:	6004      	str	r4, [r0, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60001eaa:	f893 4028 	ldrb.w	r4, [r3, #40]	; 0x28
60001eae:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
60001eb0:	eb01 1104 	add.w	r1, r1, r4, lsl #4
60001eb4:	684b      	ldr	r3, [r1, #4]
60001eb6:	6018      	str	r0, [r3, #0]
	if (hardware.scl_pins[i].select_input_register) {
60001eb8:	6b13      	ldr	r3, [r2, #48]	; 0x30
60001eba:	b10b      	cbz	r3, 60001ec0 <TwoWire::begin()+0xa8>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
60001ebc:	6b52      	ldr	r2, [r2, #52]	; 0x34
60001ebe:	601a      	str	r2, [r3, #0]
60001ec0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
60001ec4:	400fc000 	.word	0x400fc000
60001ec8:	05050bb8 	.word	0x05050bb8
60001ecc:	200006e4 	.word	0x200006e4
60001ed0:	0001f861 	.word	0x0001f861
60001ed4:	1928373b 	.word	0x1928373b

60001ed8 <TwoWire::setSDA(unsigned char)>:
//  Pins Configuration
//***************************************************


FLASHMEM void TwoWire::setSDA(uint8_t pin) {
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
60001ed8:	6943      	ldr	r3, [r0, #20]
60001eda:	7e02      	ldrb	r2, [r0, #24]
60001edc:	eb03 1202 	add.w	r2, r3, r2, lsl #4
//***************************************************
//  Pins Configuration
//***************************************************


FLASHMEM void TwoWire::setSDA(uint8_t pin) {
60001ee0:	b4f0      	push	{r4, r5, r6, r7}
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
60001ee2:	7a14      	ldrb	r4, [r2, #8]
60001ee4:	428c      	cmp	r4, r1
60001ee6:	d009      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
60001ee8:	7a1a      	ldrb	r2, [r3, #8]
		if (sda_pin == 255) return;
60001eea:	2aff      	cmp	r2, #255	; 0xff
60001eec:	d006      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
		if (sda_pin == pin) break;
60001eee:	428a      	cmp	r2, r1
60001ef0:	d028      	beq.n	60001f44 <TwoWire::setSDA(unsigned char)+0x6c>

FLASHMEM void TwoWire::setSDA(uint8_t pin) {
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
60001ef2:	7e1a      	ldrb	r2, [r3, #24]
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
60001ef4:	2aff      	cmp	r2, #255	; 0xff
60001ef6:	d001      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
60001ef8:	428a      	cmp	r2, r1
60001efa:	d001      	beq.n	60001f00 <TwoWire::setSDA(unsigned char)+0x28>
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
		// setup new one...
		configSDApin(newindex);
	}
	sda_pin_index_ = newindex;
}
60001efc:	bcf0      	pop	{r4, r5, r6, r7}
60001efe:	4770      	bx	lr
60001f00:	2501      	movs	r5, #1
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
60001f02:	462e      	mov	r6, r5
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
60001f04:	e893 0006 	ldmia.w	r3, {r1, r2}
60001f08:	6809      	ldr	r1, [r1, #0]
60001f0a:	4211      	tst	r1, r2
60001f0c:	d017      	beq.n	60001f3e <TwoWire::setSDA(unsigned char)+0x66>
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f0e:	4a0f      	ldr	r2, [pc, #60]	; (60001f4c <TwoWire::setSDA(unsigned char)+0x74>)
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f10:	eb03 1306 	add.w	r3, r3, r6, lsl #4
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f14:	2705      	movs	r7, #5
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f16:	4e0e      	ldr	r6, [pc, #56]	; (60001f50 <TwoWire::setSDA(unsigned char)+0x78>)
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f18:	eb02 1404 	add.w	r4, r2, r4, lsl #4
60001f1c:	6861      	ldr	r1, [r4, #4]
60001f1e:	600f      	str	r7, [r1, #0]
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f20:	7a19      	ldrb	r1, [r3, #8]
60001f22:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001f26:	6889      	ldr	r1, [r1, #8]
60001f28:	600e      	str	r6, [r1, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001f2a:	7a1c      	ldrb	r4, [r3, #8]
60001f2c:	68d9      	ldr	r1, [r3, #12]
60001f2e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001f32:	6852      	ldr	r2, [r2, #4]
60001f34:	6011      	str	r1, [r2, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001f36:	691a      	ldr	r2, [r3, #16]
60001f38:	b10a      	cbz	r2, 60001f3e <TwoWire::setSDA(unsigned char)+0x66>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001f3a:	695b      	ldr	r3, [r3, #20]
60001f3c:	6013      	str	r3, [r2, #0]
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
		// setup new one...
		configSDApin(newindex);
	}
	sda_pin_index_ = newindex;
60001f3e:	7605      	strb	r5, [r0, #24]
}
60001f40:	bcf0      	pop	{r4, r5, r6, r7}
60001f42:	4770      	bx	lr
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
60001f44:	2500      	movs	r5, #0
60001f46:	462e      	mov	r6, r5
60001f48:	e7dc      	b.n	60001f04 <TwoWire::setSDA(unsigned char)+0x2c>
60001f4a:	bf00      	nop
60001f4c:	200006e4 	.word	0x200006e4
60001f50:	0001f861 	.word	0x0001f861

60001f54 <TwoWire::configSDApin(unsigned char)>:
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f54:	6943      	ldr	r3, [r0, #20]
60001f56:	4a0b      	ldr	r2, [pc, #44]	; (60001f84 <TwoWire::configSDApin(unsigned char)+0x30>)
60001f58:	eb03 1001 	add.w	r0, r3, r1, lsl #4
	}
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
60001f5c:	b410      	push	{r4}
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f5e:	7a01      	ldrb	r1, [r0, #8]
60001f60:	4c09      	ldr	r4, [pc, #36]	; (60001f88 <TwoWire::configSDApin(unsigned char)+0x34>)
60001f62:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001f66:	6889      	ldr	r1, [r1, #8]
60001f68:	600c      	str	r4, [r1, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001f6a:	7a04      	ldrb	r4, [r0, #8]
60001f6c:	68c1      	ldr	r1, [r0, #12]
60001f6e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001f72:	6852      	ldr	r2, [r2, #4]
60001f74:	6011      	str	r1, [r2, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001f76:	6902      	ldr	r2, [r0, #16]
60001f78:	b10a      	cbz	r2, 60001f7e <TwoWire::configSDApin(unsigned char)+0x2a>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001f7a:	6943      	ldr	r3, [r0, #20]
60001f7c:	6013      	str	r3, [r2, #0]
	}
}
60001f7e:	f85d 4b04 	ldr.w	r4, [sp], #4
60001f82:	4770      	bx	lr
60001f84:	200006e4 	.word	0x200006e4
60001f88:	0001f861 	.word	0x0001f861

60001f8c <TwoWire::setSCL(unsigned char)>:

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
60001f8c:	6943      	ldr	r3, [r0, #20]
60001f8e:	7e42      	ldrb	r2, [r0, #25]
60001f90:	eb03 1202 	add.w	r2, r3, r2, lsl #4
	if (hardware.sda_pins[i].select_input_register) {
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
	}
}

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
60001f94:	b4f0      	push	{r4, r5, r6, r7}
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
60001f96:	f892 4028 	ldrb.w	r4, [r2, #40]	; 0x28
60001f9a:	428c      	cmp	r4, r1
60001f9c:	d00b      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
60001f9e:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
		if (scl_pin == 255) return;
60001fa2:	2aff      	cmp	r2, #255	; 0xff
60001fa4:	d007      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
		if (scl_pin == pin) break;
60001fa6:	428a      	cmp	r2, r1
60001fa8:	d02b      	beq.n	60002002 <TwoWire::setSCL(unsigned char)+0x76>

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
60001faa:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
60001fae:	2aff      	cmp	r2, #255	; 0xff
60001fb0:	d001      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
60001fb2:	428a      	cmp	r2, r1
60001fb4:	d001      	beq.n	60001fba <TwoWire::setSCL(unsigned char)+0x2e>
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
		// setup new one...
		configSCLpin(newindex);
	}
	scl_pin_index_ = newindex;
}
60001fb6:	bcf0      	pop	{r4, r5, r6, r7}
60001fb8:	4770      	bx	lr
60001fba:	2501      	movs	r5, #1
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
60001fbc:	462e      	mov	r6, r5
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
60001fbe:	e893 0006 	ldmia.w	r3, {r1, r2}
60001fc2:	6809      	ldr	r1, [r1, #0]
60001fc4:	4211      	tst	r1, r2
60001fc6:	d019      	beq.n	60001ffc <TwoWire::setSCL(unsigned char)+0x70>
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fc8:	4a0f      	ldr	r2, [pc, #60]	; (60002008 <TwoWire::setSCL(unsigned char)+0x7c>)
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fca:	eb03 1306 	add.w	r3, r3, r6, lsl #4
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fce:	2705      	movs	r7, #5
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fd0:	4e0e      	ldr	r6, [pc, #56]	; (6000200c <TwoWire::setSCL(unsigned char)+0x80>)
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fd2:	eb02 1404 	add.w	r4, r2, r4, lsl #4
60001fd6:	6861      	ldr	r1, [r4, #4]
60001fd8:	600f      	str	r7, [r1, #0]
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fda:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
60001fde:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001fe2:	6889      	ldr	r1, [r1, #8]
60001fe4:	600e      	str	r6, [r1, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60001fe6:	f893 4028 	ldrb.w	r4, [r3, #40]	; 0x28
60001fea:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
60001fec:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001ff0:	6852      	ldr	r2, [r2, #4]
60001ff2:	6011      	str	r1, [r2, #0]
	if (hardware.scl_pins[i].select_input_register) {
60001ff4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
60001ff6:	b10a      	cbz	r2, 60001ffc <TwoWire::setSCL(unsigned char)+0x70>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
60001ff8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
60001ffa:	6013      	str	r3, [r2, #0]
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
		// setup new one...
		configSCLpin(newindex);
	}
	scl_pin_index_ = newindex;
60001ffc:	7645      	strb	r5, [r0, #25]
}
60001ffe:	bcf0      	pop	{r4, r5, r6, r7}
60002000:	4770      	bx	lr
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
60002002:	2500      	movs	r5, #0
60002004:	462e      	mov	r6, r5
60002006:	e7da      	b.n	60001fbe <TwoWire::setSCL(unsigned char)+0x32>
60002008:	200006e4 	.word	0x200006e4
6000200c:	0001f861 	.word	0x0001f861

60002010 <TwoWire::configSCLpin(unsigned char)>:
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60002010:	6943      	ldr	r3, [r0, #20]
60002012:	4a0c      	ldr	r2, [pc, #48]	; (60002044 <TwoWire::configSCLpin(unsigned char)+0x34>)
60002014:	eb03 1001 	add.w	r0, r3, r1, lsl #4
	}
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
60002018:	b410      	push	{r4}
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
6000201a:	f890 1028 	ldrb.w	r1, [r0, #40]	; 0x28
6000201e:	4c0a      	ldr	r4, [pc, #40]	; (60002048 <TwoWire::configSCLpin(unsigned char)+0x38>)
60002020:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60002024:	6889      	ldr	r1, [r1, #8]
60002026:	600c      	str	r4, [r1, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60002028:	f890 4028 	ldrb.w	r4, [r0, #40]	; 0x28
6000202c:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
6000202e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60002032:	6852      	ldr	r2, [r2, #4]
60002034:	6011      	str	r1, [r2, #0]
	if (hardware.scl_pins[i].select_input_register) {
60002036:	6b02      	ldr	r2, [r0, #48]	; 0x30
60002038:	b10a      	cbz	r2, 6000203e <TwoWire::configSCLpin(unsigned char)+0x2e>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
6000203a:	6b43      	ldr	r3, [r0, #52]	; 0x34
6000203c:	6013      	str	r3, [r2, #0]
	}
}
6000203e:	f85d 4b04 	ldr.w	r4, [sp], #4
60002042:	4770      	bx	lr
60002044:	200006e4 	.word	0x200006e4
60002048:	0001f861 	.word	0x0001f861

6000204c <_init>:
6000204c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000204e:	bf00      	nop
60002050:	bcf8      	pop	{r3, r4, r5, r6, r7}
60002052:	bc08      	pop	{r3}
60002054:	469e      	mov	lr, r3
60002056:	4770      	bx	lr

60002058 <__main_veneer>:
60002058:	f85f f000 	ldr.w	pc, [pc]	; 6000205c <__main_veneer+0x4>
6000205c:	000000a1 	.word	0x000000a1

60002060 <__usb_init_serialnumber_veneer>:
60002060:	f85f f000 	ldr.w	pc, [pc]	; 60002064 <__usb_init_serialnumber_veneer+0x4>
60002064:	00002881 	.word	0x00002881

60002068 <____libc_init_array_veneer>:
60002068:	f85f f000 	ldr.w	pc, [pc]	; 6000206c <____libc_init_array_veneer+0x4>
6000206c:	000066ad 	.word	0x000066ad

60002070 <__set_arm_clock_veneer>:
60002070:	f85f f000 	ldr.w	pc, [pc]	; 60002074 <__set_arm_clock_veneer+0x4>
60002074:	000014e5 	.word	0x000014e5

60002078 <__delay_veneer>:
60002078:	f85f f000 	ldr.w	pc, [pc]	; 6000207c <__delay_veneer+0x4>
6000207c:	000017a9 	.word	0x000017a9

60002080 <__memset_veneer>:
60002080:	f85f f000 	ldr.w	pc, [pc]	; 60002084 <__memset_veneer+0x4>
60002084:	00006eb5 	.word	0x00006eb5

60002088 <__sm_set_pool_veneer>:
60002088:	f85f f000 	ldr.w	pc, [pc]	; 6000208c <__sm_set_pool_veneer+0x4>
6000208c:	00001cfd 	.word	0x00001cfd

60002090 <__pwm_init_veneer>:
60002090:	f85f f000 	ldr.w	pc, [pc]	; 60002094 <__pwm_init_veneer+0x4>
60002094:	000019c5 	.word	0x000019c5

60002098 <__init_array_start>:
60002098:	00000045 	.word	0x00000045
6000209c:	00000261 	.word	0x00000261
600020a0:	00003019 	.word	0x00003019

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      20:	4c05b510 	.word	0x4c05b510
      24:	7823      	ldrb	r3, [r4, #0]
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      26:	b933      	.short	0xb933
      28:	4b04      	ldr	r3, [pc, #16]	; (3c <_teensy_model_identifier+0x17>)
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      2a:	b113      	.short	0xb113
      2c:	4804      	ldr	r0, [pc, #16]	; (40 <_teensy_model_identifier+0x1b>)
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      2e:	f3af 8000 	nop.w
      32:	2301      	.short	0x2301
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      34:	7023      	strb	r3, [r4, #0]
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
      36:	bd10      	.short	0xbd10
      38:	2668      	movs	r6, #104	; 0x68
      3a:	2000      	.short	0x2000
      3c:	0000      	movs	r0, r0
      3e:	0000      	.short	0x0000
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
      40:	a904      	add	r1, sp, #16
	...

00000044 <frame_dummy>:

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      44:	b5104b08 	.word	0xb5104b08
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      48:	b11b      	cbz	r3, 52 <frame_dummy+0xe>
      4a:	4908      	.short	0x4908
      4c:	4808      	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	f3af      	.short	0xf3af
      50:	8000      	strh	r0, [r0, #0]
      52:	4808      	.short	0x4808
      54:	6803      	ldr	r3, [r0, #0]
      56:	b903      	.short	0xb903
      58:	bd10      	pop	{r4, pc}
      5a:	4b07      	.short	0x4b07
      5c:	2b00      	cmp	r3, #0
      5e:	d0fb      	.short	0xd0fb
      60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      64:	4718      	bx	r3
      66:	bf00      	nop
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      68:	0000      	movs	r0, r0
      6a:	0000      	movs	r0, r0
			yield(); // TODO: what happens if yield-called code uses analogRead()
      6c:	266c      	movs	r6, #108	; 0x6c
      6e:	2000      	movs	r0, #0
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      70:	a904      	add	r1, sp, #16
      72:	0000      	.short	0x0000
      74:	22c0      	movs	r2, #192	; 0xc0
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC2_R0;
      76:	2000      	movs	r0, #0
      78:	0000      	movs	r0, r0
	...

0000007c <Print::println(char const*)>:
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
      7c:	b538      	push	{r3, r4, r5, lr}
      7e:	4604      	mov	r4, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
      80:	4608      	mov	r0, r1
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
      82:	460d      	mov	r5, r1
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
      84:	f007 fb5c 	bl	7740 <strlen>
      88:	6823      	ldr	r3, [r4, #0]
      8a:	4602      	.short	0x4602
      8c:	4629      	mov	r1, r5
      8e:	4620      	.short	0x4620
      90:	685b      	ldr	r3, [r3, #4]
      92:	4798      	.short	0x4798
      94:	4605      	mov	r5, r0
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
      96:	4620      	.short	0x4620
      98:	f002 ff90 	bl	2fbc <Print::println()>
      9c:	bd384428 	.word	0xbd384428

000000a0 <main>:


#ifdef __cplusplus
extern "C" void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
      a0:	b570      	push	{r4, r5, r6, lr}
	port->SCR = 0;
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
      a2:	4c5e      	.short	0x4c5e
      a4:	b0ac      	sub	sp, #176	; 0xb0
      a6:	4d5e      	ldr	r5, [pc, #376]	; (220 <main+0x180>)
	NVIC_ENABLE_IRQ(hardware.irq_number);
      a8:	f870f003 	.word	0xf870f003
	port->SCR = 0;
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
      ac:	7823      	ldrb	r3, [r4, #0]
	NVIC_ENABLE_IRQ(hardware.irq_number);
	port->SIER = LPI2C_SIER_TDIE |  LPI2C_SIER_RDIE | LPI2C_SIER_SDIE;
      ae:	2b00      	cmp	r3, #0
      b0:	d0fa      	beq.n	a8 <main+0x8>
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
	NVIC_ENABLE_IRQ(hardware.irq_number);
      b2:	782b      	ldrb	r3, [r5, #0]
	port->SCR = 0;
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
      b4:	2b00      	cmp	r3, #0
	NVIC_ENABLE_IRQ(hardware.irq_number);
      b6:	d0f7      	beq.n	a8 <main+0x8>
	port->SIER = LPI2C_SIER_TDIE |  LPI2C_SIER_RDIE | LPI2C_SIER_SDIE;
      b8:	2500495a 	.word	0x2500495a
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
	NVIC_ENABLE_IRQ(hardware.irq_number);
      bc:	485a      	ldr	r0, [pc, #360]	; (228 <main+0x188>)
      be:	ae04      	add	r6, sp, #16
      c0:	ffdcf7ff 	.word	0xffdcf7ff
      c4:	4b59      	ldr	r3, [pc, #356]	; (22c <main+0x18c>)
      c6:	4a5a      	.short	0x4a5a
      c8:	462c      	mov	r4, r5
      ca:	e893 0003 	ldmia.w	r3, {r0, r1}
	port->SIER = LPI2C_SIER_TDIE |  LPI2C_SIER_RDIE | LPI2C_SIER_SDIE;
      ce:	9202      	str	r2, [sp, #8]
	transmitting = 0;
      d0:	e886 0003 	stmia.w	r6, {r0, r1}
	slave_mode = 1;
      d4:	4629      	mov	r1, r5
      d6:	4857      	ldr	r0, [pc, #348]	; (234 <main+0x194>)
	port->SCR = LPI2C_SCR_SEN;
      d8:	f000 ff10 	bl	efc <FTYK::set(int)>
      dc:	f000a80a 	.word	0xf000a80a
      e0:	fd2f 4955 	stc2	9, cr4, [pc, #-340]!	; ffffff90 <_flexram_bank_config+0x555554e1>
      e4:	f002a806 	.word	0xf002a806
      e8:	ffe3 aa06 	vmlsl.u32	q13, d3, d6
      ec:	48514629 	.word	0x48514629
      f0:	f000 ff76 	bl	fe0 <FTYK::print(int, String)>
      f4:	f002a806 	.word	0xf002a806
	int imu_input;
	int cmf_inputs[2] = {9, 10};

	watch.set(0);
	SystemGraph sg;
	watch.print(0, "SG init");
      f8:	ff9b 2101 	vaddw.u16	q1, <illegal reg q5.5>, d1

	watch.set(1);
      fc:	f000484d 	.word	0xf000484d
     100:	fefd 494e 	cdp2	9, 15, cr4, cr13, cr14, {2}
	sg.add("LSM", 10, 0, 0, &imu_input);
     104:	f002a806 	.word	0xf002a806
     108:	ffd3 ab03 			; <UNDEFINED> instruction: 0xffd3ab03
     10c:	a906220a 	.word	0xa906220a
     110:	a80a      	add	r0, sp, #40	; 0x28
     112:	9301      	str	r3, [sp, #4]
     114:	9500      	str	r5, [sp, #0]
     116:	462b      	mov	r3, r5
     118:	f000 fd70 	bl	bfc <SystemGraph::add(String, int, int, int, int*)>
     11c:	a806      	add	r0, sp, #24
     11e:	f002 ff87 	bl	3030 <String::~String()>
	watch.print(1, "LSM Node init");
     122:	4947      	.short	0x4947
     124:	a806      	add	r0, sp, #24
     126:	f002 ffc3 	bl	30b0 <String::String(char const*)>
     12a:	aa06      	.short	0xaa06
     12c:	2101      	movs	r1, #1
     12e:	4841      	ldr	r0, [pc, #260]	; (234 <main+0x194>)
     130:	ff56f000 	.word	0xff56f000
     134:	a806      	add	r0, sp, #24
     136:	f002      	.short	0xf002
     138:	ff7b 2101 	vrhadd.u<illegal width 64>	d18, d11, d1

	watch.set(1);
     13c:	f000483d 	.word	0xf000483d
     140:	fedd 4940 	cdp2	9, 13, cr4, cr13, cr0, {2}
	sg.add("CMF", 9, 1, 2, cmf_inputs);
     144:	f002a806 	.word	0xf002a806
     148:	ffb3 2302 	vsubw.u<illegal width 64>	q1, <illegal reg q1.5>, d2
     14c:	a9062209 	.word	0xa9062209
     150:	a80a      	add	r0, sp, #40	; 0x28
     152:	9300      	.short	0x9300
     154:	9601      	str	r6, [sp, #4]
     156:	2301      	.short	0x2301
     158:	f000 fd50 	bl	bfc <SystemGraph::add(String, int, int, int, int*)>
     15c:	f002a806 	.word	0xf002a806
     160:	ff67 4939 	vmul.p32	d20, d7, d25
	watch.print(1, "CMF Node init");
     164:	f002a806 	.word	0xf002a806
     168:	ffa3 aa06 	vmlsl.u32	q5, d3, d6
     16c:	48312101 	.word	0x48312101
     170:	f000 ff36 	bl	fe0 <FTYK::print(int, String)>
     174:	f002a806 	.word	0xf002a806
     178:	ff5b 2101 	vrhadd.u16	d18, d11, d1

	watch.set(1);
     17c:	482d      	ldr	r0, [pc, #180]	; (234 <main+0x194>)
     17e:	f000      	.short	0xf000
     180:	febd ab02 	cdp2	11, 11, cr10, cr13, cr2, {0}
	sg.update_config(9, 0, 1, tmp);
     184:	a80a462a 	.word	0xa80a462a
     188:	9300      	str	r3, [sp, #0]
     18a:	2109      	.short	0x2109
     18c:	2301      	movs	r3, #1
     18e:	f000      	.short	0xf000
     190:	fde9 492e 	stc2l	9, cr4, [r9, #184]!	; 0xb8
	watch.print(1, "Update config");
     194:	f002a806 	.word	0xf002a806
     198:	ff8b 4826 	vmlal.u8	q2, d11, d22
     19c:	aa06      	add	r2, sp, #24
     19e:	2101      	.short	0x2101
     1a0:	f000 ff1e 	bl	fe0 <FTYK::print(int, String)>
     1a4:	f002a806 	.word	0xf002a806
     1a8:	ff43 4622 	vmax.u8	d20, d3, d18

	for (int i = 0; i < 3; i++) {
		Serial.printf("Iteration: %i ===\n", i);
     1ac:	481e4928 	.word	0x481e4928

	watch.set(1);
	sg.update_config(9, 0, 1, tmp);
	watch.print(1, "Update config");

	for (int i = 0; i < 3; i++) {
     1b0:	3401      	adds	r4, #1
		Serial.printf("Iteration: %i ===\n", i);
     1b2:	f002      	.short	0xf002
     1b4:	ff1b 2101 	vrhadd.u16	d2, d11, d1
		watch.set(1);
     1b8:	481e      	ldr	r0, [pc, #120]	; (234 <main+0x194>)
     1ba:	f000 fe9f 	bl	efc <FTYK::set(int)>
		sg.spin();
     1be:	a80a      	add	r0, sp, #40	; 0x28
     1c0:	f000 fe12 	bl	de8 <SystemGraph::spin()>
		watch.print(1, "Run"); 
     1c4:	4923      	ldr	r1, [pc, #140]	; (254 <main+0x1b4>)
     1c6:	a806      	add	r0, sp, #24
     1c8:	f002 ff72 	bl	30b0 <String::String(char const*)>
     1cc:	aa06      	add	r2, sp, #24
     1ce:	2101      	.short	0x2101
     1d0:	4818      	ldr	r0, [pc, #96]	; (234 <main+0x194>)
     1d2:	f000      	.short	0xf000
     1d4:	ff05 a806 	vsub.i8	d10, d5, d6
     1d8:	ff2af002 	.word	0xff2af002
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
     1dc:	f002 fe46 	bl	2e6c <usb_seremu_flush_output>

	watch.set(1);
	sg.update_config(9, 0, 1, tmp);
	watch.print(1, "Update config");

	for (int i = 0; i < 3; i++) {
     1e0:	d1e22c03 	.word	0xd1e22c03
		watch.set(1);
		sg.spin();
		watch.print(1, "Run"); 
		Serial.flush();
	}
	sg.dump_all();
     1e4:	a80a      	add	r0, sp, #40	; 0x28
     1e6:	f000      	.short	0xf000
     1e8:	fe2d 220a 	cdp2	2, 2, cr2, cr13, cr10, {0}
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     1ec:	491a      	ldr	r1, [pc, #104]	; (258 <main+0x1b8>)
     1ee:	480e      	ldr	r0, [pc, #56]	; (228 <main+0x188>)
     1f0:	f002 ffc4 	bl	317c <usb_seremu_class::write(unsigned char const*, unsigned int)>

	Serial.print("Full test "); watch.print(0);
     1f4:	480f2100 	.word	0x480f2100
     1f8:	f000 fea2 	bl	f40 <FTYK::print(int)>

	Serial.println("=== Finished System Graph tests ===");
     1fc:	4917      	ldr	r1, [pc, #92]	; (25c <main+0x1bc>)
     1fe:	480a      	ldr	r0, [pc, #40]	; (228 <main+0x188>)
     200:	f7ff ff3c 	bl	7c <Print::println(char const*)>
#include "system_graph/graph_node.h"
#include "system_graph/process_factory.h"

#define MAXIMUM_GRAPH_NODES 10

class SystemGraph {
     204:	a82a      	add	r0, sp, #168	; 0xa8
     206:	f001 f90d 	bl	1424 <Vector<GraphNode*>::~Vector()>
     20a:	a828      	add	r0, sp, #160	; 0xa0
     20c:	ffaef000 	.word	0xffaef000
     210:	a826      	add	r0, sp, #152	; 0x98
     212:	f000      	.short	0xf000
     214:	ffab 2000 	vaddl.u32	q1, d11, d0
	
     218:	bd70b02c 	.word	0xbd70b02c
     21c:	2789      	movs	r7, #137	; 0x89
     21e:	2000      	.short	0x2000
     220:	278c      	movs	r7, #140	; 0x8c
     222:	2000      	.short	0x2000
     224:	0b34      	lsrs	r4, r6, #12
     226:	2000      	.short	0x2000
     228:	1474      	asrs	r4, r6, #17
     22a:	2000      	.short	0x2000
     22c:	03f0      	lsls	r0, r6, #15
     22e:	2000      	.short	0x2000
     230:	999a      	ldr	r1, [sp, #616]	; 0x268
     232:	3f19      	subs	r7, #25
     234:	2750      	movs	r7, #80	; 0x50
     236:	2000      	movs	r0, #0
     238:	20000b58 	.word	0x20000b58
     23c:	0b60      	lsrs	r0, r4, #13
     23e:	2000      	movs	r0, #0
     240:	0b64      	lsrs	r4, r4, #13
     242:	2000      	movs	r0, #0
     244:	20000b74 	.word	0x20000b74
     248:	0b78      	lsrs	r0, r7, #13
     24a:	2000      	.short	0x2000
     24c:	0b88      	lsrs	r0, r1, #14
     24e:	2000      	movs	r0, #0
     250:	0af0      	lsrs	r0, r6, #11
     252:	2000      	movs	r0, #0
     254:	0c4c      	lsrs	r4, r1, #17
     256:	2000      	movs	r0, #0
     258:	0b04      	lsrs	r4, r0, #12
     25a:	2000      	movs	r0, #0
     25c:	0b10      	lsrs	r0, r2, #12
     25e:	2000      	movs	r0, #0

00000260 <_GLOBAL__sub_I_watch>:
#include "system_graph/graph_node.h"
#include "system_graph/system_graph.h"

#include "sensors/lsm6dsox.h"

FTYK watch;
     260:	f0004801 	.word	0xf0004801
     264:	be3b      	bkpt	0x003b
     266:	bf00      	.short	0xbf00
     268:	2750      	movs	r7, #80	; 0x50
     26a:	2000      	.short	0x2000
void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
	}
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
     26c:	0000      	movs	r0, r0
	...

00000270 <nd_norm(float*, int)>:
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     270:	2900      	cmp	r1, #0
     272:	dd15      	.short	0xdd15
     274:	ed9f 7a12 	vldr	s14, [pc, #72]	; 2c0 <nd_norm(float*, int)+0x50>
     278:	eb00 0181 	add.w	r1, r0, r1, lsl #2
		sum += v[i] * v[i];
     27c:	ecf0 7a01 	vldmia	r0!, {s15}
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     280:	4281      	cmp	r1, r0
		sum += v[i] * v[i];
     282:	eea7 7aa7 	vfma.f32	s14, s15, s15
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     286:	d1f9      	bne.n	27c <nd_norm(float*, int)+0xc>
     288:	7ac7eeb7 	.word	0x7ac7eeb7
		sum += v[i] * v[i];
	}
	return sqrt(sum);
     28c:	eeb1 0bc7 	vsqrt.f64	d0, d7
     290:	0b40eeb4 	.word	0x0b40eeb4
     294:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     298:	eeb7d105 	.word	0xeeb7d105
}
     29c:	0bc0      	lsrs	r0, r0, #15
     29e:	4770      	bx	lr
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     2a0:	ed9f 7b05 	vldr	d7, [pc, #20]	; 2b8 <nd_norm(float*, int)+0x48>
     2a4:	b508e7f2 	.word	0xb508e7f2
		sum += v[i] * v[i];
	}
	return sqrt(sum);
     2a8:	eeb0 0b47 	vmov.f64	d0, d7
     2ac:	f004 fe9c 	bl	4fe8 <sqrt>
}
     2b0:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     2b4:	bd08      	pop	{r3, pc}
     2b6:	bf00      	nop
	...

000002c4 <weighted_vector_addition(float*, float*, float, float, int, float*)>:

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     2c4:	2a00      	cmp	r2, #0
     2c6:	dd0d      	ble.n	2e4 <weighted_vector_addition(float*, float*, float, float, int, float*)+0x20>
     2c8:	eb00 0282 	add.w	r2, r0, r2, lsl #2
		output[i] = (k1 * a[i]) + (k2 * b[i]);
     2cc:	ecf1 7a01 	vldmia	r1!, {s15}
     2d0:	ecb0 7a01 	vldmia	r0!, {s14}
     2d4:	ee67 7aa0 	vmul.f32	s15, s15, s1

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     2d8:	4290      	cmp	r0, r2
		output[i] = (k1 * a[i]) + (k2 * b[i]);
     2da:	eee7 7a00 	vfma.f32	s15, s14, s0
     2de:	ece3 7a01 	vstmia	r3!, {s15}

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     2e2:	d1f3      	.short	0xd1f3
     2e4:	4770      	bx	lr
     2e6:	bf00      	nop

000002e8 <HidReport::HidReport()>:
						data[i+8], data[i+9], data[i+10], data[i+11],
						data[i+12], data[i+13], data[i+14], data[i+15]);
	}
}

HidReport::HidReport() {
     2e8:	b510      	push	{r4, lr}

void HidReport::clear(){
	/*
		  Clear the HID packet (set all indices = 0)
	*/
	memset(data, 0, HID_REPORT_SIZE_BYTES);
     2ea:	2240      	movs	r2, #64	; 0x40
     2ec:	2100      	movs	r1, #0
						data[i+8], data[i+9], data[i+10], data[i+11],
						data[i+12], data[i+13], data[i+14], data[i+15]);
	}
}

HidReport::HidReport() {
     2ee:	4604      	mov	r4, r0

void HidReport::clear(){
	/*
		  Clear the HID packet (set all indices = 0)
	*/
	memset(data, 0, HID_REPORT_SIZE_BYTES);
     2f0:	f006 fde0 	bl	6eb4 <memset>
		  Set the byte at packet[idx]
		@param:
			idx: index of the byte to set
			value: the byte to write
	*/
	data[idx] = value;
     2f4:	23ff      	movs	r3, #255	; 0xff
}

HidReport::HidReport() {
	clear();
	put(0, 255);
}
     2f6:	4620      	mov	r0, r4
		  Set the byte at packet[idx]
		@param:
			idx: index of the byte to set
			value: the byte to write
	*/
	data[idx] = value;
     2f8:	7023      	strb	r3, [r4, #0]
}

HidReport::HidReport() {
	clear();
	put(0, 255);
}
     2fa:	bd10      	pop	{r4, pc}

000002fc <LSM6DSOX::reset()>:
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     2fc:	2300      	movs	r3, #0
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     2fe:	2200      	movs	r2, #0
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     300:	6103      	str	r3, [r0, #16]
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     302:	60c2      	str	r2, [r0, #12]
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
     304:	61c3      	str	r3, [r0, #28]
		mag[i] = 0;
     306:	6283      	str	r3, [r0, #40]	; 0x28
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     308:	6143      	str	r3, [r0, #20]
		gyro[i] = 0;
     30a:	6203      	str	r3, [r0, #32]
		mag[i] = 0;
     30c:	618362c3 	.word	0x618362c3

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
     310:	6243      	str	r3, [r0, #36]	; 0x24
		mag[i] = 0;
     312:	6303      	str	r3, [r0, #48]	; 0x30
     314:	4770      	bx	lr
     316:	bf00      	nop

00000318 <LSM6DSOX::clear()>:
	}
}

void LSM6DSOX::clear() {
	reset();
     318:	68db6803 	.word	0x68db6803
     31c:	4718      	bx	r3
     31e:	bf00      	nop

00000320 <LSM6DSOX::setup(Vector<float>*)>:
}

void LSM6DSOX::setup(Vector<float>* config) {
	reset();
     320:	6803      	ldr	r3, [r0, #0]
     322:	68db      	.short	0x68db
     324:	4718      	bx	r3
     326:	bf00      	.short	0xbf00

00000328 <LSM6DSOX::context(Vector<float>*)>:
}

void LSM6DSOX::context(Vector<float>* context) {
     328:	b538      	push	{r3, r4, r5, lr}
     32a:	460c      	mov	r4, r1
     32c:	21024605 	.word	0x21024605
	context->reset(dimensions[2]);
     330:	3004      	adds	r0, #4
     332:	f000      	.short	0xf000
     334:	ff83 6801 	vmlal.u8	q3, d3, d1
     338:	4620      	mov	r0, r4
     33a:	f000      	.short	0xf000
     33c:	ffb1 ed95 			; <UNDEFINED> instruction: 0xffb1ed95
	context->push(sensor_index);
     340:	46200a03 	.word	0x46200a03
     344:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
}
     348:	4038e8bd 	.word	0x4038e8bd
	reset();
}

void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
     34c:	f000 bfcc 	b.w	12e8 <Vector<float>::push(float)>

00000350 <LSM6DSOX::run(Vector<float>*, Vector<float>*)>:
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
	switch (sensor_index) {
     350:	2b0168c3 	.word	0x2b0168c3
void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
     354:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     358:	b08a4604 	.word	0xb08a4604
     35c:	4617      	mov	r7, r2
	switch (sensor_index) {
     35e:	d04c      	.short	0xd04c
     360:	2b02      	cmp	r3, #2
     362:	d039      	.short	0xd039
     364:	b333      	cbz	r3, 3b4 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x64>
			read_lis3mdl();
			sensor_index = 0;
			break;

		default:
			sensor_index = 0;
     366:	2300      	.short	0x2300
     368:	f100 0810 	add.w	r8, r0, #16
     36c:	061cf100 	.word	0x061cf100
     370:	f100 0528 	add.w	r5, r0, #40	; 0x28
     374:	46c660c3 	.word	0x46c660c3
     378:	4631      	mov	r1, r6
     37a:	4628      	.short	0x4628
     37c:	ab01      	add	r3, sp, #4
void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
     37e:	2203      	.short	0x2203
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		tmp[i] = accel[i];
     380:	f85e cb04 	ldr.w	ip, [lr], #4
			sensor_index = 0;
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
     384:	f8513a01 	.word	0xf8513a01
		tmp[i] = accel[i];
		tmp[i+3] = gyro[i];
     388:	6b04      	ldr	r4, [r0, #48]	; 0x30
     38a:	f103      	.short	0xf103
     38c:	0304      	lsls	r4, r0, #12
		tmp[i+6] = mag[i];
     38e:	f850      	.short	0xf850
     390:	5b04      	ldrh	r4, [r0, r4]
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		tmp[i] = accel[i];
     392:	f843      	.short	0xf843
     394:	cc04      	ldmia	r4!, {r2}
		tmp[i+3] = gyro[i];
     396:	609e      	str	r6, [r3, #8]
		tmp[i+6] = mag[i];
     398:	d1f1615d 	.word	0xd1f1615d
	}

	output->from_array(tmp, dimensions[OUTPUT_DIMENSION]);
     39c:	1d20      	adds	r0, r4, #4
     39e:	2102      	.short	0x2102
     3a0:	f000 ff4c 	bl	123c <Vector<int>::operator[](int)>
     3a4:	a901      	add	r1, sp, #4
     3a6:	6802      	.short	0x6802
     3a8:	4638      	mov	r0, r7
     3aa:	f000      	.short	0xf000
     3ac:	ff8f b00a 	vaddl.u8	<illegal reg q5.5>, d15, d10
}
     3b0:	81f0e8bd 	.word	0x81f0e8bd

void LSM6DSOX::read_lsm6dsox_accel(){
	/*
		Get the jawns from the jimmys
	*/
	lsm6dsox.readAcceleration(accel[0], accel[1], accel[2]);
     3b4:	f100 0810 	add.w	r8, r0, #16
     3b8:	0318f100 	.word	0x0318f100
     3bc:	f100 0214 	add.w	r2, r0, #20
     3c0:	4641305c 	.word	0x4641305c
     3c4:	f104 061c 	add.w	r6, r4, #28
     3c8:	f004 f992 	bl	46f0 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)>

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
	switch (sensor_index) {
		case 0:
			read_lsm6dsox_accel();
			sensor_index ++;
     3cc:	f10468e3 	.word	0xf10468e3
     3d0:	0528      	lsls	r0, r5, #20
     3d2:	3301      	.short	0x3301
     3d4:	60e3      	str	r3, [r4, #12]
			break;
     3d6:	e7ce      	b.n	376 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>

void LSM6DSOX::read_lis3mdl(){
	/*
		Get the jawns from the jimmys
	*/
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
     3d8:	f100 0528 	add.w	r5, r0, #40	; 0x28
     3dc:	0330f100 	.word	0x0330f100
     3e0:	f100 022c 	add.w	r2, r0, #44	; 0x2c
     3e4:	46293034 	.word	0x46293034
     3e8:	f104 0810 	add.w	r8, r4, #16
     3ec:	fd88f003 	.word	0xfd88f003
			sensor_index ++;
			break;

		case 2:
			read_lis3mdl();
			sensor_index = 0;
     3f0:	2300      	movs	r3, #0
     3f2:	f104      	.short	0xf104
     3f4:	061c      	lsls	r4, r3, #24
     3f6:	60e3      	.short	0x60e3
			break;
     3f8:	e7bd      	b.n	376 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>

void LSM6DSOX::read_lsm6dsox_gyro(){
	/*
		Get the jawns from the jimmys
	*/
	lsm6dsox.readGyroscope(gyro[0], gyro[1], gyro[2]);
     3fa:	f100      	.short	0xf100
     3fc:	061c      	lsls	r4, r3, #24
     3fe:	f100 0324 	add.w	r3, r0, #36	; 0x24
     402:	f100      	.short	0xf100
     404:	0220      	lsls	r0, r4, #8
     406:	305c      	adds	r0, #92	; 0x5c
     408:	4631      	mov	r1, r6
     40a:	f104      	.short	0xf104
     40c:	0810      	lsrs	r0, r2, #32
     40e:	f004      	.short	0xf004
     410:	f9d3 68e3 	ldr??.w	r6, [r3, #2275]	; 0x8e3
			sensor_index ++;
			break;

		case 1:
			read_lsm6dsox_gyro();
			sensor_index ++;
     414:	0528f104 	.word	0x0528f104
     418:	3301      	adds	r3, #1
     41a:	60e3      	.short	0x60e3
			break;
     41c:	e7ab      	b.n	376 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>
     41e:	bf00      	nop

00000420 <LSM6DSOX::print()>:

	output->from_array(tmp, dimensions[OUTPUT_DIMENSION]);
}


void LSM6DSOX::print() {
     420:	b530      	push	{r4, r5, lr}
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     422:	4d29      	ldr	r5, [pc, #164]	; (4c8 <LSM6DSOX::print()+0xa8>)
     424:	b085      	sub	sp, #20
     426:	4604      	mov	r4, r0
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
     428:	2108      	movs	r1, #8
     42a:	4828      	ldr	r0, [pc, #160]	; (4cc <LSM6DSOX::print()+0xac>)
     42c:	f002 fd10 	bl	2e50 <usb_seremu_write>
     430:	4628      	mov	r0, r5
     432:	f002 fdc3 	bl	2fbc <Print::println()>
	Serial.println("LSM6DSOX");
	Serial.printf("\tsensor_index: %i\n", sensor_index);
     436:	68e2      	ldr	r2, [r4, #12]
     438:	4628      	mov	r0, r5
     43a:	4925      	ldr	r1, [pc, #148]	; (4d0 <LSM6DSOX::print()+0xb0>)
     43c:	f002 fdd6 	bl	2fec <Print::printf(char const*, ...)>
	Serial.printf("\taccel: [%f, %f, %f]\n", accel[0], accel[1], accel[2]);
     440:	ed94 6a06 	vldr	s12, [r4, #24]
     444:	ed94 7a05 	vldr	s14, [r4, #20]
     448:	4628      	mov	r0, r5
     44a:	edd4 5a04 	vldr	s11, [r4, #16]
     44e:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     452:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     456:	491f      	ldr	r1, [pc, #124]	; (4d4 <LSM6DSOX::print()+0xb4>)
     458:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     45c:	ed8d 6b02 	vstr	d6, [sp, #8]
     460:	ec53 2b15 	vmov	r2, r3, d5
     464:	ed8d 7b00 	vstr	d7, [sp]
     468:	f002 fdc0 	bl	2fec <Print::printf(char const*, ...)>
	Serial.printf("\tgyro: [%f, %f, %f]\n", gyro[0], gyro[1], gyro[2]);
     46c:	ed94 6a09 	vldr	s12, [r4, #36]	; 0x24
     470:	ed94 7a08 	vldr	s14, [r4, #32]
     474:	4628      	mov	r0, r5
     476:	edd4 5a07 	vldr	s11, [r4, #28]
     47a:	eeb7      	.short	0xeeb7
     47c:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
     47e:	eeb7      	.short	0xeeb7
     480:	7ac7      	ldrb	r7, [r0, #11]
     482:	4915      	.short	0x4915
     484:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     488:	6b02ed8d 	.word	0x6b02ed8d
     48c:	ec53 2b15 	vmov	r2, r3, d5
     490:	7b00ed8d 	.word	0x7b00ed8d
     494:	f002 fdaa 	bl	2fec <Print::printf(char const*, ...)>
	Serial.printf("\tmag: [%f, %f, %f]\n", mag[0], mag[1], mag[2]);
     498:	6a0ced94 	.word	0x6a0ced94
     49c:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
     4a0:	edd44628 	.word	0xedd44628
     4a4:	5a0a      	ldrh	r2, [r1, r0]
     4a6:	eeb7      	.short	0xeeb7
     4a8:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
     4aa:	eeb7      	.short	0xeeb7
     4ac:	7ac7      	ldrb	r7, [r0, #11]
     4ae:	490b      	ldr	r1, [pc, #44]	; (4dc <LSM6DSOX::print()+0xbc>)
     4b0:	5ae5eeb7 	.word	0x5ae5eeb7
     4b4:	ed8d 6b02 	vstr	d6, [sp, #8]
     4b8:	2b15ec53 	.word	0x2b15ec53
     4bc:	ed8d 7b00 	vstr	d7, [sp]
     4c0:	f002 fd94 	bl	2fec <Print::printf(char const*, ...)>
	// data.print();
}
     4c4:	b005      	add	sp, #20
     4c6:	bd30      	.short	0xbd30
     4c8:	1474      	asrs	r4, r6, #17
     4ca:	2000      	.short	0x2000
     4cc:	0b98      	lsrs	r0, r3, #14
     4ce:	2000      	movs	r0, #0
     4d0:	0ba4      	lsrs	r4, r4, #14
     4d2:	2000      	movs	r0, #0
     4d4:	0bb8      	lsrs	r0, r7, #14
     4d6:	2000      	.short	0x2000
     4d8:	0bd0      	lsrs	r0, r2, #15
     4da:	2000      	.short	0x2000
     4dc:	0be8      	lsrs	r0, r5, #15
     4de:	2000      	.short	0x2000

000004e0 <LSM6DSOX::LSM6DSOX()>:
#include "lsm6dsox.h"

LSM6DSOX::LSM6DSOX() {
     4e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	Base class for all user defined processes.
	Must override the functions below, constructor
	optional... I think.
*/

class Process {	
     4e4:	46804b48 	.word	0x46804b48
     4e8:	b084      	sub	sp, #16
     4ea:	4605      	.short	0x4605
     4ec:	f100 075c 	add.w	r7, r0, #92	; 0x5c
     4f0:	f8484606 	.word	0xf8484606
     4f4:	3b04      	subs	r3, #4
     4f6:	4640      	mov	r0, r8
     4f8:	f000 fe34 	bl	1164 <Vector<int>::Vector()>
     4fc:	4b43      	ldr	r3, [pc, #268]	; (60c <LSM6DSOX::LSM6DSOX()+0x12c>)
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     4fe:	2400      	.short	0x2400
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     500:	f8df a10c 	ldr.w	sl, [pc, #268]	; 610 <LSM6DSOX::LSM6DSOX()+0x130>
#include "lsm6dsox.h"

LSM6DSOX::LSM6DSOX() {
     504:	f846 3b34 	str.w	r3, [r6], #52
     508:	4630      	mov	r0, r6
     50a:	f003 fb0b 	bl	3b24 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()>
     50e:	4638      	mov	r0, r7
     510:	f004 f9d0 	bl	48b4 <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()>
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     514:	f04f 0e00 	mov.w	lr, #0
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     518:	4623      	mov	r3, r4
     51a:	4652      	mov	r2, sl
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     51c:	f8c5 e010 	str.w	lr, [r5, #16]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     520:	4638      	mov	r0, r7

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
     522:	f8c5      	.short	0xf8c5
     524:	e01c      	b.n	560 <LSM6DSOX::LSM6DSOX()+0x80>
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     526:	216a      	movs	r1, #106	; 0x6a
void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
		mag[i] = 0;
     528:	f8c5 e028 	str.w	lr, [r5, #40]	; 0x28
	lis3mdl.setOperationMode(IMU_M_OP_MODE);
	
	lis3mdl.configInterrupt(false, false, false,   // enable z axis
											true,  // polarity
											false, // don't latch
											true); // enabled!
     52c:	f04f 0901 	mov.w	r9, #1
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     530:	f8c5 e014 	str.w	lr, [r5, #20]
		gyro[i] = 0;
     534:	f8c5 e020 	str.w	lr, [r5, #32]
		mag[i] = 0;
     538:	f8c5 e02c 	str.w	lr, [r5, #44]	; 0x2c
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     53c:	f8c5 e018 	str.w	lr, [r5, #24]
		gyro[i] = 0;
     540:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
		mag[i] = 0;
     544:	f8c5 e030 	str.w	lr, [r5, #48]	; 0x30
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     548:	60ec      	str	r4, [r5, #12]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     54a:	f003 ff37 	bl	43bc <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)>
	lsm6dsox.setAccelRange(IMU_A_RANGE);
     54e:	4638      	mov	r0, r7
     550:	2102      	movs	r1, #2
     552:	f003 ff99 	bl	4488 <Adafruit_LSM6DS::setAccelRange(accel_range)>
	lsm6dsox.setGyroRange(IMU_G_RANGE);
     556:	4638      	mov	r0, r7
     558:	2108      	movs	r1, #8
     55a:	f003 ffd5 	bl	4508 <Adafruit_LSM6DS::setGyroRange(gyro_range)>
	lsm6dsox.setAccelDataRate(IMU_A_DATA_RATE);
     55e:	4638      	mov	r0, r7
     560:	2108      	movs	r1, #8
     562:	f003 ff71 	bl	4448 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>
	lsm6dsox.setGyroDataRate(IMU_G_DATA_RATE);
     566:	4638      	mov	r0, r7
     568:	2108      	movs	r1, #8
     56a:	f003 ffaf 	bl	44cc <Adafruit_LSM6DS::setGyroDataRate(data_rate)>
		@param active_low true to set the pins  as active high, false to set the
		mode to active low
		@param open_drain true to set the pin mode as open-drain, false to set the
		mode to push-pull
	*/
	lsm6dsox.configIntOutputs(false, true);
     56e:	4638      	mov	r0, r7
     570:	4621      	mov	r1, r4
     572:	464a      	mov	r2, r9
     574:	f004 f834 	bl	45e0 <Adafruit_LSM6DS::configIntOutputs(bool, bool)>
		@param drdy_g true to output the data ready gyro interrupt
		@param drdy_xl true to output the data ready accelerometer interrupt
		@param step_detect true to output the step detection interrupt (default off)
		@param wakeup true to output the wake up interrupt (default off)
	*/
	lsm6dsox.configInt1(false, false, false, false, false);
     578:	4638      	mov	r0, r7
     57a:	4623      	mov	r3, r4
     57c:	4622      	mov	r2, r4
     57e:	4621      	mov	r1, r4
     580:	9401      	str	r4, [sp, #4]
     582:	9400      	str	r4, [sp, #0]
     584:	f004 f84e 	bl	4624 <Adafruit_LSM6DS::configInt1(bool, bool, bool, bool, bool)>
		@brief Enables and disables the data ready interrupt on INT 2.
		@param drdy_temp true to output the data ready temperature interrupt
		@param drdy_g true to output the data ready gyro interrupt
		@param drdy_xl true to output the data ready accelerometer interrupt
	*/
	lsm6dsox.configInt2(false, false, false);
     588:	4623      	mov	r3, r4
     58a:	4622      	mov	r2, r4
     58c:	4621      	mov	r1, r4
     58e:	4638      	mov	r0, r7
     590:	f004 f886 	bl	46a0 <Adafruit_LSM6DS::configInt2(bool, bool, bool)>

	// LIS3MDL Setup
	lis3mdl.begin_I2C();
     594:	4652      	mov	r2, sl
     596:	4630      	mov	r0, r6
     598:	211c      	movs	r1, #28
     59a:	f003 fc63 	bl	3e64 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)>
	lis3mdl.setRange(IMU_M_RANGE);
     59e:	4630      	mov	r0, r6
     5a0:	4649      	mov	r1, r9
     5a2:	f003 fbd5 	bl	3d50 <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>
	lis3mdl.setDataRate(IMU_M_DATA_RATE);
     5a6:	4630      	mov	r0, r6
     5a8:	2107      	movs	r1, #7
     5aa:	f003 fb7d 	bl	3ca8 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>
	lis3mdl.setPerformanceMode(IMU_M_PERFORMANCE);
     5ae:	4630      	mov	r0, r6
     5b0:	2103      	movs	r1, #3
     5b2:	f003 fb43 	bl	3c3c <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
	lis3mdl.setOperationMode(IMU_M_OP_MODE);
     5b6:	4621      	mov	r1, r4
     5b8:	4630      	mov	r0, r6
     5ba:	f003 fbad 	bl	3d18 <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>
	
	lis3mdl.configInterrupt(false, false, false,   // enable z axis
											true,  // polarity
											false, // don't latch
											true); // enabled!
     5be:	4622      	mov	r2, r4
     5c0:	4623      	mov	r3, r4
     5c2:	4630      	mov	r0, r6
     5c4:	4621      	mov	r1, r4
     5c6:	9401      	str	r4, [sp, #4]
     5c8:	f8cd 9008 	str.w	r9, [sp, #8]
     5cc:	f8cd 9000 	str.w	r9, [sp]
     5d0:	f003 fc68 	bl	3ea4 <Adafruit_LIS3MDL::configInterrupt(bool, bool, bool, bool, bool, bool)>

	dimensions.reset(PROCESS_DIMENSIONS);
     5d4:	4640      	mov	r0, r8
     5d6:	2103      	movs	r1, #3
     5d8:	f000 fdd6 	bl	1188 <Vector<int>::reset(int)>
	dimensions[INPUT_DIMENSION] = 0;
     5dc:	4621      	mov	r1, r4
     5de:	4640      	mov	r0, r8
     5e0:	f000 fe2c 	bl	123c <Vector<int>::operator[](int)>
     5e4:	4603      	mov	r3, r0
	dimensions[CONTEXT_DIMENSION] = 1;
     5e6:	4649      	mov	r1, r9
     5e8:	4640      	mov	r0, r8
											true,  // polarity
											false, // don't latch
											true); // enabled!

	dimensions.reset(PROCESS_DIMENSIONS);
	dimensions[INPUT_DIMENSION] = 0;
     5ea:	601c      	str	r4, [r3, #0]
	dimensions[CONTEXT_DIMENSION] = 1;
     5ec:	f000 fe26 	bl	123c <Vector<int>::operator[](int)>
	dimensions[OUTPUT_DIMENSION] = LSM6DSOX_DOF;
     5f0:	2102      	movs	r1, #2
											false, // don't latch
											true); // enabled!

	dimensions.reset(PROCESS_DIMENSIONS);
	dimensions[INPUT_DIMENSION] = 0;
	dimensions[CONTEXT_DIMENSION] = 1;
     5f2:	f8c0 9000 	str.w	r9, [r0]
	dimensions[OUTPUT_DIMENSION] = LSM6DSOX_DOF;
     5f6:	4640      	mov	r0, r8
     5f8:	f000 fe20 	bl	123c <Vector<int>::operator[](int)>
     5fc:	2309      	movs	r3, #9
     5fe:	6003      	str	r3, [r0, #0]
}
     600:	4628      	mov	r0, r5
     602:	b004      	add	sp, #16
     604:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     608:	20000548 	.word	0x20000548
     60c:	20000598 	.word	0x20000598
     610:	20001484 	.word	0x20001484

00000614 <GraphNode::GraphNode(Process*, int, int, int*)>:
	inputs.reset(0);
	output_buffer.reset(0);
	config_buffer.reset(0);
}

GraphNode::GraphNode(Process* p, int configs, int n_inputs, int* input_ids) {
     614:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     618:	f100 0808 	add.w	r8, r0, #8
     61c:	f100 0610 	add.w	r6, r0, #16
     620:	4604      	mov	r4, r0
     622:	f100 0718 	add.w	r7, r0, #24
     626:	4640      	mov	r0, r8
     628:	460d      	mov	r5, r1
     62a:	4692      	mov	sl, r2
     62c:	4699      	mov	r9, r3
     62e:	f000 fd99 	bl	1164 <Vector<int>::Vector()>
     632:	4630      	mov	r0, r6
     634:	f000 fe10 	bl	1258 <Vector<float>::Vector()>
     638:	4638      	mov	r0, r7
     63a:	f000 fe0d 	bl	1258 <Vector<float>::Vector()>
     63e:	f104 0020 	add.w	r0, r4, #32
     642:	f000 fe09 	bl	1258 <Vector<float>::Vector()>
			n_inputs: (int) number of input nodes
			input_ids: (int*) the identifiers of input nodes (in order of concatenation),
				does not specify the process index but a unique process id associated with each process
	*/
	proc = p;
	proc->reset();
     646:	682b      	ldr	r3, [r5, #0]
     648:	4628      	mov	r0, r5
			configs: (int) number of config values, size of buffer (always floats)
			n_inputs: (int) number of input nodes
			input_ids: (int*) the identifiers of input nodes (in order of concatenation),
				does not specify the process index but a unique process id associated with each process
	*/
	proc = p;
     64a:	6065      	str	r5, [r4, #4]
	proc->reset();
     64c:	68db      	ldr	r3, [r3, #12]
     64e:	4798      	blx	r3
	config_shape = configs;

	inputs.from_array(input_ids, n_inputs);
     650:	464a      	mov	r2, r9
     652:	4640      	mov	r0, r8
     654:	9908      	ldr	r1, [sp, #32]
			input_ids: (int*) the identifiers of input nodes (in order of concatenation),
				does not specify the process index but a unique process id associated with each process
	*/
	proc = p;
	proc->reset();
	config_shape = configs;
     656:	f8c4 a000 	str.w	sl, [r4]

	inputs.from_array(input_ids, n_inputs);
     65a:	f000 fdab 	bl	11b4 <Vector<int>::from_array(int*, int)>

	config_buffer.reset(0);
     65e:	4638      	mov	r0, r7
     660:	2100      	movs	r1, #0
     662:	f000 fe1d 	bl	12a0 <Vector<float>::reset(int)>
	output_buffer.reset(proc->output_dim());
     666:	6860      	ldr	r0, [r4, #4]
     668:	6803      	ldr	r3, [r0, #0]
     66a:	689b      	ldr	r3, [r3, #8]
     66c:	4798      	blx	r3
     66e:	4601      	mov	r1, r0
     670:	4630      	mov	r0, r6
     672:	f000 fe15 	bl	12a0 <Vector<float>::reset(int)>
}
     676:	4620      	mov	r0, r4
     678:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000067c <GraphNode::set_config(int)>:

void GraphNode::set_config(int configs) {
	config_shape = configs;
     67c:	f840 1b18 	str.w	r1, [r0], #24
	config_buffer.reset(0);
     680:	2100      	movs	r1, #0
     682:	f000 be0d 	b.w	12a0 <Vector<float>::reset(int)>
     686:	bf00      	nop

00000688 <GraphNode::n_inputs()>:
void GraphNode::set_inputs(Vector<int> input_ids) {
	inputs = input_ids;
}

int GraphNode::n_inputs() {
	return inputs.size();
     688:	3008      	adds	r0, #8
     68a:	f000 bdbf 	b.w	120c <Vector<int>::size()>
     68e:	bf00      	nop

00000690 <GraphNode::setup_proc()>:

void GraphNode::set_process(Process* process) {
	proc = process;
}

bool GraphNode::setup_proc() {
     690:	b570      	push	{r4, r5, r6, lr}
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     692:	4604      	mov	r4, r0

void GraphNode::set_process(Process* process) {
	proc = process;
}

bool GraphNode::setup_proc() {
     694:	4605      	mov	r5, r0
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     696:	f854 6b18 	ldr.w	r6, [r4], #24
     69a:	4620      	mov	r0, r4
     69c:	f000 fe46 	bl	132c <Vector<float>::size()>
		Call the processes setup function with the config buffer
		Does nothing when not configured.
		@return
			status: (bool) if setup was called.
	*/
	if (is_configured()) {
     6a0:	4286      	cmp	r6, r0
     6a2:	d001      	beq.n	6a8 <GraphNode::setup_proc()+0x18>
		proc->setup(&config_buffer);
		return true;		
	}
	return false;
     6a4:	2000      	movs	r0, #0
}
     6a6:	bd70      	pop	{r4, r5, r6, pc}
		Does nothing when not configured.
		@return
			status: (bool) if setup was called.
	*/
	if (is_configured()) {
		proc->setup(&config_buffer);
     6a8:	6868      	ldr	r0, [r5, #4]
     6aa:	4621      	mov	r1, r4
     6ac:	6803      	ldr	r3, [r0, #0]
     6ae:	699b      	ldr	r3, [r3, #24]
     6b0:	4798      	blx	r3
		return true;		
     6b2:	2001      	movs	r0, #1
     6b4:	bd70      	pop	{r4, r5, r6, pc}
     6b6:	bf00      	nop

000006b8 <GraphNode::run_proc(Vector<float>*)>:
	}
	return false;
}

bool GraphNode::run_proc(Vector<float>* input_buffer) {
     6b8:	b570      	push	{r4, r5, r6, lr}
     6ba:	4604      	mov	r4, r0
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     6bc:	f850 5b18 	ldr.w	r5, [r0], #24
		return true;		
	}
	return false;
}

bool GraphNode::run_proc(Vector<float>* input_buffer) {
     6c0:	460e      	mov	r6, r1
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     6c2:	f000 fe33 	bl	132c <Vector<float>::size()>
			input_buffer: (Vector<float>*) concatenated outputs of processes
				listed in input_ids
		@return
			status: (bool) if run was called.
	*/
	if (is_configured() && input_buffer->size() == proc->input_dim()) {
     6c6:	4285      	cmp	r5, r0
     6c8:	d001      	beq.n	6ce <GraphNode::run_proc(Vector<float>*)+0x16>
		proc->run(input_buffer, &output_buffer);
		return true;		
	}
	return false;
     6ca:	2000      	movs	r0, #0
     6cc:	bd70      	pop	{r4, r5, r6, pc}
			input_buffer: (Vector<float>*) concatenated outputs of processes
				listed in input_ids
		@return
			status: (bool) if run was called.
	*/
	if (is_configured() && input_buffer->size() == proc->input_dim()) {
     6ce:	4630      	mov	r0, r6
     6d0:	f000 fe2c 	bl	132c <Vector<float>::size()>
     6d4:	4605      	mov	r5, r0
     6d6:	6860      	ldr	r0, [r4, #4]
     6d8:	6803      	ldr	r3, [r0, #0]
     6da:	681b      	ldr	r3, [r3, #0]
     6dc:	4798      	blx	r3
     6de:	4285      	cmp	r5, r0
     6e0:	d1f3      	bne.n	6ca <GraphNode::run_proc(Vector<float>*)+0x12>
		proc->run(input_buffer, &output_buffer);
     6e2:	6860      	ldr	r0, [r4, #4]
     6e4:	4631      	mov	r1, r6
     6e6:	f104 0210 	add.w	r2, r4, #16
     6ea:	6803      	ldr	r3, [r0, #0]
     6ec:	6a1b      	ldr	r3, [r3, #32]
     6ee:	4798      	blx	r3
		return true;		
     6f0:	2001      	movs	r0, #1
	}
	return false;
}
     6f2:	bd70      	pop	{r4, r5, r6, pc}

000006f4 <GraphNode::output()>:
		Get a pointer to the output buffer
		@return
			output: (Vector<float>*) buffer of output data
	*/
	return &output_buffer;
}
     6f4:	3010      	adds	r0, #16
     6f6:	4770      	bx	lr

000006f8 <GraphNode::config()>:
		Get a pointer to the setup buffer
		@return
			config: (Vector<float>*) buffer of setup data
	*/
	return &config_buffer;
}
     6f8:	3018      	adds	r0, #24
     6fa:	4770      	bx	lr

000006fc <GraphNode::input_id(int)>:
	*/
	proc->context(&context_buffer);
	return &context_buffer;
}

int GraphNode::input_id(int index) {
     6fc:	b508      	push	{r3, lr}
	/*
		Get an id at index from the input id list
		@return
			id: (int) id of input at index
	*/
	return inputs[index];
     6fe:	3008      	adds	r0, #8
     700:	f000 fd9c 	bl	123c <Vector<int>::operator[](int)>
}
     704:	6800      	ldr	r0, [r0, #0]
     706:	bd08      	pop	{r3, pc}

00000708 <GraphNode::is_configured()>:

bool GraphNode::is_configured() {
     708:	b510      	push	{r4, lr}
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     70a:	f850 4b18 	ldr.w	r4, [r0], #24
     70e:	f000 fe0d 	bl	132c <Vector<float>::size()>
}
     712:	1a20      	subs	r0, r4, r0
     714:	fab0 f080 	clz	r0, r0
     718:	0940      	lsrs	r0, r0, #5
     71a:	bd10      	pop	{r4, pc}

0000071c <GraphNode::print_proc()>:

void GraphNode::print_proc() {
	proc->print();
     71c:	6840      	ldr	r0, [r0, #4]
     71e:	6803      	ldr	r3, [r0, #0]
     720:	695b      	ldr	r3, [r3, #20]
     722:	4718      	bx	r3

00000724 <GraphNode::print_output()>:
}

void GraphNode::print_output() {
     724:	b510      	push	{r4, lr}
     726:	4604      	mov	r4, r0
     728:	2101      	movs	r1, #1
     72a:	4804      	ldr	r0, [pc, #16]	; (73c <GraphNode::print_output()+0x18>)
     72c:	f002 fb90 	bl	2e50 <usb_seremu_write>
	Serial.print("\t");
	output_buffer.print();
     730:	f104 0010 	add.w	r0, r4, #16
}
     734:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	proc->print();
}

void GraphNode::print_output() {
	Serial.print("\t");
	output_buffer.print();
     738:	f000 bcd8 	b.w	10ec <Vector<float>::print()>
     73c:	20000bfc 	.word	0x20000bfc

00000740 <Process::input_dim()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Print");
}

int Process::input_dim() {
     740:	b508      	push	{r3, lr}
		Base implementation of process functions.
		returns dimensions of the input.
		@return
			dimension: (int) size of input
	*/
	return dimensions[0];
     742:	2100      	movs	r1, #0
     744:	3004      	adds	r0, #4
     746:	f000 fd79 	bl	123c <Vector<int>::operator[](int)>
}
     74a:	6800      	ldr	r0, [r0, #0]
     74c:	bd08      	pop	{r3, pc}
     74e:	bf00      	nop

00000750 <Process::context_dim()>:

int Process::context_dim() {
     750:	b508      	push	{r3, lr}
		Base implementation of process functions.
		returns dimensions of the context.
		@return
			dimension: (int) size of input
	*/
	return dimensions[1];
     752:	2101      	movs	r1, #1
     754:	3004      	adds	r0, #4
     756:	f000 fd71 	bl	123c <Vector<int>::operator[](int)>
}
     75a:	6800      	ldr	r0, [r0, #0]
     75c:	bd08      	pop	{r3, pc}
     75e:	bf00      	nop

00000760 <Process::output_dim()>:

int Process::output_dim() {
     760:	b508      	push	{r3, lr}
		Base implementation of process functions.
		returns dimensions of the output.
		@return
			dimension: (int) size of input
	*/
	return dimensions[2];
     762:	2102      	movs	r1, #2
     764:	3004      	adds	r0, #4
     766:	f000 fd69 	bl	123c <Vector<int>::operator[](int)>
}
     76a:	6800      	ldr	r0, [r0, #0]
     76c:	bd08      	pop	{r3, pc}
     76e:	bf00      	nop

00000770 <Process::reset()>:
#include "system_graph/process.h"

// Drivers
#include "sensors/lsm6dsox.h"

void Process::reset() {
     770:	b508      	push	{r3, lr}
     772:	2109      	movs	r1, #9
     774:	4803      	ldr	r0, [pc, #12]	; (784 <Process::reset()+0x14>)
     776:	f002 fb6b 	bl	2e50 <usb_seremu_write>
     77a:	4803      	ldr	r0, [pc, #12]	; (788 <Process::reset()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Reset");
}
     77c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     780:	f002 bc1c 	b.w	2fbc <Print::println()>
     784:	20000c00 	.word	0x20000c00
     788:	20001474 	.word	0x20001474

0000078c <Process::print()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Clear");
}

void Process::print() {
     78c:	b508      	push	{r3, lr}
     78e:	2109      	movs	r1, #9
     790:	4803      	ldr	r0, [pc, #12]	; (7a0 <Process::print()+0x14>)
     792:	f002 fb5d 	bl	2e50 <usb_seremu_write>
     796:	4803      	ldr	r0, [pc, #12]	; (7a4 <Process::print()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Print");
}
     798:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     79c:	f002 bc0e 	b.w	2fbc <Print::println()>
     7a0:	20000c0c 	.word	0x20000c0c
     7a4:	20001474 	.word	0x20001474

000007a8 <Process::clear()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Reset");
}

void Process::clear() {
     7a8:	b508      	push	{r3, lr}
     7aa:	2109      	movs	r1, #9
     7ac:	4803      	ldr	r0, [pc, #12]	; (7bc <Process::clear()+0x14>)
     7ae:	f002 fb4f 	bl	2e50 <usb_seremu_write>
     7b2:	4803      	ldr	r0, [pc, #12]	; (7c0 <Process::clear()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Clear");
}
     7b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     7b8:	f002 bc00 	b.w	2fbc <Print::println()>
     7bc:	20000c18 	.word	0x20000c18
     7c0:	20001474 	.word	0x20001474

000007c4 <Process::setup(Vector<float>*)>:
			dimension: (int) size of input
	*/
	return dimensions[2];
}

void Process::setup(Vector<float>* config) {
     7c4:	b510      	push	{r4, lr}
     7c6:	4806      	ldr	r0, [pc, #24]	; (7e0 <Process::setup(Vector<float>*)+0x1c>)
     7c8:	460c      	mov	r4, r1
     7ca:	2109      	movs	r1, #9
     7cc:	f002 fb40 	bl	2e50 <usb_seremu_write>
     7d0:	4804      	ldr	r0, [pc, #16]	; (7e4 <Process::setup(Vector<float>*)+0x20>)
     7d2:	f002 fbf3 	bl	2fbc <Print::println()>
		@param
			config: (Vector<float>) Vector of configuration data, 
				organization is handled by user
	*/
	Serial.println("PBO Setup");
	config->print();
     7d6:	4620      	mov	r0, r4
}
     7d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		@param
			config: (Vector<float>) Vector of configuration data, 
				organization is handled by user
	*/
	Serial.println("PBO Setup");
	config->print();
     7dc:	f000 bc86 	b.w	10ec <Vector<float>::print()>
     7e0:	20000c24 	.word	0x20000c24
     7e4:	20001474 	.word	0x20001474

000007e8 <Process::context(Vector<float>*)>:
}

void Process::context(Vector<float>* context) {
     7e8:	b510      	push	{r4, lr}
     7ea:	4807      	ldr	r0, [pc, #28]	; (808 <Process::context(Vector<float>*)+0x20>)
     7ec:	460c      	mov	r4, r1
     7ee:	2115      	movs	r1, #21
     7f0:	f002 fb2e 	bl	2e50 <usb_seremu_write>
     7f4:	4805      	ldr	r0, [pc, #20]	; (80c <Process::context(Vector<float>*)+0x24>)
     7f6:	f002 fbe1 	bl	2fbc <Print::println()>
		Only defined to show user when inheritance has issues.
		@param
			context: (Vector<float>*) empty vector to fill with the context
	*/
	Serial.println("Requested PBO context");
	context->reset(0);
     7fa:	4620      	mov	r0, r4
     7fc:	2100      	movs	r1, #0
}
     7fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		Only defined to show user when inheritance has issues.
		@param
			context: (Vector<float>*) empty vector to fill with the context
	*/
	Serial.println("Requested PBO context");
	context->reset(0);
     802:	f000 bd4d 	b.w	12a0 <Vector<float>::reset(int)>
     806:	bf00      	nop
     808:	20000c30 	.word	0x20000c30
     80c:	20001474 	.word	0x20001474

00000810 <Process::run(Vector<float>*, Vector<float>*)>:
}

void Process::run(Vector<float>* input, Vector<float>* output) {
     810:	b510      	push	{r4, lr}
     812:	2107      	movs	r1, #7
     814:	4614      	mov	r4, r2
     816:	4806      	ldr	r0, [pc, #24]	; (830 <Process::run(Vector<float>*, Vector<float>*)+0x20>)
     818:	f002 fb1a 	bl	2e50 <usb_seremu_write>
     81c:	4805      	ldr	r0, [pc, #20]	; (834 <Process::run(Vector<float>*, Vector<float>*)+0x24>)
     81e:	f002 fbcd 	bl	2fbc <Print::println()>
		@param
			input: (Vector<float>*) flattened Vector of input data for process
			output: (Vector<float>*) flattened Vector of output data from process
	*/
	Serial.println("PBO Run");
	output->reset(0);
     822:	4620      	mov	r0, r4
     824:	2100      	movs	r1, #0
}
     826:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		@param
			input: (Vector<float>*) flattened Vector of input data for process
			output: (Vector<float>*) flattened Vector of output data from process
	*/
	Serial.println("PBO Run");
	output->reset(0);
     82a:	f000 bd39 	b.w	12a0 <Vector<float>::reset(int)>
     82e:	bf00      	nop
     830:	20000c48 	.word	0x20000c48
     834:	20001474 	.word	0x20001474

00000838 <ComplimentaryFilter::clear()>:
			K = DEFAULT_GAIN;
			clear();
		}

		void clear() {
			axz_norm = 0;
     838:	2300      	movs	r3, #0
     83a:	6343      	str	r3, [r0, #52]	; 0x34
			ayz_norm = 0;
     83c:	6383      	str	r3, [r0, #56]	; 0x38
			mag_norm = 0;
     83e:	63c3      	str	r3, [r0, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     840:	6443      	str	r3, [r0, #68]	; 0x44
				q_accel[i] = 0;
     842:	6503      	str	r3, [r0, #80]	; 0x50
				bias_accel[i] = 0;
     844:	65c3      	str	r3, [r0, #92]	; 0x5c
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     846:	6483      	str	r3, [r0, #72]	; 0x48
				q_accel[i] = 0;
     848:	6543      	str	r3, [r0, #84]	; 0x54
				bias_accel[i] = 0;
     84a:	6603      	str	r3, [r0, #96]	; 0x60
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     84c:	64c3      	str	r3, [r0, #76]	; 0x4c
				q_accel[i] = 0;
     84e:	6583      	str	r3, [r0, #88]	; 0x58
				bias_accel[i] = 0;
     850:	6643      	str	r3, [r0, #100]	; 0x64
     852:	4770      	bx	lr

00000854 <ComplimentaryFilter::run(Vector<float>*, Vector<float>*)>:
			}
		}

		void run(Vector<float>* inputs, Vector<float>* outputs) {
     854:	b5f0      	push	{r4, r5, r6, r7, lr}
			float dt = watches.micros(0);
     856:	f100 060c 	add.w	r6, r0, #12
				q_accel[i] = 0;
				bias_accel[i] = 0;
			}
		}

		void run(Vector<float>* inputs, Vector<float>* outputs) {
     85a:	4604      	mov	r4, r0
     85c:	460d      	mov	r5, r1
			float dt = watches.micros(0);
     85e:	2100      	movs	r1, #0
     860:	4630      	mov	r0, r6
				q_accel[i] = 0;
				bias_accel[i] = 0;
			}
		}

		void run(Vector<float>* inputs, Vector<float>* outputs) {
     862:	4617      	mov	r7, r2
     864:	ed2d 8b0e 	vpush	{d8-d14}
     868:	b091      	sub	sp, #68	; 0x44
			float dt = watches.micros(0);
     86a:	f000 fb51 	bl	f10 <FTYK::micros(int)>
			watches.set(0);
     86e:	4630      	mov	r0, r6
     870:	2100      	movs	r1, #0
				bias_accel[i] = 0;
			}
		}

		void run(Vector<float>* inputs, Vector<float>* outputs) {
			float dt = watches.micros(0);
     872:	eeb0 ea40 	vmov.f32	s28, s0
			watches.set(0);
     876:	f000 fb41 	bl	efc <FTYK::set(int)>
			float estimate[ATTITUDE_DIM];
			float accel[ATTITUDE_DIM];
			float gyro[ATTITUDE_DIM];
			float mag[ATTITUDE_DIM];
			inputs->slice(estimate, 0, 3);
     87a:	4628      	mov	r0, r5
     87c:	a904      	add	r1, sp, #16
     87e:	2303      	movs	r3, #3
     880:	2200      	movs	r2, #0
     882:	f000 fda7 	bl	13d4 <Vector<float>::slice(float*, int, int)>
			inputs->slice(accel, 3, 6);
     886:	4628      	mov	r0, r5
     888:	2306      	movs	r3, #6
     88a:	2203      	movs	r2, #3
     88c:	a907      	add	r1, sp, #28
     88e:	f000 fda1 	bl	13d4 <Vector<float>::slice(float*, int, int)>
			inputs->slice(gyro, 6, 9);
     892:	4628      	mov	r0, r5
     894:	a90a      	add	r1, sp, #40	; 0x28
     896:	2309      	movs	r3, #9
     898:	2206      	movs	r2, #6
     89a:	f000 fd9b 	bl	13d4 <Vector<float>::slice(float*, int, int)>
			inputs->slice(mag, 9, 12);
     89e:	4628      	mov	r0, r5
     8a0:	a90d      	add	r1, sp, #52	; 0x34
     8a2:	230c      	movs	r3, #12
     8a4:	2209      	movs	r2, #9
     8a6:	f000 fd95 	bl	13d4 <Vector<float>::slice(float*, int, int)>
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
     8aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
			float ayz[2] = {accel[1], accel[2]};
     8ac:	9a08      	ldr	r2, [sp, #32]
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     8ae:	2102      	movs	r1, #2
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
     8b0:	9d07      	ldr	r5, [sp, #28]
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     8b2:	4668      	mov	r0, sp
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
     8b4:	9301      	str	r3, [sp, #4]
			float ayz[2] = {accel[1], accel[2]};
     8b6:	9303      	str	r3, [sp, #12]
     8b8:	9202      	str	r2, [sp, #8]
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
     8ba:	9500      	str	r5, [sp, #0]
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     8bc:	f7ff fcd8 	bl	270 <nd_norm(float*, int)>
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     8c0:	2102      	movs	r1, #2
     8c2:	a802      	add	r0, sp, #8
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     8c4:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     8c8:	f7ff fcd2 	bl	270 <nd_norm(float*, int)>
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     8cc:	a80d      	add	r0, sp, #52	; 0x34
     8ce:	2103      	movs	r1, #3

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     8d0:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     8d4:	f7ff fccc 	bl	270 <nd_norm(float*, int)>

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     8d8:	eddd 7a08 	vldr	s15, [sp, #32]
     8dc:	ed94 1a0d 	vldr	s2, [r4, #52]	; 0x34
		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     8e0:	ed84 0a0f 	vstr	s0, [r4, #60]	; 0x3c

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     8e4:	eeb7 0ae7 	vcvt.f64.f32	d0, s15
     8e8:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
     8ec:	f004 fb78 	bl	4fe0 <atan2>
			q_accel[1] = atan2(-accel[0], ayz_norm);
     8f0:	eddd 7a07 	vldr	s15, [sp, #28]
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     8f4:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
			q_accel[1] = atan2(-accel[0], ayz_norm);
     8f8:	ed94 1a0e 	vldr	s2, [r4, #56]	; 0x38
     8fc:	eef1 7a67 	vneg.f32	s15, s15
     900:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     904:	ed84 0a14 	vstr	s0, [r4, #80]	; 0x50
			q_accel[1] = atan2(-accel[0], ayz_norm);
     908:	eeb7 0ae7 	vcvt.f64.f32	d0, s15
     90c:	f004 fb68 	bl	4fe0 <atan2>

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     910:	ed94 8a14 	vldr	s16, [r4, #80]	; 0x50
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
			q_accel[1] = atan2(-accel[0], ayz_norm);
     914:	eeb7 0bc0 	vcvt.f32.f64	s0, d0

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     918:	ed9d ba0f 	vldr	s22, [sp, #60]	; 0x3c
     91c:	eeb7 8ac8 	vcvt.f64.f32	d8, s16
     920:	eeb7 bacb 	vcvt.f64.f32	d11, s22
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;
     924:	eeb7 9ac0 	vcvt.f64.f32	d9, s0
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
			q_accel[1] = atan2(-accel[0], ayz_norm);
     928:	ed84 0a15 	vstr	s0, [r4, #84]	; 0x54

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     92c:	eeb0 0b48 	vmov.f64	d0, d8
     930:	f004 fb06 	bl	4f40 <sin>
     934:	eeb0 db40 	vmov.f64	d13, d0
     938:	eeb0 0b48 	vmov.f64	d0, d8
     93c:	f004 fab0 	bl	4ea0 <cos>
     940:	ed9d 8a0e 	vldr	s16, [sp, #56]	; 0x38
     944:	ed94 aa0f 	vldr	s20, [r4, #60]	; 0x3c
     948:	eeb7 8ac8 	vcvt.f64.f32	d8, s16
     94c:	eeb7 aaca 	vcvt.f64.f32	d10, s20
     950:	ee28 8b00 	vmul.f64	d8, d8, d0
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;
     954:	eeb0 0b49 	vmov.f64	d0, d9
     958:	f004 faa2 	bl	4ea0 <cos>
     95c:	eeb0 cb40 	vmov.f64	d12, d0
     960:	eeb0 0b49 	vmov.f64	d0, d9
     964:	f004 faec 	bl	4f40 <sin>

			q_accel[2] = atan2(opposite, adjacent);
     968:	ee28 0b00 	vmul.f64	d0, d8, d0
     96c:	ed9d 6a0d 	vldr	s12, [sp, #52]	; 0x34
     970:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     974:	ee9b 8b0d 	vfnms.f64	d8, d11, d13
     978:	eeab 0b0d 	vfma.f64	d0, d11, d13
     97c:	ee88 7b0a 	vdiv.f64	d7, d8, d10
     980:	eea6 0b0c 	vfma.f64	d0, d6, d12
     984:	ee80 1b0a 	vdiv.f64	d1, d0, d10
     988:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
     98c:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
     990:	eeb7 1bc1 	vcvt.f32.f64	s2, d1
     994:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
     998:	f004 fb22 	bl	4fe0 <atan2>
     99c:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
			if (isnan(q_accel[2])) {
     9a0:	eeb4 0a40 	vcmp.f32	s0, s0
			q_accel[1] = atan2(-accel[0], ayz_norm);

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;

			q_accel[2] = atan2(opposite, adjacent);
     9a4:	ed84 0a16 	vstr	s0, [r4, #88]	; 0x58
			if (isnan(q_accel[2])) {
     9a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     9ac:	d625      	bvs.n	9fa <ComplimentaryFilter::run(Vector<float>*, Vector<float>*)+0x1a6>
				q_accel[2] = 0;
			}

			// integrate gyro measurements over time
			weighted_vector_addition(estimate, gyro, 1, dt, 3, q_gyro);
     9ae:	f104 0544 	add.w	r5, r4, #68	; 0x44
     9b2:	eef0 0a4e 	vmov.f32	s1, s28
     9b6:	a90a      	add	r1, sp, #40	; 0x28
     9b8:	a804      	add	r0, sp, #16
     9ba:	462b      	mov	r3, r5
     9bc:	2203      	movs	r2, #3
     9be:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
     9c2:	f7ff fc7f 	bl	2c4 <weighted_vector_addition(float*, float*, float, float, int, float*)>

			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
     9c6:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
     9ca:	ed94 0a10 	vldr	s0, [r4, #64]	; 0x40
     9ce:	ab04      	add	r3, sp, #16
     9d0:	4629      	mov	r1, r5
     9d2:	2203      	movs	r2, #3
     9d4:	ee70 0ac0 	vsub.f32	s1, s1, s0
     9d8:	f104 0050 	add.w	r0, r4, #80	; 0x50
     9dc:	f7ff fc72 	bl	2c4 <weighted_vector_addition(float*, float*, float, float, int, float*)>
			inputs->slice(gyro, 6, 9);
			inputs->slice(mag, 9, 12);
			
			filter(accel, gyro, mag, dt, estimate);

			outputs->from_array(estimate, dimensions[OUTPUT_DIMENSION]);
     9e0:	1d20      	adds	r0, r4, #4
     9e2:	2102      	movs	r1, #2
     9e4:	f000 fc2a 	bl	123c <Vector<int>::operator[](int)>
     9e8:	a904      	add	r1, sp, #16
     9ea:	6802      	ldr	r2, [r0, #0]
     9ec:	4638      	mov	r0, r7
     9ee:	f000 fc6d 	bl	12cc <Vector<float>::from_array(float*, int)>
		}
     9f2:	b011      	add	sp, #68	; 0x44
     9f4:	ecbd 8b0e 	vpop	{d8-d14}
     9f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;

			q_accel[2] = atan2(opposite, adjacent);
			if (isnan(q_accel[2])) {
				q_accel[2] = 0;
     9fa:	2300      	movs	r3, #0
     9fc:	65a3      	str	r3, [r4, #88]	; 0x58
     9fe:	e7d6      	b.n	9ae <ComplimentaryFilter::run(Vector<float>*, Vector<float>*)+0x15a>

00000a00 <ComplimentaryFilter::context(Vector<float>*)>:
				q_accel[i] = 0;
				q_gyro[i] = 0;
			}
		}

		void context(Vector<float>* context) {
     a00:	b570      	push	{r4, r5, r6, lr}
     a02:	460c      	mov	r4, r1
     a04:	4605      	mov	r5, r0
			context->reset(dimensions[CONTEXT_DIMENSION]);
     a06:	2101      	movs	r1, #1
     a08:	3004      	adds	r0, #4
     a0a:	f000 fc17 	bl	123c <Vector<int>::operator[](int)>
     a0e:	6801      	ldr	r1, [r0, #0]
     a10:	4620      	mov	r0, r4
     a12:	f000 fc45 	bl	12a0 <Vector<float>::reset(int)>
			context->insert(q_gyro, 0, ATTITUDE_DIM);
     a16:	f105 0144 	add.w	r1, r5, #68	; 0x44
     a1a:	4620      	mov	r0, r4
     a1c:	2303      	movs	r3, #3
     a1e:	2200      	movs	r2, #0
     a20:	f000 fcb2 	bl	1388 <Vector<float>::insert(float*, int, int)>
			context->insert(q_accel, 3, ATTITUDE_DIM);
     a24:	2303      	movs	r3, #3
     a26:	f105 0150 	add.w	r1, r5, #80	; 0x50
     a2a:	4620      	mov	r0, r4
     a2c:	461a      	mov	r2, r3
		}
     a2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		}

		void context(Vector<float>* context) {
			context->reset(dimensions[CONTEXT_DIMENSION]);
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
     a32:	f000 bca9 	b.w	1388 <Vector<float>::insert(float*, int, int)>
     a36:	bf00      	nop

00000a38 <ComplimentaryFilter::setup(Vector<float>*)>:
			watches.set(0);
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
     a38:	460b      	mov	r3, r1
			K = (*config)[0];
     a3a:	2100      	movs	r1, #0
			watches.set(0);
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
     a3c:	b510      	push	{r4, lr}
     a3e:	4604      	mov	r4, r0
			K = (*config)[0];
     a40:	4618      	mov	r0, r3
     a42:	f000 fcdd 	bl	1400 <Vector<float>::operator[](int)>
     a46:	6803      	ldr	r3, [r0, #0]
			watches.set(0);
     a48:	2100      	movs	r1, #0
     a4a:	f104 000c 	add.w	r0, r4, #12
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
			K = (*config)[0];
     a4e:	6423      	str	r3, [r4, #64]	; 0x40
			watches.set(0);
     a50:	f000 fa54 	bl	efc <FTYK::set(int)>
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     a54:	2300      	movs	r3, #0
     a56:	6523      	str	r3, [r4, #80]	; 0x50
				q_gyro[i] = 0;
     a58:	6463      	str	r3, [r4, #68]	; 0x44

		void setup(Vector<float>* config) {
			K = (*config)[0];
			watches.set(0);
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     a5a:	6563      	str	r3, [r4, #84]	; 0x54
				q_gyro[i] = 0;
     a5c:	64a3      	str	r3, [r4, #72]	; 0x48

		void setup(Vector<float>* config) {
			K = (*config)[0];
			watches.set(0);
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     a5e:	65a3      	str	r3, [r4, #88]	; 0x58
				q_gyro[i] = 0;
     a60:	64e3      	str	r3, [r4, #76]	; 0x4c
     a62:	bd10      	pop	{r4, pc}

00000a64 <ComplimentaryFilter::print()>:
			filter(accel, gyro, mag, dt, estimate);

			outputs->from_array(estimate, dimensions[OUTPUT_DIMENSION]);
		}

		void print() {
     a64:	b530      	push	{r4, r5, lr}
     a66:	4d21      	ldr	r5, [pc, #132]	; (aec <ComplimentaryFilter::print()+0x88>)
     a68:	b085      	sub	sp, #20
     a6a:	4604      	mov	r4, r0
     a6c:	2113      	movs	r1, #19
     a6e:	4820      	ldr	r0, [pc, #128]	; (af0 <ComplimentaryFilter::print()+0x8c>)
     a70:	f002 f9ee 	bl	2e50 <usb_seremu_write>
     a74:	4628      	mov	r0, r5
     a76:	f002 faa1 	bl	2fbc <Print::println()>
			Serial.println("ComplimentaryFilter");
			Serial.printf("\tgain: [%f]\n", K);
     a7a:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
     a7e:	4628      	mov	r0, r5
     a80:	491c      	ldr	r1, [pc, #112]	; (af4 <ComplimentaryFilter::print()+0x90>)
     a82:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
     a86:	ec53 2b17 	vmov	r2, r3, d7
     a8a:	f002 faaf 	bl	2fec <Print::printf(char const*, ...)>
			Serial.printf("\tq_accel: [%f, %f, %f]\n", q_accel[0], q_accel[1], q_accel[2]);
     a8e:	ed94 6a16 	vldr	s12, [r4, #88]	; 0x58
     a92:	ed94 7a15 	vldr	s14, [r4, #84]	; 0x54
     a96:	4628      	mov	r0, r5
     a98:	edd4 5a14 	vldr	s11, [r4, #80]	; 0x50
     a9c:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     aa0:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     aa4:	4914      	ldr	r1, [pc, #80]	; (af8 <ComplimentaryFilter::print()+0x94>)
     aa6:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     aaa:	ed8d 6b02 	vstr	d6, [sp, #8]
     aae:	ec53 2b15 	vmov	r2, r3, d5
     ab2:	ed8d 7b00 	vstr	d7, [sp]
     ab6:	f002 fa99 	bl	2fec <Print::printf(char const*, ...)>
			Serial.printf("\tq_gyro: [%f, %f, %f]\n", q_gyro[0], q_gyro[1], q_gyro[2]);
     aba:	ed94 6a13 	vldr	s12, [r4, #76]	; 0x4c
     abe:	ed94 7a12 	vldr	s14, [r4, #72]	; 0x48
     ac2:	4628      	mov	r0, r5
     ac4:	edd4 5a11 	vldr	s11, [r4, #68]	; 0x44
     ac8:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     acc:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     ad0:	490a      	ldr	r1, [pc, #40]	; (afc <ComplimentaryFilter::print()+0x98>)
     ad2:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     ad6:	ed8d 6b02 	vstr	d6, [sp, #8]
     ada:	ec53 2b15 	vmov	r2, r3, d5
     ade:	ed8d 7b00 	vstr	d7, [sp]
     ae2:	f002 fa83 	bl	2fec <Print::printf(char const*, ...)>
		}
     ae6:	b005      	add	sp, #20
     ae8:	bd30      	pop	{r4, r5, pc}
     aea:	bf00      	nop
     aec:	20001474 	.word	0x20001474
     af0:	20000c60 	.word	0x20000c60
     af4:	20000c74 	.word	0x20000c74
     af8:	20000c84 	.word	0x20000c84
     afc:	20000c9c 	.word	0x20000c9c

00000b00 <ComplimentaryFilter::reset()>:
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
     b00:	6802      	ldr	r2, [r0, #0]
     b02:	490d      	ldr	r1, [pc, #52]	; (b38 <ComplimentaryFilter::reset()+0x38>)
     b04:	6912      	ldr	r2, [r2, #16]

			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
     b06:	b410      	push	{r4}
     b08:	428a      	cmp	r2, r1
			K = DEFAULT_GAIN;
     b0a:	4c0c      	ldr	r4, [pc, #48]	; (b3c <ComplimentaryFilter::reset()+0x3c>)
     b0c:	6404      	str	r4, [r0, #64]	; 0x40
     b0e:	d10f      	bne.n	b30 <ComplimentaryFilter::reset()+0x30>
			clear();
		}

		void clear() {
			axz_norm = 0;
     b10:	2200      	movs	r2, #0
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
		}
     b12:	f85d 4b04 	ldr.w	r4, [sp], #4

		void clear() {
			axz_norm = 0;
     b16:	6342      	str	r2, [r0, #52]	; 0x34
			ayz_norm = 0;
     b18:	6382      	str	r2, [r0, #56]	; 0x38
			mag_norm = 0;
     b1a:	63c2      	str	r2, [r0, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     b1c:	6442      	str	r2, [r0, #68]	; 0x44
				q_accel[i] = 0;
     b1e:	6502      	str	r2, [r0, #80]	; 0x50
				bias_accel[i] = 0;
     b20:	65c2      	str	r2, [r0, #92]	; 0x5c
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     b22:	6482      	str	r2, [r0, #72]	; 0x48
				q_accel[i] = 0;
     b24:	6542      	str	r2, [r0, #84]	; 0x54
				bias_accel[i] = 0;
     b26:	6602      	str	r2, [r0, #96]	; 0x60
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     b28:	64c2      	str	r2, [r0, #76]	; 0x4c
				q_accel[i] = 0;
     b2a:	6582      	str	r2, [r0, #88]	; 0x58
				bias_accel[i] = 0;
     b2c:	6642      	str	r2, [r0, #100]	; 0x64
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
		}
     b2e:	4770      	bx	lr
     b30:	f85d 4b04 	ldr.w	r4, [sp], #4
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
     b34:	4710      	bx	r2
     b36:	bf00      	nop
     b38:	00000839 	.word	0x00000839
     b3c:	3ecccccd 	.word	0x3ecccccd

00000b40 <SystemGraph::SystemGraph()>:
#include "utilities/vector.h"
#include "system_graph/process.h"
#include "system_graph/graph_node.h"
#include "system_graph/system_graph.h"

SystemGraph::SystemGraph() {
     b40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     b44:	4604      	mov	r4, r0
     b46:	f7ff fbcf 	bl	2e8 <HidReport::HidReport()>
     b4a:	f104 0844 	add.w	r8, r4, #68	; 0x44
     b4e:	f104 0770 	add.w	r7, r4, #112	; 0x70
     b52:	f104 0578 	add.w	r5, r4, #120	; 0x78
     b56:	f104 0680 	add.w	r6, r4, #128	; 0x80
     b5a:	4640      	mov	r0, r8
     b5c:	f000 f9be 	bl	edc <FTYK::FTYK()>
     b60:	4638      	mov	r0, r7
     b62:	f000 faff 	bl	1164 <Vector<int>::Vector()>
     b66:	4628      	mov	r0, r5
     b68:	f000 fafc 	bl	1164 <Vector<int>::Vector()>
     b6c:	4630      	mov	r0, r6
     b6e:	f000 fc55 	bl	141c <Vector<GraphNode*>::Vector()>
	lifetime = 0;
     b72:	2300      	movs	r3, #0
	watch.set(0);
     b74:	4640      	mov	r0, r8
     b76:	2100      	movs	r1, #0
#include "system_graph/process.h"
#include "system_graph/graph_node.h"
#include "system_graph/system_graph.h"

SystemGraph::SystemGraph() {
	lifetime = 0;
     b78:	66e3      	str	r3, [r4, #108]	; 0x6c
	watch.set(0);
     b7a:	f000 f9bf 	bl	efc <FTYK::set(int)>
	status.reset(0);
     b7e:	4638      	mov	r0, r7
     b80:	2100      	movs	r1, #0
     b82:	f000 fb01 	bl	1188 <Vector<int>::reset(int)>
	nodes.reset(0);
     b86:	4630      	mov	r0, r6
     b88:	2100      	movs	r1, #0
     b8a:	f000 fc59 	bl	1440 <Vector<GraphNode*>::reset(int)>
	node_ids.reset(0);
     b8e:	4628      	mov	r0, r5
     b90:	2100      	movs	r1, #0
     b92:	f000 faf9 	bl	1188 <Vector<int>::reset(int)>

	setup_blink();
     b96:	f000 f989 	bl	eac <setup_blink()>
}
     b9a:	4620      	mov	r0, r4
     b9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00000ba0 <SystemGraph::collect_outputs(int, Vector<float>*)>:

void SystemGraph::collect_outputs(int index, Vector<float>* data) {
     ba0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     ba4:	460e      	mov	r6, r1
     ba6:	4690      	mov	r8, r2
	for (int i = 0; i < nodes[index]->n_inputs(); i++) {
     ba8:	2400      	movs	r4, #0
     baa:	f100 0580 	add.w	r5, r0, #128	; 0x80
		int node_id = node_ids.find(nodes[index]->input_id(i));
     bae:	f100 0778 	add.w	r7, r0, #120	; 0x78

	setup_blink();
}

void SystemGraph::collect_outputs(int index, Vector<float>* data) {
	for (int i = 0; i < nodes[index]->n_inputs(); i++) {
     bb2:	4631      	mov	r1, r6
     bb4:	4628      	mov	r0, r5
     bb6:	f000 fc87 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     bba:	6800      	ldr	r0, [r0, #0]
     bbc:	f7ff fd64 	bl	688 <GraphNode::n_inputs()>
     bc0:	4284      	cmp	r4, r0
		int node_id = node_ids.find(nodes[index]->input_id(i));
     bc2:	4631      	mov	r1, r6
     bc4:	4628      	mov	r0, r5

	setup_blink();
}

void SystemGraph::collect_outputs(int index, Vector<float>* data) {
	for (int i = 0; i < nodes[index]->n_inputs(); i++) {
     bc6:	da17      	bge.n	bf8 <SystemGraph::collect_outputs(int, Vector<float>*)+0x58>
		int node_id = node_ids.find(nodes[index]->input_id(i));
     bc8:	f000 fc7e 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     bcc:	4621      	mov	r1, r4
     bce:	6800      	ldr	r0, [r0, #0]

	setup_blink();
}

void SystemGraph::collect_outputs(int index, Vector<float>* data) {
	for (int i = 0; i < nodes[index]->n_inputs(); i++) {
     bd0:	3401      	adds	r4, #1
		int node_id = node_ids.find(nodes[index]->input_id(i));
     bd2:	f7ff fd93 	bl	6fc <GraphNode::input_id(int)>
     bd6:	4601      	mov	r1, r0
     bd8:	4638      	mov	r0, r7
     bda:	f000 fb19 	bl	1210 <Vector<int>::find(int)>
		if (node_id >= 0) {
     bde:	1e01      	subs	r1, r0, #0
			data->append(nodes[node_id]->output());
     be0:	4628      	mov	r0, r5
}

void SystemGraph::collect_outputs(int index, Vector<float>* data) {
	for (int i = 0; i < nodes[index]->n_inputs(); i++) {
		int node_id = node_ids.find(nodes[index]->input_id(i));
		if (node_id >= 0) {
     be2:	dbe6      	blt.n	bb2 <SystemGraph::collect_outputs(int, Vector<float>*)+0x12>
			data->append(nodes[node_id]->output());
     be4:	f000 fc70 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     be8:	6800      	ldr	r0, [r0, #0]
     bea:	f7ff fd83 	bl	6f4 <GraphNode::output()>
     bee:	4601      	mov	r1, r0
     bf0:	4640      	mov	r0, r8
     bf2:	f000 fb9f 	bl	1334 <Vector<float>::append(Vector<float>*)>

	setup_blink();
}

void SystemGraph::collect_outputs(int index, Vector<float>* data) {
	for (int i = 0; i < nodes[index]->n_inputs(); i++) {
     bf6:	e7dc      	b.n	bb2 <SystemGraph::collect_outputs(int, Vector<float>*)+0x12>
     bf8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00000bfc <SystemGraph::add(String, int, int, int, int*)>:
			data->append(nodes[node_id]->output());
		}
	}
}

void SystemGraph::add(String proc_id, int id, int n_configs, int n_inputs, int* inputs) {
     bfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	// status.push(0);
	int index = node_ids.find(id);
     c00:	f100 0578 	add.w	r5, r0, #120	; 0x78
			data->append(nodes[node_id]->output());
		}
	}
}

void SystemGraph::add(String proc_id, int id, int n_configs, int n_inputs, int* inputs) {
     c04:	4604      	mov	r4, r0
     c06:	4688      	mov	r8, r1
	// status.push(0);
	int index = node_ids.find(id);
     c08:	4611      	mov	r1, r2
     c0a:	4628      	mov	r0, r5
			data->append(nodes[node_id]->output());
		}
	}
}

void SystemGraph::add(String proc_id, int id, int n_configs, int n_inputs, int* inputs) {
     c0c:	461e      	mov	r6, r3
     c0e:	4617      	mov	r7, r2
     c10:	ed2d 8b02 	vpush	{d8}
     c14:	b089      	sub	sp, #36	; 0x24
	// status.push(0);
	int index = node_ids.find(id);
     c16:	f000 fafb 	bl	1210 <Vector<int>::find(int)>
	if (index == -1) {
     c1a:	1c43      	adds	r3, r0, #1
     c1c:	d00d      	beq.n	c3a <SystemGraph::add(String, int, int, int, int*)+0x3e>
		else {
			status.push(0);
		}
	}
	else {
		nodes[index]->set_config(n_configs);
     c1e:	4601      	mov	r1, r0
     c20:	f104 0080 	add.w	r0, r4, #128	; 0x80
     c24:	f000 fc50 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     c28:	4631      	mov	r1, r6
     c2a:	6800      	ldr	r0, [r0, #0]
     c2c:	f7ff fd26 	bl	67c <GraphNode::set_config(int)>
		// nodes[index]->set_inputs(inputs);
		// nodes[index]->set_process(factory.new_proc(proc_id)); // Doesn't seem to reinit imu but it should... imu init takes forever though so whatever
	}
}
     c30:	b009      	add	sp, #36	; 0x24
     c32:	ecbd 8b02 	vpop	{d8}
     c36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

void SystemGraph::add(String proc_id, int id, int n_configs, int n_inputs, int* inputs) {
	// status.push(0);
	int index = node_ids.find(id);
	if (index == -1) {
		node_ids.push(id);
     c3a:	4639      	mov	r1, r7
     c3c:	4628      	mov	r0, r5
     c3e:	f000 fac7 	bl	11d0 <Vector<int>::push(int)>
		nodes.push(new GraphNode(factory.new_proc(proc_id), n_configs, n_inputs, inputs));
     c42:	4641      	mov	r1, r8
     c44:	a804      	add	r0, sp, #16
     c46:	f104 0a80 	add.w	sl, r4, #128	; 0x80
     c4a:	f002 fa45 	bl	30d8 <String::String(String const&)>
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
     c4e:	a804      	add	r0, sp, #16
     c50:	493f      	ldr	r1, [pc, #252]	; (d50 <SystemGraph::add(String, int, int, int, int*)+0x154>)
     c52:	f002 fa51 	bl	30f8 <String::equals(char const*) const>
class Process_Factory {
	// private:
		
	public:
		Process* new_proc(String index) {
			if (index == LSM6DSOX_ID) {
     c56:	4683      	mov	fp, r0
     c58:	2800      	cmp	r0, #0
     c5a:	d168      	bne.n	d2e <SystemGraph::add(String, int, int, int, int*)+0x132>
     c5c:	493d      	ldr	r1, [pc, #244]	; (d54 <SystemGraph::add(String, int, int, int, int*)+0x158>)
     c5e:	a804      	add	r0, sp, #16
     c60:	f002 fa4a 	bl	30f8 <String::equals(char const*) const>
				return new LSM6DSOX();
			}
			else if (index == COMPLIMENTARYFILTER_ID) {
     c64:	2800      	cmp	r0, #0
     c66:	d071      	beq.n	d4c <SystemGraph::add(String, int, int, int, int*)+0x150>
				return new ComplimentaryFilter();
     c68:	2068      	movs	r0, #104	; 0x68
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     c6a:	2700      	movs	r7, #0
     c6c:	f002 fa74 	bl	3158 <operator new(unsigned int)>
     c70:	4a39      	ldr	r2, [pc, #228]	; (d58 <SystemGraph::add(String, int, int, int, int*)+0x15c>)
     c72:	4680      	mov	r8, r0
     c74:	4605      	mov	r5, r0
     c76:	9003      	str	r0, [sp, #12]
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
				q_accel[i] = 0;
				bias_accel[i] = 0;
     c78:	4681      	mov	r9, r0
     c7a:	f848 2b04 	str.w	r2, [r8], #4
     c7e:	4640      	mov	r0, r8
     c80:	f000 fa70 	bl	1164 <Vector<int>::Vector()>
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     c84:	9b03      	ldr	r3, [sp, #12]
     c86:	4a35      	ldr	r2, [pc, #212]	; (d5c <SystemGraph::add(String, int, int, int, int*)+0x160>)
     c88:	ed9f 8a35 	vldr	s16, [pc, #212]	; d60 <SystemGraph::add(String, int, int, int, int*)+0x164>
     c8c:	f843 2b0c 	str.w	r2, [r3], #12
     c90:	4618      	mov	r0, r3
     c92:	9303      	str	r3, [sp, #12]
     c94:	f000 f922 	bl	edc <FTYK::FTYK()>
			dimensions.reset(PROCESS_DIMENSIONS);
     c98:	4640      	mov	r0, r8
     c9a:	2103      	movs	r1, #3
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     c9c:	636f      	str	r7, [r5, #52]	; 0x34
     c9e:	63af      	str	r7, [r5, #56]	; 0x38
     ca0:	63ef      	str	r7, [r5, #60]	; 0x3c
     ca2:	ed85 8a10 	vstr	s16, [r5, #64]	; 0x40
			dimensions.reset(PROCESS_DIMENSIONS);
     ca6:	f000 fa6f 	bl	1188 <Vector<int>::reset(int)>
			dimensions[INPUT_DIMENSION] = CMF_INPUT_DIMS;
     caa:	4659      	mov	r1, fp
     cac:	4640      	mov	r0, r8
     cae:	f000 fac5 	bl	123c <Vector<int>::operator[](int)>
     cb2:	220c      	movs	r2, #12
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
     cb4:	2101      	movs	r1, #1


	public:
		ComplimentaryFilter() {
			dimensions.reset(PROCESS_DIMENSIONS);
			dimensions[INPUT_DIMENSION] = CMF_INPUT_DIMS;
     cb6:	6002      	str	r2, [r0, #0]
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
     cb8:	4640      	mov	r0, r8
     cba:	f000 fabf 	bl	123c <Vector<int>::operator[](int)>
     cbe:	2206      	movs	r2, #6
			dimensions[OUTPUT_DIMENSION] = ATTITUDE_DIM;
     cc0:	2102      	movs	r1, #2

	public:
		ComplimentaryFilter() {
			dimensions.reset(PROCESS_DIMENSIONS);
			dimensions[INPUT_DIMENSION] = CMF_INPUT_DIMS;
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
     cc2:	6002      	str	r2, [r0, #0]
			dimensions[OUTPUT_DIMENSION] = ATTITUDE_DIM;
     cc4:	4640      	mov	r0, r8
     cc6:	f000 fab9 	bl	123c <Vector<int>::operator[](int)>
     cca:	2203      	movs	r2, #3
			watches.set(0);
     ccc:	9b03      	ldr	r3, [sp, #12]
     cce:	4659      	mov	r1, fp
	public:
		ComplimentaryFilter() {
			dimensions.reset(PROCESS_DIMENSIONS);
			dimensions[INPUT_DIMENSION] = CMF_INPUT_DIMS;
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
			dimensions[OUTPUT_DIMENSION] = ATTITUDE_DIM;
     cd0:	6002      	str	r2, [r0, #0]
			watches.set(0);
     cd2:	4618      	mov	r0, r3
     cd4:	f000 f912 	bl	efc <FTYK::set(int)>
			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
     cd8:	ed85 8a10 	vstr	s16, [r5, #64]	; 0x40
			clear();
		}

		void clear() {
			axz_norm = 0;
     cdc:	636f      	str	r7, [r5, #52]	; 0x34
			ayz_norm = 0;
     cde:	63af      	str	r7, [r5, #56]	; 0x38
			mag_norm = 0;
     ce0:	63ef      	str	r7, [r5, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     ce2:	646f      	str	r7, [r5, #68]	; 0x44
				q_accel[i] = 0;
     ce4:	652f      	str	r7, [r5, #80]	; 0x50
				bias_accel[i] = 0;
     ce6:	65ef      	str	r7, [r5, #92]	; 0x5c
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     ce8:	64af      	str	r7, [r5, #72]	; 0x48
				q_accel[i] = 0;
     cea:	656f      	str	r7, [r5, #84]	; 0x54
				bias_accel[i] = 0;
     cec:	662f      	str	r7, [r5, #96]	; 0x60
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     cee:	64ef      	str	r7, [r5, #76]	; 0x4c
				q_accel[i] = 0;
     cf0:	65af      	str	r7, [r5, #88]	; 0x58
				bias_accel[i] = 0;
     cf2:	666f      	str	r7, [r5, #100]	; 0x64
     cf4:	2028      	movs	r0, #40	; 0x28
     cf6:	f002 fa2f 	bl	3158 <operator new(unsigned int)>
     cfa:	9b15      	ldr	r3, [sp, #84]	; 0x54
     cfc:	4605      	mov	r5, r0
     cfe:	4632      	mov	r2, r6
     d00:	9300      	str	r3, [sp, #0]
     d02:	4649      	mov	r1, r9
     d04:	9b14      	ldr	r3, [sp, #80]	; 0x50
     d06:	f7ff fc85 	bl	614 <GraphNode::GraphNode(Process*, int, int, int*)>
     d0a:	4629      	mov	r1, r5
     d0c:	4650      	mov	r0, sl
     d0e:	f000 fbbb 	bl	1488 <Vector<GraphNode*>::push(GraphNode*)>
     d12:	a804      	add	r0, sp, #16
     d14:	f002 f98c 	bl	3030 <String::~String()>

		if (n_configs == 0) {
			status.push(1);
     d18:	f104 0070 	add.w	r0, r4, #112	; 0x70
	int index = node_ids.find(id);
	if (index == -1) {
		node_ids.push(id);
		nodes.push(new GraphNode(factory.new_proc(proc_id), n_configs, n_inputs, inputs));

		if (n_configs == 0) {
     d1c:	b976      	cbnz	r6, d3c <SystemGraph::add(String, int, int, int, int*)+0x140>
			status.push(1);
     d1e:	2101      	movs	r1, #1
     d20:	f000 fa56 	bl	11d0 <Vector<int>::push(int)>
	else {
		nodes[index]->set_config(n_configs);
		// nodes[index]->set_inputs(inputs);
		// nodes[index]->set_process(factory.new_proc(proc_id)); // Doesn't seem to reinit imu but it should... imu init takes forever though so whatever
	}
}
     d24:	b009      	add	sp, #36	; 0x24
     d26:	ecbd 8b02 	vpop	{d8}
     d2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	// private:
		
	public:
		Process* new_proc(String index) {
			if (index == LSM6DSOX_ID) {
				return new LSM6DSOX();
     d2e:	20b0      	movs	r0, #176	; 0xb0
     d30:	f002 fa12 	bl	3158 <operator new(unsigned int)>
     d34:	4681      	mov	r9, r0
     d36:	f7ff fbd3 	bl	4e0 <LSM6DSOX::LSM6DSOX()>
     d3a:	e7db      	b.n	cf4 <SystemGraph::add(String, int, int, int, int*)+0xf8>

		if (n_configs == 0) {
			status.push(1);
		}
		else {
			status.push(0);
     d3c:	2100      	movs	r1, #0
     d3e:	f000 fa47 	bl	11d0 <Vector<int>::push(int)>
	else {
		nodes[index]->set_config(n_configs);
		// nodes[index]->set_inputs(inputs);
		// nodes[index]->set_process(factory.new_proc(proc_id)); // Doesn't seem to reinit imu but it should... imu init takes forever though so whatever
	}
}
     d42:	b009      	add	sp, #36	; 0x24
     d44:	ecbd 8b02 	vpop	{d8}
     d48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
			else if (index == COMPLIMENTARYFILTER_ID) {
				return new ComplimentaryFilter();
			}
			else {
				return nullptr;
     d4c:	4681      	mov	r9, r0
     d4e:	e7d1      	b.n	cf4 <SystemGraph::add(String, int, int, int, int*)+0xf8>
     d50:	20000b60 	.word	0x20000b60
     d54:	20000b74 	.word	0x20000b74
     d58:	20000548 	.word	0x20000548
     d5c:	200004c8 	.word	0x200004c8
     d60:	3ecccccd 	.word	0x3ecccccd

00000d64 <SystemGraph::update_config(int, int, int, float*)>:

void SystemGraph::update_config(int id, int chunk_id, int n_configs, float* config) {
     d64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     d68:	4605      	mov	r5, r0
	int node_index = node_ids.find(id);
     d6a:	3078      	adds	r0, #120	; 0x78
		// nodes[index]->set_inputs(inputs);
		// nodes[index]->set_process(factory.new_proc(proc_id)); // Doesn't seem to reinit imu but it should... imu init takes forever though so whatever
	}
}

void SystemGraph::update_config(int id, int chunk_id, int n_configs, float* config) {
     d6c:	4699      	mov	r9, r3
     d6e:	4690      	mov	r8, r2
     d70:	460e      	mov	r6, r1
     d72:	9f08      	ldr	r7, [sp, #32]
	int node_index = node_ids.find(id);
     d74:	f000 fa4c 	bl	1210 <Vector<int>::find(int)>
	if (node_index == -1) {
     d78:	1c43      	adds	r3, r0, #1
     d7a:	d029      	beq.n	dd0 <SystemGraph::update_config(int, int, int, float*)+0x6c>
		Serial.printf("Node not found %i\n", id);
		return;
	}
	nodes[node_index]->config()->insert(config, chunk_id * n_configs, n_configs);
     d7c:	f105 0680 	add.w	r6, r5, #128	; 0x80
     d80:	4601      	mov	r1, r0
     d82:	4604      	mov	r4, r0
     d84:	4630      	mov	r0, r6
     d86:	f000 fb9f 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     d8a:	6800      	ldr	r0, [r0, #0]
     d8c:	f7ff fcb4 	bl	6f8 <GraphNode::config()>
     d90:	464b      	mov	r3, r9
     d92:	fb09 f208 	mul.w	r2, r9, r8
     d96:	4639      	mov	r1, r7
     d98:	f000 faf6 	bl	1388 <Vector<float>::insert(float*, int, int)>
	if (nodes[node_index]->is_configured()) {
     d9c:	4621      	mov	r1, r4
     d9e:	4630      	mov	r0, r6
     da0:	f000 fb92 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     da4:	6800      	ldr	r0, [r0, #0]
     da6:	f7ff fcaf 	bl	708 <GraphNode::is_configured()>
     daa:	b908      	cbnz	r0, db0 <SystemGraph::update_config(int, int, int, float*)+0x4c>
     dac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		status[node_index] = 1;
     db0:	4621      	mov	r1, r4
     db2:	f105 0070 	add.w	r0, r5, #112	; 0x70
     db6:	f000 fa41 	bl	123c <Vector<int>::operator[](int)>
     dba:	2301      	movs	r3, #1
		nodes[node_index]->setup_proc();
     dbc:	4621      	mov	r1, r4
		Serial.printf("Node not found %i\n", id);
		return;
	}
	nodes[node_index]->config()->insert(config, chunk_id * n_configs, n_configs);
	if (nodes[node_index]->is_configured()) {
		status[node_index] = 1;
     dbe:	6003      	str	r3, [r0, #0]
		nodes[node_index]->setup_proc();
     dc0:	4630      	mov	r0, r6
     dc2:	f000 fb81 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     dc6:	6800      	ldr	r0, [r0, #0]
	}
}
     dc8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		return;
	}
	nodes[node_index]->config()->insert(config, chunk_id * n_configs, n_configs);
	if (nodes[node_index]->is_configured()) {
		status[node_index] = 1;
		nodes[node_index]->setup_proc();
     dcc:	f7ff bc60 	b.w	690 <GraphNode::setup_proc()>
}

void SystemGraph::update_config(int id, int chunk_id, int n_configs, float* config) {
	int node_index = node_ids.find(id);
	if (node_index == -1) {
		Serial.printf("Node not found %i\n", id);
     dd0:	4632      	mov	r2, r6
     dd2:	4903      	ldr	r1, [pc, #12]	; (de0 <SystemGraph::update_config(int, int, int, float*)+0x7c>)
     dd4:	4803      	ldr	r0, [pc, #12]	; (de4 <SystemGraph::update_config(int, int, int, float*)+0x80>)
	nodes[node_index]->config()->insert(config, chunk_id * n_configs, n_configs);
	if (nodes[node_index]->is_configured()) {
		status[node_index] = 1;
		nodes[node_index]->setup_proc();
	}
}
     dd6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
}

void SystemGraph::update_config(int id, int chunk_id, int n_configs, float* config) {
	int node_index = node_ids.find(id);
	if (node_index == -1) {
		Serial.printf("Node not found %i\n", id);
     dda:	f002 b907 	b.w	2fec <Print::printf(char const*, ...)>
     dde:	bf00      	nop
     de0:	20000cb4 	.word	0x20000cb4
     de4:	20001474 	.word	0x20001474

00000de8 <SystemGraph::spin()>:
		status[node_index] = 1;
		nodes[node_index]->setup_proc();
	}
}

void SystemGraph::spin() {
     de8:	b5f0      	push	{r4, r5, r6, r7, lr}
	Vector<float> input(0);
	for (int i = 0; i < nodes.size(); i++) {
     dea:	2400      	movs	r4, #0
		status[node_index] = 1;
		nodes[node_index]->setup_proc();
	}
}

void SystemGraph::spin() {
     dec:	b083      	sub	sp, #12
     dee:	4607      	mov	r7, r0
     df0:	f100 0580 	add.w	r5, r0, #128	; 0x80
	Vector<float> input(0);
	for (int i = 0; i < nodes.size(); i++) {
		if (status[i] == 1) {
     df4:	f100 0670 	add.w	r6, r0, #112	; 0x70
		nodes[node_index]->setup_proc();
	}
}

void SystemGraph::spin() {
	Vector<float> input(0);
     df8:	4621      	mov	r1, r4
     dfa:	4668      	mov	r0, sp
     dfc:	f000 fa3e 	bl	127c <Vector<float>::Vector(int)>
     e00:	e000      	b.n	e04 <SystemGraph::spin()+0x1c>
	for (int i = 0; i < nodes.size(); i++) {
     e02:	3401      	adds	r4, #1
     e04:	4628      	mov	r0, r5
     e06:	f000 fb5d 	bl	14c4 <Vector<GraphNode*>::size()>
     e0a:	4284      	cmp	r4, r0
		if (status[i] == 1) {
     e0c:	4621      	mov	r1, r4
     e0e:	4630      	mov	r0, r6
	}
}

void SystemGraph::spin() {
	Vector<float> input(0);
	for (int i = 0; i < nodes.size(); i++) {
     e10:	da12      	bge.n	e38 <SystemGraph::spin()+0x50>
		if (status[i] == 1) {
     e12:	f000 fa13 	bl	123c <Vector<int>::operator[](int)>
     e16:	6803      	ldr	r3, [r0, #0]
     e18:	2b01      	cmp	r3, #1
     e1a:	d1f2      	bne.n	e02 <SystemGraph::spin()+0x1a>
			collect_outputs(i, &input);
     e1c:	466a      	mov	r2, sp
     e1e:	4621      	mov	r1, r4
     e20:	4638      	mov	r0, r7
     e22:	f7ff febd 	bl	ba0 <SystemGraph::collect_outputs(int, Vector<float>*)>
			nodes[i]->run_proc(&input);
     e26:	4621      	mov	r1, r4
     e28:	4628      	mov	r0, r5
     e2a:	f000 fb4d 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     e2e:	4669      	mov	r1, sp
     e30:	6800      	ldr	r0, [r0, #0]
     e32:	f7ff fc41 	bl	6b8 <GraphNode::run_proc(Vector<float>*)>
     e36:	e7e4      	b.n	e02 <SystemGraph::spin()+0x1a>
		nodes[node_index]->setup_proc();
	}
}

void SystemGraph::spin() {
	Vector<float> input(0);
     e38:	4668      	mov	r0, sp
     e3a:	f000 fa11 	bl	1260 <Vector<float>::~Vector()>
		if (status[i] == 1) {
			collect_outputs(i, &input);
			nodes[i]->run_proc(&input);
		}
	}
}
     e3e:	b003      	add	sp, #12
     e40:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e42:	bf00      	nop

00000e44 <SystemGraph::dump_all()>:

void SystemGraph::dump_all() {
     e44:	b570      	push	{r4, r5, r6, lr}
     e46:	4606      	mov	r6, r0
	Serial.printf("lifetime: %f\n", lifetime);
     e48:	4915      	ldr	r1, [pc, #84]	; (ea0 <SystemGraph::dump_all()+0x5c>)
     e4a:	4816      	ldr	r0, [pc, #88]	; (ea4 <SystemGraph::dump_all()+0x60>)
	Serial.print("Node ids\n\t");
	node_ids.print();
	for (int i = 0; i < nodes.size(); i++) {
     e4c:	2400      	movs	r4, #0
		}
	}
}

void SystemGraph::dump_all() {
	Serial.printf("lifetime: %f\n", lifetime);
     e4e:	edd6 7a1b 	vldr	s15, [r6, #108]	; 0x6c
     e52:	f106 0580 	add.w	r5, r6, #128	; 0x80
     e56:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
     e5a:	ec53 2b17 	vmov	r2, r3, d7
     e5e:	f002 f8c5 	bl	2fec <Print::printf(char const*, ...)>
     e62:	210a      	movs	r1, #10
     e64:	4810      	ldr	r0, [pc, #64]	; (ea8 <SystemGraph::dump_all()+0x64>)
     e66:	f001 fff3 	bl	2e50 <usb_seremu_write>
	Serial.print("Node ids\n\t");
	node_ids.print();
     e6a:	f106 0078 	add.w	r0, r6, #120	; 0x78
     e6e:	f000 f90b 	bl	1088 <Vector<int>::print()>
     e72:	e00c      	b.n	e8e <SystemGraph::dump_all()+0x4a>
	for (int i = 0; i < nodes.size(); i++) {
		nodes[i]->print_proc();
     e74:	f000 fb28 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     e78:	6800      	ldr	r0, [r0, #0]
     e7a:	f7ff fc4f 	bl	71c <GraphNode::print_proc()>
		nodes[i]->print_output();
     e7e:	4621      	mov	r1, r4
     e80:	4628      	mov	r0, r5

void SystemGraph::dump_all() {
	Serial.printf("lifetime: %f\n", lifetime);
	Serial.print("Node ids\n\t");
	node_ids.print();
	for (int i = 0; i < nodes.size(); i++) {
     e82:	3401      	adds	r4, #1
		nodes[i]->print_proc();
		nodes[i]->print_output();
     e84:	f000 fb20 	bl	14c8 <Vector<GraphNode*>::operator[](int)>
     e88:	6800      	ldr	r0, [r0, #0]
     e8a:	f7ff fc4b 	bl	724 <GraphNode::print_output()>

void SystemGraph::dump_all() {
	Serial.printf("lifetime: %f\n", lifetime);
	Serial.print("Node ids\n\t");
	node_ids.print();
	for (int i = 0; i < nodes.size(); i++) {
     e8e:	4628      	mov	r0, r5
     e90:	f000 fb18 	bl	14c4 <Vector<GraphNode*>::size()>
     e94:	4284      	cmp	r4, r0
		nodes[i]->print_proc();
     e96:	4621      	mov	r1, r4
     e98:	4628      	mov	r0, r5

void SystemGraph::dump_all() {
	Serial.printf("lifetime: %f\n", lifetime);
	Serial.print("Node ids\n\t");
	node_ids.print();
	for (int i = 0; i < nodes.size(); i++) {
     e9a:	dbeb      	blt.n	e74 <SystemGraph::dump_all()+0x30>
     e9c:	bd70      	pop	{r4, r5, r6, pc}
     e9e:	bf00      	nop
     ea0:	20000cc8 	.word	0x20000cc8
     ea4:	20001474 	.word	0x20001474
     ea8:	20000cd8 	.word	0x20000cd8

00000eac <setup_blink()>:
bool blinker_status;

/*
	Easy use blinker implementation
*/
void setup_blink() {
     eac:	b510      	push	{r4, lr}
	// Hardware setup
	blinker_status = false;
     eae:	2200      	movs	r2, #0
     eb0:	4c07      	ldr	r4, [pc, #28]	; (ed0 <setup_blink()+0x24>)
	blinker_timer_mark = ARM_DWT_CYCCNT;
     eb2:	4b08      	ldr	r3, [pc, #32]	; (ed4 <setup_blink()+0x28>)

	pinMode(BLINK_PIN, OUTPUT);
     eb4:	2101      	movs	r1, #1
/*
	Easy use blinker implementation
*/
void setup_blink() {
	// Hardware setup
	blinker_status = false;
     eb6:	7022      	strb	r2, [r4, #0]
	blinker_timer_mark = ARM_DWT_CYCCNT;

	pinMode(BLINK_PIN, OUTPUT);
     eb8:	200d      	movs	r0, #13
	Easy use blinker implementation
*/
void setup_blink() {
	// Hardware setup
	blinker_status = false;
	blinker_timer_mark = ARM_DWT_CYCCNT;
     eba:	681a      	ldr	r2, [r3, #0]
     ebc:	4b06      	ldr	r3, [pc, #24]	; (ed8 <setup_blink()+0x2c>)
     ebe:	601a      	str	r2, [r3, #0]

	pinMode(BLINK_PIN, OUTPUT);
     ec0:	f000 fd18 	bl	18f4 <pinMode>
	digitalWrite(BLINK_PIN, blinker_status);
     ec4:	7821      	ldrb	r1, [r4, #0]
     ec6:	200d      	movs	r0, #13
}
     ec8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	// Hardware setup
	blinker_status = false;
	blinker_timer_mark = ARM_DWT_CYCCNT;

	pinMode(BLINK_PIN, OUTPUT);
	digitalWrite(BLINK_PIN, blinker_status);
     ecc:	f000 bd06 	b.w	18dc <digitalWrite>
     ed0:	2000277d 	.word	0x2000277d
     ed4:	e0001004 	.word	0xe0001004
     ed8:	200026e8 	.word	0x200026e8

00000edc <FTYK::FTYK()>:
	uint32_t delta_ns = CYCLES_2_NS(delta_cycles); 
	Serial.printf( "\t%1lu cycles, %1lu ns\n", delta_cycles, delta_ns);
	return delta_ns;
}

FTYK::FTYK() {
     edc:	b410      	push	{r4}
     ede:	1f03      	subs	r3, r0, #4
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
		timers[i] = ARM_DWT_CYCCNT;
     ee0:	4c05      	ldr	r4, [pc, #20]	; (ef8 <FTYK::FTYK()+0x1c>)
     ee2:	f100 0124 	add.w	r1, r0, #36	; 0x24
     ee6:	6822      	ldr	r2, [r4, #0]
     ee8:	f843 2f04 	str.w	r2, [r3, #4]!
			- add rollover support: ARM_DWT_CYCCNT is a cycle count that resets every 8
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
     eec:	428b      	cmp	r3, r1
     eee:	d1fa      	bne.n	ee6 <FTYK::FTYK()+0xa>
		timers[i] = ARM_DWT_CYCCNT;
	}
}
     ef0:	f85d 4b04 	ldr.w	r4, [sp], #4
     ef4:	4770      	bx	lr
     ef6:	bf00      	nop
     ef8:	e0001004 	.word	0xe0001004

00000efc <FTYK::set(int)>:
	/*
		  Set the timer at idx to the current cycle count.
		@param:
			idx: (int) index of the timer to set.
	*/
	timers[idx] = ARM_DWT_CYCCNT;
     efc:	4b02      	ldr	r3, [pc, #8]	; (f08 <FTYK::set(int)+0xc>)
     efe:	681b      	ldr	r3, [r3, #0]
     f00:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
     f04:	4770      	bx	lr
     f06:	bf00      	nop
     f08:	e0001004 	.word	0xe0001004
     f0c:	00000000 	.word	0x00000000

00000f10 <FTYK::micros(int)>:
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     f10:	4b09      	ldr	r3, [pc, #36]	; (f38 <FTYK::micros(int)+0x28>)
	/*
		  Get the number of microseconds since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return CYCLES_2_US(cycles(idx)); 
     f12:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     f16:	681b      	ldr	r3, [r3, #0]
	/*
		  Get the number of microseconds since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return CYCLES_2_US(cycles(idx)); 
     f18:	1a9b      	subs	r3, r3, r2
     f1a:	ee00 3a10 	vmov	s0, r3
     f1e:	ed9f 7b04 	vldr	d7, [pc, #16]	; f30 <FTYK::micros(int)+0x20>
     f22:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
     f26:	ee20 0b07 	vmul.f64	d0, d0, d7
}
     f2a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     f2e:	4770      	bx	lr
     f30:	b4e81b4f 	.word	0xb4e81b4f
     f34:	3f5b4e81 	.word	0x3f5b4e81
     f38:	e0001004 	.word	0xe0001004
     f3c:	00000000 	.word	0x00000000

00000f40 <FTYK::print(int)>:
		tmp = cycles(idx);
	}
	return CYCLES_2_MS(tmp);
}

void FTYK::print(int idx) {
     f40:	b570      	push	{r4, r5, r6, lr}
     f42:	460d      	mov	r5, r1
	Serial.printf("Timer %i\n", idx);
     f44:	4c22      	ldr	r4, [pc, #136]	; (fd0 <FTYK::print(int)+0x90>)
		tmp = cycles(idx);
	}
	return CYCLES_2_MS(tmp);
}

void FTYK::print(int idx) {
     f46:	b088      	sub	sp, #32
     f48:	4606      	mov	r6, r0
	Serial.printf("Timer %i\n", idx);
     f4a:	462a      	mov	r2, r5
     f4c:	4921      	ldr	r1, [pc, #132]	; (fd4 <FTYK::print(int)+0x94>)
     f4e:	4620      	mov	r0, r4
     f50:	f002 f84c 	bl	2fec <Print::printf(char const*, ...)>
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     f54:	4b20      	ldr	r3, [pc, #128]	; (fd8 <FTYK::print(int)+0x98>)
     f56:	f856 2025 	ldr.w	r2, [r6, r5, lsl #2]
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
     f5a:	4620      	mov	r0, r4
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     f5c:	681b      	ldr	r3, [r3, #0]
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
     f5e:	491f      	ldr	r1, [pc, #124]	; (fdc <FTYK::print(int)+0x9c>)
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     f60:	1a9b      	subs	r3, r3, r2

void FTYK::print(int idx) {
	Serial.printf("Timer %i\n", idx);
	int cyccnt = cycles(idx);
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
     f62:	ee07 3a90 	vmov	s15, r3
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
     f66:	9306      	str	r3, [sp, #24]

void FTYK::print(int idx) {
	Serial.printf("Timer %i\n", idx);
	int cyccnt = cycles(idx);
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
     f68:	ed9f 5b11 	vldr	d5, [pc, #68]	; fb0 <FTYK::print(int)+0x70>
     f6c:	eeb8 7be7 	vcvt.f64.s32	d7, s15
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
     f70:	ed9f 4b11 	vldr	d4, [pc, #68]	; fb8 <FTYK::print(int)+0x78>

void FTYK::print(int idx) {
	Serial.printf("Timer %i\n", idx);
	int cyccnt = cycles(idx);
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
     f74:	ee27 7b05 	vmul.f64	d7, d7, d5
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
     f78:	ed9f 6b11 	vldr	d6, [pc, #68]	; fc0 <FTYK::print(int)+0x80>
     f7c:	ed9f 3b12 	vldr	d3, [pc, #72]	; fc8 <FTYK::print(int)+0x88>

void FTYK::print(int idx) {
	Serial.printf("Timer %i\n", idx);
	int cyccnt = cycles(idx);
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
     f80:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
     f84:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
     f88:	ee87 5b06 	vdiv.f64	d5, d7, d6
     f8c:	ee87 6b03 	vdiv.f64	d6, d7, d3
     f90:	ee87 3b04 	vdiv.f64	d3, d7, d4
     f94:	ed8d 7b04 	vstr	d7, [sp, #16]
     f98:	ed8d 5b02 	vstr	d5, [sp, #8]
     f9c:	ed8d 6b00 	vstr	d6, [sp]
     fa0:	ec53 2b13 	vmov	r2, r3, d3
     fa4:	f002 f822 	bl	2fec <Print::printf(char const*, ...)>
}
     fa8:	b008      	add	sp, #32
     faa:	bd70      	pop	{r4, r5, r6, pc}
     fac:	f3af 8000 	nop.w
     fb0:	aaaaaaab 	.word	0xaaaaaaab
     fb4:	3ffaaaaa 	.word	0x3ffaaaaa
     fb8:	00000000 	.word	0x00000000
     fbc:	41cdcd65 	.word	0x41cdcd65
     fc0:	00000000 	.word	0x00000000
     fc4:	408f4000 	.word	0x408f4000
     fc8:	00000000 	.word	0x00000000
     fcc:	412e8480 	.word	0x412e8480
     fd0:	20001474 	.word	0x20001474
     fd4:	20000d30 	.word	0x20000d30
     fd8:	e0001004 	.word	0xe0001004
     fdc:	20000d3c 	.word	0x20000d3c

00000fe0 <FTYK::print(int, String)>:

void FTYK::print(int idx, String title) {
     fe0:	b570      	push	{r4, r5, r6, lr}
	Serial.print(title); Serial.printf(" Timer %i\n", idx);
     fe2:	4c25      	ldr	r4, [pc, #148]	; (1078 <FTYK::print(int, String)+0x98>)
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
}

void FTYK::print(int idx, String title) {
     fe4:	460d      	mov	r5, r1
     fe6:	b088      	sub	sp, #32
     fe8:	4606      	mov	r6, r0
	Serial.print(title); Serial.printf(" Timer %i\n", idx);
     fea:	4611      	mov	r1, r2
     fec:	4620      	mov	r0, r4
     fee:	f001 ffbf 	bl	2f70 <Print::print(String const&)>
     ff2:	462a      	mov	r2, r5
     ff4:	4620      	mov	r0, r4
     ff6:	4921      	ldr	r1, [pc, #132]	; (107c <FTYK::print(int, String)+0x9c>)
     ff8:	f001 fff8 	bl	2fec <Print::printf(char const*, ...)>
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     ffc:	4b20      	ldr	r3, [pc, #128]	; (1080 <FTYK::print(int, String)+0xa0>)
     ffe:	f856 2025 	ldr.w	r2, [r6, r5, lsl #2]
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
    1002:	4620      	mov	r0, r4
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
    1004:	681b      	ldr	r3, [r3, #0]
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
    1006:	491f      	ldr	r1, [pc, #124]	; (1084 <FTYK::print(int, String)+0xa4>)
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
    1008:	1a9b      	subs	r3, r3, r2

void FTYK::print(int idx, String title) {
	Serial.print(title); Serial.printf(" Timer %i\n", idx);
	int cyccnt = cycles(idx);
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
    100a:	ee07 3a90 	vmov	s15, r3
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
    100e:	9306      	str	r3, [sp, #24]

void FTYK::print(int idx, String title) {
	Serial.print(title); Serial.printf(" Timer %i\n", idx);
	int cyccnt = cycles(idx);
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
    1010:	ed9f 5b11 	vldr	d5, [pc, #68]	; 1058 <FTYK::print(int, String)+0x78>
    1014:	eeb8 7be7 	vcvt.f64.s32	d7, s15
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
    1018:	ed9f 4b11 	vldr	d4, [pc, #68]	; 1060 <FTYK::print(int, String)+0x80>

void FTYK::print(int idx, String title) {
	Serial.print(title); Serial.printf(" Timer %i\n", idx);
	int cyccnt = cycles(idx);
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
    101c:	ee27 7b05 	vmul.f64	d7, d7, d5
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
    1020:	ed9f 6b11 	vldr	d6, [pc, #68]	; 1068 <FTYK::print(int, String)+0x88>
    1024:	ed9f 3b12 	vldr	d3, [pc, #72]	; 1070 <FTYK::print(int, String)+0x90>

void FTYK::print(int idx, String title) {
	Serial.print(title); Serial.printf(" Timer %i\n", idx);
	int cyccnt = cycles(idx);
	float ns = CYCLES_2_NS(cyccnt);
	Serial.printf("%f s | %f ms | %f us | %f ns | %i cycles\n", 
    1028:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    102c:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
		NS_2_S(ns),
		NS_2_MS(ns),
		NS_2_US(ns),
		ns, cyccnt);
    1030:	ee87 5b06 	vdiv.f64	d5, d7, d6
    1034:	ee87 6b03 	vdiv.f64	d6, d7, d3
    1038:	ee87 3b04 	vdiv.f64	d3, d7, d4
    103c:	ed8d 7b04 	vstr	d7, [sp, #16]
    1040:	ed8d 5b02 	vstr	d5, [sp, #8]
    1044:	ed8d 6b00 	vstr	d6, [sp]
    1048:	ec53 2b13 	vmov	r2, r3, d3
    104c:	f001 ffce 	bl	2fec <Print::printf(char const*, ...)>
    1050:	b008      	add	sp, #32
    1052:	bd70      	pop	{r4, r5, r6, pc}
    1054:	f3af 8000 	nop.w
    1058:	aaaaaaab 	.word	0xaaaaaaab
    105c:	3ffaaaaa 	.word	0x3ffaaaaa
    1060:	00000000 	.word	0x00000000
    1064:	41cdcd65 	.word	0x41cdcd65
    1068:	00000000 	.word	0x00000000
    106c:	408f4000 	.word	0x408f4000
    1070:	00000000 	.word	0x00000000
    1074:	412e8480 	.word	0x412e8480
    1078:	20001474 	.word	0x20001474
    107c:	20000d68 	.word	0x20000d68
    1080:	e0001004 	.word	0xe0001004
    1084:	20000d3c 	.word	0x20000d3c

00001088 <Vector<int>::print()>:
}

/// print

template <> void Vector<int>::print() {
	if (length == 0) {
    1088:	6802      	ldr	r2, [r0, #0]
    108a:	b30a      	cbz	r2, 10d0 <Vector<int>::print()+0x48>
		Serial.printf("Vectori [%i]\n", length);
		return;
	}
	Serial.printf("Vectori [%i]: [", length);
    108c:	4912      	ldr	r1, [pc, #72]	; (10d8 <Vector<int>::print()+0x50>)
	from_array(data.as_array(), data.size());
}

/// print

template <> void Vector<int>::print() {
    108e:	b538      	push	{r3, r4, r5, lr}
    1090:	4605      	mov	r5, r0
	if (length == 0) {
		Serial.printf("Vectori [%i]\n", length);
		return;
	}
	Serial.printf("Vectori [%i]: [", length);
    1092:	4812      	ldr	r0, [pc, #72]	; (10dc <Vector<int>::print()+0x54>)
    1094:	f001 ffaa 	bl	2fec <Print::printf(char const*, ...)>
	for (int i = 0; i < length-1; i++) {
    1098:	682b      	ldr	r3, [r5, #0]
    109a:	2b01      	cmp	r3, #1
    109c:	dd0c      	ble.n	10b8 <Vector<int>::print()+0x30>
    109e:	2400      	movs	r4, #0
		Serial.printf("%i, ", buffer[i]);
    10a0:	686b      	ldr	r3, [r5, #4]
    10a2:	490f      	ldr	r1, [pc, #60]	; (10e0 <Vector<int>::print()+0x58>)
    10a4:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
	if (length == 0) {
		Serial.printf("Vectori [%i]\n", length);
		return;
	}
	Serial.printf("Vectori [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
    10a8:	3401      	adds	r4, #1
		Serial.printf("%i, ", buffer[i]);
    10aa:	480c      	ldr	r0, [pc, #48]	; (10dc <Vector<int>::print()+0x54>)
    10ac:	f001 ff9e 	bl	2fec <Print::printf(char const*, ...)>
	if (length == 0) {
		Serial.printf("Vectori [%i]\n", length);
		return;
	}
	Serial.printf("Vectori [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
    10b0:	682b      	ldr	r3, [r5, #0]
    10b2:	1e5a      	subs	r2, r3, #1
    10b4:	42a2      	cmp	r2, r4
    10b6:	dcf3      	bgt.n	10a0 <Vector<int>::print()+0x18>
		Serial.printf("%i, ", buffer[i]);
	}
	Serial.printf("%i]\n", buffer[length-1]);
    10b8:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
    10bc:	686c      	ldr	r4, [r5, #4]
    10be:	4909      	ldr	r1, [pc, #36]	; (10e4 <Vector<int>::print()+0x5c>)
    10c0:	441a      	add	r2, r3
    10c2:	4806      	ldr	r0, [pc, #24]	; (10dc <Vector<int>::print()+0x54>)
    10c4:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
}
    10c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	}
	Serial.printf("Vectori [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
		Serial.printf("%i, ", buffer[i]);
	}
	Serial.printf("%i]\n", buffer[length-1]);
    10cc:	f001 bf8e 	b.w	2fec <Print::printf(char const*, ...)>

/// print

template <> void Vector<int>::print() {
	if (length == 0) {
		Serial.printf("Vectori [%i]\n", length);
    10d0:	4905      	ldr	r1, [pc, #20]	; (10e8 <Vector<int>::print()+0x60>)
    10d2:	4802      	ldr	r0, [pc, #8]	; (10dc <Vector<int>::print()+0x54>)
    10d4:	f001 bf8a 	b.w	2fec <Print::printf(char const*, ...)>
    10d8:	20000d84 	.word	0x20000d84
    10dc:	20001474 	.word	0x20001474
    10e0:	20000d94 	.word	0x20000d94
    10e4:	20000d9c 	.word	0x20000d9c
    10e8:	20000d74 	.word	0x20000d74

000010ec <Vector<float>::print()>:
	}
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
	if (length == 0) {
    10ec:	6802      	ldr	r2, [r0, #0]
    10ee:	b352      	cbz	r2, 1146 <Vector<float>::print()+0x5a>
		Serial.printf("Vectorf [%i]\n", length);
		return;
	}
	Serial.printf("Vectorf [%i]: [", length);
    10f0:	4917      	ldr	r1, [pc, #92]	; (1150 <Vector<float>::print()+0x64>)
		Serial.printf("%i, ", buffer[i]);
	}
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
    10f2:	b570      	push	{r4, r5, r6, lr}
    10f4:	4605      	mov	r5, r0
	if (length == 0) {
		Serial.printf("Vectorf [%i]\n", length);
		return;
	}
	Serial.printf("Vectorf [%i]: [", length);
    10f6:	4817      	ldr	r0, [pc, #92]	; (1154 <Vector<float>::print()+0x68>)
    10f8:	f001 ff78 	bl	2fec <Print::printf(char const*, ...)>
	for (int i = 0; i < length-1; i++) {
    10fc:	682b      	ldr	r3, [r5, #0]
    10fe:	2b01      	cmp	r3, #1
    1100:	dd12      	ble.n	1128 <Vector<float>::print()+0x3c>
    1102:	2400      	movs	r4, #0
		Serial.printf("%f, ", buffer[i]);
    1104:	686b      	ldr	r3, [r5, #4]
    1106:	4914      	ldr	r1, [pc, #80]	; (1158 <Vector<float>::print()+0x6c>)
    1108:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    110c:	4811      	ldr	r0, [pc, #68]	; (1154 <Vector<float>::print()+0x68>)
	if (length == 0) {
		Serial.printf("Vectorf [%i]\n", length);
		return;
	}
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
    110e:	3401      	adds	r4, #1
		Serial.printf("%f, ", buffer[i]);
    1110:	edd3 7a00 	vldr	s15, [r3]
    1114:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
    1118:	ec53 2b17 	vmov	r2, r3, d7
    111c:	f001 ff66 	bl	2fec <Print::printf(char const*, ...)>
	if (length == 0) {
		Serial.printf("Vectorf [%i]\n", length);
		return;
	}
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
    1120:	682b      	ldr	r3, [r5, #0]
    1122:	1e5a      	subs	r2, r3, #1
    1124:	42a2      	cmp	r2, r4
    1126:	dced      	bgt.n	1104 <Vector<float>::print()+0x18>
		Serial.printf("%f, ", buffer[i]);
	}
	Serial.printf("%f]\n", buffer[length-1]);
    1128:	686a      	ldr	r2, [r5, #4]
    112a:	490c      	ldr	r1, [pc, #48]	; (115c <Vector<float>::print()+0x70>)
    112c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    1130:	4808      	ldr	r0, [pc, #32]	; (1154 <Vector<float>::print()+0x68>)
    1132:	ed53 7a01 	vldr	s15, [r3, #-4]
    1136:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
}
    113a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	}
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
		Serial.printf("%f, ", buffer[i]);
	}
	Serial.printf("%f]\n", buffer[length-1]);
    113e:	ec53 2b17 	vmov	r2, r3, d7
    1142:	f001 bf53 	b.w	2fec <Print::printf(char const*, ...)>
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
	if (length == 0) {
		Serial.printf("Vectorf [%i]\n", length);
    1146:	4906      	ldr	r1, [pc, #24]	; (1160 <Vector<float>::print()+0x74>)
    1148:	4802      	ldr	r0, [pc, #8]	; (1154 <Vector<float>::print()+0x68>)
    114a:	f001 bf4f 	b.w	2fec <Print::printf(char const*, ...)>
    114e:	bf00      	nop
    1150:	20000db4 	.word	0x20000db4
    1154:	20001474 	.word	0x20001474
    1158:	20000dc4 	.word	0x20000dc4
    115c:	20000be0 	.word	0x20000be0
    1160:	20000da4 	.word	0x20000da4

00001164 <Vector<int>::Vector()>:
#include "utilities/vector.h"
#include "system_graph/process.h"
#include "system_graph/graph_node.h"

template <typename T> Vector<T>::Vector() {
	length = 0;
    1164:	2200      	movs	r2, #0
    1166:	6002      	str	r2, [r0, #0]
	buffer = NULL;
    1168:	6042      	str	r2, [r0, #4]
}
    116a:	4770      	bx	lr

0000116c <Vector<int>::~Vector()>:

template <typename T> Vector<T>::~Vector() {
    116c:	b510      	push	{r4, lr}
    116e:	4604      	mov	r4, r0
	delete buffer;
    1170:	2104      	movs	r1, #4
    1172:	6840      	ldr	r0, [r0, #4]
    1174:	f001 fff4 	bl	3160 <operator delete(void*, unsigned int)>
}
    1178:	4620      	mov	r0, r4
    117a:	bd10      	pop	{r4, pc}

0000117c <Vector<int>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
    117c:	6802      	ldr	r2, [r0, #0]
    117e:	2100      	movs	r1, #0
    1180:	6840      	ldr	r0, [r0, #4]
    1182:	0092      	lsls	r2, r2, #2
    1184:	f005 be96 	b.w	6eb4 <memset>

00001188 <Vector<int>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    1188:	b538      	push	{r3, r4, r5, lr}
    118a:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    118c:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    118e:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    1190:	b110      	cbz	r0, 1198 <Vector<int>::reset(int)+0x10>
		delete buffer;
    1192:	2104      	movs	r1, #4
    1194:	f001 ffe4 	bl	3160 <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
    1198:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
    119c:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
    119e:	bf94      	ite	ls
    11a0:	00a0      	lslls	r0, r4, #2
    11a2:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
    11a6:	f001 ffd9 	bl	315c <operator new[](unsigned int)>
    11aa:	6068      	str	r0, [r5, #4]
	clear();
    11ac:	4628      	mov	r0, r5
    11ae:	f7ff ffe5 	bl	117c <Vector<int>::clear()>
    11b2:	bd38      	pop	{r3, r4, r5, pc}

000011b4 <Vector<int>::from_array(int*, int)>:
}

template <typename T> void Vector<T>::from_array(T* data, int size) {
    11b4:	b570      	push	{r4, r5, r6, lr}
    11b6:	4614      	mov	r4, r2
    11b8:	460e      	mov	r6, r1
    11ba:	4605      	mov	r5, r0
		  reset the buffer to size n with data T*.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
    11bc:	4611      	mov	r1, r2
    11be:	f7ff ffe3 	bl	1188 <Vector<int>::reset(int)>
	memcpy(buffer, data, size * sizeof(T));
    11c2:	4631      	mov	r1, r6
    11c4:	00a2      	lsls	r2, r4, #2
    11c6:	6868      	ldr	r0, [r5, #4]
}
    11c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
	memcpy(buffer, data, size * sizeof(T));
    11cc:	f005 bd74 	b.w	6cb8 <memcpy>

000011d0 <Vector<int>::push(int)>:
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    11d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    11d4:	6805      	ldr	r5, [r0, #0]
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    11d6:	af00      	add	r7, sp, #0
    11d8:	4604      	mov	r4, r0
    11da:	4688      	mov	r8, r1
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    11dc:	1c6e      	adds	r6, r5, #1
	memcpy(tmp, buffer, length * sizeof(T));
    11de:	6841      	ldr	r1, [r0, #4]
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    11e0:	00b2      	lsls	r2, r6, #2
    11e2:	f102 030a 	add.w	r3, r2, #10
	memcpy(tmp, buffer, length * sizeof(T));
    11e6:	3a04      	subs	r2, #4
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    11e8:	f023 0307 	bic.w	r3, r3, #7
    11ec:	ebad 0d03 	sub.w	sp, sp, r3
	memcpy(tmp, buffer, length * sizeof(T));
    11f0:	4668      	mov	r0, sp
    11f2:	f005 fd61 	bl	6cb8 <memcpy>
    11f6:	4603      	mov	r3, r0
	tmp[length] = item;
	from_array(tmp, length+1);
    11f8:	4601      	mov	r1, r0
    11fa:	4632      	mov	r2, r6
    11fc:	4620      	mov	r0, r4
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
    11fe:	f843 8025 	str.w	r8, [r3, r5, lsl #2]
	from_array(tmp, length+1);
    1202:	f7ff ffd7 	bl	11b4 <Vector<int>::from_array(int*, int)>
}
    1206:	46bd      	mov	sp, r7
    1208:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000120c <Vector<int>::size()>:
		  Get the size of buffer (not necessarily elements available)
		@return
			length: (int) size of buffer
	*/
	return length;
}
    120c:	6800      	ldr	r0, [r0, #0]
    120e:	4770      	bx	lr

00001210 <Vector<int>::find(int)>:

template <typename T> int Vector<T>::find(T data) {
    1210:	b410      	push	{r4}
	/*
		  Get the first index of an item in the buffer
		@return
			data: (T) item to search for (-1 if not found, maybe causes template issues)
	*/
	for (int i = 0; i < length; i++) {
    1212:	6804      	ldr	r4, [r0, #0]
    1214:	2c00      	cmp	r4, #0
    1216:	dd0c      	ble.n	1232 <Vector<int>::find(int)+0x22>
		if (buffer[i] == data) {
    1218:	6843      	ldr	r3, [r0, #4]
	/*
		  Get the first index of an item in the buffer
		@return
			data: (T) item to search for (-1 if not found, maybe causes template issues)
	*/
	for (int i = 0; i < length; i++) {
    121a:	2000      	movs	r0, #0
		if (buffer[i] == data) {
    121c:	681a      	ldr	r2, [r3, #0]
    121e:	4291      	cmp	r1, r2
    1220:	d104      	bne.n	122c <Vector<int>::find(int)+0x1c>
    1222:	e008      	b.n	1236 <Vector<int>::find(int)+0x26>
    1224:	f853 2f04 	ldr.w	r2, [r3, #4]!
    1228:	428a      	cmp	r2, r1
    122a:	d004      	beq.n	1236 <Vector<int>::find(int)+0x26>
	/*
		  Get the first index of an item in the buffer
		@return
			data: (T) item to search for (-1 if not found, maybe causes template issues)
	*/
	for (int i = 0; i < length; i++) {
    122c:	3001      	adds	r0, #1
    122e:	42a0      	cmp	r0, r4
    1230:	d1f8      	bne.n	1224 <Vector<int>::find(int)+0x14>
		if (buffer[i] == data) {
			return i;
		}
	}
	return -1;
    1232:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    1236:	f85d 4b04 	ldr.w	r4, [sp], #4
    123a:	4770      	bx	lr

0000123c <Vector<int>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
    123c:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
    123e:	6803      	ldr	r3, [r0, #0]
    1240:	428b      	cmp	r3, r1
    1242:	dd05      	ble.n	1250 <Vector<int>::operator[](int)+0x14>
    1244:	2900      	cmp	r1, #0
    1246:	db03      	blt.n	1250 <Vector<int>::operator[](int)+0x14>
		return buffer[index];
    1248:	6840      	ldr	r0, [r0, #4]
    124a:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
    124e:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
    1250:	2000      	movs	r0, #0
    1252:	f005 fa1b 	bl	668c <exit>
    1256:	bf00      	nop

00001258 <Vector<float>::Vector()>:
#include "utilities/vector.h"
#include "system_graph/process.h"
#include "system_graph/graph_node.h"

template <typename T> Vector<T>::Vector() {
	length = 0;
    1258:	2200      	movs	r2, #0
    125a:	6002      	str	r2, [r0, #0]
	buffer = NULL;
    125c:	6042      	str	r2, [r0, #4]
}
    125e:	4770      	bx	lr

00001260 <Vector<float>::~Vector()>:

template <typename T> Vector<T>::~Vector() {
    1260:	b510      	push	{r4, lr}
    1262:	4604      	mov	r4, r0
	delete buffer;
    1264:	2104      	movs	r1, #4
    1266:	6840      	ldr	r0, [r0, #4]
    1268:	f001 ff7a 	bl	3160 <operator delete(void*, unsigned int)>
}
    126c:	4620      	mov	r0, r4
    126e:	bd10      	pop	{r4, pc}

00001270 <Vector<float>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
    1270:	6802      	ldr	r2, [r0, #0]
    1272:	2100      	movs	r1, #0
    1274:	6840      	ldr	r0, [r0, #4]
    1276:	0092      	lsls	r2, r2, #2
    1278:	f005 be1c 	b.w	6eb4 <memset>

0000127c <Vector<float>::Vector(int)>:
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
	buffer = new T[size];
    127c:	f1b1 5ffe 	cmp.w	r1, #532676608	; 0x1fc00000

template <typename T> Vector<T>::~Vector() {
	delete buffer;
}

template <typename T> Vector<T>::Vector(int size) {
    1280:	b510      	push	{r4, lr}
    1282:	4604      	mov	r4, r0
	/*
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
    1284:	6001      	str	r1, [r0, #0]
	buffer = new T[size];
    1286:	bf94      	ite	ls
    1288:	0088      	lslls	r0, r1, #2
    128a:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
    128e:	f001 ff65 	bl	315c <operator new[](unsigned int)>
    1292:	6060      	str	r0, [r4, #4]
	clear();
    1294:	4620      	mov	r0, r4
    1296:	f7ff ffeb 	bl	1270 <Vector<float>::clear()>
}
    129a:	4620      	mov	r0, r4
    129c:	bd10      	pop	{r4, pc}
    129e:	bf00      	nop

000012a0 <Vector<float>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    12a0:	b538      	push	{r3, r4, r5, lr}
    12a2:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    12a4:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    12a6:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    12a8:	b110      	cbz	r0, 12b0 <Vector<float>::reset(int)+0x10>
		delete buffer;
    12aa:	2104      	movs	r1, #4
    12ac:	f001 ff58 	bl	3160 <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
    12b0:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
    12b4:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
    12b6:	bf94      	ite	ls
    12b8:	00a0      	lslls	r0, r4, #2
    12ba:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
    12be:	f001 ff4d 	bl	315c <operator new[](unsigned int)>
    12c2:	6068      	str	r0, [r5, #4]
	clear();
    12c4:	4628      	mov	r0, r5
    12c6:	f7ff ffd3 	bl	1270 <Vector<float>::clear()>
    12ca:	bd38      	pop	{r3, r4, r5, pc}

000012cc <Vector<float>::from_array(float*, int)>:
}

template <typename T> void Vector<T>::from_array(T* data, int size) {
    12cc:	b570      	push	{r4, r5, r6, lr}
    12ce:	4614      	mov	r4, r2
    12d0:	460e      	mov	r6, r1
    12d2:	4605      	mov	r5, r0
		  reset the buffer to size n with data T*.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
    12d4:	4611      	mov	r1, r2
    12d6:	f7ff ffe3 	bl	12a0 <Vector<float>::reset(int)>
	memcpy(buffer, data, size * sizeof(T));
    12da:	4631      	mov	r1, r6
    12dc:	00a2      	lsls	r2, r4, #2
    12de:	6868      	ldr	r0, [r5, #4]
}
    12e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
	memcpy(buffer, data, size * sizeof(T));
    12e4:	f005 bce8 	b.w	6cb8 <memcpy>

000012e8 <Vector<float>::push(float)>:
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    12e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    12ea:	6806      	ldr	r6, [r0, #0]
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    12ec:	4604      	mov	r4, r0
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
    12ee:	6841      	ldr	r1, [r0, #4]
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    12f0:	1c75      	adds	r5, r6, #1
    12f2:	00aa      	lsls	r2, r5, #2
    12f4:	f102 000a 	add.w	r0, r2, #10
	memcpy(tmp, buffer, length * sizeof(T));
    12f8:	3a04      	subs	r2, #4
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    12fa:	f020 0007 	bic.w	r0, r0, #7
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    12fe:	ed2d 8b02 	vpush	{d8}
    1302:	af00      	add	r7, sp, #0
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    1304:	ebad 0d00 	sub.w	sp, sp, r0
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    1308:	eeb0 8a40 	vmov.f32	s16, s0
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
    130c:	4668      	mov	r0, sp
    130e:	f005 fcd3 	bl	6cb8 <memcpy>
	tmp[length] = item;
	from_array(tmp, length+1);
    1312:	462a      	mov	r2, r5
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
    1314:	eb00 0386 	add.w	r3, r0, r6, lsl #2
	from_array(tmp, length+1);
    1318:	4601      	mov	r1, r0
    131a:	4620      	mov	r0, r4
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
    131c:	ed83 8a00 	vstr	s16, [r3]
	from_array(tmp, length+1);
    1320:	f7ff ffd4 	bl	12cc <Vector<float>::from_array(float*, int)>
}
    1324:	46bd      	mov	sp, r7
    1326:	ecbd 8b02 	vpop	{d8}
    132a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000132c <Vector<float>::size()>:
		  Get the size of buffer (not necessarily elements available)
		@return
			length: (int) size of buffer
	*/
	return length;
}
    132c:	6800      	ldr	r0, [r0, #0]
    132e:	4770      	bx	lr

00001330 <Vector<float>::as_array()>:
	return -1;
}

template <typename T> T* Vector<T>::as_array() {
	return buffer;
}
    1330:	6840      	ldr	r0, [r0, #4]
    1332:	4770      	bx	lr

00001334 <Vector<float>::append(Vector<float>*)>:
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
    1334:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		  Add n values to the buffer. Stores the current buffer and
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
    1338:	f8d0 8000 	ldr.w	r8, [r0]
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
    133c:	af00      	add	r7, sp, #0
    133e:	4604      	mov	r4, r0
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();
    1340:	4608      	mov	r0, r1

	T tmp1[n];
    1342:	ea4f 0588 	mov.w	r5, r8, lsl #2
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
    1346:	4689      	mov	r9, r1
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();
    1348:	f7ff fff0 	bl	132c <Vector<float>::size()>
    134c:	4606      	mov	r6, r0

	T tmp1[n];
    134e:	f105 030a 	add.w	r3, r5, #10
	T* tmp2 = data->as_array();
    1352:	4648      	mov	r0, r9
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();

	T tmp1[n];
    1354:	f023 0307 	bic.w	r3, r3, #7
    1358:	ebad 0d03 	sub.w	sp, sp, r3
	T* tmp2 = data->as_array();
    135c:	f7ff ffe8 	bl	1330 <Vector<float>::as_array()>

	reset(n + m);
    1360:	eb08 0106 	add.w	r1, r8, r6
	*/
	int n = length;
	int m = data->size();

	T tmp1[n];
	T* tmp2 = data->as_array();
    1364:	4681      	mov	r9, r0

	reset(n + m);
    1366:	4620      	mov	r0, r4
    1368:	f7ff ff9a 	bl	12a0 <Vector<float>::reset(int)>
	memcpy(buffer, tmp1, n * sizeof(T));
    136c:	462a      	mov	r2, r5
    136e:	4669      	mov	r1, sp
    1370:	6860      	ldr	r0, [r4, #4]
    1372:	f005 fca1 	bl	6cb8 <memcpy>
	memcpy(&buffer[n], tmp2, m * sizeof(T));
    1376:	6860      	ldr	r0, [r4, #4]
    1378:	00b2      	lsls	r2, r6, #2
    137a:	4649      	mov	r1, r9
    137c:	4428      	add	r0, r5
    137e:	f005 fc9b 	bl	6cb8 <memcpy>
}
    1382:	46bd      	mov	sp, r7
    1384:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00001388 <Vector<float>::insert(float*, int, int)>:

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
    1388:	b5f0      	push	{r4, r5, r6, r7, lr}
    138a:	461d      	mov	r5, r3
    138c:	460c      	mov	r4, r1
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
    138e:	6803      	ldr	r3, [r0, #0]
	reset(n + m);
	memcpy(buffer, tmp1, n * sizeof(T));
	memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
    1390:	b083      	sub	sp, #12
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
    1392:	1951      	adds	r1, r2, r5
	reset(n + m);
	memcpy(buffer, tmp1, n * sizeof(T));
	memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
    1394:	4606      	mov	r6, r0
    1396:	4617      	mov	r7, r2
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
    1398:	4299      	cmp	r1, r3
    139a:	dc0f      	bgt.n	13bc <Vector<float>::insert(float*, int, int)+0x34>
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
    139c:	2d00      	cmp	r5, #0
    139e:	dd0b      	ble.n	13b8 <Vector<float>::insert(float*, int, int)+0x30>
    13a0:	6870      	ldr	r0, [r6, #4]
    13a2:	4621      	mov	r1, r4
    13a4:	eb04 0385 	add.w	r3, r4, r5, lsl #2
    13a8:	eb00 0287 	add.w	r2, r0, r7, lsl #2
		buffer[i + index] = data[i];
    13ac:	f851 0b04 	ldr.w	r0, [r1], #4
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
    13b0:	428b      	cmp	r3, r1
		buffer[i + index] = data[i];
    13b2:	f842 0b04 	str.w	r0, [r2], #4
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
    13b6:	d1f9      	bne.n	13ac <Vector<float>::insert(float*, int, int)+0x24>
		buffer[i + index] = data[i];
	}
}
    13b8:	b003      	add	sp, #12
    13ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
    13bc:	1ac9      	subs	r1, r1, r3
    13be:	4668      	mov	r0, sp
    13c0:	f7ff ff5c 	bl	127c <Vector<float>::Vector(int)>
		append(&empty);
    13c4:	4630      	mov	r0, r6
    13c6:	4669      	mov	r1, sp
    13c8:	f7ff ffb4 	bl	1334 <Vector<float>::append(Vector<float>*)>
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
    13cc:	4668      	mov	r0, sp
    13ce:	f7ff ff47 	bl	1260 <Vector<float>::~Vector()>
    13d2:	e7e3      	b.n	139c <Vector<float>::insert(float*, int, int)+0x14>

000013d4 <Vector<float>::slice(float*, int, int)>:

template <typename T> T* Vector<T>::as_array() {
	return buffer;
}

template <typename T> void Vector<T>::slice(T* data, int start, int n) {
    13d4:	b430      	push	{r4, r5}
		@return
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
    13d6:	1e14      	subs	r4, r2, #0
    13d8:	db03      	blt.n	13e2 <Vector<float>::slice(float*, int, int)+0xe>
    13da:	18e2      	adds	r2, r4, r3
    13dc:	6805      	ldr	r5, [r0, #0]
    13de:	42aa      	cmp	r2, r5
    13e0:	dd05      	ble.n	13ee <Vector<float>::slice(float*, int, int)+0x1a>
		memcpy(data, &buffer[start], n * sizeof(T));
	}
	else {
		memset(data, 0, n * sizeof(T));
    13e2:	4608      	mov	r0, r1
    13e4:	009a      	lsls	r2, r3, #2
    13e6:	2100      	movs	r1, #0
	}
}
    13e8:	bc30      	pop	{r4, r5}
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
	}
	else {
		memset(data, 0, n * sizeof(T));
    13ea:	f005 bd63 	b.w	6eb4 <memset>
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
    13ee:	6845      	ldr	r5, [r0, #4]
    13f0:	009a      	lsls	r2, r3, #2
    13f2:	4608      	mov	r0, r1
    13f4:	eb05 0184 	add.w	r1, r5, r4, lsl #2
	}
	else {
		memset(data, 0, n * sizeof(T));
	}
}
    13f8:	bc30      	pop	{r4, r5}
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
    13fa:	f005 bc5d 	b.w	6cb8 <memcpy>
    13fe:	bf00      	nop

00001400 <Vector<float>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
    1400:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
    1402:	6803      	ldr	r3, [r0, #0]
    1404:	428b      	cmp	r3, r1
    1406:	dd05      	ble.n	1414 <Vector<float>::operator[](int)+0x14>
    1408:	2900      	cmp	r1, #0
    140a:	db03      	blt.n	1414 <Vector<float>::operator[](int)+0x14>
		return buffer[index];
    140c:	6840      	ldr	r0, [r0, #4]
    140e:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
    1412:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
    1414:	2000      	movs	r0, #0
    1416:	f005 f939 	bl	668c <exit>
    141a:	bf00      	nop

0000141c <Vector<GraphNode*>::Vector()>:
#include "utilities/vector.h"
#include "system_graph/process.h"
#include "system_graph/graph_node.h"

template <typename T> Vector<T>::Vector() {
	length = 0;
    141c:	2200      	movs	r2, #0
    141e:	6002      	str	r2, [r0, #0]
	buffer = NULL;
    1420:	6042      	str	r2, [r0, #4]
}
    1422:	4770      	bx	lr

00001424 <Vector<GraphNode*>::~Vector()>:

template <typename T> Vector<T>::~Vector() {
    1424:	b510      	push	{r4, lr}
    1426:	4604      	mov	r4, r0
	delete buffer;
    1428:	2104      	movs	r1, #4
    142a:	6840      	ldr	r0, [r0, #4]
    142c:	f001 fe98 	bl	3160 <operator delete(void*, unsigned int)>
}
    1430:	4620      	mov	r0, r4
    1432:	bd10      	pop	{r4, pc}

00001434 <Vector<GraphNode*>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
    1434:	6802      	ldr	r2, [r0, #0]
    1436:	2100      	movs	r1, #0
    1438:	6840      	ldr	r0, [r0, #4]
    143a:	0092      	lsls	r2, r2, #2
    143c:	f005 bd3a 	b.w	6eb4 <memset>

00001440 <Vector<GraphNode*>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    1440:	b538      	push	{r3, r4, r5, lr}
    1442:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    1444:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
    1446:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
    1448:	b110      	cbz	r0, 1450 <Vector<GraphNode*>::reset(int)+0x10>
		delete buffer;
    144a:	2104      	movs	r1, #4
    144c:	f001 fe88 	bl	3160 <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
    1450:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
    1454:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
    1456:	bf94      	ite	ls
    1458:	00a0      	lslls	r0, r4, #2
    145a:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
    145e:	f001 fe7d 	bl	315c <operator new[](unsigned int)>
    1462:	6068      	str	r0, [r5, #4]
	clear();
    1464:	4628      	mov	r0, r5
    1466:	f7ff ffe5 	bl	1434 <Vector<GraphNode*>::clear()>
    146a:	bd38      	pop	{r3, r4, r5, pc}

0000146c <Vector<GraphNode*>::from_array(GraphNode**, int)>:
}

template <typename T> void Vector<T>::from_array(T* data, int size) {
    146c:	b570      	push	{r4, r5, r6, lr}
    146e:	4614      	mov	r4, r2
    1470:	460e      	mov	r6, r1
    1472:	4605      	mov	r5, r0
		  reset the buffer to size n with data T*.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
    1474:	4611      	mov	r1, r2
    1476:	f7ff ffe3 	bl	1440 <Vector<GraphNode*>::reset(int)>
	memcpy(buffer, data, size * sizeof(T));
    147a:	4631      	mov	r1, r6
    147c:	00a2      	lsls	r2, r4, #2
    147e:	6868      	ldr	r0, [r5, #4]
}
    1480:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
	memcpy(buffer, data, size * sizeof(T));
    1484:	f005 bc18 	b.w	6cb8 <memcpy>

00001488 <Vector<GraphNode*>::push(GraphNode*)>:
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    1488:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    148c:	6805      	ldr	r5, [r0, #0]
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
    148e:	af00      	add	r7, sp, #0
    1490:	4604      	mov	r4, r0
    1492:	4688      	mov	r8, r1
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    1494:	1c6e      	adds	r6, r5, #1
	memcpy(tmp, buffer, length * sizeof(T));
    1496:	6841      	ldr	r1, [r0, #4]
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    1498:	00b2      	lsls	r2, r6, #2
    149a:	f102 030a 	add.w	r3, r2, #10
	memcpy(tmp, buffer, length * sizeof(T));
    149e:	3a04      	subs	r2, #4
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
    14a0:	f023 0307 	bic.w	r3, r3, #7
    14a4:	ebad 0d03 	sub.w	sp, sp, r3
	memcpy(tmp, buffer, length * sizeof(T));
    14a8:	4668      	mov	r0, sp
    14aa:	f005 fc05 	bl	6cb8 <memcpy>
    14ae:	4603      	mov	r3, r0
	tmp[length] = item;
	from_array(tmp, length+1);
    14b0:	4601      	mov	r1, r0
    14b2:	4632      	mov	r2, r6
    14b4:	4620      	mov	r0, r4
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
    14b6:	f843 8025 	str.w	r8, [r3, r5, lsl #2]
	from_array(tmp, length+1);
    14ba:	f7ff ffd7 	bl	146c <Vector<GraphNode*>::from_array(GraphNode**, int)>
}
    14be:	46bd      	mov	sp, r7
    14c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000014c4 <Vector<GraphNode*>::size()>:
		  Get the size of buffer (not necessarily elements available)
		@return
			length: (int) size of buffer
	*/
	return length;
}
    14c4:	6800      	ldr	r0, [r0, #0]
    14c6:	4770      	bx	lr

000014c8 <Vector<GraphNode*>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
    14c8:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
    14ca:	6803      	ldr	r3, [r0, #0]
    14cc:	428b      	cmp	r3, r1
    14ce:	dd05      	ble.n	14dc <Vector<GraphNode*>::operator[](int)+0x14>
    14d0:	2900      	cmp	r1, #0
    14d2:	db03      	blt.n	14dc <Vector<GraphNode*>::operator[](int)+0x14>
		return buffer[index];
    14d4:	6840      	ldr	r0, [r0, #4]
    14d6:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
    14da:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
    14dc:	2000      	movs	r0, #0
    14de:	f005 f8d5 	bl	668c <exit>
    14e2:	bf00      	nop

000014e4 <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    14e4:	4a96      	ldr	r2, [pc, #600]	; (1740 <set_arm_clock+0x25c>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    14e6:	4b97      	ldr	r3, [pc, #604]	; (1744 <set_arm_clock+0x260>)
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    14e8:	4290      	cmp	r0, r2
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
    14ea:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;
    14ee:	4c96      	ldr	r4, [pc, #600]	; (1748 <set_arm_clock+0x264>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    14f0:	f8d3 e014 	ldr.w	lr, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    14f4:	6999      	ldr	r1, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    14f6:	68e6      	ldr	r6, [r4, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    14f8:	d91c      	bls.n	1534 <set_arm_clock+0x50>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    14fa:	4b94      	ldr	r3, [pc, #592]	; (174c <set_arm_clock+0x268>)
    14fc:	4298      	cmp	r0, r3
    14fe:	f240 8115 	bls.w	172c <set_arm_clock+0x248>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    1502:	4b93      	ldr	r3, [pc, #588]	; (1750 <set_arm_clock+0x26c>)
    1504:	f240 6527 	movw	r5, #1575	; 0x627
    1508:	4f92      	ldr	r7, [pc, #584]	; (1754 <set_arm_clock+0x270>)
    150a:	4403      	add	r3, r0
    150c:	4c92      	ldr	r4, [pc, #584]	; (1758 <set_arm_clock+0x274>)
    150e:	0a1a      	lsrs	r2, r3, #8
    1510:	fba7 3202 	umull	r3, r2, r7, r2
    1514:	09d3      	lsrs	r3, r2, #7
    1516:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    151a:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    151e:	f202 43e2 	addw	r3, r2, #1250	; 0x4e2
    1522:	42ab      	cmp	r3, r5
    1524:	bf28      	it	cs
    1526:	462b      	movcs	r3, r5
    1528:	f5a3 7348 	sub.w	r3, r3, #800	; 0x320
    152c:	fba4 3503 	umull	r3, r5, r4, r3
    1530:	08ed      	lsrs	r5, r5, #3
    1532:	e004      	b.n	153e <set_arm_clock+0x5a>
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
		}
#endif
	} else if (frequency <= 24000000) {
    1534:	4d89      	ldr	r5, [pc, #548]	; (175c <set_arm_clock+0x278>)
    1536:	42a8      	cmp	r0, r5
    1538:	bf94      	ite	ls
    153a:	2506      	movls	r5, #6
    153c:	250e      	movhi	r5, #14
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    153e:	4a81      	ldr	r2, [pc, #516]	; (1744 <set_arm_clock+0x260>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    1540:	f006 071f 	and.w	r7, r6, #31
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    1544:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    1548:	42af      	cmp	r7, r5
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    154a:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    154e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    1552:	d20a      	bcs.n	156a <set_arm_clock+0x86>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    1554:	4b7c      	ldr	r3, [pc, #496]	; (1748 <set_arm_clock+0x264>)

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    1556:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    155a:	461a      	mov	r2, r3
	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    155c:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
    155e:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    1560:	6813      	ldr	r3, [r2, #0]
    1562:	2b00      	cmp	r3, #0
    1564:	dafc      	bge.n	1560 <set_arm_clock+0x7c>
    1566:	f006 071f 	and.w	r7, r6, #31
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    156a:	f01e 7300 	ands.w	r3, lr, #33554432	; 0x2000000
    156e:	d131      	bne.n	15d4 <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    1570:	4c7b      	ldr	r4, [pc, #492]	; (1760 <set_arm_clock+0x27c>)
    1572:	4a7c      	ldr	r2, [pc, #496]	; (1764 <set_arm_clock+0x280>)
    1574:	f8d4 c010 	ldr.w	ip, [r4, #16]
    1578:	4614      	mov	r4, r2
    157a:	ea0c 0202 	and.w	r2, ip, r2
    157e:	42a2      	cmp	r2, r4
    1580:	bf0a      	itet	eq
    1582:	f04f 53c0 	moveq.w	r3, #402653184	; 0x18000000
    1586:	f44f 5280 	movne.w	r2, #4096	; 0x1000
    158a:	2200      	moveq	r2, #0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    158c:	ea8e 0403 	eor.w	r4, lr, r3
    1590:	f014 5f60 	tst.w	r4, #939524096	; 0x38000000
    1594:	d008      	beq.n	15a8 <set_arm_clock+0xc4>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    1596:	f02e 5e60 	bic.w	lr, lr, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    159a:	f003 5360 	and.w	r3, r3, #939524096	; 0x38000000
			CCM_CBCDR = cbcdr;
    159e:	4c69      	ldr	r4, [pc, #420]	; (1744 <set_arm_clock+0x260>)
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    15a0:	ea43 0e0e 	orr.w	lr, r3, lr
			CCM_CBCDR = cbcdr;
    15a4:	f8c4 e014 	str.w	lr, [r4, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    15a8:	ea81 0302 	eor.w	r3, r1, r2
    15ac:	f413 5f40 	tst.w	r3, #12288	; 0x3000
    15b0:	d008      	beq.n	15c4 <set_arm_clock+0xe0>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    15b2:	4b64      	ldr	r3, [pc, #400]	; (1744 <set_arm_clock+0x260>)
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
			CCM_CBCDR = cbcdr;
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    15b4:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    15b8:	4311      	orrs	r1, r2
			CCM_CBCMR = cbcmr;
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    15ba:	461a      	mov	r2, r3
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    15bc:	6199      	str	r1, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    15be:	6c93      	ldr	r3, [r2, #72]	; 0x48
    15c0:	071c      	lsls	r4, r3, #28
    15c2:	d4fc      	bmi.n	15be <set_arm_clock+0xda>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    15c4:	f04e 7e00 	orr.w	lr, lr, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    15c8:	4a5e      	ldr	r2, [pc, #376]	; (1744 <set_arm_clock+0x260>)
    15ca:	f8c2 e014 	str.w	lr, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    15ce:	6c93      	ldr	r3, [r2, #72]	; 0x48
    15d0:	0699      	lsls	r1, r3, #26
    15d2:	d4fc      	bmi.n	15ce <set_arm_clock+0xea>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
    15d4:	2101      	movs	r1, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    15d6:	4c64      	ldr	r4, [pc, #400]	; (1768 <set_arm_clock+0x284>)
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
    15d8:	460a      	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    15da:	fb01 f302 	mul.w	r3, r1, r2
    15de:	fb00 f303 	mul.w	r3, r0, r3
    15e2:	42a3      	cmp	r3, r4
    15e4:	d809      	bhi.n	15fa <set_arm_clock+0x116>
		if (div_arm < 8) {
    15e6:	2a07      	cmp	r2, #7
    15e8:	f200 8095 	bhi.w	1716 <set_arm_clock+0x232>
			div_arm = div_arm + 1;
    15ec:	3201      	adds	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    15ee:	fb01 f302 	mul.w	r3, r1, r2
    15f2:	fb00 f303 	mul.w	r3, r0, r3
    15f6:	42a3      	cmp	r3, r4
    15f8:	d9f5      	bls.n	15e6 <set_arm_clock+0x102>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    15fa:	485c      	ldr	r0, [pc, #368]	; (176c <set_arm_clock+0x288>)
    15fc:	4c5c      	ldr	r4, [pc, #368]	; (1770 <set_arm_clock+0x28c>)
    15fe:	4418      	add	r0, r3
    1600:	fba4 0300 	umull	r0, r3, r4, r0
    1604:	0d1b      	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
    1606:	2b6c      	cmp	r3, #108	; 0x6c
    1608:	f200 808b 	bhi.w	1722 <set_arm_clock+0x23e>
	if (mult < 54) mult = 54;
    160c:	2b35      	cmp	r3, #53	; 0x35
    160e:	f200 808f 	bhi.w	1730 <set_arm_clock+0x24c>
    1612:	f8df 8188 	ldr.w	r8, [pc, #392]	; 179c <set_arm_clock+0x2b8>
    1616:	2336      	movs	r3, #54	; 0x36
    1618:	4856      	ldr	r0, [pc, #344]	; (1774 <set_arm_clock+0x290>)

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    161a:	f8df c144 	ldr.w	ip, [pc, #324]	; 1760 <set_arm_clock+0x27c>
    161e:	4c56      	ldr	r4, [pc, #344]	; (1778 <set_arm_clock+0x294>)
    1620:	f8dc 9000 	ldr.w	r9, [ip]
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    1624:	fbb0 f0f2 	udiv	r0, r0, r2

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    1628:	ea09 0404 	and.w	r4, r9, r4
    162c:	4544      	cmp	r4, r8
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    162e:	fbb0 f0f1 	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    1632:	d00b      	beq.n	164c <set_arm_clock+0x168>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    1634:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    1638:	f44f 5880 	mov.w	r8, #4096	; 0x1000
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    163c:	4664      	mov	r4, ip
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    163e:	f8cc 8000 	str.w	r8, [ip]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    1642:	f8cc 3000 	str.w	r3, [ip]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    1646:	6823      	ldr	r3, [r4, #0]
    1648:	2b00      	cmp	r3, #0
    164a:	dafc      	bge.n	1646 <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    164c:	f8df c0f4 	ldr.w	ip, [pc, #244]	; 1744 <set_arm_clock+0x260>
    1650:	3a01      	subs	r2, #1
    1652:	f8dc 3010 	ldr.w	r3, [ip, #16]
    1656:	f003 0307 	and.w	r3, r3, #7
    165a:	4293      	cmp	r3, r2
    165c:	d007      	beq.n	166e <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    165e:	f002 0207 	and.w	r2, r2, #7
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    1662:	4664      	mov	r4, ip
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    1664:	f8cc 2010 	str.w	r2, [ip, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    1668:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    166a:	03db      	lsls	r3, r3, #15
    166c:	d4fc      	bmi.n	1668 <set_arm_clock+0x184>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    166e:	3901      	subs	r1, #1
    1670:	0289      	lsls	r1, r1, #10
    1672:	ea8e 0301 	eor.w	r3, lr, r1
    1676:	f413 5fe0 	tst.w	r3, #7168	; 0x1c00
    167a:	d00c      	beq.n	1696 <set_arm_clock+0x1b2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
		CCM_CBCDR = cbcdr;
    167c:	4b31      	ldr	r3, [pc, #196]	; (1744 <set_arm_clock+0x260>)
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    167e:	f42e 5ee0 	bic.w	lr, lr, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    1682:	f401 51e0 	and.w	r1, r1, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    1686:	461a      	mov	r2, r3
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    1688:	ea41 0e0e 	orr.w	lr, r1, lr
		CCM_CBCDR = cbcdr;
    168c:	f8c3 e014 	str.w	lr, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    1690:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1692:	0799      	lsls	r1, r3, #30
    1694:	d4fc      	bmi.n	1690 <set_arm_clock+0x1ac>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    1696:	4b39      	ldr	r3, [pc, #228]	; (177c <set_arm_clock+0x298>)
    1698:	4939      	ldr	r1, [pc, #228]	; (1780 <set_arm_clock+0x29c>)
    169a:	4403      	add	r3, r0
    169c:	09db      	lsrs	r3, r3, #7
    169e:	fba1 3103 	umull	r3, r1, r1, r3
    16a2:	0b09      	lsrs	r1, r1, #12
    16a4:	2904      	cmp	r1, #4
    16a6:	bf28      	it	cs
    16a8:	2104      	movcs	r1, #4
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    16aa:	1e4b      	subs	r3, r1, #1
    16ac:	021b      	lsls	r3, r3, #8
    16ae:	ea8e 0203 	eor.w	r2, lr, r3
    16b2:	f412 7f40 	tst.w	r2, #768	; 0x300
    16b6:	d007      	beq.n	16c8 <set_arm_clock+0x1e4>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    16b8:	f42e 7e40 	bic.w	lr, lr, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    16bc:	f403 7340 	and.w	r3, r3, #768	; 0x300
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    16c0:	4a20      	ldr	r2, [pc, #128]	; (1744 <set_arm_clock+0x260>)

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    16c2:	ea43 030e 	orr.w	r3, r3, lr
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    16c6:	6153      	str	r3, [r2, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    16c8:	4b1e      	ldr	r3, [pc, #120]	; (1744 <set_arm_clock+0x260>)
    16ca:	695c      	ldr	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    16cc:	461a      	mov	r2, r3
		CCM_CBCDR = cbcdr;
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    16ce:	f024 7400 	bic.w	r4, r4, #33554432	; 0x2000000
    16d2:	615c      	str	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    16d4:	6c93      	ldr	r3, [r2, #72]	; 0x48
    16d6:	069b      	lsls	r3, r3, #26
    16d8:	d4fc      	bmi.n	16d4 <set_arm_clock+0x1f0>

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    16da:	4b2a      	ldr	r3, [pc, #168]	; (1784 <set_arm_clock+0x2a0>)
    16dc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    16e0:	4c29      	ldr	r4, [pc, #164]	; (1788 <set_arm_clock+0x2a4>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    16e2:	42bd      	cmp	r5, r7
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    16e4:	fba3 e300 	umull	lr, r3, r3, r0
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    16e8:	6020      	str	r0, [r4, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    16ea:	ea4f 4393 	mov.w	r3, r3, lsr #18
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    16ee:	4c27      	ldr	r4, [pc, #156]	; (178c <set_arm_clock+0x2a8>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    16f0:	fbb2 f3f3 	udiv	r3, r2, r3
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    16f4:	fbb0 f1f1 	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    16f8:	4a25      	ldr	r2, [pc, #148]	; (1790 <set_arm_clock+0x2ac>)
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    16fa:	6021      	str	r1, [r4, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    16fc:	6013      	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    16fe:	d208      	bcs.n	1712 <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    1700:	4b11      	ldr	r3, [pc, #68]	; (1748 <set_arm_clock+0x264>)
	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    1702:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    1706:	461a      	mov	r2, r3

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    1708:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
    170a:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    170c:	6813      	ldr	r3, [r2, #0]
    170e:	2b00      	cmp	r3, #0
    1710:	dafc      	bge.n	170c <set_arm_clock+0x228>
	}

	return frequency;
}
    1712:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
		if (div_arm < 8) {
			div_arm = div_arm + 1;
		} else {
			if (div_ahb < 5) {
    1716:	2904      	cmp	r1, #4
    1718:	f63f af6f 	bhi.w	15fa <set_arm_clock+0x116>
				div_ahb = div_ahb + 1;
    171c:	3101      	adds	r1, #1
				div_arm = 1;
    171e:	2201      	movs	r2, #1
    1720:	e75b      	b.n	15da <set_arm_clock+0xf6>
    1722:	f8df 807c 	ldr.w	r8, [pc, #124]	; 17a0 <set_arm_clock+0x2bc>
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
    1726:	236c      	movs	r3, #108	; 0x6c
    1728:	481a      	ldr	r0, [pc, #104]	; (1794 <set_arm_clock+0x2b0>)
    172a:	e776      	b.n	161a <set_arm_clock+0x136>
    172c:	2512      	movs	r5, #18
    172e:	e706      	b.n	153e <set_arm_clock+0x5a>
    1730:	4819      	ldr	r0, [pc, #100]	; (1798 <set_arm_clock+0x2b4>)
    1732:	f8df 8070 	ldr.w	r8, [pc, #112]	; 17a4 <set_arm_clock+0x2c0>
    1736:	fb00 f003 	mul.w	r0, r0, r3
    173a:	ea43 0808 	orr.w	r8, r3, r8
    173e:	e76c      	b.n	161a <set_arm_clock+0x136>
    1740:	1f78a400 	.word	0x1f78a400
    1744:	400fc000 	.word	0x400fc000
    1748:	40080000 	.word	0x40080000
    174c:	23c34600 	.word	0x23c34600
    1750:	dc3cba00 	.word	0xdc3cba00
    1754:	004cb223 	.word	0x004cb223
    1758:	51eb851f 	.word	0x51eb851f
    175c:	016e3600 	.word	0x016e3600
    1760:	400d8000 	.word	0x400d8000
    1764:	80003040 	.word	0x80003040
    1768:	269fb1ff 	.word	0x269fb1ff
    176c:	005b8d80 	.word	0x005b8d80
    1770:	165e9f81 	.word	0x165e9f81
    1774:	269fb200 	.word	0x269fb200
    1778:	8001307f 	.word	0x8001307f
    177c:	08f0d17f 	.word	0x08f0d17f
    1780:	00e5109f 	.word	0x00e5109f
    1784:	431bde83 	.word	0x431bde83
    1788:	20001470 	.word	0x20001470
    178c:	2000146c 	.word	0x2000146c
    1790:	2000273c 	.word	0x2000273c
    1794:	4d3f6400 	.word	0x4d3f6400
    1798:	00b71b00 	.word	0x00b71b00
    179c:	80002036 	.word	0x80002036
    17a0:	8000206c 	.word	0x8000206c
    17a4:	80002000 	.word	0x80002000

000017a8 <delay>:
// or delayNanoseconds().
void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
    17a8:	2800      	cmp	r0, #0
    17aa:	d057      	beq.n	185c <delay+0xb4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    17ac:	2201      	movs	r2, #1
// active, but the rest of your program becomes effectively stalled.  Usually
// delay() is used in very simple programs.  To achieve delay without waiting
// use millis() or elapsedMillis.  For shorter delay, use delayMicroseconds()
// or delayNanoseconds().
void delay(uint32_t msec)
{
    17ae:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    17b2:	b085      	sub	sp, #20
    17b4:	4683      	mov	fp, r0
    17b6:	4c2a      	ldr	r4, [pc, #168]	; (1860 <delay+0xb8>)
    17b8:	4d2a      	ldr	r5, [pc, #168]	; (1864 <delay+0xbc>)
    17ba:	4e2b      	ldr	r6, [pc, #172]	; (1868 <delay+0xc0>)
    17bc:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    17c0:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    17c4:	6828      	ldr	r0, [r5, #0]
		scc = systick_cycle_count;
    17c6:	6833      	ldr	r3, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    17c8:	e844 2100 	strex	r1, r2, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    17cc:	2900      	cmp	r1, #0
    17ce:	d1f7      	bne.n	17c0 <delay+0x18>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    17d0:	4f26      	ldr	r7, [pc, #152]	; (186c <delay+0xc4>)
    17d2:	e9cd 8902 	strd	r8, r9, [sp, #8]
    17d6:	683a      	ldr	r2, [r7, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    17d8:	1ad3      	subs	r3, r2, r3
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    17da:	4a25      	ldr	r2, [pc, #148]	; (1870 <delay+0xc8>)
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    17dc:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    17e0:	9701      	str	r7, [sp, #4]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    17e2:	6812      	ldr	r2, [r2, #0]
    17e4:	2701      	movs	r7, #1
    17e6:	fba3 2302 	umull	r2, r3, r3, r2
	if (frac > 1000) frac = 1000;
    17ea:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    17ee:	4698      	mov	r8, r3
	if (frac > 1000) frac = 1000;
    17f0:	2300      	movs	r3, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    17f2:	428b      	cmp	r3, r1
    17f4:	bf08      	it	eq
    17f6:	4542      	cmpeq	r2, r8
    17f8:	bf2c      	ite	cs
    17fa:	46c2      	movcs	sl, r8
    17fc:	46f2      	movcc	sl, lr
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    17fe:	fb0e aa00 	mla	sl, lr, r0, sl
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    1802:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    1806:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    1808:	6831      	ldr	r1, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    180a:	e844 7300 	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    180e:	2b00      	cmp	r3, #0
    1810:	d1f7      	bne.n	1802 <delay+0x5a>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    1812:	9801      	ldr	r0, [sp, #4]
    1814:	6800      	ldr	r0, [r0, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    1816:	1a41      	subs	r1, r0, r1
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1818:	4815      	ldr	r0, [pc, #84]	; (1870 <delay+0xc8>)
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    181a:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    181e:	6800      	ldr	r0, [r0, #0]
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    1820:	fb0e f202 	mul.w	r2, lr, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1824:	fba1 0100 	umull	r0, r1, r1, r0
	if (frac > 1000) frac = 1000;
    1828:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    182c:	ebca 0202 	rsb	r2, sl, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1830:	4688      	mov	r8, r1
	if (frac > 1000) frac = 1000;
    1832:	2100      	movs	r1, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1834:	4299      	cmp	r1, r3
    1836:	bf08      	it	eq
    1838:	4540      	cmpeq	r0, r8
    183a:	bf2c      	ite	cs
    183c:	4643      	movcs	r3, r8
    183e:	4673      	movcc	r3, lr
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    1840:	441a      	add	r2, r3
    1842:	4572      	cmp	r2, lr
    1844:	d307      	bcc.n	1856 <delay+0xae>
			if (--msec == 0) return;
    1846:	f1bb 0b01 	subs.w	fp, fp, #1
			start += 1000;
    184a:	f50a 7a7a 	add.w	sl, sl, #1000	; 0x3e8

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
    184e:	d1d8      	bne.n	1802 <delay+0x5a>
			start += 1000;
		}
		yield();
	}
	// TODO...
}
    1850:	b005      	add	sp, #20
    1852:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
    1856:	f001 fc99 	bl	318c <yield>
	}
    185a:	e7d2      	b.n	1802 <delay+0x5a>
    185c:	4770      	bx	lr
    185e:	bf00      	nop
    1860:	200027e0 	.word	0x200027e0
    1864:	20002744 	.word	0x20002744
    1868:	20002740 	.word	0x20002740
    186c:	e0001004 	.word	0xe0001004
    1870:	2000273c 	.word	0x2000273c

00001874 <digitalWrite.part.0>:
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    1874:	0100      	lsls	r0, r0, #4
    1876:	4b0f      	ldr	r3, [pc, #60]	; (18b4 <digitalWrite.part.0+0x40>)
    1878:	181a      	adds	r2, r3, r0
	pinmode = *(p->reg + 1);
    187a:	581b      	ldr	r3, [r3, r0]
	{&CORE_PIN53_PORTREG, &CORE_PIN53_CONFIG, &CORE_PIN53_PADCONFIG, CORE_PIN53_BITMASK},
	{&CORE_PIN54_PORTREG, &CORE_PIN54_CONFIG, &CORE_PIN54_PADCONFIG, CORE_PIN54_BITMASK},
#endif
};

void digitalWrite(uint8_t pin, uint8_t val)
    187c:	b410      	push	{r4}
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
	mask = p->mask;
    187e:	68d0      	ldr	r0, [r2, #12]
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
    1880:	685c      	ldr	r4, [r3, #4]
	mask = p->mask;
	if (pinmode & mask) {
    1882:	4204      	tst	r4, r0
    1884:	d005      	beq.n	1892 <digitalWrite.part.0+0x1e>
		// pin is configured for output mode
		if (val) {
    1886:	b159      	cbz	r1, 18a0 <digitalWrite.part.0+0x2c>
			*(p->reg + 0x21) = mask; // set register
    1888:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    188c:	f85d 4b04 	ldr.w	r4, [sp], #4
    1890:	4770      	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    1892:	6893      	ldr	r3, [r2, #8]
			*(p->reg + 0x22) = mask; // clear register
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
    1894:	b949      	cbnz	r1, 18aa <digitalWrite.part.0+0x36>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    1896:	4a08      	ldr	r2, [pc, #32]	; (18b8 <digitalWrite.part.0+0x44>)
		}
	}
}
    1898:	f85d 4b04 	ldr.w	r4, [sp], #4
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    189c:	601a      	str	r2, [r3, #0]
		}
	}
}
    189e:	4770      	bx	lr
	if (pinmode & mask) {
		// pin is configured for output mode
		if (val) {
			*(p->reg + 0x21) = mask; // set register
		} else {
			*(p->reg + 0x22) = mask; // clear register
    18a0:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    18a4:	f85d 4b04 	ldr.w	r4, [sp], #4
    18a8:	4770      	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    18aa:	4a04      	ldr	r2, [pc, #16]	; (18bc <digitalWrite.part.0+0x48>)
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    18ac:	f85d 4b04 	ldr.w	r4, [sp], #4
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    18b0:	601a      	str	r2, [r3, #0]
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    18b2:	4770      	bx	lr
    18b4:	200006e4 	.word	0x200006e4
    18b8:	00013038 	.word	0x00013038
    18bc:	0001f038 	.word	0x0001f038

000018c0 <digitalRead.part.1>:
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    18c0:	0100      	lsls	r0, r0, #4
    18c2:	4b05      	ldr	r3, [pc, #20]	; (18d8 <digitalRead.part.1+0x18>)
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    18c4:	581a      	ldr	r2, [r3, r0]
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    18c6:	1819      	adds	r1, r3, r0
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    18c8:	6892      	ldr	r2, [r2, #8]
    18ca:	68cb      	ldr	r3, [r1, #12]
    18cc:	421a      	tst	r2, r3
}
    18ce:	bf14      	ite	ne
    18d0:	2001      	movne	r0, #1
    18d2:	2000      	moveq	r0, #0
    18d4:	4770      	bx	lr
    18d6:	bf00      	nop
    18d8:	200006e4 	.word	0x200006e4

000018dc <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    18dc:	2836      	cmp	r0, #54	; 0x36
    18de:	d801      	bhi.n	18e4 <digitalWrite+0x8>
    18e0:	f7ff bfc8 	b.w	1874 <digitalWrite.part.0>
    18e4:	4770      	bx	lr
    18e6:	bf00      	nop

000018e8 <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    18e8:	2836      	cmp	r0, #54	; 0x36
    18ea:	d801      	bhi.n	18f0 <digitalRead+0x8>
    18ec:	f7ff bfe8 	b.w	18c0 <digitalRead.part.1>
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}
    18f0:	2000      	movs	r0, #0
    18f2:	4770      	bx	lr

000018f4 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
    18f4:	2836      	cmp	r0, #54	; 0x36
    18f6:	d81c      	bhi.n	1932 <pinMode+0x3e>
	p = digital_pin_to_info_PGM + pin;
    18f8:	0100      	lsls	r0, r0, #4
    18fa:	4a1a      	ldr	r2, [pc, #104]	; (1964 <pinMode+0x70>)
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    18fc:	2901      	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    18fe:	eb02 0300 	add.w	r3, r2, r0
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    1902:	5810      	ldr	r0, [r2, r0]
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}

void pinMode(uint8_t pin, uint8_t mode)
{
    1904:	b410      	push	{r4}
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    1906:	d015      	beq.n	1934 <pinMode+0x40>
    1908:	2904      	cmp	r1, #4
    190a:	d013      	beq.n	1934 <pinMode+0x40>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    190c:	68dc      	ldr	r4, [r3, #12]
    190e:	6842      	ldr	r2, [r0, #4]
    1910:	ea22 0204 	bic.w	r2, r2, r4
    1914:	6042      	str	r2, [r0, #4]
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    1916:	689a      	ldr	r2, [r3, #8]
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
    1918:	b1e9      	cbz	r1, 1956 <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
    191a:	2902      	cmp	r1, #2
    191c:	d01e      	beq.n	195c <pinMode+0x68>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
    191e:	2903      	cmp	r1, #3
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    1920:	685b      	ldr	r3, [r3, #4]
}
    1922:	f85d 4b04 	ldr.w	r4, [sp], #4
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    1926:	bf0c      	ite	eq
    1928:	490f      	ldreq	r1, [pc, #60]	; (1968 <pinMode+0x74>)
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
    192a:	4910      	ldrne	r1, [pc, #64]	; (196c <pinMode+0x78>)
    192c:	6011      	str	r1, [r2, #0]
		}
	}
	*(p->mux) = 5 | 0x10;
    192e:	2215      	movs	r2, #21
    1930:	601a      	str	r2, [r3, #0]
}
    1932:	4770      	bx	lr
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
    1934:	68da      	ldr	r2, [r3, #12]
		if (mode == OUTPUT) {
    1936:	2901      	cmp	r1, #1
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
    1938:	6844      	ldr	r4, [r0, #4]
    193a:	ea42 0204 	orr.w	r2, r2, r4
    193e:	6042      	str	r2, [r0, #4]
		if (mode == OUTPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    1940:	689a      	ldr	r2, [r3, #8]

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
		if (mode == OUTPUT) {
    1942:	d008      	beq.n	1956 <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
    1944:	f640 0138 	movw	r1, #2104	; 0x838
    1948:	6011      	str	r1, [r2, #0]
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    194a:	685b      	ldr	r3, [r3, #4]
    194c:	2215      	movs	r2, #21
}
    194e:	f85d 4b04 	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    1952:	601a      	str	r2, [r3, #0]
}
    1954:	4770      	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    1956:	2138      	movs	r1, #56	; 0x38
    1958:	6011      	str	r1, [r2, #0]
    195a:	e7f6      	b.n	194a <pinMode+0x56>
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    195c:	4904      	ldr	r1, [pc, #16]	; (1970 <pinMode+0x7c>)
    195e:	6011      	str	r1, [r2, #0]
    1960:	e7f3      	b.n	194a <pinMode+0x56>
    1962:	bf00      	nop
    1964:	200006e4 	.word	0x200006e4
    1968:	00013038 	.word	0x00013038
    196c:	00010038 	.word	0x00010038
    1970:	0001f038 	.word	0x0001f038

00001974 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    1974:	b4f0      	push	{r4, r5, r6, r7}
    1976:	1e4e      	subs	r6, r1, #1
	unsigned digit;
	int i=0, j;
    1978:	2500      	movs	r5, #0
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    197a:	4637      	mov	r7, r6
    197c:	e000      	b.n	1980 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    197e:	3501      	adds	r5, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    1980:	fbb0 f3f2 	udiv	r3, r0, r2
    1984:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    1988:	f100 0437 	add.w	r4, r0, #55	; 0x37
    198c:	2809      	cmp	r0, #9
    198e:	f100 0030 	add.w	r0, r0, #48	; 0x30
    1992:	b2e4      	uxtb	r4, r4
    1994:	bf98      	it	ls
    1996:	b2c4      	uxtbls	r4, r0
		val /= radix;
		if (val == 0) break;
    1998:	4618      	mov	r0, r3
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    199a:	f807 4f01 	strb.w	r4, [r7, #1]!
		val /= radix;
		if (val == 0) break;
    199e:	2b00      	cmp	r3, #0
    19a0:	d1ed      	bne.n	197e <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    19a2:	194a      	adds	r2, r1, r5
    19a4:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    19a6:	b14d      	cbz	r5, 19bc <ultoa+0x48>
    19a8:	3301      	adds	r3, #1
		t = buf[j];
    19aa:	f816 4f01 	ldrb.w	r4, [r6, #1]!
		buf[j] = buf[i];
    19ae:	7817      	ldrb	r7, [r2, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    19b0:	1ae8      	subs	r0, r5, r3
		t = buf[j];
		buf[j] = buf[i];
    19b2:	7037      	strb	r7, [r6, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    19b4:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    19b6:	f802 4901 	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    19ba:	dbf5      	blt.n	19a8 <ultoa+0x34>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    19bc:	4608      	mov	r0, r1
    19be:	bcf0      	pop	{r4, r5, r6, r7}
    19c0:	4770      	bx	lr
    19c2:	bf00      	nop

000019c4 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    19c4:	48a4      	ldr	r0, [pc, #656]	; (1c58 <pwm_init+0x294>)
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    19c6:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    19ca:	4ba4      	ldr	r3, [pc, #656]	; (1c5c <pwm_init+0x298>)
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    19cc:	6f82      	ldr	r2, [r0, #120]	; 0x78
    19ce:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}

void pwm_init(void)
{
    19d2:	b5f0      	push	{r4, r5, r6, r7, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    19d4:	6782      	str	r2, [r0, #120]	; 0x78
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    19d6:	2500      	movs	r5, #0
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    19d8:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    19dc:	f44f 4670 	mov.w	r6, #61440	; 0xf000
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    19e0:	4c9f      	ldr	r4, [pc, #636]	; (1c60 <pwm_init+0x29c>)
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    19e2:	f44f 4e60 	mov.w	lr, #57344	; 0xe000

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    19e6:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    19e8:	f44f 6780 	mov.w	r7, #1024	; 0x400
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    19ec:	4314      	orrs	r4, r2
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    19ee:	462a      	mov	r2, r5
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    19f0:	f8c0 4080 	str.w	r4, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    19f4:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    19f8:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    19fc:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    1a00:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1a04:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    1a08:	b280      	uxth	r0, r0
    1a0a:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1a0e:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    1a12:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    1a16:	4b91      	ldr	r3, [pc, #580]	; (1c5c <pwm_init+0x298>)
	for (i=0; i < 4; i++) {
    1a18:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1a1a:	2500      	movs	r5, #0
    1a1c:	0140      	lsls	r0, r0, #5
    1a1e:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1a20:	2904      	cmp	r1, #4
    1a22:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1a24:	f8a3 e004 	strh.w	lr, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1a28:	80df      	strh	r7, [r3, #6]
		p->SM[i].OCTRL = 0;
    1a2a:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1a2c:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    1a2e:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    1a30:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    1a32:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    1a34:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    1a36:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1a38:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    1a3a:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1a3c:	d1e9      	bne.n	1a12 <pwm_init+0x4e>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1a3e:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1a42:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1a46:	4b87      	ldr	r3, [pc, #540]	; (1c64 <pwm_init+0x2a0>)
    1a48:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1a4c:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1a4e:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1a50:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1a54:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1a56:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1a5a:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1a5e:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    1a62:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    1a66:	b280      	uxth	r0, r0
    1a68:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    1a6c:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1a70:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    1a74:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1a78:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    1a7c:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1a80:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    1a84:	b280      	uxth	r0, r0
    1a86:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1a8a:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    1a8e:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    1a92:	4b74      	ldr	r3, [pc, #464]	; (1c64 <pwm_init+0x2a0>)
	for (i=0; i < 4; i++) {
    1a94:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1a96:	2500      	movs	r5, #0
    1a98:	0140      	lsls	r0, r0, #5
    1a9a:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1a9c:	2904      	cmp	r1, #4
    1a9e:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1aa0:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1aa2:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    1aa6:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1aa8:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    1aaa:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    1aac:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    1aae:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    1ab0:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    1ab2:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1ab4:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    1ab6:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1ab8:	d1e9      	bne.n	1a8e <pwm_init+0xca>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1aba:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1abe:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1ac2:	4b69      	ldr	r3, [pc, #420]	; (1c68 <pwm_init+0x2a4>)
    1ac4:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1ac8:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1aca:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1acc:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1ad0:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1ad2:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1ad6:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1ada:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    1ade:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    1ae2:	b280      	uxth	r0, r0
    1ae4:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    1ae8:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1aec:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    1af0:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1af4:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    1af8:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1afc:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    1b00:	b280      	uxth	r0, r0
    1b02:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1b06:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    1b0a:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    1b0e:	4b56      	ldr	r3, [pc, #344]	; (1c68 <pwm_init+0x2a4>)
	for (i=0; i < 4; i++) {
    1b10:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1b12:	2500      	movs	r5, #0
    1b14:	0140      	lsls	r0, r0, #5
    1b16:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1b18:	2904      	cmp	r1, #4
    1b1a:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1b1c:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1b1e:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    1b22:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1b24:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    1b26:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    1b28:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    1b2a:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    1b2c:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    1b2e:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1b30:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    1b32:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1b34:	d1e9      	bne.n	1b0a <pwm_init+0x146>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1b36:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1b3a:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1b3e:	4b4b      	ldr	r3, [pc, #300]	; (1c6c <pwm_init+0x2a8>)
    1b40:	f44f 4770 	mov.w	r7, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1b44:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1b46:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1b48:	f44f 4660 	mov.w	r6, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1b4c:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1b4e:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1b52:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1b56:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    1b5a:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    1b5e:	b280      	uxth	r0, r0
    1b60:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    1b64:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1b68:	f8a3 718c 	strh.w	r7, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    1b6c:	f248 27b8 	movw	r7, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1b70:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    1b74:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1b78:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    1b7c:	b280      	uxth	r0, r0
    1b7e:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1b82:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    1b86:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    1b8a:	4b38      	ldr	r3, [pc, #224]	; (1c6c <pwm_init+0x2a8>)
	for (i=0; i < 4; i++) {
    1b8c:	3101      	adds	r1, #1
    1b8e:	0140      	lsls	r0, r0, #5
    1b90:	461c      	mov	r4, r3
    1b92:	2904      	cmp	r1, #4
    1b94:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1b96:	809e      	strh	r6, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1b98:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    1b9c:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1b9e:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    1ba0:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    1ba2:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    1ba4:	81df      	strh	r7, [r3, #14]
		p->SM[i].VAL2 = 0;
    1ba6:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    1ba8:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1baa:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    1bac:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1bae:	d1ea      	bne.n	1b86 <pwm_init+0x1c2>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1bb0:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1bb4:	270f      	movs	r7, #15

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1bb6:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1bb8:	f241 0601 	movw	r6, #4097	; 0x1001
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1bbc:	b29b      	uxth	r3, r3
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1bbe:	f645 5ec0 	movw	lr, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1bc2:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1bc4:	f243 0526 	movw	r5, #12326	; 0x3026
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1bc8:	433b      	orrs	r3, r7
    1bca:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    1bce:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
    1bd2:	b29b      	uxth	r3, r3
    1bd4:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
    1bd8:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1bdc:	0150      	lsls	r0, r2, #5
    1bde:	4b24      	ldr	r3, [pc, #144]	; (1c70 <pwm_init+0x2ac>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1be0:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    1be2:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1be4:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    1be6:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    1be8:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1bea:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1bec:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1bee:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    1bf2:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    1bf4:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1bf6:	819d      	strh	r5, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1bf8:	d1f0      	bne.n	1bdc <pwm_init+0x218>
    1bfa:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1bfc:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1bfe:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1c02:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1c06:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1c08:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1c0c:	0150      	lsls	r0, r2, #5
    1c0e:	4b19      	ldr	r3, [pc, #100]	; (1c74 <pwm_init+0x2b0>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1c10:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    1c12:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1c14:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    1c16:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    1c18:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1c1a:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1c1c:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1c1e:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    1c20:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    1c22:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1c24:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1c26:	d1f1      	bne.n	1c0c <pwm_init+0x248>
    1c28:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1c2a:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1c2c:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1c30:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1c34:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1c36:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1c3a:	0150      	lsls	r0, r2, #5
    1c3c:	4b0e      	ldr	r3, [pc, #56]	; (1c78 <pwm_init+0x2b4>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1c3e:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    1c40:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1c42:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    1c44:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    1c46:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1c48:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1c4a:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1c4c:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    1c4e:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    1c50:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1c52:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1c54:	d1f1      	bne.n	1c3a <pwm_init+0x276>
	flexpwm_init(&IMXRT_FLEXPWM3);
	flexpwm_init(&IMXRT_FLEXPWM4);
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    1c56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1c58:	400fc000 	.word	0x400fc000
    1c5c:	403dc000 	.word	0x403dc000
    1c60:	fc030000 	.word	0xfc030000
    1c64:	403e0000 	.word	0x403e0000
    1c68:	403e4000 	.word	0x403e4000
    1c6c:	403e8000 	.word	0x403e8000
    1c70:	401dc000 	.word	0x401dc000
    1c74:	401e0000 	.word	0x401e0000
    1c78:	401e4000 	.word	0x401e4000

00001c7c <rtc_get>:
#include "debug/printf.h"


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
    1c7c:	4b0a      	ldr	r3, [pc, #40]	; (1ca8 <rtc_get+0x2c>)
#include "imxrt.h"
#include "debug/printf.h"


unsigned long rtc_get(void)
{
    1c7e:	b430      	push	{r4, r5}
	uint32_t hi1 = SNVS_HPRTCMR;
    1c80:	6a58      	ldr	r0, [r3, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    1c82:	461c      	mov	r4, r3


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
    1c84:	6a99      	ldr	r1, [r3, #40]	; 0x28
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    1c86:	6a62      	ldr	r2, [r4, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
    1c88:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
    1c8a:	4299      	cmp	r1, r3
    1c8c:	bf08      	it	eq
    1c8e:	4290      	cmpeq	r0, r2
unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    1c90:	4610      	mov	r0, r2
		uint32_t lo2 = SNVS_HPRTCLR;
    1c92:	4619      	mov	r1, r3
		if (lo1 == lo2 && hi1 == hi2) {
    1c94:	bf0c      	ite	eq
    1c96:	2501      	moveq	r5, #1
    1c98:	2500      	movne	r5, #0
    1c9a:	2d00      	cmp	r5, #0
    1c9c:	d0f3      	beq.n	1c86 <rtc_get+0xa>
			return (hi2 << 17) | (lo2 >> 15);
    1c9e:	0bd9      	lsrs	r1, r3, #15
		}
		hi1 = hi2;
		lo1 = lo2;
	}
}
    1ca0:	bc30      	pop	{r4, r5}
    1ca2:	ea41 4042 	orr.w	r0, r1, r2, lsl #17
    1ca6:	4770      	bx	lr
    1ca8:	400d4000 	.word	0x400d4000

00001cac <sm_align_pool>:
	if (spool->pool_size % HEADER_SZ) return 0;
	return 1;
}

int sm_align_pool(struct smalloc_pool *spool)
{
    1cac:	b508      	push	{r3, lr}

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    1cae:	6803      	ldr	r3, [r0, #0]
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    1cb0:	6842      	ldr	r2, [r0, #4]

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    1cb2:	b1bb      	cbz	r3, 1ce4 <sm_align_pool+0x38>
    1cb4:	b17a      	cbz	r2, 1cd6 <sm_align_pool+0x2a>
	if (spool->pool_size % HEADER_SZ) return 0;
    1cb6:	4b10      	ldr	r3, [pc, #64]	; (1cf8 <sm_align_pool+0x4c>)
    1cb8:	fba3 1302 	umull	r1, r3, r3, r2
    1cbc:	08db      	lsrs	r3, r3, #3
    1cbe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    1cc2:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
    1cc6:	d003      	beq.n	1cd0 <sm_align_pool+0x24>
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
    1cc8:	1ad2      	subs	r2, r2, r3
    1cca:	6042      	str	r2, [r0, #4]
	if (spool->pool_size <= MIN_POOL_SZ) {
    1ccc:	2af0      	cmp	r2, #240	; 0xf0
    1cce:	d902      	bls.n	1cd6 <sm_align_pool+0x2a>

int sm_align_pool(struct smalloc_pool *spool)
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;
    1cd0:	2301      	movs	r3, #1
		errno = ENOSPC;
		return 0;
	}

	return 1;
}
    1cd2:	4618      	mov	r0, r3
    1cd4:	bd08      	pop	{r3, pc}
	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
	if (spool->pool_size <= MIN_POOL_SZ) {
		errno = ENOSPC;
    1cd6:	f004 fcd3 	bl	6680 <__errno>
    1cda:	221c      	movs	r2, #28
    1cdc:	2300      	movs	r3, #0
    1cde:	6002      	str	r2, [r0, #0]
		return 0;
	}

	return 1;
}
    1ce0:	4618      	mov	r0, r3
    1ce2:	bd08      	pop	{r3, pc}
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    1ce4:	4b04      	ldr	r3, [pc, #16]	; (1cf8 <sm_align_pool+0x4c>)
    1ce6:	fba3 1302 	umull	r1, r3, r3, r2
    1cea:	08db      	lsrs	r3, r3, #3
    1cec:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (x) spool->pool_size -= x;
    1cf0:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
    1cf4:	d1e8      	bne.n	1cc8 <sm_align_pool+0x1c>
    1cf6:	e7e9      	b.n	1ccc <sm_align_pool+0x20>
    1cf8:	aaaaaaab 	.word	0xaaaaaaab

00001cfc <sm_set_pool>:

	return 1;
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
    1cfc:	b570      	push	{r4, r5, r6, lr}
	if (!spool) {
    1cfe:	4604      	mov	r4, r0
    1d00:	2800      	cmp	r0, #0
    1d02:	d03a      	beq.n	1d7a <sm_set_pool+0x7e>
		errno = EINVAL;
		return 0;
	}

	if (!new_pool || !new_pool_size) {
    1d04:	b119      	cbz	r1, 1d0e <sm_set_pool+0x12>
    1d06:	fab2 f582 	clz	r5, r2
    1d0a:	096d      	lsrs	r5, r5, #5
    1d0c:	b1fd      	cbz	r5, 1d4e <sm_set_pool+0x52>

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    1d0e:	6820      	ldr	r0, [r4, #0]
    1d10:	b108      	cbz	r0, 1d16 <sm_set_pool+0x1a>
    1d12:	6862      	ldr	r2, [r4, #4]
    1d14:	b932      	cbnz	r2, 1d24 <sm_set_pool+0x28>
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    1d16:	f004 fcb3 	bl	6680 <__errno>
    1d1a:	2316      	movs	r3, #22
		return 0;
    1d1c:	2200      	movs	r2, #0
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    1d1e:	6003      	str	r3, [r0, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1d20:	4610      	mov	r0, r2
    1d22:	bd70      	pop	{r4, r5, r6, pc}
struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
	if (spool->pool_size % HEADER_SZ) return 0;
    1d24:	4918      	ldr	r1, [pc, #96]	; (1d88 <sm_set_pool+0x8c>)
    1d26:	fba1 3102 	umull	r3, r1, r1, r2
    1d2a:	08c9      	lsrs	r1, r1, #3
    1d2c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    1d30:	ebb2 0181 	subs.w	r1, r2, r1, lsl #2
    1d34:	d1ef      	bne.n	1d16 <sm_set_pool+0x1a>
		return 0;
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
    1d36:	68a3      	ldr	r3, [r4, #8]
    1d38:	b10b      	cbz	r3, 1d3e <sm_set_pool+0x42>
    1d3a:	f005 f8bb 	bl	6eb4 <memset>
			memset(spool, 0, sizeof(struct smalloc_pool));
    1d3e:	2300      	movs	r3, #0
			return 1;
    1d40:	2201      	movs	r2, #1
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    1d42:	6023      	str	r3, [r4, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1d44:	4610      	mov	r0, r2
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    1d46:	6063      	str	r3, [r4, #4]
    1d48:	60a3      	str	r3, [r4, #8]
    1d4a:	60e3      	str	r3, [r4, #12]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1d4c:	bd70      	pop	{r4, r5, r6, pc}
    1d4e:	461e      	mov	r6, r3
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
    1d50:	9b04      	ldr	r3, [sp, #16]
		errno = EINVAL;
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
    1d52:	e880 0006 	stmia.w	r0, {r1, r2}
	spool->oomfn = oom_handler;
    1d56:	60c3      	str	r3, [r0, #12]
	if (!sm_align_pool(spool)) return 0;
    1d58:	f7ff ffa8 	bl	1cac <sm_align_pool>
    1d5c:	4602      	mov	r2, r0
    1d5e:	2800      	cmp	r0, #0
    1d60:	d0de      	beq.n	1d20 <sm_set_pool+0x24>

	if (do_zero) {
    1d62:	b916      	cbnz	r6, 1d6a <sm_set_pool+0x6e>
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
    1d64:	2201      	movs	r2, #1
}
    1d66:	4610      	mov	r0, r2
    1d68:	bd70      	pop	{r4, r5, r6, pc}
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
    1d6a:	e894 0005 	ldmia.w	r4, {r0, r2}
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
    1d6e:	60a6      	str	r6, [r4, #8]
		memset(spool->pool, 0, spool->pool_size);
    1d70:	4629      	mov	r1, r5
    1d72:	f005 f89f 	bl	6eb4 <memset>
	}

	return 1;
    1d76:	2201      	movs	r2, #1
    1d78:	e7d2      	b.n	1d20 <sm_set_pool+0x24>
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    1d7a:	f004 fc81 	bl	6680 <__errno>
    1d7e:	2316      	movs	r3, #22
		return 0;
    1d80:	4622      	mov	r2, r4
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    1d82:	6003      	str	r3, [r0, #0]
		return 0;
    1d84:	e7cc      	b.n	1d20 <sm_set_pool+0x24>
    1d86:	bf00      	nop
    1d88:	aaaaaaab 	.word	0xaaaaaaab

00001d8c <unused_interrupt_vector>:
	const uint32_t *stack;
	struct arm_fault_info_struct *info;
	const uint32_t *p, *end;

	// disallow any nested interrupts
	__disable_irq();
    1d8c:	b672      	cpsid	i
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
    1d8e:	f3ef 8305 	mrs	r3, IPSR
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
    1d92:	4d49      	ldr	r5, [pc, #292]	; (1eb8 <unused_interrupt_vector+0x12c>)
    1d94:	606b      	str	r3, [r5, #4]
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
    1d96:	f3ef 8308 	mrs	r3, MSP
	info->cfsr = SCB_CFSR;
    1d9a:	4c48      	ldr	r4, [pc, #288]	; (1ebc <unused_interrupt_vector+0x130>)
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
	info->len = sizeof(*info) / 4;
    1d9c:	462e      	mov	r6, r5
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
    1d9e:	4848      	ldr	r0, [pc, #288]	; (1ec0 <unused_interrupt_vector+0x134>)
	info->mmfar = SCB_MMFAR;
    1da0:	4948      	ldr	r1, [pc, #288]	; (1ec4 <unused_interrupt_vector+0x138>)
	info->bfar = SCB_BFAR;
    1da2:	4a49      	ldr	r2, [pc, #292]	; (1ec8 <unused_interrupt_vector+0x13c>)
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    1da4:	6824      	ldr	r4, [r4, #0]
	info->hfsr = SCB_HFSR;
    1da6:	6800      	ldr	r0, [r0, #0]
	info->mmfar = SCB_MMFAR;
    1da8:	6809      	ldr	r1, [r1, #0]
	info->bfar = SCB_BFAR;
    1daa:	6812      	ldr	r2, [r2, #0]
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
    1dac:	6129      	str	r1, [r5, #16]
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    1dae:	60ac      	str	r4, [r5, #8]
	info->hfsr = SCB_HFSR;
    1db0:	60e8      	str	r0, [r5, #12]
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
    1db2:	616a      	str	r2, [r5, #20]
	info->ret = stack[6];
    1db4:	699a      	ldr	r2, [r3, #24]
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    1db6:	4c45      	ldr	r4, [pc, #276]	; (1ecc <unused_interrupt_vector+0x140>)
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
    1db8:	61aa      	str	r2, [r5, #24]
	info->xpsr = stack[7];
    1dba:	69db      	ldr	r3, [r3, #28]
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    1dbc:	4f44      	ldr	r7, [pc, #272]	; (1ed0 <unused_interrupt_vector+0x144>)
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
    1dbe:	61eb      	str	r3, [r5, #28]
	info->temp = tempmonGetTemp();
    1dc0:	f000 f8c8 	bl	1f54 <tempmonGetTemp>
    1dc4:	ed85 0a08 	vstr	s0, [r5, #32]
	info->time = rtc_get();
    1dc8:	f7ff ff58 	bl	1c7c <rtc_get>
	info->len = sizeof(*info) / 4;
    1dcc:	230b      	movs	r3, #11
	// add CRC to crash report
	crc = 0xFFFFFFFF;
    1dce:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
    1dd2:	6268      	str	r0, [r5, #36]	; 0x24
	info->len = sizeof(*info) / 4;
    1dd4:	4619      	mov	r1, r3
    1dd6:	602b      	str	r3, [r5, #0]
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
    1dd8:	404a      	eors	r2, r1
    1dda:	2120      	movs	r1, #32
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    1ddc:	f002 0301 	and.w	r3, r2, #1
    1de0:	3901      	subs	r1, #1
    1de2:	fb04 f303 	mul.w	r3, r4, r3
    1de6:	ea83 0252 	eor.w	r2, r3, r2, lsr #1
    1dea:	d1f7      	bne.n	1ddc <unused_interrupt_vector+0x50>
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    1dec:	42be      	cmp	r6, r7
    1dee:	d002      	beq.n	1df6 <unused_interrupt_vector+0x6a>
    1df0:	f856 1f04 	ldr.w	r1, [r6, #4]!
    1df4:	e7f0      	b.n	1dd8 <unused_interrupt_vector+0x4c>
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
	}
	info->crc = crc;
    1df6:	4930      	ldr	r1, [pc, #192]	; (1eb8 <unused_interrupt_vector+0x12c>)
    1df8:	628a      	str	r2, [r1, #40]	; 0x28
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    1dfa:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    1dfe:	4b35      	ldr	r3, [pc, #212]	; (1ed4 <unused_interrupt_vector+0x148>)
    1e00:	4a35      	ldr	r2, [pc, #212]	; (1ed8 <unused_interrupt_vector+0x14c>)
    1e02:	6019      	str	r1, [r3, #0]
    1e04:	601a      	str	r2, [r3, #0]
		location += 32;
	} while (location < end_addr);
	asm("dsb");
    1e06:	f3bf 8f4f 	dsb	sy
	asm("isb");
    1e0a:	f3bf 8f6f 	isb	sy
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1e0e:	4a33      	ldr	r2, [pc, #204]	; (1edc <unused_interrupt_vector+0x150>)
	PIT_MCR = PIT_MCR_MDIS;
    1e10:	2502      	movs	r5, #2
    1e12:	4c33      	ldr	r4, [pc, #204]	; (1ee0 <unused_interrupt_vector+0x154>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1e14:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1e16:	4933      	ldr	r1, [pc, #204]	; (1ee4 <unused_interrupt_vector+0x158>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1e18:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1e1c:	4832      	ldr	r0, [pc, #200]	; (1ee8 <unused_interrupt_vector+0x15c>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1e1e:	66d3      	str	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
    1e20:	6025      	str	r5, [r4, #0]
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    1e22:	69d3      	ldr	r3, [r2, #28]
    1e24:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    1e28:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1e2c:	61d3      	str	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1e2e:	680b      	ldr	r3, [r1, #0]
    1e30:	4283      	cmp	r3, r0
    1e32:	d83e      	bhi.n	1eb2 <unused_interrupt_vector+0x126>
	PIT_MCR = 0;
    1e34:	4a2a      	ldr	r2, [pc, #168]	; (1ee0 <unused_interrupt_vector+0x154>)
    1e36:	2100      	movs	r1, #0
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    1e38:	2001      	movs	r0, #1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    1e3a:	4e2c      	ldr	r6, [pc, #176]	; (1eec <unused_interrupt_vector+0x160>)
	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
    1e3c:	6011      	str	r1, [r2, #0]
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    1e3e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
    1e42:	f8c2 1108 	str.w	r1, [r2, #264]	; 0x108
	NVIC_ICER4 = 0xFFFFFFFF;

	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
    1e46:	460c      	mov	r4, r1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    1e48:	f8c2 6100 	str.w	r6, [r2, #256]	; 0x100
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    1e4c:	4615      	mov	r5, r2
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    1e4e:	f8c2 0108 	str.w	r0, [r2, #264]	; 0x108
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    1e52:	4607      	mov	r7, r0
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    1e54:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 1f18 <unused_interrupt_vector+0x18c>
	NVIC_ICER1 = 0xFFFFFFFF;
    1e58:	4e25      	ldr	r6, [pc, #148]	; (1ef0 <unused_interrupt_vector+0x164>)
	NVIC_ICER2 = 0xFFFFFFFF;
    1e5a:	4826      	ldr	r0, [pc, #152]	; (1ef4 <unused_interrupt_vector+0x168>)
	NVIC_ICER3 = 0xFFFFFFFF;
    1e5c:	4926      	ldr	r1, [pc, #152]	; (1ef8 <unused_interrupt_vector+0x16c>)
	NVIC_ICER4 = 0xFFFFFFFF;
    1e5e:	4a27      	ldr	r2, [pc, #156]	; (1efc <unused_interrupt_vector+0x170>)
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    1e60:	f8ce 3000 	str.w	r3, [lr]
	NVIC_ICER1 = 0xFFFFFFFF;
    1e64:	6033      	str	r3, [r6, #0]
	NVIC_ICER2 = 0xFFFFFFFF;
    1e66:	6003      	str	r3, [r0, #0]
	NVIC_ICER3 = 0xFFFFFFFF;
    1e68:	600b      	str	r3, [r1, #0]
	NVIC_ICER4 = 0xFFFFFFFF;
    1e6a:	6013      	str	r3, [r2, #0]
    1e6c:	e001      	b.n	1e72 <unused_interrupt_vector+0xe6>
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
		}
		usb_isr();
    1e6e:	f000 f955 	bl	211c <usb_isr>
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    1e72:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
    1e76:	4b1a      	ldr	r3, [pc, #104]	; (1ee0 <unused_interrupt_vector+0x154>)
    1e78:	2a00      	cmp	r2, #0
    1e7a:	d0f8      	beq.n	1e6e <unused_interrupt_vector+0xe2>
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
    1e7c:	3401      	adds	r4, #1
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    1e7e:	f8c5 710c 	str.w	r7, [r5, #268]	; 0x10c
			if (++count >= 80) break;  // reboot after 8 seconds
    1e82:	2c4f      	cmp	r4, #79	; 0x4f
    1e84:	d9f3      	bls.n	1e6e <unused_interrupt_vector+0xe2>
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    1e86:	4a1e      	ldr	r2, [pc, #120]	; (1f00 <unused_interrupt_vector+0x174>)
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    1e88:	2402      	movs	r4, #2
    1e8a:	481e      	ldr	r0, [pc, #120]	; (1f04 <unused_interrupt_vector+0x178>)
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    1e8c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    1e90:	f8c0 4140 	str.w	r4, [r0, #320]	; 0x140
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    1e94:	6351      	str	r1, [r2, #52]	; 0x34
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    1e96:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    1e9a:	b932      	cbnz	r2, 1eaa <unused_interrupt_vector+0x11e>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
    1e9c:	491a      	ldr	r1, [pc, #104]	; (1f08 <unused_interrupt_vector+0x17c>)
    1e9e:	4a1b      	ldr	r2, [pc, #108]	; (1f0c <unused_interrupt_vector+0x180>)
    1ea0:	630a      	str	r2, [r1, #48]	; 0x30
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    1ea2:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    1ea6:	2800      	cmp	r0, #0
    1ea8:	d0fa      	beq.n	1ea0 <unused_interrupt_vector+0x114>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
	SCB_AIRCR = 0x05FA0004;
    1eaa:	4b19      	ldr	r3, [pc, #100]	; (1f10 <unused_interrupt_vector+0x184>)
    1eac:	4a19      	ldr	r2, [pc, #100]	; (1f14 <unused_interrupt_vector+0x188>)
    1eae:	601a      	str	r2, [r3, #0]
    1eb0:	e7fe      	b.n	1eb0 <unused_interrupt_vector+0x124>

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1eb2:	f7ff fb17 	bl	14e4 <set_arm_clock>
    1eb6:	e7bd      	b.n	1e34 <unused_interrupt_vector+0xa8>
    1eb8:	2027ff80 	.word	0x2027ff80
    1ebc:	e000ed28 	.word	0xe000ed28
    1ec0:	e000ed2c 	.word	0xe000ed2c
    1ec4:	e000ed34 	.word	0xe000ed34
    1ec8:	e000ed38 	.word	0xe000ed38
    1ecc:	edb88320 	.word	0xedb88320
    1ed0:	2027ffa4 	.word	0x2027ffa4
    1ed4:	e000ef70 	.word	0xe000ef70
    1ed8:	2027ffa0 	.word	0x2027ffa0
    1edc:	400fc000 	.word	0x400fc000
    1ee0:	40084000 	.word	0x40084000
    1ee4:	20001470 	.word	0x20001470
    1ee8:	0bcd3d80 	.word	0x0bcd3d80
    1eec:	00249f00 	.word	0x00249f00
    1ef0:	e000e184 	.word	0xe000e184
    1ef4:	e000e188 	.word	0xe000e188
    1ef8:	e000e18c 	.word	0xe000e18c
    1efc:	e000e190 	.word	0xe000e190
    1f00:	400d9000 	.word	0x400d9000
    1f04:	402e0000 	.word	0x402e0000
    1f08:	400f8000 	.word	0x400f8000
    1f0c:	0bad00f1 	.word	0x0bad00f1
    1f10:	e000ed0c 	.word	0xe000ed0c
    1f14:	05fa0004 	.word	0x05fa0004
    1f18:	e000e180 	.word	0xe000e180

00001f1c <_sbrk>:

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
        char *prev = __brkval;
    1f1c:	4a09      	ldr	r2, [pc, #36]	; (1f44 <_sbrk+0x28>)
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
    1f1e:	b508      	push	{r3, lr}
        char *prev = __brkval;
    1f20:	6813      	ldr	r3, [r2, #0]
        if (incr != 0) {
    1f22:	b120      	cbz	r0, 1f2e <_sbrk+0x12>
                if (prev + incr > (char *)&_heap_end) {
    1f24:	4418      	add	r0, r3
    1f26:	4908      	ldr	r1, [pc, #32]	; (1f48 <_sbrk+0x2c>)
    1f28:	4288      	cmp	r0, r1
    1f2a:	d802      	bhi.n	1f32 <_sbrk+0x16>
                        errno = ENOMEM;
                        return (void *)-1;
                }
                __brkval = prev + incr;
    1f2c:	6010      	str	r0, [r2, #0]
        }
        return prev;
}
    1f2e:	4618      	mov	r0, r3
    1f30:	bd08      	pop	{r3, pc}
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    1f32:	f004 fba5 	bl	6680 <__errno>
    1f36:	220c      	movs	r2, #12
                        return (void *)-1;
    1f38:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    1f3c:	6002      	str	r2, [r0, #0]
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    1f3e:	4618      	mov	r0, r3
    1f40:	bd08      	pop	{r3, pc}
    1f42:	bf00      	nop
    1f44:	20001850 	.word	0x20001850
    1f48:	20280000 	.word	0x20280000

00001f4c <_exit>:
}

__attribute__((weak))
void _exit(int status)
{
	while (1) asm ("WFI");
    1f4c:	bf30      	wfi
    1f4e:	e7fd      	b.n	1f4c <_exit>

00001f50 <Panic_Temp_isr>:
static float s_hot_ROOM, s_roomC_hotC;

extern void unused_interrupt_vector(void); // startup.c

void Panic_Temp_isr(void) {
  unused_interrupt_vector();
    1f50:	f7ff bf1c 	b.w	1d8c <unused_interrupt_vector>

00001f54 <tempmonGetTemp>:
float tempmonGetTemp(void)
{
    uint32_t nmeas;
    float tmeas;

    while (!(TEMPMON_TEMPSENSE0 & 0x4U))
    1f54:	4912      	ldr	r1, [pc, #72]	; (1fa0 <tempmonGetTemp+0x4c>)
    1f56:	680b      	ldr	r3, [r1, #0]
    1f58:	4a11      	ldr	r2, [pc, #68]	; (1fa0 <tempmonGetTemp+0x4c>)
    1f5a:	075b      	lsls	r3, r3, #29
    1f5c:	d5fb      	bpl.n	1f56 <tempmonGetTemp+0x2>
    {
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    1f5e:	6813      	ldr	r3, [r2, #0]
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1f60:	4910      	ldr	r1, [pc, #64]	; (1fa4 <tempmonGetTemp+0x50>)

    return tmeas;
    1f62:	f3c3 230b 	ubfx	r3, r3, #8, #12
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1f66:	4a10      	ldr	r2, [pc, #64]	; (1fa8 <tempmonGetTemp+0x54>)

    return tmeas;
    1f68:	ee07 3a90 	vmov	s15, r3
    1f6c:	680b      	ldr	r3, [r1, #0]
    1f6e:	ed92 6a00 	vldr	s12, [r2]
    1f72:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    1f76:	ee07 3a90 	vmov	s15, r3
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1f7a:	4a0c      	ldr	r2, [pc, #48]	; (1fac <tempmonGetTemp+0x58>)

    return tmeas;
    1f7c:	eef8 7a67 	vcvt.f32.u32	s15, s15
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1f80:	4b0b      	ldr	r3, [pc, #44]	; (1fb0 <tempmonGetTemp+0x5c>)

    return tmeas;
    1f82:	edd2 6a00 	vldr	s13, [r2]
    1f86:	ee77 7a67 	vsub.f32	s15, s14, s15
    1f8a:	ed93 7a00 	vldr	s14, [r3]
    1f8e:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    1f92:	ee67 7a86 	vmul.f32	s15, s15, s12
    1f96:	ee87 0aa6 	vdiv.f32	s0, s15, s13
}
    1f9a:	ee37 0a40 	vsub.f32	s0, s14, s0
    1f9e:	4770      	bx	lr
    1fa0:	400d8180 	.word	0x400d8180
    1fa4:	2000272c 	.word	0x2000272c
    1fa8:	20002734 	.word	0x20002734
    1fac:	20002738 	.word	0x20002738
    1fb0:	20002730 	.word	0x20002730

00001fb4 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    1fb4:	6b83      	ldr	r3, [r0, #56]	; 0x38
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
    1fb6:	b4f0      	push	{r4, r5, r6, r7}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    1fb8:	b11b      	cbz	r3, 1fc2 <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    1fba:	6853      	ldr	r3, [r2, #4]
    1fbc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    1fc0:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    1fc2:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    1fc4:	6b44      	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    1fc6:	b35c      	cbz	r4, 2020 <schedule_transfer+0x6c>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    1fc8:	4b1c      	ldr	r3, [pc, #112]	; (203c <schedule_transfer+0x88>)
	__disable_irq();
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
	if (last) {
		last->next = (uint32_t)transfer;
    1fca:	6022      	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    1fcc:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    1fd0:	420c      	tst	r4, r1
    1fd2:	d115      	bne.n	2000 <schedule_transfer+0x4c>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    1fd4:	4e1a      	ldr	r6, [pc, #104]	; (2040 <schedule_transfer+0x8c>)
    1fd6:	6837      	ldr	r7, [r6, #0]
    1fd8:	e004      	b.n	1fe4 <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    1fda:	6834      	ldr	r4, [r6, #0]
    1fdc:	1be4      	subs	r4, r4, r7
    1fde:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
    1fe2:	d20b      	bcs.n	1ffc <schedule_transfer+0x48>
		if (USB1_ENDPTPRIME & epmask) goto end;
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    1fe4:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    1fe8:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    1fec:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    1ff0:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    1ff4:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    1ff8:	0464      	lsls	r4, r4, #17
    1ffa:	d5ee      	bpl.n	1fda <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    1ffc:	400d      	ands	r5, r1
    1ffe:	d003      	beq.n	2008 <schedule_transfer+0x54>
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    2000:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    2002:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    2004:	bcf0      	pop	{r4, r5, r6, r7}
    2006:	4770      	bx	lr
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
    2008:	4c0c      	ldr	r4, [pc, #48]	; (203c <schedule_transfer+0x88>)
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
    200a:	6082      	str	r2, [r0, #8]
		endpoint->status = 0;
    200c:	60c5      	str	r5, [r0, #12]
		USB1_ENDPTPRIME |= epmask;
    200e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    2012:	4319      	orrs	r1, r3
    2014:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    2018:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    201a:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    201c:	bcf0      	pop	{r4, r5, r6, r7}
    201e:	4770      	bx	lr
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
    2020:	4d06      	ldr	r5, [pc, #24]	; (203c <schedule_transfer+0x88>)
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
    2022:	6082      	str	r2, [r0, #8]
	endpoint->status = 0;
    2024:	60c4      	str	r4, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
    2026:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
    202a:	4319      	orrs	r1, r3
    202c:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    2030:	6302      	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
    2032:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    2034:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    2036:	bcf0      	pop	{r4, r5, r6, r7}
    2038:	4770      	bx	lr
    203a:	bf00      	nop
    203c:	402e0000 	.word	0x402e0000
    2040:	e0001004 	.word	0xe0001004

00002044 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    2044:	b570      	push	{r4, r5, r6, lr}
    2046:	4606      	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    2048:	6b00      	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
    204a:	b190      	cbz	r0, 2072 <run_callbacks+0x2e>
    204c:	4602      	mov	r2, r0
    204e:	2400      	movs	r4, #0
    2050:	e003      	b.n	205a <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    2052:	6812      	ldr	r2, [r2, #0]
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
    2054:	3401      	adds	r4, #1
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
    2056:	2a01      	cmp	r2, #1
    2058:	d00c      	beq.n	2074 <run_callbacks+0x30>

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
    205a:	6853      	ldr	r3, [r2, #4]
    205c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    2060:	d0f7      	beq.n	2052 <run_callbacks+0xe>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
    2062:	6332      	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    2064:	b12c      	cbz	r4, 2072 <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
    2066:	6bb3      	ldr	r3, [r6, #56]	; 0x38
			break;
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
    2068:	6805      	ldr	r5, [r0, #0]
		ep->callback_function(first);
    206a:	4798      	blx	r3
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    206c:	3c01      	subs	r4, #1
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
    206e:	4628      	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    2070:	d1f9      	bne.n	2066 <run_callbacks+0x22>
    2072:	bd70      	pop	{r4, r5, r6, pc}
		count++;
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
    2074:	6333      	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
    2076:	6373      	str	r3, [r6, #52]	; 0x34
			break;
    2078:	e7f4      	b.n	2064 <run_callbacks+0x20>
    207a:	bf00      	nop

0000207c <endpoint0_transmit.constprop.1>:
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    207c:	b5f0      	push	{r4, r5, r6, r7, lr}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
    207e:	b9e1      	cbnz	r1, 20ba <endpoint0_transmit.constprop.1+0x3e>
    2080:	4c21      	ldr	r4, [pc, #132]	; (2108 <endpoint0_transmit.constprop.1+0x8c>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2082:	4922      	ldr	r1, [pc, #136]	; (210c <endpoint0_transmit.constprop.1+0x90>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    2084:	2000      	movs	r0, #0
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    2086:	4b22      	ldr	r3, [pc, #136]	; (2110 <endpoint0_transmit.constprop.1+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2088:	2201      	movs	r2, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    208a:	f04f 1501 	mov.w	r5, #65537	; 0x10001
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    208e:	2680      	movs	r6, #128	; 0x80
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2090:	600a      	str	r2, [r1, #0]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
	while (USB1_ENDPTPRIME) ;
    2092:	461a      	mov	r2, r3
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
    2094:	60a1      	str	r1, [r4, #8]
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    2096:	604e      	str	r6, [r1, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
    2098:	60e0      	str	r0, [r4, #12]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    209a:	f8c3 51bc 	str.w	r5, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    209e:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    20a2:	4d1c      	ldr	r5, [pc, #112]	; (2114 <endpoint0_transmit.constprop.1+0x98>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    20a4:	f044 0401 	orr.w	r4, r4, #1
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    20a8:	6088      	str	r0, [r1, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    20aa:	f8c3 41b0 	str.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    20ae:	6028      	str	r0, [r5, #0]
	while (USB1_ENDPTPRIME) ;
    20b0:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    20b4:	2b00      	cmp	r3, #0
    20b6:	d1fb      	bne.n	20b0 <endpoint0_transmit.constprop.1+0x34>
}
    20b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    20ba:	0409      	lsls	r1, r1, #16
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    20bc:	4b16      	ldr	r3, [pc, #88]	; (2118 <endpoint0_transmit.constprop.1+0x9c>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    20be:	4d14      	ldr	r5, [pc, #80]	; (2110 <endpoint0_transmit.constprop.1+0x94>)
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    20c0:	2601      	movs	r6, #1
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    20c2:	4c11      	ldr	r4, [pc, #68]	; (2108 <endpoint0_transmit.constprop.1+0x8c>)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    20c4:	f041 0180 	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    20c8:	2200      	movs	r2, #0
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    20ca:	601e      	str	r6, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    20cc:	6059      	str	r1, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    20ce:	f500 5c80 	add.w	ip, r0, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    20d2:	64e2      	str	r2, [r4, #76]	; 0x4c
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    20d4:	f500 5e00 	add.w	lr, r0, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    20d8:	64a3      	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    20da:	f500 5740 	add.w	r7, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    20de:	f8d5 11b0 	ldr.w	r1, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    20e2:	f500 4680 	add.w	r6, r0, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
    20e6:	462a      	mov	r2, r5
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    20e8:	6098      	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    20ea:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    20ee:	f8c3 c00c 	str.w	ip, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    20f2:	f8c3 e010 	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    20f6:	615f      	str	r7, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    20f8:	619e      	str	r6, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    20fa:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    20fe:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    2102:	2b00      	cmp	r3, #0
    2104:	d1fb      	bne.n	20fe <endpoint0_transmit.constprop.1+0x82>
    2106:	e7bc      	b.n	2082 <endpoint0_transmit.constprop.1+0x6>
    2108:	20000000 	.word	0x20000000
    210c:	200027c0 	.word	0x200027c0
    2110:	402e0000 	.word	0x402e0000
    2114:	200026f4 	.word	0x200026f4
    2118:	200027a0 	.word	0x200027a0

0000211c <usb_isr>:
	__builtin_unreachable();
}


void usb_isr(void)
{
    211c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    2120:	4cb0      	ldr	r4, [pc, #704]	; (23e4 <usb_isr+0x2c8>)
	__builtin_unreachable();
}


void usb_isr(void)
{
    2122:	b083      	sub	sp, #12
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    2124:	f8d4 8144 	ldr.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    2128:	f018 0f01 	tst.w	r8, #1
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
	USB1_USBSTS = status;
    212c:	f8c4 8144 	str.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    2130:	d06f      	beq.n	2212 <usb_isr+0xf6>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    2132:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    2136:	2b00      	cmp	r3, #0
    2138:	d066      	beq.n	2208 <usb_isr+0xec>
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    213a:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
    213e:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 2408 <usb_isr+0x2ec>
    2142:	4fa9      	ldr	r7, [pc, #676]	; (23e8 <usb_isr+0x2cc>)
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    2144:	4626      	mov	r6, r4
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    2146:	46da      	mov	sl, fp
	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
    2148:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
    214c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    214e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    2150:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    2154:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    2158:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    215c:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    2160:	049d      	lsls	r5, r3, #18
    2162:	d5f5      	bpl.n	2150 <usb_isr+0x34>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    2164:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
    2168:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    216c:	f8c6 3140 	str.w	r3, [r6, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    2170:	f8c6 a1b4 	str.w	sl, [r6, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    2174:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
    2178:	f013 1301 	ands.w	r3, r3, #65537	; 0x10001
    217c:	d1fa      	bne.n	2174 <usb_isr+0x58>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    217e:	b281      	uxth	r1, r0
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
    2180:	f8c9 3000 	str.w	r3, [r9]
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    2184:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    2188:	f000 8148 	beq.w	241c <usb_isr+0x300>
    218c:	f200 80bb 	bhi.w	2306 <usb_isr+0x1ea>
    2190:	2982      	cmp	r1, #130	; 0x82
    2192:	f000 8193 	beq.w	24bc <usb_isr+0x3a0>
    2196:	f240 80cf 	bls.w	2338 <usb_isr+0x21c>
    219a:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    219e:	f000 815d 	beq.w	245c <usb_isr+0x340>
    21a2:	f240 3302 	movw	r3, #770	; 0x302
    21a6:	4299      	cmp	r1, r3
    21a8:	f040 80be 	bne.w	2328 <usb_isr+0x20c>
			reply_buffer[0] = 1;
		}
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    21ac:	b292      	uxth	r2, r2
    21ae:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    21b2:	2b07      	cmp	r3, #7
    21b4:	f200 80b8 	bhi.w	2328 <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    21b8:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    21bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
    21c0:	4a8a      	ldr	r2, [pc, #552]	; (23ec <usb_isr+0x2d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    21c2:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    21c6:	f04f 0001 	mov.w	r0, #1
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    21ca:	441a      	add	r2, r3
    21cc:	6813      	ldr	r3, [r2, #0]
    21ce:	bf14      	ite	ne
    21d0:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    21d4:	f043 0301 	orreq.w	r3, r3, #1
    21d8:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    21da:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    21dc:	4b84      	ldr	r3, [pc, #528]	; (23f0 <usb_isr+0x2d4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    21de:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    21e0:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    21e2:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    21e4:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    21e6:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    21ea:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    21ee:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    21f0:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    21f4:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    21f8:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    21fc:	2b00      	cmp	r3, #0
    21fe:	d1fb      	bne.n	21f8 <usb_isr+0xdc>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    2200:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    2204:	2b00      	cmp	r3, #0
    2206:	d19f      	bne.n	2148 <usb_isr+0x2c>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    2208:	4a76      	ldr	r2, [pc, #472]	; (23e4 <usb_isr+0x2c8>)
    220a:	f8d2 31bc 	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    220e:	2b00      	cmp	r3, #0
    2210:	d147      	bne.n	22a2 <usb_isr+0x186>
			}
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
    2212:	f018 0f40 	tst.w	r8, #64	; 0x40
    2216:	d016      	beq.n	2246 <usb_isr+0x12a>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    2218:	4b72      	ldr	r3, [pc, #456]	; (23e4 <usb_isr+0x2c8>)
    221a:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    221e:	4619      	mov	r1, r3
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    2220:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    2224:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    2228:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    222c:	f8d1 31b0 	ldr.w	r3, [r1, #432]	; 0x1b0
    2230:	4a6c      	ldr	r2, [pc, #432]	; (23e4 <usb_isr+0x2c8>)
    2232:	2b00      	cmp	r3, #0
    2234:	d1fa      	bne.n	222c <usb_isr+0x110>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    2236:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    223a:	496e      	ldr	r1, [pc, #440]	; (23f4 <usb_isr+0x2d8>)
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    223c:	f8c2 01b4 	str.w	r0, [r2, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    2240:	f8d2 2184 	ldr.w	r2, [r2, #388]	; 0x184
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    2244:	600b      	str	r3, [r1, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
    2246:	f018 7f80 	tst.w	r8, #16777216	; 0x1000000
    224a:	d003      	beq.n	2254 <usb_isr+0x138>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    224c:	4b6a      	ldr	r3, [pc, #424]	; (23f8 <usb_isr+0x2dc>)
    224e:	681b      	ldr	r3, [r3, #0]
    2250:	b103      	cbz	r3, 2254 <usb_isr+0x138>
    2252:	4798      	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
    2254:	f018 7f00 	tst.w	r8, #33554432	; 0x2000000
    2258:	d003      	beq.n	2262 <usb_isr+0x146>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    225a:	4b68      	ldr	r3, [pc, #416]	; (23fc <usb_isr+0x2e0>)
    225c:	681b      	ldr	r3, [r3, #0]
    225e:	b103      	cbz	r3, 2262 <usb_isr+0x146>
    2260:	4798      	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
    2262:	f018 0f04 	tst.w	r8, #4
    2266:	d008      	beq.n	227a <usb_isr+0x15e>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    2268:	4b5e      	ldr	r3, [pc, #376]	; (23e4 <usb_isr+0x2c8>)
    226a:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    226e:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    2272:	d045      	beq.n	2300 <usb_isr+0x1e4>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
    2274:	4b62      	ldr	r3, [pc, #392]	; (2400 <usb_isr+0x2e4>)
    2276:	2201      	movs	r2, #1
    2278:	701a      	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    227a:	4b5a      	ldr	r3, [pc, #360]	; (23e4 <usb_isr+0x2c8>)
    227c:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    2280:	0612      	lsls	r2, r2, #24
    2282:	d50b      	bpl.n	229c <usb_isr+0x180>
    2284:	f018 0f80 	tst.w	r8, #128	; 0x80
    2288:	d008      	beq.n	229c <usb_isr+0x180>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
    228a:	495e      	ldr	r1, [pc, #376]	; (2404 <usb_isr+0x2e8>)
    228c:	780a      	ldrb	r2, [r1, #0]
    228e:	b12a      	cbz	r2, 229c <usb_isr+0x180>
			if (--usb_reboot_timer == 0) {
    2290:	3a01      	subs	r2, #1
    2292:	b2d2      	uxtb	r2, r2
    2294:	700a      	strb	r2, [r1, #0]
    2296:	2a00      	cmp	r2, #0
    2298:	f000 8217 	beq.w	26ca <usb_isr+0x5ae>
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
    229c:	b003      	add	sp, #12
    229e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    22a2:	4959      	ldr	r1, [pc, #356]	; (2408 <usb_isr+0x2ec>)
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
    22a4:	f8c2 31bc 	str.w	r3, [r2, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    22a8:	6808      	ldr	r0, [r1, #0]
    22aa:	4203      	tst	r3, r0
    22ac:	f040 81b1 	bne.w	2612 <usb_isr+0x4f6>
				endpoint0_notify_mask = 0;
				endpoint0_complete();
			}
			completestatus &= endpointN_notify_mask;
    22b0:	4a50      	ldr	r2, [pc, #320]	; (23f4 <usb_isr+0x2d8>)
    22b2:	6815      	ldr	r5, [r2, #0]
#if 1
			if (completestatus) {
    22b4:	401d      	ands	r5, r3
    22b6:	d0ac      	beq.n	2212 <usb_isr+0xf6>

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    22b8:	0c2e      	lsrs	r6, r5, #16
    22ba:	d00f      	beq.n	22dc <usb_isr+0x1c0>
    22bc:	4f4a      	ldr	r7, [pc, #296]	; (23e8 <usb_isr+0x2cc>)
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
    22be:	f04f 0901 	mov.w	r9, #1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
    22c2:	fa96 f4a6 	rbit	r4, r6
    22c6:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    22ca:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					tx &= ~(1<<p);
    22ce:	fa09 f404 	lsl.w	r4, r9, r4

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    22d2:	3040      	adds	r0, #64	; 0x40
    22d4:	f7ff feb6 	bl	2044 <run_callbacks>
#if 1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    22d8:	43a6      	bics	r6, r4
    22da:	d1f2      	bne.n	22c2 <usb_isr+0x1a6>
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
    22dc:	b2ad      	uxth	r5, r5
				while(rx) {
    22de:	2d00      	cmp	r5, #0
    22e0:	d097      	beq.n	2212 <usb_isr+0xf6>
    22e2:	4f41      	ldr	r7, [pc, #260]	; (23e8 <usb_isr+0x2cc>)
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
					rx &= ~(1<<p);
    22e4:	2601      	movs	r6, #1
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
    22e6:	fa95 f4a5 	rbit	r4, r5
    22ea:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2);
    22ee:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					rx &= ~(1<<p);
    22f2:	fa06 f404 	lsl.w	r4, r6, r4

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
    22f6:	f7ff fea5 	bl	2044 <run_callbacks>
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
    22fa:	43a5      	bics	r5, r4
    22fc:	d1f3      	bne.n	22e6 <usb_isr+0x1ca>
    22fe:	e788      	b.n	2212 <usb_isr+0xf6>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
    2300:	4a3f      	ldr	r2, [pc, #252]	; (2400 <usb_isr+0x2e4>)
    2302:	7013      	strb	r3, [r2, #0]
    2304:	e7b9      	b.n	227a <usb_isr+0x15e>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    2306:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    230a:	f000 80f5 	beq.w	24f8 <usb_isr+0x3dc>
    230e:	d922      	bls.n	2356 <usb_isr+0x23a>
    2310:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    2314:	f000 80fe 	beq.w	2514 <usb_isr+0x3f8>
    2318:	f640 1521 	movw	r5, #2337	; 0x921
    231c:	42a9      	cmp	r1, r5
    231e:	d103      	bne.n	2328 <usb_isr+0x20c>
		endpoint0_receive(endpoint0_buffer, 7, 1);
		return;
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
    2320:	0c11      	lsrs	r1, r2, #16
    2322:	2908      	cmp	r1, #8
    2324:	f240 8126 	bls.w	2574 <usb_isr+0x458>
		}
		break;
#endif
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    2328:	f8c4 b1c0 	str.w	fp, [r4, #448]	; 0x1c0
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    232c:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    2330:	2b00      	cmp	r3, #0
    2332:	f47f af09 	bne.w	2148 <usb_isr+0x2c>
    2336:	e767      	b.n	2208 <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    2338:	2980      	cmp	r1, #128	; 0x80
    233a:	d1f5      	bne.n	2328 <usb_isr+0x20c>
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    233c:	4a33      	ldr	r2, [pc, #204]	; (240c <usb_isr+0x2f0>)
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
    233e:	2102      	movs	r1, #2
    2340:	4610      	mov	r0, r2
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    2342:	7013      	strb	r3, [r2, #0]
		reply_buffer[1] = 0;
    2344:	7053      	strb	r3, [r2, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
    2346:	f7ff fe99 	bl	207c <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    234a:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    234e:	2b00      	cmp	r3, #0
    2350:	f47f aefa 	bne.w	2148 <usb_isr+0x2c>
    2354:	e758      	b.n	2208 <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    2356:	f5a1 61d0 	sub.w	r1, r1, #1664	; 0x680
    235a:	2901      	cmp	r1, #1
    235c:	d8e4      	bhi.n	2328 <usb_isr+0x20c>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    235e:	4b2c      	ldr	r3, [pc, #176]	; (2410 <usb_isr+0x2f4>)
    2360:	6859      	ldr	r1, [r3, #4]
    2362:	2900      	cmp	r1, #0
    2364:	d0e0      	beq.n	2328 <usb_isr+0x20c>
    2366:	0c00      	lsrs	r0, r0, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    2368:	fa1f fe82 	uxth.w	lr, r2
    236c:	e003      	b.n	2376 <usb_isr+0x25a>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    236e:	330c      	adds	r3, #12
    2370:	6859      	ldr	r1, [r3, #4]
    2372:	2900      	cmp	r1, #0
    2374:	d0d8      	beq.n	2328 <usb_isr+0x20c>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    2376:	881d      	ldrh	r5, [r3, #0]
    2378:	4285      	cmp	r5, r0
    237a:	d1f8      	bne.n	236e <usb_isr+0x252>
    237c:	885d      	ldrh	r5, [r3, #2]
    237e:	4575      	cmp	r5, lr
    2380:	d1f5      	bne.n	236e <usb_isr+0x252>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
    2382:	0a05      	lsrs	r5, r0, #8
    2384:	2d03      	cmp	r5, #3
    2386:	f000 817b 	beq.w	2680 <usb_isr+0x564>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
    238a:	891b      	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    238c:	0c12      	lsrs	r2, r2, #16
    238e:	4293      	cmp	r3, r2
    2390:	bf28      	it	cs
    2392:	4613      	movcs	r3, r2

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
    2394:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    2398:	f000 8163 	beq.w	2662 <usb_isr+0x546>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
    239c:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    23a0:	f000 814c 	beq.w	263c <usb_isr+0x520>
    23a4:	4d1b      	ldr	r5, [pc, #108]	; (2414 <usb_isr+0x2f8>)
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
					usb_descriptor_buffer[1] = 7;
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    23a6:	461a      	mov	r2, r3
    23a8:	9301      	str	r3, [sp, #4]
    23aa:	4628      	mov	r0, r5
    23ac:	f004 fc84 	bl	6cb8 <memcpy>
    23b0:	9b01      	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    23b2:	f025 021f 	bic.w	r2, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    23b6:	441d      	add	r5, r3
	asm volatile("": : :"memory");
	asm("dsb");
    23b8:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    23bc:	4916      	ldr	r1, [pc, #88]	; (2418 <usb_isr+0x2fc>)
    23be:	600a      	str	r2, [r1, #0]
		location += 32;
    23c0:	3220      	adds	r2, #32
	} while (location < end_addr);
    23c2:	4295      	cmp	r5, r2
    23c4:	d8fa      	bhi.n	23bc <usb_isr+0x2a0>
	asm("dsb");
    23c6:	f3bf 8f4f 	dsb	sy
	asm("isb");
    23ca:	f3bf 8f6f 	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    23ce:	4811      	ldr	r0, [pc, #68]	; (2414 <usb_isr+0x2f8>)
    23d0:	4619      	mov	r1, r3
    23d2:	f7ff fe53 	bl	207c <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    23d6:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    23da:	2b00      	cmp	r3, #0
    23dc:	f47f aeb4 	bne.w	2148 <usb_isr+0x2c>
    23e0:	e712      	b.n	2208 <usb_isr+0xec>
    23e2:	bf00      	nop
    23e4:	402e0000 	.word	0x402e0000
    23e8:	20000000 	.word	0x20000000
    23ec:	402e01c0 	.word	0x402e01c0
    23f0:	200027c0 	.word	0x200027c0
    23f4:	200026f8 	.word	0x200026f8
    23f8:	20002748 	.word	0x20002748
    23fc:	2000274c 	.word	0x2000274c
    2400:	2000278a 	.word	0x2000278a
    2404:	2000278b 	.word	0x2000278b
    2408:	200026f4 	.word	0x200026f4
    240c:	200026fc 	.word	0x200026fc
    2410:	20000f94 	.word	0x20000f94
    2414:	20200000 	.word	0x20200000
    2418:	e000ef70 	.word	0xe000ef70
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    241c:	4ab2      	ldr	r2, [pc, #712]	; (26e8 <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    241e:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2420:	2501      	movs	r5, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    2422:	64fb      	str	r3, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    2424:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2426:	6015      	str	r5, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    2428:	6051      	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    242a:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    242e:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    2432:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    2434:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
    2438:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    243c:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    2440:	2b00      	cmp	r3, #0
    2442:	d1fb      	bne.n	243c <usb_isr+0x320>

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    2444:	0c03      	lsrs	r3, r0, #16
    2446:	065b      	lsls	r3, r3, #25
    2448:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    244c:	f8c6 3154 	str.w	r3, [r6, #340]	; 0x154
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    2450:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    2454:	2b00      	cmp	r3, #0
    2456:	f47f ae77 	bne.w	2148 <usb_isr+0x2c>
    245a:	e6d5      	b.n	2208 <usb_isr+0xec>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    245c:	b292      	uxth	r2, r2
    245e:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    2462:	2b07      	cmp	r3, #7
    2464:	f63f af60 	bhi.w	2328 <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    2468:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    246c:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2470:	4a9e      	ldr	r2, [pc, #632]	; (26ec <usb_isr+0x5d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    2472:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2476:	f04f 0001 	mov.w	r0, #1
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    247a:	441a      	add	r2, r3
    247c:	6813      	ldr	r3, [r2, #0]
    247e:	bf14      	ite	ne
    2480:	f423 3380 	bicne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    2484:	f023 0301 	biceq.w	r3, r3, #1
    2488:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    248a:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    248c:	4b96      	ldr	r3, [pc, #600]	; (26e8 <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    248e:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    2490:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2492:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    2494:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    2496:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    249a:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    249e:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    24a0:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    24a4:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    24a8:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    24ac:	2b00      	cmp	r3, #0
    24ae:	d1fb      	bne.n	24a8 <usb_isr+0x38c>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    24b0:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    24b4:	2b00      	cmp	r3, #0
    24b6:	f47f ae47 	bne.w	2148 <usb_isr+0x2c>
    24ba:	e6a5      	b.n	2208 <usb_isr+0xec>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
    24bc:	b292      	uxth	r2, r2
    24be:	f002 017f 	and.w	r1, r2, #127	; 0x7f
		if (endpoint > 7) break;
    24c2:	2907      	cmp	r1, #7
    24c4:	f63f af30 	bhi.w	2328 <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    24c8:	0089      	lsls	r1, r1, #2
    24ca:	4888      	ldr	r0, [pc, #544]	; (26ec <usb_isr+0x5d0>)
		reply_buffer[0] = 0;
    24cc:	4d88      	ldr	r5, [pc, #544]	; (26f0 <usb_isr+0x5d4>)
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    24ce:	4408      	add	r0, r1
    24d0:	6801      	ldr	r1, [r0, #0]
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    24d2:	0610      	lsls	r0, r2, #24
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
    24d4:	702b      	strb	r3, [r5, #0]
		reply_buffer[1] = 0;
    24d6:	706b      	strb	r3, [r5, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    24d8:	f140 8097 	bpl.w	260a <usb_isr+0x4ee>
    24dc:	03ca      	lsls	r2, r1, #15
    24de:	d501      	bpl.n	24e4 <usb_isr+0x3c8>
			reply_buffer[0] = 1;
    24e0:	2301      	movs	r3, #1
    24e2:	702b      	strb	r3, [r5, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
    24e4:	2102      	movs	r1, #2
    24e6:	4882      	ldr	r0, [pc, #520]	; (26f0 <usb_isr+0x5d4>)
    24e8:	f7ff fdc8 	bl	207c <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    24ec:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    24f0:	2b00      	cmp	r3, #0
    24f2:	f47f ae29 	bne.w	2148 <usb_isr+0x2c>
    24f6:	e687      	b.n	2208 <usb_isr+0xec>
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    24f8:	4a7e      	ldr	r2, [pc, #504]	; (26f4 <usb_isr+0x5d8>)
		endpoint0_transmit(reply_buffer, 1, 0);
    24fa:	2101      	movs	r1, #1
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    24fc:	4b7c      	ldr	r3, [pc, #496]	; (26f0 <usb_isr+0x5d4>)
    24fe:	7812      	ldrb	r2, [r2, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    2500:	4618      	mov	r0, r3
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    2502:	701a      	strb	r2, [r3, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    2504:	f7ff fdba 	bl	207c <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    2508:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    250c:	2b00      	cmp	r3, #0
    250e:	f47f ae1b 	bne.w	2148 <usb_isr+0x2c>
    2512:	e679      	b.n	2208 <usb_isr+0xec>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    2514:	f3c0 4007 	ubfx	r0, r0, #16, #8
    2518:	4a76      	ldr	r2, [pc, #472]	; (26f4 <usb_isr+0x5d8>)
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    251a:	4977      	ldr	r1, [pc, #476]	; (26f8 <usb_isr+0x5dc>)
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    251c:	f04f 15cc 	mov.w	r5, #13369548	; 0xcc00cc
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    2520:	7010      	strb	r0, [r2, #0]
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    2522:	4a76      	ldr	r2, [pc, #472]	; (26fc <usb_isr+0x5e0>)
    2524:	9301      	str	r3, [sp, #4]
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    2526:	f8c6 51c8 	str.w	r5, [r6, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    252a:	f8c6 11cc 	str.w	r1, [r6, #460]	; 0x1cc
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    252e:	f8c6 21d0 	str.w	r2, [r6, #464]	; 0x1d0
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
		#elif defined(SEREMU_INTERFACE)
		usb_seremu_configure();
    2532:	f000 fab3 	bl	2a9c <usb_seremu_configure>
		#endif
		#if defined(CDC3_STATUS_INTERFACE) && defined(CDC3_DATA_INTERFACE)
		usb_serial3_configure();
		#endif
		#if defined(RAWHID_INTERFACE)
		usb_rawhid_configure();
    2536:	f000 fa19 	bl	296c <usb_rawhid_configure>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    253a:	4a6b      	ldr	r2, [pc, #428]	; (26e8 <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    253c:	9b01      	ldr	r3, [sp, #4]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    253e:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2540:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    2542:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    2544:	6051      	str	r1, [r2, #4]
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    2546:	6010      	str	r0, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    2548:	64fb      	str	r3, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    254a:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    254e:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    2552:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    2554:	f441 3280 	orr.w	r2, r1, #65536	; 0x10000
    2558:	f8c6 21b0 	str.w	r2, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    255c:	4a68      	ldr	r2, [pc, #416]	; (2700 <usb_isr+0x5e4>)
    255e:	6013      	str	r3, [r2, #0]
	while (USB1_ENDPTPRIME) ;
    2560:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    2564:	2b00      	cmp	r3, #0
    2566:	d1fb      	bne.n	2560 <usb_isr+0x444>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    2568:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    256c:	2b00      	cmp	r3, #0
    256e:	f47f adeb 	bne.w	2148 <usb_isr+0x2c>
    2572:	e649      	b.n	2208 <usb_isr+0xec>
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    2574:	f8df e194 	ldr.w	lr, [pc, #404]	; 270c <usb_isr+0x5f0>
			endpoint0_buffer[0] = 0xE9;
    2578:	f04f 0ce9 	mov.w	ip, #233	; 0xe9
    257c:	4d61      	ldr	r5, [pc, #388]	; (2704 <usb_isr+0x5e8>)
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    257e:	e88e 0005 	stmia.w	lr, {r0, r2}
			endpoint0_buffer[0] = 0xE9;
    2582:	f885 c000 	strb.w	ip, [r5]
}

static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
    2586:	b301      	cbz	r1, 25ca <usb_isr+0x4ae>
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    2588:	0409      	lsls	r1, r1, #16
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    258a:	4a5f      	ldr	r2, [pc, #380]	; (2708 <usb_isr+0x5ec>)
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
    258c:	60fb      	str	r3, [r7, #12]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    258e:	2001      	movs	r0, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    2590:	f041 0380 	orr.w	r3, r1, #128	; 0x80
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    2594:	60ba      	str	r2, [r7, #8]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    2596:	6010      	str	r0, [r2, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    2598:	f505 5e00 	add.w	lr, r5, #8192	; 0x2000
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    259c:	6053      	str	r3, [r2, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    259e:	f505 5080 	add.w	r0, r5, #4096	; 0x1000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    25a2:	f8d6 31b0 	ldr.w	r3, [r6, #432]	; 0x1b0
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    25a6:	f505 5140 	add.w	r1, r5, #12288	; 0x3000
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    25aa:	6095      	str	r5, [r2, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    25ac:	f505 4580 	add.w	r5, r5, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    25b0:	f043 0301 	orr.w	r3, r3, #1
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    25b4:	60d0      	str	r0, [r2, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    25b6:	f8c2 e010 	str.w	lr, [r2, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    25ba:	6151      	str	r1, [r2, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    25bc:	6195      	str	r5, [r2, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    25be:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    25c2:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    25c6:	2b00      	cmp	r3, #0
    25c8:	d1fb      	bne.n	25c2 <usb_isr+0x4a6>
	}
	endpoint0_transfer_ack.next = 1;
    25ca:	4b47      	ldr	r3, [pc, #284]	; (26e8 <usb_isr+0x5cc>)
    25cc:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    25ce:	f248 0280 	movw	r2, #32896	; 0x8080
	endpoint0_transfer_ack.pointer0 = 0;
    25d2:	2100      	movs	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    25d4:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    25d6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    25da:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    25dc:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    25de:	64f9      	str	r1, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    25e0:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    25e4:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    25e8:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    25ea:	ea42 0300 	orr.w	r3, r2, r0
    25ee:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    25f2:	f8c9 0000 	str.w	r0, [r9]
	while (USB1_ENDPTPRIME) ;
    25f6:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    25fa:	2b00      	cmp	r3, #0
    25fc:	d1fb      	bne.n	25f6 <usb_isr+0x4da>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    25fe:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    2602:	2b00      	cmp	r3, #0
    2604:	f47f ada0 	bne.w	2148 <usb_isr+0x2c>
    2608:	e5fe      	b.n	2208 <usb_isr+0xec>
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    260a:	07cb      	lsls	r3, r1, #31
    260c:	f57f af6a 	bpl.w	24e4 <usb_isr+0x3c8>
    2610:	e766      	b.n	24e0 <usb_isr+0x3c4>

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    2612:	483e      	ldr	r0, [pc, #248]	; (270c <usb_isr+0x5f0>)
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    2614:	2600      	movs	r6, #0
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    2616:	4c3e      	ldr	r4, [pc, #248]	; (2710 <usb_isr+0x5f4>)

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    2618:	6805      	ldr	r5, [r0, #0]
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    261a:	600e      	str	r6, [r1, #0]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    261c:	42a5      	cmp	r5, r4

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    261e:	6840      	ldr	r0, [r0, #4]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    2620:	f47f ae46 	bne.w	22b0 <usb_isr+0x194>
    2624:	493b      	ldr	r1, [pc, #236]	; (2714 <usb_isr+0x5f8>)
    2626:	4288      	cmp	r0, r1
    2628:	f47f ae42 	bne.w	22b0 <usb_isr+0x194>
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    262c:	4935      	ldr	r1, [pc, #212]	; (2704 <usb_isr+0x5e8>)
    262e:	7808      	ldrb	r0, [r1, #0]
    2630:	28a9      	cmp	r0, #169	; 0xa9
    2632:	d02b      	beq.n	268c <usb_isr+0x570>
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
		} else {
			// any other feature report means Arduino Serial Monitor is open
			usb_seremu_online = 1;
    2634:	4a38      	ldr	r2, [pc, #224]	; (2718 <usb_isr+0x5fc>)
    2636:	2101      	movs	r1, #1
    2638:	7011      	strb	r1, [r2, #0]
    263a:	e639      	b.n	22b0 <usb_isr+0x194>
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    263c:	4837      	ldr	r0, [pc, #220]	; (271c <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    263e:	461a      	mov	r2, r3
    2640:	4d37      	ldr	r5, [pc, #220]	; (2720 <usb_isr+0x604>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    2642:	f890 e000 	ldrb.w	lr, [r0]
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
    2646:	4937      	ldr	r1, [pc, #220]	; (2724 <usb_isr+0x608>)
    2648:	4837      	ldr	r0, [pc, #220]	; (2728 <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
    264a:	9301      	str	r3, [sp, #4]
    264c:	f1be 0f00 	cmp.w	lr, #0
    2650:	bf08      	it	eq
    2652:	4601      	moveq	r1, r0
    2654:	4628      	mov	r0, r5
    2656:	f004 fb2f 	bl	6cb8 <memcpy>
					usb_descriptor_buffer[1] = 7;
    265a:	2207      	movs	r2, #7
    265c:	9b01      	ldr	r3, [sp, #4]
    265e:	706a      	strb	r2, [r5, #1]
    2660:	e6a7      	b.n	23b2 <usb_isr+0x296>

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
    2662:	482e      	ldr	r0, [pc, #184]	; (271c <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    2664:	461a      	mov	r2, r3
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    2666:	4930      	ldr	r1, [pc, #192]	; (2728 <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_480;
    2668:	7805      	ldrb	r5, [r0, #0]
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    266a:	482e      	ldr	r0, [pc, #184]	; (2724 <usb_isr+0x608>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
    266c:	9301      	str	r3, [sp, #4]
    266e:	2d00      	cmp	r5, #0
    2670:	bf08      	it	eq
    2672:	4601      	moveq	r1, r0
    2674:	482a      	ldr	r0, [pc, #168]	; (2720 <usb_isr+0x604>)
    2676:	f004 fb1f 	bl	6cb8 <memcpy>
    267a:	4d29      	ldr	r5, [pc, #164]	; (2720 <usb_isr+0x604>)
    267c:	9b01      	ldr	r3, [sp, #4]
    267e:	e698      	b.n	23b2 <usb_isr+0x296>
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    2680:	0c12      	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
    2682:	780b      	ldrb	r3, [r1, #0]
    2684:	4293      	cmp	r3, r2
    2686:	bf28      	it	cs
    2688:	4613      	movcs	r3, r2
    268a:	e687      	b.n	239c <usb_isr+0x280>
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    268c:	7848      	ldrb	r0, [r1, #1]
    268e:	2845      	cmp	r0, #69	; 0x45
    2690:	d1d0      	bne.n	2634 <usb_isr+0x518>
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
    2692:	7888      	ldrb	r0, [r1, #2]
    2694:	28c2      	cmp	r0, #194	; 0xc2
    2696:	d1cd      	bne.n	2634 <usb_isr+0x518>
    2698:	78c9      	ldrb	r1, [r1, #3]
    269a:	296b      	cmp	r1, #107	; 0x6b
    269c:	d1ca      	bne.n	2634 <usb_isr+0x518>
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
    269e:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    26a0:	4822      	ldr	r0, [pc, #136]	; (272c <usb_isr+0x610>)
    26a2:	7801      	ldrb	r1, [r0, #0]
    26a4:	f041 0104 	orr.w	r1, r1, #4
    26a8:	7001      	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    26aa:	f8d2 1148 	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    26ae:	0608      	lsls	r0, r1, #24
    26b0:	d406      	bmi.n	26c0 <usb_isr+0x5a4>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    26b2:	f041 0180 	orr.w	r1, r1, #128	; 0x80
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    26b6:	2080      	movs	r0, #128	; 0x80
    26b8:	f8c2 0144 	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    26bc:	f8c2 1148 	str.w	r1, [r2, #328]	; 0x148
	}
	__enable_irq();
    26c0:	b662      	cpsie	i
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    26c2:	4a1b      	ldr	r2, [pc, #108]	; (2730 <usb_isr+0x614>)
    26c4:	2150      	movs	r1, #80	; 0x50
    26c6:	7011      	strb	r1, [r2, #0]
    26c8:	e5f2      	b.n	22b0 <usb_isr+0x194>
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
    26ca:	4918      	ldr	r1, [pc, #96]	; (272c <usb_isr+0x610>)
    26cc:	780a      	ldrb	r2, [r1, #0]
    26ce:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    26d2:	700a      	strb	r2, [r1, #0]
	if (sof_usage == 0) {
    26d4:	b92a      	cbnz	r2, 26e2 <usb_isr+0x5c6>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    26d6:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    26da:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    26de:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
			if (--usb_reboot_timer == 0) {
				usb_stop_sof_interrupts(NUM_INTERFACE);
				_reboot_Teensyduino_();
    26e2:	f008 f909 	bl	a8f8 <___reboot_Teensyduino__veneer>
    26e6:	bf00      	nop
    26e8:	200027c0 	.word	0x200027c0
    26ec:	402e01c0 	.word	0x402e01c0
    26f0:	200026fc 	.word	0x200026fc
    26f4:	20002789 	.word	0x20002789
    26f8:	00cc0002 	.word	0x00cc0002
    26fc:	000200cc 	.word	0x000200cc
    2700:	200026f4 	.word	0x200026f4
    2704:	200026ec 	.word	0x200026ec
    2708:	200027a0 	.word	0x200027a0
    270c:	20002660 	.word	0x20002660
    2710:	03000921 	.word	0x03000921
    2714:	00040001 	.word	0x00040001
    2718:	2000278c 	.word	0x2000278c
    271c:	2000278a 	.word	0x2000278a
    2720:	20200000 	.word	0x20200000
    2724:	600020e8 	.word	0x600020e8
    2728:	60002134 	.word	0x60002134
    272c:	20002784 	.word	0x20002784
    2730:	2000278b 	.word	0x2000278b

00002734 <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    2734:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    2736:	f1a0 0202 	sub.w	r2, r0, #2
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    273a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    273e:	bf14      	ite	ne
    2740:	2700      	movne	r7, #0
    2742:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    2746:	2a02      	cmp	r2, #2
    2748:	d901      	bls.n	274e <usb_config_rx+0x1a>
    274a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    274e:	ea4f 19c0 	mov.w	r9, r0, lsl #7
    2752:	f8df a040 	ldr.w	sl, [pc, #64]	; 2794 <usb_config_rx+0x60>
    2756:	460d      	mov	r5, r1
    2758:	4604      	mov	r4, r0
    275a:	eb0a 0609 	add.w	r6, sl, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    275e:	2100      	movs	r1, #0
    2760:	2240      	movs	r2, #64	; 0x40
    2762:	4698      	mov	r8, r3
    2764:	4630      	mov	r0, r6
    2766:	f004 fba5 	bl	6eb4 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    276a:	2001      	movs	r0, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    276c:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
    2770:	f84a 1009 	str.w	r1, [sl, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    2774:	f8c6 8038 	str.w	r8, [r6, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    2778:	60b0      	str	r0, [r6, #8]
void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
    277a:	f1b8 0f00 	cmp.w	r8, #0
    277e:	d0e4      	beq.n	274a <usb_config_rx+0x16>
    2780:	4b03      	ldr	r3, [pc, #12]	; (2790 <usb_config_rx+0x5c>)
    2782:	40a0      	lsls	r0, r4
    2784:	681c      	ldr	r4, [r3, #0]
    2786:	4320      	orrs	r0, r4
    2788:	6018      	str	r0, [r3, #0]
    278a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    278e:	bf00      	nop
    2790:	200026f8 	.word	0x200026f8
    2794:	20000000 	.word	0x20000000

00002798 <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    2798:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    279a:	f1a0 0202 	sub.w	r2, r0, #2
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    279e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    27a2:	bf14      	ite	ne
    27a4:	2700      	movne	r7, #0
    27a6:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    27aa:	2a02      	cmp	r2, #2
    27ac:	d901      	bls.n	27b2 <usb_config_tx+0x1a>
    27ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    27b2:	2240      	movs	r2, #64	; 0x40

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    27b4:	01c5      	lsls	r5, r0, #7
    27b6:	f8df 9044 	ldr.w	r9, [pc, #68]	; 27fc <usb_config_tx+0x64>
    27ba:	4688      	mov	r8, r1
    27bc:	4415      	add	r5, r2
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    27be:	2100      	movs	r1, #0
    27c0:	4604      	mov	r4, r0
    27c2:	461e      	mov	r6, r3

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    27c4:	eb09 0a05 	add.w	sl, r9, r5
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    27c8:	4650      	mov	r0, sl
    27ca:	f004 fb73 	bl	6eb4 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    27ce:	2201      	movs	r2, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    27d0:	ea47 4108 	orr.w	r1, r7, r8, lsl #16
    27d4:	f849 1005 	str.w	r1, [r9, r5]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    27d8:	f8ca 6038 	str.w	r6, [sl, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    27dc:	f8ca 2008 	str.w	r2, [sl, #8]
void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    27e0:	2e00      	cmp	r6, #0
    27e2:	d0e4      	beq.n	27ae <usb_config_tx+0x16>
    27e4:	f104 0010 	add.w	r0, r4, #16
    27e8:	4b03      	ldr	r3, [pc, #12]	; (27f8 <usb_config_tx+0x60>)
    27ea:	4082      	lsls	r2, r0
    27ec:	6818      	ldr	r0, [r3, #0]
    27ee:	4302      	orrs	r2, r0
    27f0:	601a      	str	r2, [r3, #0]
    27f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    27f6:	bf00      	nop
    27f8:	200026f8 	.word	0x200026f8
    27fc:	20000000 	.word	0x20000000

00002800 <usb_prepare_transfer>:


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    2800:	0412      	lsls	r2, r2, #16
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
    2802:	6081      	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
	transfer->pointer2 = addr + 8192;
	transfer->pointer3 = addr + 12288;
	transfer->pointer4 = addr + 16384;
	transfer->callback_param = param;
    2804:	61c3      	str	r3, [r0, #28]


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    2806:	f042 0280 	orr.w	r2, r2, #128	; 0x80
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
    280a:	b4f0      	push	{r4, r5, r6, r7}
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    280c:	6042      	str	r2, [r0, #4]



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    280e:	2701      	movs	r7, #1
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    2810:	f501 5680 	add.w	r6, r1, #4096	; 0x1000
	transfer->pointer2 = addr + 8192;
    2814:	f501 5500 	add.w	r5, r1, #8192	; 0x2000
	transfer->pointer3 = addr + 12288;
    2818:	f501 5440 	add.w	r4, r1, #12288	; 0x3000
	transfer->pointer4 = addr + 16384;
    281c:	f501 4280 	add.w	r2, r1, #16384	; 0x4000



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    2820:	6007      	str	r7, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    2822:	60c6      	str	r6, [r0, #12]
	transfer->pointer2 = addr + 8192;
    2824:	6105      	str	r5, [r0, #16]
	transfer->pointer3 = addr + 12288;
    2826:	6144      	str	r4, [r0, #20]
	transfer->pointer4 = addr + 16384;
    2828:	6182      	str	r2, [r0, #24]
	transfer->callback_param = param;
}
    282a:	bcf0      	pop	{r4, r5, r6, r7}
    282c:	4770      	bx	lr
    282e:	bf00      	nop

00002830 <usb_transmit>:
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    2830:	1e83      	subs	r3, r0, #2
    2832:	2b02      	cmp	r3, #2
    2834:	d900      	bls.n	2838 <usb_transmit+0x8>
    2836:	4770      	bx	lr
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    2838:	4b06      	ldr	r3, [pc, #24]	; (2854 <usb_transmit+0x24>)
    283a:	460a      	mov	r2, r1
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
    283c:	b430      	push	{r4, r5}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    283e:	f100 0410 	add.w	r4, r0, #16
    2842:	2501      	movs	r5, #1
    2844:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    2848:	fa05 f104 	lsl.w	r1, r5, r4
    284c:	3040      	adds	r0, #64	; 0x40
}
    284e:	bc30      	pop	{r4, r5}
void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    2850:	f7ff bbb0 	b.w	1fb4 <schedule_transfer>
    2854:	20000000 	.word	0x20000000

00002858 <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    2858:	1e83      	subs	r3, r0, #2
    285a:	2b02      	cmp	r3, #2
    285c:	d900      	bls.n	2860 <usb_receive+0x8>
    285e:	4770      	bx	lr
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
    2860:	b410      	push	{r4}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    2862:	4b05      	ldr	r3, [pc, #20]	; (2878 <usb_receive+0x20>)
    2864:	2401      	movs	r4, #1
    2866:	460a      	mov	r2, r1
    2868:	fa04 f100 	lsl.w	r1, r4, r0
    286c:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
}
    2870:	f85d 4b04 	ldr.w	r4, [sp], #4
void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    2874:	f7ff bb9e 	b.w	1fb4 <schedule_transfer>
    2878:	20000000 	.word	0x20000000

0000287c <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    287c:	6840      	ldr	r0, [r0, #4]
#endif
}
    287e:	4770      	bx	lr

00002880 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    2880:	4a12      	ldr	r2, [pc, #72]	; (28cc <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    2882:	4b13      	ldr	r3, [pc, #76]	; (28d0 <usb_init_serialnumber+0x50>)
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    2884:	f8d2 0220 	ldr.w	r0, [r2, #544]	; 0x220
    2888:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    288c:	4298      	cmp	r0, r3
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    288e:	b510      	push	{r4, lr}
    2890:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    2892:	d802      	bhi.n	289a <usb_init_serialnumber+0x1a>
    2894:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    2898:	0040      	lsls	r0, r0, #1
    289a:	4c0e      	ldr	r4, [pc, #56]	; (28d4 <usb_init_serialnumber+0x54>)
	ultoa(num, buf, 10);
    289c:	a901      	add	r1, sp, #4
    289e:	220a      	movs	r2, #10
    28a0:	f7ff f868 	bl	1974 <ultoa>
    28a4:	a901      	add	r1, sp, #4
	for (i=0; i<10; i++) {
    28a6:	2300      	movs	r3, #0
    28a8:	4620      	mov	r0, r4
		char c = buf[i];
    28aa:	f811 2b01 	ldrb.w	r2, [r1], #1
    28ae:	3301      	adds	r3, #1
		if (!c) break;
    28b0:	b13a      	cbz	r2, 28c2 <usb_init_serialnumber+0x42>

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    28b2:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    28b4:	f820 2f02 	strh.w	r2, [r0, #2]!

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    28b8:	d1f7      	bne.n	28aa <usb_init_serialnumber+0x2a>
    28ba:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    28bc:	7023      	strb	r3, [r4, #0]
}
    28be:	b004      	add	sp, #16
    28c0:	bd10      	pop	{r4, pc}
    28c2:	005b      	lsls	r3, r3, #1
    28c4:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    28c6:	7023      	strb	r3, [r4, #0]
}
    28c8:	b004      	add	sp, #16
    28ca:	bd10      	pop	{r4, pc}
    28cc:	401f4400 	.word	0x401f4400
    28d0:	0098967f 	.word	0x0098967f
    28d4:	20001e28 	.word	0x20001e28

000028d8 <rx_event>:
static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    28d8:	4a0a      	ldr	r2, [pc, #40]	; (2904 <rx_event+0x2c>)
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
    28da:	b410      	push	{r4}
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    28dc:	7813      	ldrb	r3, [r2, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
    28de:	69c4      	ldr	r4, [r0, #28]
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    28e0:	3301      	adds	r3, #1
    28e2:	2b04      	cmp	r3, #4
    28e4:	d907      	bls.n	28f6 <rx_event+0x1e>
    28e6:	2100      	movs	r1, #0
	rx_list[head] = i;
    28e8:	4807      	ldr	r0, [pc, #28]	; (2908 <rx_event+0x30>)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    28ea:	460b      	mov	r3, r1
	rx_list[head] = i;
	rx_head = head;
    28ec:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    28ee:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    28f0:	f85d 4b04 	ldr.w	r4, [sp], #4
    28f4:	4770      	bx	lr
    28f6:	b2d9      	uxtb	r1, r3
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    28f8:	4803      	ldr	r0, [pc, #12]	; (2908 <rx_event+0x30>)
	rx_head = head;
    28fa:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    28fc:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    28fe:	f85d 4b04 	ldr.w	r4, [sp], #4
    2902:	4770      	bx	lr
    2904:	20002780 	.word	0x20002780
    2908:	20002718 	.word	0x20002718

0000290c <rx_queue_transfer>:
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
    290c:	4912      	ldr	r1, [pc, #72]	; (2958 <rx_queue_transfer+0x4c>)
    290e:	eb01 1180 	add.w	r1, r1, r0, lsl #6
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    2912:	b538      	push	{r3, r4, r5, lr}
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    2914:	f021 021f 	bic.w	r2, r1, #31
    2918:	4603      	mov	r3, r0
	uint32_t end_addr = (uint32_t)addr + size;
    291a:	f101 0540 	add.w	r5, r1, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    291e:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    2922:	4c0e      	ldr	r4, [pc, #56]	; (295c <rx_queue_transfer+0x50>)
    2924:	6022      	str	r2, [r4, #0]
		location += 32;
    2926:	3220      	adds	r2, #32
	} while (location < end_addr);
    2928:	4295      	cmp	r5, r2
    292a:	d8fb      	bhi.n	2924 <rx_queue_transfer+0x18>
	asm("dsb");
    292c:	f3bf 8f4f 	dsb	sy
	asm("isb");
    2930:	f3bf 8f6f 	isb	sy
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    2934:	4c0a      	ldr	r4, [pc, #40]	; (2960 <rx_queue_transfer+0x54>)
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    2936:	f44f 3500 	mov.w	r5, #131072	; 0x20000
    293a:	4a0a      	ldr	r2, [pc, #40]	; (2964 <rx_queue_transfer+0x58>)
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    293c:	eb04 1443 	add.w	r4, r4, r3, lsl #5
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    2940:	6015      	str	r5, [r2, #0]
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    2942:	2240      	movs	r2, #64	; 0x40
    2944:	4620      	mov	r0, r4
    2946:	f7ff ff5b 	bl	2800 <usb_prepare_transfer>
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
    294a:	4621      	mov	r1, r4
    294c:	2004      	movs	r0, #4
    294e:	f7ff ff83 	bl	2858 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    2952:	4b05      	ldr	r3, [pc, #20]	; (2968 <rx_queue_transfer+0x5c>)
    2954:	601d      	str	r5, [r3, #0]
    2956:	bd38      	pop	{r3, r4, r5, pc}
    2958:	20200060 	.word	0x20200060
    295c:	e000ef5c 	.word	0xe000ef5c
    2960:	200022e0 	.word	0x200022e0
    2964:	e000e18c 	.word	0xe000e18c
    2968:	e000e10c 	.word	0xe000e10c

0000296c <usb_rawhid_configure>:


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    296c:	2100      	movs	r1, #0
    296e:	4816      	ldr	r0, [pc, #88]	; (29c8 <usb_rawhid_configure+0x5c>)
static void rx_event(transfer_t *t);
extern volatile uint8_t usb_configuration;


void usb_rawhid_configure(void)
{
    2970:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    2972:	2580      	movs	r5, #128	; 0x80
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    2974:	460c      	mov	r4, r1
	rx_head = 0;
    2976:	4f15      	ldr	r7, [pc, #84]	; (29cc <usb_rawhid_configure+0x60>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    2978:	462a      	mov	r2, r5
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    297a:	4e15      	ldr	r6, [pc, #84]	; (29d0 <usb_rawhid_configure+0x64>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    297c:	f004 fa9a 	bl	6eb4 <memset>
	memset(rx_transfer, 0, sizeof(rx_transfer));
    2980:	462a      	mov	r2, r5
    2982:	4621      	mov	r1, r4
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
    2984:	4d13      	ldr	r5, [pc, #76]	; (29d4 <usb_rawhid_configure+0x68>)

void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
    2986:	4814      	ldr	r0, [pc, #80]	; (29d8 <usb_rawhid_configure+0x6c>)
    2988:	f004 fa94 	bl	6eb4 <memset>
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    298c:	4623      	mov	r3, r4
    298e:	4622      	mov	r2, r4
    2990:	2140      	movs	r1, #64	; 0x40
    2992:	2003      	movs	r0, #3
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
	rx_head = 0;
    2994:	703c      	strb	r4, [r7, #0]
void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    2996:	7034      	strb	r4, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
    2998:	702c      	strb	r4, [r5, #0]
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    299a:	f7ff fefd 	bl	2798 <usb_config_tx>
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
    299e:	4622      	mov	r2, r4
    29a0:	4b0e      	ldr	r3, [pc, #56]	; (29dc <usb_rawhid_configure+0x70>)
    29a2:	2140      	movs	r1, #64	; 0x40
    29a4:	2004      	movs	r0, #4
    29a6:	f7ff fec5 	bl	2734 <usb_config_rx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    29aa:	4620      	mov	r0, r4
    29ac:	f7ff ffae 	bl	290c <rx_queue_transfer>
    29b0:	2001      	movs	r0, #1
    29b2:	f7ff ffab 	bl	290c <rx_queue_transfer>
    29b6:	2002      	movs	r0, #2
    29b8:	f7ff ffa8 	bl	290c <rx_queue_transfer>
    29bc:	2003      	movs	r0, #3
}
    29be:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    29c2:	f7ff bfa3 	b.w	290c <rx_queue_transfer>
    29c6:	bf00      	nop
    29c8:	20002460 	.word	0x20002460
    29cc:	20002780 	.word	0x20002780
    29d0:	20002786 	.word	0x20002786
    29d4:	20002782 	.word	0x20002782
    29d8:	200022e0 	.word	0x200022e0
    29dc:	000028d9 	.word	0x000028d9

000029e0 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    29e0:	b570      	push	{r4, r5, r6, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    29e2:	0141      	lsls	r1, r0, #5
    29e4:	4c12      	ldr	r4, [pc, #72]	; (2a30 <rx_queue_transfer+0x50>)
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    29e6:	4d13      	ldr	r5, [pc, #76]	; (2a34 <rx_queue_transfer+0x54>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    29e8:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    29ea:	440c      	add	r4, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    29ec:	f44f 3600 	mov.w	r6, #131072	; 0x20000
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    29f0:	440d      	add	r5, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    29f2:	4811      	ldr	r0, [pc, #68]	; (2a38 <rx_queue_transfer+0x58>)
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    29f4:	4621      	mov	r1, r4
    29f6:	2220      	movs	r2, #32
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    29f8:	6006      	str	r6, [r0, #0]
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    29fa:	4628      	mov	r0, r5
    29fc:	f7ff ff00 	bl	2800 <usb_prepare_transfer>
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    2a00:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    2a04:	f104 0120 	add.w	r1, r4, #32
	asm volatile("": : :"memory");
	asm("dsb");
    2a08:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    2a0c:	4a0b      	ldr	r2, [pc, #44]	; (2a3c <rx_queue_transfer+0x5c>)
    2a0e:	6013      	str	r3, [r2, #0]
		location += 32;
    2a10:	3320      	adds	r3, #32
	} while (location < end_addr);
    2a12:	4299      	cmp	r1, r3
    2a14:	d8fb      	bhi.n	2a0e <rx_queue_transfer+0x2e>
	asm("dsb");
    2a16:	f3bf 8f4f 	dsb	sy
	asm("isb");
    2a1a:	f3bf 8f6f 	isb	sy
	arm_dcache_delete(buffer, SEREMU_RX_SIZE);
	usb_receive(SEREMU_RX_ENDPOINT, rx_transfer + i);
    2a1e:	2002      	movs	r0, #2
    2a20:	4629      	mov	r1, r5
    2a22:	f7ff ff19 	bl	2858 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    2a26:	4b06      	ldr	r3, [pc, #24]	; (2a40 <rx_queue_transfer+0x60>)
    2a28:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    2a2c:	601a      	str	r2, [r3, #0]
    2a2e:	bd70      	pop	{r4, r5, r6, pc}
    2a30:	20200260 	.word	0x20200260
    2a34:	20002360 	.word	0x20002360
    2a38:	e000e18c 	.word	0xe000e18c
    2a3c:	e000ef5c 	.word	0xe000ef5c
    2a40:	e000e10c 	.word	0xe000e10c

00002a44 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
    2a44:	6843      	ldr	r3, [r0, #4]
	int i = t->callback_param;
    2a46:	69c0      	ldr	r0, [r0, #28]
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    2a48:	f3c3 430e 	ubfx	r3, r3, #16, #15
    2a4c:	b10b      	cbz	r3, 2a52 <rx_event+0xe>
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
    2a4e:	f7ff bfc7 	b.w	29e0 <rx_queue_transfer>
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    2a52:	490d      	ldr	r1, [pc, #52]	; (2a88 <rx_event+0x44>)
    2a54:	0142      	lsls	r2, r0, #5
    2a56:	5c8a      	ldrb	r2, [r1, r2]
    2a58:	2a00      	cmp	r2, #0
    2a5a:	d0f8      	beq.n	2a4e <rx_event+0xa>
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
    2a5c:	490b      	ldr	r1, [pc, #44]	; (2a8c <rx_event+0x48>)
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
    2a5e:	b410      	push	{r4}
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    2a60:	4c0b      	ldr	r4, [pc, #44]	; (2a90 <rx_event+0x4c>)
		rx_index[i] = 0;
    2a62:	f821 3010 	strh.w	r3, [r1, r0, lsl #1]
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    2a66:	7822      	ldrb	r2, [r4, #0]
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
    2a68:	490a      	ldr	r1, [pc, #40]	; (2a94 <rx_event+0x50>)
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    2a6a:	3201      	adds	r2, #1
    2a6c:	2a08      	cmp	r2, #8
    2a6e:	bf94      	ite	ls
    2a70:	b2d3      	uxtbls	r3, r2
    2a72:	461a      	movhi	r2, r3
		rx_list[head] = i;
		rx_head = head;
    2a74:	7023      	strb	r3, [r4, #0]
		rx_available += len;
    2a76:	680b      	ldr	r3, [r1, #0]
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    2a78:	4c07      	ldr	r4, [pc, #28]	; (2a98 <rx_event+0x54>)
		rx_head = head;
		rx_available += len;
    2a7a:	3320      	adds	r3, #32
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    2a7c:	54a0      	strb	r0, [r4, r2]
		rx_head = head;
		rx_available += len;
    2a7e:	600b      	str	r3, [r1, #0]
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
	}
}
    2a80:	f85d 4b04 	ldr.w	r4, [sp], #4
    2a84:	4770      	bx	lr
    2a86:	bf00      	nop
    2a88:	20200260 	.word	0x20200260
    2a8c:	20002708 	.word	0x20002708
    2a90:	20002781 	.word	0x20002781
    2a94:	20002704 	.word	0x20002704
    2a98:	20002720 	.word	0x20002720

00002a9c <usb_seremu_configure>:


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    2a9c:	2100      	movs	r1, #0
    2a9e:	f44f 72c0 	mov.w	r2, #384	; 0x180
    2aa2:	481f      	ldr	r0, [pc, #124]	; (2b20 <usb_seremu_configure+0x84>)
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_seremu_configure(void)
{
    2aa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    2aa6:	460d      	mov	r5, r1
    2aa8:	4c1e      	ldr	r4, [pc, #120]	; (2b24 <usb_seremu_configure+0x88>)


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    2aaa:	f004 fa03 	bl	6eb4 <memset>
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    2aae:	4e1e      	ldr	r6, [pc, #120]	; (2b28 <usb_seremu_configure+0x8c>)
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    2ab0:	4b1e      	ldr	r3, [pc, #120]	; (2b2c <usb_seremu_configure+0x90>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    2ab2:	4629      	mov	r1, r5
    2ab4:	f44f 7280 	mov.w	r2, #256	; 0x100
    2ab8:	481d      	ldr	r0, [pc, #116]	; (2b30 <usb_seremu_configure+0x94>)

void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    2aba:	7025      	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    2abc:	462c      	mov	r4, r5
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    2abe:	801d      	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    2ac0:	f004 f9f8 	bl	6eb4 <memset>
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    2ac4:	7035      	strb	r5, [r6, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    2ac6:	462a      	mov	r2, r5
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    2ac8:	4e1a      	ldr	r6, [pc, #104]	; (2b34 <usb_seremu_configure+0x98>)
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    2aca:	2120      	movs	r1, #32
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    2acc:	4b1a      	ldr	r3, [pc, #104]	; (2b38 <usb_seremu_configure+0x9c>)
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    2ace:	2002      	movs	r0, #2
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    2ad0:	4f1a      	ldr	r7, [pc, #104]	; (2b3c <usb_seremu_configure+0xa0>)
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    2ad2:	701d      	strb	r5, [r3, #0]
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    2ad4:	6035      	str	r5, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    2ad6:	4b1a      	ldr	r3, [pc, #104]	; (2b40 <usb_seremu_configure+0xa4>)
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    2ad8:	6075      	str	r5, [r6, #4]
    2ada:	60b5      	str	r5, [r6, #8]
    2adc:	60f5      	str	r5, [r6, #12]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    2ade:	603d      	str	r5, [r7, #0]
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    2ae0:	f7ff fe28 	bl	2734 <usb_config_rx>
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
    2ae4:	462b      	mov	r3, r5
    2ae6:	462a      	mov	r2, r5
    2ae8:	2140      	movs	r1, #64	; 0x40
    2aea:	2002      	movs	r0, #2
    2aec:	f7ff fe54 	bl	2798 <usb_config_tx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    2af0:	4620      	mov	r0, r4
    2af2:	3401      	adds	r4, #1
    2af4:	f7ff ff74 	bl	29e0 <rx_queue_transfer>
    2af8:	2c08      	cmp	r4, #8
    2afa:	d1f9      	bne.n	2af0 <usb_seremu_configure+0x54>
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
	USB1_GPTIMER0CTRL = 0;
    2afc:	4b11      	ldr	r3, [pc, #68]	; (2b44 <usb_seremu_configure+0xa8>)
	USB1_GPTIMER0LD = microseconds - 1;
    2afe:	224a      	movs	r2, #74	; 0x4a
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    2b00:	4811      	ldr	r0, [pc, #68]	; (2b48 <usb_seremu_configure+0xac>)
	USB1_GPTIMER0CTRL = 0;
    2b02:	2100      	movs	r1, #0
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    2b04:	4c11      	ldr	r4, [pc, #68]	; (2b4c <usb_seremu_configure+0xb0>)
    2b06:	6004      	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    2b08:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    2b0c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    2b10:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    2b14:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    2b18:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    2b1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2b1e:	bf00      	nop
    2b20:	200024e0 	.word	0x200024e0
    2b24:	20002787 	.word	0x20002787
    2b28:	20002781 	.word	0x20002781
    2b2c:	20002778 	.word	0x20002778
    2b30:	20002360 	.word	0x20002360
    2b34:	20002708 	.word	0x20002708
    2b38:	20002783 	.word	0x20002783
    2b3c:	20002704 	.word	0x20002704
    2b40:	00002a45 	.word	0x00002a45
    2b44:	402e0000 	.word	0x402e0000
    2b48:	20002748 	.word	0x20002748
    2b4c:	00002cb9 	.word	0x00002cb9

00002b50 <usb_seremu_getchar>:
	}
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
    2b50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t tail = rx_tail;
    2b52:	4d14      	ldr	r5, [pc, #80]	; (2ba4 <usb_seremu_getchar+0x54>)

	if (tail == rx_head) return -1;
    2b54:	4a14      	ldr	r2, [pc, #80]	; (2ba8 <usb_seremu_getchar+0x58>)
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    2b56:	782b      	ldrb	r3, [r5, #0]

	if (tail == rx_head) return -1;
    2b58:	7812      	ldrb	r2, [r2, #0]
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    2b5a:	b2db      	uxtb	r3, r3

	if (tail == rx_head) return -1;
    2b5c:	4293      	cmp	r3, r2
    2b5e:	d01d      	beq.n	2b9c <usb_seremu_getchar+0x4c>
	if (++tail > RX_NUM) tail = 0;
    2b60:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    2b62:	4a12      	ldr	r2, [pc, #72]	; (2bac <usb_seremu_getchar+0x5c>)
	uint32_t index = rx_index[i];
    2b64:	4e12      	ldr	r6, [pc, #72]	; (2bb0 <usb_seremu_getchar+0x60>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    2b66:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    2b68:	4c12      	ldr	r4, [pc, #72]	; (2bb4 <usb_seremu_getchar+0x64>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    2b6a:	bf28      	it	cs
    2b6c:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    2b6e:	5cd0      	ldrb	r0, [r2, r3]
	uint32_t index = rx_index[i];
    2b70:	f836 2010 	ldrh.w	r2, [r6, r0, lsl #1]
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    2b74:	eb02 1140 	add.w	r1, r2, r0, lsl #5
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    2b78:	3201      	adds	r2, #1
    2b7a:	2a1f      	cmp	r2, #31

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    2b7c:	eb04 0701 	add.w	r7, r4, r1
	int c = *p;
    2b80:	5c64      	ldrb	r4, [r4, r1]
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    2b82:	d805      	bhi.n	2b90 <usb_seremu_getchar+0x40>
    2b84:	7879      	ldrb	r1, [r7, #1]
    2b86:	b119      	cbz	r1, 2b90 <usb_seremu_getchar+0x40>
		rx_tail = tail;
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
    2b88:	f826 2010 	strh.w	r2, [r6, r0, lsl #1]
	}
	return c;
    2b8c:	4620      	mov	r0, r4
    2b8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
    2b90:	b2db      	uxtb	r3, r3
    2b92:	702b      	strb	r3, [r5, #0]
		rx_queue_transfer(i);
    2b94:	f7ff ff24 	bl	29e0 <rx_queue_transfer>
	} else {
		rx_index[i] = index;
	}
	return c;
    2b98:	4620      	mov	r0, r4
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
		rx_queue_transfer(i);
    2b9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
    2b9c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
	}
	return c;
}
    2ba0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2ba2:	bf00      	nop
    2ba4:	20002783 	.word	0x20002783
    2ba8:	20002781 	.word	0x20002781
    2bac:	20002720 	.word	0x20002720
    2bb0:	20002708 	.word	0x20002708
    2bb4:	20200260 	.word	0x20200260

00002bb8 <usb_seremu_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    2bb8:	4b0b      	ldr	r3, [pc, #44]	; (2be8 <usb_seremu_peekchar+0x30>)
	if (tail == rx_head) return -1;
    2bba:	4a0c      	ldr	r2, [pc, #48]	; (2bec <usb_seremu_peekchar+0x34>)
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    2bbc:	781b      	ldrb	r3, [r3, #0]
	if (tail == rx_head) return -1;
    2bbe:	7812      	ldrb	r2, [r2, #0]
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    2bc0:	b2db      	uxtb	r3, r3
	if (tail == rx_head) return -1;
    2bc2:	4293      	cmp	r3, r2
    2bc4:	d00d      	beq.n	2be2 <usb_seremu_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    2bc6:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    2bc8:	4a09      	ldr	r2, [pc, #36]	; (2bf0 <usb_seremu_peekchar+0x38>)
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    2bca:	480a      	ldr	r0, [pc, #40]	; (2bf4 <usb_seremu_peekchar+0x3c>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    2bcc:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    2bce:	490a      	ldr	r1, [pc, #40]	; (2bf8 <usb_seremu_peekchar+0x40>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    2bd0:	bf28      	it	cs
    2bd2:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    2bd4:	5cd2      	ldrb	r2, [r2, r3]
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    2bd6:	f830 3012 	ldrh.w	r3, [r0, r2, lsl #1]
    2bda:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    2bde:	5cc8      	ldrb	r0, [r1, r3]
    2be0:	4770      	bx	lr

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
    2be2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
}
    2be6:	4770      	bx	lr
    2be8:	20002783 	.word	0x20002783
    2bec:	20002781 	.word	0x20002781
    2bf0:	20002720 	.word	0x20002720
    2bf4:	20002708 	.word	0x20002708
    2bf8:	20200260 	.word	0x20200260

00002bfc <usb_seremu_available>:

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
    2bfc:	b508      	push	{r3, lr}
	uint32_t tail = rx_tail;
    2bfe:	4a06      	ldr	r2, [pc, #24]	; (2c18 <usb_seremu_available+0x1c>)
	if (tail == rx_head) {
    2c00:	4b06      	ldr	r3, [pc, #24]	; (2c1c <usb_seremu_available+0x20>)
}

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
    2c02:	7812      	ldrb	r2, [r2, #0]
	if (tail == rx_head) {
    2c04:	781b      	ldrb	r3, [r3, #0]
    2c06:	429a      	cmp	r2, r3
    2c08:	d001      	beq.n	2c0e <usb_seremu_available+0x12>
		yield();
		return 0;
	}
	// TODO: how much is actually available?
	return 1;
    2c0a:	2001      	movs	r0, #1
}
    2c0c:	bd08      	pop	{r3, pc}
// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) {
		yield();
    2c0e:	f000 fabd 	bl	318c <yield>
		return 0;
    2c12:	2000      	movs	r0, #0
    2c14:	bd08      	pop	{r3, pc}
    2c16:	bf00      	nop
    2c18:	20002783 	.word	0x20002783
    2c1c:	20002781 	.word	0x20002781

00002c20 <tx_zero_pad>:
	USB1_GPTIMER0CTRL = 0;
}


void tx_zero_pad(void)
{
    2c20:	b538      	push	{r3, r4, r5, lr}
	if (!tx_available) return;
    2c22:	4c08      	ldr	r4, [pc, #32]	; (2c44 <tx_zero_pad+0x24>)
    2c24:	8822      	ldrh	r2, [r4, #0]
    2c26:	b162      	cbz	r2, 2c42 <tx_zero_pad+0x22>
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    2c28:	4907      	ldr	r1, [pc, #28]	; (2c48 <tx_zero_pad+0x28>)
	memset(txdata, 0, tx_available);
    2c2a:	f1c2 0340 	rsb	r3, r2, #64	; 0x40
    2c2e:	4807      	ldr	r0, [pc, #28]	; (2c4c <tx_zero_pad+0x2c>)


void tx_zero_pad(void)
{
	if (!tx_available) return;
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    2c30:	780d      	ldrb	r5, [r1, #0]
	memset(txdata, 0, tx_available);
    2c32:	2100      	movs	r1, #0
    2c34:	eb03 1385 	add.w	r3, r3, r5, lsl #6
    2c38:	4418      	add	r0, r3
    2c3a:	f004 f93b 	bl	6eb4 <memset>
	tx_available = 0;
    2c3e:	2300      	movs	r3, #0
    2c40:	8023      	strh	r3, [r4, #0]
    2c42:	bd38      	pop	{r3, r4, r5, pc}
    2c44:	20002778 	.word	0x20002778
    2c48:	20002787 	.word	0x20002787
    2c4c:	20200360 	.word	0x20200360

00002c50 <tx_queue_transfer>:
}

void tx_queue_transfer(void)
{
    2c50:	b570      	push	{r4, r5, r6, lr}
	transfer_t *xfer = tx_transfer + tx_head;
    2c52:	4e15      	ldr	r6, [pc, #84]	; (2ca8 <tx_queue_transfer+0x58>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    2c54:	2300      	movs	r3, #0
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    2c56:	4d15      	ldr	r5, [pc, #84]	; (2cac <tx_queue_transfer+0x5c>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    2c58:	2240      	movs	r2, #64	; 0x40
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    2c5a:	7831      	ldrb	r1, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    2c5c:	4c14      	ldr	r4, [pc, #80]	; (2cb0 <tx_queue_transfer+0x60>)
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    2c5e:	eb05 1541 	add.w	r5, r5, r1, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    2c62:	eb04 1481 	add.w	r4, r4, r1, lsl #6
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    2c66:	4628      	mov	r0, r5
    2c68:	4621      	mov	r1, r4
    2c6a:	f7ff fdc9 	bl	2800 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    2c6e:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    2c72:	f104 0140 	add.w	r1, r4, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    2c76:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    2c7a:	4a0e      	ldr	r2, [pc, #56]	; (2cb4 <tx_queue_transfer+0x64>)
    2c7c:	6013      	str	r3, [r2, #0]
		location += 32;
    2c7e:	3320      	adds	r3, #32
	} while (location < end_addr);
    2c80:	4299      	cmp	r1, r3
    2c82:	d8fb      	bhi.n	2c7c <tx_queue_transfer+0x2c>
	asm("dsb");
    2c84:	f3bf 8f4f 	dsb	sy
	asm("isb");
    2c88:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
    2c8c:	2002      	movs	r0, #2
    2c8e:	4629      	mov	r1, r5
    2c90:	f7ff fdce 	bl	2830 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    2c94:	7833      	ldrb	r3, [r6, #0]
    2c96:	4a04      	ldr	r2, [pc, #16]	; (2ca8 <tx_queue_transfer+0x58>)
    2c98:	3301      	adds	r3, #1
    2c9a:	b2db      	uxtb	r3, r3
    2c9c:	2b0b      	cmp	r3, #11
    2c9e:	bf88      	it	hi
    2ca0:	2300      	movhi	r3, #0
    2ca2:	7013      	strb	r3, [r2, #0]
    2ca4:	bd70      	pop	{r4, r5, r6, pc}
    2ca6:	bf00      	nop
    2ca8:	20002787 	.word	0x20002787
    2cac:	200024e0 	.word	0x200024e0
    2cb0:	20200360 	.word	0x20200360
    2cb4:	e000ef70 	.word	0xe000ef70

00002cb8 <usb_seremu_flush_callback>:
	timer_stop();
	tx_noautoflush = 0;
}

static void usb_seremu_flush_callback(void)
{
    2cb8:	b508      	push	{r3, lr}
	if (tx_noautoflush) return;
    2cba:	4b08      	ldr	r3, [pc, #32]	; (2cdc <usb_seremu_flush_callback+0x24>)
    2cbc:	781b      	ldrb	r3, [r3, #0]
    2cbe:	b92b      	cbnz	r3, 2ccc <usb_seremu_flush_callback+0x14>
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
    2cc0:	4b07      	ldr	r3, [pc, #28]	; (2ce0 <usb_seremu_flush_callback+0x28>)
    2cc2:	881b      	ldrh	r3, [r3, #0]
    2cc4:	3b01      	subs	r3, #1
    2cc6:	b29b      	uxth	r3, r3
    2cc8:	2b3e      	cmp	r3, #62	; 0x3e
    2cca:	d900      	bls.n	2cce <usb_seremu_flush_callback+0x16>
    2ccc:	bd08      	pop	{r3, pc}
	tx_zero_pad();
    2cce:	f7ff ffa7 	bl	2c20 <tx_zero_pad>
	tx_queue_transfer();
}
    2cd2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
static void usb_seremu_flush_callback(void)
{
	if (tx_noautoflush) return;
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
	tx_zero_pad();
	tx_queue_transfer();
    2cd6:	f7ff bfbb 	b.w	2c50 <tx_queue_transfer>
    2cda:	bf00      	nop
    2cdc:	20002788 	.word	0x20002788
    2ce0:	20002778 	.word	0x20002778

00002ce4 <usb_seremu_write.part.1>:
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
	if (++tx_head >= TX_NUM) tx_head = 0;
}

int usb_seremu_write(const void *buffer, uint32_t size)
    2ce4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2ce8:	b085      	sub	sp, #20
    2cea:	9002      	str	r0, [sp, #8]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2cec:	9100      	str	r1, [sp, #0]
    2cee:	2900      	cmp	r1, #0
    2cf0:	f000 8084 	beq.w	2dfc <usb_seremu_write.part.1+0x118>
    2cf4:	2300      	movs	r3, #0
    2cf6:	4f42      	ldr	r7, [pc, #264]	; (2e00 <usb_seremu_write.part.1+0x11c>)
    2cf8:	f8df 8120 	ldr.w	r8, [pc, #288]	; 2e1c <usb_seremu_write.part.1+0x138>
    2cfc:	f8df a110 	ldr.w	sl, [pc, #272]	; 2e10 <usb_seremu_write.part.1+0x12c>
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
    2d00:	4e40      	ldr	r6, [pc, #256]	; (2e04 <usb_seremu_write.part.1+0x120>)
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    2d02:	f8df b11c 	ldr.w	fp, [pc, #284]	; 2e20 <usb_seremu_write.part.1+0x13c>
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2d06:	9301      	str	r3, [sp, #4]
		tx_noautoflush = 1;
    2d08:	2101      	movs	r1, #1
		transfer_t *xfer = tx_transfer + tx_head;
    2d0a:	4b3f      	ldr	r3, [pc, #252]	; (2e08 <usb_seremu_write.part.1+0x124>)
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
    2d0c:	7039      	strb	r1, [r7, #0]
		transfer_t *xfer = tx_transfer + tx_head;
    2d0e:	781a      	ldrb	r2, [r3, #0]
    2d10:	493e      	ldr	r1, [pc, #248]	; (2e0c <usb_seremu_write.part.1+0x128>)
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    2d12:	f8b8 3000 	ldrh.w	r3, [r8]
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
    2d16:	eb01 1942 	add.w	r9, r1, r2, lsl #5
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    2d1a:	bb0b      	cbnz	r3, 2d60 <usb_seremu_write.part.1+0x7c>
    2d1c:	461d      	mov	r5, r3
    2d1e:	461c      	mov	r4, r3
			uint32_t status = usb_transfer_status(xfer);
    2d20:	4648      	mov	r0, r9
    2d22:	f7ff fdab 	bl	287c <usb_transfer_status>
			if (!(status & 0x80)) {
    2d26:	f010 0080 	ands.w	r0, r0, #128	; 0x80
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    2d2a:	f04f 0300 	mov.w	r3, #0
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2d2e:	4938      	ldr	r1, [pc, #224]	; (2e10 <usb_seremu_write.part.1+0x12c>)
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
			uint32_t status = usb_transfer_status(xfer);
			if (!(status & 0x80)) {
    2d30:	d056      	beq.n	2de0 <usb_seremu_write.part.1+0xfc>
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2d32:	f89a 2000 	ldrb.w	r2, [sl]
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    2d36:	703b      	strb	r3, [r7, #0]
			if (!waiting) {
    2d38:	b904      	cbnz	r4, 2d3c <usb_seremu_write.part.1+0x58>
				wait_begin_at = systick_millis_count;
    2d3a:	6835      	ldr	r5, [r6, #0]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2d3c:	2a00      	cmp	r2, #0
    2d3e:	d134      	bne.n	2daa <usb_seremu_write.part.1+0xc6>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    2d40:	6833      	ldr	r3, [r6, #0]
    2d42:	2401      	movs	r4, #1
    2d44:	1b5b      	subs	r3, r3, r5
    2d46:	2b32      	cmp	r3, #50	; 0x32
    2d48:	d853      	bhi.n	2df2 <usb_seremu_write.part.1+0x10e>
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    2d4a:	f89b 3000 	ldrb.w	r3, [fp]
    2d4e:	b363      	cbz	r3, 2daa <usb_seremu_write.part.1+0xc6>
			yield();
    2d50:	f000 fa1c 	bl	318c <yield>
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    2d54:	f8b8 3000 	ldrh.w	r3, [r8]
    2d58:	2b00      	cmp	r3, #0
    2d5a:	d0e1      	beq.n	2d20 <usb_seremu_write.part.1+0x3c>
    2d5c:	4a2a      	ldr	r2, [pc, #168]	; (2e08 <usb_seremu_write.part.1+0x124>)
    2d5e:	7812      	ldrb	r2, [r2, #0]
    2d60:	461c      	mov	r4, r3
    2d62:	f1c3 0040 	rsb	r0, r3, #64	; 0x40
				return sent;
			}
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    2d66:	eb00 1082 	add.w	r0, r0, r2, lsl #6
    2d6a:	4a2a      	ldr	r2, [pc, #168]	; (2e14 <usb_seremu_write.part.1+0x130>)
    2d6c:	4410      	add	r0, r2
		if (size >= tx_available) {
    2d6e:	9a00      	ldr	r2, [sp, #0]
    2d70:	42a2      	cmp	r2, r4
    2d72:	d31e      	bcc.n	2db2 <usb_seremu_write.part.1+0xce>
			memcpy(txdata, data, tx_available);
			size -= tx_available;
    2d74:	9b00      	ldr	r3, [sp, #0]
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    2d76:	2500      	movs	r5, #0
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    2d78:	f8dd 9008 	ldr.w	r9, [sp, #8]
    2d7c:	4622      	mov	r2, r4
			size -= tx_available;
    2d7e:	1b1b      	subs	r3, r3, r4
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    2d80:	4649      	mov	r1, r9
			size -= tx_available;
    2d82:	9300      	str	r3, [sp, #0]
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    2d84:	f003 ff98 	bl	6cb8 <memcpy>
			size -= tx_available;
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    2d88:	f8a8 5000 	strh.w	r5, [r8]
			tx_queue_transfer();
    2d8c:	f7ff ff60 	bl	2c50 <tx_queue_transfer>
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    2d90:	9a01      	ldr	r2, [sp, #4]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    2d92:	4b21      	ldr	r3, [pc, #132]	; (2e18 <usb_seremu_write.part.1+0x134>)
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    2d94:	4422      	add	r2, r4
    2d96:	9201      	str	r2, [sp, #4]
			data += tx_available;
    2d98:	464a      	mov	r2, r9
    2d9a:	4422      	add	r2, r4
    2d9c:	9202      	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    2d9e:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2da2:	9b00      	ldr	r3, [sp, #0]
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    2da4:	703d      	strb	r5, [r7, #0]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2da6:	2b00      	cmp	r3, #0
    2da8:	d1ae      	bne.n	2d08 <usb_seremu_write.part.1+0x24>
    2daa:	9801      	ldr	r0, [sp, #4]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    2dac:	b005      	add	sp, #20
    2dae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    2db2:	9d00      	ldr	r5, [sp, #0]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2db4:	f04f 4440 	mov.w	r4, #3221225472	; 0xc0000000
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    2db8:	9902      	ldr	r1, [sp, #8]
    2dba:	462a      	mov	r2, r5
    2dbc:	9303      	str	r3, [sp, #12]
    2dbe:	f003 ff7b 	bl	6cb8 <memcpy>
			tx_available -= size;
    2dc2:	9b03      	ldr	r3, [sp, #12]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2dc4:	4914      	ldr	r1, [pc, #80]	; (2e18 <usb_seremu_write.part.1+0x134>)
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    2dc6:	2200      	movs	r2, #0
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
			tx_available -= size;
    2dc8:	1b5b      	subs	r3, r3, r5
    2dca:	f8a8 3000 	strh.w	r3, [r8]
    2dce:	9b01      	ldr	r3, [sp, #4]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2dd0:	f8c1 4084 	str.w	r4, [r1, #132]	; 0x84
    2dd4:	4618      	mov	r0, r3
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    2dd6:	703a      	strb	r2, [r7, #0]
    2dd8:	4428      	add	r0, r5
	}
	return sent;
}
    2dda:	b005      	add	sp, #20
    2ddc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    2de0:	2340      	movs	r3, #64	; 0x40
    2de2:	4a09      	ldr	r2, [pc, #36]	; (2e08 <usb_seremu_write.part.1+0x124>)
				transmit_previous_timeout = 0;
    2de4:	f88a 0000 	strb.w	r0, [sl]
    2de8:	7812      	ldrb	r2, [r2, #0]
    2dea:	461c      	mov	r4, r3
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    2dec:	f8a8 3000 	strh.w	r3, [r8]
    2df0:	e7b9      	b.n	2d66 <usb_seremu_write.part.1+0x82>
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
    2df2:	9801      	ldr	r0, [sp, #4]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    2df4:	700c      	strb	r4, [r1, #0]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    2df6:	b005      	add	sp, #20
    2df8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2dfc:	9800      	ldr	r0, [sp, #0]
    2dfe:	e7d5      	b.n	2dac <usb_seremu_write.part.1+0xc8>
    2e00:	20002788 	.word	0x20002788
    2e04:	20002744 	.word	0x20002744
    2e08:	20002787 	.word	0x20002787
    2e0c:	200024e0 	.word	0x200024e0
    2e10:	20002785 	.word	0x20002785
    2e14:	20200360 	.word	0x20200360
    2e18:	402e0000 	.word	0x402e0000
    2e1c:	20002778 	.word	0x20002778
    2e20:	20002789 	.word	0x20002789

00002e24 <usb_seremu_putchar>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2e24:	4b09      	ldr	r3, [pc, #36]	; (2e4c <usb_seremu_putchar+0x28>)
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    2e26:	b500      	push	{lr}
    2e28:	b083      	sub	sp, #12
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2e2a:	781b      	ldrb	r3, [r3, #0]
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    2e2c:	f88d 0007 	strb.w	r0, [sp, #7]
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2e30:	b923      	cbnz	r3, 2e3c <usb_seremu_putchar+0x18>
    2e32:	f003 00ff 	and.w	r0, r3, #255	; 0xff

// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
	return usb_seremu_write(&c, 1);
}
    2e36:	b003      	add	sp, #12
    2e38:	f85d fb04 	ldr.w	pc, [sp], #4
    2e3c:	2101      	movs	r1, #1
    2e3e:	f10d 0007 	add.w	r0, sp, #7
    2e42:	f7ff ff4f 	bl	2ce4 <usb_seremu_write.part.1>
    2e46:	b003      	add	sp, #12
    2e48:	f85d fb04 	ldr.w	pc, [sp], #4
    2e4c:	20002789 	.word	0x20002789

00002e50 <usb_seremu_write>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2e50:	4b04      	ldr	r3, [pc, #16]	; (2e64 <usb_seremu_write+0x14>)
    2e52:	781b      	ldrb	r3, [r3, #0]
    2e54:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    2e58:	b10b      	cbz	r3, 2e5e <usb_seremu_write+0xe>
    2e5a:	f7ff bf43 	b.w	2ce4 <usb_seremu_write.part.1>
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    2e5e:	4610      	mov	r0, r2
    2e60:	4770      	bx	lr
    2e62:	bf00      	nop
    2e64:	20002789 	.word	0x20002789

00002e68 <usb_seremu_write_buffer_free>:

int usb_seremu_write_buffer_free(void)
{
	return 1;
}
    2e68:	2001      	movs	r0, #1
    2e6a:	4770      	bx	lr

00002e6c <usb_seremu_flush_output>:

void usb_seremu_flush_output(void)
{
	if (!usb_configuration) return;
    2e6c:	4b0a      	ldr	r3, [pc, #40]	; (2e98 <usb_seremu_flush_output+0x2c>)
    2e6e:	781b      	ldrb	r3, [r3, #0]
    2e70:	b113      	cbz	r3, 2e78 <usb_seremu_flush_output+0xc>
	if (tx_available == 0) return;
    2e72:	4b0a      	ldr	r3, [pc, #40]	; (2e9c <usb_seremu_flush_output+0x30>)
    2e74:	881b      	ldrh	r3, [r3, #0]
    2e76:	b903      	cbnz	r3, 2e7a <usb_seremu_flush_output+0xe>
    2e78:	4770      	bx	lr
{
	return 1;
}

void usb_seremu_flush_output(void)
{
    2e7a:	b510      	push	{r4, lr}
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    2e7c:	2301      	movs	r3, #1
    2e7e:	4c08      	ldr	r4, [pc, #32]	; (2ea0 <usb_seremu_flush_output+0x34>)
    2e80:	7023      	strb	r3, [r4, #0]
	tx_zero_pad();
    2e82:	f7ff fecd 	bl	2c20 <tx_zero_pad>
	tx_queue_transfer();
    2e86:	f7ff fee3 	bl	2c50 <tx_queue_transfer>
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    2e8a:	2300      	movs	r3, #0
    2e8c:	4a05      	ldr	r2, [pc, #20]	; (2ea4 <usb_seremu_flush_output+0x38>)
    2e8e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	tx_zero_pad();
	tx_queue_transfer();
	timer_stop();
	tx_noautoflush = 0;
    2e92:	7023      	strb	r3, [r4, #0]
    2e94:	bd10      	pop	{r4, pc}
    2e96:	bf00      	nop
    2e98:	20002789 	.word	0x20002789
    2e9c:	20002778 	.word	0x20002778
    2ea0:	20002788 	.word	0x20002788
    2ea4:	402e0000 	.word	0x402e0000

00002ea8 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    2ea8:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2eaa:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    2eae:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2eb0:	4c0c      	ldr	r4, [pc, #48]	; (2ee4 <EventResponder::runFromInterrupt()+0x3c>)
    2eb2:	6823      	ldr	r3, [r4, #0]
		if (first) {
    2eb4:	b18b      	cbz	r3, 2eda <EventResponder::runFromInterrupt()+0x32>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    2eb6:	4e0c      	ldr	r6, [pc, #48]	; (2ee8 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    2eb8:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    2eba:	695a      	ldr	r2, [r3, #20]
    2ebc:	6022      	str	r2, [r4, #0]
			if (firstInterrupt) {
    2ebe:	b17a      	cbz	r2, 2ee0 <EventResponder::runFromInterrupt()+0x38>
				firstInterrupt->_prev = nullptr;
    2ec0:	6195      	str	r5, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2ec2:	b901      	cbnz	r1, 2ec6 <EventResponder::runFromInterrupt()+0x1e>
    2ec4:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    2ec6:	775d      	strb	r5, [r3, #29]
			(*(first->_function))(*first);
    2ec8:	4618      	mov	r0, r3
    2eca:	689b      	ldr	r3, [r3, #8]
    2ecc:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2ece:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    2ed2:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2ed4:	6823      	ldr	r3, [r4, #0]
		if (first) {
    2ed6:	2b00      	cmp	r3, #0
    2ed8:	d1ef      	bne.n	2eba <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2eda:	b901      	cbnz	r1, 2ede <EventResponder::runFromInterrupt()+0x36>
    2edc:	b662      	cpsie	i
    2ede:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    2ee0:	6032      	str	r2, [r6, #0]
    2ee2:	e7ee      	b.n	2ec2 <EventResponder::runFromInterrupt()+0x1a>
    2ee4:	2000268c 	.word	0x2000268c
    2ee8:	20002688 	.word	0x20002688

00002eec <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    2eec:	f7ff bfdc 	b.w	2ea8 <EventResponder::runFromInterrupt()>

00002ef0 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    2ef0:	4a04      	ldr	r2, [pc, #16]	; (2f04 <systick_isr+0x14>)
    2ef2:	4b05      	ldr	r3, [pc, #20]	; (2f08 <systick_isr+0x18>)
    2ef4:	6811      	ldr	r1, [r2, #0]
	systick_millis_count++;
    2ef6:	4a05      	ldr	r2, [pc, #20]	; (2f0c <systick_isr+0x1c>)
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    2ef8:	6019      	str	r1, [r3, #0]
	systick_millis_count++;
    2efa:	6813      	ldr	r3, [r2, #0]
    2efc:	3301      	adds	r3, #1
    2efe:	6013      	str	r3, [r2, #0]
    2f00:	4770      	bx	lr
    2f02:	bf00      	nop
    2f04:	e0001004 	.word	0xe0001004
    2f08:	20002740 	.word	0x20002740
    2f0c:	20002744 	.word	0x20002744

00002f10 <IntervalTimer::end()>:
}


void IntervalTimer::end() {
#if 1
	if (channel) {
    2f10:	6802      	ldr	r2, [r0, #0]
    2f12:	b30a      	cbz	r2, 2f58 <IntervalTimer::end()+0x48>
		int index = channel - IMXRT_PIT_CHANNELS;
    2f14:	4b11      	ldr	r3, [pc, #68]	; (2f5c <IntervalTimer::end()+0x4c>)
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2f16:	4912      	ldr	r1, [pc, #72]	; (2f60 <IntervalTimer::end()+0x50>)


void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    2f18:	4413      	add	r3, r2
	NVIC_ENABLE_IRQ(IRQ_PIT);
	return true;
}


void IntervalTimer::end() {
    2f1a:	b5f0      	push	{r4, r5, r6, r7, lr}
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    2f1c:	111b      	asrs	r3, r3, #4
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2f1e:	25ff      	movs	r5, #255	; 0xff
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    2f20:	2400      	movs	r4, #0
    2f22:	f8df e044 	ldr.w	lr, [pc, #68]	; 2f68 <IntervalTimer::end()+0x58>
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2f26:	54cd      	strb	r5, [r1, r3]
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    2f28:	780e      	ldrb	r6, [r1, #0]
    2f2a:	784d      	ldrb	r5, [r1, #1]
    2f2c:	2eff      	cmp	r6, #255	; 0xff
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
    2f2e:	6094      	str	r4, [r2, #8]
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    2f30:	f84e 4023 	str.w	r4, [lr, r3, lsl #2]
    2f34:	bf28      	it	cs
    2f36:	26ff      	movcs	r6, #255	; 0xff
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    2f38:	788a      	ldrb	r2, [r1, #2]
    2f3a:	78c9      	ldrb	r1, [r1, #3]
    2f3c:	42ae      	cmp	r6, r5
    2f3e:	4633      	mov	r3, r6
		}
		NVIC_SET_PRIORITY(IRQ_PIT, top_priority);
    2f40:	4f08      	ldr	r7, [pc, #32]	; (2f64 <IntervalTimer::end()+0x54>)
    2f42:	bf28      	it	cs
    2f44:	462b      	movcs	r3, r5
    2f46:	4293      	cmp	r3, r2
    2f48:	bf28      	it	cs
    2f4a:	4613      	movcs	r3, r2
    2f4c:	428b      	cmp	r3, r1
    2f4e:	bf28      	it	cs
    2f50:	460b      	movcs	r3, r1
    2f52:	703b      	strb	r3, [r7, #0]
		channel = 0;
    2f54:	6004      	str	r4, [r0, #0]
    2f56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2f58:	4770      	bx	lr
    2f5a:	bf00      	nop
    2f5c:	bff7bf00 	.word	0xbff7bf00
    2f60:	2000184c 	.word	0x2000184c
    2f64:	e000e47a 	.word	0xe000e47a
    2f68:	200022c0 	.word	0x200022c0

00002f6c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
    2f6c:	2000      	movs	r0, #0
    2f6e:	4770      	bx	lr

00002f70 <Print::print(String const&)>:
	return count;
}


size_t Print::print(const String &s)
{
    2f70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2f74:	688c      	ldr	r4, [r1, #8]
    2f76:	b08b      	sub	sp, #44	; 0x2c
	uint8_t buffer[33];
	size_t count = 0;
	unsigned int index = 0;
	unsigned int len = s.length();
	while (len > 0) {
    2f78:	b1ec      	cbz	r4, 2fb6 <Print::print(String const&)+0x46>
    2f7a:	2500      	movs	r5, #0
    2f7c:	4606      	mov	r6, r0
    2f7e:	4689      	mov	r9, r1
    2f80:	462f      	mov	r7, r5
		s.getBytes(buffer, sizeof(buffer), index);
    2f82:	462b      	mov	r3, r5
    2f84:	2221      	movs	r2, #33	; 0x21
    2f86:	a901      	add	r1, sp, #4
    2f88:	4648      	mov	r0, r9
    2f8a:	f000 f8cb 	bl	3124 <String::getBytes(unsigned char*, unsigned int, unsigned int) const>
    2f8e:	2c20      	cmp	r4, #32
    2f90:	4623      	mov	r3, r4
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
		len -= nbytes;
		count += write(buffer, nbytes);
    2f92:	6830      	ldr	r0, [r6, #0]
    2f94:	bf28      	it	cs
    2f96:	2320      	movcs	r3, #32
    2f98:	a901      	add	r1, sp, #4
    2f9a:	f8d0 8004 	ldr.w	r8, [r0, #4]
    2f9e:	4630      	mov	r0, r6
	while (len > 0) {
		s.getBytes(buffer, sizeof(buffer), index);
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
		len -= nbytes;
    2fa0:	1ae4      	subs	r4, r4, r3
		count += write(buffer, nbytes);
    2fa2:	461a      	mov	r2, r3
	unsigned int len = s.length();
	while (len > 0) {
		s.getBytes(buffer, sizeof(buffer), index);
		unsigned int nbytes = len;
		if (nbytes > sizeof(buffer)-1) nbytes = sizeof(buffer)-1;
		index += nbytes;
    2fa4:	441d      	add	r5, r3
		len -= nbytes;
		count += write(buffer, nbytes);
    2fa6:	47c0      	blx	r8
    2fa8:	4407      	add	r7, r0
{
	uint8_t buffer[33];
	size_t count = 0;
	unsigned int index = 0;
	unsigned int len = s.length();
	while (len > 0) {
    2faa:	2c00      	cmp	r4, #0
    2fac:	d1e9      	bne.n	2f82 <Print::print(String const&)+0x12>
		index += nbytes;
		len -= nbytes;
		count += write(buffer, nbytes);
	}
	return count;
}
    2fae:	4638      	mov	r0, r7
    2fb0:	b00b      	add	sp, #44	; 0x2c
    2fb2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}


size_t Print::print(const String &s)
{
	uint8_t buffer[33];
	size_t count = 0;
    2fb6:	4627      	mov	r7, r4
    2fb8:	e7f9      	b.n	2fae <Print::print(String const&)+0x3e>
    2fba:	bf00      	nop

00002fbc <Print::println()>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    2fbc:	b510      	push	{r4, lr}
	uint8_t buf[2]={'\r', '\n'};
    2fbe:	4c06      	ldr	r4, [pc, #24]	; (2fd8 <Print::println()+0x1c>)
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    2fc0:	b082      	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    2fc2:	6803      	ldr	r3, [r0, #0]
    2fc4:	2202      	movs	r2, #2
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    2fc6:	8824      	ldrh	r4, [r4, #0]
	return write(buf, 2);
    2fc8:	a901      	add	r1, sp, #4
    2fca:	685b      	ldr	r3, [r3, #4]
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    2fcc:	f8ad 4004 	strh.w	r4, [sp, #4]
	return write(buf, 2);
    2fd0:	4798      	blx	r3
}
    2fd2:	b002      	add	sp, #8
    2fd4:	bd10      	pop	{r4, pc}
    2fd6:	bf00      	nop
    2fd8:	200003f8 	.word	0x200003f8

00002fdc <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
	((class Print *)file)->write((uint8_t *)ptr, len);
    2fdc:	6803      	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    2fde:	b510      	push	{r4, lr}
    2fe0:	4614      	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    2fe2:	685b      	ldr	r3, [r3, #4]
    2fe4:	4798      	blx	r3
	return len;
}
    2fe6:	4620      	mov	r0, r4
    2fe8:	bd10      	pop	{r4, pc}
    2fea:	bf00      	nop

00002fec <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    2fec:	b40e      	push	{r1, r2, r3}
    2fee:	b500      	push	{lr}
    2ff0:	b082      	sub	sp, #8
    2ff2:	ab03      	add	r3, sp, #12
    2ff4:	f853 1b04 	ldr.w	r1, [r3], #4
	va_start(ap, format);
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    2ff8:	461a      	mov	r2, r3
}

int Print::printf(const char *format, ...)
{
	va_list ap;
	va_start(ap, format);
    2ffa:	9301      	str	r3, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    2ffc:	f004 fc68 	bl	78d0 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    3000:	b002      	add	sp, #8
    3002:	f85d eb04 	ldr.w	lr, [sp], #4
    3006:	b003      	add	sp, #12
    3008:	4770      	bx	lr
    300a:	bf00      	nop

0000300c <IntervalTimer::~IntervalTimer()>:
private:
	static const uint32_t MAX_PERIOD = UINT32_MAX / (24000000 / 1000000);
public:
	constexpr IntervalTimer() {
	}
	~IntervalTimer() {
    300c:	b510      	push	{r4, lr}
    300e:	4604      	mov	r4, r0
		end();
    3010:	f7ff ff7e 	bl	2f10 <IntervalTimer::end()>
	}
    3014:	4620      	mov	r0, r4
    3016:	bd10      	pop	{r4, pc}

00003018 <_GLOBAL__sub_I__Z4tonehtm>:
static uint32_t tone_toggle_count;
static volatile uint32_t *tone_reg;
static uint32_t tone_mask;
static float tone_usec=0.0;
static uint32_t tone_new_count=0;
static IntervalTimer tone_timer;
    3018:	4a02      	ldr	r2, [pc, #8]	; (3024 <_GLOBAL__sub_I__Z4tonehtm+0xc>)
    301a:	4903      	ldr	r1, [pc, #12]	; (3028 <_GLOBAL__sub_I__Z4tonehtm+0x10>)
    301c:	4803      	ldr	r0, [pc, #12]	; (302c <_GLOBAL__sub_I__Z4tonehtm+0x14>)
    301e:	f003 b997 	b.w	6350 <__aeabi_atexit>
    3022:	bf00      	nop
    3024:	20001468 	.word	0x20001468
    3028:	0000300d 	.word	0x0000300d
    302c:	20001844 	.word	0x20001844

00003030 <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    3030:	b510      	push	{r4, lr}
    3032:	4604      	mov	r4, r0
{
	free(buffer);
    3034:	6800      	ldr	r0, [r0, #0]
    3036:	f003 fb69 	bl	670c <free>
}
    303a:	4620      	mov	r0, r4
    303c:	bd10      	pop	{r4, pc}
    303e:	bf00      	nop

00003040 <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    3040:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    3042:	6843      	ldr	r3, [r0, #4]
    3044:	428b      	cmp	r3, r1
    3046:	d301      	bcc.n	304c <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    3048:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    304a:	bd38      	pop	{r3, r4, r5, pc}
    304c:	460d      	mov	r5, r1
    304e:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    3050:	3101      	adds	r1, #1
    3052:	6800      	ldr	r0, [r0, #0]
    3054:	f003 ff80 	bl	6f58 <realloc>
	if (newbuffer) {
    3058:	2800      	cmp	r0, #0
    305a:	d0f6      	beq.n	304a <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    305c:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    305e:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    3062:	2b00      	cmp	r3, #0
    3064:	d1f0      	bne.n	3048 <String::reserve(unsigned int)+0x8>
    3066:	7003      	strb	r3, [r0, #0]
    3068:	e7ee      	b.n	3048 <String::reserve(unsigned int)+0x8>
    306a:	bf00      	nop

0000306c <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    306c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    306e:	4604      	mov	r4, r0
	if (length == 0) {
    3070:	4615      	mov	r5, r2
    3072:	b932      	cbnz	r2, 3082 <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    3074:	6803      	ldr	r3, [r0, #0]
    3076:	b103      	cbz	r3, 307a <String::copy(char const*, unsigned int)+0xe>
    3078:	701a      	strb	r2, [r3, #0]
		len = 0;
    307a:	2300      	movs	r3, #0
    307c:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    307e:	4620      	mov	r0, r4
    3080:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3082:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    3084:	4611      	mov	r1, r2
    3086:	f7ff ffdb 	bl	3040 <String::reserve(unsigned int)>
    308a:	4607      	mov	r7, r0
    308c:	b948      	cbnz	r0, 30a2 <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    308e:	6820      	ldr	r0, [r4, #0]
    3090:	b110      	cbz	r0, 3098 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    3092:	f003 fb3b 	bl	670c <free>
			buffer = NULL;
    3096:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    3098:	2300      	movs	r3, #0
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    309a:	4620      	mov	r0, r4
	if (!reserve(length)) {
		if (buffer) {
			free(buffer);
			buffer = NULL;
		}
		len = capacity = 0;
    309c:	6063      	str	r3, [r4, #4]
    309e:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    30a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    30a2:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    30a4:	4631      	mov	r1, r6
    30a6:	6820      	ldr	r0, [r4, #0]
    30a8:	f004 fad8 	bl	765c <strcpy>
	return *this;
    30ac:	e7e7      	b.n	307e <String::copy(char const*, unsigned int)+0x12>
    30ae:	bf00      	nop

000030b0 <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    30b0:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    30b2:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    30b4:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    30b6:	6003      	str	r3, [r0, #0]
	capacity = 0;
    30b8:	6043      	str	r3, [r0, #4]
	len = 0;
    30ba:	6083      	str	r3, [r0, #8]
	flags = 0;
    30bc:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    30be:	b141      	cbz	r1, 30d2 <String::String(char const*)+0x22>
    30c0:	460d      	mov	r5, r1
    30c2:	4608      	mov	r0, r1
    30c4:	f004 fb3c 	bl	7740 <strlen>
    30c8:	4602      	mov	r2, r0
    30ca:	4629      	mov	r1, r5
    30cc:	4620      	mov	r0, r4
    30ce:	f7ff ffcd 	bl	306c <String::copy(char const*, unsigned int)>
}
    30d2:	4620      	mov	r0, r4
    30d4:	bd38      	pop	{r3, r4, r5, pc}
    30d6:	bf00      	nop

000030d8 <String::String(String const&)>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    30d8:	2300      	movs	r3, #0
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    30da:	4288      	cmp	r0, r1
{
	init();
	*this = pgmstr;
}

String::String(const String &value)
    30dc:	b510      	push	{r4, lr}
    30de:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    30e0:	6003      	str	r3, [r0, #0]
	capacity = 0;
    30e2:	6043      	str	r3, [r0, #4]
	len = 0;
    30e4:	6083      	str	r3, [r0, #8]
	flags = 0;
    30e6:	7303      	strb	r3, [r0, #12]
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    30e8:	d003      	beq.n	30f2 <String::String(String const&)+0x1a>
	return copy(rhs.buffer, rhs.len);
    30ea:	688a      	ldr	r2, [r1, #8]
    30ec:	6809      	ldr	r1, [r1, #0]
    30ee:	f7ff ffbd 	bl	306c <String::copy(char const*, unsigned int)>

String::String(const String &value)
{
	init();
	*this = value;
}
    30f2:	4620      	mov	r0, r4
    30f4:	bd10      	pop	{r4, pc}
    30f6:	bf00      	nop

000030f8 <String::equals(char const*) const>:
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    30f8:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    30fa:	b508      	push	{r3, lr}
    30fc:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    30fe:	b92a      	cbnz	r2, 310c <String::equals(char const*) const+0x14>
    3100:	b171      	cbz	r1, 3120 <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    3102:	7818      	ldrb	r0, [r3, #0]
    3104:	fab0 f080 	clz	r0, r0
    3108:	0940      	lsrs	r0, r0, #5
    310a:	bd08      	pop	{r3, pc}
    310c:	b131      	cbz	r1, 311c <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    310e:	6800      	ldr	r0, [r0, #0]
    3110:	f004 f93a 	bl	7388 <strcmp>
    3114:	fab0 f080 	clz	r0, r0
    3118:	0940      	lsrs	r0, r0, #5
}
    311a:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    311c:	6803      	ldr	r3, [r0, #0]
    311e:	e7f0      	b.n	3102 <String::equals(char const*) const+0xa>
    3120:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    3122:	bd08      	pop	{r3, pc}

00003124 <String::getBytes(unsigned char*, unsigned int, unsigned int) const>:
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
    3124:	b1ba      	cbz	r2, 3156 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x32>
	if (index >= len || !buffer) return 0;
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
    3126:	b570      	push	{r4, r5, r6, lr}
	if (!bufsize || !buf) return;
    3128:	fab1 f481 	clz	r4, r1
    312c:	0964      	lsrs	r4, r4, #5
    312e:	b97c      	cbnz	r4, 3150 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x2c>
	if (index >= len) {
    3130:	6886      	ldr	r6, [r0, #8]
    3132:	429e      	cmp	r6, r3
    3134:	d90d      	bls.n	3152 <String::getBytes(unsigned char*, unsigned int, unsigned int) const+0x2e>
		buf[0] = 0;
		return;
	}
	unsigned int n = bufsize - 1;
	if (n > len - index) n = len - index;
    3136:	1af6      	subs	r6, r6, r3
	if (!bufsize || !buf) return;
	if (index >= len) {
		buf[0] = 0;
		return;
	}
	unsigned int n = bufsize - 1;
    3138:	3a01      	subs	r2, #1
    313a:	460d      	mov	r5, r1
	if (n > len - index) n = len - index;
	strncpy((char *)buf, buffer + index, n);
    313c:	6801      	ldr	r1, [r0, #0]
    313e:	4296      	cmp	r6, r2
    3140:	4628      	mov	r0, r5
    3142:	4419      	add	r1, r3
    3144:	bf28      	it	cs
    3146:	4616      	movcs	r6, r2
    3148:	4632      	mov	r2, r6
    314a:	f004 fb67 	bl	781c <strncpy>
	buf[n] = 0;
    314e:	55ac      	strb	r4, [r5, r6]
    3150:	bd70      	pop	{r4, r5, r6, pc}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
	if (index >= len) {
		buf[0] = 0;
    3152:	700c      	strb	r4, [r1, #0]
		return;
    3154:	bd70      	pop	{r4, r5, r6, pc}
    3156:	4770      	bx	lr

00003158 <operator new(unsigned int)>:
    3158:	f003 bad0 	b.w	66fc <malloc>

0000315c <operator new[](unsigned int)>:
	return malloc(size);
}

void * operator new[](size_t size)
{
	return malloc(size);
    315c:	f003 bace 	b.w	66fc <malloc>

00003160 <operator delete(void*, unsigned int)>:
    3160:	f003 bad4 	b.w	670c <free>

00003164 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    3164:	4770      	bx	lr
    3166:	bf00      	nop

00003168 <usb_seremu_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
    3168:	f7ff bd26 	b.w	2bb8 <usb_seremu_peekchar>

0000316c <usb_seremu_class::read()>:
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
    316c:	f7ff bcf0 	b.w	2b50 <usb_seremu_getchar>

00003170 <usb_seremu_class::available()>:
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    3170:	f7ff bd44 	b.w	2bfc <usb_seremu_available>

00003174 <usb_seremu_class::flush()>:
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
    3174:	f7ff be7a 	b.w	2e6c <usb_seremu_flush_output>

00003178 <usb_seremu_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
        size_t write(unsigned long n) { return write((uint8_t)n); }
        size_t write(long n) { return write((uint8_t)n); }
        size_t write(unsigned int n) { return write((uint8_t)n); }
        size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_seremu_write_buffer_free(); }
    3178:	f7ff be76 	b.w	2e68 <usb_seremu_write_buffer_free>

0000317c <usb_seremu_class::write(unsigned char const*, unsigned int)>:
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
    317c:	4608      	mov	r0, r1
    317e:	4611      	mov	r1, r2
    3180:	f7ff be66 	b.w	2e50 <usb_seremu_write>

00003184 <usb_seremu_class::write(unsigned char)>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
    3184:	4608      	mov	r0, r1
    3186:	f7ff be4d 	b.w	2e24 <usb_seremu_putchar>
    318a:	bf00      	nop

0000318c <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    318c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    3190:	4e32      	ldr	r6, [pc, #200]	; (325c <yield+0xd0>)
    3192:	7833      	ldrb	r3, [r6, #0]
    3194:	b193      	cbz	r3, 31bc <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    3196:	4f32      	ldr	r7, [pc, #200]	; (3260 <yield+0xd4>)
    3198:	783a      	ldrb	r2, [r7, #0]
    319a:	b97a      	cbnz	r2, 31bc <yield+0x30>
	running = 1;
    319c:	2201      	movs	r2, #1


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    319e:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    31a0:	703a      	strb	r2, [r7, #0]


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    31a2:	d437      	bmi.n	3214 <yield+0x88>
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
    31a4:	079a      	lsls	r2, r3, #30
    31a6:	d419      	bmi.n	31dc <yield+0x50>

	running = 0;
    31a8:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    31aa:	075b      	lsls	r3, r3, #29
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();

	running = 0;
    31ac:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    31ae:	d505      	bpl.n	31bc <yield+0x30>
	// Wait for event(s) to occur.  These are most likely to be useful when
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);
	static void runFromYield() {
		if (!firstYield) return;  
    31b0:	4b2c      	ldr	r3, [pc, #176]	; (3264 <yield+0xd8>)
    31b2:	681a      	ldr	r2, [r3, #0]
    31b4:	b112      	cbz	r2, 31bc <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    31b6:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    31ba:	b10a      	cbz	r2, 31c0 <yield+0x34>
    31bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    31c0:	f3ef 8010 	mrs	r0, PRIMASK
		__disable_irq();
    31c4:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    31c6:	681a      	ldr	r2, [r3, #0]
		if (first == nullptr) {
    31c8:	b11a      	cbz	r2, 31d2 <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    31ca:	4c27      	ldr	r4, [pc, #156]	; (3268 <yield+0xdc>)
    31cc:	7821      	ldrb	r1, [r4, #0]
    31ce:	2900      	cmp	r1, #0
    31d0:	d02f      	beq.n	3232 <yield+0xa6>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    31d2:	2800      	cmp	r0, #0
    31d4:	d1f2      	bne.n	31bc <yield+0x30>
    31d6:	b662      	cpsie	i
    31d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    31dc:	f8df 8094 	ldr.w	r8, [pc, #148]	; 3274 <yield+0xe8>
    31e0:	f898 2000 	ldrb.w	r2, [r8]
    31e4:	2a00      	cmp	r2, #0
    31e6:	d0df      	beq.n	31a8 <yield+0x1c>
    31e8:	2400      	movs	r4, #0
    31ea:	f8df 908c 	ldr.w	r9, [pc, #140]	; 3278 <yield+0xec>
    31ee:	e005      	b.n	31fc <yield+0x70>
    31f0:	3401      	adds	r4, #1
    31f2:	f898 3000 	ldrb.w	r3, [r8]
    31f6:	b2e4      	uxtb	r4, r4
    31f8:	42a3      	cmp	r3, r4
    31fa:	d913      	bls.n	3224 <yield+0x98>
			s_serials_with_serial_events[i]->doYieldCode();
    31fc:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    3200:	682b      	ldr	r3, [r5, #0]
    3202:	4628      	mov	r0, r5
    3204:	691b      	ldr	r3, [r3, #16]
    3206:	4798      	blx	r3
    3208:	2800      	cmp	r0, #0
    320a:	d0f1      	beq.n	31f0 <yield+0x64>
    320c:	696b      	ldr	r3, [r5, #20]
    320e:	689b      	ldr	r3, [r3, #8]
    3210:	4798      	blx	r3
    3212:	e7ed      	b.n	31f0 <yield+0x64>
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    3214:	f7ff fcf2 	bl	2bfc <usb_seremu_available>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    3218:	b9d0      	cbnz	r0, 3250 <yield+0xc4>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    321a:	4b14      	ldr	r3, [pc, #80]	; (326c <yield+0xe0>)
    321c:	781b      	ldrb	r3, [r3, #0]
    321e:	b91b      	cbnz	r3, 3228 <yield+0x9c>
    3220:	7833      	ldrb	r3, [r6, #0]
    3222:	e7bf      	b.n	31a4 <yield+0x18>
    3224:	7833      	ldrb	r3, [r6, #0]
    3226:	e7bf      	b.n	31a8 <yield+0x1c>
    3228:	7833      	ldrb	r3, [r6, #0]
    322a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    322e:	7033      	strb	r3, [r6, #0]
    3230:	e7b8      	b.n	31a4 <yield+0x18>
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    3232:	2601      	movs	r6, #1
		firstYield = first->_next;
    3234:	6955      	ldr	r5, [r2, #20]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    3236:	7026      	strb	r6, [r4, #0]
		firstYield = first->_next;
    3238:	601d      	str	r5, [r3, #0]
		if (firstYield) {
    323a:	b165      	cbz	r5, 3256 <yield+0xca>
			firstYield->_prev = nullptr;
    323c:	61a9      	str	r1, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    323e:	b900      	cbnz	r0, 3242 <yield+0xb6>
    3240:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    3242:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    3244:	6893      	ldr	r3, [r2, #8]
    3246:	4610      	mov	r0, r2
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    3248:	7755      	strb	r5, [r2, #29]
		(*(first->_function))(*first);
    324a:	4798      	blx	r3
		runningFromYield = false;
    324c:	7025      	strb	r5, [r4, #0]
    324e:	e7b5      	b.n	31bc <yield+0x30>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    3250:	f7ff ff88 	bl	3164 <serialEvent()>
    3254:	e7e1      	b.n	321a <yield+0x8e>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    3256:	4b06      	ldr	r3, [pc, #24]	; (3270 <yield+0xe4>)
    3258:	601d      	str	r5, [r3, #0]
    325a:	e7f0      	b.n	323e <yield+0xb2>
    325c:	20001e3f 	.word	0x20001e3f
    3260:	2000277c 	.word	0x2000277c
    3264:	20002684 	.word	0x20002684
    3268:	2000277a 	.word	0x2000277a
    326c:	6000218a 	.word	0x6000218a
    3270:	20002690 	.word	0x20002690
    3274:	2000277b 	.word	0x2000277b
    3278:	20002694 	.word	0x20002694

0000327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>:
 *    @param  byteorder The byte order of the register (used when width is > 1),
 * defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    327c:	b5f0      	push	{r4, r5, r6, r7, lr}
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
  _spidevice = spidevice;
    327e:	6042      	str	r2, [r0, #4]
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
    3280:	f04f 0e00 	mov.w	lr, #0
 *    @param  byteorder The byte order of the register (used when width is > 1),
 * defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    3284:	f89d 7020 	ldrb.w	r7, [sp, #32]
    3288:	f8bd 6014 	ldrh.w	r6, [sp, #20]
    328c:	f89d 501c 	ldrb.w	r5, [sp, #28]
    3290:	f89d 2018 	ldrb.w	r2, [sp, #24]
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
  _spidevice = spidevice;
  _i2cdevice = i2cdevice;
    3294:	6001      	str	r1, [r0, #0]
  _spiregtype = type;
    3296:	7203      	strb	r3, [r0, #8]
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
    3298:	f8c0 e014 	str.w	lr, [r0, #20]
  _spidevice = spidevice;
  _i2cdevice = i2cdevice;
  _spiregtype = type;
  _addrwidth = address_width;
    329c:	7347      	strb	r7, [r0, #13]
  _address = reg_addr;
    329e:	8146      	strh	r6, [r0, #10]
  _byteorder = byteorder;
    32a0:	7385      	strb	r5, [r0, #14]
  _width = width;
    32a2:	7302      	strb	r2, [r0, #12]
}
    32a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    32a6:	bf00      	nop

000032a8 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>:
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
    32a8:	8943      	ldrh	r3, [r0, #10]
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    32aa:	b5f0      	push	{r4, r5, r6, r7, lr}

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    32ac:	b2dd      	uxtb	r5, r3
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    32ae:	b085      	sub	sp, #20

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    32b0:	0a1b      	lsrs	r3, r3, #8

  if (_i2cdevice) {
    32b2:	6804      	ldr	r4, [r0, #0]
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    32b4:	f88d 500c 	strb.w	r5, [sp, #12]
    32b8:	f88d 300d 	strb.w	r3, [sp, #13]

  if (_i2cdevice) {
    32bc:	b14c      	cbz	r4, 32d2 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x2a>
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
    32be:	7b46      	ldrb	r6, [r0, #13]
    32c0:	ad03      	add	r5, sp, #12
    32c2:	4620      	mov	r0, r4
    32c4:	2301      	movs	r3, #1
    32c6:	e88d 0060 	stmia.w	sp, {r5, r6}
    32ca:	f000 f949 	bl	3560 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>
      addrbuffer[0] |= 0x40;
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
  }
  return false;
}
    32ce:	b005      	add	sp, #20
    32d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
  }
  if (_spidevice) {
    32d2:	f8d0 e004 	ldr.w	lr, [r0, #4]
    32d6:	f1be 0f00 	cmp.w	lr, #0
    32da:	d023      	beq.n	3324 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x7c>
    if (_spiregtype == ADDRESSED_OPCODE_BIT0_LOW_TO_WRITE) {
    32dc:	7a04      	ldrb	r4, [r0, #8]
    32de:	2c03      	cmp	r4, #3
    32e0:	d022      	beq.n	3328 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x80>
    32e2:	460e      	mov	r6, r1
    32e4:	4617      	mov	r7, r2
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    }

    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    32e6:	b96c      	cbnz	r4, 3304 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x5c>
      addrbuffer[0] &= ~0x80;
    32e8:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    32ec:	f88d 500c 	strb.w	r5, [sp, #12]
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
      addrbuffer[0] &= ~0x80;
      addrbuffer[0] |= 0x40;
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
    32f0:	7b43      	ldrb	r3, [r0, #13]
    32f2:	463a      	mov	r2, r7
    32f4:	4631      	mov	r1, r6
    32f6:	4670      	mov	r0, lr
    32f8:	9300      	str	r3, [sp, #0]
    32fa:	ab03      	add	r3, sp, #12
    32fc:	f000 fb72 	bl	39e4 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>
  }
  return false;
}
    3300:	b005      	add	sp, #20
    3302:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }

    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] &= ~0x80;
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOWRITE) {
    3304:	2c02      	cmp	r4, #2
    3306:	d104      	bne.n	3312 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x6a>
      addrbuffer[0] |= 0x80;
    3308:	f065 057f 	orn	r5, r5, #127	; 0x7f
    330c:	f88d 500c 	strb.w	r5, [sp, #12]
    3310:	e7ee      	b.n	32f0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
    3312:	2c01      	cmp	r4, #1
    3314:	d1ec      	bne.n	32f0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
      addrbuffer[0] &= ~0x80;
      addrbuffer[0] |= 0x40;
    3316:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    331a:	f045 0540 	orr.w	r5, r5, #64	; 0x40
    331e:	f88d 500c 	strb.w	r5, [sp, #12]
    3322:	e7e5      	b.n	32f0 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
  }
  return false;
    3324:	4670      	mov	r0, lr
    3326:	e7d2      	b.n	32ce <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x26>
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    3328:	7b46      	ldrb	r6, [r0, #13]
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
    332a:	f023 0401 	bic.w	r4, r3, #1
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    332e:	4670      	mov	r0, lr
    3330:	ab03      	add	r3, sp, #12
    3332:	3601      	adds	r6, #1
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
    3334:	f88d 400c 	strb.w	r4, [sp, #12]
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
    3338:	f88d 500d 	strb.w	r5, [sp, #13]
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    333c:	9600      	str	r6, [sp, #0]
    333e:	f000 fb51 	bl	39e4 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>
    3342:	e7c4      	b.n	32ce <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x26>

00003344 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>:
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
  if (numbytes == 0) {
    3344:	b902      	cbnz	r2, 3348 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x4>
    numbytes = _width;
    3346:	7b02      	ldrb	r2, [r0, #12]
  }
  if (numbytes > 4) {
    3348:	2a04      	cmp	r2, #4
    334a:	d818      	bhi.n	337e <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x3a>
 *    @param  value Data to write
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
    334c:	b4f0      	push	{r4, r5, r6, r7}
  if (numbytes > 4) {
    return false;
  }

  // store a copy
  _cached = value;
    334e:	6141      	str	r1, [r0, #20]
    3350:	f100 070f 	add.w	r7, r0, #15

  for (int i = 0; i < numbytes; i++) {
    3354:	b16a      	cbz	r2, 3372 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x2e>
    3356:	f102 030e 	add.w	r3, r2, #14
    335a:	7b86      	ldrb	r6, [r0, #14]
    335c:	f100 050e 	add.w	r5, r0, #14
    3360:	463c      	mov	r4, r7
    3362:	4403      	add	r3, r0
    if (_byteorder == LSBFIRST) {
    3364:	b94e      	cbnz	r6, 337a <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x36>
      _buffer[i] = value & 0xFF;
    3366:	7021      	strb	r1, [r4, #0]
    3368:	3b01      	subs	r3, #1
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
    336a:	0a09      	lsrs	r1, r1, #8
    336c:	3401      	adds	r4, #1
  }

  // store a copy
  _cached = value;

  for (int i = 0; i < numbytes; i++) {
    336e:	42ab      	cmp	r3, r5
    3370:	d1f8      	bne.n	3364 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x20>
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    3372:	4639      	mov	r1, r7
}
    3374:	bcf0      	pop	{r4, r5, r6, r7}
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    3376:	f7ff bf97 	b.w	32a8 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>

  for (int i = 0; i < numbytes; i++) {
    if (_byteorder == LSBFIRST) {
      _buffer[i] = value & 0xFF;
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    337a:	7019      	strb	r1, [r3, #0]
    337c:	e7f4      	b.n	3368 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x24>
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
}
    337e:	2000      	movs	r0, #0
    3380:	4770      	bx	lr
    3382:	bf00      	nop

00003384 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>:
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    3384:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
    3386:	8944      	ldrh	r4, [r0, #10]
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    3388:	b085      	sub	sp, #20
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    338a:	6805      	ldr	r5, [r0, #0]
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    338c:	b2e6      	uxtb	r6, r4
    338e:	0a24      	lsrs	r4, r4, #8
    3390:	f88d 600c 	strb.w	r6, [sp, #12]
    3394:	f88d 400d 	strb.w	r4, [sp, #13]

  if (_i2cdevice) {
    3398:	b15d      	cbz	r5, 33b2 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2e>
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    339a:	7b40      	ldrb	r0, [r0, #13]
    339c:	2400      	movs	r4, #0
    339e:	9200      	str	r2, [sp, #0]
    33a0:	460b      	mov	r3, r1
    33a2:	4602      	mov	r2, r0
    33a4:	9401      	str	r4, [sp, #4]
    33a6:	4628      	mov	r0, r5
    33a8:	a903      	add	r1, sp, #12
    33aa:	f000 f96b 	bl	3684 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>
      addrbuffer[0] |= 0x80 | 0x40;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
}
    33ae:	b005      	add	sp, #20
    33b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  if (_spidevice) {
    33b2:	6845      	ldr	r5, [r0, #4]
    33b4:	b30d      	cbz	r5, 33fa <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x76>
    if (_spiregtype == ADDRESSED_OPCODE_BIT0_LOW_TO_WRITE) {
    33b6:	7a03      	ldrb	r3, [r0, #8]
    33b8:	2b03      	cmp	r3, #3
    33ba:	d020      	beq.n	33fe <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x7a>
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    33bc:	b97b      	cbnz	r3, 33de <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x5a>
      addrbuffer[0] |= 0x80;
    33be:	f066 067f 	orn	r6, r6, #127	; 0x7f
    33c2:	f88d 600c 	strb.w	r6, [sp, #12]
      addrbuffer[0] &= ~0x80;
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
      addrbuffer[0] |= 0x80 | 0x40;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    33c6:	7b40      	ldrb	r0, [r0, #13]
    33c8:	24ff      	movs	r4, #255	; 0xff
    33ca:	9200      	str	r2, [sp, #0]
    33cc:	460b      	mov	r3, r1
    33ce:	4602      	mov	r2, r0
    33d0:	a903      	add	r1, sp, #12
    33d2:	4628      	mov	r0, r5
    33d4:	9401      	str	r4, [sp, #4]
    33d6:	f000 fb3b 	bl	3a50 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>
  }
  return false;
}
    33da:	b005      	add	sp, #20
    33dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         len);
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] |= 0x80;
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOWRITE) {
    33de:	2b02      	cmp	r3, #2
    33e0:	d104      	bne.n	33ec <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x68>
      addrbuffer[0] &= ~0x80;
    33e2:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    33e6:	f88d 600c 	strb.w	r6, [sp, #12]
    33ea:	e7ec      	b.n	33c6 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
    33ec:	2b01      	cmp	r3, #1
    33ee:	d1ea      	bne.n	33c6 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
      addrbuffer[0] |= 0x80 | 0x40;
    33f0:	f066 063f 	orn	r6, r6, #63	; 0x3f
    33f4:	f88d 600c 	strb.w	r6, [sp, #12]
    33f8:	e7e5      	b.n	33c6 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
    33fa:	4628      	mov	r0, r5
    33fc:	e7d7      	b.n	33ae <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2a>
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    33fe:	7b43      	ldrb	r3, [r0, #13]
    3400:	27ff      	movs	r7, #255	; 0xff
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
    3402:	f044 0401 	orr.w	r4, r4, #1
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    3406:	9200      	str	r2, [sp, #0]
    3408:	4628      	mov	r0, r5
    340a:	1c5a      	adds	r2, r3, #1
    340c:	9701      	str	r7, [sp, #4]
    340e:	460b      	mov	r3, r1
    3410:	a903      	add	r1, sp, #12
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
    3412:	f88d 400c 	strb.w	r4, [sp, #12]
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
    3416:	f88d 600d 	strb.w	r6, [sp, #13]
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    341a:	f000 fb19 	bl	3a50 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>
    341e:	e7c6      	b.n	33ae <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2a>

00003420 <Adafruit_BusIO_Register::read()>:
/*!
 *    @brief  Read data from the register location. This does not do any error
 * checking!
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    3420:	b538      	push	{r3, r4, r5, lr}
  if (!read(_buffer, _width)) {
    3422:	f100 040f 	add.w	r4, r0, #15
    3426:	7b02      	ldrb	r2, [r0, #12]
/*!
 *    @brief  Read data from the register location. This does not do any error
 * checking!
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    3428:	4605      	mov	r5, r0
  if (!read(_buffer, _width)) {
    342a:	4621      	mov	r1, r4
    342c:	f7ff ffaa 	bl	3384 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    3430:	b910      	cbnz	r0, 3438 <Adafruit_BusIO_Register::read()+0x18>
    return -1;
    3432:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
      value |= _buffer[i];
    }
  }

  return value;
}
    3436:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    3438:	7b28      	ldrb	r0, [r5, #12]
    343a:	2800      	cmp	r0, #0
    343c:	d0fb      	beq.n	3436 <Adafruit_BusIO_Register::read()+0x16>
    343e:	300e      	adds	r0, #14
    3440:	4621      	mov	r1, r4
    3442:	f105 020e 	add.w	r2, r5, #14
    3446:	7bac      	ldrb	r4, [r5, #14]
    3448:	182b      	adds	r3, r5, r0
    344a:	2000      	movs	r0, #0
    344c:	e006      	b.n	345c <Adafruit_BusIO_Register::read()+0x3c>
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    344e:	781d      	ldrb	r5, [r3, #0]
    3450:	3b01      	subs	r3, #1
    3452:	3101      	adds	r1, #1
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    3454:	4293      	cmp	r3, r2
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    3456:	ea40 0005 	orr.w	r0, r0, r5
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    345a:	d009      	beq.n	3470 <Adafruit_BusIO_Register::read()+0x50>
    value <<= 8;
    345c:	0200      	lsls	r0, r0, #8
    if (_byteorder == LSBFIRST) {
    345e:	2c00      	cmp	r4, #0
    3460:	d0f5      	beq.n	344e <Adafruit_BusIO_Register::read()+0x2e>
    3462:	3b01      	subs	r3, #1
      value |= _buffer[_width - i - 1];
    } else {
      value |= _buffer[i];
    3464:	780d      	ldrb	r5, [r1, #0]
    3466:	3101      	adds	r1, #1
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    3468:	4293      	cmp	r3, r2
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    } else {
      value |= _buffer[i];
    346a:	ea40 0005 	orr.w	r0, r0, r5
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    346e:	d1f5      	bne.n	345c <Adafruit_BusIO_Register::read()+0x3c>
    3470:	bd38      	pop	{r3, r4, r5, pc}
    3472:	bf00      	nop

00003474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>:
 * touching other bits
 *    @param  reg The Adafruit_BusIO_Register which defines the bus/register
 *    @param  bits The number of bits wide we are slicing
 *    @param  shift The number of bits that our bit-slice is shifted from LSB
 */
Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(
    3474:	b410      	push	{r4}
    Adafruit_BusIO_Register *reg, uint8_t bits, uint8_t shift) {
  _register = reg;
    3476:	6001      	str	r1, [r0, #0]
  _bits = bits;
    3478:	7102      	strb	r2, [r0, #4]
  _shift = shift;
    347a:	7143      	strb	r3, [r0, #5]
}
    347c:	f85d 4b04 	ldr.w	r4, [sp], #4
    3480:	4770      	bx	lr
    3482:	bf00      	nop

00003484 <Adafruit_BusIO_RegisterBits::read()>:

/*!
 *    @brief  Read 4 bytes of data from the register
 *    @return  data The 4 bytes to read
 */
uint32_t Adafruit_BusIO_RegisterBits::read(void) {
    3484:	b510      	push	{r4, lr}
    3486:	4604      	mov	r4, r0
  uint32_t val = _register->read();
    3488:	6800      	ldr	r0, [r0, #0]
    348a:	f7ff ffc9 	bl	3420 <Adafruit_BusIO_Register::read()>
  val >>= _shift;
  return val & ((1 << (_bits)) - 1);
    348e:	2301      	movs	r3, #1
    3490:	7921      	ldrb	r1, [r4, #4]
    3492:	7962      	ldrb	r2, [r4, #5]
    3494:	408b      	lsls	r3, r1
    3496:	40d0      	lsrs	r0, r2
    3498:	3b01      	subs	r3, #1
}
    349a:	4018      	ands	r0, r3
    349c:	bd10      	pop	{r4, pc}
    349e:	bf00      	nop

000034a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>:
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    34a0:	b538      	push	{r3, r4, r5, lr}
    34a2:	4605      	mov	r5, r0
  uint32_t val = _register->read();
    34a4:	6800      	ldr	r0, [r0, #0]
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    34a6:	460c      	mov	r4, r1
  uint32_t val = _register->read();
    34a8:	f7ff ffba 	bl	3420 <Adafruit_BusIO_Register::read()>

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    34ac:	792a      	ldrb	r2, [r5, #4]
    34ae:	2301      	movs	r3, #1
  data &= mask;

  mask <<= _shift;
    34b0:	7969      	ldrb	r1, [r5, #5]
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
  uint32_t val = _register->read();

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    34b2:	4093      	lsls	r3, r2

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    34b4:	682d      	ldr	r5, [r5, #0]
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
  uint32_t val = _register->read();

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    34b6:	3b01      	subs	r3, #1

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    34b8:	7b2a      	ldrb	r2, [r5, #12]
    34ba:	401c      	ands	r4, r3
  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
  data &= mask;

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
    34bc:	408b      	lsls	r3, r1
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    34be:	fa04 f101 	lsl.w	r1, r4, r1
  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
  data &= mask;

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
    34c2:	ea20 0303 	bic.w	r3, r0, r3
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    34c6:	4628      	mov	r0, r5
    34c8:	4319      	orrs	r1, r3
}
    34ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    34ce:	f7ff bf39 	b.w	3344 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>
    34d2:	bf00      	nop

000034d4 <TwoWire::read()>:
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    34d4:	f890 30a2 	ldrb.w	r3, [r0, #162]	; 0xa2
    34d8:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    34dc:	429a      	cmp	r2, r3
    34de:	d905      	bls.n	34ec <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    34e0:	1c5a      	adds	r2, r3, #1
    34e2:	4403      	add	r3, r0
    34e4:	f880 20a2 	strb.w	r2, [r0, #162]	; 0xa2
    34e8:	7e98      	ldrb	r0, [r3, #26]
    34ea:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    34ec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    34f0:	4770      	bx	lr
    34f2:	bf00      	nop

000034f4 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>:
/*!
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
    34f4:	b430      	push	{r4, r5}
  _addr = addr;
  _wire = theWire;
  _begun = false;
    34f6:	2500      	movs	r5, #0
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
    34f8:	2420      	movs	r4, #32
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
    34fa:	7001      	strb	r1, [r0, #0]
  _wire = theWire;
  _begun = false;
    34fc:	7205      	strb	r5, [r0, #8]
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
    34fe:	60c4      	str	r4, [r0, #12]
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
  _wire = theWire;
    3500:	6042      	str	r2, [r0, #4]
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
#endif
}
    3502:	bc30      	pop	{r4, r5}
    3504:	4770      	bx	lr
    3506:	bf00      	nop

00003508 <Adafruit_I2CDevice::detected()>:
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    3508:	7a03      	ldrb	r3, [r0, #8]
/*!
 *    @brief  Scans I2C for the address - note will give a false-positive
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
    350a:	b510      	push	{r4, lr}
    350c:	4604      	mov	r4, r0
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    350e:	b18b      	cbz	r3, 3534 <Adafruit_I2CDevice::detected()+0x2c>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    3510:	7820      	ldrb	r0, [r4, #0]
		transmitting = 1;
    3512:	2201      	movs	r2, #1
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
    3514:	6863      	ldr	r3, [r4, #4]
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    3516:	4090      	lsls	r0, r2
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    3518:	4611      	mov	r1, r2
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    351a:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    351e:	f883 00a5 	strb.w	r0, [r3, #165]	; 0xa5
		transmitting = 1;
		txBufferLength = 1;
    3522:	f883 212f 	strb.w	r2, [r3, #303]	; 0x12f
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    3526:	6860      	ldr	r0, [r4, #4]
    3528:	f001 fb4c 	bl	4bc4 <TwoWire::endTransmission(unsigned char)>
  if (_wire->endTransmission() == 0) {
    352c:	fab0 f080 	clz	r0, r0
    3530:	0940      	lsrs	r0, r0, #5
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    3532:	bd10      	pop	{r4, pc}
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    3534:	2101      	movs	r1, #1
    3536:	f000 f803 	bl	3540 <Adafruit_I2CDevice::begin(bool)>
    353a:	2800      	cmp	r0, #0
    353c:	d1e8      	bne.n	3510 <Adafruit_I2CDevice::detected()+0x8>
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    353e:	bd10      	pop	{r4, pc}

00003540 <Adafruit_I2CDevice::begin(bool)>:
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    3540:	b538      	push	{r3, r4, r5, lr}
    3542:	4604      	mov	r4, r0
  _wire->begin();
    3544:	6840      	ldr	r0, [r0, #4]
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    3546:	460d      	mov	r5, r1
  _wire->begin();
    3548:	f007 f9d2 	bl	a8f0 <___ZN7TwoWire5beginEv_veneer>
  _begun = true;
    354c:	2001      	movs	r0, #1
    354e:	7220      	strb	r0, [r4, #8]

  if (addr_detect) {
    3550:	b905      	cbnz	r5, 3554 <Adafruit_I2CDevice::begin(bool)+0x14>
    return detected();
  }
  return true;
}
    3552:	bd38      	pop	{r3, r4, r5, pc}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    3554:	4620      	mov	r0, r4
  }
  return true;
}
    3556:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    355a:	f7ff bfd5 	b.w	3508 <Adafruit_I2CDevice::detected()>
    355e:	bf00      	nop

00003560 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>:
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    3560:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3564:	9e07      	ldr	r6, [sp, #28]
  if ((len + prefix_len) > maxBufferSize()) {
    3566:	68c4      	ldr	r4, [r0, #12]
    3568:	1995      	adds	r5, r2, r6
    356a:	42a5      	cmp	r5, r4
    356c:	d818      	bhi.n	35a0 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x40>
    356e:	4698      	mov	r8, r3
    3570:	460f      	mov	r7, r1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    3572:	7803      	ldrb	r3, [r0, #0]
		transmitting = 1;
    3574:	2101      	movs	r1, #1
    3576:	4615      	mov	r5, r2
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    3578:	6842      	ldr	r2, [r0, #4]
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    357a:	408b      	lsls	r3, r1
    357c:	4604      	mov	r4, r0
		transmitting = 1;
    357e:	f882 1130 	strb.w	r1, [r2, #304]	; 0x130
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    3582:	f882 30a5 	strb.w	r3, [r2, #165]	; 0xa5
		transmitting = 1;
		txBufferLength = 1;
    3586:	f882 112f 	strb.w	r1, [r2, #303]	; 0x12f

  // Write the prefix data (usually an address)
  if ((prefix_len != 0) && (prefix_buffer != nullptr)) {
    358a:	b166      	cbz	r6, 35a6 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    358c:	9b06      	ldr	r3, [sp, #24]
    358e:	b153      	cbz	r3, 35a6 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {
    3590:	6840      	ldr	r0, [r0, #4]
    3592:	4632      	mov	r2, r6
    3594:	9906      	ldr	r1, [sp, #24]
    3596:	6803      	ldr	r3, [r0, #0]
    3598:	685b      	ldr	r3, [r3, #4]
    359a:	4798      	blx	r3
    359c:	4286      	cmp	r6, r0
    359e:	d002      	beq.n	35a6 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    // we will need to find out if some platforms have larger
    // I2C buffer sizes :/
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
    35a0:	2000      	movs	r0, #0
    35a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    35a6:	6860      	ldr	r0, [r4, #4]
    35a8:	4639      	mov	r1, r7
    35aa:	462a      	mov	r2, r5
    35ac:	6803      	ldr	r3, [r0, #0]
    35ae:	685b      	ldr	r3, [r3, #4]
    35b0:	4798      	blx	r3
    35b2:	4285      	cmp	r5, r0
    35b4:	d1f4      	bne.n	35a0 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x40>
  if (stop) {
    DEBUG_SERIAL.print("\tSTOP");
  }
#endif

  if (_wire->endTransmission(stop) == 0) {
    35b6:	4641      	mov	r1, r8
    35b8:	6860      	ldr	r0, [r4, #4]
    35ba:	f001 fb03 	bl	4bc4 <TwoWire::endTransmission(unsigned char)>
    35be:	fab0 f080 	clz	r0, r0
    35c2:	0940      	lsrs	r0, r0, #5
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("\tFailed to send!");
#endif
    return false;
  }
}
    35c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000035c8 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>:
    pos += read_len;
  }
  return true;
}

bool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {
    35c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    35cc:	4615      	mov	r5, r2
    35ce:	4606      	mov	r6, r0
    35d0:	460f      	mov	r7, r1
#if defined(TinyWireM_h)
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#elif defined(ARDUINO_ARCH_MEGAAVR)
  size_t recv = _wire->requestFrom(_addr, len, stop);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
    35d2:	b2d2      	uxtb	r2, r2
    35d4:	7801      	ldrb	r1, [r0, #0]
    35d6:	6840      	ldr	r0, [r0, #4]
    35d8:	f001 fb64 	bl	4ca4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
#endif

  if (recv != len) {
    35dc:	4285      	cmp	r5, r0
    35de:	d002      	beq.n	35e6 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x1e>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    35e0:	2000      	movs	r0, #0
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    35e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    35e6:	b30d      	cbz	r5, 362c <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x64>
    35e8:	2300      	movs	r3, #0
    35ea:	f8df 904c 	ldr.w	r9, [pc, #76]	; 3638 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x70>
    35ee:	461c      	mov	r4, r3
    35f0:	e012      	b.n	3618 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x50>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    35f2:	f890 20a2 	ldrb.w	r2, [r0, #162]	; 0xa2
    35f6:	f890 30a3 	ldrb.w	r3, [r0, #163]	; 0xa3
		return rxBuffer[rxBufferIndex++];
    35fa:	f102 0e01 	add.w	lr, r2, #1
    35fe:	1881      	adds	r1, r0, r2
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    3600:	4293      	cmp	r3, r2
    3602:	d916      	bls.n	3632 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x6a>
		return rxBuffer[rxBufferIndex++];
    3604:	f880 e0a2 	strb.w	lr, [r0, #162]	; 0xa2
    3608:	7e88      	ldrb	r0, [r1, #26]
    360a:	3401      	adds	r4, #1
    buffer[i] = _wire->read();
    360c:	f888 0000 	strb.w	r0, [r8]
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    3610:	b2a4      	uxth	r4, r4
    3612:	42a5      	cmp	r5, r4
    3614:	4623      	mov	r3, r4
    3616:	d909      	bls.n	362c <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x64>
    buffer[i] = _wire->read();
    3618:	6870      	ldr	r0, [r6, #4]
    361a:	eb07 0803 	add.w	r8, r7, r3
    361e:	6803      	ldr	r3, [r0, #0]
    3620:	695a      	ldr	r2, [r3, #20]
    3622:	454a      	cmp	r2, r9
    3624:	d0e5      	beq.n	35f2 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x2a>
    3626:	4790      	blx	r2
    3628:	b2c0      	uxtb	r0, r0
    362a:	e7ee      	b.n	360a <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x42>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    362c:	2001      	movs	r0, #1
    362e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    3632:	20ff      	movs	r0, #255	; 0xff
    3634:	e7e9      	b.n	360a <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x42>
    3636:	bf00      	nop
    3638:	000034d5 	.word	0x000034d5

0000363c <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    363c:	b302      	cbz	r2, 3680 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x44>
 *    @param  buffer Pointer to buffer of data to read into
 *    @param  len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
    363e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3642:	4616      	mov	r6, r2
    3644:	4699      	mov	r9, r3
    3646:	4688      	mov	r8, r1
    3648:	4607      	mov	r7, r0
  size_t pos = 0;
  while (pos < len) {
    364a:	2400      	movs	r4, #0
    364c:	e001      	b.n	3652 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x16>
    364e:	42a6      	cmp	r6, r4
    3650:	d913      	bls.n	367a <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x3e>
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    3652:	1b32      	subs	r2, r6, r4
    3654:	68fd      	ldr	r5, [r7, #12]
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
    3656:	eb08 0104 	add.w	r1, r8, r4
    365a:	4638      	mov	r0, r7
    365c:	42aa      	cmp	r2, r5
    365e:	bf28      	it	cs
    3660:	462a      	movcs	r2, r5
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    3662:	1ab3      	subs	r3, r6, r2
    if (!_read(buffer + pos, read_len, read_stop))
    3664:	42a3      	cmp	r3, r4
    3666:	bf94      	ite	ls
    3668:	464b      	movls	r3, r9
    366a:	2300      	movhi	r3, #0
      return false;
    pos += read_len;
    366c:	4414      	add	r4, r2
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
    366e:	f7ff ffab 	bl	35c8 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>
    3672:	2800      	cmp	r0, #0
    3674:	d1eb      	bne.n	364e <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x12>
      return false;
    pos += read_len;
  }
  return true;
}
    3676:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
      return false;
    pos += read_len;
  }
  return true;
    367a:	2001      	movs	r0, #1
    367c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3680:	2001      	movs	r0, #1
}
    3682:	4770      	bx	lr

00003684 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    3684:	b5f0      	push	{r4, r5, r6, r7, lr}
    3686:	b083      	sub	sp, #12
  if (!write(write_buffer, write_len, stop)) {
    3688:	2400      	movs	r4, #0
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    368a:	461f      	mov	r7, r3
    368c:	4606      	mov	r6, r0
    368e:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  if (!write(write_buffer, write_len, stop)) {
    3692:	9401      	str	r4, [sp, #4]
    3694:	9400      	str	r4, [sp, #0]
    3696:	462b      	mov	r3, r5
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    3698:	9c08      	ldr	r4, [sp, #32]
  if (!write(write_buffer, write_len, stop)) {
    369a:	f7ff ff61 	bl	3560 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>
    369e:	b908      	cbnz	r0, 36a4 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)+0x20>
    return false;
  }

  return read(read_buffer, read_len);
}
    36a0:	b003      	add	sp, #12
    36a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
    36a4:	4622      	mov	r2, r4
    36a6:	4639      	mov	r1, r7
    36a8:	4630      	mov	r0, r6
    36aa:	2301      	movs	r3, #1
}
    36ac:	b003      	add	sp, #12
    36ae:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
    36b2:	f7ff bfc3 	b.w	363c <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>
    36b6:	bf00      	nop

000036b8 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>:
 *    @brief  Transfer (send/receive) a buffer over hard/soft SPI, without
 * transaction management
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    36b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // HARDWARE SPI
  //
  if (_spi) {
    36bc:	6804      	ldr	r4, [r0, #0]
 *    @brief  Transfer (send/receive) a buffer over hard/soft SPI, without
 * transaction management
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    36be:	4613      	mov	r3, r2
    36c0:	b085      	sub	sp, #20
    36c2:	460a      	mov	r2, r1
  //
  // HARDWARE SPI
  //
  if (_spi) {
    36c4:	b12c      	cbz	r4, 36d2 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x1a>
				transfer16(buf, buf, count >> 1);
				return;
			}
		}
#endif
		transfer(buf, buf, count);
    36c6:	4620      	mov	r0, r4
        buffer[i] = reply;
      }
    }
  }
  return;
}
    36c8:	b005      	add	sp, #20
    36ca:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    36ce:	f001 b981 	b.w	49d4 <SPIClass::transfer(void const*, void*, unsigned int)>

  //
  // SOFTWARE SPI
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    36d2:	7b04      	ldrb	r4, [r0, #12]
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    36d4:	4959      	ldr	r1, [pc, #356]	; (383c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x184>)
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    36d6:	2c00      	cmp	r4, #0
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    36d8:	6886      	ldr	r6, [r0, #8]
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    36da:	7814      	ldrb	r4, [r2, #0]
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    36dc:	bf0c      	ite	eq
    36de:	2501      	moveq	r5, #1
    36e0:	2580      	movne	r5, #128	; 0x80
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    36e2:	fbb1 f6f6 	udiv	r6, r1, r6
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    36e6:	4225      	tst	r5, r4
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    36e8:	9502      	str	r5, [sp, #8]
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    36ea:	b2f6      	uxtb	r6, r6
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    36ec:	bf0c      	ite	eq
    36ee:	2101      	moveq	r1, #1
    36f0:	2100      	movne	r1, #0
    36f2:	9100      	str	r1, [sp, #0]
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    36f4:	2b00      	cmp	r3, #0
    36f6:	d063      	beq.n	37c0 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x108>
    36f8:	4690      	mov	r8, r2
    36fa:	4683      	mov	fp, r0
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    36fc:	4c50      	ldr	r4, [pc, #320]	; (3840 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x188>)
    36fe:	4443      	add	r3, r8
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3700:	f8df 9144 	ldr.w	r9, [pc, #324]	; 3848 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x190>
    3704:	9303      	str	r3, [sp, #12]
    uint8_t reply = 0;
    uint8_t send = buffer[i];
    3706:	f818 ab01 	ldrb.w	sl, [r8], #1
    370a:	465b      	mov	r3, fp
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    370c:	9d02      	ldr	r5, [sp, #8]

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    uint8_t reply = 0;
    370e:	2700      	movs	r7, #0
    3710:	46c3      	mov	fp, r8
    3712:	4698      	mov	r8, r3

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
    3714:	2e00      	cmp	r6, #0
    3716:	d05a      	beq.n	37ce <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x116>
    3718:	4a4a      	ldr	r2, [pc, #296]	; (3844 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x18c>)
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    371a:	6823      	ldr	r3, [r4, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    371c:	6810      	ldr	r0, [r2, #0]
    371e:	fba9 1000 	umull	r1, r0, r9, r0
    3722:	0c80      	lsrs	r0, r0, #18
    3724:	fb00 f006 	mul.w	r0, r0, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    3728:	6821      	ldr	r1, [r4, #0]
    372a:	1ac9      	subs	r1, r1, r3
    372c:	4288      	cmp	r0, r1
    372e:	d8fb      	bhi.n	3728 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x70>
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    3730:	f898 100d 	ldrb.w	r1, [r8, #13]
    3734:	f011 0ff7 	tst.w	r1, #247	; 0xf7
    3738:	d16c      	bne.n	3814 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x15c>
        towrite = send & b;
    373a:	ea1a 0f05 	tst.w	sl, r5
        if ((_mosi != -1) && (lastmosi != towrite)) {
    373e:	f998 0010 	ldrsb.w	r0, [r8, #16]
      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
        towrite = send & b;
    3742:	bf14      	ite	ne
    3744:	2101      	movne	r1, #1
    3746:	2100      	moveq	r1, #0
        if ((_mosi != -1) && (lastmosi != towrite)) {
    3748:	1c43      	adds	r3, r0, #1
    374a:	d006      	beq.n	375a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xa2>
    374c:	9b00      	ldr	r3, [sp, #0]
    374e:	4299      	cmp	r1, r3
    3750:	d003      	beq.n	375a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xa2>
          if (towrite)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
#else
          digitalWrite(_mosi, towrite);
    3752:	b2c0      	uxtb	r0, r0
    3754:	9100      	str	r1, [sp, #0]
    3756:	f7fe f8c1 	bl	18dc <digitalWrite>
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    375a:	2101      	movs	r1, #1
    375c:	f898 000f 	ldrb.w	r0, [r8, #15]
    3760:	f7fe f8bc 	bl	18dc <digitalWrite>
#endif

        if (bitdelay_us) {
    3764:	b15e      	cbz	r6, 377e <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xc6>
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3766:	4a37      	ldr	r2, [pc, #220]	; (3844 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x18c>)
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3768:	6820      	ldr	r0, [r4, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    376a:	6811      	ldr	r1, [r2, #0]
    376c:	fba9 3101 	umull	r3, r1, r9, r1
    3770:	0c89      	lsrs	r1, r1, #18
    3772:	fb01 f106 	mul.w	r1, r1, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    3776:	6823      	ldr	r3, [r4, #0]
    3778:	1a1b      	subs	r3, r3, r0
    377a:	4299      	cmp	r1, r3
    377c:	d8fb      	bhi.n	3776 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xbe>
          delayMicroseconds(bitdelay_us);
        }

        if (_miso != -1) {
    377e:	f998 0011 	ldrsb.w	r0, [r8, #17]
    3782:	1c41      	adds	r1, r0, #1
    3784:	d004      	beq.n	3790 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xd8>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
#else
          if (digitalRead(_miso)) {
    3786:	b2c0      	uxtb	r0, r0
    3788:	f7fe f8ae 	bl	18e8 <digitalRead>
    378c:	b100      	cbz	r0, 3790 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xd8>
#endif
            reply |= b;
    378e:	432f      	orrs	r7, r5
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
#else
        digitalWrite(_sck, LOW);
    3790:	2100      	movs	r1, #0
    3792:	f898 000f 	ldrb.w	r0, [r8, #15]
    3796:	f7fe f8a1 	bl	18dc <digitalWrite>
#endif
            reply |= b;
          }
        }
      }
      if (_miso != -1) {
    379a:	f998 2011 	ldrsb.w	r2, [r8, #17]
    379e:	3201      	adds	r2, #1
        buffer[i] = reply;
    37a0:	bf18      	it	ne
    37a2:	f80b 7c01 	strbne.w	r7, [fp, #-1]
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    37a6:	f898 200c 	ldrb.w	r2, [r8, #12]
    37aa:	b962      	cbnz	r2, 37c6 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x10e>
    37ac:	006d      	lsls	r5, r5, #1
    37ae:	b2ed      	uxtb	r5, r5
    37b0:	2d00      	cmp	r5, #0
    37b2:	d1af      	bne.n	3714 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
    37b4:	4643      	mov	r3, r8
    37b6:	46d8      	mov	r8, fp
    37b8:	469b      	mov	fp, r3
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    37ba:	9b03      	ldr	r3, [sp, #12]
    37bc:	4543      	cmp	r3, r8
    37be:	d1a2      	bne.n	3706 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x4e>
        buffer[i] = reply;
      }
    }
  }
  return;
}
    37c0:	b005      	add	sp, #20
    37c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    37c6:	086d      	lsrs	r5, r5, #1
    37c8:	2d00      	cmp	r5, #0
    37ca:	d1a3      	bne.n	3714 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
    37cc:	e7f2      	b.n	37b4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xfc>

      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    37ce:	f898 200d 	ldrb.w	r2, [r8, #13]
    37d2:	f012 0ff7 	tst.w	r2, #247	; 0xf7
    37d6:	d0b0      	beq.n	373a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x82>
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    37d8:	2101      	movs	r1, #1
    37da:	f898 000f 	ldrb.w	r0, [r8, #15]
    37de:	f7fe f87d 	bl	18dc <digitalWrite>

        if (bitdelay_us) {
          delayMicroseconds(bitdelay_us);
        }

        if (_mosi != -1) {
    37e2:	f998 0010 	ldrsb.w	r0, [r8, #16]
    37e6:	1c42      	adds	r2, r0, #1
    37e8:	d004      	beq.n	37f4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x13c>
          if (send & b)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
#else
          digitalWrite(_mosi, send & b);
    37ea:	b2c0      	uxtb	r0, r0
    37ec:	ea0a 0105 	and.w	r1, sl, r5
    37f0:	f7fe f874 	bl	18dc <digitalWrite>
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
#else
        digitalWrite(_sck, LOW);
    37f4:	f898 000f 	ldrb.w	r0, [r8, #15]
    37f8:	2100      	movs	r1, #0
    37fa:	f7fe f86f 	bl	18dc <digitalWrite>
#endif

        if (_miso != -1) {
    37fe:	f998 0011 	ldrsb.w	r0, [r8, #17]
    3802:	1c43      	adds	r3, r0, #1
    3804:	d0cf      	beq.n	37a6 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xee>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
#else
          if (digitalRead(_miso)) {
    3806:	b2c0      	uxtb	r0, r0
    3808:	f7fe f86e 	bl	18e8 <digitalRead>
    380c:	2800      	cmp	r0, #0
    380e:	d0c4      	beq.n	379a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xe2>
#endif
            reply |= b;
    3810:	432f      	orrs	r7, r5
    3812:	e7c2      	b.n	379a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xe2>
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    3814:	2101      	movs	r1, #1
    3816:	f898 000f 	ldrb.w	r0, [r8, #15]
    381a:	9201      	str	r2, [sp, #4]
    381c:	f7fe f85e 	bl	18dc <digitalWrite>
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3820:	4b07      	ldr	r3, [pc, #28]	; (3840 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x188>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3822:	9a01      	ldr	r2, [sp, #4]
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3824:	6818      	ldr	r0, [r3, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3826:	6811      	ldr	r1, [r2, #0]
    3828:	fba9 3101 	umull	r3, r1, r9, r1
    382c:	0c89      	lsrs	r1, r1, #18
    382e:	fb01 f106 	mul.w	r1, r1, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    3832:	6823      	ldr	r3, [r4, #0]
    3834:	1a1b      	subs	r3, r3, r0
    3836:	4299      	cmp	r1, r3
    3838:	d8fb      	bhi.n	3832 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x17a>
    383a:	e7d2      	b.n	37e2 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x12a>
    383c:	0007a120 	.word	0x0007a120
    3840:	e0001004 	.word	0xe0001004
    3844:	20001470 	.word	0x20001470
    3848:	431bde83 	.word	0x431bde83

0000384c <Adafruit_SPIDevice::endTransaction()>:

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 */
void Adafruit_SPIDevice::endTransaction(void) {
  if (_spi) {
    384c:	6802      	ldr	r2, [r0, #0]
    384e:	b1f2      	cbz	r2, 388e <Adafruit_SPIDevice::endTransaction()+0x42>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    3850:	7cd3      	ldrb	r3, [r2, #19]
    3852:	b1e3      	cbz	r3, 388e <Adafruit_SPIDevice::endTransaction()+0x42>
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
    3854:	07d8      	lsls	r0, r3, #31
    3856:	d503      	bpl.n	3860 <Adafruit_SPIDevice::endTransaction()+0x14>
    3858:	4b0d      	ldr	r3, [pc, #52]	; (3890 <Adafruit_SPIDevice::endTransaction()+0x44>)
    385a:	6a91      	ldr	r1, [r2, #40]	; 0x28
    385c:	6019      	str	r1, [r3, #0]
    385e:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
    3860:	0799      	lsls	r1, r3, #30
    3862:	d503      	bpl.n	386c <Adafruit_SPIDevice::endTransaction()+0x20>
    3864:	4b0b      	ldr	r3, [pc, #44]	; (3894 <Adafruit_SPIDevice::endTransaction()+0x48>)
    3866:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    3868:	6019      	str	r1, [r3, #0]
    386a:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
    386c:	0758      	lsls	r0, r3, #29
    386e:	d503      	bpl.n	3878 <Adafruit_SPIDevice::endTransaction()+0x2c>
    3870:	4b09      	ldr	r3, [pc, #36]	; (3898 <Adafruit_SPIDevice::endTransaction()+0x4c>)
    3872:	6b11      	ldr	r1, [r2, #48]	; 0x30
    3874:	6019      	str	r1, [r3, #0]
    3876:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
    3878:	0719      	lsls	r1, r3, #28
    387a:	d503      	bpl.n	3884 <Adafruit_SPIDevice::endTransaction()+0x38>
    387c:	4b07      	ldr	r3, [pc, #28]	; (389c <Adafruit_SPIDevice::endTransaction()+0x50>)
    387e:	6b51      	ldr	r1, [r2, #52]	; 0x34
    3880:	6019      	str	r1, [r3, #0]
    3882:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
    3884:	06db      	lsls	r3, r3, #27
    3886:	d502      	bpl.n	388e <Adafruit_SPIDevice::endTransaction()+0x42>
    3888:	6b92      	ldr	r2, [r2, #56]	; 0x38
    388a:	4b05      	ldr	r3, [pc, #20]	; (38a0 <Adafruit_SPIDevice::endTransaction()+0x54>)
    388c:	601a      	str	r2, [r3, #0]
    388e:	4770      	bx	lr
    3890:	e000e100 	.word	0xe000e100
    3894:	e000e104 	.word	0xe000e104
    3898:	e000e108 	.word	0xe000e108
    389c:	e000e10c 	.word	0xe000e10c
    38a0:	e000e110 	.word	0xe000e110

000038a4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>:
/*!
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 * SPI)
 */
void Adafruit_SPIDevice::beginTransaction(void) {
  if (_spi) {
    38a4:	6803      	ldr	r3, [r0, #0]
 *    @brief  Write a buffer or two to the SPI device, with transaction
 * management.
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
    38a6:	b470      	push	{r4, r5, r6}
/*!
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 * SPI)
 */
void Adafruit_SPIDevice::beginTransaction(void) {
  if (_spi) {
    38a8:	2b00      	cmp	r3, #0
    38aa:	d02d      	beq.n	3908 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x64>
#ifdef BUSIO_HAS_HW_SPI
    _spi->beginTransaction(*_spiSetting);
    38ac:	6842      	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    38ae:	7cdc      	ldrb	r4, [r3, #19]
    38b0:	e892 0022 	ldmia.w	r2, {r1, r5}
    38b4:	2c00      	cmp	r4, #0
    38b6:	d130      	bne.n	391a <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x76>
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
    38b8:	689a      	ldr	r2, [r3, #8]
    38ba:	428a      	cmp	r2, r1
    38bc:	d05f      	beq.n	397e <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xda>
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
    38be:	4a39      	ldr	r2, [pc, #228]	; (39a4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x100>)
						     720000000,  // PLL3 PFD0
						     528000000,  // PLL2
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();
    38c0:	6099      	str	r1, [r3, #8]

			uint32_t cbcmr = CCM_CBCMR;
    38c2:	6992      	ldr	r2, [r2, #24]
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
    38c4:	4c38      	ldr	r4, [pc, #224]	; (39a8 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x104>)
    38c6:	f3c2 1601 	ubfx	r6, r2, #4, #2
    38ca:	f3c2 6282 	ubfx	r2, r2, #26, #3
    38ce:	f854 4026 	ldr.w	r4, [r4, r6, lsl #2]
    38d2:	3201      	adds	r2, #1
    38d4:	fbb4 f4f2 	udiv	r4, r4, r2
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
    38d8:	2900      	cmp	r1, #0
    38da:	d052      	beq.n	3982 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xde>
    38dc:	fbb4 f2f1 	udiv	r2, r4, r1

			if (d && clkhz/d > _clock) d++;
    38e0:	b142      	cbz	r2, 38f4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    38e2:	fbb4 f4f2 	udiv	r4, r4, r2
    38e6:	428c      	cmp	r4, r1
    38e8:	bf88      	it	hi
    38ea:	3201      	addhi	r2, #1
			if (d > 257) d= 257;  // max div
    38ec:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
    38f0:	d34b      	bcc.n	398a <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xe6>
    38f2:	4a2e      	ldr	r2, [pc, #184]	; (39ac <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x108>)
				div = d-2;
			} else {
				div =0;
			}
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);
    38f4:	60da      	str	r2, [r3, #12]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    38f6:	681b      	ldr	r3, [r3, #0]
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
    38f8:	2600      	movs	r6, #0
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
    38fa:	2403      	movs	r4, #3
		port().CCR = _ccr;
		port().TCR = settings.tcr;
		port().CR = LPSPI_CR_MEN;
    38fc:	2101      	movs	r1, #1
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
    38fe:	611e      	str	r6, [r3, #16]
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
    3900:	625c      	str	r4, [r3, #36]	; 0x24
		port().CCR = _ccr;
    3902:	641a      	str	r2, [r3, #64]	; 0x40
		port().TCR = settings.tcr;
    3904:	661d      	str	r5, [r3, #96]	; 0x60
		port().CR = LPSPI_CR_MEN;
    3906:	6119      	str	r1, [r3, #16]
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    3908:	f990 000e 	ldrsb.w	r0, [r0, #14]
    390c:	1c43      	adds	r3, r0, #1
    390e:	d03a      	beq.n	3986 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xe2>
    digitalWrite(_cs, value);
    3910:	b2c0      	uxtb	r0, r0
    3912:	2100      	movs	r1, #0
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    3914:	bc70      	pop	{r4, r5, r6}
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    digitalWrite(_cs, value);
    3916:	f7fd bfe1 	b.w	18dc <digitalWrite>
	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
			__disable_irq();
    391a:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    391c:	7cda      	ldrb	r2, [r3, #19]
    391e:	07d6      	lsls	r6, r2, #31
    3920:	d506      	bpl.n	3930 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x8c>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    3922:	4c23      	ldr	r4, [pc, #140]	; (39b0 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x10c>)
    3924:	695a      	ldr	r2, [r3, #20]
    3926:	6826      	ldr	r6, [r4, #0]
    3928:	4032      	ands	r2, r6
    392a:	629a      	str	r2, [r3, #40]	; 0x28
				NVIC_ICER0 = interruptSave[0];
    392c:	6022      	str	r2, [r4, #0]
    392e:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x02) {
    3930:	0794      	lsls	r4, r2, #30
    3932:	d506      	bpl.n	3942 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x9e>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    3934:	4c1f      	ldr	r4, [pc, #124]	; (39b4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x110>)
    3936:	699a      	ldr	r2, [r3, #24]
    3938:	6826      	ldr	r6, [r4, #0]
    393a:	4032      	ands	r2, r6
    393c:	62da      	str	r2, [r3, #44]	; 0x2c
				NVIC_ICER1 = interruptSave[1];
    393e:	6022      	str	r2, [r4, #0]
    3940:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x04) {
    3942:	0756      	lsls	r6, r2, #29
    3944:	d506      	bpl.n	3954 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xb0>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    3946:	4c1c      	ldr	r4, [pc, #112]	; (39b8 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x114>)
    3948:	69da      	ldr	r2, [r3, #28]
    394a:	6826      	ldr	r6, [r4, #0]
    394c:	4032      	ands	r2, r6
    394e:	631a      	str	r2, [r3, #48]	; 0x30
				NVIC_ICER2 = interruptSave[2];
    3950:	6022      	str	r2, [r4, #0]
    3952:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x08) {
    3954:	0714      	lsls	r4, r2, #28
    3956:	d506      	bpl.n	3966 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xc2>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    3958:	4c18      	ldr	r4, [pc, #96]	; (39bc <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x118>)
    395a:	6a1a      	ldr	r2, [r3, #32]
    395c:	6826      	ldr	r6, [r4, #0]
    395e:	4032      	ands	r2, r6
    3960:	635a      	str	r2, [r3, #52]	; 0x34
				NVIC_ICER3 = interruptSave[3];
    3962:	6022      	str	r2, [r4, #0]
    3964:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x10) {
    3966:	06d2      	lsls	r2, r2, #27
    3968:	d505      	bpl.n	3976 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xd2>
				interruptSave[4] = NVIC_ICER4 & interruptMask[4];
    396a:	4c15      	ldr	r4, [pc, #84]	; (39c0 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x11c>)
    396c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    396e:	6826      	ldr	r6, [r4, #0]
    3970:	4032      	ands	r2, r6
    3972:	639a      	str	r2, [r3, #56]	; 0x38
				NVIC_ICER4 = interruptSave[4];
    3974:	6022      	str	r2, [r4, #0]
			}
			__enable_irq();
    3976:	b662      	cpsie	i
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
    3978:	689a      	ldr	r2, [r3, #8]
    397a:	428a      	cmp	r2, r1
    397c:	d19f      	bne.n	38be <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x1a>
    397e:	68da      	ldr	r2, [r3, #12]
    3980:	e7b9      	b.n	38f6 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x52>

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
    3982:	4622      	mov	r2, r4
    3984:	e7ac      	b.n	38e0 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x3c>
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    3986:	bc70      	pop	{r4, r5, r6}
    3988:	4770      	bx	lr

			if (d && clkhz/d > _clock) d++;
			if (d > 257) d= 257;  // max div
			if (d > 2) {
    398a:	2a02      	cmp	r2, #2
    398c:	d908      	bls.n	39a0 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xfc>
    398e:	3a02      	subs	r2, #2
    3990:	0854      	lsrs	r4, r2, #1
    3992:	0421      	lsls	r1, r4, #16
    3994:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
    3998:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    399c:	430a      	orrs	r2, r1
    399e:	e7a9      	b.n	38f4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    39a0:	2200      	movs	r2, #0
    39a2:	e7a7      	b.n	38f4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    39a4:	400fc000 	.word	0x400fc000
    39a8:	200005bc 	.word	0x200005bc
    39ac:	007f7fff 	.word	0x007f7fff
    39b0:	e000e180 	.word	0xe000e180
    39b4:	e000e184 	.word	0xe000e184
    39b8:	e000e188 	.word	0xe000e188
    39bc:	e000e18c 	.word	0xe000e18c
    39c0:	e000e190 	.word	0xe000e190

000039c4 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>:

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
    39c4:	b510      	push	{r4, lr}
    39c6:	4604      	mov	r4, r0
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    39c8:	f990 000e 	ldrsb.w	r0, [r0, #14]
    39cc:	1c43      	adds	r3, r0, #1
    39ce:	d003      	beq.n	39d8 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()+0x14>
    digitalWrite(_cs, value);
    39d0:	b2c0      	uxtb	r0, r0
    39d2:	2101      	movs	r1, #1
    39d4:	f7fd ff82 	bl	18dc <digitalWrite>
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
    39d8:	4620      	mov	r0, r4
}
    39da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
    39de:	f7ff bf35 	b.w	384c <Adafruit_SPIDevice::endTransaction()>
    39e2:	bf00      	nop

000039e4 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>:
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(const uint8_t *buffer, size_t len,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    39e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    39e8:	b083      	sub	sp, #12
    39ea:	460c      	mov	r4, r1
    39ec:	4690      	mov	r8, r2
    39ee:	461d      	mov	r5, r3
    39f0:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    39f4:	4606      	mov	r6, r0
  beginTransactionWithAssertingCS();
    39f6:	f7ff ff55 	bl	38a4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
      _spi->transferBytes(buffer, nullptr, len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
    39fa:	f1b9 0f00 	cmp.w	r9, #0
    39fe:	d00d      	beq.n	3a1c <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x38>
    3a00:	f10d 0707 	add.w	r7, sp, #7
    3a04:	44a9      	add	r9, r5
      transfer(prefix_buffer[i]);
    3a06:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    3a0a:	2201      	movs	r2, #1
    3a0c:	4639      	mov	r1, r7
    3a0e:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    3a10:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    3a14:	f7ff fe50 	bl	36b8 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
      _spi->transferBytes(buffer, nullptr, len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
    3a18:	454d      	cmp	r5, r9
    3a1a:	d1f4      	bne.n	3a06 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x22>
      transfer(prefix_buffer[i]);
    }
    for (size_t i = 0; i < len; i++) {
    3a1c:	f1b8 0f00 	cmp.w	r8, #0
    3a20:	d00e      	beq.n	3a40 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x5c>
    3a22:	f10d 0707 	add.w	r7, sp, #7
    3a26:	eb04 0508 	add.w	r5, r4, r8
      transfer(buffer[i]);
    3a2a:	f814 3b01 	ldrb.w	r3, [r4], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    3a2e:	2201      	movs	r2, #1
    3a30:	4639      	mov	r1, r7
    3a32:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    3a34:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    3a38:	f7ff fe3e 	bl	36b8 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
      transfer(prefix_buffer[i]);
    }
    for (size_t i = 0; i < len; i++) {
    3a3c:	42ac      	cmp	r4, r5
    3a3e:	d1f4      	bne.n	3a2a <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x46>
      transfer(buffer[i]);
    }
  }
  endTransactionWithDeassertingCS();
    3a40:	4630      	mov	r0, r6
    3a42:	f7ff ffbf 	bl	39c4 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    3a46:	2001      	movs	r0, #1
    3a48:	b003      	add	sp, #12
    3a4a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    3a4e:	bf00      	nop

00003a50 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>:
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
    3a50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3a54:	4692      	mov	sl, r2
    3a56:	b082      	sub	sp, #8
    3a58:	460d      	mov	r5, r1
    3a5a:	461c      	mov	r4, r3
    3a5c:	4606      	mov	r6, r0
    3a5e:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    3a62:	f89d 802c 	ldrb.w	r8, [sp, #44]	; 0x2c
  beginTransactionWithAssertingCS();
    3a66:	f7ff ff1d 	bl	38a4 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
      _spi->transferBytes(write_buffer, nullptr, write_len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
    3a6a:	f1ba 0f00 	cmp.w	sl, #0
    3a6e:	d00d      	beq.n	3a8c <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x3c>
    3a70:	f10d 0707 	add.w	r7, sp, #7
    3a74:	44aa      	add	sl, r5
      transfer(write_buffer[i]);
    3a76:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    3a7a:	2201      	movs	r2, #1
    3a7c:	4639      	mov	r1, r7
    3a7e:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    3a80:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    3a84:	f7ff fe18 	bl	36b8 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
      _spi->transferBytes(write_buffer, nullptr, write_len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
    3a88:	4555      	cmp	r5, sl
    3a8a:	d1f4      	bne.n	3a76 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x26>
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    3a8c:	f1b9 0f00 	cmp.w	r9, #0
    3a90:	d00f      	beq.n	3ab2 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x62>
    3a92:	f10d 0707 	add.w	r7, sp, #7
    3a96:	44a1      	add	r9, r4
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    3a98:	2201      	movs	r2, #1
    3a9a:	4639      	mov	r1, r7
    3a9c:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    3a9e:	f88d 8007 	strb.w	r8, [sp, #7]
  transfer(&data, 1);
    3aa2:	f7ff fe09 	bl	36b8 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
  return data;
    3aa6:	f89d 3007 	ldrb.w	r3, [sp, #7]
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    read_buffer[i] = transfer(sendvalue);
    3aaa:	f804 3b01 	strb.w	r3, [r4], #1
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    3aae:	454c      	cmp	r4, r9
    3ab0:	d1f2      	bne.n	3a98 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x48>
    }
  }
  DEBUG_SERIAL.println();
#endif

  endTransactionWithDeassertingCS();
    3ab2:	4630      	mov	r0, r6
    3ab4:	f7ff ff86 	bl	39c4 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>

  return true;
}
    3ab8:	2001      	movs	r0, #1
    3aba:	b002      	add	sp, #8
    3abc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00003ac0 <Adafruit_Sensor::enableAutoRange(bool)>:
  // These must be defined by the subclass

  /*! @brief Whether we should automatically change the range (if possible) for
     higher precision
      @param enabled True if we will try to autorange */
  virtual void enableAutoRange(bool enabled) {
    3ac0:	4770      	bx	lr
    3ac2:	bf00      	nop

00003ac4 <Adafruit_LIS3MDL::~Adafruit_LIS3MDL()>:
  LIS3MDL_SINGLEMODE = 0b01,     ///< Single-shot conversion
  LIS3MDL_POWERDOWNMODE = 0b11,  ///< Powered-down mode
} lis3mdl_operationmode_t;

/** Class for hardware interfacing with an LIS3MDL magnetometer */
class Adafruit_LIS3MDL : public Adafruit_Sensor {
    3ac4:	4770      	bx	lr
    3ac6:	bf00      	nop

00003ac8 <Adafruit_LIS3MDL::getSensor(sensor_t*)>:
    @brief  Gets the sensor_t device data, Adafruit Unified Sensor format
    @param  sensor Pointer to an Adafruit Unified sensor_t object that we'll
   fill in
*/
/**************************************************************************/
void Adafruit_LIS3MDL::getSensor(sensor_t *sensor) {
    3ac8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3aca:	460c      	mov	r4, r1
    3acc:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3ace:	2228      	movs	r2, #40	; 0x28
    3ad0:	2100      	movs	r1, #0
    3ad2:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3ad4:	2701      	movs	r7, #1
   fill in
*/
/**************************************************************************/
void Adafruit_LIS3MDL::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3ad6:	f003 f9ed 	bl	6eb4 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
    3ada:	220b      	movs	r2, #11
    3adc:	4909      	ldr	r1, [pc, #36]	; (3b04 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x3c>)
    3ade:	4620      	mov	r0, r4
    3ae0:	f003 fe9c 	bl	781c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3ae4:	2300      	movs	r3, #0
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
    3ae6:	2502      	movs	r5, #2
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
    3ae8:	4807      	ldr	r0, [pc, #28]	; (3b08 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3aea:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
  sensor->max_value = 1600;   // +16 gauss in uTesla
    3aec:	4907      	ldr	r1, [pc, #28]	; (3b0c <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3aee:	6a76      	ldr	r6, [r6, #36]	; 0x24
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
  sensor->max_value = 1600;   // +16 gauss in uTesla
  sensor->resolution = 0.015; // 100/6842 uTesla per LSB at +-4 gauss range
    3af0:	4a07      	ldr	r2, [pc, #28]	; (3b10 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x48>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3af2:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    3af4:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
    3af6:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
    3af8:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
    3afa:	61e0      	str	r0, [r4, #28]
  sensor->max_value = 1600;   // +16 gauss in uTesla
    3afc:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 0.015; // 100/6842 uTesla per LSB at +-4 gauss range
    3afe:	6222      	str	r2, [r4, #32]
    3b00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3b02:	bf00      	nop
    3b04:	20000df4 	.word	0x20000df4
    3b08:	c4c80000 	.word	0xc4c80000
    3b0c:	44c80000 	.word	0x44c80000
    3b10:	3c75c28f 	.word	0x3c75c28f

00003b14 <Adafruit_LIS3MDL::~Adafruit_LIS3MDL()>:
    3b14:	b510      	push	{r4, lr}
    3b16:	4604      	mov	r4, r0
    3b18:	2128      	movs	r1, #40	; 0x28
    3b1a:	f7ff fb21 	bl	3160 <operator delete(void*, unsigned int)>
    3b1e:	4620      	mov	r0, r4
    3b20:	bd10      	pop	{r4, pc}
    3b22:	bf00      	nop

00003b24 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()>:
/**************************************************************************/
/*!
    @brief  Instantiates a new LIS3MDL class
*/
/**************************************************************************/
Adafruit_LIS3MDL::Adafruit_LIS3MDL() {}
    3b24:	2200      	movs	r2, #0
    3b26:	4903      	ldr	r1, [pc, #12]	; (3b34 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()+0x10>)
    3b28:	7602      	strb	r2, [r0, #24]
    3b2a:	6001      	str	r1, [r0, #0]
    3b2c:	61c2      	str	r2, [r0, #28]
    3b2e:	6202      	str	r2, [r0, #32]
    3b30:	4770      	bx	lr
    3b32:	bf00      	nop
    3b34:	20000470 	.word	0x20000470

00003b38 <Adafruit_LIS3MDL::read()>:
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    3b38:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3b3a:	2301      	movs	r3, #1
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    3b3c:	b08d      	sub	sp, #52	; 0x34
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3b3e:	2506      	movs	r5, #6
    3b40:	2700      	movs	r7, #0
    3b42:	2628      	movs	r6, #40	; 0x28
    3b44:	6a02      	ldr	r2, [r0, #32]
    3b46:	69c1      	ldr	r1, [r0, #28]
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    3b48:	4604      	mov	r4, r0
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3b4a:	9303      	str	r3, [sp, #12]
    3b4c:	a806      	add	r0, sp, #24
    3b4e:	9501      	str	r5, [sp, #4]
    3b50:	9702      	str	r7, [sp, #8]
    3b52:	9600      	str	r6, [sp, #0]
    3b54:	f7ff fb92 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  XYZDataReg.read(buffer, 6);
    3b58:	462a      	mov	r2, r5
    3b5a:	a904      	add	r1, sp, #16
    3b5c:	a806      	add	r0, sp, #24
    3b5e:	f7ff fc11 	bl	3384 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
  x = buffer[0];
  x |= buffer[1] << 8;
    3b62:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3b66:	f89d 1011 	ldrb.w	r1, [sp, #17]
  y = buffer[2];
  y |= buffer[3] << 8;
    3b6a:	f89d 0013 	ldrb.w	r0, [sp, #19]

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    3b6e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
  y = buffer[2];
  y |= buffer[3] << 8;
    3b72:	f89d 2012 	ldrb.w	r2, [sp, #18]
  z = buffer[4];
  z |= buffer[5] << 8;
    3b76:	f89d 5015 	ldrb.w	r5, [sp, #21]
    3b7a:	f89d 3014 	ldrb.w	r3, [sp, #20]
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
  y = buffer[2];
  y |= buffer[3] << 8;
    3b7e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  z = buffer[4];
  z |= buffer[5] << 8;

  float scale = 1; // LSB per gauss
  switch (rangeBuffered) {
    3b82:	7e20      	ldrb	r0, [r4, #24]

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    3b84:	b209      	sxth	r1, r1
  y = buffer[2];
  y |= buffer[3] << 8;
  z = buffer[4];
  z |= buffer[5] << 8;
    3b86:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
  y = buffer[2];
  y |= buffer[3] << 8;
    3b8a:	b212      	sxth	r2, r2
    3b8c:	2803      	cmp	r0, #3
  z = buffer[4];
  z |= buffer[5] << 8;
    3b8e:	b21b      	sxth	r3, r3

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    3b90:	80e1      	strh	r1, [r4, #6]
  y = buffer[2];
  y |= buffer[3] << 8;
    3b92:	8122      	strh	r2, [r4, #8]
  z = buffer[4];
  z |= buffer[5] << 8;
    3b94:	8163      	strh	r3, [r4, #10]
    3b96:	d81e      	bhi.n	3bd6 <Adafruit_LIS3MDL::read()+0x9e>
    3b98:	4d10      	ldr	r5, [pc, #64]	; (3bdc <Adafruit_LIS3MDL::read()+0xa4>)
    3b9a:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    3b9e:	ed90 6a00 	vldr	s12, [r0]
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    3ba2:	ee07 1a90 	vmov	s15, r1
    3ba6:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  y_gauss = (float)y / scale;
    3baa:	ee07 2a90 	vmov	s15, r2
    3bae:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  z_gauss = (float)z / scale;
    3bb2:	ee07 3a90 	vmov	s15, r3
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    3bb6:	eec6 5a86 	vdiv.f32	s11, s13, s12
  y_gauss = (float)y / scale;
  z_gauss = (float)z / scale;
    3bba:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
  y_gauss = (float)y / scale;
    3bbe:	eec7 6a06 	vdiv.f32	s13, s14, s12
  z_gauss = (float)z / scale;
    3bc2:	ee87 7a86 	vdiv.f32	s14, s15, s12
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    3bc6:	edc4 5a03 	vstr	s11, [r4, #12]
  y_gauss = (float)y / scale;
    3bca:	edc4 6a04 	vstr	s13, [r4, #16]
  z_gauss = (float)z / scale;
    3bce:	ed84 7a05 	vstr	s14, [r4, #20]
}
    3bd2:	b00d      	add	sp, #52	; 0x34
    3bd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  y |= buffer[3] << 8;
  z = buffer[4];
  z |= buffer[5] << 8;

  float scale = 1; // LSB per gauss
  switch (rangeBuffered) {
    3bd6:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    3bda:	e7e2      	b.n	3ba2 <Adafruit_LIS3MDL::read()+0x6a>
    3bdc:	20000430 	.word	0x20000430

00003be0 <Adafruit_LIS3MDL::getEvent(sensors_event_t*)>:
    @param  event Pointer to an Adafruit Unified sensor_event_t object that
   we'll fill in
    @returns True on successful read
*/
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
    3be0:	b570      	push	{r4, r5, r6, lr}
    3be2:	460c      	mov	r4, r1
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    3be4:	2624      	movs	r6, #36	; 0x24
    @param  event Pointer to an Adafruit Unified sensor_event_t object that
   we'll fill in
    @returns True on successful read
*/
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
    3be6:	4605      	mov	r5, r0
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    3be8:	2100      	movs	r1, #0
    3bea:	4632      	mov	r2, r6
    3bec:	4620      	mov	r0, r4
    3bee:	f003 f961 	bl	6eb4 <memset>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
    3bf2:	4b10      	ldr	r3, [pc, #64]	; (3c34 <Adafruit_LIS3MDL::getEvent(sensors_event_t*)+0x54>)

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
    3bf4:	6a69      	ldr	r1, [r5, #36]	; 0x24
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
    3bf6:	2202      	movs	r2, #2
    3bf8:	681b      	ldr	r3, [r3, #0]
  event->timestamp = millis();

  read();
    3bfa:	4628      	mov	r0, r5
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));

  event->version = sizeof(sensors_event_t);
    3bfc:	6026      	str	r6, [r4, #0]
  event->sensor_id = _sensorID;
    3bfe:	6061      	str	r1, [r4, #4]
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
    3c00:	60a2      	str	r2, [r4, #8]
  event->timestamp = millis();
    3c02:	6123      	str	r3, [r4, #16]

  read();
    3c04:	f7ff ff98 	bl	3b38 <Adafruit_LIS3MDL::read()>

  event->magnetic.x = x_gauss * 100; // microTesla per gauss
    3c08:	edd5 7a03 	vldr	s15, [r5, #12]
    3c0c:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 3c38 <Adafruit_LIS3MDL::getEvent(sensors_event_t*)+0x58>
  event->magnetic.y = y_gauss * 100; // microTesla per gauss
  event->magnetic.z = z_gauss * 100; // microTesla per gauss

  return true;
}
    3c10:	2001      	movs	r0, #1
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
  event->timestamp = millis();

  read();

  event->magnetic.x = x_gauss * 100; // microTesla per gauss
    3c12:	ee67 7a87 	vmul.f32	s15, s15, s14
    3c16:	edc4 7a05 	vstr	s15, [r4, #20]
  event->magnetic.y = y_gauss * 100; // microTesla per gauss
    3c1a:	edd5 7a04 	vldr	s15, [r5, #16]
    3c1e:	ee67 7a87 	vmul.f32	s15, s15, s14
    3c22:	edc4 7a06 	vstr	s15, [r4, #24]
  event->magnetic.z = z_gauss * 100; // microTesla per gauss
    3c26:	edd5 7a05 	vldr	s15, [r5, #20]
    3c2a:	ee67 7a87 	vmul.f32	s15, s15, s14
    3c2e:	edc4 7a07 	vstr	s15, [r4, #28]

  return true;
}
    3c32:	bd70      	pop	{r4, r5, r6, pc}
    3c34:	20002744 	.word	0x20002744
    3c38:	42c80000 	.word	0x42c80000

00003c3c <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>:
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    3c3c:	b5f0      	push	{r4, r5, r6, r7, lr}
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3c3e:	69c3      	ldr	r3, [r0, #28]
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    3c40:	b095      	sub	sp, #84	; 0x54
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3c42:	f04f 0e20 	mov.w	lr, #32
    3c46:	2401      	movs	r4, #1
    3c48:	2700      	movs	r7, #0
    3c4a:	6a02      	ldr	r2, [r0, #32]
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    3c4c:	4605      	mov	r5, r0
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3c4e:	f8cd e000 	str.w	lr, [sp]
    3c52:	eb0d 000e 	add.w	r0, sp, lr
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    3c56:	460e      	mov	r6, r1
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3c58:	9403      	str	r4, [sp, #12]
    3c5a:	4619      	mov	r1, r3
    3c5c:	9401      	str	r4, [sp, #4]
    3c5e:	4623      	mov	r3, r4
    3c60:	9702      	str	r7, [sp, #8]
    3c62:	f7ff fb0b 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits performancemodebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG1, 2, 5);
    3c66:	a908      	add	r1, sp, #32
    3c68:	2305      	movs	r3, #5
    3c6a:	2202      	movs	r2, #2
    3c6c:	a804      	add	r0, sp, #16
    3c6e:	f7ff fc01 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  performancemodebits.write((uint8_t)mode);
    3c72:	4631      	mov	r1, r6
    3c74:	a804      	add	r0, sp, #16
    3c76:	f7ff fc13 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // write z
  Adafruit_BusIO_Register CTRL_REG4 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG4, 1);
    3c7a:	6a2a      	ldr	r2, [r5, #32]
    3c7c:	69e9      	ldr	r1, [r5, #28]
    3c7e:	2523      	movs	r5, #35	; 0x23
    3c80:	4623      	mov	r3, r4
    3c82:	9702      	str	r7, [sp, #8]
    3c84:	9403      	str	r4, [sp, #12]
    3c86:	a80e      	add	r0, sp, #56	; 0x38
    3c88:	9401      	str	r4, [sp, #4]
    3c8a:	9500      	str	r5, [sp, #0]
    3c8c:	f7ff faf6 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits performancemodezbits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG4, 2, 2);
    3c90:	2302      	movs	r3, #2
    3c92:	a90e      	add	r1, sp, #56	; 0x38
    3c94:	a806      	add	r0, sp, #24
    3c96:	461a      	mov	r2, r3
    3c98:	f7ff fbec 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  performancemodezbits.write((uint8_t)mode);
    3c9c:	4631      	mov	r1, r6
    3c9e:	a806      	add	r0, sp, #24
    3ca0:	f7ff fbfe 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3ca4:	b015      	add	sp, #84	; 0x54
    3ca6:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003ca8 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>:
    from 0.625 Hz to 80Hz
    @param dataRate Enumerated lis3mdl_dataRate_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    3ca8:	2901      	cmp	r1, #1
    @brief  Sets the data rate for the LIS3MDL (controls power consumption)
    from 0.625 Hz to 80Hz
    @param dataRate Enumerated lis3mdl_dataRate_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
    3caa:	b5f0      	push	{r4, r5, r6, r7, lr}
    3cac:	460c      	mov	r4, r1
    3cae:	b08d      	sub	sp, #52	; 0x34
    3cb0:	4606      	mov	r6, r0
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    3cb2:	d025      	beq.n	3d00 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x58>
    // set OP to UHP
    setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_300_HZ) {
    3cb4:	2903      	cmp	r1, #3
    3cb6:	d027      	beq.n	3d08 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x60>
    // set OP to HP
    setPerformanceMode(LIS3MDL_HIGHMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_560_HZ) {
    3cb8:	2905      	cmp	r1, #5
    3cba:	d029      	beq.n	3d10 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x68>
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    3cbc:	2907      	cmp	r1, #7
    3cbe:	d01b      	beq.n	3cf8 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x50>
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
  }
  delay(10);
    3cc0:	200a      	movs	r0, #10
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3cc2:	2501      	movs	r5, #1
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
  }
  delay(10);
    3cc4:	f7fd fd70 	bl	17a8 <delay>
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3cc8:	2700      	movs	r7, #0
    3cca:	6a32      	ldr	r2, [r6, #32]
    3ccc:	462b      	mov	r3, r5
    3cce:	69f1      	ldr	r1, [r6, #28]
    3cd0:	2620      	movs	r6, #32
    3cd2:	a806      	add	r0, sp, #24
    3cd4:	9503      	str	r5, [sp, #12]
    3cd6:	9501      	str	r5, [sp, #4]
    3cd8:	9702      	str	r7, [sp, #8]
    3cda:	9600      	str	r6, [sp, #0]
    3cdc:	f7ff face 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits dataratebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG1, 4, 1); // includes FAST_ODR
    3ce0:	462b      	mov	r3, r5
    3ce2:	a906      	add	r1, sp, #24
    3ce4:	2204      	movs	r2, #4
    3ce6:	a804      	add	r0, sp, #16
    3ce8:	f7ff fbc4 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  dataratebits.write((uint8_t)dataRate);
    3cec:	4621      	mov	r1, r4
    3cee:	a804      	add	r0, sp, #16
    3cf0:	f7ff fbd6 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3cf4:	b00d      	add	sp, #52	; 0x34
    3cf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
    3cf8:	2100      	movs	r1, #0
    3cfa:	f7ff ff9f 	bl	3c3c <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3cfe:	e7df      	b.n	3cc0 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    // set OP to UHP
    setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
    3d00:	2103      	movs	r1, #3
    3d02:	f7ff ff9b 	bl	3c3c <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3d06:	e7db      	b.n	3cc0 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
  }
  if (dataRate == LIS3MDL_DATARATE_300_HZ) {
    // set OP to HP
    setPerformanceMode(LIS3MDL_HIGHMODE);
    3d08:	2102      	movs	r1, #2
    3d0a:	f7ff ff97 	bl	3c3c <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3d0e:	e7d7      	b.n	3cc0 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
  }
  if (dataRate == LIS3MDL_DATARATE_560_HZ) {
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
    3d10:	2101      	movs	r1, #1
    3d12:	f7ff ff93 	bl	3c3c <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3d16:	e7d3      	b.n	3cc0 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>

00003d18 <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>:
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    3d18:	b570      	push	{r4, r5, r6, lr}
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    3d1a:	6a02      	ldr	r2, [r0, #32]
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    3d1c:	b08c      	sub	sp, #48	; 0x30
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    3d1e:	69c0      	ldr	r0, [r0, #28]
    3d20:	2301      	movs	r3, #1
    3d22:	2400      	movs	r4, #0
    3d24:	2622      	movs	r6, #34	; 0x22
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    3d26:	460d      	mov	r5, r1
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    3d28:	9303      	str	r3, [sp, #12]
    3d2a:	4601      	mov	r1, r0
    3d2c:	9301      	str	r3, [sp, #4]
    3d2e:	a806      	add	r0, sp, #24
    3d30:	9402      	str	r4, [sp, #8]
    3d32:	9600      	str	r6, [sp, #0]
    3d34:	f7ff faa2 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits opmodebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG3, 2, 0);
    3d38:	4623      	mov	r3, r4
    3d3a:	a906      	add	r1, sp, #24
    3d3c:	2202      	movs	r2, #2
    3d3e:	a804      	add	r0, sp, #16
    3d40:	f7ff fb98 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  opmodebits.write((uint8_t)mode);
    3d44:	4629      	mov	r1, r5
    3d46:	a804      	add	r0, sp, #16
    3d48:	f7ff fbaa 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3d4c:	b00c      	add	sp, #48	; 0x30
    3d4e:	bd70      	pop	{r4, r5, r6, pc}

00003d50 <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>:
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    3d50:	b5f0      	push	{r4, r5, r6, r7, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3d52:	2301      	movs	r3, #1
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    3d54:	b08d      	sub	sp, #52	; 0x34
    3d56:	4604      	mov	r4, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3d58:	2700      	movs	r7, #0
    3d5a:	2621      	movs	r6, #33	; 0x21
    3d5c:	6a02      	ldr	r2, [r0, #32]
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    3d5e:	460d      	mov	r5, r1
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3d60:	a806      	add	r0, sp, #24
    3d62:	69e1      	ldr	r1, [r4, #28]
    3d64:	9303      	str	r3, [sp, #12]
    3d66:	9301      	str	r3, [sp, #4]
    3d68:	9702      	str	r7, [sp, #8]
    3d6a:	9600      	str	r6, [sp, #0]
    3d6c:	f7ff fa86 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits rangebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 2, 5);
    3d70:	a906      	add	r1, sp, #24
    3d72:	2305      	movs	r3, #5
    3d74:	2202      	movs	r2, #2
    3d76:	a804      	add	r0, sp, #16
    3d78:	f7ff fb7c 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  rangebits.write((uint8_t)range);
    3d7c:	4629      	mov	r1, r5
    3d7e:	a804      	add	r0, sp, #16
    3d80:	f7ff fb8e 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  rangeBuffered = range;
    3d84:	7625      	strb	r5, [r4, #24]
}
    3d86:	b00d      	add	sp, #52	; 0x34
    3d88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3d8a:	bf00      	nop

00003d8c <Adafruit_LIS3MDL::getRange()>:
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    3d8c:	b570      	push	{r4, r5, r6, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3d8e:	2301      	movs	r3, #1
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    3d90:	b08c      	sub	sp, #48	; 0x30
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3d92:	2600      	movs	r6, #0
    3d94:	2521      	movs	r5, #33	; 0x21
    3d96:	6a02      	ldr	r2, [r0, #32]
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    3d98:	4604      	mov	r4, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3d9a:	69c1      	ldr	r1, [r0, #28]
    3d9c:	a806      	add	r0, sp, #24
    3d9e:	9303      	str	r3, [sp, #12]
    3da0:	9301      	str	r3, [sp, #4]
    3da2:	9602      	str	r6, [sp, #8]
    3da4:	9500      	str	r5, [sp, #0]
    3da6:	f7ff fa69 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits rangebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 2, 5);
    3daa:	a906      	add	r1, sp, #24
    3dac:	2305      	movs	r3, #5
    3dae:	2202      	movs	r2, #2
    3db0:	a804      	add	r0, sp, #16
    3db2:	f7ff fb5f 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  rangeBuffered = (lis3mdl_range_t)rangebits.read();
    3db6:	a804      	add	r0, sp, #16
    3db8:	f7ff fb64 	bl	3484 <Adafruit_BusIO_RegisterBits::read()>
    3dbc:	b2c0      	uxtb	r0, r0
    3dbe:	7620      	strb	r0, [r4, #24]

  return rangeBuffered;
}
    3dc0:	b00c      	add	sp, #48	; 0x30
    3dc2:	bd70      	pop	{r4, r5, r6, pc}

00003dc4 <Adafruit_LIS3MDL::reset()>:
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3dc4:	b5f0      	push	{r4, r5, r6, r7, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3dc6:	2401      	movs	r4, #1
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3dc8:	b08d      	sub	sp, #52	; 0x34
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3dca:	2700      	movs	r7, #0
    3dcc:	2621      	movs	r6, #33	; 0x21
    3dce:	6a02      	ldr	r2, [r0, #32]
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3dd0:	4605      	mov	r5, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3dd2:	69c1      	ldr	r1, [r0, #28]
    3dd4:	4623      	mov	r3, r4
    3dd6:	a806      	add	r0, sp, #24
    3dd8:	9403      	str	r4, [sp, #12]
    3dda:	9401      	str	r4, [sp, #4]
    3ddc:	9702      	str	r7, [sp, #8]
    3dde:	9600      	str	r6, [sp, #0]
    3de0:	f7ff fa4c 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits resetbits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 1, 2);
    3de4:	4622      	mov	r2, r4
    3de6:	2302      	movs	r3, #2
    3de8:	a906      	add	r1, sp, #24
    3dea:	a804      	add	r0, sp, #16
    3dec:	f7ff fb42 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  resetbits.write(0x1);
    3df0:	4621      	mov	r1, r4
    3df2:	a804      	add	r0, sp, #16
    3df4:	f7ff fb54 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
  delay(10);
    3df8:	200a      	movs	r0, #10
    3dfa:	f7fd fcd5 	bl	17a8 <delay>

  getRange();
    3dfe:	4628      	mov	r0, r5
    3e00:	f7ff ffc4 	bl	3d8c <Adafruit_LIS3MDL::getRange()>
}
    3e04:	b00d      	add	sp, #52	; 0x34
    3e06:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003e08 <Adafruit_LIS3MDL::_init()>:

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    3e08:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    3e0a:	2501      	movs	r5, #1

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    3e0c:	b08b      	sub	sp, #44	; 0x2c
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    3e0e:	2400      	movs	r4, #0
    3e10:	270f      	movs	r7, #15
    3e12:	6a02      	ldr	r2, [r0, #32]
    3e14:	462b      	mov	r3, r5
    3e16:	69c1      	ldr	r1, [r0, #28]

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    3e18:	4606      	mov	r6, r0
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    3e1a:	9503      	str	r5, [sp, #12]
    3e1c:	a804      	add	r0, sp, #16
    3e1e:	9501      	str	r5, [sp, #4]
    3e20:	9402      	str	r4, [sp, #8]
    3e22:	9700      	str	r7, [sp, #0]
    3e24:	f7ff fa2a 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  // make sure we're talking to the right chip
  if (chip_id.read() != 0x3D) {
    3e28:	a804      	add	r0, sp, #16
    3e2a:	f7ff faf9 	bl	3420 <Adafruit_BusIO_Register::read()>
    3e2e:	283d      	cmp	r0, #61	; 0x3d
    3e30:	d002      	beq.n	3e38 <Adafruit_LIS3MDL::_init()+0x30>
    // No LIS3MDL detected ... return false
    return false;
    3e32:	4620      	mov	r0, r4
  setRange(LIS3MDL_RANGE_4_GAUSS);

  setOperationMode(LIS3MDL_CONTINUOUSMODE);

  return true;
}
    3e34:	b00b      	add	sp, #44	; 0x2c
    3e36:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (chip_id.read() != 0x3D) {
    // No LIS3MDL detected ... return false
    return false;
  }

  reset();
    3e38:	4630      	mov	r0, r6
    3e3a:	f7ff ffc3 	bl	3dc4 <Adafruit_LIS3MDL::reset()>

  // set high quality performance mode
  setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
    3e3e:	4630      	mov	r0, r6
    3e40:	2103      	movs	r1, #3
    3e42:	f7ff fefb 	bl	3c3c <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>

  // 155Hz default rate
  setDataRate(LIS3MDL_DATARATE_155_HZ);
    3e46:	4629      	mov	r1, r5
    3e48:	4630      	mov	r0, r6
    3e4a:	f7ff ff2d 	bl	3ca8 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>

  // lowest range
  setRange(LIS3MDL_RANGE_4_GAUSS);
    3e4e:	4621      	mov	r1, r4
    3e50:	4630      	mov	r0, r6
    3e52:	f7ff ff7d 	bl	3d50 <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>

  setOperationMode(LIS3MDL_CONTINUOUSMODE);
    3e56:	4630      	mov	r0, r6
    3e58:	4621      	mov	r1, r4
    3e5a:	f7ff ff5d 	bl	3d18 <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>
    3e5e:	4628      	mov	r0, r5

  return true;
}
    3e60:	b00b      	add	sp, #44	; 0x2c
    3e62:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003e64 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)>:
 *            The I2C address to be used.
 *    @param  wire
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
    3e64:	b530      	push	{r4, r5, lr}
    3e66:	4604      	mov	r4, r0
  if (!i2c_dev) {
    3e68:	69c0      	ldr	r0, [r0, #28]
 *            The I2C address to be used.
 *    @param  wire
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
    3e6a:	b083      	sub	sp, #12
  if (!i2c_dev) {
    3e6c:	b168      	cbz	r0, 3e8a <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0x26>
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
  }
  spi_dev = NULL;
    3e6e:	2300      	movs	r3, #0

  if (!i2c_dev->begin()) {
    3e70:	2101      	movs	r1, #1
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
  if (!i2c_dev) {
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
  }
  spi_dev = NULL;
    3e72:	6223      	str	r3, [r4, #32]

  if (!i2c_dev->begin()) {
    3e74:	f7ff fb64 	bl	3540 <Adafruit_I2CDevice::begin(bool)>
    3e78:	b908      	cbnz	r0, 3e7e <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0x1a>
    return false;
  }
  return _init();
}
    3e7a:	b003      	add	sp, #12
    3e7c:	bd30      	pop	{r4, r5, pc}
  spi_dev = NULL;

  if (!i2c_dev->begin()) {
    return false;
  }
  return _init();
    3e7e:	4620      	mov	r0, r4
}
    3e80:	b003      	add	sp, #12
    3e82:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  spi_dev = NULL;

  if (!i2c_dev->begin()) {
    return false;
  }
  return _init();
    3e86:	f7ff bfbf 	b.w	3e08 <Adafruit_LIS3MDL::_init()>
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
  if (!i2c_dev) {
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
    3e8a:	2010      	movs	r0, #16
    3e8c:	e88d 0006 	stmia.w	sp, {r1, r2}
    3e90:	f7ff f962 	bl	3158 <operator new(unsigned int)>
    3e94:	4605      	mov	r5, r0
    3e96:	e89d 0006 	ldmia.w	sp, {r1, r2}
    3e9a:	f7ff fb2b 	bl	34f4 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    3e9e:	4628      	mov	r0, r5
    3ea0:	61e5      	str	r5, [r4, #28]
    3ea2:	e7e4      	b.n	3e6e <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0xa>

00003ea4 <Adafruit_LIS3MDL::configInterrupt(bool, bool, bool, bool, bool, bool)>:
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3ea4:	b5f0      	push	{r4, r5, r6, r7, lr}
    3ea6:	b08b      	sub	sp, #44	; 0x2c
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3ea8:	f8d0 e020 	ldr.w	lr, [r0, #32]
    3eac:	69c7      	ldr	r7, [r0, #28]
    3eae:	2001      	movs	r0, #1
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3eb0:	f89d 4044 	ldrb.w	r4, [sp, #68]	; 0x44
    3eb4:	f89d c040 	ldrb.w	ip, [sp, #64]	; 0x40
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3eb8:	0065      	lsls	r5, r4, #1
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3eba:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3ebe:	9003      	str	r0, [sp, #12]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3ec0:	f045 0508 	orr.w	r5, r5, #8
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3ec4:	9001      	str	r0, [sp, #4]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3ec6:	ea45 048c 	orr.w	r4, r5, ip, lsl #2
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3eca:	2500      	movs	r5, #0
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3ecc:	ea44 1443 	orr.w	r4, r4, r3, lsl #5
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3ed0:	4603      	mov	r3, r0
    3ed2:	2030      	movs	r0, #48	; 0x30
    3ed4:	9502      	str	r5, [sp, #8]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3ed6:	ea44 1482 	orr.w	r4, r4, r2, lsl #6
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3eda:	4672      	mov	r2, lr
    3edc:	9000      	str	r0, [sp, #0]
    3ede:	a804      	add	r0, sp, #16
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3ee0:	ea44 14c1 	orr.w	r4, r4, r1, lsl #7
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3ee4:	4639      	mov	r1, r7
    3ee6:	f7ff f9c9 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  INT_CFG.write(value);
    3eea:	462a      	mov	r2, r5
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3eec:	b2e4      	uxtb	r4, r4
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
  INT_CFG.write(value);
    3eee:	a804      	add	r0, sp, #16
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;
    3ef0:	4334      	orrs	r4, r6

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
  INT_CFG.write(value);
    3ef2:	4621      	mov	r1, r4
    3ef4:	f7ff fa26 	bl	3344 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>
}
    3ef8:	b00b      	add	sp, #44	; 0x2c
    3efa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3efc:	0000      	movs	r0, r0
	...

00003f00 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3f00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3f04:	f04f 0c00 	mov.w	ip, #0
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3f08:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3f0a:	f8d0 9020 	ldr.w	r9, [r0, #32]
    3f0e:	2401      	movs	r4, #1
    3f10:	69c0      	ldr	r0, [r0, #28]
    3f12:	f04f 0806 	mov.w	r8, #6
    3f16:	f04f 0e28 	mov.w	lr, #40	; 0x28
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3f1a:	460f      	mov	r7, r1
    3f1c:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3f1e:	4601      	mov	r1, r0
    3f20:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3f22:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3f24:	a806      	add	r0, sp, #24
    3f26:	9403      	str	r4, [sp, #12]
    3f28:	4623      	mov	r3, r4
    3f2a:	f8cd c008 	str.w	ip, [sp, #8]
    3f2e:	f8cd 8004 	str.w	r8, [sp, #4]
    3f32:	f8cd e000 	str.w	lr, [sp]
    3f36:	f7ff f9a1 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    3f3a:	4642      	mov	r2, r8
    3f3c:	a806      	add	r0, sp, #24
    3f3e:	a904      	add	r1, sp, #16
    3f40:	f7ff fa20 	bl	3384 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    3f44:	b3c8      	cbz	r0, 3fba <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xba>
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3f46:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    3f4a:	eeb1 6b00 	vmov.f64	d6, #16	; 0x40800000  4.0
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;

  return 1;
    3f4e:	4620      	mov	r0, r4
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3f50:	ee04 3a10 	vmov	s8, r3
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3f54:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    3f58:	ee05 3a10 	vmov	s10, r3
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3f5c:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3f60:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3f64:	ee07 3a10 	vmov	s14, r3
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3f68:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3f6c:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3f70:	ee24 4b06 	vmul.f64	d4, d4, d6
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3f74:	ee25 5b06 	vmul.f64	d5, d5, d6
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3f78:	ee27 6b06 	vmul.f64	d6, d7, d6
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3f7c:	ed9f 7b12 	vldr	d7, [pc, #72]	; 3fc8 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xc8>
    3f80:	ed9f 3b13 	vldr	d3, [pc, #76]	; 3fd0 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xd0>
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3f84:	ee25 5b07 	vmul.f64	d5, d5, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3f88:	ee24 4b07 	vmul.f64	d4, d4, d7
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3f8c:	ee26 7b07 	vmul.f64	d7, d6, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3f90:	ee24 4b03 	vmul.f64	d4, d4, d3
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3f94:	ee25 6b03 	vmul.f64	d6, d5, d3
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3f98:	ee27 7b03 	vmul.f64	d7, d7, d3
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3f9c:	eeb7 4bc4 	vcvt.f32.f64	s8, d4
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3fa0:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3fa4:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3fa8:	ed87 4a00 	vstr	s8, [r7]
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3fac:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3fb0:	ed85 7a00 	vstr	s14, [r5]

  return 1;
    3fb4:	b00d      	add	sp, #52	; 0x34
    3fb6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);

  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    3fba:	4b07      	ldr	r3, [pc, #28]	; (3fd8 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xd8>)
    3fbc:	602b      	str	r3, [r5, #0]
    3fbe:	6033      	str	r3, [r6, #0]
    3fc0:	603b      	str	r3, [r7, #0]
  x = data[0] * 4.0 * 100.0 / 32768.0;
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;

  return 1;
    3fc2:	b00d      	add	sp, #52	; 0x34
    3fc4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    3fc8:	00000000 	.word	0x00000000
    3fcc:	40590000 	.word	0x40590000
    3fd0:	00000000 	.word	0x00000000
    3fd4:	3f000000 	.word	0x3f000000
    3fd8:	7fc00000 	.word	0x7fc00000

00003fdc <Adafruit_LSM6DS::~Adafruit_LSM6DS()>:
Adafruit_LSM6DS::Adafruit_LSM6DS(void) {}

/*!
 *    @brief  Cleans up the LSM6DS
 */
Adafruit_LSM6DS::~Adafruit_LSM6DS(void) { delete temp_sensor; }
    3fdc:	b510      	push	{r4, lr}
    3fde:	4b05      	ldr	r3, [pc, #20]	; (3ff4 <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x18>)
    3fe0:	4604      	mov	r4, r0
    3fe2:	6c40      	ldr	r0, [r0, #68]	; 0x44
    3fe4:	6023      	str	r3, [r4, #0]
    3fe6:	b110      	cbz	r0, 3fee <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x12>
    3fe8:	6803      	ldr	r3, [r0, #0]
    3fea:	685b      	ldr	r3, [r3, #4]
    3fec:	4798      	blx	r3
    3fee:	4620      	mov	r0, r4
    3ff0:	bd10      	pop	{r4, pc}
    3ff2:	bf00      	nop
    3ff4:	20000458 	.word	0x20000458

00003ff8 <Adafruit_LSM6DS_Gyro::~Adafruit_LSM6DS_Gyro()>:
  int _sensorID = 0x6D1;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
    3ff8:	4770      	bx	lr
    3ffa:	bf00      	nop

00003ffc <Adafruit_LSM6DS_Accelerometer::~Adafruit_LSM6DS_Accelerometer()>:
  int _sensorID = 0x6D0;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for accelerometer component of LSM6DS */
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
    3ffc:	4770      	bx	lr
    3ffe:	bf00      	nop

00004000 <Adafruit_LSM6DS_Temp::~Adafruit_LSM6DS_Temp()>:
} lsm6ds_hp_filter_t;

class Adafruit_LSM6DS;

/** Adafruit Unified Sensor interface for temperature component of LSM6DS */
class Adafruit_LSM6DS_Temp : public Adafruit_Sensor {
    4000:	4770      	bx	lr
    4002:	bf00      	nop

00004004 <Adafruit_LSM6DS::~Adafruit_LSM6DS()>:
    4004:	b510      	push	{r4, lr}
    4006:	4b07      	ldr	r3, [pc, #28]	; (4024 <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x20>)
    4008:	4604      	mov	r4, r0
    400a:	6c40      	ldr	r0, [r0, #68]	; 0x44
    400c:	6023      	str	r3, [r4, #0]
    400e:	b110      	cbz	r0, 4016 <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x12>
    4010:	6803      	ldr	r3, [r0, #0]
    4012:	685b      	ldr	r3, [r3, #4]
    4014:	4798      	blx	r3
    4016:	4620      	mov	r0, r4
    4018:	2154      	movs	r1, #84	; 0x54
    401a:	f7ff f8a1 	bl	3160 <operator delete(void*, unsigned int)>
    401e:	4620      	mov	r0, r4
    4020:	bd10      	pop	{r4, pc}
    4022:	bf00      	nop
    4024:	20000458 	.word	0x20000458

00004028 <Adafruit_LSM6DS_Temp::~Adafruit_LSM6DS_Temp()>:
    4028:	b510      	push	{r4, lr}
    402a:	4604      	mov	r4, r0
    402c:	2110      	movs	r1, #16
    402e:	f7ff f897 	bl	3160 <operator delete(void*, unsigned int)>
    4032:	4620      	mov	r0, r4
    4034:	bd10      	pop	{r4, pc}
    4036:	bf00      	nop

00004038 <Adafruit_LSM6DS_Accelerometer::~Adafruit_LSM6DS_Accelerometer()>:
  int _sensorID = 0x6D0;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for accelerometer component of LSM6DS */
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
    4038:	b510      	push	{r4, lr}
    403a:	4604      	mov	r4, r0
    403c:	2110      	movs	r1, #16
    403e:	f7ff f88f 	bl	3160 <operator delete(void*, unsigned int)>
    4042:	4620      	mov	r0, r4
    4044:	bd10      	pop	{r4, pc}
    4046:	bf00      	nop

00004048 <Adafruit_LSM6DS_Gyro::~Adafruit_LSM6DS_Gyro()>:
  int _sensorID = 0x6D1;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
    4048:	b510      	push	{r4, lr}
    404a:	4604      	mov	r4, r0
    404c:	2110      	movs	r1, #16
    404e:	f7ff f887 	bl	3160 <operator delete(void*, unsigned int)>
    4052:	4620      	mov	r0, r4
    4054:	bd10      	pop	{r4, pc}
    4056:	bf00      	nop

00004058 <Adafruit_LSM6DS_Temp::getEvent(sensors_event_t*)>:
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
    4058:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    405a:	4606      	mov	r6, r0
  _theLSM6DS->_read();
    405c:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
    405e:	460c      	mov	r4, r1
  fillTempEvent(temp, t);
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
    4060:	2524      	movs	r5, #36	; 0x24
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
    4062:	6803      	ldr	r3, [r0, #0]
    4064:	689b      	ldr	r3, [r3, #8]
    4066:	4798      	blx	r3
  _theLSM6DS->fillTempEvent(event, millis());
    4068:	68f6      	ldr	r6, [r6, #12]
    406a:	4b08      	ldr	r3, [pc, #32]	; (408c <Adafruit_LSM6DS_Temp::getEvent(sensors_event_t*)+0x34>)
  fillTempEvent(temp, t);
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
    406c:	462a      	mov	r2, r5
    406e:	4620      	mov	r0, r4
    4070:	2100      	movs	r1, #0
    4072:	681f      	ldr	r7, [r3, #0]
    4074:	f002 ff1e 	bl	6eb4 <memset>
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
    4078:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    407a:	230d      	movs	r3, #13
  temp->timestamp = timestamp;
  temp->temperature = temperature;
    407c:	6972      	ldr	r2, [r6, #20]
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillTempEvent(event, millis());

  return true;
}
    407e:	2001      	movs	r0, #1
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
    4080:	6025      	str	r5, [r4, #0]
  temp->sensor_id = _sensorid_temp;
    4082:	6061      	str	r1, [r4, #4]
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  temp->timestamp = timestamp;
  temp->temperature = temperature;
    4084:	6162      	str	r2, [r4, #20]
void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  temp->timestamp = timestamp;
    4086:	6127      	str	r7, [r4, #16]

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    4088:	60a3      	str	r3, [r4, #8]
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillTempEvent(event, millis());

  return true;
}
    408a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    408c:	20002744 	.word	0x20002744

00004090 <Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t*)>:
    @brief  Gets the gyroscope as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
    4090:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4092:	4605      	mov	r5, r0
  _theLSM6DS->_read();
    4094:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the gyroscope as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
    4096:	460c      	mov	r4, r1
  _theLSM6DS->_read();
    4098:	6803      	ldr	r3, [r0, #0]
    409a:	689b      	ldr	r3, [r3, #8]
    409c:	4798      	blx	r3
  _theLSM6DS->fillGyroEvent(event, millis());
    409e:	68ed      	ldr	r5, [r5, #12]
    40a0:	4b0a      	ldr	r3, [pc, #40]	; (40cc <Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t*)+0x3c>)
  temp->timestamp = timestamp;
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
    40a2:	4620      	mov	r0, r4
    40a4:	2224      	movs	r2, #36	; 0x24
    40a6:	2100      	movs	r1, #0
    40a8:	681e      	ldr	r6, [r3, #0]
    40aa:	f002 ff03 	bl	6eb4 <memset>
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
    40ae:	6a69      	ldr	r1, [r5, #36]	; 0x24
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
    40b0:	2301      	movs	r3, #1
  gyro->sensor_id = _sensorid_gyro;
    40b2:	8e6f      	ldrh	r7, [r5, #50]	; 0x32
  gyro->type = SENSOR_TYPE_GYROSCOPE;
    40b4:	2204      	movs	r2, #4
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
    40b6:	6161      	str	r1, [r4, #20]
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillGyroEvent(event, millis());

  return true;
}
    40b8:	4618      	mov	r0, r3
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
    40ba:	6aa9      	ldr	r1, [r5, #40]	; 0x28
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
    40bc:	6067      	str	r7, [r4, #4]
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
    40be:	61a1      	str	r1, [r4, #24]
  gyro->gyro.z = gyroZ;
    40c0:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
    40c2:	6126      	str	r6, [r4, #16]
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
  gyro->gyro.z = gyroZ;
    40c4:	61e1      	str	r1, [r4, #28]

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
    40c6:	60a2      	str	r2, [r4, #8]
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
    40c8:	6023      	str	r3, [r4, #0]
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillGyroEvent(event, millis());

  return true;
}
    40ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    40cc:	20002744 	.word	0x20002744

000040d0 <Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t*)>:
    @brief  Gets the accelerometer as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
    40d0:	b570      	push	{r4, r5, r6, lr}
    40d2:	4605      	mov	r5, r0
  _theLSM6DS->_read();
    40d4:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the accelerometer as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
    40d6:	460c      	mov	r4, r1
  _theLSM6DS->_read();
    40d8:	6803      	ldr	r3, [r0, #0]
    40da:	689b      	ldr	r3, [r3, #8]
    40dc:	4798      	blx	r3
  _theLSM6DS->fillAccelEvent(event, millis());
    40de:	68ed      	ldr	r5, [r5, #12]
    40e0:	4b0a      	ldr	r3, [pc, #40]	; (410c <Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t*)+0x3c>)
  gyro->gyro.z = gyroZ;
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
    40e2:	4620      	mov	r0, r4
    40e4:	2224      	movs	r2, #36	; 0x24
    40e6:	2100      	movs	r1, #0
    40e8:	681e      	ldr	r6, [r3, #0]
    40ea:	f002 fee3 	bl	6eb4 <memset>
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
    40ee:	69aa      	ldr	r2, [r5, #24]
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
    40f0:	2301      	movs	r3, #1
  accel->sensor_id = _sensorid_accel;
    40f2:	8e29      	ldrh	r1, [r5, #48]	; 0x30
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
    40f4:	6162      	str	r2, [r4, #20]
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillAccelEvent(event, millis());

  return true;
}
    40f6:	4618      	mov	r0, r3
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
    40f8:	69ea      	ldr	r2, [r5, #28]

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
    40fa:	6061      	str	r1, [r4, #4]
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
    40fc:	61a2      	str	r2, [r4, #24]
  accel->acceleration.z = accZ;
    40fe:	6a2a      	ldr	r2, [r5, #32]
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
    4100:	6126      	str	r6, [r4, #16]
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
  accel->acceleration.z = accZ;
    4102:	61e2      	str	r2, [r4, #28]
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
    4104:	6023      	str	r3, [r4, #0]
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
    4106:	60a3      	str	r3, [r4, #8]
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillAccelEvent(event, millis());

  return true;
}
    4108:	bd70      	pop	{r4, r5, r6, pc}
    410a:	bf00      	nop
    410c:	20002744 	.word	0x20002744

00004110 <Adafruit_LSM6DS::_read()>:
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    4110:	b5f0      	push	{r4, r5, r6, r7, lr}
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    4112:	2300      	movs	r3, #0
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    4114:	b08f      	sub	sp, #60	; 0x3c
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    4116:	2620      	movs	r6, #32
    4118:	250e      	movs	r5, #14
    411a:	2701      	movs	r7, #1
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    411c:	4604      	mov	r4, r0
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    411e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    4120:	6b81      	ldr	r1, [r0, #56]	; 0x38
    4122:	eb0d 0006 	add.w	r0, sp, r6
    4126:	9302      	str	r3, [sp, #8]
    4128:	9703      	str	r7, [sp, #12]
    412a:	9501      	str	r5, [sp, #4]
    412c:	9600      	str	r6, [sp, #0]
    412e:	f7ff f8a5 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  uint8_t buffer[14];
  data_reg.read(buffer, 14);
    4132:	462a      	mov	r2, r5
    4134:	eb0d 0006 	add.w	r0, sp, r6
    4138:	a904      	add	r1, sp, #16
    413a:	f7ff f923 	bl	3384 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>

  rawTemp = buffer[1] << 8 | buffer[0];
    413e:	f89d 3010 	ldrb.w	r3, [sp, #16]
    4142:	f89d 7011 	ldrb.w	r7, [sp, #17]
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    4146:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
    414a:	edd4 6a10 	vldr	s13, [r4, #64]	; 0x40
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    414e:	ea43 2707 	orr.w	r7, r3, r7, lsl #8
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    4152:	f89d 6013 	ldrb.w	r6, [sp, #19]
    4156:	f89d 3012 	ldrb.w	r3, [sp, #18]
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    415a:	b23f      	sxth	r7, r7
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    415c:	f89d 2014 	ldrb.w	r2, [sp, #20]
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    4160:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    4164:	f89d e019 	ldrb.w	lr, [sp, #25]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    4168:	ee07 7a90 	vmov	s15, r7

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    416c:	f89d 3016 	ldrb.w	r3, [sp, #22]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    4170:	f89d 5015 	ldrb.w	r5, [sp, #21]
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    4174:	b236      	sxth	r6, r6

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    4176:	eeb8 6ae7 	vcvt.f32.s32	s12, s15

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    417a:	f89d 0017 	ldrb.w	r0, [sp, #23]

  rawAccX = buffer[9] << 8 | buffer[8];
    417e:	f89d 1018 	ldrb.w	r1, [sp, #24]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    4182:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
  rawGyroZ = buffer[7] << 8 | buffer[6];
    4186:	ea43 2000 	orr.w	r0, r3, r0, lsl #8

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    418a:	f89d c01b 	ldrb.w	ip, [sp, #27]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    418e:	eec6 7a26 	vdiv.f32	s15, s12, s13

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    4192:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
  rawAccY = buffer[11] << 8 | buffer[10];
    4196:	f89d 201a 	ldrb.w	r2, [sp, #26]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    419a:	b22d      	sxth	r5, r5
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    419c:	f89d e01d 	ldrb.w	lr, [sp, #29]
  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    41a0:	b200      	sxth	r0, r0

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    41a2:	f89d 301c 	ldrb.w	r3, [sp, #28]
  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    41a6:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    41aa:	8167      	strh	r7, [r4, #10]

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    41ac:	b209      	sxth	r1, r1
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    41ae:	ea43 230e 	orr.w	r3, r3, lr, lsl #8

  float gyro_scale = 1; // range is in milli-dps per bit!
  switch (gyroRangeBuffered) {
    41b2:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    41b6:	b212      	sxth	r2, r2
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    41b8:	81a6      	strh	r6, [r4, #12]
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    41ba:	b21b      	sxth	r3, r3
    41bc:	2f0c      	cmp	r7, #12

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    41be:	81e5      	strh	r5, [r4, #14]
  rawGyroZ = buffer[7] << 8 | buffer[6];
    41c0:	8220      	strh	r0, [r4, #16]

  rawAccX = buffer[9] << 8 | buffer[8];
    41c2:	80a1      	strh	r1, [r4, #4]
  rawAccY = buffer[11] << 8 | buffer[10];
    41c4:	80e2      	strh	r2, [r4, #6]
  rawAccZ = buffer[13] << 8 | buffer[12];
    41c6:	8123      	strh	r3, [r4, #8]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    41c8:	ee77 7a87 	vadd.f32	s15, s15, s14
    41cc:	edc4 7a05 	vstr	s15, [r4, #20]
    41d0:	d860      	bhi.n	4294 <Adafruit_LSM6DS::_read()+0x184>
    41d2:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 42b0 <Adafruit_LSM6DS::_read()+0x1a0>
    41d6:	eb0e 0787 	add.w	r7, lr, r7, lsl #2
    41da:	edd7 7a00 	vldr	s15, [r7]
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    41de:	ee07 6a10 	vmov	s14, r6
    41e2:	ed9f 5a2f 	vldr	s10, [pc, #188]	; 42a0 <Adafruit_LSM6DS::_read()+0x190>
    41e6:	eddf 5a2f 	vldr	s11, [pc, #188]	; 42a4 <Adafruit_LSM6DS::_read()+0x194>
    41ea:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    41ee:	ee07 5a10 	vmov	s14, r5
    41f2:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    41f6:	ee07 0a10 	vmov	s14, r0
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    41fa:	ee26 6a27 	vmul.f32	s12, s12, s15
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;

  float accel_scale = 1; // range is in milli-g per bit!
  switch (accelRangeBuffered) {
    41fe:	f894 0050 	ldrb.w	r0, [r4, #80]	; 0x50
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4202:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4206:	ee66 6aa7 	vmul.f32	s13, s13, s15
    420a:	2803      	cmp	r0, #3
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    420c:	ee26 6a05 	vmul.f32	s12, s12, s10
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4210:	ee67 7a27 	vmul.f32	s15, s14, s15
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4214:	ee26 7a85 	vmul.f32	s14, s13, s10
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4218:	ee67 7a85 	vmul.f32	s15, s15, s10
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    421c:	eec7 6a25 	vdiv.f32	s13, s14, s11
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4220:	ee86 5a25 	vdiv.f32	s10, s12, s11
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4224:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4228:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    422c:	ed84 5a09 	vstr	s10, [r4, #36]	; 0x24
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    4230:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
    4234:	d831      	bhi.n	429a <Adafruit_LSM6DS::_read()+0x18a>
    4236:	4d1c      	ldr	r5, [pc, #112]	; (42a8 <Adafruit_LSM6DS::_read()+0x198>)
    4238:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    423c:	edd0 7a00 	vldr	s15, [r0]
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4240:	ee07 1a10 	vmov	s14, r1
    4244:	ed9f 5a19 	vldr	s10, [pc, #100]	; 42ac <Adafruit_LSM6DS::_read()+0x19c>
    4248:	eddf 5a16 	vldr	s11, [pc, #88]	; 42a4 <Adafruit_LSM6DS::_read()+0x194>
    424c:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4250:	ee07 2a10 	vmov	s14, r2
    4254:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4258:	ee07 3a10 	vmov	s14, r3
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    425c:	ee26 6a27 	vmul.f32	s12, s12, s15
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4260:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4264:	ee66 6aa7 	vmul.f32	s13, s13, s15
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4268:	ee26 6a05 	vmul.f32	s12, s12, s10
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    426c:	ee67 7a27 	vmul.f32	s15, s14, s15
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4270:	ee26 7a85 	vmul.f32	s14, s13, s10
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4274:	ee67 7a85 	vmul.f32	s15, s15, s10
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4278:	eec7 6a25 	vdiv.f32	s13, s14, s11
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    427c:	ee86 5a25 	vdiv.f32	s10, s12, s11
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4280:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4284:	edc4 6a07 	vstr	s13, [r4, #28]
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    4288:	ed84 5a06 	vstr	s10, [r4, #24]
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    428c:	ed84 7a08 	vstr	s14, [r4, #32]
}
    4290:	b00f      	add	sp, #60	; 0x3c
    4292:	bdf0      	pop	{r4, r5, r6, r7, pc}
  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];

  float gyro_scale = 1; // range is in milli-dps per bit!
  switch (gyroRangeBuffered) {
    4294:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    4298:	e7a1      	b.n	41de <Adafruit_LSM6DS::_read()+0xce>
  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;

  float accel_scale = 1; // range is in milli-g per bit!
  switch (accelRangeBuffered) {
    429a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    429e:	e7cf      	b.n	4240 <Adafruit_LSM6DS::_read()+0x130>
    42a0:	3c8efa35 	.word	0x3c8efa35
    42a4:	447a0000 	.word	0x447a0000
    42a8:	20000440 	.word	0x20000440
    42ac:	411ce80a 	.word	0x411ce80a
    42b0:	200003fc 	.word	0x200003fc

000042b4 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's gyroscope sensor
*/
/**************************************************************************/
void Adafruit_LSM6DS_Gyro::getSensor(sensor_t *sensor) {
    42b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    42b6:	460c      	mov	r4, r1
    42b8:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    42ba:	2228      	movs	r2, #40	; 0x28
    42bc:	2100      	movs	r1, #0
    42be:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    42c0:	2701      	movs	r7, #1
    @brief  Gets the sensor_t data for the LSM6DS's gyroscope sensor
*/
/**************************************************************************/
void Adafruit_LSM6DS_Gyro::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    42c2:	f002 fdf7 	bl	6eb4 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
    42c6:	220b      	movs	r2, #11
    42c8:	4909      	ldr	r1, [pc, #36]	; (42f0 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x3c>)
    42ca:	4620      	mov	r0, r4
    42cc:	f003 faa6 	bl	781c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    42d0:	2300      	movs	r3, #0
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
    42d2:	2504      	movs	r5, #4
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
    42d4:	4807      	ldr	r0, [pc, #28]	; (42f4 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    42d6:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
  sensor->max_value = +34.91;
    42d8:	4907      	ldr	r1, [pc, #28]	; (42f8 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    42da:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
  sensor->max_value = +34.91;
  sensor->resolution = 7.6358e-5; /* 4.375 mdps -> rad/s */
    42dc:	4a07      	ldr	r2, [pc, #28]	; (42fc <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x48>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    42de:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    42e0:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
    42e2:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
    42e4:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
    42e6:	61e0      	str	r0, [r4, #28]
  sensor->max_value = +34.91;
    42e8:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 7.6358e-5; /* 4.375 mdps -> rad/s */
    42ea:	6222      	str	r2, [r4, #32]
    42ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    42ee:	bf00      	nop
    42f0:	20000dfc 	.word	0x20000dfc
    42f4:	c20ba3d7 	.word	0xc20ba3d7
    42f8:	420ba3d7 	.word	0x420ba3d7
    42fc:	38a02264 	.word	0x38a02264

00004300 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's accelerometer
*/
/**************************************************************************/
void Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t *sensor) {
    4300:	b570      	push	{r4, r5, r6, lr}
    4302:	460c      	mov	r4, r1
    4304:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    4306:	2228      	movs	r2, #40	; 0x28
    4308:	2100      	movs	r1, #0
    430a:	4620      	mov	r0, r4
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
    430c:	4d0a      	ldr	r5, [pc, #40]	; (4338 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x38>)
    @brief  Gets the sensor_t data for the LSM6DS's accelerometer
*/
/**************************************************************************/
void Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    430e:	f002 fdd1 	bl	6eb4 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
    4312:	220b      	movs	r2, #11
    4314:	4909      	ldr	r1, [pc, #36]	; (433c <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x3c>)
    4316:	4620      	mov	r0, r4
    4318:	f003 fa80 	bl	781c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    431c:	2200      	movs	r2, #0
  sensor->version = 1;
    431e:	2301      	movs	r3, #1
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
    4320:	4807      	ldr	r0, [pc, #28]	; (4340 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    4322:	72e2      	strb	r2, [r4, #11]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
  sensor->resolution = 0.061;     /* 0.061 mg/LSB at +-2g */
    4324:	4907      	ldr	r1, [pc, #28]	; (4344 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    4326:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
    4328:	6262      	str	r2, [r4, #36]	; 0x24

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    432a:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
    432c:	61e5      	str	r5, [r4, #28]
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
    432e:	61a0      	str	r0, [r4, #24]
  sensor->resolution = 0.061;     /* 0.061 mg/LSB at +-2g */
    4330:	6221      	str	r1, [r4, #32]
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    4332:	60e3      	str	r3, [r4, #12]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
    4334:	6163      	str	r3, [r4, #20]
    4336:	bd70      	pop	{r4, r5, r6, pc}
    4338:	c31ce80a 	.word	0xc31ce80a
    433c:	20000e08 	.word	0x20000e08
    4340:	431ce80a 	.word	0x431ce80a
    4344:	3d79db23 	.word	0x3d79db23

00004348 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's tenperature
*/
/**************************************************************************/
void Adafruit_LSM6DS_Temp::getSensor(sensor_t *sensor) {
    4348:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    434a:	460c      	mov	r4, r1
    434c:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    434e:	2228      	movs	r2, #40	; 0x28
    4350:	2100      	movs	r1, #0
    4352:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    4354:	2701      	movs	r7, #1
    @brief  Gets the sensor_t data for the LSM6DS's tenperature
*/
/**************************************************************************/
void Adafruit_LSM6DS_Temp::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    4356:	f002 fdad 	bl	6eb4 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
    435a:	220b      	movs	r2, #11
    435c:	4909      	ldr	r1, [pc, #36]	; (4384 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x3c>)
    435e:	4620      	mov	r0, r4
    4360:	f003 fa5c 	bl	781c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    4364:	2300      	movs	r3, #0
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
  sensor->max_value = 85;
  sensor->resolution = 1; /* not a great sensor */
    4366:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    436a:	250d      	movs	r5, #13
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    436c:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
    436e:	4806      	ldr	r0, [pc, #24]	; (4388 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x40>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    4370:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
  sensor->max_value = 85;
    4372:	4906      	ldr	r1, [pc, #24]	; (438c <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x44>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    4374:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    4376:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
    4378:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    437a:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -40;
    437c:	61e0      	str	r0, [r4, #28]
  sensor->max_value = 85;
    437e:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 1; /* not a great sensor */
    4380:	6222      	str	r2, [r4, #32]
    4382:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4384:	20000e14 	.word	0x20000e14
    4388:	c2200000 	.word	0xc2200000
    438c:	42aa0000 	.word	0x42aa0000

00004390 <Adafruit_LSM6DS::Adafruit_LSM6DS()>:
};

/*!
 *    @brief  Instantiates a new LSM6DS class
 */
Adafruit_LSM6DS::Adafruit_LSM6DS(void) {}
    4390:	2200      	movs	r2, #0
    4392:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
    4396:	b410      	push	{r4}
    4398:	4c07      	ldr	r4, [pc, #28]	; (43b8 <Adafruit_LSM6DS::Adafruit_LSM6DS()+0x28>)
    439a:	6401      	str	r1, [r0, #64]	; 0x40
    439c:	6004      	str	r4, [r0, #0]
    439e:	6382      	str	r2, [r0, #56]	; 0x38
    43a0:	63c2      	str	r2, [r0, #60]	; 0x3c
    43a2:	6442      	str	r2, [r0, #68]	; 0x44
    43a4:	6482      	str	r2, [r0, #72]	; 0x48
    43a6:	64c2      	str	r2, [r0, #76]	; 0x4c
    43a8:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
    43ac:	f880 2051 	strb.w	r2, [r0, #81]	; 0x51
    43b0:	f85d 4b04 	ldr.w	r4, [sp], #4
    43b4:	4770      	bx	lr
    43b6:	bf00      	nop
    43b8:	20000458 	.word	0x20000458

000043bc <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)>:
 *    @param  sensor_id
 *            The user-defined ID to differentiate different sensors
 *    @return True if initialization was successful, otherwise false.
 */
boolean Adafruit_LSM6DS::begin_I2C(uint8_t i2c_address, TwoWire *wire,
                                   int32_t sensor_id) {
    43bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    43c0:	4604      	mov	r4, r0
    43c2:	460e      	mov	r6, r1
  delete i2c_dev; // remove old interface
    43c4:	6b80      	ldr	r0, [r0, #56]	; 0x38
    43c6:	2110      	movs	r1, #16
 *    @param  sensor_id
 *            The user-defined ID to differentiate different sensors
 *    @return True if initialization was successful, otherwise false.
 */
boolean Adafruit_LSM6DS::begin_I2C(uint8_t i2c_address, TwoWire *wire,
                                   int32_t sensor_id) {
    43c8:	4617      	mov	r7, r2
    43ca:	4698      	mov	r8, r3
  delete i2c_dev; // remove old interface
    43cc:	f7fe fec8 	bl	3160 <operator delete(void*, unsigned int)>

  i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
    43d0:	2010      	movs	r0, #16
    43d2:	f7fe fec1 	bl	3158 <operator new(unsigned int)>
    43d6:	4605      	mov	r5, r0
    43d8:	4631      	mov	r1, r6
    43da:	463a      	mov	r2, r7
    43dc:	f7ff f88a 	bl	34f4 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    43e0:	63a5      	str	r5, [r4, #56]	; 0x38

  if (!i2c_dev->begin()) {
    43e2:	4628      	mov	r0, r5
    43e4:	2101      	movs	r1, #1
    43e6:	f7ff f8ab 	bl	3540 <Adafruit_I2CDevice::begin(bool)>
    43ea:	b908      	cbnz	r0, 43f0 <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)+0x34>
    return false;
  }

  return _init(sensor_id);
}
    43ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if (!i2c_dev->begin()) {
    return false;
  }

  return _init(sensor_id);
    43f0:	6823      	ldr	r3, [r4, #0]
    43f2:	4641      	mov	r1, r8
    43f4:	4620      	mov	r0, r4
    43f6:	68db      	ldr	r3, [r3, #12]
}
    43f8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  if (!i2c_dev->begin()) {
    return false;
  }

  return _init(sensor_id);
    43fc:	4718      	bx	r3
    43fe:	bf00      	nop

00004400 <Adafruit_LSM6DS::reset()>:
/**************************************************************************/
/*!
    @brief Resets the sensor to its power-on state, clearing all registers and
   memory
*/
void Adafruit_LSM6DS::reset(void) {
    4400:	b570      	push	{r4, r5, r6, lr}

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    4402:	2401      	movs	r4, #1
/**************************************************************************/
/*!
    @brief Resets the sensor to its power-on state, clearing all registers and
   memory
*/
void Adafruit_LSM6DS::reset(void) {
    4404:	b08c      	sub	sp, #48	; 0x30

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    4406:	2500      	movs	r5, #0
    4408:	2612      	movs	r6, #18
    440a:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    440c:	6b81      	ldr	r1, [r0, #56]	; 0x38
    440e:	462b      	mov	r3, r5
    4410:	a806      	add	r0, sp, #24
    4412:	9403      	str	r4, [sp, #12]
    4414:	9401      	str	r4, [sp, #4]
    4416:	9502      	str	r5, [sp, #8]
    4418:	9600      	str	r6, [sp, #0]
    441a:	f7fe ff2f 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits sw_reset =
      Adafruit_BusIO_RegisterBits(&ctrl3, 1, 0);
    441e:	a906      	add	r1, sp, #24
    4420:	462b      	mov	r3, r5
    4422:	4622      	mov	r2, r4
    4424:	a804      	add	r0, sp, #16
    4426:	f7ff f825 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  // Adafruit_BusIO_RegisterBits boot = Adafruit_BusIO_RegisterBits(&ctrl3, 1,
  // 7);

  sw_reset.write(true);
    442a:	4621      	mov	r1, r4
    442c:	a804      	add	r0, sp, #16
    442e:	f7ff f837 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
    4432:	e002      	b.n	443a <Adafruit_LSM6DS::reset()+0x3a>

  while (sw_reset.read()) {
    delay(1);
    4434:	2001      	movs	r0, #1
    4436:	f7fd f9b7 	bl	17a8 <delay>
  // Adafruit_BusIO_RegisterBits boot = Adafruit_BusIO_RegisterBits(&ctrl3, 1,
  // 7);

  sw_reset.write(true);

  while (sw_reset.read()) {
    443a:	a804      	add	r0, sp, #16
    443c:	f7ff f822 	bl	3484 <Adafruit_BusIO_RegisterBits::read()>
    4440:	2800      	cmp	r0, #0
    4442:	d1f7      	bne.n	4434 <Adafruit_LSM6DS::reset()+0x34>
    delay(1);
  }
}
    4444:	b00c      	add	sp, #48	; 0x30
    4446:	bd70      	pop	{r4, r5, r6, pc}

00004448 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>:
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    4448:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    444a:	2301      	movs	r3, #1
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    444c:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    444e:	6b87      	ldr	r7, [r0, #56]	; 0x38
    4450:	2610      	movs	r6, #16
    4452:	2400      	movs	r4, #0
    4454:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    4456:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    4458:	9303      	str	r3, [sp, #12]
    445a:	4639      	mov	r1, r7
    445c:	9301      	str	r3, [sp, #4]
    445e:	a806      	add	r0, sp, #24
    4460:	4623      	mov	r3, r4
    4462:	9402      	str	r4, [sp, #8]
    4464:	9600      	str	r6, [sp, #0]
    4466:	f7fe ff09 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits accel_data_rate =
      Adafruit_BusIO_RegisterBits(&ctrl1, 4, 4);
    446a:	2304      	movs	r3, #4
    446c:	a906      	add	r1, sp, #24
    446e:	eb0d 0006 	add.w	r0, sp, r6
    4472:	461a      	mov	r2, r3
    4474:	f7fe fffe 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  accel_data_rate.write(data_rate);
    4478:	4629      	mov	r1, r5
    447a:	eb0d 0006 	add.w	r0, sp, r6
    447e:	f7ff f80f 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    4482:	b00d      	add	sp, #52	; 0x34
    4484:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4486:	bf00      	nop

00004488 <Adafruit_LSM6DS::setAccelRange(accel_range)>:
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    4488:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    448a:	2301      	movs	r3, #1
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    448c:	b08d      	sub	sp, #52	; 0x34
    448e:	4604      	mov	r4, r0

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    4490:	2710      	movs	r7, #16
    4492:	2600      	movs	r6, #0
    4494:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    4496:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    4498:	a806      	add	r0, sp, #24
    449a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    449c:	9303      	str	r3, [sp, #12]
    449e:	9301      	str	r3, [sp, #4]
    44a0:	4633      	mov	r3, r6
    44a2:	9602      	str	r6, [sp, #8]
    44a4:	9700      	str	r7, [sp, #0]
    44a6:	f7fe fee9 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits accel_range =
      Adafruit_BusIO_RegisterBits(&ctrl1, 2, 2);
    44aa:	2302      	movs	r3, #2
    44ac:	a906      	add	r1, sp, #24
    44ae:	eb0d 0007 	add.w	r0, sp, r7
    44b2:	461a      	mov	r2, r3
    44b4:	f7fe ffde 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  accel_range.write(new_range);
    44b8:	4629      	mov	r1, r5
    44ba:	eb0d 0007 	add.w	r0, sp, r7
    44be:	f7fe ffef 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  accelRangeBuffered = new_range;
    44c2:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
}
    44c6:	b00d      	add	sp, #52	; 0x34
    44c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    44ca:	bf00      	nop

000044cc <Adafruit_LSM6DS::setGyroDataRate(data_rate)>:
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    44cc:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    44ce:	2301      	movs	r3, #1
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    44d0:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    44d2:	6b87      	ldr	r7, [r0, #56]	; 0x38
    44d4:	2400      	movs	r4, #0
    44d6:	2611      	movs	r6, #17
    44d8:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    44da:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    44dc:	9303      	str	r3, [sp, #12]
    44de:	4639      	mov	r1, r7
    44e0:	9301      	str	r3, [sp, #4]
    44e2:	a806      	add	r0, sp, #24
    44e4:	4623      	mov	r3, r4
    44e6:	9402      	str	r4, [sp, #8]
    44e8:	9600      	str	r6, [sp, #0]
    44ea:	f7fe fec7 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits gyro_data_rate =
      Adafruit_BusIO_RegisterBits(&ctrl2, 4, 4);
    44ee:	2304      	movs	r3, #4
    44f0:	a906      	add	r1, sp, #24
    44f2:	a804      	add	r0, sp, #16
    44f4:	461a      	mov	r2, r3
    44f6:	f7fe ffbd 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  gyro_data_rate.write(data_rate);
    44fa:	4629      	mov	r1, r5
    44fc:	a804      	add	r0, sp, #16
    44fe:	f7fe ffcf 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    4502:	b00d      	add	sp, #52	; 0x34
    4504:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4506:	bf00      	nop

00004508 <Adafruit_LSM6DS::setGyroRange(gyro_range)>:
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    4508:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    450a:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    450c:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    450e:	2500      	movs	r5, #0
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    4510:	4604      	mov	r4, r0

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    4512:	2301      	movs	r3, #1
    4514:	6b80      	ldr	r0, [r0, #56]	; 0x38
    4516:	2711      	movs	r7, #17
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    4518:	460e      	mov	r6, r1

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    451a:	9303      	str	r3, [sp, #12]
    451c:	4601      	mov	r1, r0
    451e:	9301      	str	r3, [sp, #4]
    4520:	a806      	add	r0, sp, #24
    4522:	462b      	mov	r3, r5
    4524:	9502      	str	r5, [sp, #8]
    4526:	9700      	str	r7, [sp, #0]
    4528:	f7fe fea8 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits gyro_range =
      Adafruit_BusIO_RegisterBits(&ctrl2, 4, 0);
    452c:	462b      	mov	r3, r5
    452e:	a906      	add	r1, sp, #24
    4530:	2204      	movs	r2, #4
    4532:	a804      	add	r0, sp, #16
    4534:	f7fe ff9e 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  gyro_range.write(new_range);
    4538:	4631      	mov	r1, r6
    453a:	a804      	add	r0, sp, #16
    453c:	f7fe ffb0 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  gyroRangeBuffered = new_range;
    4540:	f884 6051 	strb.w	r6, [r4, #81]	; 0x51
}
    4544:	b00d      	add	sp, #52	; 0x34
    4546:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004548 <Adafruit_LSM6DS::_init(long)>:

/*!  @brief  Unique subclass initializer post i2c/spi init
 *   @param sensor_id Optional unique ID for the sensor set
 *   @returns True if chip identified and initialized
 */
bool Adafruit_LSM6DS::_init(int32_t sensor_id) {
    4548:	b510      	push	{r4, lr}
    454a:	4604      	mov	r4, r0
  (void)sensor_id;

  // Enable accelerometer with 104 Hz data rate, 4G
  setAccelDataRate(LSM6DS_RATE_104_HZ);
    454c:	2104      	movs	r1, #4
    454e:	f7ff ff7b 	bl	4448 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>
  setAccelRange(LSM6DS_ACCEL_RANGE_4_G);
    4552:	2102      	movs	r1, #2
    4554:	4620      	mov	r0, r4
    4556:	f7ff ff97 	bl	4488 <Adafruit_LSM6DS::setAccelRange(accel_range)>

  // Enable gyro with 104 Hz data rate, 2000 dps
  setGyroDataRate(LSM6DS_RATE_104_HZ);
    455a:	4620      	mov	r0, r4
    455c:	2104      	movs	r1, #4
    455e:	f7ff ffb5 	bl	44cc <Adafruit_LSM6DS::setGyroDataRate(data_rate)>
  setGyroRange(LSM6DS_GYRO_RANGE_2000_DPS);
    4562:	4620      	mov	r0, r4
    4564:	210c      	movs	r1, #12
    4566:	f7ff ffcf 	bl	4508 <Adafruit_LSM6DS::setGyroRange(gyro_range)>

  delay(10);
    456a:	200a      	movs	r0, #10
    456c:	f7fd f91c 	bl	17a8 <delay>

  // delete objects if sensor is reinitialized
  delete temp_sensor;
    4570:	6c60      	ldr	r0, [r4, #68]	; 0x44
    4572:	b110      	cbz	r0, 457a <Adafruit_LSM6DS::_init(long)+0x32>
    4574:	6803      	ldr	r3, [r0, #0]
    4576:	685b      	ldr	r3, [r3, #4]
    4578:	4798      	blx	r3
  delete accel_sensor;
    457a:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    457c:	b110      	cbz	r0, 4584 <Adafruit_LSM6DS::_init(long)+0x3c>
    457e:	6803      	ldr	r3, [r0, #0]
    4580:	685b      	ldr	r3, [r3, #4]
    4582:	4798      	blx	r3
  delete gyro_sensor;
    4584:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    4586:	b110      	cbz	r0, 458e <Adafruit_LSM6DS::_init(long)+0x46>
    4588:	6803      	ldr	r3, [r0, #0]
    458a:	685b      	ldr	r3, [r3, #4]
    458c:	4798      	blx	r3

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
    458e:	2010      	movs	r0, #16
    4590:	f7fe fde2 	bl	3158 <operator new(unsigned int)>
/** Adafruit Unified Sensor interface for temperature component of LSM6DS */
class Adafruit_LSM6DS_Temp : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the temp sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Temp(Adafruit_LSM6DS *parent) { _theLSM6DS = parent; }
    4594:	490f      	ldr	r1, [pc, #60]	; (45d4 <Adafruit_LSM6DS::_init(long)+0x8c>)
    4596:	4603      	mov	r3, r0
    4598:	f44f 62da 	mov.w	r2, #1744	; 0x6d0
    459c:	6460      	str	r0, [r4, #68]	; 0x44
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
    459e:	2010      	movs	r0, #16
    45a0:	60dc      	str	r4, [r3, #12]
    45a2:	6019      	str	r1, [r3, #0]
    45a4:	609a      	str	r2, [r3, #8]
    45a6:	f7fe fdd7 	bl	3158 <operator new(unsigned int)>
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the accelerometer
     sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Accelerometer(Adafruit_LSM6DS *parent) {
    45aa:	490b      	ldr	r1, [pc, #44]	; (45d8 <Adafruit_LSM6DS::_init(long)+0x90>)
    45ac:	4603      	mov	r3, r0
    45ae:	f240 62d1 	movw	r2, #1745	; 0x6d1
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    45b2:	2010      	movs	r0, #16
  delete temp_sensor;
  delete accel_sensor;
  delete gyro_sensor;

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
    45b4:	64a3      	str	r3, [r4, #72]	; 0x48
    _theLSM6DS = parent;
    45b6:	60dc      	str	r4, [r3, #12]
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the accelerometer
     sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Accelerometer(Adafruit_LSM6DS *parent) {
    45b8:	6019      	str	r1, [r3, #0]
    45ba:	609a      	str	r2, [r3, #8]
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    45bc:	f7fe fdcc 	bl	3158 <operator new(unsigned int)>
/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the gyro sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Gyro(Adafruit_LSM6DS *parent) { _theLSM6DS = parent; }
    45c0:	4906      	ldr	r1, [pc, #24]	; (45dc <Adafruit_LSM6DS::_init(long)+0x94>)
    45c2:	4603      	mov	r3, r0
    45c4:	f240 62d2 	movw	r2, #1746	; 0x6d2

  return false;
};
    45c8:	2000      	movs	r0, #0
    45ca:	60dc      	str	r4, [r3, #12]
  delete accel_sensor;
  delete gyro_sensor;

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    45cc:	64e3      	str	r3, [r4, #76]	; 0x4c
    45ce:	6019      	str	r1, [r3, #0]
    45d0:	609a      	str	r2, [r3, #8]

  return false;
};
    45d2:	bd10      	pop	{r4, pc}
    45d4:	20000510 	.word	0x20000510
    45d8:	2000052c 	.word	0x2000052c
    45dc:	200004f4 	.word	0x200004f4

000045e0 <Adafruit_LSM6DS::configIntOutputs(bool, bool)>:
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    45e0:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    45e2:	f8d0 c03c 	ldr.w	ip, [r0, #60]	; 0x3c
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    45e6:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    45e8:	f8d0 e038 	ldr.w	lr, [r0, #56]	; 0x38
    45ec:	2401      	movs	r4, #1
    45ee:	2300      	movs	r3, #0
    45f0:	2712      	movs	r7, #18
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    45f2:	460e      	mov	r6, r1
    45f4:	4615      	mov	r5, r2

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    45f6:	4671      	mov	r1, lr
    45f8:	4662      	mov	r2, ip
    45fa:	9302      	str	r3, [sp, #8]
    45fc:	a806      	add	r0, sp, #24
    45fe:	9403      	str	r4, [sp, #12]
    4600:	9401      	str	r4, [sp, #4]
    4602:	9700      	str	r7, [sp, #0]
    4604:	f7fe fe3a 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits ppod_bits =
      Adafruit_BusIO_RegisterBits(&ctrl3, 2, 4);
    4608:	a906      	add	r1, sp, #24
    460a:	2304      	movs	r3, #4
    460c:	2202      	movs	r2, #2
    460e:	a804      	add	r0, sp, #16
    4610:	f7fe ff30 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  ppod_bits.write((active_low << 1) | open_drain);
    4614:	a804      	add	r0, sp, #16
    4616:	ea45 0146 	orr.w	r1, r5, r6, lsl #1
    461a:	f7fe ff41 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    461e:	b00d      	add	sp, #52	; 0x34
    4620:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4622:	bf00      	nop

00004624 <Adafruit_LSM6DS::configInt1(bool, bool, bool, bool, bool)>:
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    4624:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4628:	4692      	mov	sl, r2
    462a:	461e      	mov	r6, r3
    462c:	b093      	sub	sp, #76	; 0x4c

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    462e:	2401      	movs	r4, #1
    4630:	2500      	movs	r5, #0
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    4632:	4680      	mov	r8, r0

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    4634:	270d      	movs	r7, #13
    4636:	6b80      	ldr	r0, [r0, #56]	; 0x38
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    4638:	4689      	mov	r9, r1

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    463a:	ea46 064a 	orr.w	r6, r6, sl, lsl #1
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    463e:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
    4642:	462b      	mov	r3, r5
    4644:	4601      	mov	r1, r0
    4646:	9700      	str	r7, [sp, #0]
    4648:	a806      	add	r0, sp, #24
    464a:	9403      	str	r4, [sp, #12]
    464c:	9401      	str	r4, [sp, #4]
    464e:	9502      	str	r5, [sp, #8]
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    4650:	f89d b070 	ldrb.w	fp, [sp, #112]	; 0x70
    4654:	f89d 7074 	ldrb.w	r7, [sp, #116]	; 0x74

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    4658:	f7fe fe10 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    465c:	ea46 0189 	orr.w	r1, r6, r9, lsl #2

  Adafruit_BusIO_Register md1cfg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_MD1_CFG);
    4660:	265e      	movs	r6, #94	; 0x5e

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    4662:	462a      	mov	r2, r5
    4664:	a806      	add	r0, sp, #24
    4666:	ea41 11cb 	orr.w	r1, r1, fp, lsl #7
    466a:	f7fe fe6b 	bl	3344 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>

  Adafruit_BusIO_Register md1cfg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_MD1_CFG);
    466e:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
    4672:	f8d8 1038 	ldr.w	r1, [r8, #56]	; 0x38
    4676:	462b      	mov	r3, r5
    4678:	9403      	str	r4, [sp, #12]
    467a:	a80c      	add	r0, sp, #48	; 0x30
    467c:	9502      	str	r5, [sp, #8]
    467e:	9401      	str	r4, [sp, #4]
    4680:	9600      	str	r6, [sp, #0]
    4682:	f7fe fdfb 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits wu = Adafruit_BusIO_RegisterBits(&md1cfg, 1, 5);
    4686:	4622      	mov	r2, r4
    4688:	a90c      	add	r1, sp, #48	; 0x30
    468a:	2305      	movs	r3, #5
    468c:	a804      	add	r0, sp, #16
    468e:	f7fe fef1 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  wu.write(wakeup);
    4692:	4639      	mov	r1, r7
    4694:	a804      	add	r0, sp, #16
    4696:	f7fe ff03 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    469a:	b013      	add	sp, #76	; 0x4c
    469c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000046a0 <Adafruit_LSM6DS::configInt2(bool, bool, bool)>:
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    46a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    46a4:	f8d0 c03c 	ldr.w	ip, [r0, #60]	; 0x3c
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    46a8:	b08c      	sub	sp, #48	; 0x30

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    46aa:	6b80      	ldr	r0, [r0, #56]	; 0x38
    46ac:	f04f 0e0e 	mov.w	lr, #14
    46b0:	2500      	movs	r5, #0
    46b2:	2601      	movs	r6, #1
    46b4:	f8cd e000 	str.w	lr, [sp]
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    46b8:	460f      	mov	r7, r1
    46ba:	4690      	mov	r8, r2
    46bc:	461c      	mov	r4, r3

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    46be:	4662      	mov	r2, ip
    46c0:	4601      	mov	r1, r0
    46c2:	462b      	mov	r3, r5
    46c4:	a806      	add	r0, sp, #24
    46c6:	9603      	str	r6, [sp, #12]
    46c8:	9601      	str	r6, [sp, #4]
    46ca:	9502      	str	r5, [sp, #8]
    46cc:	f7fe fdd6 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits int2_drdy_bits =
      Adafruit_BusIO_RegisterBits(&int2_ctrl, 3, 0);
    46d0:	462b      	mov	r3, r5
    46d2:	a906      	add	r1, sp, #24
    46d4:	2203      	movs	r2, #3
    46d6:	a804      	add	r0, sp, #16
    46d8:	f7fe fecc 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  int2_drdy_bits.write((drdy_temp << 2) | (drdy_g << 1) | drdy_xl);
    46dc:	a804      	add	r0, sp, #16
    46de:	ea44 0148 	orr.w	r1, r4, r8, lsl #1
    46e2:	ea41 0187 	orr.w	r1, r1, r7, lsl #2
    46e6:	f7fe fedb 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    46ea:	b00c      	add	sp, #48	; 0x30
    46ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000046f0 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    46f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    46f4:	f04f 0c28 	mov.w	ip, #40	; 0x28
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    46f8:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    46fa:	f8d0 903c 	ldr.w	r9, [r0, #60]	; 0x3c
    46fe:	f04f 0e00 	mov.w	lr, #0
    4702:	6b80      	ldr	r0, [r0, #56]	; 0x38
    4704:	f04f 0806 	mov.w	r8, #6
    4708:	2401      	movs	r4, #1
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    470a:	460f      	mov	r7, r1
    470c:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    470e:	4601      	mov	r1, r0
    4710:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    4712:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    4714:	a806      	add	r0, sp, #24
    4716:	9403      	str	r4, [sp, #12]
    4718:	4673      	mov	r3, lr
    471a:	f8cd e008 	str.w	lr, [sp, #8]
    471e:	f8cd 8004 	str.w	r8, [sp, #4]
    4722:	f8cd c000 	str.w	ip, [sp]
    4726:	f7fe fda9 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!accel_data.read((uint8_t *)data, sizeof(data))) {
    472a:	4642      	mov	r2, r8
    472c:	a806      	add	r0, sp, #24
    472e:	a904      	add	r1, sp, #16
    4730:	f7fe fe28 	bl	3384 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    4734:	b388      	cbz	r0, 479a <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xaa>
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4736:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    473a:	eeb1 4b00 	vmov.f64	d4, #16	; 0x40800000  4.0
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;

  return 1;
    473e:	4620      	mov	r0, r4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4740:	ee05 3a10 	vmov	s10, r3
  y = data[1] * 4.0 / 32768.0;
    4744:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    4748:	ee06 3a10 	vmov	s12, r3
  z = data[2] * 4.0 / 32768.0;
    474c:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4750:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;
    4754:	ee07 3a10 	vmov	s14, r3
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
  y = data[1] * 4.0 / 32768.0;
    4758:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
  z = data[2] * 4.0 / 32768.0;
    475c:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4760:	ee25 5b04 	vmul.f64	d5, d5, d4
  y = data[1] * 4.0 / 32768.0;
    4764:	ee26 6b04 	vmul.f64	d6, d6, d4
  z = data[2] * 4.0 / 32768.0;
    4768:	ee27 7b04 	vmul.f64	d7, d7, d4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    476c:	ed9f 4b0e 	vldr	d4, [pc, #56]	; 47a8 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xb8>
    4770:	ee25 5b04 	vmul.f64	d5, d5, d4
  y = data[1] * 4.0 / 32768.0;
    4774:	ee26 6b04 	vmul.f64	d6, d6, d4
  z = data[2] * 4.0 / 32768.0;
    4778:	ee27 7b04 	vmul.f64	d7, d7, d4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    477c:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
  y = data[1] * 4.0 / 32768.0;
    4780:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 4.0 / 32768.0;
    4784:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4  4
  x = data[0] * 4.0 / 32768.0;
    4788:	ed87 5a00 	vstr	s10, [r7]
  y = data[1] * 4.0 / 32768.0;
    478c:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 4.0 / 32768.0;
    4790:	ed85 7a00 	vstr	s14, [r5]

  return 1;
}
    4794:	b00d      	add	sp, #52	; 0x34
    4796:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);

  if (!accel_data.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    479a:	4b05      	ldr	r3, [pc, #20]	; (47b0 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xc0>)
    479c:	602b      	str	r3, [r5, #0]
    479e:	6033      	str	r3, [r6, #0]
    47a0:	603b      	str	r3, [r7, #0]
  x = data[0] * 4.0 / 32768.0;
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;

  return 1;
}
    47a2:	b00d      	add	sp, #52	; 0x34
    47a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    47a8:	00000000 	.word	0x00000000
    47ac:	3f000000 	.word	0x3f000000
    47b0:	7fc00000 	.word	0x7fc00000
    47b4:	00000000 	.word	0x00000000

000047b8 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    47b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    47bc:	f04f 0c22 	mov.w	ip, #34	; 0x22
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    47c0:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    47c2:	f8d0 903c 	ldr.w	r9, [r0, #60]	; 0x3c
    47c6:	f04f 0e00 	mov.w	lr, #0
    47ca:	6b80      	ldr	r0, [r0, #56]	; 0x38
    47cc:	f04f 0806 	mov.w	r8, #6
    47d0:	2401      	movs	r4, #1
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    47d2:	460f      	mov	r7, r1
    47d4:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    47d6:	4601      	mov	r1, r0
    47d8:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    47da:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    47dc:	a806      	add	r0, sp, #24
    47de:	9403      	str	r4, [sp, #12]
    47e0:	4673      	mov	r3, lr
    47e2:	f8cd e008 	str.w	lr, [sp, #8]
    47e6:	f8cd 8004 	str.w	r8, [sp, #4]
    47ea:	f8cd c000 	str.w	ip, [sp]
    47ee:	f7fe fd45 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!gyro_data.read((uint8_t *)data, sizeof(data))) {
    47f2:	4642      	mov	r2, r8
    47f4:	a806      	add	r0, sp, #24
    47f6:	a904      	add	r1, sp, #16
    47f8:	f7fe fdc4 	bl	3384 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    47fc:	b388      	cbz	r0, 4862 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xaa>
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    47fe:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;

  return 1;
    4802:	4620      	mov	r0, r4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    4804:	ee04 3a10 	vmov	s8, r3
  y = data[1] * 2000.0 / 32768.0;
    4808:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    480c:	ee05 3a10 	vmov	s10, r3
  z = data[2] * 2000.0 / 32768.0;
    4810:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    4814:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;
    4818:	ee07 3a10 	vmov	s14, r3
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
  y = data[1] * 2000.0 / 32768.0;
    481c:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  z = data[2] * 2000.0 / 32768.0;
    4820:	eeb8 6bc7 	vcvt.f64.s32	d6, s14
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    4824:	ed9f 7b12 	vldr	d7, [pc, #72]	; 4870 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xb8>
    4828:	ed9f 3b13 	vldr	d3, [pc, #76]	; 4878 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xc0>
  y = data[1] * 2000.0 / 32768.0;
    482c:	ee25 5b07 	vmul.f64	d5, d5, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    4830:	ee24 4b07 	vmul.f64	d4, d4, d7
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;
    4834:	ee26 7b07 	vmul.f64	d7, d6, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    4838:	ee24 4b03 	vmul.f64	d4, d4, d3
  y = data[1] * 2000.0 / 32768.0;
    483c:	ee25 6b03 	vmul.f64	d6, d5, d3
  z = data[2] * 2000.0 / 32768.0;
    4840:	ee27 7b03 	vmul.f64	d7, d7, d3
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    4844:	eeb7 4bc4 	vcvt.f32.f64	s8, d4
  y = data[1] * 2000.0 / 32768.0;
    4848:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 2000.0 / 32768.0;
    484c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000  2000
  x = data[0] * 2000.0 / 32768.0;
    4850:	ed87 4a00 	vstr	s8, [r7]
  y = data[1] * 2000.0 / 32768.0;
    4854:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 2000.0 / 32768.0;
    4858:	ed85 7a00 	vstr	s14, [r5]

  return 1;
}
    485c:	b00d      	add	sp, #52	; 0x34
    485e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);

  if (!gyro_data.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    4862:	4b07      	ldr	r3, [pc, #28]	; (4880 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xc8>)
    4864:	602b      	str	r3, [r5, #0]
    4866:	6033      	str	r3, [r6, #0]
    4868:	603b      	str	r3, [r7, #0]
  x = data[0] * 2000.0 / 32768.0;
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;

  return 1;
}
    486a:	b00d      	add	sp, #52	; 0x34
    486c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4870:	00000000 	.word	0x00000000
    4874:	409f4000 	.word	0x409f4000
    4878:	00000000 	.word	0x00000000
    487c:	3f000000 	.word	0x3f000000
    4880:	7fc00000 	.word	0x7fc00000

00004884 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()>:

/*!
 *    @brief  Class that stores state and functions for interacting with
 *            the LSM6DSOX I2C Digital Potentiometer
 */
class Adafruit_LSM6DSOX : public Adafruit_LSM6DS {
    4884:	4b03      	ldr	r3, [pc, #12]	; (4894 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()+0x10>)
    4886:	b510      	push	{r4, lr}
    4888:	4604      	mov	r4, r0
    488a:	6003      	str	r3, [r0, #0]
    488c:	f7ff fba6 	bl	3fdc <Adafruit_LSM6DS::~Adafruit_LSM6DS()>
    4890:	4620      	mov	r0, r4
    4892:	bd10      	pop	{r4, pc}
    4894:	200004b0 	.word	0x200004b0

00004898 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()>:
    4898:	4b05      	ldr	r3, [pc, #20]	; (48b0 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()+0x18>)
    489a:	b510      	push	{r4, lr}
    489c:	4604      	mov	r4, r0
    489e:	6003      	str	r3, [r0, #0]
    48a0:	f7ff fb9c 	bl	3fdc <Adafruit_LSM6DS::~Adafruit_LSM6DS()>
    48a4:	2154      	movs	r1, #84	; 0x54
    48a6:	4620      	mov	r0, r4
    48a8:	f7fe fc5a 	bl	3160 <operator delete(void*, unsigned int)>
    48ac:	4620      	mov	r0, r4
    48ae:	bd10      	pop	{r4, pc}
    48b0:	200004b0 	.word	0x200004b0

000048b4 <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()>:
#include "Adafruit_LSM6DSOX.h"

/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}
    48b4:	b510      	push	{r4, lr}
    48b6:	4604      	mov	r4, r0
    48b8:	f7ff fd6a 	bl	4390 <Adafruit_LSM6DS::Adafruit_LSM6DS()>
    48bc:	4b01      	ldr	r3, [pc, #4]	; (48c4 <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()+0x10>)
    48be:	4620      	mov	r0, r4
    48c0:	6023      	str	r3, [r4, #0]
    48c2:	bd10      	pop	{r4, pc}
    48c4:	200004b0 	.word	0x200004b0

000048c8 <Adafruit_LSM6DSOX::_init(long)>:

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    48c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    48cc:	6b83      	ldr	r3, [r0, #56]	; 0x38
/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    48ce:	b09a      	sub	sp, #104	; 0x68
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    48d0:	2501      	movs	r5, #1
    48d2:	2400      	movs	r4, #0
    48d4:	270f      	movs	r7, #15
    48d6:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    48d8:	4606      	mov	r6, r0
    48da:	4688      	mov	r8, r1
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    48dc:	a808      	add	r0, sp, #32
    48de:	4619      	mov	r1, r3
    48e0:	9503      	str	r5, [sp, #12]
    48e2:	4623      	mov	r3, r4
    48e4:	9501      	str	r5, [sp, #4]
    48e6:	9402      	str	r4, [sp, #8]
    48e8:	9700      	str	r7, [sp, #0]
    48ea:	f7fe fcc7 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    48ee:	a808      	add	r0, sp, #32
    48f0:	f7fe fd96 	bl	3420 <Adafruit_BusIO_Register::read()>
    48f4:	286c      	cmp	r0, #108	; 0x6c
    48f6:	d003      	beq.n	4900 <Adafruit_LSM6DSOX::_init(long)+0x38>
    return false;
    48f8:	4620      	mov	r0, r4

  // call base class _init()
  Adafruit_LSM6DS::_init(sensor_id);

  return true;
}
    48fa:	b01a      	add	sp, #104	; 0x68
    48fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
    4900:	fa1f f388 	uxth.w	r3, r8
  _sensorid_gyro = sensor_id + 1;
  _sensorid_temp = sensor_id + 2;

  reset();
    4904:	4630      	mov	r0, r6
  Adafruit_BusIO_RegisterBits bdu = Adafruit_BusIO_RegisterBits(&ctrl3, 1, 6);
  bdu.write(true);

  // Disable I3C
  Adafruit_BusIO_Register ctrl_9 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL9_XL);
    4906:	2718      	movs	r7, #24
  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
  _sensorid_gyro = sensor_id + 1;
    4908:	1959      	adds	r1, r3, r5
  _sensorid_temp = sensor_id + 2;
    490a:	1c9a      	adds	r2, r3, #2

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
    490c:	8633      	strh	r3, [r6, #48]	; 0x30
  _sensorid_gyro = sensor_id + 1;
    490e:	8671      	strh	r1, [r6, #50]	; 0x32
  _sensorid_temp = sensor_id + 2;
    4910:	86b2      	strh	r2, [r6, #52]	; 0x34

  reset();
    4912:	f7ff fd75 	bl	4400 <Adafruit_LSM6DS::reset()>

  // Block Data Update
  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL3_C);
    4916:	2312      	movs	r3, #18
    4918:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
    491a:	a80e      	add	r0, sp, #56	; 0x38
    491c:	6bb1      	ldr	r1, [r6, #56]	; 0x38
    491e:	9300      	str	r3, [sp, #0]
    4920:	4623      	mov	r3, r4
    4922:	9503      	str	r5, [sp, #12]
    4924:	9402      	str	r4, [sp, #8]
    4926:	9501      	str	r5, [sp, #4]
    4928:	f7fe fca8 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits bdu = Adafruit_BusIO_RegisterBits(&ctrl3, 1, 6);
    492c:	462a      	mov	r2, r5
    492e:	a90e      	add	r1, sp, #56	; 0x38
    4930:	2306      	movs	r3, #6
    4932:	a804      	add	r0, sp, #16
    4934:	f7fe fd9e 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  bdu.write(true);
    4938:	4629      	mov	r1, r5
    493a:	a804      	add	r0, sp, #16
    493c:	f7fe fdb0 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // Disable I3C
  Adafruit_BusIO_Register ctrl_9 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL9_XL);
    4940:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
    4942:	6bb1      	ldr	r1, [r6, #56]	; 0x38
    4944:	4623      	mov	r3, r4
    4946:	9503      	str	r5, [sp, #12]
    4948:	a814      	add	r0, sp, #80	; 0x50
    494a:	9402      	str	r4, [sp, #8]
    494c:	9501      	str	r5, [sp, #4]
    494e:	9700      	str	r7, [sp, #0]
    4950:	f7fe fc94 	bl	327c <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits i3c_disable_bit =
      Adafruit_BusIO_RegisterBits(&ctrl_9, 1, 1);
    4954:	462b      	mov	r3, r5
    4956:	462a      	mov	r2, r5
    4958:	a914      	add	r1, sp, #80	; 0x50
    495a:	eb0d 0007 	add.w	r0, sp, r7
    495e:	f7fe fd89 	bl	3474 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  i3c_disable_bit.write(true);
    4962:	4629      	mov	r1, r5
    4964:	eb0d 0007 	add.w	r0, sp, r7
    4968:	f7fe fd9a 	bl	34a0 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // call base class _init()
  Adafruit_LSM6DS::_init(sensor_id);
    496c:	4641      	mov	r1, r8
    496e:	4630      	mov	r0, r6
    4970:	f7ff fdea 	bl	4548 <Adafruit_LSM6DS::_init(long)>
    4974:	4628      	mov	r0, r5

  return true;
}
    4976:	b01a      	add	sp, #104	; 0x68
    4978:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000497c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>:
	if (interruptMask[n >> 5] == 0) {
		interruptMasksUsed &= ~(1 << (n >> 5));
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    497c:	b470      	push	{r4, r5, r6}
    uint8_t *p_read = (uint8_t*)retbuf;
    size_t count_read = count;

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 
    497e:	f240 2501 	movw	r5, #513	; 0x201
    4982:	6804      	ldr	r4, [r0, #0]
    4984:	6125      	str	r5, [r4, #16]

	while (count > 0) {
    4986:	b31b      	cbz	r3, 49d0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
    4988:	461e      	mov	r6, r3
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    498a:	b1f1      	cbz	r1, 49ca <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4e>
    498c:	780d      	ldrb	r5, [r1, #0]
    498e:	3101      	adds	r1, #1
		count--; // how many bytes left to output.
    4990:	3b01      	subs	r3, #1
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    4992:	6665      	str	r5, [r4, #100]	; 0x64
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    4994:	6f25      	ldr	r5, [r4, #112]	; 0x70
    4996:	07ad      	lsls	r5, r5, #30
    4998:	d406      	bmi.n	49a8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
				uint8_t b = port().RDR;  // Read any pending RX bytes in
    499a:	6f65      	ldr	r5, [r4, #116]	; 0x74
				if (p_read) *p_read++ = b; 
				count_read--;
    499c:	3e01      	subs	r6, #1
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
				uint8_t b = port().RDR;  // Read any pending RX bytes in
    499e:	b2ed      	uxtb	r5, r5
				if (p_read) *p_read++ = b; 
    49a0:	b112      	cbz	r2, 49a8 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
    49a2:	7015      	strb	r5, [r2, #0]
    49a4:	3201      	adds	r2, #1
    49a6:	6804      	ldr	r4, [r0, #0]
				count_read--;
			}
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;
    49a8:	6965      	ldr	r5, [r4, #20]
	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
    49aa:	07ed      	lsls	r5, r5, #31
    49ac:	d5f2      	bpl.n	4994 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x18>

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
    49ae:	2b00      	cmp	r3, #0
    49b0:	d1eb      	bne.n	498a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0xe>
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;

	}

	// now lets wait for all of the read bytes to be returned...
	while (count_read) {
    49b2:	b16e      	cbz	r6, 49d0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    49b4:	6801      	ldr	r1, [r0, #0]
		if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    49b6:	6f0b      	ldr	r3, [r1, #112]	; 0x70
    49b8:	079b      	lsls	r3, r3, #30
    49ba:	d4fc      	bmi.n	49b6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x3a>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
    49bc:	6f4b      	ldr	r3, [r1, #116]	; 0x74
    49be:	b2db      	uxtb	r3, r3
			if (p_read) *p_read++ = b; 
    49c0:	b10a      	cbz	r2, 49c6 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4a>
    49c2:	7013      	strb	r3, [r2, #0]
    49c4:	3201      	adds	r2, #1
			count_read--;
    49c6:	3e01      	subs	r6, #1
    49c8:	e7f3      	b.n	49b2 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x36>
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    49ca:	f890 503c 	ldrb.w	r5, [r0, #60]	; 0x3c
    49ce:	e7df      	b.n	4990 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x14>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
			if (p_read) *p_read++ = b; 
			count_read--;
		}
	}
}
    49d0:	bc70      	pop	{r4, r5, r6}
    49d2:	4770      	bx	lr

000049d4 <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    49d4:	b10b      	cbz	r3, 49da <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    49d6:	f7ff bfd1 	b.w	497c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>
    49da:	4770      	bx	lr

000049dc <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    49dc:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    49e0:	f890 00a2 	ldrb.w	r0, [r0, #162]	; 0xa2
	}
    49e4:	1a10      	subs	r0, r2, r0
    49e6:	4770      	bx	lr

000049e8 <TwoWire::peek()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    49e8:	f890 30a2 	ldrb.w	r3, [r0, #162]	; 0xa2
    49ec:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    49f0:	429a      	cmp	r2, r3
    49f2:	d902      	bls.n	49fa <TwoWire::peek()+0x12>
		return rxBuffer[rxBufferIndex];
    49f4:	4403      	add	r3, r0
    49f6:	7e98      	ldrb	r0, [r3, #26]
    49f8:	4770      	bx	lr
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    49fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    49fe:	4770      	bx	lr

00004a00 <TwoWire::flush()>:
	virtual void flush(void) {
    4a00:	4770      	bx	lr
    4a02:	bf00      	nop

00004a04 <TwoWire::write(unsigned char)>:
}


size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    4a04:	f8b0 3130 	ldrh.w	r3, [r0, #304]	; 0x130
    4a08:	b193      	cbz	r3, 4a30 <TwoWire::write(unsigned char)+0x2c>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    4a0a:	f890 312f 	ldrb.w	r3, [r0, #303]	; 0x12f
    4a0e:	2b88      	cmp	r3, #136	; 0x88
    4a10:	d80b      	bhi.n	4a2a <TwoWire::write(unsigned char)+0x26>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4a12:	18c2      	adds	r2, r0, r3
{
}


size_t TwoWire::write(uint8_t data)
{
    4a14:	b410      	push	{r4}
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4a16:	1c5c      	adds	r4, r3, #1
		return 1;
    4a18:	2301      	movs	r3, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4a1a:	f880 412f 	strb.w	r4, [r0, #303]	; 0x12f
		return 1;
	}
	return 0;
}
    4a1e:	4618      	mov	r0, r3
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4a20:	f882 10a5 	strb.w	r1, [r2, #165]	; 0xa5
		return 1;
	}
	return 0;
}
    4a24:	f85d 4b04 	ldr.w	r4, [sp], #4
    4a28:	4770      	bx	lr
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	// int printf(const char *format, ...) __attribute__ ((format (printf, 2, 3)));

  protected:
	void setWriteError(int err = 1) { write_error = err; }
    4a2a:	2201      	movs	r2, #1
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    4a2c:	2300      	movs	r3, #0
    4a2e:	7102      	strb	r2, [r0, #4]
		}
		txBuffer[txBufferLength++] = data;
		return 1;
	}
	return 0;
}
    4a30:	4618      	mov	r0, r3
    4a32:	4770      	bx	lr

00004a34 <TwoWire::write(unsigned char const*, unsigned int)>:

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    4a34:	b538      	push	{r3, r4, r5, lr}
    4a36:	4605      	mov	r5, r0
	if (transmitting || slave_mode) {
    4a38:	f8b0 0130 	ldrh.w	r0, [r0, #304]	; 0x130
    4a3c:	b190      	cbz	r0, 4a64 <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    4a3e:	f895 312f 	ldrb.w	r3, [r5, #303]	; 0x12f
    4a42:	4614      	mov	r4, r2
    4a44:	f1c3 0289 	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    4a48:	4294      	cmp	r4, r2
    4a4a:	d80c      	bhi.n	4a66 <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    4a4c:	f105 00a5 	add.w	r0, r5, #165	; 0xa5
    4a50:	4622      	mov	r2, r4
    4a52:	4418      	add	r0, r3
    4a54:	f002 f930 	bl	6cb8 <memcpy>
		txBufferLength += quantity;
    4a58:	f895 312f 	ldrb.w	r3, [r5, #303]	; 0x12f
    4a5c:	4620      	mov	r0, r4
    4a5e:	441c      	add	r4, r3
    4a60:	f885 412f 	strb.w	r4, [r5, #303]	; 0x12f
		return quantity;
	}
	return 0;
}
    4a64:	bd38      	pop	{r3, r4, r5, pc}
    4a66:	4614      	mov	r4, r2
    4a68:	2201      	movs	r2, #1
    4a6a:	712a      	strb	r2, [r5, #4]
    4a6c:	e7ee      	b.n	4a4c <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    4a6e:	bf00      	nop

00004a70 <TwoWire::force_clock()>:
	if (qty > BUFFER_LENGTH) qty = BUFFER_LENGTH;
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
    4a70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4a74:	4683      	mov	fp, r0
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    4a76:	4840      	ldr	r0, [pc, #256]	; (4b78 <TwoWire::force_clock()+0x108>)
	if (qty > BUFFER_LENGTH) qty = BUFFER_LENGTH;
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
    4a78:	b083      	sub	sp, #12
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    4a7a:	2515      	movs	r5, #21
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    4a7c:	f8db a014 	ldr.w	sl, [fp, #20]
    4a80:	f89b 6018 	ldrb.w	r6, [fp, #24]
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    4a84:	f89b 3019 	ldrb.w	r3, [fp, #25]
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    4a88:	eb0a 1606 	add.w	r6, sl, r6, lsl #4
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4a8c:	493b      	ldr	r1, [pc, #236]	; (4b7c <TwoWire::force_clock()+0x10c>)
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    4a8e:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4a92:	f8df e0ec 	ldr.w	lr, [pc, #236]	; 4b80 <TwoWire::force_clock()+0x110>
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    4a96:	7a36      	ldrb	r6, [r6, #8]
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4a98:	460c      	mov	r4, r1
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    4a9a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    4a9e:	0136      	lsls	r6, r6, #4
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4aa0:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 4b84 <TwoWire::force_clock()+0x114>
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    4aa4:	011b      	lsls	r3, r3, #4
bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    4aa6:	1987      	adds	r7, r0, r6
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
    4aa8:	f850 8006 	ldr.w	r8, [r0, r6]
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    4aac:	eb00 0c03 	add.w	ip, r0, r3
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
    4ab0:	58c6      	ldr	r6, [r0, r3]
bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    4ab2:	68f8      	ldr	r0, [r7, #12]
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    4ab4:	687b      	ldr	r3, [r7, #4]
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    4ab6:	f8dc 700c 	ldr.w	r7, [ip, #12]
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    4aba:	9300      	str	r3, [sp, #0]
    4abc:	601d      	str	r5, [r3, #0]
	*portSetRegister(sda_pin) = sda_mask;
    4abe:	f8c8 0084 	str.w	r0, [r8, #132]	; 0x84
	*portModeRegister(sda_pin) |= sda_mask;
    4ac2:	f8d8 3004 	ldr.w	r3, [r8, #4]
	*portConfigRegister(scl_pin) = 5 | 0x10;
    4ac6:	f8dc 2004 	ldr.w	r2, [ip, #4]
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
    4aca:	4303      	orrs	r3, r0
	*portConfigRegister(scl_pin) = 5 | 0x10;
    4acc:	9201      	str	r2, [sp, #4]
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
    4ace:	f8c8 3004 	str.w	r3, [r8, #4]
	*portConfigRegister(scl_pin) = 5 | 0x10;
    4ad2:	6015      	str	r5, [r2, #0]
	*portSetRegister(scl_pin) = scl_mask;
    4ad4:	f8c6 7084 	str.w	r7, [r6, #132]	; 0x84
	*portModeRegister(scl_pin) |= scl_mask;
    4ad8:	6873      	ldr	r3, [r6, #4]
    4ada:	433b      	orrs	r3, r7
    4adc:	6073      	str	r3, [r6, #4]
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4ade:	6809      	ldr	r1, [r1, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4ae0:	f8de 3000 	ldr.w	r3, [lr]
    4ae4:	fba9 3203 	umull	r3, r2, r9, r3
    4ae8:	0c92      	lsrs	r2, r2, #18
    4aea:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    4aee:	0052      	lsls	r2, r2, #1
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4af0:	6823      	ldr	r3, [r4, #0]
    4af2:	1a5b      	subs	r3, r3, r1
    4af4:	429a      	cmp	r2, r3
    4af6:	d8fb      	bhi.n	4af0 <TwoWire::force_clock()+0x80>
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4af8:	4a20      	ldr	r2, [pc, #128]	; (4b7c <TwoWire::force_clock()+0x10c>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4afa:	2509      	movs	r5, #9
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4afc:	f8df c084 	ldr.w	ip, [pc, #132]	; 4b84 <TwoWire::force_clock()+0x114>
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4b00:	4691      	mov	r9, r2
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
    4b02:	f8d8 3008 	ldr.w	r3, [r8, #8]
		  && (*portInputRegister(scl_pin) & scl_mask)) {
    4b06:	4218      	tst	r0, r3
    4b08:	d002      	beq.n	4b10 <TwoWire::force_clock()+0xa0>
    4b0a:	68b3      	ldr	r3, [r6, #8]
    4b0c:	421f      	tst	r7, r3
    4b0e:	d131      	bne.n	4b74 <TwoWire::force_clock()+0x104>
			// success, both pins are high
			ret = true;
			break;
		}
		*portClearRegister(scl_pin) = scl_mask;
    4b10:	f8c6 7088 	str.w	r7, [r6, #136]	; 0x88
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4b14:	6814      	ldr	r4, [r2, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4b16:	f8de 1000 	ldr.w	r1, [lr]
    4b1a:	fbac 3101 	umull	r3, r1, ip, r1
    4b1e:	0c89      	lsrs	r1, r1, #18
    4b20:	eb01 0181 	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4b24:	6813      	ldr	r3, [r2, #0]
    4b26:	1b1b      	subs	r3, r3, r4
    4b28:	4299      	cmp	r1, r3
    4b2a:	d8fb      	bhi.n	4b24 <TwoWire::force_clock()+0xb4>
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
    4b2c:	f8c6 7084 	str.w	r7, [r6, #132]	; 0x84
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4b30:	f8d9 4000 	ldr.w	r4, [r9]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4b34:	f8de 1000 	ldr.w	r1, [lr]
    4b38:	fbac 3101 	umull	r3, r1, ip, r1
    4b3c:	0c89      	lsrs	r1, r1, #18
    4b3e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4b42:	6813      	ldr	r3, [r2, #0]
    4b44:	1b1b      	subs	r3, r3, r4
    4b46:	4299      	cmp	r1, r3
    4b48:	d8fb      	bhi.n	4b42 <TwoWire::force_clock()+0xd2>
	*portModeRegister(sda_pin) |= sda_mask;
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
	*portModeRegister(scl_pin) |= scl_mask;
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
    4b4a:	3d01      	subs	r5, #1
    4b4c:	d1d9      	bne.n	4b02 <TwoWire::force_clock()+0x92>
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
	bool ret = false;
    4b4e:	4628      	mov	r0, r5
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
		delayMicroseconds(5);
	}
	// return control of pins to I2C
	*(portConfigRegister(sda_pin)) = hardware.sda_pins[sda_pin_index_].mux_val;
    4b50:	f89b 3018 	ldrb.w	r3, [fp, #24]
    4b54:	9a00      	ldr	r2, [sp, #0]
    4b56:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
    4b5a:	68db      	ldr	r3, [r3, #12]
    4b5c:	6013      	str	r3, [r2, #0]
	*(portConfigRegister(scl_pin)) = hardware.scl_pins[scl_pin_index_].mux_val;
    4b5e:	f89b 3019 	ldrb.w	r3, [fp, #25]
    4b62:	9a01      	ldr	r2, [sp, #4]
    4b64:	eb0a 1a03 	add.w	sl, sl, r3, lsl #4
    4b68:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
    4b6c:	6013      	str	r3, [r2, #0]
	return ret;
}
    4b6e:	b003      	add	sp, #12
    4b70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
		  && (*portInputRegister(scl_pin) & scl_mask)) {
			// success, both pins are high
			ret = true;
    4b74:	2001      	movs	r0, #1
    4b76:	e7eb      	b.n	4b50 <TwoWire::force_clock()+0xe0>
    4b78:	200006e4 	.word	0x200006e4
    4b7c:	e0001004 	.word	0xe0001004
    4b80:	20001470 	.word	0x20001470
    4b84:	431bde83 	.word	0x431bde83

00004b88 <TwoWire::wait_idle()>:
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
    4b88:	490d      	ldr	r1, [pc, #52]	; (4bc0 <TwoWire::wait_idle()+0x38>)
    4b8a:	6902      	ldr	r2, [r0, #16]
//   01   EPF = End Packet Flag
//      2 RDF = Receive Data Flag
//      1 TDF = Transmit Data Flag

bool TwoWire::wait_idle()
{
    4b8c:	b510      	push	{r4, lr}
    4b8e:	680c      	ldr	r4, [r1, #0]
    4b90:	e005      	b.n	4b9e <TwoWire::wait_idle()+0x16>
	elapsedMillis timeout = 0;
	while (1) {
		uint32_t status = port->MSR; // pg 2899 & 2892
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
		if (status & LPI2C_MSR_MBF) break; // we already have bus control
    4b92:	01db      	lsls	r3, r3, #7
    4b94:	d407      	bmi.n	4ba6 <TwoWire::wait_idle()+0x1e>
    4b96:	680b      	ldr	r3, [r1, #0]
		if (timeout > 16) {
    4b98:	1b1b      	subs	r3, r3, r4
    4b9a:	2b10      	cmp	r3, #16
    4b9c:	d808      	bhi.n	4bb0 <TwoWire::wait_idle()+0x28>

bool TwoWire::wait_idle()
{
	elapsedMillis timeout = 0;
	while (1) {
		uint32_t status = port->MSR; // pg 2899 & 2892
    4b9e:	6953      	ldr	r3, [r2, #20]
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
    4ba0:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    4ba4:	d1f5      	bne.n	4b92 <TwoWire::wait_idle()+0xa>
			if (force_clock()) break;
			//Serial.printf("unable to get control of I2C bus\n");
			return false;
		}
	}
	port->MSR = 0x00007F00; // clear all prior flags
    4ba6:	f44f 43fe 	mov.w	r3, #32512	; 0x7f00
	return true;
    4baa:	2001      	movs	r0, #1
			if (force_clock()) break;
			//Serial.printf("unable to get control of I2C bus\n");
			return false;
		}
	}
	port->MSR = 0x00007F00; // clear all prior flags
    4bac:	6153      	str	r3, [r2, #20]
	return true;
}
    4bae:	bd10      	pop	{r4, pc}
    4bb0:	4604      	mov	r4, r0
		uint32_t status = port->MSR; // pg 2899 & 2892
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
		if (status & LPI2C_MSR_MBF) break; // we already have bus control
		if (timeout > 16) {
			//Serial.printf("timeout waiting for idle, MSR = %x\n", status);
			if (force_clock()) break;
    4bb2:	f7ff ff5d 	bl	4a70 <TwoWire::force_clock()>
    4bb6:	2800      	cmp	r0, #0
    4bb8:	d0f9      	beq.n	4bae <TwoWire::wait_idle()+0x26>
    4bba:	6922      	ldr	r2, [r4, #16]
    4bbc:	e7f3      	b.n	4ba6 <TwoWire::wait_idle()+0x1e>
    4bbe:	bf00      	nop
    4bc0:	20002744 	.word	0x20002744

00004bc4 <TwoWire::endTransmission(unsigned char)>:
	return true;
}


uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    4bc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t tx_len = txBufferLength;
    4bc8:	f890 a12f 	ldrb.w	sl, [r0, #303]	; 0x12f
	if (!tx_len) return 4; // no address for transmit
    4bcc:	f1ba 0f00 	cmp.w	sl, #0
    4bd0:	d102      	bne.n	4bd8 <TwoWire::endTransmission(unsigned char)+0x14>
    4bd2:	2004      	movs	r0, #4
    4bd4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4bd8:	4605      	mov	r5, r0
    4bda:	460e      	mov	r6, r1
	if (!wait_idle()) return 4;
    4bdc:	f7ff ffd4 	bl	4b88 <TwoWire::wait_idle()>
    4be0:	2800      	cmp	r0, #0
    4be2:	d0f6      	beq.n	4bd2 <TwoWire::endTransmission(unsigned char)+0xe>
    4be4:	4f2e      	ldr	r7, [pc, #184]	; (4ca0 <TwoWire::endTransmission(unsigned char)+0xdc>)
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
    4be6:	2400      	movs	r4, #0
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4be8:	f44f 7900 	mov.w	r9, #512	; 0x200
    4bec:	f8d7 8000 	ldr.w	r8, [r7]
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
    4bf0:	4554      	cmp	r4, sl
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
    4bf2:	6929      	ldr	r1, [r5, #16]
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
    4bf4:	d81a      	bhi.n	4c2c <TwoWire::endTransmission(unsigned char)+0x68>
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
    4bf6:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
    4bf8:	f003 0307 	and.w	r3, r3, #7
			while (fifo_used < 4) {
    4bfc:	2b03      	cmp	r3, #3
    4bfe:	d909      	bls.n	4c14 <TwoWire::endTransmission(unsigned char)+0x50>
    4c00:	e014      	b.n	4c2c <TwoWire::endTransmission(unsigned char)+0x68>
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    4c02:	f895 20a5 	ldrb.w	r2, [r5, #165]	; 0xa5
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
					tx_index++;
					break;
				}
				fifo_used++;
    4c06:	3301      	adds	r3, #1
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
    4c08:	2401      	movs	r4, #1
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    4c0a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4c0e:	2b04      	cmp	r3, #4
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    4c10:	660a      	str	r2, [r1, #96]	; 0x60
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4c12:	d00b      	beq.n	4c2c <TwoWire::endTransmission(unsigned char)+0x68>
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    4c14:	192a      	adds	r2, r5, r4
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
    4c16:	2c00      	cmp	r4, #0
    4c18:	d0f3      	beq.n	4c02 <TwoWire::endTransmission(unsigned char)+0x3e>
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
    4c1a:	45a2      	cmp	sl, r4
    4c1c:	d927      	bls.n	4c6e <TwoWire::endTransmission(unsigned char)+0xaa>
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
					tx_index++;
					break;
				}
				fifo_used++;
    4c1e:	3301      	adds	r3, #1
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    4c20:	f892 20a5 	ldrb.w	r2, [r2, #165]	; 0xa5
    4c24:	3401      	adds	r4, #1
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4c26:	2b04      	cmp	r3, #4
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    4c28:	660a      	str	r2, [r1, #96]	; 0x60
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4c2a:	d1f3      	bne.n	4c14 <TwoWire::endTransmission(unsigned char)+0x50>
				}
				fifo_used++;
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
    4c2c:	694b      	ldr	r3, [r1, #20]
		if (status & LPI2C_MSR_ALF) {
    4c2e:	0518      	lsls	r0, r3, #20
    4c30:	d422      	bmi.n	4c78 <TwoWire::endTransmission(unsigned char)+0xb4>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			return 4; // we lost bus arbitration to another master
		}
		if (status & LPI2C_MSR_NDF) {
    4c32:	055a      	lsls	r2, r3, #21
    4c34:	d427      	bmi.n	4c86 <TwoWire::endTransmission(unsigned char)+0xc2>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP;
			return 2; // NACK (assume address, TODO: how to tell address from data)
		}
		if ((status & LPI2C_MSR_PLTF) || timeout > 50) {
    4c36:	0498      	lsls	r0, r3, #18
    4c38:	d404      	bmi.n	4c44 <TwoWire::endTransmission(unsigned char)+0x80>
    4c3a:	683a      	ldr	r2, [r7, #0]
    4c3c:	ebc8 0202 	rsb	r2, r8, r2
    4c40:	2a32      	cmp	r2, #50	; 0x32
    4c42:	d909      	bls.n	4c58 <TwoWire::endTransmission(unsigned char)+0x94>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4c44:	690b      	ldr	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    4c46:	f44f 7200 	mov.w	r2, #512	; 0x200
			return 4; // clock stretched too long or generic timeout
    4c4a:	2004      	movs	r0, #4
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP;
			return 2; // NACK (assume address, TODO: how to tell address from data)
		}
		if ((status & LPI2C_MSR_PLTF) || timeout > 50) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4c4c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    4c50:	610b      	str	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    4c52:	660a      	str	r2, [r1, #96]	; 0x60
			return 4; // clock stretched too long or generic timeout
    4c54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
    4c58:	4554      	cmp	r4, sl
    4c5a:	d905      	bls.n	4c68 <TwoWire::endTransmission(unsigned char)+0xa4>
			uint32_t tx_fifo = port->MFSR & 0x07;
    4c5c:	6dca      	ldr	r2, [r1, #92]	; 0x5c
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
    4c5e:	0752      	lsls	r2, r2, #29
    4c60:	d102      	bne.n	4c68 <TwoWire::endTransmission(unsigned char)+0xa4>
    4c62:	059b      	lsls	r3, r3, #22
    4c64:	d419      	bmi.n	4c9a <TwoWire::endTransmission(unsigned char)+0xd6>
    4c66:	b1c6      	cbz	r6, 4c9a <TwoWire::endTransmission(unsigned char)+0xd6>
				return 0;
			}
		}
		yield();
    4c68:	f7fe fa90 	bl	318c <yield>
	uint32_t tx_len = txBufferLength;
	if (!tx_len) return 4; // no address for transmit
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
    4c6c:	e7c0      	b.n	4bf0 <TwoWire::endTransmission(unsigned char)+0x2c>
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4c6e:	b10e      	cbz	r6, 4c74 <TwoWire::endTransmission(unsigned char)+0xb0>
    4c70:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
					tx_index++;
    4c74:	3401      	adds	r4, #1
					break;
    4c76:	e7d9      	b.n	4c2c <TwoWire::endTransmission(unsigned char)+0x68>
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4c78:	690b      	ldr	r3, [r1, #16]
			return 4; // we lost bus arbitration to another master
    4c7a:	2004      	movs	r0, #4
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4c7c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    4c80:	610b      	str	r3, [r1, #16]
			return 4; // we lost bus arbitration to another master
    4c82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		if (status & LPI2C_MSR_NDF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4c86:	690b      	ldr	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP;
    4c88:	f44f 7200 	mov.w	r2, #512	; 0x200
			return 2; // NACK (assume address, TODO: how to tell address from data)
    4c8c:	2002      	movs	r0, #2
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			return 4; // we lost bus arbitration to another master
		}
		if (status & LPI2C_MSR_NDF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4c8e:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    4c92:	610b      	str	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP;
    4c94:	660a      	str	r2, [r1, #96]	; 0x60
			return 2; // NACK (assume address, TODO: how to tell address from data)
    4c96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
			uint32_t tx_fifo = port->MFSR & 0x07;
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
				return 0;
    4c9a:	2000      	movs	r0, #0
    4c9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4ca0:	20002744 	.word	0x20002744

00004ca4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
		yield();
	}
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    4ca4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4ca8:	460c      	mov	r4, r1
    4caa:	4615      	mov	r5, r2
    4cac:	4698      	mov	r8, r3
    4cae:	4681      	mov	r9, r0
	if (!wait_idle()) return 4;
    4cb0:	f7ff ff6a 	bl	4b88 <TwoWire::wait_idle()>
    4cb4:	b910      	cbnz	r0, 4cbc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x18>
    4cb6:	2004      	movs	r0, #4
    4cb8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
    4cbc:	2200      	movs	r2, #0
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
    4cbe:	0063      	lsls	r3, r4, #1
	if (length < 1) length = 1;
    4cc0:	2d00      	cmp	r5, #0
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4cc2:	f240 4a01 	movw	sl, #1025	; 0x401
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
    4cc6:	4614      	mov	r4, r2
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4cc8:	b2db      	uxtb	r3, r3
    4cca:	4e3d      	ldr	r6, [pc, #244]	; (4dc0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>)

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
    4ccc:	bf08      	it	eq
    4cce:	2501      	moveq	r5, #1
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    4cd0:	2c02      	cmp	r4, #2
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4cd2:	ea43 0a0a 	orr.w	sl, r3, sl
    4cd6:	f8d6 b000 	ldr.w	fp, [r6]
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
    4cda:	f889 20a2 	strb.w	r2, [r9, #162]	; 0xa2
	rxBufferLength = 0;
    4cde:	f889 20a3 	strb.w	r2, [r9, #163]	; 0xa3
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    4ce2:	d948      	bls.n	4d76 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xd2>
    4ce4:	f8d9 3010 	ldr.w	r3, [r9, #16]
				tx_state++;
				tx_fifo--;
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
    4ce8:	f899 20a3 	ldrb.w	r2, [r9, #163]	; 0xa3
    4cec:	2a87      	cmp	r2, #135	; 0x87
    4cee:	d812      	bhi.n	4d16 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
    4cf0:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
    4cf2:	f3c1 4102 	ubfx	r1, r1, #16, #3
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    4cf6:	b911      	cbnz	r1, 4cfe <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x5a>
    4cf8:	e00d      	b.n	4d16 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    4cfa:	2a88      	cmp	r2, #136	; 0x88
    4cfc:	d00b      	beq.n	4d16 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
				rxBuffer[rxBufferLength++] = port->MRDR;
    4cfe:	f102 0e01 	add.w	lr, r2, #1
    4d02:	eb09 0002 	add.w	r0, r9, r2
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    4d06:	3901      	subs	r1, #1
				rxBuffer[rxBufferLength++] = port->MRDR;
    4d08:	fa5f f28e 	uxtb.w	r2, lr
    4d0c:	f889 20a3 	strb.w	r2, [r9, #163]	; 0xa3
    4d10:	6f1f      	ldr	r7, [r3, #112]	; 0x70
    4d12:	7687      	strb	r7, [r0, #26]
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    4d14:	d1f1      	bne.n	4cfa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x56>
				rxBuffer[rxBufferLength++] = port->MRDR;
				rx_fifo--;
			}
		}
		// monitor status, check for error conditions
		uint32_t status = port->MSR; // pg 2884 & 2891
    4d16:	695a      	ldr	r2, [r3, #20]
		if (status & LPI2C_MSR_ALF) {
    4d18:	0510      	lsls	r0, r2, #20
    4d1a:	d44c      	bmi.n	4db6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x112>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			break;
		}
		if ((status & LPI2C_MSR_NDF) || (status & LPI2C_MSR_PLTF) || timeout > 50) {
    4d1c:	f412 5f10 	tst.w	r2, #9216	; 0x2400
    4d20:	d104      	bne.n	4d2c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x88>
    4d22:	6831      	ldr	r1, [r6, #0]
    4d24:	ebcb 0101 	rsb	r1, fp, r1
    4d28:	2932      	cmp	r1, #50	; 0x32
    4d2a:	d912      	bls.n	4d52 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xae>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4d2c:	691a      	ldr	r2, [r3, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    4d2e:	f44f 7100 	mov.w	r1, #512	; 0x200
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			break;
		}
		if ((status & LPI2C_MSR_NDF) || (status & LPI2C_MSR_PLTF) || timeout > 50) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4d32:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    4d36:	611a      	str	r2, [r3, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    4d38:	6619      	str	r1, [r3, #96]	; 0x60
				break;
			}
		}
		yield();
	}
	uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
    4d3a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
	if (rx_fifo > 0) port->MCR |= LPI2C_MCR_RRF;
    4d3c:	f412 2fe0 	tst.w	r2, #458752	; 0x70000
    4d40:	d003      	beq.n	4d4a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
    4d42:	691a      	ldr	r2, [r3, #16]
    4d44:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    4d48:	611a      	str	r2, [r3, #16]
	return rxBufferLength;
    4d4a:	f899 00a3 	ldrb.w	r0, [r9, #163]	; 0xa3
    4d4e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
			break;
		}
		// are we done yet?
		if (rxBufferLength >= length && tx_state >= 3) {
    4d52:	f899 10a3 	ldrb.w	r1, [r9, #163]	; 0xa3
    4d56:	42a9      	cmp	r1, r5
    4d58:	d309      	bcc.n	4d6e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    4d5a:	2c02      	cmp	r4, #2
    4d5c:	d907      	bls.n	4d6e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
			uint32_t tx_fifo = port->MFSR & 0x07;
    4d5e:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
    4d60:	0749      	lsls	r1, r1, #29
    4d62:	d104      	bne.n	4d6e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    4d64:	0592      	lsls	r2, r2, #22
    4d66:	d4e8      	bmi.n	4d3a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    4d68:	f1b8 0f00 	cmp.w	r8, #0
    4d6c:	d0e5      	beq.n	4d3a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
				break;
			}
		}
		yield();
    4d6e:	f7fe fa0d 	bl	318c <yield>
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    4d72:	2c02      	cmp	r4, #2
    4d74:	d8b6      	bhi.n	4ce4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x40>
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
    4d76:	f8d9 2010 	ldr.w	r2, [r9, #16]
    4d7a:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    4d7c:	f003 0307 	and.w	r3, r3, #7
			while (tx_fifo < 4 && tx_state < 3) {
    4d80:	2b03      	cmp	r3, #3
    4d82:	d80d      	bhi.n	4da0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    4d84:	1e69      	subs	r1, r5, #1
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4d86:	f44f 7000 	mov.w	r0, #512	; 0x200
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    4d8a:	f441 7180 	orr.w	r1, r1, #256	; 0x100
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
    4d8e:	b94c      	cbnz	r4, 4da4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x100>
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4d90:	f8c2 a060 	str.w	sl, [r2, #96]	; 0x60
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
				}
				tx_state++;
				tx_fifo--;
    4d94:	3b01      	subs	r3, #1
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
				}
				tx_state++;
    4d96:	3401      	adds	r4, #1
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
    4d98:	2b03      	cmp	r3, #3
    4d9a:	d801      	bhi.n	4da0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
    4d9c:	2c02      	cmp	r4, #2
    4d9e:	d9f6      	bls.n	4d8e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
    4da0:	4613      	mov	r3, r2
    4da2:	e7a1      	b.n	4ce8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
    4da4:	2c01      	cmp	r4, #1
    4da6:	d004      	beq.n	4db2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10e>
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4da8:	f1b8 0f00 	cmp.w	r8, #0
    4dac:	d0f2      	beq.n	4d94 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    4dae:	6610      	str	r0, [r2, #96]	; 0x60
    4db0:	e7f0      	b.n	4d94 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    4db2:	6611      	str	r1, [r2, #96]	; 0x60
    4db4:	e7ee      	b.n	4d94 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
			}
		}
		// monitor status, check for error conditions
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4db6:	691a      	ldr	r2, [r3, #16]
    4db8:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    4dbc:	611a      	str	r2, [r3, #16]
    4dbe:	e7bc      	b.n	4d3a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    4dc0:	20002744 	.word	0x20002744

00004dc4 <TwoWire::isr()>:
}


void TwoWire::isr(void)
{
	uint32_t status = port->SSR;
    4dc4:	6903      	ldr	r3, [r0, #16]
	port->SCR = LPI2C_SCR_SEN;
}


void TwoWire::isr(void)
{
    4dc6:	b570      	push	{r4, r5, r6, lr}
	uint32_t status = port->SSR;
    4dc8:	f8d3 5114 	ldr.w	r5, [r3, #276]	; 0x114
	port->SCR = LPI2C_SCR_SEN;
}


void TwoWire::isr(void)
{
    4dcc:	4604      	mov	r4, r0
	uint32_t status = port->SSR;
	uint32_t w1c_bits = status & 0xF00;
	if (w1c_bits) port->SSR = w1c_bits;
    4dce:	f415 6270 	ands.w	r2, r5, #3840	; 0xf00
    4dd2:	d001      	beq.n	4dd8 <TwoWire::isr()+0x14>
    4dd4:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

	//Serial.print("isr ");
	//Serial.println(status, HEX);

	if (status & LPI2C_SSR_RDF) { // Receive Data Flag
    4dd8:	07ae      	lsls	r6, r5, #30
    4dda:	d50b      	bpl.n	4df4 <TwoWire::isr()+0x30>
		int rx = port->SRDR;
    4ddc:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
		if (rx & 0x8000) {
    4de0:	0408      	lsls	r0, r1, #16
    4de2:	d542      	bpl.n	4e6a <TwoWire::isr()+0xa6>
			rxBufferIndex = 0;
    4de4:	2200      	movs	r2, #0
    4de6:	2001      	movs	r0, #1
    4de8:	f884 20a2 	strb.w	r2, [r4, #162]	; 0xa2
			rxBufferLength = 0;
		}
		if (rxBufferLength < BUFFER_LENGTH) {
			rxBuffer[rxBufferLength++] = rx & 255;
    4dec:	4422      	add	r2, r4
    4dee:	f884 00a3 	strb.w	r0, [r4, #163]	; 0xa3
    4df2:	7691      	strb	r1, [r2, #26]
		}
		//Serial.print("rx = ");
		//Serial.println(rx, HEX);
	}
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
    4df4:	07ea      	lsls	r2, r5, #31
    4df6:	d510      	bpl.n	4e1a <TwoWire::isr()+0x56>
		if (!transmitting) {
    4df8:	f894 6130 	ldrb.w	r6, [r4, #304]	; 0x130
    4dfc:	b316      	cbz	r6, 4e44 <TwoWire::isr()+0x80>
    4dfe:	f894 612e 	ldrb.w	r6, [r4, #302]	; 0x12e
				(*user_onRequest)();
			}
			txBufferIndex = 0;
			transmitting = 1;
		}
		if (txBufferIndex < txBufferLength) {
    4e02:	f894 212f 	ldrb.w	r2, [r4, #303]	; 0x12f
    4e06:	42b2      	cmp	r2, r6
    4e08:	d92b      	bls.n	4e62 <TwoWire::isr()+0x9e>
			port->STDR = txBuffer[txBufferIndex++];
    4e0a:	1c72      	adds	r2, r6, #1
    4e0c:	4426      	add	r6, r4
    4e0e:	f884 212e 	strb.w	r2, [r4, #302]	; 0x12e
    4e12:	f896 20a5 	ldrb.w	r2, [r6, #165]	; 0xa5
    4e16:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
			port->STDR = 0;
		}
		//Serial.println("tx");
	}

	if (status & LPI2C_SSR_SDF) { // Stop
    4e1a:	05ab      	lsls	r3, r5, #22
    4e1c:	d511      	bpl.n	4e42 <TwoWire::isr()+0x7e>
		//Serial.println("Stop");
		if (rxBufferLength > 0 && user_onReceive != nullptr) {
    4e1e:	f894 00a3 	ldrb.w	r0, [r4, #163]	; 0xa3
    4e22:	b118      	cbz	r0, 4e2c <TwoWire::isr()+0x68>
    4e24:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
    4e28:	b103      	cbz	r3, 4e2c <TwoWire::isr()+0x68>
			(*user_onReceive)(rxBufferLength);
    4e2a:	4798      	blx	r3
		}
		rxBufferIndex = 0;
    4e2c:	2300      	movs	r3, #0
    4e2e:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
		rxBufferLength = 0;
    4e32:	f884 30a3 	strb.w	r3, [r4, #163]	; 0xa3
		txBufferIndex = 0;
    4e36:	f884 312e 	strb.w	r3, [r4, #302]	; 0x12e
		txBufferLength = 0;
    4e3a:	f884 312f 	strb.w	r3, [r4, #303]	; 0x12f
		transmitting = 0;
    4e3e:	f884 3130 	strb.w	r3, [r4, #304]	; 0x130
    4e42:	bd70      	pop	{r4, r5, r6, pc}
		//Serial.print("rx = ");
		//Serial.println(rx, HEX);
	}
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
    4e44:	f8d4 2138 	ldr.w	r2, [r4, #312]	; 0x138
    4e48:	b10a      	cbz	r2, 4e4e <TwoWire::isr()+0x8a>
				(*user_onRequest)();
    4e4a:	4790      	blx	r2
    4e4c:	6923      	ldr	r3, [r4, #16]
			}
			txBufferIndex = 0;
			transmitting = 1;
    4e4e:	2201      	movs	r2, #1
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
				(*user_onRequest)();
			}
			txBufferIndex = 0;
    4e50:	2100      	movs	r1, #0
			transmitting = 1;
    4e52:	f884 2130 	strb.w	r2, [r4, #304]	; 0x130
		}
		if (txBufferIndex < txBufferLength) {
    4e56:	f894 212f 	ldrb.w	r2, [r4, #303]	; 0x12f
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
				(*user_onRequest)();
			}
			txBufferIndex = 0;
    4e5a:	f884 112e 	strb.w	r1, [r4, #302]	; 0x12e
			transmitting = 1;
		}
		if (txBufferIndex < txBufferLength) {
    4e5e:	42b2      	cmp	r2, r6
    4e60:	d8d3      	bhi.n	4e0a <TwoWire::isr()+0x46>
			port->STDR = txBuffer[txBufferIndex++];
		} else {
			port->STDR = 0;
    4e62:	2200      	movs	r2, #0
    4e64:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
    4e68:	e7d7      	b.n	4e1a <TwoWire::isr()+0x56>
		int rx = port->SRDR;
		if (rx & 0x8000) {
			rxBufferIndex = 0;
			rxBufferLength = 0;
		}
		if (rxBufferLength < BUFFER_LENGTH) {
    4e6a:	f894 20a3 	ldrb.w	r2, [r4, #163]	; 0xa3
    4e6e:	2a87      	cmp	r2, #135	; 0x87
    4e70:	d8c0      	bhi.n	4df4 <TwoWire::isr()+0x30>
    4e72:	1c50      	adds	r0, r2, #1
    4e74:	b2c0      	uxtb	r0, r0
    4e76:	e7b9      	b.n	4dec <TwoWire::isr()+0x28>

00004e78 <lpi2c1_isr()>:
void lpi2c1_isr(void) { Wire.isr(); }
void lpi2c3_isr(void) { Wire2.isr(); }
void lpi2c4_isr(void) { Wire1.isr(); }
void lpi2c2_isr(void) { Wire3.isr(); }
#else
void lpi2c1_isr(void) { Wire.isr(); }
    4e78:	4801      	ldr	r0, [pc, #4]	; (4e80 <lpi2c1_isr()+0x8>)
    4e7a:	f7ff bfa3 	b.w	4dc4 <TwoWire::isr()>
    4e7e:	bf00      	nop
    4e80:	20001484 	.word	0x20001484

00004e84 <lpi2c3_isr()>:
void lpi2c3_isr(void) { Wire1.isr(); }
    4e84:	4801      	ldr	r0, [pc, #4]	; (4e8c <lpi2c3_isr()+0x8>)
    4e86:	f7ff bf9d 	b.w	4dc4 <TwoWire::isr()>
    4e8a:	bf00      	nop
    4e8c:	200015c4 	.word	0x200015c4

00004e90 <lpi2c4_isr()>:
void lpi2c4_isr(void) { Wire2.isr(); }
    4e90:	4801      	ldr	r0, [pc, #4]	; (4e98 <lpi2c4_isr()+0x8>)
    4e92:	f7ff bf97 	b.w	4dc4 <TwoWire::isr()>
    4e96:	bf00      	nop
    4e98:	20001704 	.word	0x20001704
    4e9c:	00000000 	.word	0x00000000

00004ea0 <cos>:
    4ea0:	b500      	push	{lr}
    4ea2:	eeb0 7b40 	vmov.f64	d7, d0
    4ea6:	ee17 3a90 	vmov	r3, s15
    4eaa:	4a23      	ldr	r2, [pc, #140]	; (4f38 <cos+0x98>)
    4eac:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    4eb0:	4293      	cmp	r3, r2
    4eb2:	b085      	sub	sp, #20
    4eb4:	dd19      	ble.n	4eea <cos+0x4a>
    4eb6:	4a21      	ldr	r2, [pc, #132]	; (4f3c <cos+0x9c>)
    4eb8:	4293      	cmp	r3, r2
    4eba:	dd04      	ble.n	4ec6 <cos+0x26>
    4ebc:	ee30 0b40 	vsub.f64	d0, d0, d0
    4ec0:	b005      	add	sp, #20
    4ec2:	f85d fb04 	ldr.w	pc, [sp], #4
    4ec6:	4668      	mov	r0, sp
    4ec8:	f000 f9d2 	bl	5270 <__ieee754_rem_pio2>
    4ecc:	f000 0003 	and.w	r0, r0, #3
    4ed0:	2801      	cmp	r0, #1
    4ed2:	d01a      	beq.n	4f0a <cos+0x6a>
    4ed4:	2802      	cmp	r0, #2
    4ed6:	d00f      	beq.n	4ef8 <cos+0x58>
    4ed8:	b300      	cbz	r0, 4f1c <cos+0x7c>
    4eda:	2001      	movs	r0, #1
    4edc:	ed9d 1b02 	vldr	d1, [sp, #8]
    4ee0:	ed9d 0b00 	vldr	d0, [sp]
    4ee4:	f000 ffa4 	bl	5e30 <__kernel_sin>
    4ee8:	e7ea      	b.n	4ec0 <cos+0x20>
    4eea:	ed9f 1b11 	vldr	d1, [pc, #68]	; 4f30 <cos+0x90>
    4eee:	f000 fbcf 	bl	5690 <__kernel_cos>
    4ef2:	b005      	add	sp, #20
    4ef4:	f85d fb04 	ldr.w	pc, [sp], #4
    4ef8:	ed9d 1b02 	vldr	d1, [sp, #8]
    4efc:	ed9d 0b00 	vldr	d0, [sp]
    4f00:	f000 fbc6 	bl	5690 <__kernel_cos>
    4f04:	eeb1 0b40 	vneg.f64	d0, d0
    4f08:	e7da      	b.n	4ec0 <cos+0x20>
    4f0a:	ed9d 1b02 	vldr	d1, [sp, #8]
    4f0e:	ed9d 0b00 	vldr	d0, [sp]
    4f12:	f000 ff8d 	bl	5e30 <__kernel_sin>
    4f16:	eeb1 0b40 	vneg.f64	d0, d0
    4f1a:	e7d1      	b.n	4ec0 <cos+0x20>
    4f1c:	ed9d 1b02 	vldr	d1, [sp, #8]
    4f20:	ed9d 0b00 	vldr	d0, [sp]
    4f24:	f000 fbb4 	bl	5690 <__kernel_cos>
    4f28:	e7ca      	b.n	4ec0 <cos+0x20>
    4f2a:	bf00      	nop
    4f2c:	f3af 8000 	nop.w
	...
    4f38:	3fe921fb 	.word	0x3fe921fb
    4f3c:	7fefffff 	.word	0x7fefffff

00004f40 <sin>:
    4f40:	b500      	push	{lr}
    4f42:	eeb0 7b40 	vmov.f64	d7, d0
    4f46:	ee17 3a90 	vmov	r3, s15
    4f4a:	4a23      	ldr	r2, [pc, #140]	; (4fd8 <sin+0x98>)
    4f4c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    4f50:	4293      	cmp	r3, r2
    4f52:	b085      	sub	sp, #20
    4f54:	dd1a      	ble.n	4f8c <sin+0x4c>
    4f56:	4a21      	ldr	r2, [pc, #132]	; (4fdc <sin+0x9c>)
    4f58:	4293      	cmp	r3, r2
    4f5a:	dd04      	ble.n	4f66 <sin+0x26>
    4f5c:	ee30 0b40 	vsub.f64	d0, d0, d0
    4f60:	b005      	add	sp, #20
    4f62:	f85d fb04 	ldr.w	pc, [sp], #4
    4f66:	4668      	mov	r0, sp
    4f68:	f000 f982 	bl	5270 <__ieee754_rem_pio2>
    4f6c:	f000 0003 	and.w	r0, r0, #3
    4f70:	2801      	cmp	r0, #1
    4f72:	d01d      	beq.n	4fb0 <sin+0x70>
    4f74:	2802      	cmp	r0, #2
    4f76:	d011      	beq.n	4f9c <sin+0x5c>
    4f78:	b308      	cbz	r0, 4fbe <sin+0x7e>
    4f7a:	ed9d 1b02 	vldr	d1, [sp, #8]
    4f7e:	ed9d 0b00 	vldr	d0, [sp]
    4f82:	f000 fb85 	bl	5690 <__kernel_cos>
    4f86:	eeb1 0b40 	vneg.f64	d0, d0
    4f8a:	e7e9      	b.n	4f60 <sin+0x20>
    4f8c:	2000      	movs	r0, #0
    4f8e:	ed9f 1b10 	vldr	d1, [pc, #64]	; 4fd0 <sin+0x90>
    4f92:	f000 ff4d 	bl	5e30 <__kernel_sin>
    4f96:	b005      	add	sp, #20
    4f98:	f85d fb04 	ldr.w	pc, [sp], #4
    4f9c:	2001      	movs	r0, #1
    4f9e:	ed9d 1b02 	vldr	d1, [sp, #8]
    4fa2:	ed9d 0b00 	vldr	d0, [sp]
    4fa6:	f000 ff43 	bl	5e30 <__kernel_sin>
    4faa:	eeb1 0b40 	vneg.f64	d0, d0
    4fae:	e7d7      	b.n	4f60 <sin+0x20>
    4fb0:	ed9d 1b02 	vldr	d1, [sp, #8]
    4fb4:	ed9d 0b00 	vldr	d0, [sp]
    4fb8:	f000 fb6a 	bl	5690 <__kernel_cos>
    4fbc:	e7d0      	b.n	4f60 <sin+0x20>
    4fbe:	2001      	movs	r0, #1
    4fc0:	ed9d 1b02 	vldr	d1, [sp, #8]
    4fc4:	ed9d 0b00 	vldr	d0, [sp]
    4fc8:	f000 ff32 	bl	5e30 <__kernel_sin>
    4fcc:	e7c8      	b.n	4f60 <sin+0x20>
    4fce:	bf00      	nop
	...
    4fd8:	3fe921fb 	.word	0x3fe921fb
    4fdc:	7fefffff 	.word	0x7fefffff

00004fe0 <atan2>:
    4fe0:	f000 b856 	b.w	5090 <__ieee754_atan2>
    4fe4:	0000      	movs	r0, r0
	...

00004fe8 <sqrt>:
    4fe8:	b500      	push	{lr}
    4fea:	ed2d 8b02 	vpush	{d8}
    4fee:	eeb0 8b40 	vmov.f64	d8, d0
    4ff2:	b08b      	sub	sp, #44	; 0x2c
    4ff4:	f000 fa8a 	bl	550c <__ieee754_sqrt>
    4ff8:	4b23      	ldr	r3, [pc, #140]	; (5088 <sqrt+0xa0>)
    4ffa:	f993 3000 	ldrsb.w	r3, [r3]
    4ffe:	1c5a      	adds	r2, r3, #1
    5000:	d00b      	beq.n	501a <sqrt+0x32>
    5002:	eeb4 8b48 	vcmp.f64	d8, d8
    5006:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    500a:	d606      	bvs.n	501a <sqrt+0x32>
    500c:	ed9f 7b1c 	vldr	d7, [pc, #112]	; 5080 <sqrt+0x98>
    5010:	eeb4 8bc7 	vcmpe.f64	d8, d7
    5014:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5018:	d404      	bmi.n	5024 <sqrt+0x3c>
    501a:	b00b      	add	sp, #44	; 0x2c
    501c:	ecbd 8b02 	vpop	{d8}
    5020:	f85d fb04 	ldr.w	pc, [sp], #4
    5024:	2201      	movs	r2, #1
    5026:	4919      	ldr	r1, [pc, #100]	; (508c <sqrt+0xa4>)
    5028:	9200      	str	r2, [sp, #0]
    502a:	2200      	movs	r2, #0
    502c:	ed8d 8b04 	vstr	d8, [sp, #16]
    5030:	ed8d 8b02 	vstr	d8, [sp, #8]
    5034:	9101      	str	r1, [sp, #4]
    5036:	9208      	str	r2, [sp, #32]
    5038:	b193      	cbz	r3, 5060 <sqrt+0x78>
    503a:	ee87 6b07 	vdiv.f64	d6, d7, d7
    503e:	2b02      	cmp	r3, #2
    5040:	ed8d 6b06 	vstr	d6, [sp, #24]
    5044:	d10e      	bne.n	5064 <sqrt+0x7c>
    5046:	f001 fb1b 	bl	6680 <__errno>
    504a:	2321      	movs	r3, #33	; 0x21
    504c:	6003      	str	r3, [r0, #0]
    504e:	9b08      	ldr	r3, [sp, #32]
    5050:	b973      	cbnz	r3, 5070 <sqrt+0x88>
    5052:	ed9d 0b06 	vldr	d0, [sp, #24]
    5056:	b00b      	add	sp, #44	; 0x2c
    5058:	ecbd 8b02 	vpop	{d8}
    505c:	f85d fb04 	ldr.w	pc, [sp], #4
    5060:	ed8d 7b06 	vstr	d7, [sp, #24]
    5064:	4668      	mov	r0, sp
    5066:	f001 f8d3 	bl	6210 <matherr>
    506a:	2800      	cmp	r0, #0
    506c:	d1ef      	bne.n	504e <sqrt+0x66>
    506e:	e7ea      	b.n	5046 <sqrt+0x5e>
    5070:	f001 fb06 	bl	6680 <__errno>
    5074:	9b08      	ldr	r3, [sp, #32]
    5076:	6003      	str	r3, [r0, #0]
    5078:	e7eb      	b.n	5052 <sqrt+0x6a>
    507a:	bf00      	nop
    507c:	f3af 8000 	nop.w
	...
    5088:	20001e3e 	.word	0x20001e3e
    508c:	20000e20 	.word	0x20000e20

00005090 <__ieee754_atan2>:
    5090:	b5f0      	push	{r4, r5, r6, r7, lr}
    5092:	b085      	sub	sp, #20
    5094:	ed8d 1b02 	vstr	d1, [sp, #8]
    5098:	9a02      	ldr	r2, [sp, #8]
    509a:	9803      	ldr	r0, [sp, #12]
    509c:	4972      	ldr	r1, [pc, #456]	; (5268 <__ieee754_atan2+0x1d8>)
    509e:	4253      	negs	r3, r2
    50a0:	ed8d 0b00 	vstr	d0, [sp]
    50a4:	4313      	orrs	r3, r2
    50a6:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
    50aa:	ea45 73d3 	orr.w	r3, r5, r3, lsr #31
    50ae:	428b      	cmp	r3, r1
    50b0:	e89d 0090 	ldmia.w	sp, {r4, r7}
    50b4:	d842      	bhi.n	513c <__ieee754_atan2+0xac>
    50b6:	4263      	negs	r3, r4
    50b8:	4323      	orrs	r3, r4
    50ba:	f027 4e00 	bic.w	lr, r7, #2147483648	; 0x80000000
    50be:	ea4e 73d3 	orr.w	r3, lr, r3, lsr #31
    50c2:	428b      	cmp	r3, r1
    50c4:	d83a      	bhi.n	513c <__ieee754_atan2+0xac>
    50c6:	f100 4340 	add.w	r3, r0, #3221225472	; 0xc0000000
    50ca:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
    50ce:	4313      	orrs	r3, r2
    50d0:	d053      	beq.n	517a <__ieee754_atan2+0xea>
    50d2:	1786      	asrs	r6, r0, #30
    50d4:	f006 0602 	and.w	r6, r6, #2
    50d8:	ea54 030e 	orrs.w	r3, r4, lr
    50dc:	ea46 76d7 	orr.w	r6, r6, r7, lsr #31
    50e0:	d034      	beq.n	514c <__ieee754_atan2+0xbc>
    50e2:	ea52 0305 	orrs.w	r3, r2, r5
    50e6:	d03e      	beq.n	5166 <__ieee754_atan2+0xd6>
    50e8:	428d      	cmp	r5, r1
    50ea:	d052      	beq.n	5192 <__ieee754_atan2+0x102>
    50ec:	458e      	cmp	lr, r1
    50ee:	d03a      	beq.n	5166 <__ieee754_atan2+0xd6>
    50f0:	ebc5 050e 	rsb	r5, r5, lr
    50f4:	152d      	asrs	r5, r5, #20
    50f6:	2d3c      	cmp	r5, #60	; 0x3c
    50f8:	dc44      	bgt.n	5184 <__ieee754_atan2+0xf4>
    50fa:	2800      	cmp	r0, #0
    50fc:	db6b      	blt.n	51d6 <__ieee754_atan2+0x146>
    50fe:	e9dd 2300 	ldrd	r2, r3, [sp]
    5102:	ed9d 0b02 	vldr	d0, [sp, #8]
    5106:	ec43 2b17 	vmov	d7, r2, r3
    510a:	ee87 0b00 	vdiv.f64	d0, d7, d0
    510e:	f000 ffe9 	bl	60e4 <fabs>
    5112:	f000 fee5 	bl	5ee0 <atan>
    5116:	ec53 2b10 	vmov	r2, r3, d0
    511a:	2e01      	cmp	r6, #1
    511c:	d056      	beq.n	51cc <__ieee754_atan2+0x13c>
    511e:	2e02      	cmp	r6, #2
    5120:	d049      	beq.n	51b6 <__ieee754_atan2+0x126>
    5122:	2e00      	cmp	r6, #0
    5124:	d044      	beq.n	51b0 <__ieee754_atan2+0x120>
    5126:	ed9f 7b3a 	vldr	d7, [pc, #232]	; 5210 <__ieee754_atan2+0x180>
    512a:	ed9f 6b3b 	vldr	d6, [pc, #236]	; 5218 <__ieee754_atan2+0x188>
    512e:	ec43 2b15 	vmov	d5, r2, r3
    5132:	ee35 7b47 	vsub.f64	d7, d5, d7
    5136:	ee37 0b46 	vsub.f64	d0, d7, d6
    513a:	e005      	b.n	5148 <__ieee754_atan2+0xb8>
    513c:	ed9d 7b02 	vldr	d7, [sp, #8]
    5140:	ed9d 6b00 	vldr	d6, [sp]
    5144:	ee37 0b06 	vadd.f64	d0, d7, d6
    5148:	b005      	add	sp, #20
    514a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    514c:	2e02      	cmp	r6, #2
    514e:	d01d      	beq.n	518c <__ieee754_atan2+0xfc>
    5150:	ed9f 0b33 	vldr	d0, [pc, #204]	; 5220 <__ieee754_atan2+0x190>
    5154:	ed9d 7b00 	vldr	d7, [sp]
    5158:	2e03      	cmp	r6, #3
    515a:	bf08      	it	eq
    515c:	eeb0 7b40 	vmoveq.f64	d7, d0
    5160:	eeb0 0b47 	vmov.f64	d0, d7
    5164:	e7f0      	b.n	5148 <__ieee754_atan2+0xb8>
    5166:	ed9f 7b30 	vldr	d7, [pc, #192]	; 5228 <__ieee754_atan2+0x198>
    516a:	ed9f 0b31 	vldr	d0, [pc, #196]	; 5230 <__ieee754_atan2+0x1a0>
    516e:	2f00      	cmp	r7, #0
    5170:	bfa8      	it	ge
    5172:	eeb0 0b47 	vmovge.f64	d0, d7
    5176:	b005      	add	sp, #20
    5178:	bdf0      	pop	{r4, r5, r6, r7, pc}
    517a:	b005      	add	sp, #20
    517c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    5180:	f000 beae 	b.w	5ee0 <atan>
    5184:	a328      	add	r3, pc, #160	; (adr r3, 5228 <__ieee754_atan2+0x198>)
    5186:	e9d3 2300 	ldrd	r2, r3, [r3]
    518a:	e7c6      	b.n	511a <__ieee754_atan2+0x8a>
    518c:	ed9f 0b22 	vldr	d0, [pc, #136]	; 5218 <__ieee754_atan2+0x188>
    5190:	e7da      	b.n	5148 <__ieee754_atan2+0xb8>
    5192:	45ae      	cmp	lr, r5
    5194:	d024      	beq.n	51e0 <__ieee754_atan2+0x150>
    5196:	2e02      	cmp	r6, #2
    5198:	d0f8      	beq.n	518c <__ieee754_atan2+0xfc>
    519a:	2e03      	cmp	r6, #3
    519c:	d02d      	beq.n	51fa <__ieee754_atan2+0x16a>
    519e:	ed9f 7b26 	vldr	d7, [pc, #152]	; 5238 <__ieee754_atan2+0x1a8>
    51a2:	ed9f 0b27 	vldr	d0, [pc, #156]	; 5240 <__ieee754_atan2+0x1b0>
    51a6:	2e01      	cmp	r6, #1
    51a8:	bf08      	it	eq
    51aa:	eeb0 0b47 	vmoveq.f64	d0, d7
    51ae:	e7cb      	b.n	5148 <__ieee754_atan2+0xb8>
    51b0:	ec43 2b10 	vmov	d0, r2, r3
    51b4:	e7c8      	b.n	5148 <__ieee754_atan2+0xb8>
    51b6:	ed9f 7b16 	vldr	d7, [pc, #88]	; 5210 <__ieee754_atan2+0x180>
    51ba:	ed9f 6b17 	vldr	d6, [pc, #92]	; 5218 <__ieee754_atan2+0x188>
    51be:	ec43 2b15 	vmov	d5, r2, r3
    51c2:	ee35 7b47 	vsub.f64	d7, d5, d7
    51c6:	ee36 0b47 	vsub.f64	d0, d6, d7
    51ca:	e7bd      	b.n	5148 <__ieee754_atan2+0xb8>
    51cc:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
    51d0:	ec43 2b10 	vmov	d0, r2, r3
    51d4:	e7b8      	b.n	5148 <__ieee754_atan2+0xb8>
    51d6:	353c      	adds	r5, #60	; 0x3c
    51d8:	da91      	bge.n	50fe <__ieee754_atan2+0x6e>
    51da:	2200      	movs	r2, #0
    51dc:	2300      	movs	r3, #0
    51de:	e79c      	b.n	511a <__ieee754_atan2+0x8a>
    51e0:	2e02      	cmp	r6, #2
    51e2:	d010      	beq.n	5206 <__ieee754_atan2+0x176>
    51e4:	2e03      	cmp	r6, #3
    51e6:	d00b      	beq.n	5200 <__ieee754_atan2+0x170>
    51e8:	ed9f 7b17 	vldr	d7, [pc, #92]	; 5248 <__ieee754_atan2+0x1b8>
    51ec:	ed9f 0b18 	vldr	d0, [pc, #96]	; 5250 <__ieee754_atan2+0x1c0>
    51f0:	2e01      	cmp	r6, #1
    51f2:	bf08      	it	eq
    51f4:	eeb0 0b47 	vmoveq.f64	d0, d7
    51f8:	e7a6      	b.n	5148 <__ieee754_atan2+0xb8>
    51fa:	ed9f 0b09 	vldr	d0, [pc, #36]	; 5220 <__ieee754_atan2+0x190>
    51fe:	e7a3      	b.n	5148 <__ieee754_atan2+0xb8>
    5200:	ed9f 0b15 	vldr	d0, [pc, #84]	; 5258 <__ieee754_atan2+0x1c8>
    5204:	e7a0      	b.n	5148 <__ieee754_atan2+0xb8>
    5206:	ed9f 0b16 	vldr	d0, [pc, #88]	; 5260 <__ieee754_atan2+0x1d0>
    520a:	e79d      	b.n	5148 <__ieee754_atan2+0xb8>
    520c:	f3af 8000 	nop.w
    5210:	33145c07 	.word	0x33145c07
    5214:	3ca1a626 	.word	0x3ca1a626
    5218:	54442d18 	.word	0x54442d18
    521c:	400921fb 	.word	0x400921fb
    5220:	54442d18 	.word	0x54442d18
    5224:	c00921fb 	.word	0xc00921fb
    5228:	54442d18 	.word	0x54442d18
    522c:	3ff921fb 	.word	0x3ff921fb
    5230:	54442d18 	.word	0x54442d18
    5234:	bff921fb 	.word	0xbff921fb
    5238:	00000000 	.word	0x00000000
    523c:	80000000 	.word	0x80000000
	...
    5248:	54442d18 	.word	0x54442d18
    524c:	bfe921fb 	.word	0xbfe921fb
    5250:	54442d18 	.word	0x54442d18
    5254:	3fe921fb 	.word	0x3fe921fb
    5258:	7f3321d2 	.word	0x7f3321d2
    525c:	c002d97c 	.word	0xc002d97c
    5260:	7f3321d2 	.word	0x7f3321d2
    5264:	4002d97c 	.word	0x4002d97c
    5268:	7ff00000 	.word	0x7ff00000
    526c:	00000000 	.word	0x00000000

00005270 <__ieee754_rem_pio2>:
    5270:	b570      	push	{r4, r5, r6, lr}
    5272:	ec53 2b10 	vmov	r2, r3, d0
    5276:	499e      	ldr	r1, [pc, #632]	; (54f0 <__ieee754_rem_pio2+0x280>)
    5278:	f023 4600 	bic.w	r6, r3, #2147483648	; 0x80000000
    527c:	428e      	cmp	r6, r1
    527e:	b088      	sub	sp, #32
    5280:	dd62      	ble.n	5348 <__ieee754_rem_pio2+0xd8>
    5282:	499c      	ldr	r1, [pc, #624]	; (54f4 <__ieee754_rem_pio2+0x284>)
    5284:	428e      	cmp	r6, r1
    5286:	461d      	mov	r5, r3
    5288:	dc1c      	bgt.n	52c4 <__ieee754_rem_pio2+0x54>
    528a:	2b00      	cmp	r3, #0
    528c:	ed9f 7b88 	vldr	d7, [pc, #544]	; 54b0 <__ieee754_rem_pio2+0x240>
    5290:	f340 80df 	ble.w	5452 <__ieee754_rem_pio2+0x1e2>
    5294:	ee30 7b47 	vsub.f64	d7, d0, d7
    5298:	f5a1 211b 	sub.w	r1, r1, #634880	; 0x9b000
    529c:	f5a1 61f0 	sub.w	r1, r1, #1920	; 0x780
    52a0:	428e      	cmp	r6, r1
    52a2:	d063      	beq.n	536c <__ieee754_rem_pio2+0xfc>
    52a4:	ed9f 6b84 	vldr	d6, [pc, #528]	; 54b8 <__ieee754_rem_pio2+0x248>
    52a8:	ee37 5b46 	vsub.f64	d5, d7, d6
    52ac:	ee37 7b45 	vsub.f64	d7, d7, d5
    52b0:	2301      	movs	r3, #1
    52b2:	ed80 5b00 	vstr	d5, [r0]
    52b6:	ee37 7b46 	vsub.f64	d7, d7, d6
    52ba:	ed80 7b02 	vstr	d7, [r0, #8]
    52be:	4618      	mov	r0, r3
    52c0:	b008      	add	sp, #32
    52c2:	bd70      	pop	{r4, r5, r6, pc}
    52c4:	498c      	ldr	r1, [pc, #560]	; (54f8 <__ieee754_rem_pio2+0x288>)
    52c6:	428e      	cmp	r6, r1
    52c8:	4604      	mov	r4, r0
    52ca:	dd56      	ble.n	537a <__ieee754_rem_pio2+0x10a>
    52cc:	498b      	ldr	r1, [pc, #556]	; (54fc <__ieee754_rem_pio2+0x28c>)
    52ce:	428e      	cmp	r6, r1
    52d0:	dc44      	bgt.n	535c <__ieee754_rem_pio2+0xec>
    52d2:	4610      	mov	r0, r2
    52d4:	1532      	asrs	r2, r6, #20
    52d6:	f2a2 4216 	subw	r2, r2, #1046	; 0x416
    52da:	eba6 5102 	sub.w	r1, r6, r2, lsl #20
    52de:	ec41 0b16 	vmov	d6, r0, r1
    52e2:	ed9f 7b77 	vldr	d7, [pc, #476]	; 54c0 <__ieee754_rem_pio2+0x250>
    52e6:	eebd 4bc6 	vcvt.s32.f64	s8, d6
    52ea:	2300      	movs	r3, #0
    52ec:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
    52f0:	ee36 6b44 	vsub.f64	d6, d6, d4
    52f4:	ee26 6b07 	vmul.f64	d6, d6, d7
    52f8:	eebd 5bc6 	vcvt.s32.f64	s10, d6
    52fc:	ed8d 4b02 	vstr	d4, [sp, #8]
    5300:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
    5304:	ee36 6b45 	vsub.f64	d6, d6, d5
    5308:	ee26 7b07 	vmul.f64	d7, d6, d7
    530c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    5310:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5314:	ed8d 5b04 	vstr	d5, [sp, #16]
    5318:	ed8d 7b06 	vstr	d7, [sp, #24]
    531c:	f040 80bb 	bne.w	5496 <__ieee754_rem_pio2+0x226>
    5320:	eeb5 5b40 	vcmp.f64	d5, #0.0
    5324:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5328:	bf0c      	ite	eq
    532a:	2301      	moveq	r3, #1
    532c:	2302      	movne	r3, #2
    532e:	4974      	ldr	r1, [pc, #464]	; (5500 <__ieee754_rem_pio2+0x290>)
    5330:	9101      	str	r1, [sp, #4]
    5332:	2102      	movs	r1, #2
    5334:	9100      	str	r1, [sp, #0]
    5336:	a802      	add	r0, sp, #8
    5338:	4621      	mov	r1, r4
    533a:	f000 fa39 	bl	57b0 <__kernel_rem_pio2>
    533e:	2d00      	cmp	r5, #0
    5340:	f2c0 809b 	blt.w	547a <__ieee754_rem_pio2+0x20a>
    5344:	4603      	mov	r3, r0
    5346:	e006      	b.n	5356 <__ieee754_rem_pio2+0xe6>
    5348:	2400      	movs	r4, #0
    534a:	2500      	movs	r5, #0
    534c:	ed80 0b00 	vstr	d0, [r0]
    5350:	e9c0 4502 	strd	r4, r5, [r0, #8]
    5354:	2300      	movs	r3, #0
    5356:	4618      	mov	r0, r3
    5358:	b008      	add	sp, #32
    535a:	bd70      	pop	{r4, r5, r6, pc}
    535c:	ee30 7b40 	vsub.f64	d7, d0, d0
    5360:	2300      	movs	r3, #0
    5362:	ed80 7b02 	vstr	d7, [r0, #8]
    5366:	ed80 7b00 	vstr	d7, [r0]
    536a:	e7f4      	b.n	5356 <__ieee754_rem_pio2+0xe6>
    536c:	ed9f 5b56 	vldr	d5, [pc, #344]	; 54c8 <__ieee754_rem_pio2+0x258>
    5370:	ed9f 6b57 	vldr	d6, [pc, #348]	; 54d0 <__ieee754_rem_pio2+0x260>
    5374:	ee37 7b45 	vsub.f64	d7, d7, d5
    5378:	e796      	b.n	52a8 <__ieee754_rem_pio2+0x38>
    537a:	f000 feb3 	bl	60e4 <fabs>
    537e:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    5382:	ed9f 6b55 	vldr	d6, [pc, #340]	; 54d8 <__ieee754_rem_pio2+0x268>
    5386:	eea0 7b06 	vfma.f64	d7, d0, d6
    538a:	eefd 7bc7 	vcvt.s32.f64	s15, d7
    538e:	ed9f 3b48 	vldr	d3, [pc, #288]	; 54b0 <__ieee754_rem_pio2+0x240>
    5392:	ee17 3a90 	vmov	r3, s15
    5396:	ed9f 6b48 	vldr	d6, [pc, #288]	; 54b8 <__ieee754_rem_pio2+0x248>
    539a:	2b1f      	cmp	r3, #31
    539c:	eeb8 5be7 	vcvt.f64.s32	d5, s15
    53a0:	eeb1 4b45 	vneg.f64	d4, d5
    53a4:	ee25 7b06 	vmul.f64	d7, d5, d6
    53a8:	eea4 0b03 	vfma.f64	d0, d4, d3
    53ac:	dc1b      	bgt.n	53e6 <__ieee754_rem_pio2+0x176>
    53ae:	4a55      	ldr	r2, [pc, #340]	; (5504 <__ieee754_rem_pio2+0x294>)
    53b0:	1e59      	subs	r1, r3, #1
    53b2:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    53b6:	4296      	cmp	r6, r2
    53b8:	d015      	beq.n	53e6 <__ieee754_rem_pio2+0x176>
    53ba:	ee30 6b47 	vsub.f64	d6, d0, d7
    53be:	ed84 6b00 	vstr	d6, [r4]
    53c2:	ee30 0b46 	vsub.f64	d0, d0, d6
    53c6:	ee30 0b47 	vsub.f64	d0, d0, d7
    53ca:	2d00      	cmp	r5, #0
    53cc:	ed84 0b02 	vstr	d0, [r4, #8]
    53d0:	dac1      	bge.n	5356 <__ieee754_rem_pio2+0xe6>
    53d2:	eeb1 6b46 	vneg.f64	d6, d6
    53d6:	eeb1 0b40 	vneg.f64	d0, d0
    53da:	ed84 6b00 	vstr	d6, [r4]
    53de:	ed84 0b02 	vstr	d0, [r4, #8]
    53e2:	425b      	negs	r3, r3
    53e4:	e7b7      	b.n	5356 <__ieee754_rem_pio2+0xe6>
    53e6:	ee30 6b47 	vsub.f64	d6, d0, d7
    53ea:	ee16 2a90 	vmov	r2, s13
    53ee:	1536      	asrs	r6, r6, #20
    53f0:	f3c2 520a 	ubfx	r2, r2, #20, #11
    53f4:	1ab2      	subs	r2, r6, r2
    53f6:	2a10      	cmp	r2, #16
    53f8:	ed84 6b00 	vstr	d6, [r4]
    53fc:	dde1      	ble.n	53c2 <__ieee754_rem_pio2+0x152>
    53fe:	eeb0 3b40 	vmov.f64	d3, d0
    5402:	ed9f 7b31 	vldr	d7, [pc, #196]	; 54c8 <__ieee754_rem_pio2+0x258>
    5406:	ed9f 6b32 	vldr	d6, [pc, #200]	; 54d0 <__ieee754_rem_pio2+0x260>
    540a:	eea4 3b07 	vfma.f64	d3, d4, d7
    540e:	ee30 0b43 	vsub.f64	d0, d0, d3
    5412:	eea4 0b07 	vfma.f64	d0, d4, d7
    5416:	eeb0 7b40 	vmov.f64	d7, d0
    541a:	ee95 7b06 	vfnms.f64	d7, d5, d6
    541e:	ee33 6b47 	vsub.f64	d6, d3, d7
    5422:	ee16 2a90 	vmov	r2, s13
    5426:	f3c2 520a 	ubfx	r2, r2, #20, #11
    542a:	1ab6      	subs	r6, r6, r2
    542c:	2e31      	cmp	r6, #49	; 0x31
    542e:	ed84 6b00 	vstr	d6, [r4]
    5432:	dd39      	ble.n	54a8 <__ieee754_rem_pio2+0x238>
    5434:	eeb0 0b43 	vmov.f64	d0, d3
    5438:	ed9f 6b29 	vldr	d6, [pc, #164]	; 54e0 <__ieee754_rem_pio2+0x270>
    543c:	ed9f 2b2a 	vldr	d2, [pc, #168]	; 54e8 <__ieee754_rem_pio2+0x278>
    5440:	eea4 0b06 	vfma.f64	d0, d4, d6
    5444:	ee33 7b40 	vsub.f64	d7, d3, d0
    5448:	eea4 7b06 	vfma.f64	d7, d4, d6
    544c:	ee95 7b02 	vfnms.f64	d7, d5, d2
    5450:	e7b3      	b.n	53ba <__ieee754_rem_pio2+0x14a>
    5452:	492d      	ldr	r1, [pc, #180]	; (5508 <__ieee754_rem_pio2+0x298>)
    5454:	ee30 7b07 	vadd.f64	d7, d0, d7
    5458:	428e      	cmp	r6, r1
    545a:	d01e      	beq.n	549a <__ieee754_rem_pio2+0x22a>
    545c:	ed9f 6b16 	vldr	d6, [pc, #88]	; 54b8 <__ieee754_rem_pio2+0x248>
    5460:	ee37 5b06 	vadd.f64	d5, d7, d6
    5464:	ee37 7b45 	vsub.f64	d7, d7, d5
    5468:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    546c:	ee37 7b06 	vadd.f64	d7, d7, d6
    5470:	ed80 5b00 	vstr	d5, [r0]
    5474:	ed80 7b02 	vstr	d7, [r0, #8]
    5478:	e76d      	b.n	5356 <__ieee754_rem_pio2+0xe6>
    547a:	ed94 6b00 	vldr	d6, [r4]
    547e:	ed94 7b02 	vldr	d7, [r4, #8]
    5482:	eeb1 6b46 	vneg.f64	d6, d6
    5486:	eeb1 7b47 	vneg.f64	d7, d7
    548a:	4243      	negs	r3, r0
    548c:	ed84 6b00 	vstr	d6, [r4]
    5490:	ed84 7b02 	vstr	d7, [r4, #8]
    5494:	e75f      	b.n	5356 <__ieee754_rem_pio2+0xe6>
    5496:	2303      	movs	r3, #3
    5498:	e749      	b.n	532e <__ieee754_rem_pio2+0xbe>
    549a:	ed9f 5b0b 	vldr	d5, [pc, #44]	; 54c8 <__ieee754_rem_pio2+0x258>
    549e:	ed9f 6b0c 	vldr	d6, [pc, #48]	; 54d0 <__ieee754_rem_pio2+0x260>
    54a2:	ee37 7b05 	vadd.f64	d7, d7, d5
    54a6:	e7db      	b.n	5460 <__ieee754_rem_pio2+0x1f0>
    54a8:	eeb0 0b43 	vmov.f64	d0, d3
    54ac:	e789      	b.n	53c2 <__ieee754_rem_pio2+0x152>
    54ae:	bf00      	nop
    54b0:	54400000 	.word	0x54400000
    54b4:	3ff921fb 	.word	0x3ff921fb
    54b8:	1a626331 	.word	0x1a626331
    54bc:	3dd0b461 	.word	0x3dd0b461
    54c0:	00000000 	.word	0x00000000
    54c4:	41700000 	.word	0x41700000
    54c8:	1a600000 	.word	0x1a600000
    54cc:	3dd0b461 	.word	0x3dd0b461
    54d0:	2e037073 	.word	0x2e037073
    54d4:	3ba3198a 	.word	0x3ba3198a
    54d8:	6dc9c883 	.word	0x6dc9c883
    54dc:	3fe45f30 	.word	0x3fe45f30
    54e0:	2e000000 	.word	0x2e000000
    54e4:	3ba3198a 	.word	0x3ba3198a
    54e8:	252049c1 	.word	0x252049c1
    54ec:	397b839a 	.word	0x397b839a
    54f0:	3fe921fb 	.word	0x3fe921fb
    54f4:	4002d97b 	.word	0x4002d97b
    54f8:	413921fb 	.word	0x413921fb
    54fc:	7fefffff 	.word	0x7fefffff
    5500:	20000e8c 	.word	0x20000e8c
    5504:	20000a64 	.word	0x20000a64
    5508:	3ff921fb 	.word	0x3ff921fb

0000550c <__ieee754_sqrt>:
    550c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5510:	b082      	sub	sp, #8
    5512:	ed8d 0b00 	vstr	d0, [sp]
    5516:	495d      	ldr	r1, [pc, #372]	; (568c <__ieee754_sqrt+0x180>)
    5518:	9b01      	ldr	r3, [sp, #4]
    551a:	9800      	ldr	r0, [sp, #0]
    551c:	460c      	mov	r4, r1
    551e:	4019      	ands	r1, r3
    5520:	42a1      	cmp	r1, r4
    5522:	f000 8098 	beq.w	5656 <__ieee754_sqrt+0x14a>
    5526:	2b00      	cmp	r3, #0
    5528:	4602      	mov	r2, r0
    552a:	dd77      	ble.n	561c <__ieee754_sqrt+0x110>
    552c:	151f      	asrs	r7, r3, #20
    552e:	f000 8082 	beq.w	5636 <__ieee754_sqrt+0x12a>
    5532:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
    5536:	f3c3 0313 	ubfx	r3, r3, #0, #20
    553a:	07f9      	lsls	r1, r7, #31
    553c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    5540:	d467      	bmi.n	5612 <__ieee754_sqrt+0x106>
    5542:	eb03 71d2 	add.w	r1, r3, r2, lsr #31
    5546:	2600      	movs	r6, #0
    5548:	440b      	add	r3, r1
    554a:	107f      	asrs	r7, r7, #1
    554c:	0052      	lsls	r2, r2, #1
    554e:	46b6      	mov	lr, r6
    5550:	2016      	movs	r0, #22
    5552:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    5556:	eb0e 0401 	add.w	r4, lr, r1
    555a:	429c      	cmp	r4, r3
    555c:	ea4f 75d2 	mov.w	r5, r2, lsr #31
    5560:	ea4f 0242 	mov.w	r2, r2, lsl #1
    5564:	dc03      	bgt.n	556e <__ieee754_sqrt+0x62>
    5566:	1b1b      	subs	r3, r3, r4
    5568:	eb04 0e01 	add.w	lr, r4, r1
    556c:	440e      	add	r6, r1
    556e:	3801      	subs	r0, #1
    5570:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    5574:	ea4f 0151 	mov.w	r1, r1, lsr #1
    5578:	d1ed      	bne.n	5556 <__ieee754_sqrt+0x4a>
    557a:	4684      	mov	ip, r0
    557c:	2420      	movs	r4, #32
    557e:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    5582:	e009      	b.n	5598 <__ieee754_sqrt+0x8c>
    5584:	d020      	beq.n	55c8 <__ieee754_sqrt+0xbc>
    5586:	eb03 75d2 	add.w	r5, r3, r2, lsr #31
    558a:	3c01      	subs	r4, #1
    558c:	ea4f 0151 	mov.w	r1, r1, lsr #1
    5590:	442b      	add	r3, r5
    5592:	ea4f 0242 	mov.w	r2, r2, lsl #1
    5596:	d020      	beq.n	55da <__ieee754_sqrt+0xce>
    5598:	459e      	cmp	lr, r3
    559a:	eb01 050c 	add.w	r5, r1, ip
    559e:	daf1      	bge.n	5584 <__ieee754_sqrt+0x78>
    55a0:	2d00      	cmp	r5, #0
    55a2:	eb05 0c01 	add.w	ip, r5, r1
    55a6:	db09      	blt.n	55bc <__ieee754_sqrt+0xb0>
    55a8:	46f0      	mov	r8, lr
    55aa:	4295      	cmp	r5, r2
    55ac:	ebce 0303 	rsb	r3, lr, r3
    55b0:	d900      	bls.n	55b4 <__ieee754_sqrt+0xa8>
    55b2:	3b01      	subs	r3, #1
    55b4:	1b52      	subs	r2, r2, r5
    55b6:	4408      	add	r0, r1
    55b8:	46c6      	mov	lr, r8
    55ba:	e7e4      	b.n	5586 <__ieee754_sqrt+0x7a>
    55bc:	f1bc 0f00 	cmp.w	ip, #0
    55c0:	dbf2      	blt.n	55a8 <__ieee754_sqrt+0x9c>
    55c2:	f10e 0801 	add.w	r8, lr, #1
    55c6:	e7f0      	b.n	55aa <__ieee754_sqrt+0x9e>
    55c8:	4295      	cmp	r5, r2
    55ca:	d81a      	bhi.n	5602 <__ieee754_sqrt+0xf6>
    55cc:	2d00      	cmp	r5, #0
    55ce:	eb05 0c01 	add.w	ip, r5, r1
    55d2:	db48      	blt.n	5666 <__ieee754_sqrt+0x15a>
    55d4:	4698      	mov	r8, r3
    55d6:	2300      	movs	r3, #0
    55d8:	e7ec      	b.n	55b4 <__ieee754_sqrt+0xa8>
    55da:	4313      	orrs	r3, r2
    55dc:	d113      	bne.n	5606 <__ieee754_sqrt+0xfa>
    55de:	0840      	lsrs	r0, r0, #1
    55e0:	1071      	asrs	r1, r6, #1
    55e2:	07f3      	lsls	r3, r6, #31
    55e4:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
    55e8:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
    55ec:	bf48      	it	mi
    55ee:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
    55f2:	eb01 5307 	add.w	r3, r1, r7, lsl #20
    55f6:	4602      	mov	r2, r0
    55f8:	ec43 2b10 	vmov	d0, r2, r3
    55fc:	b002      	add	sp, #8
    55fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5602:	4673      	mov	r3, lr
    5604:	e7bf      	b.n	5586 <__ieee754_sqrt+0x7a>
    5606:	1c42      	adds	r2, r0, #1
    5608:	d031      	beq.n	566e <__ieee754_sqrt+0x162>
    560a:	f000 0301 	and.w	r3, r0, #1
    560e:	4418      	add	r0, r3
    5610:	e7e5      	b.n	55de <__ieee754_sqrt+0xd2>
    5612:	005b      	lsls	r3, r3, #1
    5614:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
    5618:	0052      	lsls	r2, r2, #1
    561a:	e792      	b.n	5542 <__ieee754_sqrt+0x36>
    561c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    5620:	4301      	orrs	r1, r0
    5622:	d01d      	beq.n	5660 <__ieee754_sqrt+0x154>
    5624:	bb5b      	cbnz	r3, 567e <__ieee754_sqrt+0x172>
    5626:	461f      	mov	r7, r3
    5628:	0ad3      	lsrs	r3, r2, #11
    562a:	3f15      	subs	r7, #21
    562c:	0552      	lsls	r2, r2, #21
    562e:	2b00      	cmp	r3, #0
    5630:	d0fa      	beq.n	5628 <__ieee754_sqrt+0x11c>
    5632:	02dd      	lsls	r5, r3, #11
    5634:	d41e      	bmi.n	5674 <__ieee754_sqrt+0x168>
    5636:	2100      	movs	r1, #0
    5638:	e000      	b.n	563c <__ieee754_sqrt+0x130>
    563a:	4601      	mov	r1, r0
    563c:	005b      	lsls	r3, r3, #1
    563e:	02dc      	lsls	r4, r3, #11
    5640:	f101 0001 	add.w	r0, r1, #1
    5644:	d5f9      	bpl.n	563a <__ieee754_sqrt+0x12e>
    5646:	f1c0 0420 	rsb	r4, r0, #32
    564a:	fa22 f404 	lsr.w	r4, r2, r4
    564e:	4323      	orrs	r3, r4
    5650:	1a7f      	subs	r7, r7, r1
    5652:	4082      	lsls	r2, r0
    5654:	e76d      	b.n	5532 <__ieee754_sqrt+0x26>
    5656:	eea0 0b00 	vfma.f64	d0, d0, d0
    565a:	b002      	add	sp, #8
    565c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5660:	ed9d 0b00 	vldr	d0, [sp]
    5664:	e7ca      	b.n	55fc <__ieee754_sqrt+0xf0>
    5666:	f1bc 0f00 	cmp.w	ip, #0
    566a:	daaa      	bge.n	55c2 <__ieee754_sqrt+0xb6>
    566c:	e7b2      	b.n	55d4 <__ieee754_sqrt+0xc8>
    566e:	3601      	adds	r6, #1
    5670:	4620      	mov	r0, r4
    5672:	e7b5      	b.n	55e0 <__ieee754_sqrt+0xd4>
    5674:	2420      	movs	r4, #32
    5676:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    567a:	2000      	movs	r0, #0
    567c:	e7e5      	b.n	564a <__ieee754_sqrt+0x13e>
    567e:	ed9d 7b00 	vldr	d7, [sp]
    5682:	ee37 7b47 	vsub.f64	d7, d7, d7
    5686:	ee87 0b07 	vdiv.f64	d0, d7, d7
    568a:	e7b7      	b.n	55fc <__ieee754_sqrt+0xf0>
    568c:	7ff00000 	.word	0x7ff00000

00005690 <__kernel_cos>:
    5690:	ee10 3a90 	vmov	r3, s1
    5694:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5698:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
    569c:	da2c      	bge.n	56f8 <__kernel_cos+0x68>
    569e:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    56a2:	ee17 3a90 	vmov	r3, s15
    56a6:	2b00      	cmp	r3, #0
    56a8:	d061      	beq.n	576e <__kernel_cos+0xde>
    56aa:	ee20 7b00 	vmul.f64	d7, d0, d0
    56ae:	ed9f 4b32 	vldr	d4, [pc, #200]	; 5778 <__kernel_cos+0xe8>
    56b2:	ed9f 5b33 	vldr	d5, [pc, #204]	; 5780 <__kernel_cos+0xf0>
    56b6:	ed9f 6b34 	vldr	d6, [pc, #208]	; 5788 <__kernel_cos+0xf8>
    56ba:	eea7 5b04 	vfma.f64	d5, d7, d4
    56be:	ed9f 4b34 	vldr	d4, [pc, #208]	; 5790 <__kernel_cos+0x100>
    56c2:	eea7 6b05 	vfma.f64	d6, d7, d5
    56c6:	ed9f 5b34 	vldr	d5, [pc, #208]	; 5798 <__kernel_cos+0x108>
    56ca:	eea7 4b06 	vfma.f64	d4, d7, d6
    56ce:	ed9f 6b34 	vldr	d6, [pc, #208]	; 57a0 <__kernel_cos+0x110>
    56d2:	eea7 5b04 	vfma.f64	d5, d7, d4
    56d6:	eea7 6b05 	vfma.f64	d6, d7, d5
    56da:	ee26 6b07 	vmul.f64	d6, d6, d7
    56de:	ee21 0b40 	vnmul.f64	d0, d1, d0
    56e2:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
    56e6:	eea7 0b06 	vfma.f64	d0, d7, d6
    56ea:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    56ee:	ee97 0b05 	vfnms.f64	d0, d7, d5
    56f2:	ee36 0b40 	vsub.f64	d0, d6, d0
    56f6:	4770      	bx	lr
    56f8:	ed9f 4b1f 	vldr	d4, [pc, #124]	; 5778 <__kernel_cos+0xe8>
    56fc:	ee20 7b00 	vmul.f64	d7, d0, d0
    5700:	ed9f 5b1f 	vldr	d5, [pc, #124]	; 5780 <__kernel_cos+0xf0>
    5704:	ed9f 6b20 	vldr	d6, [pc, #128]	; 5788 <__kernel_cos+0xf8>
    5708:	eea7 5b04 	vfma.f64	d5, d7, d4
    570c:	ed9f 4b20 	vldr	d4, [pc, #128]	; 5790 <__kernel_cos+0x100>
    5710:	eea7 6b05 	vfma.f64	d6, d7, d5
    5714:	4a24      	ldr	r2, [pc, #144]	; (57a8 <__kernel_cos+0x118>)
    5716:	eea7 4b06 	vfma.f64	d4, d7, d6
    571a:	ed9f 5b1f 	vldr	d5, [pc, #124]	; 5798 <__kernel_cos+0x108>
    571e:	ed9f 6b20 	vldr	d6, [pc, #128]	; 57a0 <__kernel_cos+0x110>
    5722:	eea7 5b04 	vfma.f64	d5, d7, d4
    5726:	4293      	cmp	r3, r2
    5728:	eea7 6b05 	vfma.f64	d6, d7, d5
    572c:	ee26 6b07 	vmul.f64	d6, d6, d7
    5730:	ddd5      	ble.n	56de <__kernel_cos+0x4e>
    5732:	4a1e      	ldr	r2, [pc, #120]	; (57ac <__kernel_cos+0x11c>)
    5734:	4293      	cmp	r3, r2
    5736:	dc15      	bgt.n	5764 <__kernel_cos+0xd4>
    5738:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
    573c:	2000      	movs	r0, #0
    573e:	f5a3 1100 	sub.w	r1, r3, #2097152	; 0x200000
    5742:	ec41 0b15 	vmov	d5, r0, r1
    5746:	ee34 4b45 	vsub.f64	d4, d4, d5
    574a:	ee21 1b40 	vnmul.f64	d1, d1, d0
    574e:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    5752:	eea7 1b06 	vfma.f64	d1, d7, d6
    5756:	ee97 5b03 	vfnms.f64	d5, d7, d3
    575a:	ee35 5b41 	vsub.f64	d5, d5, d1
    575e:	ee34 0b45 	vsub.f64	d0, d4, d5
    5762:	4770      	bx	lr
    5764:	eeb6 4b07 	vmov.f64	d4, #103	; 0x3f380000  0.7187500
    5768:	eeb5 5b02 	vmov.f64	d5, #82	; 0x3e900000  0.2812500
    576c:	e7ed      	b.n	574a <__kernel_cos+0xba>
    576e:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    5772:	4770      	bx	lr
    5774:	f3af 8000 	nop.w
    5778:	be8838d4 	.word	0xbe8838d4
    577c:	bda8fae9 	.word	0xbda8fae9
    5780:	bdb4b1c4 	.word	0xbdb4b1c4
    5784:	3e21ee9e 	.word	0x3e21ee9e
    5788:	809c52ad 	.word	0x809c52ad
    578c:	be927e4f 	.word	0xbe927e4f
    5790:	19cb1590 	.word	0x19cb1590
    5794:	3efa01a0 	.word	0x3efa01a0
    5798:	16c15177 	.word	0x16c15177
    579c:	bf56c16c 	.word	0xbf56c16c
    57a0:	5555554c 	.word	0x5555554c
    57a4:	3fa55555 	.word	0x3fa55555
    57a8:	3fd33332 	.word	0x3fd33332
    57ac:	3fe90000 	.word	0x3fe90000

000057b0 <__kernel_rem_pio2>:
    57b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    57b4:	ed2d 8b08 	vpush	{d8-d11}
    57b8:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
    57bc:	4cb0      	ldr	r4, [pc, #704]	; (5a80 <__kernel_rem_pio2+0x2d0>)
    57be:	9ea4      	ldr	r6, [sp, #656]	; 0x290
    57c0:	4db0      	ldr	r5, [pc, #704]	; (5a84 <__kernel_rem_pio2+0x2d4>)
    57c2:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
    57c6:	9301      	str	r3, [sp, #4]
    57c8:	1ed4      	subs	r4, r2, #3
    57ca:	fb85 7504 	smull	r7, r5, r5, r4
    57ce:	17e4      	asrs	r4, r4, #31
    57d0:	ebc4 04a5 	rsb	r4, r4, r5, asr #2
    57d4:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
    57d8:	1e5f      	subs	r7, r3, #1
    57da:	f104 0a01 	add.w	sl, r4, #1
    57de:	ebaa 0a8a 	sub.w	sl, sl, sl, lsl #2
    57e2:	468b      	mov	fp, r1
    57e4:	19f1      	adds	r1, r6, r7
    57e6:	9402      	str	r4, [sp, #8]
    57e8:	4681      	mov	r9, r0
    57ea:	eb02 0aca 	add.w	sl, r2, sl, lsl #3
    57ee:	eba4 0307 	sub.w	r3, r4, r7
    57f2:	d418      	bmi.n	5826 <__kernel_rem_pio2+0x76>
    57f4:	4419      	add	r1, r3
    57f6:	3101      	adds	r1, #1
    57f8:	aa1a      	add	r2, sp, #104	; 0x68
    57fa:	98a5      	ldr	r0, [sp, #660]	; 0x294
    57fc:	e00a      	b.n	5814 <__kernel_rem_pio2+0x64>
    57fe:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    5802:	ee07 4a90 	vmov	s15, r4
    5806:	3301      	adds	r3, #1
    5808:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    580c:	428b      	cmp	r3, r1
    580e:	eca2 7b02 	vstmia	r2!, {d7}
    5812:	d008      	beq.n	5826 <__kernel_rem_pio2+0x76>
    5814:	2b00      	cmp	r3, #0
    5816:	daf2      	bge.n	57fe <__kernel_rem_pio2+0x4e>
    5818:	ed9f 7b93 	vldr	d7, [pc, #588]	; 5a68 <__kernel_rem_pio2+0x2b8>
    581c:	3301      	adds	r3, #1
    581e:	428b      	cmp	r3, r1
    5820:	eca2 7b02 	vstmia	r2!, {d7}
    5824:	d1f6      	bne.n	5814 <__kernel_rem_pio2+0x64>
    5826:	2e00      	cmp	r6, #0
    5828:	f2c0 82e2 	blt.w	5df0 <__kernel_rem_pio2+0x640>
    582c:	9b01      	ldr	r3, [sp, #4]
    582e:	a86a      	add	r0, sp, #424	; 0x1a8
    5830:	f106 0e01 	add.w	lr, r6, #1
    5834:	00dc      	lsls	r4, r3, #3
    5836:	eb00 0ece 	add.w	lr, r0, lr, lsl #3
    583a:	eb09 0104 	add.w	r1, r9, r4
    583e:	463d      	mov	r5, r7
    5840:	2f00      	cmp	r7, #0
    5842:	f2c0 81c8 	blt.w	5bd6 <__kernel_rem_pio2+0x426>
    5846:	ab1a      	add	r3, sp, #104	; 0x68
    5848:	ed9f 7b87 	vldr	d7, [pc, #540]	; 5a68 <__kernel_rem_pio2+0x2b8>
    584c:	eb03 02c5 	add.w	r2, r3, r5, lsl #3
    5850:	3208      	adds	r2, #8
    5852:	464b      	mov	r3, r9
    5854:	ecb3 5b02 	vldmia	r3!, {d5}
    5858:	ed32 6b02 	vldmdb	r2!, {d6}
    585c:	428b      	cmp	r3, r1
    585e:	eea5 7b06 	vfma.f64	d7, d5, d6
    5862:	d1f7      	bne.n	5854 <__kernel_rem_pio2+0xa4>
    5864:	eca0 7b02 	vstmia	r0!, {d7}
    5868:	4570      	cmp	r0, lr
    586a:	f105 0501 	add.w	r5, r5, #1
    586e:	d1e7      	bne.n	5840 <__kernel_rem_pio2+0x90>
    5870:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
    5874:	3b02      	subs	r3, #2
    5876:	009b      	lsls	r3, r3, #2
    5878:	aa06      	add	r2, sp, #24
    587a:	ed9f 9b7d 	vldr	d9, [pc, #500]	; 5a70 <__kernel_rem_pio2+0x2c0>
    587e:	ed9f 8b7e 	vldr	d8, [pc, #504]	; 5a78 <__kernel_rem_pio2+0x2c8>
    5882:	f103 0804 	add.w	r8, r3, #4
    5886:	4413      	add	r3, r2
    5888:	444c      	add	r4, r9
    588a:	4490      	add	r8, r2
    588c:	9303      	str	r3, [sp, #12]
    588e:	4635      	mov	r5, r6
    5890:	f8cd b010 	str.w	fp, [sp, #16]
    5894:	ab92      	add	r3, sp, #584	; 0x248
    5896:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    589a:	2d00      	cmp	r5, #0
    589c:	ed13 0b28 	vldr	d0, [r3, #-160]	; 0xffffff60
    58a0:	dd17      	ble.n	58d2 <__kernel_rem_pio2+0x122>
    58a2:	a96a      	add	r1, sp, #424	; 0x1a8
    58a4:	eb01 03c5 	add.w	r3, r1, r5, lsl #3
    58a8:	aa05      	add	r2, sp, #20
    58aa:	ee20 7b09 	vmul.f64	d7, d0, d9
    58ae:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    58b2:	ed33 6b02 	vldmdb	r3!, {d6}
    58b6:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    58ba:	eea7 0b48 	vfms.f64	d0, d7, d8
    58be:	eefd 5bc0 	vcvt.s32.f64	s11, d0
    58c2:	428b      	cmp	r3, r1
    58c4:	ee15 0a90 	vmov	r0, s11
    58c8:	ee37 0b06 	vadd.f64	d0, d7, d6
    58cc:	f842 0f04 	str.w	r0, [r2, #4]!
    58d0:	d1eb      	bne.n	58aa <__kernel_rem_pio2+0xfa>
    58d2:	4650      	mov	r0, sl
    58d4:	f000 fca0 	bl	6218 <scalbn>
    58d8:	eeb0 ab40 	vmov.f64	d10, d0
    58dc:	eeb4 0b00 	vmov.f64	d0, #64	; 0x3e000000  0.125
    58e0:	ee2a 0b00 	vmul.f64	d0, d10, d0
    58e4:	f000 fc08 	bl	60f8 <floor>
    58e8:	eeb2 7b00 	vmov.f64	d7, #32	; 0x41000000  8.0
    58ec:	eea0 ab47 	vfms.f64	d10, d0, d7
    58f0:	eefd 7bca 	vcvt.s32.f64	s15, d10
    58f4:	f1ba 0f00 	cmp.w	sl, #0
    58f8:	ee17 ba90 	vmov	fp, s15
    58fc:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    5900:	ee3a ab47 	vsub.f64	d10, d10, d7
    5904:	f340 814c 	ble.w	5ba0 <__kernel_rem_pio2+0x3f0>
    5908:	f105 3eff 	add.w	lr, r5, #4294967295	; 0xffffffff
    590c:	ab06      	add	r3, sp, #24
    590e:	f1ca 0218 	rsb	r2, sl, #24
    5912:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
    5916:	fa43 f002 	asr.w	r0, r3, r2
    591a:	fa00 f202 	lsl.w	r2, r0, r2
    591e:	a906      	add	r1, sp, #24
    5920:	1a9b      	subs	r3, r3, r2
    5922:	f1ca 0217 	rsb	r2, sl, #23
    5926:	f841 302e 	str.w	r3, [r1, lr, lsl #2]
    592a:	4483      	add	fp, r0
    592c:	fa43 f102 	asr.w	r1, r3, r2
    5930:	2900      	cmp	r1, #0
    5932:	dd39      	ble.n	59a8 <__kernel_rem_pio2+0x1f8>
    5934:	2d00      	cmp	r5, #0
    5936:	f10b 0b01 	add.w	fp, fp, #1
    593a:	f340 8224 	ble.w	5d86 <__kernel_rem_pio2+0x5d6>
    593e:	2200      	movs	r2, #0
    5940:	4610      	mov	r0, r2
    5942:	f10d 0e14 	add.w	lr, sp, #20
    5946:	468c      	mov	ip, r1
    5948:	e008      	b.n	595c <__kernel_rem_pio2+0x1ac>
    594a:	f1c3 7180 	rsb	r1, r3, #16777216	; 0x1000000
    594e:	b113      	cbz	r3, 5956 <__kernel_rem_pio2+0x1a6>
    5950:	f8ce 1000 	str.w	r1, [lr]
    5954:	2001      	movs	r0, #1
    5956:	3201      	adds	r2, #1
    5958:	4295      	cmp	r5, r2
    595a:	dd0e      	ble.n	597a <__kernel_rem_pio2+0x1ca>
    595c:	f85e 3f04 	ldr.w	r3, [lr, #4]!
    5960:	2800      	cmp	r0, #0
    5962:	d0f2      	beq.n	594a <__kernel_rem_pio2+0x19a>
    5964:	f1c3 13ff 	rsb	r3, r3, #16711935	; 0xff00ff
    5968:	3201      	adds	r2, #1
    596a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    596e:	4295      	cmp	r5, r2
    5970:	f8ce 3000 	str.w	r3, [lr]
    5974:	f04f 0001 	mov.w	r0, #1
    5978:	dcf0      	bgt.n	595c <__kernel_rem_pio2+0x1ac>
    597a:	4661      	mov	r1, ip
    597c:	f1ba 0f00 	cmp.w	sl, #0
    5980:	dd10      	ble.n	59a4 <__kernel_rem_pio2+0x1f4>
    5982:	f1ba 0f01 	cmp.w	sl, #1
    5986:	f000 8112 	beq.w	5bae <__kernel_rem_pio2+0x3fe>
    598a:	f1ba 0f02 	cmp.w	sl, #2
    598e:	d109      	bne.n	59a4 <__kernel_rem_pio2+0x1f4>
    5990:	1e6a      	subs	r2, r5, #1
    5992:	ab06      	add	r3, sp, #24
    5994:	f10d 0e18 	add.w	lr, sp, #24
    5998:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    599c:	f3c3 0315 	ubfx	r3, r3, #0, #22
    59a0:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    59a4:	2902      	cmp	r1, #2
    59a6:	d06f      	beq.n	5a88 <__kernel_rem_pio2+0x2d8>
    59a8:	eeb5 ab40 	vcmp.f64	d10, #0.0
    59ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    59b0:	d17c      	bne.n	5aac <__kernel_rem_pio2+0x2fc>
    59b2:	f105 3eff 	add.w	lr, r5, #4294967295	; 0xffffffff
    59b6:	4576      	cmp	r6, lr
    59b8:	dc0f      	bgt.n	59da <__kernel_rem_pio2+0x22a>
    59ba:	f105 4280 	add.w	r2, r5, #1073741824	; 0x40000000
    59be:	3a01      	subs	r2, #1
    59c0:	ab06      	add	r3, sp, #24
    59c2:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    59c6:	2000      	movs	r0, #0
    59c8:	f852 3904 	ldr.w	r3, [r2], #-4
    59cc:	4542      	cmp	r2, r8
    59ce:	ea40 0003 	orr.w	r0, r0, r3
    59d2:	d1f9      	bne.n	59c8 <__kernel_rem_pio2+0x218>
    59d4:	2800      	cmp	r0, #0
    59d6:	f040 8115 	bne.w	5c04 <__kernel_rem_pio2+0x454>
    59da:	1e73      	subs	r3, r6, #1
    59dc:	aa06      	add	r2, sp, #24
    59de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    59e2:	2b00      	cmp	r3, #0
    59e4:	f040 81cc 	bne.w	5d80 <__kernel_rem_pio2+0x5d0>
    59e8:	9b03      	ldr	r3, [sp, #12]
    59ea:	f04f 0e01 	mov.w	lr, #1
    59ee:	f853 2904 	ldr.w	r2, [r3], #-4
    59f2:	f10e 0e01 	add.w	lr, lr, #1
    59f6:	2a00      	cmp	r2, #0
    59f8:	d0f9      	beq.n	59ee <__kernel_rem_pio2+0x23e>
    59fa:	44ae      	add	lr, r5
    59fc:	1c6b      	adds	r3, r5, #1
    59fe:	4573      	cmp	r3, lr
    5a00:	dc2d      	bgt.n	5a5e <__kernel_rem_pio2+0x2ae>
    5a02:	9a02      	ldr	r2, [sp, #8]
    5a04:	1898      	adds	r0, r3, r2
    5a06:	9a01      	ldr	r2, [sp, #4]
    5a08:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5a0c:	1951      	adds	r1, r2, r5
    5a0e:	eb0e 0c02 	add.w	ip, lr, r2
    5a12:	9aa5      	ldr	r2, [sp, #660]	; 0x294
    5a14:	3801      	subs	r0, #1
    5a16:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    5a1a:	aa1a      	add	r2, sp, #104	; 0x68
    5a1c:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
    5a20:	eb02 0ccc 	add.w	ip, r2, ip, lsl #3
    5a24:	aa6a      	add	r2, sp, #424	; 0x1a8
    5a26:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
    5a2a:	f850 3f04 	ldr.w	r3, [r0, #4]!
    5a2e:	ee07 3a10 	vmov	s14, r3
    5a32:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    5a36:	2f00      	cmp	r7, #0
    5a38:	eca1 7b02 	vstmia	r1!, {d7}
    5a3c:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 5a68 <__kernel_rem_pio2+0x2b8>
    5a40:	db09      	blt.n	5a56 <__kernel_rem_pio2+0x2a6>
    5a42:	464b      	mov	r3, r9
    5a44:	460a      	mov	r2, r1
    5a46:	ecb3 5b02 	vldmia	r3!, {d5}
    5a4a:	ed32 6b02 	vldmdb	r2!, {d6}
    5a4e:	42a3      	cmp	r3, r4
    5a50:	eea5 7b06 	vfma.f64	d7, d5, d6
    5a54:	d1f7      	bne.n	5a46 <__kernel_rem_pio2+0x296>
    5a56:	4561      	cmp	r1, ip
    5a58:	eca5 7b02 	vstmia	r5!, {d7}
    5a5c:	d1e5      	bne.n	5a2a <__kernel_rem_pio2+0x27a>
    5a5e:	4675      	mov	r5, lr
    5a60:	e718      	b.n	5894 <__kernel_rem_pio2+0xe4>
    5a62:	bf00      	nop
    5a64:	f3af 8000 	nop.w
	...
    5a74:	3e700000 	.word	0x3e700000
    5a78:	00000000 	.word	0x00000000
    5a7c:	41700000 	.word	0x41700000
    5a80:	20000a54 	.word	0x20000a54
    5a84:	2aaaaaab 	.word	0x2aaaaaab
    5a88:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    5a8c:	ee30 ab4a 	vsub.f64	d10, d0, d10
    5a90:	2800      	cmp	r0, #0
    5a92:	d089      	beq.n	59a8 <__kernel_rem_pio2+0x1f8>
    5a94:	4650      	mov	r0, sl
    5a96:	9105      	str	r1, [sp, #20]
    5a98:	f000 fbbe 	bl	6218 <scalbn>
    5a9c:	ee3a ab40 	vsub.f64	d10, d10, d0
    5aa0:	eeb5 ab40 	vcmp.f64	d10, #0.0
    5aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5aa8:	9905      	ldr	r1, [sp, #20]
    5aaa:	d082      	beq.n	59b2 <__kernel_rem_pio2+0x202>
    5aac:	eeb0 0b4a 	vmov.f64	d0, d10
    5ab0:	f1ca 0000 	rsb	r0, sl, #0
    5ab4:	ee0b ba10 	vmov	s22, fp
    5ab8:	4689      	mov	r9, r1
    5aba:	f8dd b010 	ldr.w	fp, [sp, #16]
    5abe:	f000 fbab 	bl	6218 <scalbn>
    5ac2:	ed9f 6bd1 	vldr	d6, [pc, #836]	; 5e08 <__kernel_rem_pio2+0x658>
    5ac6:	eeb4 0bc6 	vcmpe.f64	d0, d6
    5aca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5ace:	f2c0 8172 	blt.w	5db6 <__kernel_rem_pio2+0x606>
    5ad2:	ed9f 7bcf 	vldr	d7, [pc, #828]	; 5e10 <__kernel_rem_pio2+0x660>
    5ad6:	ee20 7b07 	vmul.f64	d7, d0, d7
    5ada:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    5ade:	a906      	add	r1, sp, #24
    5ae0:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
    5ae4:	eea5 0b46 	vfms.f64	d0, d5, d6
    5ae8:	eebd 0bc0 	vcvt.s32.f64	s0, d0
    5aec:	1c6b      	adds	r3, r5, #1
    5aee:	ee10 2a10 	vmov	r2, s0
    5af2:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    5af6:	ee17 2a10 	vmov	r2, s14
    5afa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    5afe:	f10a 0a18 	add.w	sl, sl, #24
    5b02:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    5b06:	4650      	mov	r0, sl
    5b08:	9301      	str	r3, [sp, #4]
    5b0a:	f000 fb85 	bl	6218 <scalbn>
    5b0e:	9b01      	ldr	r3, [sp, #4]
    5b10:	2b00      	cmp	r3, #0
    5b12:	f2c0 815e 	blt.w	5dd2 <__kernel_rem_pio2+0x622>
    5b16:	ac6a      	add	r4, sp, #424	; 0x1a8
    5b18:	00df      	lsls	r7, r3, #3
    5b1a:	aa06      	add	r2, sp, #24
    5b1c:	ed9f 6bbc 	vldr	d6, [pc, #752]	; 5e10 <__kernel_rem_pio2+0x660>
    5b20:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    5b24:	eb04 0c07 	add.w	ip, r4, r7
    5b28:	3204      	adds	r2, #4
    5b2a:	f10c 0008 	add.w	r0, ip, #8
    5b2e:	ed32 7a01 	vldmdb	r2!, {s14}
    5b32:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    5b36:	ee27 7b00 	vmul.f64	d7, d7, d0
    5b3a:	ed20 7b02 	vstmdb	r0!, {d7}
    5b3e:	ee20 0b06 	vmul.f64	d0, d0, d6
    5b42:	42a0      	cmp	r0, r4
    5b44:	d1f3      	bne.n	5b2e <__kernel_rem_pio2+0x37e>
    5b46:	f50d 78d0 	add.w	r8, sp, #416	; 0x1a0
    5b4a:	2500      	movs	r5, #0
    5b4c:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    5b50:	2e00      	cmp	r6, #0
    5b52:	f2c0 8112 	blt.w	5d7a <__kernel_rem_pio2+0x5ca>
    5b56:	48b4      	ldr	r0, [pc, #720]	; (5e28 <__kernel_rem_pio2+0x678>)
    5b58:	4661      	mov	r1, ip
    5b5a:	ed9f 6baf 	vldr	d6, [pc, #700]	; 5e18 <__kernel_rem_pio2+0x668>
    5b5e:	ed9f 7bb0 	vldr	d7, [pc, #704]	; 5e20 <__kernel_rem_pio2+0x670>
    5b62:	2200      	movs	r2, #0
    5b64:	e003      	b.n	5b6e <__kernel_rem_pio2+0x3be>
    5b66:	4295      	cmp	r5, r2
    5b68:	db08      	blt.n	5b7c <__kernel_rem_pio2+0x3cc>
    5b6a:	ecb0 6b02 	vldmia	r0!, {d6}
    5b6e:	ecb1 5b02 	vldmia	r1!, {d5}
    5b72:	3201      	adds	r2, #1
    5b74:	4296      	cmp	r6, r2
    5b76:	eea5 7b06 	vfma.f64	d7, d5, d6
    5b7a:	daf4      	bge.n	5b66 <__kernel_rem_pio2+0x3b6>
    5b7c:	f1ac 0c08 	sub.w	ip, ip, #8
    5b80:	eb0e 02c5 	add.w	r2, lr, r5, lsl #3
    5b84:	45c4      	cmp	ip, r8
    5b86:	ed82 7b00 	vstr	d7, [r2]
    5b8a:	f105 0501 	add.w	r5, r5, #1
    5b8e:	d1df      	bne.n	5b50 <__kernel_rem_pio2+0x3a0>
    5b90:	9aa4      	ldr	r2, [sp, #656]	; 0x290
    5b92:	2a03      	cmp	r2, #3
    5b94:	f200 80ad 	bhi.w	5cf2 <__kernel_rem_pio2+0x542>
    5b98:	e8df f002 	tbb	[pc, r2]
    5b9c:	50b5b5dd 	.word	0x50b5b5dd
    5ba0:	d110      	bne.n	5bc4 <__kernel_rem_pio2+0x414>
    5ba2:	1e6b      	subs	r3, r5, #1
    5ba4:	aa06      	add	r2, sp, #24
    5ba6:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    5baa:	15c9      	asrs	r1, r1, #23
    5bac:	e6c0      	b.n	5930 <__kernel_rem_pio2+0x180>
    5bae:	1e6a      	subs	r2, r5, #1
    5bb0:	ab06      	add	r3, sp, #24
    5bb2:	f10d 0e18 	add.w	lr, sp, #24
    5bb6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5bba:	f3c3 0316 	ubfx	r3, r3, #0, #23
    5bbe:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    5bc2:	e6ef      	b.n	59a4 <__kernel_rem_pio2+0x1f4>
    5bc4:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    5bc8:	eeb4 abc7 	vcmpe.f64	d10, d7
    5bcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5bd0:	da0b      	bge.n	5bea <__kernel_rem_pio2+0x43a>
    5bd2:	2100      	movs	r1, #0
    5bd4:	e6e8      	b.n	59a8 <__kernel_rem_pio2+0x1f8>
    5bd6:	ed9f 7b92 	vldr	d7, [pc, #584]	; 5e20 <__kernel_rem_pio2+0x670>
    5bda:	eca0 7b02 	vstmia	r0!, {d7}
    5bde:	4570      	cmp	r0, lr
    5be0:	f105 0501 	add.w	r5, r5, #1
    5be4:	f47f ae2c 	bne.w	5840 <__kernel_rem_pio2+0x90>
    5be8:	e642      	b.n	5870 <__kernel_rem_pio2+0xc0>
    5bea:	2d00      	cmp	r5, #0
    5bec:	f10b 0b01 	add.w	fp, fp, #1
    5bf0:	bfc8      	it	gt
    5bf2:	2102      	movgt	r1, #2
    5bf4:	f73f aea3 	bgt.w	593e <__kernel_rem_pio2+0x18e>
    5bf8:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    5bfc:	2102      	movs	r1, #2
    5bfe:	ee37 ab4a 	vsub.f64	d10, d7, d10
    5c02:	e6d1      	b.n	59a8 <__kernel_rem_pio2+0x1f8>
    5c04:	aa06      	add	r2, sp, #24
    5c06:	ee0b ba10 	vmov	s22, fp
    5c0a:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
    5c0e:	f8dd b010 	ldr.w	fp, [sp, #16]
    5c12:	4673      	mov	r3, lr
    5c14:	4689      	mov	r9, r1
    5c16:	f1aa 0a18 	sub.w	sl, sl, #24
    5c1a:	2a00      	cmp	r2, #0
    5c1c:	f47f af71 	bne.w	5b02 <__kernel_rem_pio2+0x352>
    5c20:	f10e 4280 	add.w	r2, lr, #1073741824	; 0x40000000
    5c24:	3a01      	subs	r2, #1
    5c26:	a906      	add	r1, sp, #24
    5c28:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    5c2c:	f852 1904 	ldr.w	r1, [r2], #-4
    5c30:	3b01      	subs	r3, #1
    5c32:	f1aa 0a18 	sub.w	sl, sl, #24
    5c36:	2900      	cmp	r1, #0
    5c38:	d0f8      	beq.n	5c2c <__kernel_rem_pio2+0x47c>
    5c3a:	e762      	b.n	5b02 <__kernel_rem_pio2+0x352>
    5c3c:	2b00      	cmp	r3, #0
    5c3e:	f340 80c5 	ble.w	5dcc <__kernel_rem_pio2+0x61c>
    5c42:	f103 5200 	add.w	r2, r3, #536870912	; 0x20000000
    5c46:	3a01      	subs	r2, #1
    5c48:	eb0e 0407 	add.w	r4, lr, r7
    5c4c:	00d0      	lsls	r0, r2, #3
    5c4e:	ed94 7b00 	vldr	d7, [r4]
    5c52:	f100 0408 	add.w	r4, r0, #8
    5c56:	3010      	adds	r0, #16
    5c58:	4474      	add	r4, lr
    5c5a:	4470      	add	r0, lr
    5c5c:	ad44      	add	r5, sp, #272	; 0x110
    5c5e:	ed34 6b02 	vldmdb	r4!, {d6}
    5c62:	ee36 5b07 	vadd.f64	d5, d6, d7
    5c66:	ee36 6b45 	vsub.f64	d6, d6, d5
    5c6a:	ee36 7b07 	vadd.f64	d7, d6, d7
    5c6e:	ed20 7b02 	vstmdb	r0!, {d7}
    5c72:	eeb0 7b45 	vmov.f64	d7, d5
    5c76:	42a8      	cmp	r0, r5
    5c78:	ed84 5b00 	vstr	d5, [r4]
    5c7c:	d1ef      	bne.n	5c5e <__kernel_rem_pio2+0x4ae>
    5c7e:	2b01      	cmp	r3, #1
    5c80:	f340 80a4 	ble.w	5dcc <__kernel_rem_pio2+0x61c>
    5c84:	00d2      	lsls	r2, r2, #3
    5c86:	4477      	add	r7, lr
    5c88:	f102 0010 	add.w	r0, r2, #16
    5c8c:	ed97 7b00 	vldr	d7, [r7]
    5c90:	3208      	adds	r2, #8
    5c92:	4470      	add	r0, lr
    5c94:	eb0e 0302 	add.w	r3, lr, r2
    5c98:	ac46      	add	r4, sp, #280	; 0x118
    5c9a:	4602      	mov	r2, r0
    5c9c:	ed33 6b02 	vldmdb	r3!, {d6}
    5ca0:	ee37 5b06 	vadd.f64	d5, d7, d6
    5ca4:	ee36 6b45 	vsub.f64	d6, d6, d5
    5ca8:	ee36 7b07 	vadd.f64	d7, d6, d7
    5cac:	ed22 7b02 	vstmdb	r2!, {d7}
    5cb0:	eeb0 7b45 	vmov.f64	d7, d5
    5cb4:	4294      	cmp	r4, r2
    5cb6:	ed83 5b00 	vstr	d5, [r3]
    5cba:	d1ef      	bne.n	5c9c <__kernel_rem_pio2+0x4ec>
    5cbc:	ed9f 7b58 	vldr	d7, [pc, #352]	; 5e20 <__kernel_rem_pio2+0x670>
    5cc0:	ed30 6b02 	vldmdb	r0!, {d6}
    5cc4:	4284      	cmp	r4, r0
    5cc6:	ee37 7b06 	vadd.f64	d7, d7, d6
    5cca:	d1f9      	bne.n	5cc0 <__kernel_rem_pio2+0x510>
    5ccc:	464b      	mov	r3, r9
    5cce:	2b00      	cmp	r3, #0
    5cd0:	d066      	beq.n	5da0 <__kernel_rem_pio2+0x5f0>
    5cd2:	eeb1 7b47 	vneg.f64	d7, d7
    5cd6:	ed9e 5b00 	vldr	d5, [lr]
    5cda:	ed9e 6b02 	vldr	d6, [lr, #8]
    5cde:	eeb1 5b45 	vneg.f64	d5, d5
    5ce2:	ed8b 5b00 	vstr	d5, [fp]
    5ce6:	ed8b 7b04 	vstr	d7, [fp, #16]
    5cea:	eeb1 7b46 	vneg.f64	d7, d6
    5cee:	ed8b 7b02 	vstr	d7, [fp, #8]
    5cf2:	ee1b 3a10 	vmov	r3, s22
    5cf6:	f003 0007 	and.w	r0, r3, #7
    5cfa:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
    5cfe:	ecbd 8b08 	vpop	{d8-d11}
    5d02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5d06:	ed9f 7b46 	vldr	d7, [pc, #280]	; 5e20 <__kernel_rem_pio2+0x670>
    5d0a:	f107 0208 	add.w	r2, r7, #8
    5d0e:	4472      	add	r2, lr
    5d10:	ed32 6b02 	vldmdb	r2!, {d6}
    5d14:	4572      	cmp	r2, lr
    5d16:	ee37 7b06 	vadd.f64	d7, d7, d6
    5d1a:	d1f9      	bne.n	5d10 <__kernel_rem_pio2+0x560>
    5d1c:	464a      	mov	r2, r9
    5d1e:	b3a2      	cbz	r2, 5d8a <__kernel_rem_pio2+0x5da>
    5d20:	eeb1 5b47 	vneg.f64	d5, d7
    5d24:	ed9e 6b00 	vldr	d6, [lr]
    5d28:	2b00      	cmp	r3, #0
    5d2a:	ed8b 5b00 	vstr	d5, [fp]
    5d2e:	ee36 7b47 	vsub.f64	d7, d6, d7
    5d32:	dd0b      	ble.n	5d4c <__kernel_rem_pio2+0x59c>
    5d34:	a844      	add	r0, sp, #272	; 0x110
    5d36:	2201      	movs	r2, #1
    5d38:	ecb0 6b02 	vldmia	r0!, {d6}
    5d3c:	3201      	adds	r2, #1
    5d3e:	4293      	cmp	r3, r2
    5d40:	ee37 7b06 	vadd.f64	d7, d7, d6
    5d44:	daf8      	bge.n	5d38 <__kernel_rem_pio2+0x588>
    5d46:	464b      	mov	r3, r9
    5d48:	2b00      	cmp	r3, #0
    5d4a:	d0d0      	beq.n	5cee <__kernel_rem_pio2+0x53e>
    5d4c:	eeb1 7b47 	vneg.f64	d7, d7
    5d50:	ed8b 7b02 	vstr	d7, [fp, #8]
    5d54:	e7cd      	b.n	5cf2 <__kernel_rem_pio2+0x542>
    5d56:	ed9f 7b32 	vldr	d7, [pc, #200]	; 5e20 <__kernel_rem_pio2+0x670>
    5d5a:	3708      	adds	r7, #8
    5d5c:	44be      	add	lr, r7
    5d5e:	ed3e 6b02 	vldmdb	lr!, {d6}
    5d62:	3b01      	subs	r3, #1
    5d64:	1c5a      	adds	r2, r3, #1
    5d66:	ee37 7b06 	vadd.f64	d7, d7, d6
    5d6a:	d1f8      	bne.n	5d5e <__kernel_rem_pio2+0x5ae>
    5d6c:	464b      	mov	r3, r9
    5d6e:	b10b      	cbz	r3, 5d74 <__kernel_rem_pio2+0x5c4>
    5d70:	eeb1 7b47 	vneg.f64	d7, d7
    5d74:	ed8b 7b00 	vstr	d7, [fp]
    5d78:	e7bb      	b.n	5cf2 <__kernel_rem_pio2+0x542>
    5d7a:	ed9f 7b29 	vldr	d7, [pc, #164]	; 5e20 <__kernel_rem_pio2+0x670>
    5d7e:	e6fd      	b.n	5b7c <__kernel_rem_pio2+0x3cc>
    5d80:	f04f 0e01 	mov.w	lr, #1
    5d84:	e639      	b.n	59fa <__kernel_rem_pio2+0x24a>
    5d86:	2000      	movs	r0, #0
    5d88:	e5f8      	b.n	597c <__kernel_rem_pio2+0x1cc>
    5d8a:	ed9e 6b00 	vldr	d6, [lr]
    5d8e:	2b00      	cmp	r3, #0
    5d90:	ed8b 7b00 	vstr	d7, [fp]
    5d94:	ee36 7b47 	vsub.f64	d7, d6, d7
    5d98:	dccc      	bgt.n	5d34 <__kernel_rem_pio2+0x584>
    5d9a:	ed8b 7b02 	vstr	d7, [fp, #8]
    5d9e:	e7a8      	b.n	5cf2 <__kernel_rem_pio2+0x542>
    5da0:	e9de 0100 	ldrd	r0, r1, [lr]
    5da4:	e9de 2302 	ldrd	r2, r3, [lr, #8]
    5da8:	ed8b 7b04 	vstr	d7, [fp, #16]
    5dac:	e9cb 0100 	strd	r0, r1, [fp]
    5db0:	e9cb 2302 	strd	r2, r3, [fp, #8]
    5db4:	e79d      	b.n	5cf2 <__kernel_rem_pio2+0x542>
    5db6:	eebd 0bc0 	vcvt.s32.f64	s0, d0
    5dba:	a906      	add	r1, sp, #24
    5dbc:	ee10 2a10 	vmov	r2, s0
    5dc0:	462b      	mov	r3, r5
    5dc2:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    5dc6:	e69c      	b.n	5b02 <__kernel_rem_pio2+0x352>
    5dc8:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    5dcc:	ed9f 7b14 	vldr	d7, [pc, #80]	; 5e20 <__kernel_rem_pio2+0x670>
    5dd0:	e77c      	b.n	5ccc <__kernel_rem_pio2+0x51c>
    5dd2:	9aa4      	ldr	r2, [sp, #656]	; 0x290
    5dd4:	2a03      	cmp	r2, #3
    5dd6:	d88c      	bhi.n	5cf2 <__kernel_rem_pio2+0x542>
    5dd8:	a101      	add	r1, pc, #4	; (adr r1, 5de0 <__kernel_rem_pio2+0x630>)
    5dda:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    5dde:	bf00      	nop
    5de0:	00005e01 	.word	0x00005e01
    5de4:	00005df7 	.word	0x00005df7
    5de8:	00005df7 	.word	0x00005df7
    5dec:	00005dc9 	.word	0x00005dc9
    5df0:	9b01      	ldr	r3, [sp, #4]
    5df2:	00dc      	lsls	r4, r3, #3
    5df4:	e53c      	b.n	5870 <__kernel_rem_pio2+0xc0>
    5df6:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 5e20 <__kernel_rem_pio2+0x670>
    5dfa:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    5dfe:	e78d      	b.n	5d1c <__kernel_rem_pio2+0x56c>
    5e00:	ed9f 7b07 	vldr	d7, [pc, #28]	; 5e20 <__kernel_rem_pio2+0x670>
    5e04:	e7b2      	b.n	5d6c <__kernel_rem_pio2+0x5bc>
    5e06:	bf00      	nop
    5e08:	00000000 	.word	0x00000000
    5e0c:	41700000 	.word	0x41700000
    5e10:	00000000 	.word	0x00000000
    5e14:	3e700000 	.word	0x3e700000
    5e18:	40000000 	.word	0x40000000
    5e1c:	3ff921fb 	.word	0x3ff921fb
	...
    5e28:	20000288 	.word	0x20000288
    5e2c:	00000000 	.word	0x00000000

00005e30 <__kernel_sin>:
    5e30:	ee10 3a90 	vmov	r3, s1
    5e34:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5e38:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
    5e3c:	da04      	bge.n	5e48 <__kernel_sin+0x18>
    5e3e:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    5e42:	ee17 3a90 	vmov	r3, s15
    5e46:	b323      	cbz	r3, 5e92 <__kernel_sin+0x62>
    5e48:	ee20 7b00 	vmul.f64	d7, d0, d0
    5e4c:	ee20 4b07 	vmul.f64	d4, d0, d7
    5e50:	ed9f 5b15 	vldr	d5, [pc, #84]	; 5ea8 <__kernel_sin+0x78>
    5e54:	ed9f 6b16 	vldr	d6, [pc, #88]	; 5eb0 <__kernel_sin+0x80>
    5e58:	ed9f 3b17 	vldr	d3, [pc, #92]	; 5eb8 <__kernel_sin+0x88>
    5e5c:	eea7 6b05 	vfma.f64	d6, d7, d5
    5e60:	ed9f 5b17 	vldr	d5, [pc, #92]	; 5ec0 <__kernel_sin+0x90>
    5e64:	eea7 3b06 	vfma.f64	d3, d7, d6
    5e68:	ed9f 6b17 	vldr	d6, [pc, #92]	; 5ec8 <__kernel_sin+0x98>
    5e6c:	eea7 5b03 	vfma.f64	d5, d7, d3
    5e70:	eea7 6b05 	vfma.f64	d6, d7, d5
    5e74:	b170      	cbz	r0, 5e94 <__kernel_sin+0x64>
    5e76:	ee26 6b44 	vnmul.f64	d6, d6, d4
    5e7a:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    5e7e:	ed9f 5b14 	vldr	d5, [pc, #80]	; 5ed0 <__kernel_sin+0xa0>
    5e82:	eea1 6b03 	vfma.f64	d6, d1, d3
    5e86:	ee97 1b06 	vfnms.f64	d1, d7, d6
    5e8a:	eea4 1b05 	vfma.f64	d1, d4, d5
    5e8e:	ee30 0b41 	vsub.f64	d0, d0, d1
    5e92:	4770      	bx	lr
    5e94:	ed9f 5b10 	vldr	d5, [pc, #64]	; 5ed8 <__kernel_sin+0xa8>
    5e98:	eea7 5b06 	vfma.f64	d5, d7, d6
    5e9c:	eea4 0b05 	vfma.f64	d0, d4, d5
    5ea0:	4770      	bx	lr
    5ea2:	bf00      	nop
    5ea4:	f3af 8000 	nop.w
    5ea8:	5acfd57c 	.word	0x5acfd57c
    5eac:	3de5d93a 	.word	0x3de5d93a
    5eb0:	8a2b9ceb 	.word	0x8a2b9ceb
    5eb4:	be5ae5e6 	.word	0xbe5ae5e6
    5eb8:	57b1fe7d 	.word	0x57b1fe7d
    5ebc:	3ec71de3 	.word	0x3ec71de3
    5ec0:	19c161d5 	.word	0x19c161d5
    5ec4:	bf2a01a0 	.word	0xbf2a01a0
    5ec8:	1110f8a6 	.word	0x1110f8a6
    5ecc:	3f811111 	.word	0x3f811111
    5ed0:	55555549 	.word	0x55555549
    5ed4:	3fc55555 	.word	0x3fc55555
    5ed8:	55555549 	.word	0x55555549
    5edc:	bfc55555 	.word	0xbfc55555

00005ee0 <atan>:
    5ee0:	b538      	push	{r3, r4, r5, lr}
    5ee2:	eeb0 7b40 	vmov.f64	d7, d0
    5ee6:	ee17 5a90 	vmov	r5, s15
    5eea:	4b77      	ldr	r3, [pc, #476]	; (60c8 <atan+0x1e8>)
    5eec:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
    5ef0:	429c      	cmp	r4, r3
    5ef2:	dd0e      	ble.n	5f12 <atan+0x32>
    5ef4:	4b75      	ldr	r3, [pc, #468]	; (60cc <atan+0x1ec>)
    5ef6:	429c      	cmp	r4, r3
    5ef8:	ee10 2a10 	vmov	r2, s0
    5efc:	dc5c      	bgt.n	5fb8 <atan+0xd8>
    5efe:	d059      	beq.n	5fb4 <atan+0xd4>
    5f00:	ed9f 7b55 	vldr	d7, [pc, #340]	; 6058 <atan+0x178>
    5f04:	ed9f 0b56 	vldr	d0, [pc, #344]	; 6060 <atan+0x180>
    5f08:	2d00      	cmp	r5, #0
    5f0a:	bfc8      	it	gt
    5f0c:	eeb0 0b47 	vmovgt.f64	d0, d7
    5f10:	bd38      	pop	{r3, r4, r5, pc}
    5f12:	4b6f      	ldr	r3, [pc, #444]	; (60d0 <atan+0x1f0>)
    5f14:	429c      	cmp	r4, r3
    5f16:	dc60      	bgt.n	5fda <atan+0xfa>
    5f18:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
    5f1c:	429c      	cmp	r4, r3
    5f1e:	dd4e      	ble.n	5fbe <atan+0xde>
    5f20:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5f24:	ed9f 2b50 	vldr	d2, [pc, #320]	; 6068 <atan+0x188>
    5f28:	ee27 4b07 	vmul.f64	d4, d7, d7
    5f2c:	ee24 6b04 	vmul.f64	d6, d4, d4
    5f30:	ed9f 3b4f 	vldr	d3, [pc, #316]	; 6070 <atan+0x190>
    5f34:	ed9f 5b50 	vldr	d5, [pc, #320]	; 6078 <atan+0x198>
    5f38:	eea6 3b02 	vfma.f64	d3, d6, d2
    5f3c:	ed9f 2b50 	vldr	d2, [pc, #320]	; 6080 <atan+0x1a0>
    5f40:	eea6 5b03 	vfma.f64	d5, d6, d3
    5f44:	ed9f 3b50 	vldr	d3, [pc, #320]	; 6088 <atan+0x1a8>
    5f48:	eea6 2b05 	vfma.f64	d2, d6, d5
    5f4c:	ed9f 5b50 	vldr	d5, [pc, #320]	; 6090 <atan+0x1b0>
    5f50:	eea6 3b02 	vfma.f64	d3, d6, d2
    5f54:	ed9f 1b50 	vldr	d1, [pc, #320]	; 6098 <atan+0x1b8>
    5f58:	eea6 5b03 	vfma.f64	d5, d6, d3
    5f5c:	ee25 5b04 	vmul.f64	d5, d5, d4
    5f60:	ed9f 2b4f 	vldr	d2, [pc, #316]	; 60a0 <atan+0x1c0>
    5f64:	ed9f 4b50 	vldr	d4, [pc, #320]	; 60a8 <atan+0x1c8>
    5f68:	ed9f 3b51 	vldr	d3, [pc, #324]	; 60b0 <atan+0x1d0>
    5f6c:	eea6 4b01 	vfma.f64	d4, d6, d1
    5f70:	eea6 2b04 	vfma.f64	d2, d6, d4
    5f74:	ed9f 4b50 	vldr	d4, [pc, #320]	; 60b8 <atan+0x1d8>
    5f78:	eea6 3b02 	vfma.f64	d3, d6, d2
    5f7c:	1c5a      	adds	r2, r3, #1
    5f7e:	eea6 4b03 	vfma.f64	d4, d6, d3
    5f82:	ee24 6b06 	vmul.f64	d6, d4, d6
    5f86:	d040      	beq.n	600a <atan+0x12a>
    5f88:	ee35 5b06 	vadd.f64	d5, d5, d6
    5f8c:	4a51      	ldr	r2, [pc, #324]	; (60d4 <atan+0x1f4>)
    5f8e:	4952      	ldr	r1, [pc, #328]	; (60d8 <atan+0x1f8>)
    5f90:	00db      	lsls	r3, r3, #3
    5f92:	441a      	add	r2, r3
    5f94:	440b      	add	r3, r1
    5f96:	ed92 6b00 	vldr	d6, [r2]
    5f9a:	ed93 0b00 	vldr	d0, [r3]
    5f9e:	ee97 6b05 	vfnms.f64	d6, d7, d5
    5fa2:	ee36 7b47 	vsub.f64	d7, d6, d7
    5fa6:	2d00      	cmp	r5, #0
    5fa8:	ee30 7b47 	vsub.f64	d7, d0, d7
    5fac:	db2a      	blt.n	6004 <atan+0x124>
    5fae:	eeb0 0b47 	vmov.f64	d0, d7
    5fb2:	bd38      	pop	{r3, r4, r5, pc}
    5fb4:	2a00      	cmp	r2, #0
    5fb6:	d0a3      	beq.n	5f00 <atan+0x20>
    5fb8:	ee37 0b07 	vadd.f64	d0, d7, d7
    5fbc:	bd38      	pop	{r3, r4, r5, pc}
    5fbe:	ed9f 6b40 	vldr	d6, [pc, #256]	; 60c0 <atan+0x1e0>
    5fc2:	eeb7 5b00 	vmov.f64	d5, #112	; 0x3f800000  1.0
    5fc6:	ee30 6b06 	vadd.f64	d6, d0, d6
    5fca:	eeb4 6bc5 	vcmpe.f64	d6, d5
    5fce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5fd2:	dda5      	ble.n	5f20 <atan+0x40>
    5fd4:	eeb0 0b47 	vmov.f64	d0, d7
    5fd8:	bd38      	pop	{r3, r4, r5, pc}
    5fda:	f000 f883 	bl	60e4 <fabs>
    5fde:	4b3f      	ldr	r3, [pc, #252]	; (60dc <atan+0x1fc>)
    5fe0:	429c      	cmp	r4, r3
    5fe2:	dc19      	bgt.n	6018 <atan+0x138>
    5fe4:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
    5fe8:	429c      	cmp	r4, r3
    5fea:	dc2a      	bgt.n	6042 <atan+0x162>
    5fec:	eeb0 7b00 	vmov.f64	d7, #0	; 0x40000000  2.0
    5ff0:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
    5ff4:	ee30 5b07 	vadd.f64	d5, d0, d7
    5ff8:	eea0 6b07 	vfma.f64	d6, d0, d7
    5ffc:	2300      	movs	r3, #0
    5ffe:	ee86 7b05 	vdiv.f64	d7, d6, d5
    6002:	e78f      	b.n	5f24 <atan+0x44>
    6004:	eeb1 0b47 	vneg.f64	d0, d7
    6008:	bd38      	pop	{r3, r4, r5, pc}
    600a:	ee35 6b06 	vadd.f64	d6, d5, d6
    600e:	eea7 7b46 	vfms.f64	d7, d7, d6
    6012:	eeb0 0b47 	vmov.f64	d0, d7
    6016:	bd38      	pop	{r3, r4, r5, pc}
    6018:	4b31      	ldr	r3, [pc, #196]	; (60e0 <atan+0x200>)
    601a:	429c      	cmp	r4, r3
    601c:	dc0b      	bgt.n	6036 <atan+0x156>
    601e:	eeb7 7b08 	vmov.f64	d7, #120	; 0x3fc00000  1.5
    6022:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    6026:	ee30 5b47 	vsub.f64	d5, d0, d7
    602a:	eea0 6b07 	vfma.f64	d6, d0, d7
    602e:	2302      	movs	r3, #2
    6030:	ee85 7b06 	vdiv.f64	d7, d5, d6
    6034:	e776      	b.n	5f24 <atan+0x44>
    6036:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
    603a:	2303      	movs	r3, #3
    603c:	ee86 7b00 	vdiv.f64	d7, d6, d0
    6040:	e770      	b.n	5f24 <atan+0x44>
    6042:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    6046:	2301      	movs	r3, #1
    6048:	ee30 6b47 	vsub.f64	d6, d0, d7
    604c:	ee30 0b07 	vadd.f64	d0, d0, d7
    6050:	ee86 7b00 	vdiv.f64	d7, d6, d0
    6054:	e766      	b.n	5f24 <atan+0x44>
    6056:	bf00      	nop
    6058:	54442d18 	.word	0x54442d18
    605c:	3ff921fb 	.word	0x3ff921fb
    6060:	54442d18 	.word	0x54442d18
    6064:	bff921fb 	.word	0xbff921fb
    6068:	e322da11 	.word	0xe322da11
    606c:	3f90ad3a 	.word	0x3f90ad3a
    6070:	24760deb 	.word	0x24760deb
    6074:	3fa97b4b 	.word	0x3fa97b4b
    6078:	a0d03d51 	.word	0xa0d03d51
    607c:	3fb10d66 	.word	0x3fb10d66
    6080:	c54c206e 	.word	0xc54c206e
    6084:	3fb745cd 	.word	0x3fb745cd
    6088:	920083ff 	.word	0x920083ff
    608c:	3fc24924 	.word	0x3fc24924
    6090:	5555550d 	.word	0x5555550d
    6094:	3fd55555 	.word	0x3fd55555
    6098:	2c6a6c2f 	.word	0x2c6a6c2f
    609c:	bfa2b444 	.word	0xbfa2b444
    60a0:	af749a6d 	.word	0xaf749a6d
    60a4:	bfb3b0f2 	.word	0xbfb3b0f2
    60a8:	52defd9a 	.word	0x52defd9a
    60ac:	bfadde2d 	.word	0xbfadde2d
    60b0:	fe231671 	.word	0xfe231671
    60b4:	bfbc71c6 	.word	0xbfbc71c6
    60b8:	9998ebc4 	.word	0x9998ebc4
    60bc:	bfc99999 	.word	0xbfc99999
    60c0:	8800759c 	.word	0x8800759c
    60c4:	7e37e43c 	.word	0x7e37e43c
    60c8:	440fffff 	.word	0x440fffff
    60cc:	7ff00000 	.word	0x7ff00000
    60d0:	3fdbffff 	.word	0x3fdbffff
    60d4:	200003d0 	.word	0x200003d0
    60d8:	200003b0 	.word	0x200003b0
    60dc:	3ff2ffff 	.word	0x3ff2ffff
    60e0:	40037fff 	.word	0x40037fff

000060e4 <fabs>:
    60e4:	ec53 2b10 	vmov	r2, r3, d0
    60e8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    60ec:	ec43 2b10 	vmov	d0, r2, r3
    60f0:	4770      	bx	lr
    60f2:	bf00      	nop
    60f4:	0000      	movs	r0, r0
	...

000060f8 <floor>:
    60f8:	b470      	push	{r4, r5, r6}
    60fa:	b083      	sub	sp, #12
    60fc:	ed8d 0b00 	vstr	d0, [sp]
    6100:	9901      	ldr	r1, [sp, #4]
    6102:	9c00      	ldr	r4, [sp, #0]
    6104:	f3c1 520a 	ubfx	r2, r1, #20, #11
    6108:	f2a2 33ff 	subw	r3, r2, #1023	; 0x3ff
    610c:	2b13      	cmp	r3, #19
    610e:	460d      	mov	r5, r1
    6110:	4620      	mov	r0, r4
    6112:	dc1e      	bgt.n	6152 <floor+0x5a>
    6114:	2b00      	cmp	r3, #0
    6116:	db43      	blt.n	61a0 <floor+0xa8>
    6118:	4a3b      	ldr	r2, [pc, #236]	; (6208 <floor+0x110>)
    611a:	411a      	asrs	r2, r3
    611c:	ea01 0602 	and.w	r6, r1, r2
    6120:	4334      	orrs	r4, r6
    6122:	d01b      	beq.n	615c <floor+0x64>
    6124:	ed9f 7b36 	vldr	d7, [pc, #216]	; 6200 <floor+0x108>
    6128:	ed9d 6b00 	vldr	d6, [sp]
    612c:	ee36 7b07 	vadd.f64	d7, d6, d7
    6130:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    6134:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    6138:	dd04      	ble.n	6144 <floor+0x4c>
    613a:	2900      	cmp	r1, #0
    613c:	db43      	blt.n	61c6 <floor+0xce>
    613e:	ea25 0102 	bic.w	r1, r5, r2
    6142:	2000      	movs	r0, #0
    6144:	460b      	mov	r3, r1
    6146:	4602      	mov	r2, r0
    6148:	ec43 2b10 	vmov	d0, r2, r3
    614c:	b003      	add	sp, #12
    614e:	bc70      	pop	{r4, r5, r6}
    6150:	4770      	bx	lr
    6152:	2b33      	cmp	r3, #51	; 0x33
    6154:	dd07      	ble.n	6166 <floor+0x6e>
    6156:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    615a:	d02f      	beq.n	61bc <floor+0xc4>
    615c:	ed9d 0b00 	vldr	d0, [sp]
    6160:	b003      	add	sp, #12
    6162:	bc70      	pop	{r4, r5, r6}
    6164:	4770      	bx	lr
    6166:	f2a2 4213 	subw	r2, r2, #1043	; 0x413
    616a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    616e:	fa24 f202 	lsr.w	r2, r4, r2
    6172:	4210      	tst	r0, r2
    6174:	d0f2      	beq.n	615c <floor+0x64>
    6176:	ed9f 7b22 	vldr	d7, [pc, #136]	; 6200 <floor+0x108>
    617a:	ed9d 6b00 	vldr	d6, [sp]
    617e:	ee36 7b07 	vadd.f64	d7, d6, d7
    6182:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    6186:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    618a:	dddb      	ble.n	6144 <floor+0x4c>
    618c:	2900      	cmp	r1, #0
    618e:	db20      	blt.n	61d2 <floor+0xda>
    6190:	4629      	mov	r1, r5
    6192:	ea20 0002 	bic.w	r0, r0, r2
    6196:	460b      	mov	r3, r1
    6198:	4602      	mov	r2, r0
    619a:	ec43 2b10 	vmov	d0, r2, r3
    619e:	e7d5      	b.n	614c <floor+0x54>
    61a0:	ed9f 7b17 	vldr	d7, [pc, #92]	; 6200 <floor+0x108>
    61a4:	ee30 7b07 	vadd.f64	d7, d0, d7
    61a8:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    61ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    61b0:	ddc8      	ble.n	6144 <floor+0x4c>
    61b2:	2900      	cmp	r1, #0
    61b4:	db18      	blt.n	61e8 <floor+0xf0>
    61b6:	2000      	movs	r0, #0
    61b8:	4601      	mov	r1, r0
    61ba:	e7c3      	b.n	6144 <floor+0x4c>
    61bc:	ed9d 7b00 	vldr	d7, [sp]
    61c0:	ee37 0b07 	vadd.f64	d0, d7, d7
    61c4:	e7cc      	b.n	6160 <floor+0x68>
    61c6:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    61ca:	fa41 f303 	asr.w	r3, r1, r3
    61ce:	441d      	add	r5, r3
    61d0:	e7b5      	b.n	613e <floor+0x46>
    61d2:	2b14      	cmp	r3, #20
    61d4:	d010      	beq.n	61f8 <floor+0x100>
    61d6:	2101      	movs	r1, #1
    61d8:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
    61dc:	fa01 f303 	lsl.w	r3, r1, r3
    61e0:	1818      	adds	r0, r3, r0
    61e2:	bf28      	it	cs
    61e4:	186d      	addcs	r5, r5, r1
    61e6:	e7d3      	b.n	6190 <floor+0x98>
    61e8:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
    61ec:	4b07      	ldr	r3, [pc, #28]	; (620c <floor+0x114>)
    61ee:	4322      	orrs	r2, r4
    61f0:	bf18      	it	ne
    61f2:	4619      	movne	r1, r3
    61f4:	2000      	movs	r0, #0
    61f6:	e7a5      	b.n	6144 <floor+0x4c>
    61f8:	3501      	adds	r5, #1
    61fa:	e7c9      	b.n	6190 <floor+0x98>
    61fc:	f3af 8000 	nop.w
    6200:	8800759c 	.word	0x8800759c
    6204:	7e37e43c 	.word	0x7e37e43c
    6208:	000fffff 	.word	0x000fffff
    620c:	bff00000 	.word	0xbff00000

00006210 <matherr>:
    6210:	2000      	movs	r0, #0
    6212:	4770      	bx	lr
    6214:	0000      	movs	r0, r0
	...

00006218 <scalbn>:
    6218:	b510      	push	{r4, lr}
    621a:	ed2d 8b02 	vpush	{d8}
    621e:	b082      	sub	sp, #8
    6220:	ed8d 0b00 	vstr	d0, [sp]
    6224:	9b01      	ldr	r3, [sp, #4]
    6226:	9900      	ldr	r1, [sp, #0]
    6228:	f3c3 520a 	ubfx	r2, r3, #20, #11
    622c:	bb2a      	cbnz	r2, 627a <scalbn+0x62>
    622e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    6232:	430b      	orrs	r3, r1
    6234:	d02d      	beq.n	6292 <scalbn+0x7a>
    6236:	ed9f 7b36 	vldr	d7, [pc, #216]	; 6310 <scalbn+0xf8>
    623a:	4a3d      	ldr	r2, [pc, #244]	; (6330 <scalbn+0x118>)
    623c:	ee20 7b07 	vmul.f64	d7, d0, d7
    6240:	4290      	cmp	r0, r2
    6242:	ed8d 7b00 	vstr	d7, [sp]
    6246:	9b01      	ldr	r3, [sp, #4]
    6248:	db29      	blt.n	629e <scalbn+0x86>
    624a:	f3c3 520a 	ubfx	r2, r3, #20, #11
    624e:	3a36      	subs	r2, #54	; 0x36
    6250:	1884      	adds	r4, r0, r2
    6252:	f240 72fe 	movw	r2, #2046	; 0x7fe
    6256:	4294      	cmp	r4, r2
    6258:	dc30      	bgt.n	62bc <scalbn+0xa4>
    625a:	2c00      	cmp	r4, #0
    625c:	dd27      	ble.n	62ae <scalbn+0x96>
    625e:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
    6262:	e9dd 2300 	ldrd	r2, r3, [sp]
    6266:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    626a:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    626e:	ec43 2b10 	vmov	d0, r2, r3
    6272:	b002      	add	sp, #8
    6274:	ecbd 8b02 	vpop	{d8}
    6278:	bd10      	pop	{r4, pc}
    627a:	f240 71ff 	movw	r1, #2047	; 0x7ff
    627e:	428a      	cmp	r2, r1
    6280:	d1e6      	bne.n	6250 <scalbn+0x38>
    6282:	ed9d 7b00 	vldr	d7, [sp]
    6286:	ee37 0b07 	vadd.f64	d0, d7, d7
    628a:	b002      	add	sp, #8
    628c:	ecbd 8b02 	vpop	{d8}
    6290:	bd10      	pop	{r4, pc}
    6292:	ed9d 0b00 	vldr	d0, [sp]
    6296:	b002      	add	sp, #8
    6298:	ecbd 8b02 	vpop	{d8}
    629c:	bd10      	pop	{r4, pc}
    629e:	ed9f 0b1e 	vldr	d0, [pc, #120]	; 6318 <scalbn+0x100>
    62a2:	ee27 0b00 	vmul.f64	d0, d7, d0
    62a6:	b002      	add	sp, #8
    62a8:	ecbd 8b02 	vpop	{d8}
    62ac:	bd10      	pop	{r4, pc}
    62ae:	f114 0f35 	cmn.w	r4, #53	; 0x35
    62b2:	da11      	bge.n	62d8 <scalbn+0xc0>
    62b4:	f24c 3350 	movw	r3, #50000	; 0xc350
    62b8:	4298      	cmp	r0, r3
    62ba:	dd1d      	ble.n	62f8 <scalbn+0xe0>
    62bc:	ed9f 8b18 	vldr	d8, [pc, #96]	; 6320 <scalbn+0x108>
    62c0:	ed9d 1b00 	vldr	d1, [sp]
    62c4:	eeb0 0b48 	vmov.f64	d0, d8
    62c8:	f000 f834 	bl	6334 <copysign>
    62cc:	ee20 0b08 	vmul.f64	d0, d0, d8
    62d0:	b002      	add	sp, #8
    62d2:	ecbd 8b02 	vpop	{d8}
    62d6:	bd10      	pop	{r4, pc}
    62d8:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
    62dc:	e9dd 2300 	ldrd	r2, r3, [sp]
    62e0:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    62e4:	3436      	adds	r4, #54	; 0x36
    62e6:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    62ea:	ed9f 0b0f 	vldr	d0, [pc, #60]	; 6328 <scalbn+0x110>
    62ee:	ec43 2b17 	vmov	d7, r2, r3
    62f2:	ee27 0b00 	vmul.f64	d0, d7, d0
    62f6:	e7bc      	b.n	6272 <scalbn+0x5a>
    62f8:	ed9f 8b07 	vldr	d8, [pc, #28]	; 6318 <scalbn+0x100>
    62fc:	ed9d 1b00 	vldr	d1, [sp]
    6300:	eeb0 0b48 	vmov.f64	d0, d8
    6304:	f000 f816 	bl	6334 <copysign>
    6308:	ee20 0b08 	vmul.f64	d0, d0, d8
    630c:	e7b1      	b.n	6272 <scalbn+0x5a>
    630e:	bf00      	nop
    6310:	00000000 	.word	0x00000000
    6314:	43500000 	.word	0x43500000
    6318:	c2f8f359 	.word	0xc2f8f359
    631c:	01a56e1f 	.word	0x01a56e1f
    6320:	8800759c 	.word	0x8800759c
    6324:	7e37e43c 	.word	0x7e37e43c
    6328:	00000000 	.word	0x00000000
    632c:	3c900000 	.word	0x3c900000
    6330:	ffff3cb0 	.word	0xffff3cb0

00006334 <copysign>:
    6334:	ec53 2b10 	vmov	r2, r3, d0
    6338:	ee11 0a90 	vmov	r0, s3
    633c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    6340:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    6344:	ea41 0300 	orr.w	r3, r1, r0
    6348:	ec43 2b10 	vmov	d0, r2, r3
    634c:	4770      	bx	lr
    634e:	bf00      	nop

00006350 <__aeabi_atexit>:
    6350:	460b      	mov	r3, r1
    6352:	4601      	mov	r1, r0
    6354:	4618      	mov	r0, r3
    6356:	f000 b98d 	b.w	6674 <__cxa_atexit>
    635a:	bf00      	nop

0000635c <__aeabi_uldivmod>:
    635c:	b953      	cbnz	r3, 6374 <__aeabi_uldivmod+0x18>
    635e:	b94a      	cbnz	r2, 6374 <__aeabi_uldivmod+0x18>
    6360:	2900      	cmp	r1, #0
    6362:	bf08      	it	eq
    6364:	2800      	cmpeq	r0, #0
    6366:	bf1c      	itt	ne
    6368:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    636c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    6370:	f000 b97e 	b.w	6670 <__aeabi_idiv0>
    6374:	f1ad 0c08 	sub.w	ip, sp, #8
    6378:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    637c:	f000 f806 	bl	638c <__udivmoddi4>
    6380:	f8dd e004 	ldr.w	lr, [sp, #4]
    6384:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    6388:	b004      	add	sp, #16
    638a:	4770      	bx	lr

0000638c <__udivmoddi4>:
    638c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6390:	468c      	mov	ip, r1
    6392:	460e      	mov	r6, r1
    6394:	4604      	mov	r4, r0
    6396:	9d08      	ldr	r5, [sp, #32]
    6398:	2b00      	cmp	r3, #0
    639a:	d150      	bne.n	643e <__udivmoddi4+0xb2>
    639c:	428a      	cmp	r2, r1
    639e:	4617      	mov	r7, r2
    63a0:	d96c      	bls.n	647c <__udivmoddi4+0xf0>
    63a2:	fab2 fe82 	clz	lr, r2
    63a6:	f1be 0f00 	cmp.w	lr, #0
    63aa:	d00b      	beq.n	63c4 <__udivmoddi4+0x38>
    63ac:	f1ce 0420 	rsb	r4, lr, #32
    63b0:	fa20 f404 	lsr.w	r4, r0, r4
    63b4:	fa01 f60e 	lsl.w	r6, r1, lr
    63b8:	ea44 0c06 	orr.w	ip, r4, r6
    63bc:	fa02 f70e 	lsl.w	r7, r2, lr
    63c0:	fa00 f40e 	lsl.w	r4, r0, lr
    63c4:	ea4f 4917 	mov.w	r9, r7, lsr #16
    63c8:	0c22      	lsrs	r2, r4, #16
    63ca:	fbbc f0f9 	udiv	r0, ip, r9
    63ce:	fa1f f887 	uxth.w	r8, r7
    63d2:	fb09 c610 	mls	r6, r9, r0, ip
    63d6:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    63da:	fb00 f308 	mul.w	r3, r0, r8
    63de:	42b3      	cmp	r3, r6
    63e0:	d909      	bls.n	63f6 <__udivmoddi4+0x6a>
    63e2:	19f6      	adds	r6, r6, r7
    63e4:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    63e8:	f080 8122 	bcs.w	6630 <__udivmoddi4+0x2a4>
    63ec:	42b3      	cmp	r3, r6
    63ee:	f240 811f 	bls.w	6630 <__udivmoddi4+0x2a4>
    63f2:	3802      	subs	r0, #2
    63f4:	443e      	add	r6, r7
    63f6:	1af6      	subs	r6, r6, r3
    63f8:	b2a2      	uxth	r2, r4
    63fa:	fbb6 f3f9 	udiv	r3, r6, r9
    63fe:	fb09 6613 	mls	r6, r9, r3, r6
    6402:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    6406:	fb03 f808 	mul.w	r8, r3, r8
    640a:	45a0      	cmp	r8, r4
    640c:	d909      	bls.n	6422 <__udivmoddi4+0x96>
    640e:	19e4      	adds	r4, r4, r7
    6410:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    6414:	f080 810a 	bcs.w	662c <__udivmoddi4+0x2a0>
    6418:	45a0      	cmp	r8, r4
    641a:	f240 8107 	bls.w	662c <__udivmoddi4+0x2a0>
    641e:	3b02      	subs	r3, #2
    6420:	443c      	add	r4, r7
    6422:	ebc8 0404 	rsb	r4, r8, r4
    6426:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    642a:	2100      	movs	r1, #0
    642c:	2d00      	cmp	r5, #0
    642e:	d062      	beq.n	64f6 <__udivmoddi4+0x16a>
    6430:	fa24 f40e 	lsr.w	r4, r4, lr
    6434:	2300      	movs	r3, #0
    6436:	602c      	str	r4, [r5, #0]
    6438:	606b      	str	r3, [r5, #4]
    643a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    643e:	428b      	cmp	r3, r1
    6440:	d907      	bls.n	6452 <__udivmoddi4+0xc6>
    6442:	2d00      	cmp	r5, #0
    6444:	d055      	beq.n	64f2 <__udivmoddi4+0x166>
    6446:	2100      	movs	r1, #0
    6448:	e885 0041 	stmia.w	r5, {r0, r6}
    644c:	4608      	mov	r0, r1
    644e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6452:	fab3 f183 	clz	r1, r3
    6456:	2900      	cmp	r1, #0
    6458:	f040 8090 	bne.w	657c <__udivmoddi4+0x1f0>
    645c:	42b3      	cmp	r3, r6
    645e:	d302      	bcc.n	6466 <__udivmoddi4+0xda>
    6460:	4282      	cmp	r2, r0
    6462:	f200 80f8 	bhi.w	6656 <__udivmoddi4+0x2ca>
    6466:	1a84      	subs	r4, r0, r2
    6468:	eb66 0603 	sbc.w	r6, r6, r3
    646c:	2001      	movs	r0, #1
    646e:	46b4      	mov	ip, r6
    6470:	2d00      	cmp	r5, #0
    6472:	d040      	beq.n	64f6 <__udivmoddi4+0x16a>
    6474:	e885 1010 	stmia.w	r5, {r4, ip}
    6478:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    647c:	b912      	cbnz	r2, 6484 <__udivmoddi4+0xf8>
    647e:	2701      	movs	r7, #1
    6480:	fbb7 f7f2 	udiv	r7, r7, r2
    6484:	fab7 fe87 	clz	lr, r7
    6488:	f1be 0f00 	cmp.w	lr, #0
    648c:	d135      	bne.n	64fa <__udivmoddi4+0x16e>
    648e:	1bf3      	subs	r3, r6, r7
    6490:	ea4f 4817 	mov.w	r8, r7, lsr #16
    6494:	fa1f fc87 	uxth.w	ip, r7
    6498:	2101      	movs	r1, #1
    649a:	fbb3 f0f8 	udiv	r0, r3, r8
    649e:	0c22      	lsrs	r2, r4, #16
    64a0:	fb08 3610 	mls	r6, r8, r0, r3
    64a4:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    64a8:	fb0c f300 	mul.w	r3, ip, r0
    64ac:	42b3      	cmp	r3, r6
    64ae:	d907      	bls.n	64c0 <__udivmoddi4+0x134>
    64b0:	19f6      	adds	r6, r6, r7
    64b2:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    64b6:	d202      	bcs.n	64be <__udivmoddi4+0x132>
    64b8:	42b3      	cmp	r3, r6
    64ba:	f200 80ce 	bhi.w	665a <__udivmoddi4+0x2ce>
    64be:	4610      	mov	r0, r2
    64c0:	1af6      	subs	r6, r6, r3
    64c2:	b2a2      	uxth	r2, r4
    64c4:	fbb6 f3f8 	udiv	r3, r6, r8
    64c8:	fb08 6613 	mls	r6, r8, r3, r6
    64cc:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    64d0:	fb0c fc03 	mul.w	ip, ip, r3
    64d4:	45a4      	cmp	ip, r4
    64d6:	d907      	bls.n	64e8 <__udivmoddi4+0x15c>
    64d8:	19e4      	adds	r4, r4, r7
    64da:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    64de:	d202      	bcs.n	64e6 <__udivmoddi4+0x15a>
    64e0:	45a4      	cmp	ip, r4
    64e2:	f200 80b5 	bhi.w	6650 <__udivmoddi4+0x2c4>
    64e6:	4613      	mov	r3, r2
    64e8:	ebcc 0404 	rsb	r4, ip, r4
    64ec:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    64f0:	e79c      	b.n	642c <__udivmoddi4+0xa0>
    64f2:	4629      	mov	r1, r5
    64f4:	4628      	mov	r0, r5
    64f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    64fa:	f1ce 0120 	rsb	r1, lr, #32
    64fe:	fa06 f30e 	lsl.w	r3, r6, lr
    6502:	fa07 f70e 	lsl.w	r7, r7, lr
    6506:	fa20 f901 	lsr.w	r9, r0, r1
    650a:	ea4f 4817 	mov.w	r8, r7, lsr #16
    650e:	40ce      	lsrs	r6, r1
    6510:	ea49 0903 	orr.w	r9, r9, r3
    6514:	fbb6 faf8 	udiv	sl, r6, r8
    6518:	ea4f 4419 	mov.w	r4, r9, lsr #16
    651c:	fb08 661a 	mls	r6, r8, sl, r6
    6520:	fa1f fc87 	uxth.w	ip, r7
    6524:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
    6528:	fb0a f20c 	mul.w	r2, sl, ip
    652c:	429a      	cmp	r2, r3
    652e:	fa00 f40e 	lsl.w	r4, r0, lr
    6532:	d90a      	bls.n	654a <__udivmoddi4+0x1be>
    6534:	19db      	adds	r3, r3, r7
    6536:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    653a:	f080 8087 	bcs.w	664c <__udivmoddi4+0x2c0>
    653e:	429a      	cmp	r2, r3
    6540:	f240 8084 	bls.w	664c <__udivmoddi4+0x2c0>
    6544:	f1aa 0a02 	sub.w	sl, sl, #2
    6548:	443b      	add	r3, r7
    654a:	1a9b      	subs	r3, r3, r2
    654c:	fa1f f989 	uxth.w	r9, r9
    6550:	fbb3 f1f8 	udiv	r1, r3, r8
    6554:	fb08 3311 	mls	r3, r8, r1, r3
    6558:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
    655c:	fb01 f60c 	mul.w	r6, r1, ip
    6560:	429e      	cmp	r6, r3
    6562:	d907      	bls.n	6574 <__udivmoddi4+0x1e8>
    6564:	19db      	adds	r3, r3, r7
    6566:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    656a:	d26b      	bcs.n	6644 <__udivmoddi4+0x2b8>
    656c:	429e      	cmp	r6, r3
    656e:	d969      	bls.n	6644 <__udivmoddi4+0x2b8>
    6570:	3902      	subs	r1, #2
    6572:	443b      	add	r3, r7
    6574:	1b9b      	subs	r3, r3, r6
    6576:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
    657a:	e78e      	b.n	649a <__udivmoddi4+0x10e>
    657c:	f1c1 0e20 	rsb	lr, r1, #32
    6580:	fa22 f40e 	lsr.w	r4, r2, lr
    6584:	408b      	lsls	r3, r1
    6586:	4323      	orrs	r3, r4
    6588:	fa20 f70e 	lsr.w	r7, r0, lr
    658c:	fa06 f401 	lsl.w	r4, r6, r1
    6590:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    6594:	fa26 f60e 	lsr.w	r6, r6, lr
    6598:	433c      	orrs	r4, r7
    659a:	fbb6 f9fc 	udiv	r9, r6, ip
    659e:	0c27      	lsrs	r7, r4, #16
    65a0:	fb0c 6619 	mls	r6, ip, r9, r6
    65a4:	fa1f f883 	uxth.w	r8, r3
    65a8:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
    65ac:	fb09 f708 	mul.w	r7, r9, r8
    65b0:	42b7      	cmp	r7, r6
    65b2:	fa02 f201 	lsl.w	r2, r2, r1
    65b6:	fa00 fa01 	lsl.w	sl, r0, r1
    65ba:	d908      	bls.n	65ce <__udivmoddi4+0x242>
    65bc:	18f6      	adds	r6, r6, r3
    65be:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    65c2:	d241      	bcs.n	6648 <__udivmoddi4+0x2bc>
    65c4:	42b7      	cmp	r7, r6
    65c6:	d93f      	bls.n	6648 <__udivmoddi4+0x2bc>
    65c8:	f1a9 0902 	sub.w	r9, r9, #2
    65cc:	441e      	add	r6, r3
    65ce:	1bf6      	subs	r6, r6, r7
    65d0:	b2a0      	uxth	r0, r4
    65d2:	fbb6 f4fc 	udiv	r4, r6, ip
    65d6:	fb0c 6614 	mls	r6, ip, r4, r6
    65da:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
    65de:	fb04 f808 	mul.w	r8, r4, r8
    65e2:	45b8      	cmp	r8, r7
    65e4:	d907      	bls.n	65f6 <__udivmoddi4+0x26a>
    65e6:	18ff      	adds	r7, r7, r3
    65e8:	f104 30ff 	add.w	r0, r4, #4294967295	; 0xffffffff
    65ec:	d228      	bcs.n	6640 <__udivmoddi4+0x2b4>
    65ee:	45b8      	cmp	r8, r7
    65f0:	d926      	bls.n	6640 <__udivmoddi4+0x2b4>
    65f2:	3c02      	subs	r4, #2
    65f4:	441f      	add	r7, r3
    65f6:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
    65fa:	ebc8 0707 	rsb	r7, r8, r7
    65fe:	fba0 8902 	umull	r8, r9, r0, r2
    6602:	454f      	cmp	r7, r9
    6604:	4644      	mov	r4, r8
    6606:	464e      	mov	r6, r9
    6608:	d314      	bcc.n	6634 <__udivmoddi4+0x2a8>
    660a:	d029      	beq.n	6660 <__udivmoddi4+0x2d4>
    660c:	b365      	cbz	r5, 6668 <__udivmoddi4+0x2dc>
    660e:	ebba 0304 	subs.w	r3, sl, r4
    6612:	eb67 0706 	sbc.w	r7, r7, r6
    6616:	fa07 fe0e 	lsl.w	lr, r7, lr
    661a:	40cb      	lsrs	r3, r1
    661c:	40cf      	lsrs	r7, r1
    661e:	ea4e 0303 	orr.w	r3, lr, r3
    6622:	e885 0088 	stmia.w	r5, {r3, r7}
    6626:	2100      	movs	r1, #0
    6628:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    662c:	4613      	mov	r3, r2
    662e:	e6f8      	b.n	6422 <__udivmoddi4+0x96>
    6630:	4610      	mov	r0, r2
    6632:	e6e0      	b.n	63f6 <__udivmoddi4+0x6a>
    6634:	ebb8 0402 	subs.w	r4, r8, r2
    6638:	eb69 0603 	sbc.w	r6, r9, r3
    663c:	3801      	subs	r0, #1
    663e:	e7e5      	b.n	660c <__udivmoddi4+0x280>
    6640:	4604      	mov	r4, r0
    6642:	e7d8      	b.n	65f6 <__udivmoddi4+0x26a>
    6644:	4611      	mov	r1, r2
    6646:	e795      	b.n	6574 <__udivmoddi4+0x1e8>
    6648:	4681      	mov	r9, r0
    664a:	e7c0      	b.n	65ce <__udivmoddi4+0x242>
    664c:	468a      	mov	sl, r1
    664e:	e77c      	b.n	654a <__udivmoddi4+0x1be>
    6650:	3b02      	subs	r3, #2
    6652:	443c      	add	r4, r7
    6654:	e748      	b.n	64e8 <__udivmoddi4+0x15c>
    6656:	4608      	mov	r0, r1
    6658:	e70a      	b.n	6470 <__udivmoddi4+0xe4>
    665a:	3802      	subs	r0, #2
    665c:	443e      	add	r6, r7
    665e:	e72f      	b.n	64c0 <__udivmoddi4+0x134>
    6660:	45c2      	cmp	sl, r8
    6662:	d3e7      	bcc.n	6634 <__udivmoddi4+0x2a8>
    6664:	463e      	mov	r6, r7
    6666:	e7d1      	b.n	660c <__udivmoddi4+0x280>
    6668:	4629      	mov	r1, r5
    666a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    666e:	bf00      	nop

00006670 <__aeabi_idiv0>:
    6670:	4770      	bx	lr
    6672:	bf00      	nop

00006674 <__cxa_atexit>:
    6674:	4613      	mov	r3, r2
    6676:	460a      	mov	r2, r1
    6678:	4601      	mov	r1, r0
    667a:	2002      	movs	r0, #2
    667c:	f001 b958 	b.w	7930 <__register_exitproc>

00006680 <__errno>:
    6680:	4b01      	ldr	r3, [pc, #4]	; (6688 <__errno+0x8>)
    6682:	6818      	ldr	r0, [r3, #0]
    6684:	4770      	bx	lr
    6686:	bf00      	nop
    6688:	20001dd0 	.word	0x20001dd0

0000668c <exit>:
    668c:	b508      	push	{r3, lr}
    668e:	2100      	movs	r1, #0
    6690:	4604      	mov	r4, r0
    6692:	f001 f99f 	bl	79d4 <__call_exitprocs>
    6696:	4b04      	ldr	r3, [pc, #16]	; (66a8 <exit+0x1c>)
    6698:	6818      	ldr	r0, [r3, #0]
    669a:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    669c:	b103      	cbz	r3, 66a0 <exit+0x14>
    669e:	4798      	blx	r3
    66a0:	4620      	mov	r0, r4
    66a2:	f7fb fc53 	bl	1f4c <_exit>
    66a6:	bf00      	nop
    66a8:	200006d0 	.word	0x200006d0

000066ac <__libc_init_array>:
    66ac:	b570      	push	{r4, r5, r6, lr}
    66ae:	4e0f      	ldr	r6, [pc, #60]	; (66ec <__libc_init_array+0x40>)
    66b0:	4d0f      	ldr	r5, [pc, #60]	; (66f0 <__libc_init_array+0x44>)
    66b2:	1b76      	subs	r6, r6, r5
    66b4:	10b6      	asrs	r6, r6, #2
    66b6:	bf18      	it	ne
    66b8:	2400      	movne	r4, #0
    66ba:	d005      	beq.n	66c8 <__libc_init_array+0x1c>
    66bc:	3401      	adds	r4, #1
    66be:	f855 3b04 	ldr.w	r3, [r5], #4
    66c2:	4798      	blx	r3
    66c4:	42a6      	cmp	r6, r4
    66c6:	d1f9      	bne.n	66bc <__libc_init_array+0x10>
    66c8:	4e0a      	ldr	r6, [pc, #40]	; (66f4 <__libc_init_array+0x48>)
    66ca:	4d0b      	ldr	r5, [pc, #44]	; (66f8 <__libc_init_array+0x4c>)
    66cc:	1b76      	subs	r6, r6, r5
    66ce:	f004 f90b 	bl	a8e8 <___init_veneer>
    66d2:	10b6      	asrs	r6, r6, #2
    66d4:	bf18      	it	ne
    66d6:	2400      	movne	r4, #0
    66d8:	d006      	beq.n	66e8 <__libc_init_array+0x3c>
    66da:	3401      	adds	r4, #1
    66dc:	f855 3b04 	ldr.w	r3, [r5], #4
    66e0:	4798      	blx	r3
    66e2:	42a6      	cmp	r6, r4
    66e4:	d1f9      	bne.n	66da <__libc_init_array+0x2e>
    66e6:	bd70      	pop	{r4, r5, r6, pc}
    66e8:	bd70      	pop	{r4, r5, r6, pc}
    66ea:	bf00      	nop
    66ec:	60002098 	.word	0x60002098
    66f0:	60002098 	.word	0x60002098
    66f4:	600020a4 	.word	0x600020a4
    66f8:	60002098 	.word	0x60002098

000066fc <malloc>:
    66fc:	4b02      	ldr	r3, [pc, #8]	; (6708 <malloc+0xc>)
    66fe:	4601      	mov	r1, r0
    6700:	6818      	ldr	r0, [r3, #0]
    6702:	f000 b80b 	b.w	671c <_malloc_r>
    6706:	bf00      	nop
    6708:	20001dd0 	.word	0x20001dd0

0000670c <free>:
    670c:	4b02      	ldr	r3, [pc, #8]	; (6718 <free+0xc>)
    670e:	4601      	mov	r1, r0
    6710:	6818      	ldr	r0, [r3, #0]
    6712:	f001 ba19 	b.w	7b48 <_free_r>
    6716:	bf00      	nop
    6718:	20001dd0 	.word	0x20001dd0

0000671c <_malloc_r>:
    671c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6720:	f101 050b 	add.w	r5, r1, #11
    6724:	2d16      	cmp	r5, #22
    6726:	b083      	sub	sp, #12
    6728:	4606      	mov	r6, r0
    672a:	f240 809f 	bls.w	686c <_malloc_r+0x150>
    672e:	f035 0507 	bics.w	r5, r5, #7
    6732:	f100 80bf 	bmi.w	68b4 <_malloc_r+0x198>
    6736:	42a9      	cmp	r1, r5
    6738:	f200 80bc 	bhi.w	68b4 <_malloc_r+0x198>
    673c:	f000 fc08 	bl	6f50 <__malloc_lock>
    6740:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    6744:	f0c0 829c 	bcc.w	6c80 <_malloc_r+0x564>
    6748:	0a6b      	lsrs	r3, r5, #9
    674a:	f000 80ba 	beq.w	68c2 <_malloc_r+0x1a6>
    674e:	2b04      	cmp	r3, #4
    6750:	f200 8183 	bhi.w	6a5a <_malloc_r+0x33e>
    6754:	09a8      	lsrs	r0, r5, #6
    6756:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    675a:	ea4f 034e 	mov.w	r3, lr, lsl #1
    675e:	3038      	adds	r0, #56	; 0x38
    6760:	4fc4      	ldr	r7, [pc, #784]	; (6a74 <_malloc_r+0x358>)
    6762:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    6766:	f1a3 0108 	sub.w	r1, r3, #8
    676a:	685c      	ldr	r4, [r3, #4]
    676c:	42a1      	cmp	r1, r4
    676e:	d107      	bne.n	6780 <_malloc_r+0x64>
    6770:	e0ac      	b.n	68cc <_malloc_r+0x1b0>
    6772:	2a00      	cmp	r2, #0
    6774:	f280 80ac 	bge.w	68d0 <_malloc_r+0x1b4>
    6778:	68e4      	ldr	r4, [r4, #12]
    677a:	42a1      	cmp	r1, r4
    677c:	f000 80a6 	beq.w	68cc <_malloc_r+0x1b0>
    6780:	6863      	ldr	r3, [r4, #4]
    6782:	f023 0303 	bic.w	r3, r3, #3
    6786:	1b5a      	subs	r2, r3, r5
    6788:	2a0f      	cmp	r2, #15
    678a:	ddf2      	ble.n	6772 <_malloc_r+0x56>
    678c:	49b9      	ldr	r1, [pc, #740]	; (6a74 <_malloc_r+0x358>)
    678e:	693c      	ldr	r4, [r7, #16]
    6790:	f101 0e08 	add.w	lr, r1, #8
    6794:	4574      	cmp	r4, lr
    6796:	f000 81b3 	beq.w	6b00 <_malloc_r+0x3e4>
    679a:	6863      	ldr	r3, [r4, #4]
    679c:	f023 0303 	bic.w	r3, r3, #3
    67a0:	1b5a      	subs	r2, r3, r5
    67a2:	2a0f      	cmp	r2, #15
    67a4:	f300 8199 	bgt.w	6ada <_malloc_r+0x3be>
    67a8:	2a00      	cmp	r2, #0
    67aa:	f8c1 e014 	str.w	lr, [r1, #20]
    67ae:	f8c1 e010 	str.w	lr, [r1, #16]
    67b2:	f280 809e 	bge.w	68f2 <_malloc_r+0x1d6>
    67b6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    67ba:	f080 8167 	bcs.w	6a8c <_malloc_r+0x370>
    67be:	08db      	lsrs	r3, r3, #3
    67c0:	f103 0c01 	add.w	ip, r3, #1
    67c4:	2201      	movs	r2, #1
    67c6:	109b      	asrs	r3, r3, #2
    67c8:	fa02 f303 	lsl.w	r3, r2, r3
    67cc:	684a      	ldr	r2, [r1, #4]
    67ce:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    67d2:	f8c4 8008 	str.w	r8, [r4, #8]
    67d6:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    67da:	431a      	orrs	r2, r3
    67dc:	f1a9 0308 	sub.w	r3, r9, #8
    67e0:	60e3      	str	r3, [r4, #12]
    67e2:	604a      	str	r2, [r1, #4]
    67e4:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    67e8:	f8c8 400c 	str.w	r4, [r8, #12]
    67ec:	1083      	asrs	r3, r0, #2
    67ee:	2401      	movs	r4, #1
    67f0:	409c      	lsls	r4, r3
    67f2:	4294      	cmp	r4, r2
    67f4:	f200 808a 	bhi.w	690c <_malloc_r+0x1f0>
    67f8:	4214      	tst	r4, r2
    67fa:	d106      	bne.n	680a <_malloc_r+0xee>
    67fc:	f020 0003 	bic.w	r0, r0, #3
    6800:	0064      	lsls	r4, r4, #1
    6802:	4214      	tst	r4, r2
    6804:	f100 0004 	add.w	r0, r0, #4
    6808:	d0fa      	beq.n	6800 <_malloc_r+0xe4>
    680a:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    680e:	46cc      	mov	ip, r9
    6810:	4680      	mov	r8, r0
    6812:	f8dc 100c 	ldr.w	r1, [ip, #12]
    6816:	458c      	cmp	ip, r1
    6818:	d107      	bne.n	682a <_malloc_r+0x10e>
    681a:	e173      	b.n	6b04 <_malloc_r+0x3e8>
    681c:	2a00      	cmp	r2, #0
    681e:	f280 8181 	bge.w	6b24 <_malloc_r+0x408>
    6822:	68c9      	ldr	r1, [r1, #12]
    6824:	458c      	cmp	ip, r1
    6826:	f000 816d 	beq.w	6b04 <_malloc_r+0x3e8>
    682a:	684b      	ldr	r3, [r1, #4]
    682c:	f023 0303 	bic.w	r3, r3, #3
    6830:	1b5a      	subs	r2, r3, r5
    6832:	2a0f      	cmp	r2, #15
    6834:	ddf2      	ble.n	681c <_malloc_r+0x100>
    6836:	460c      	mov	r4, r1
    6838:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    683c:	f854 8f08 	ldr.w	r8, [r4, #8]!
    6840:	194b      	adds	r3, r1, r5
    6842:	f045 0501 	orr.w	r5, r5, #1
    6846:	604d      	str	r5, [r1, #4]
    6848:	f042 0101 	orr.w	r1, r2, #1
    684c:	f8c8 c00c 	str.w	ip, [r8, #12]
    6850:	4630      	mov	r0, r6
    6852:	f8cc 8008 	str.w	r8, [ip, #8]
    6856:	617b      	str	r3, [r7, #20]
    6858:	613b      	str	r3, [r7, #16]
    685a:	f8c3 e00c 	str.w	lr, [r3, #12]
    685e:	f8c3 e008 	str.w	lr, [r3, #8]
    6862:	6059      	str	r1, [r3, #4]
    6864:	509a      	str	r2, [r3, r2]
    6866:	f000 fb75 	bl	6f54 <__malloc_unlock>
    686a:	e01f      	b.n	68ac <_malloc_r+0x190>
    686c:	2910      	cmp	r1, #16
    686e:	d821      	bhi.n	68b4 <_malloc_r+0x198>
    6870:	f000 fb6e 	bl	6f50 <__malloc_lock>
    6874:	2510      	movs	r5, #16
    6876:	2306      	movs	r3, #6
    6878:	2002      	movs	r0, #2
    687a:	4f7e      	ldr	r7, [pc, #504]	; (6a74 <_malloc_r+0x358>)
    687c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    6880:	f1a3 0208 	sub.w	r2, r3, #8
    6884:	685c      	ldr	r4, [r3, #4]
    6886:	4294      	cmp	r4, r2
    6888:	f000 8145 	beq.w	6b16 <_malloc_r+0x3fa>
    688c:	6863      	ldr	r3, [r4, #4]
    688e:	68e1      	ldr	r1, [r4, #12]
    6890:	68a5      	ldr	r5, [r4, #8]
    6892:	f023 0303 	bic.w	r3, r3, #3
    6896:	4423      	add	r3, r4
    6898:	4630      	mov	r0, r6
    689a:	685a      	ldr	r2, [r3, #4]
    689c:	60e9      	str	r1, [r5, #12]
    689e:	f042 0201 	orr.w	r2, r2, #1
    68a2:	608d      	str	r5, [r1, #8]
    68a4:	605a      	str	r2, [r3, #4]
    68a6:	f000 fb55 	bl	6f54 <__malloc_unlock>
    68aa:	3408      	adds	r4, #8
    68ac:	4620      	mov	r0, r4
    68ae:	b003      	add	sp, #12
    68b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    68b4:	2400      	movs	r4, #0
    68b6:	230c      	movs	r3, #12
    68b8:	4620      	mov	r0, r4
    68ba:	6033      	str	r3, [r6, #0]
    68bc:	b003      	add	sp, #12
    68be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    68c2:	2380      	movs	r3, #128	; 0x80
    68c4:	f04f 0e40 	mov.w	lr, #64	; 0x40
    68c8:	203f      	movs	r0, #63	; 0x3f
    68ca:	e749      	b.n	6760 <_malloc_r+0x44>
    68cc:	4670      	mov	r0, lr
    68ce:	e75d      	b.n	678c <_malloc_r+0x70>
    68d0:	4423      	add	r3, r4
    68d2:	68e1      	ldr	r1, [r4, #12]
    68d4:	685a      	ldr	r2, [r3, #4]
    68d6:	68a5      	ldr	r5, [r4, #8]
    68d8:	f042 0201 	orr.w	r2, r2, #1
    68dc:	60e9      	str	r1, [r5, #12]
    68de:	4630      	mov	r0, r6
    68e0:	608d      	str	r5, [r1, #8]
    68e2:	605a      	str	r2, [r3, #4]
    68e4:	f000 fb36 	bl	6f54 <__malloc_unlock>
    68e8:	3408      	adds	r4, #8
    68ea:	4620      	mov	r0, r4
    68ec:	b003      	add	sp, #12
    68ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    68f2:	4423      	add	r3, r4
    68f4:	4630      	mov	r0, r6
    68f6:	685a      	ldr	r2, [r3, #4]
    68f8:	f042 0201 	orr.w	r2, r2, #1
    68fc:	605a      	str	r2, [r3, #4]
    68fe:	f000 fb29 	bl	6f54 <__malloc_unlock>
    6902:	3408      	adds	r4, #8
    6904:	4620      	mov	r0, r4
    6906:	b003      	add	sp, #12
    6908:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    690c:	68bc      	ldr	r4, [r7, #8]
    690e:	6863      	ldr	r3, [r4, #4]
    6910:	f023 0803 	bic.w	r8, r3, #3
    6914:	45a8      	cmp	r8, r5
    6916:	d304      	bcc.n	6922 <_malloc_r+0x206>
    6918:	ebc5 0308 	rsb	r3, r5, r8
    691c:	2b0f      	cmp	r3, #15
    691e:	f300 808c 	bgt.w	6a3a <_malloc_r+0x31e>
    6922:	4b55      	ldr	r3, [pc, #340]	; (6a78 <_malloc_r+0x35c>)
    6924:	f8df 9160 	ldr.w	r9, [pc, #352]	; 6a88 <_malloc_r+0x36c>
    6928:	681a      	ldr	r2, [r3, #0]
    692a:	f8d9 3000 	ldr.w	r3, [r9]
    692e:	3301      	adds	r3, #1
    6930:	442a      	add	r2, r5
    6932:	eb04 0a08 	add.w	sl, r4, r8
    6936:	f000 8160 	beq.w	6bfa <_malloc_r+0x4de>
    693a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    693e:	320f      	adds	r2, #15
    6940:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    6944:	f022 020f 	bic.w	r2, r2, #15
    6948:	4611      	mov	r1, r2
    694a:	4630      	mov	r0, r6
    694c:	9201      	str	r2, [sp, #4]
    694e:	f000 fcfb 	bl	7348 <_sbrk_r>
    6952:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    6956:	4683      	mov	fp, r0
    6958:	9a01      	ldr	r2, [sp, #4]
    695a:	f000 8158 	beq.w	6c0e <_malloc_r+0x4f2>
    695e:	4582      	cmp	sl, r0
    6960:	f200 80fc 	bhi.w	6b5c <_malloc_r+0x440>
    6964:	4b45      	ldr	r3, [pc, #276]	; (6a7c <_malloc_r+0x360>)
    6966:	6819      	ldr	r1, [r3, #0]
    6968:	45da      	cmp	sl, fp
    696a:	4411      	add	r1, r2
    696c:	6019      	str	r1, [r3, #0]
    696e:	f000 8153 	beq.w	6c18 <_malloc_r+0x4fc>
    6972:	f8d9 0000 	ldr.w	r0, [r9]
    6976:	f8df e110 	ldr.w	lr, [pc, #272]	; 6a88 <_malloc_r+0x36c>
    697a:	3001      	adds	r0, #1
    697c:	bf1b      	ittet	ne
    697e:	ebca 0a0b 	rsbne	sl, sl, fp
    6982:	4451      	addne	r1, sl
    6984:	f8ce b000 	streq.w	fp, [lr]
    6988:	6019      	strne	r1, [r3, #0]
    698a:	f01b 0107 	ands.w	r1, fp, #7
    698e:	f000 8117 	beq.w	6bc0 <_malloc_r+0x4a4>
    6992:	f1c1 0008 	rsb	r0, r1, #8
    6996:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    699a:	4483      	add	fp, r0
    699c:	3108      	adds	r1, #8
    699e:	445a      	add	r2, fp
    69a0:	f3c2 020b 	ubfx	r2, r2, #0, #12
    69a4:	ebc2 0901 	rsb	r9, r2, r1
    69a8:	4649      	mov	r1, r9
    69aa:	4630      	mov	r0, r6
    69ac:	9301      	str	r3, [sp, #4]
    69ae:	f000 fccb 	bl	7348 <_sbrk_r>
    69b2:	1c43      	adds	r3, r0, #1
    69b4:	9b01      	ldr	r3, [sp, #4]
    69b6:	f000 813f 	beq.w	6c38 <_malloc_r+0x51c>
    69ba:	ebcb 0200 	rsb	r2, fp, r0
    69be:	444a      	add	r2, r9
    69c0:	f042 0201 	orr.w	r2, r2, #1
    69c4:	6819      	ldr	r1, [r3, #0]
    69c6:	f8c7 b008 	str.w	fp, [r7, #8]
    69ca:	4449      	add	r1, r9
    69cc:	42bc      	cmp	r4, r7
    69ce:	f8cb 2004 	str.w	r2, [fp, #4]
    69d2:	6019      	str	r1, [r3, #0]
    69d4:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 6a7c <_malloc_r+0x360>
    69d8:	d016      	beq.n	6a08 <_malloc_r+0x2ec>
    69da:	f1b8 0f0f 	cmp.w	r8, #15
    69de:	f240 80fd 	bls.w	6bdc <_malloc_r+0x4c0>
    69e2:	6862      	ldr	r2, [r4, #4]
    69e4:	f1a8 030c 	sub.w	r3, r8, #12
    69e8:	f023 0307 	bic.w	r3, r3, #7
    69ec:	18e0      	adds	r0, r4, r3
    69ee:	f002 0201 	and.w	r2, r2, #1
    69f2:	f04f 0e05 	mov.w	lr, #5
    69f6:	431a      	orrs	r2, r3
    69f8:	2b0f      	cmp	r3, #15
    69fa:	6062      	str	r2, [r4, #4]
    69fc:	f8c0 e004 	str.w	lr, [r0, #4]
    6a00:	f8c0 e008 	str.w	lr, [r0, #8]
    6a04:	f200 811c 	bhi.w	6c40 <_malloc_r+0x524>
    6a08:	4b1d      	ldr	r3, [pc, #116]	; (6a80 <_malloc_r+0x364>)
    6a0a:	68bc      	ldr	r4, [r7, #8]
    6a0c:	681a      	ldr	r2, [r3, #0]
    6a0e:	4291      	cmp	r1, r2
    6a10:	bf88      	it	hi
    6a12:	6019      	strhi	r1, [r3, #0]
    6a14:	4b1b      	ldr	r3, [pc, #108]	; (6a84 <_malloc_r+0x368>)
    6a16:	681a      	ldr	r2, [r3, #0]
    6a18:	4291      	cmp	r1, r2
    6a1a:	6862      	ldr	r2, [r4, #4]
    6a1c:	bf88      	it	hi
    6a1e:	6019      	strhi	r1, [r3, #0]
    6a20:	f022 0203 	bic.w	r2, r2, #3
    6a24:	4295      	cmp	r5, r2
    6a26:	eba2 0305 	sub.w	r3, r2, r5
    6a2a:	d801      	bhi.n	6a30 <_malloc_r+0x314>
    6a2c:	2b0f      	cmp	r3, #15
    6a2e:	dc04      	bgt.n	6a3a <_malloc_r+0x31e>
    6a30:	4630      	mov	r0, r6
    6a32:	f000 fa8f 	bl	6f54 <__malloc_unlock>
    6a36:	2400      	movs	r4, #0
    6a38:	e738      	b.n	68ac <_malloc_r+0x190>
    6a3a:	1962      	adds	r2, r4, r5
    6a3c:	f043 0301 	orr.w	r3, r3, #1
    6a40:	f045 0501 	orr.w	r5, r5, #1
    6a44:	6065      	str	r5, [r4, #4]
    6a46:	4630      	mov	r0, r6
    6a48:	60ba      	str	r2, [r7, #8]
    6a4a:	6053      	str	r3, [r2, #4]
    6a4c:	f000 fa82 	bl	6f54 <__malloc_unlock>
    6a50:	3408      	adds	r4, #8
    6a52:	4620      	mov	r0, r4
    6a54:	b003      	add	sp, #12
    6a56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6a5a:	2b14      	cmp	r3, #20
    6a5c:	d971      	bls.n	6b42 <_malloc_r+0x426>
    6a5e:	2b54      	cmp	r3, #84	; 0x54
    6a60:	f200 80a4 	bhi.w	6bac <_malloc_r+0x490>
    6a64:	0b28      	lsrs	r0, r5, #12
    6a66:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    6a6a:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6a6e:	306e      	adds	r0, #110	; 0x6e
    6a70:	e676      	b.n	6760 <_malloc_r+0x44>
    6a72:	bf00      	nop
    6a74:	200019c0 	.word	0x200019c0
    6a78:	200026e4 	.word	0x200026e4
    6a7c:	200026b4 	.word	0x200026b4
    6a80:	200026dc 	.word	0x200026dc
    6a84:	200026e0 	.word	0x200026e0
    6a88:	20001dc8 	.word	0x20001dc8
    6a8c:	0a5a      	lsrs	r2, r3, #9
    6a8e:	2a04      	cmp	r2, #4
    6a90:	d95e      	bls.n	6b50 <_malloc_r+0x434>
    6a92:	2a14      	cmp	r2, #20
    6a94:	f200 80b3 	bhi.w	6bfe <_malloc_r+0x4e2>
    6a98:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    6a9c:	0049      	lsls	r1, r1, #1
    6a9e:	325b      	adds	r2, #91	; 0x5b
    6aa0:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    6aa4:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    6aa8:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 6c88 <_malloc_r+0x56c>
    6aac:	f1ac 0c08 	sub.w	ip, ip, #8
    6ab0:	458c      	cmp	ip, r1
    6ab2:	f000 8088 	beq.w	6bc6 <_malloc_r+0x4aa>
    6ab6:	684a      	ldr	r2, [r1, #4]
    6ab8:	f022 0203 	bic.w	r2, r2, #3
    6abc:	4293      	cmp	r3, r2
    6abe:	d202      	bcs.n	6ac6 <_malloc_r+0x3aa>
    6ac0:	6889      	ldr	r1, [r1, #8]
    6ac2:	458c      	cmp	ip, r1
    6ac4:	d1f7      	bne.n	6ab6 <_malloc_r+0x39a>
    6ac6:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    6aca:	687a      	ldr	r2, [r7, #4]
    6acc:	f8c4 c00c 	str.w	ip, [r4, #12]
    6ad0:	60a1      	str	r1, [r4, #8]
    6ad2:	f8cc 4008 	str.w	r4, [ip, #8]
    6ad6:	60cc      	str	r4, [r1, #12]
    6ad8:	e688      	b.n	67ec <_malloc_r+0xd0>
    6ada:	1963      	adds	r3, r4, r5
    6adc:	f042 0701 	orr.w	r7, r2, #1
    6ae0:	f045 0501 	orr.w	r5, r5, #1
    6ae4:	6065      	str	r5, [r4, #4]
    6ae6:	4630      	mov	r0, r6
    6ae8:	614b      	str	r3, [r1, #20]
    6aea:	610b      	str	r3, [r1, #16]
    6aec:	f8c3 e00c 	str.w	lr, [r3, #12]
    6af0:	f8c3 e008 	str.w	lr, [r3, #8]
    6af4:	605f      	str	r7, [r3, #4]
    6af6:	509a      	str	r2, [r3, r2]
    6af8:	3408      	adds	r4, #8
    6afa:	f000 fa2b 	bl	6f54 <__malloc_unlock>
    6afe:	e6d5      	b.n	68ac <_malloc_r+0x190>
    6b00:	684a      	ldr	r2, [r1, #4]
    6b02:	e673      	b.n	67ec <_malloc_r+0xd0>
    6b04:	f108 0801 	add.w	r8, r8, #1
    6b08:	f018 0f03 	tst.w	r8, #3
    6b0c:	f10c 0c08 	add.w	ip, ip, #8
    6b10:	f47f ae7f 	bne.w	6812 <_malloc_r+0xf6>
    6b14:	e030      	b.n	6b78 <_malloc_r+0x45c>
    6b16:	68dc      	ldr	r4, [r3, #12]
    6b18:	42a3      	cmp	r3, r4
    6b1a:	bf08      	it	eq
    6b1c:	3002      	addeq	r0, #2
    6b1e:	f43f ae35 	beq.w	678c <_malloc_r+0x70>
    6b22:	e6b3      	b.n	688c <_malloc_r+0x170>
    6b24:	440b      	add	r3, r1
    6b26:	460c      	mov	r4, r1
    6b28:	685a      	ldr	r2, [r3, #4]
    6b2a:	68c9      	ldr	r1, [r1, #12]
    6b2c:	f854 5f08 	ldr.w	r5, [r4, #8]!
    6b30:	f042 0201 	orr.w	r2, r2, #1
    6b34:	605a      	str	r2, [r3, #4]
    6b36:	4630      	mov	r0, r6
    6b38:	60e9      	str	r1, [r5, #12]
    6b3a:	608d      	str	r5, [r1, #8]
    6b3c:	f000 fa0a 	bl	6f54 <__malloc_unlock>
    6b40:	e6b4      	b.n	68ac <_malloc_r+0x190>
    6b42:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    6b46:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    6b4a:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6b4e:	e607      	b.n	6760 <_malloc_r+0x44>
    6b50:	099a      	lsrs	r2, r3, #6
    6b52:	f102 0139 	add.w	r1, r2, #57	; 0x39
    6b56:	0049      	lsls	r1, r1, #1
    6b58:	3238      	adds	r2, #56	; 0x38
    6b5a:	e7a1      	b.n	6aa0 <_malloc_r+0x384>
    6b5c:	42bc      	cmp	r4, r7
    6b5e:	4b4a      	ldr	r3, [pc, #296]	; (6c88 <_malloc_r+0x56c>)
    6b60:	f43f af00 	beq.w	6964 <_malloc_r+0x248>
    6b64:	689c      	ldr	r4, [r3, #8]
    6b66:	6862      	ldr	r2, [r4, #4]
    6b68:	f022 0203 	bic.w	r2, r2, #3
    6b6c:	e75a      	b.n	6a24 <_malloc_r+0x308>
    6b6e:	f859 3908 	ldr.w	r3, [r9], #-8
    6b72:	4599      	cmp	r9, r3
    6b74:	f040 8082 	bne.w	6c7c <_malloc_r+0x560>
    6b78:	f010 0f03 	tst.w	r0, #3
    6b7c:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    6b80:	d1f5      	bne.n	6b6e <_malloc_r+0x452>
    6b82:	687b      	ldr	r3, [r7, #4]
    6b84:	ea23 0304 	bic.w	r3, r3, r4
    6b88:	607b      	str	r3, [r7, #4]
    6b8a:	0064      	lsls	r4, r4, #1
    6b8c:	429c      	cmp	r4, r3
    6b8e:	f63f aebd 	bhi.w	690c <_malloc_r+0x1f0>
    6b92:	2c00      	cmp	r4, #0
    6b94:	f43f aeba 	beq.w	690c <_malloc_r+0x1f0>
    6b98:	421c      	tst	r4, r3
    6b9a:	4640      	mov	r0, r8
    6b9c:	f47f ae35 	bne.w	680a <_malloc_r+0xee>
    6ba0:	0064      	lsls	r4, r4, #1
    6ba2:	421c      	tst	r4, r3
    6ba4:	f100 0004 	add.w	r0, r0, #4
    6ba8:	d0fa      	beq.n	6ba0 <_malloc_r+0x484>
    6baa:	e62e      	b.n	680a <_malloc_r+0xee>
    6bac:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    6bb0:	d818      	bhi.n	6be4 <_malloc_r+0x4c8>
    6bb2:	0be8      	lsrs	r0, r5, #15
    6bb4:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    6bb8:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6bbc:	3077      	adds	r0, #119	; 0x77
    6bbe:	e5cf      	b.n	6760 <_malloc_r+0x44>
    6bc0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    6bc4:	e6eb      	b.n	699e <_malloc_r+0x282>
    6bc6:	2101      	movs	r1, #1
    6bc8:	f8d8 3004 	ldr.w	r3, [r8, #4]
    6bcc:	1092      	asrs	r2, r2, #2
    6bce:	fa01 f202 	lsl.w	r2, r1, r2
    6bd2:	431a      	orrs	r2, r3
    6bd4:	f8c8 2004 	str.w	r2, [r8, #4]
    6bd8:	4661      	mov	r1, ip
    6bda:	e777      	b.n	6acc <_malloc_r+0x3b0>
    6bdc:	2301      	movs	r3, #1
    6bde:	f8cb 3004 	str.w	r3, [fp, #4]
    6be2:	e725      	b.n	6a30 <_malloc_r+0x314>
    6be4:	f240 5254 	movw	r2, #1364	; 0x554
    6be8:	4293      	cmp	r3, r2
    6bea:	d820      	bhi.n	6c2e <_malloc_r+0x512>
    6bec:	0ca8      	lsrs	r0, r5, #18
    6bee:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    6bf2:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6bf6:	307c      	adds	r0, #124	; 0x7c
    6bf8:	e5b2      	b.n	6760 <_malloc_r+0x44>
    6bfa:	3210      	adds	r2, #16
    6bfc:	e6a4      	b.n	6948 <_malloc_r+0x22c>
    6bfe:	2a54      	cmp	r2, #84	; 0x54
    6c00:	d826      	bhi.n	6c50 <_malloc_r+0x534>
    6c02:	0b1a      	lsrs	r2, r3, #12
    6c04:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    6c08:	0049      	lsls	r1, r1, #1
    6c0a:	326e      	adds	r2, #110	; 0x6e
    6c0c:	e748      	b.n	6aa0 <_malloc_r+0x384>
    6c0e:	68bc      	ldr	r4, [r7, #8]
    6c10:	6862      	ldr	r2, [r4, #4]
    6c12:	f022 0203 	bic.w	r2, r2, #3
    6c16:	e705      	b.n	6a24 <_malloc_r+0x308>
    6c18:	f3ca 000b 	ubfx	r0, sl, #0, #12
    6c1c:	2800      	cmp	r0, #0
    6c1e:	f47f aea8 	bne.w	6972 <_malloc_r+0x256>
    6c22:	4442      	add	r2, r8
    6c24:	68bb      	ldr	r3, [r7, #8]
    6c26:	f042 0201 	orr.w	r2, r2, #1
    6c2a:	605a      	str	r2, [r3, #4]
    6c2c:	e6ec      	b.n	6a08 <_malloc_r+0x2ec>
    6c2e:	23fe      	movs	r3, #254	; 0xfe
    6c30:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    6c34:	207e      	movs	r0, #126	; 0x7e
    6c36:	e593      	b.n	6760 <_malloc_r+0x44>
    6c38:	2201      	movs	r2, #1
    6c3a:	f04f 0900 	mov.w	r9, #0
    6c3e:	e6c1      	b.n	69c4 <_malloc_r+0x2a8>
    6c40:	f104 0108 	add.w	r1, r4, #8
    6c44:	4630      	mov	r0, r6
    6c46:	f000 ff7f 	bl	7b48 <_free_r>
    6c4a:	f8d9 1000 	ldr.w	r1, [r9]
    6c4e:	e6db      	b.n	6a08 <_malloc_r+0x2ec>
    6c50:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    6c54:	d805      	bhi.n	6c62 <_malloc_r+0x546>
    6c56:	0bda      	lsrs	r2, r3, #15
    6c58:	f102 0178 	add.w	r1, r2, #120	; 0x78
    6c5c:	0049      	lsls	r1, r1, #1
    6c5e:	3277      	adds	r2, #119	; 0x77
    6c60:	e71e      	b.n	6aa0 <_malloc_r+0x384>
    6c62:	f240 5154 	movw	r1, #1364	; 0x554
    6c66:	428a      	cmp	r2, r1
    6c68:	d805      	bhi.n	6c76 <_malloc_r+0x55a>
    6c6a:	0c9a      	lsrs	r2, r3, #18
    6c6c:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    6c70:	0049      	lsls	r1, r1, #1
    6c72:	327c      	adds	r2, #124	; 0x7c
    6c74:	e714      	b.n	6aa0 <_malloc_r+0x384>
    6c76:	21fe      	movs	r1, #254	; 0xfe
    6c78:	227e      	movs	r2, #126	; 0x7e
    6c7a:	e711      	b.n	6aa0 <_malloc_r+0x384>
    6c7c:	687b      	ldr	r3, [r7, #4]
    6c7e:	e784      	b.n	6b8a <_malloc_r+0x46e>
    6c80:	08e8      	lsrs	r0, r5, #3
    6c82:	1c43      	adds	r3, r0, #1
    6c84:	005b      	lsls	r3, r3, #1
    6c86:	e5f8      	b.n	687a <_malloc_r+0x15e>
    6c88:	200019c0 	.word	0x200019c0

00006c8c <__ascii_mbtowc>:
    6c8c:	b082      	sub	sp, #8
    6c8e:	b149      	cbz	r1, 6ca4 <__ascii_mbtowc+0x18>
    6c90:	b15a      	cbz	r2, 6caa <__ascii_mbtowc+0x1e>
    6c92:	b16b      	cbz	r3, 6cb0 <__ascii_mbtowc+0x24>
    6c94:	7813      	ldrb	r3, [r2, #0]
    6c96:	600b      	str	r3, [r1, #0]
    6c98:	7812      	ldrb	r2, [r2, #0]
    6c9a:	1c10      	adds	r0, r2, #0
    6c9c:	bf18      	it	ne
    6c9e:	2001      	movne	r0, #1
    6ca0:	b002      	add	sp, #8
    6ca2:	4770      	bx	lr
    6ca4:	a901      	add	r1, sp, #4
    6ca6:	2a00      	cmp	r2, #0
    6ca8:	d1f3      	bne.n	6c92 <__ascii_mbtowc+0x6>
    6caa:	4610      	mov	r0, r2
    6cac:	b002      	add	sp, #8
    6cae:	4770      	bx	lr
    6cb0:	f06f 0001 	mvn.w	r0, #1
    6cb4:	e7f4      	b.n	6ca0 <__ascii_mbtowc+0x14>
    6cb6:	bf00      	nop

00006cb8 <memcpy>:
    6cb8:	4684      	mov	ip, r0
    6cba:	ea41 0300 	orr.w	r3, r1, r0
    6cbe:	f013 0303 	ands.w	r3, r3, #3
    6cc2:	d16d      	bne.n	6da0 <memcpy+0xe8>
    6cc4:	3a40      	subs	r2, #64	; 0x40
    6cc6:	d341      	bcc.n	6d4c <memcpy+0x94>
    6cc8:	f851 3b04 	ldr.w	r3, [r1], #4
    6ccc:	f840 3b04 	str.w	r3, [r0], #4
    6cd0:	f851 3b04 	ldr.w	r3, [r1], #4
    6cd4:	f840 3b04 	str.w	r3, [r0], #4
    6cd8:	f851 3b04 	ldr.w	r3, [r1], #4
    6cdc:	f840 3b04 	str.w	r3, [r0], #4
    6ce0:	f851 3b04 	ldr.w	r3, [r1], #4
    6ce4:	f840 3b04 	str.w	r3, [r0], #4
    6ce8:	f851 3b04 	ldr.w	r3, [r1], #4
    6cec:	f840 3b04 	str.w	r3, [r0], #4
    6cf0:	f851 3b04 	ldr.w	r3, [r1], #4
    6cf4:	f840 3b04 	str.w	r3, [r0], #4
    6cf8:	f851 3b04 	ldr.w	r3, [r1], #4
    6cfc:	f840 3b04 	str.w	r3, [r0], #4
    6d00:	f851 3b04 	ldr.w	r3, [r1], #4
    6d04:	f840 3b04 	str.w	r3, [r0], #4
    6d08:	f851 3b04 	ldr.w	r3, [r1], #4
    6d0c:	f840 3b04 	str.w	r3, [r0], #4
    6d10:	f851 3b04 	ldr.w	r3, [r1], #4
    6d14:	f840 3b04 	str.w	r3, [r0], #4
    6d18:	f851 3b04 	ldr.w	r3, [r1], #4
    6d1c:	f840 3b04 	str.w	r3, [r0], #4
    6d20:	f851 3b04 	ldr.w	r3, [r1], #4
    6d24:	f840 3b04 	str.w	r3, [r0], #4
    6d28:	f851 3b04 	ldr.w	r3, [r1], #4
    6d2c:	f840 3b04 	str.w	r3, [r0], #4
    6d30:	f851 3b04 	ldr.w	r3, [r1], #4
    6d34:	f840 3b04 	str.w	r3, [r0], #4
    6d38:	f851 3b04 	ldr.w	r3, [r1], #4
    6d3c:	f840 3b04 	str.w	r3, [r0], #4
    6d40:	f851 3b04 	ldr.w	r3, [r1], #4
    6d44:	f840 3b04 	str.w	r3, [r0], #4
    6d48:	3a40      	subs	r2, #64	; 0x40
    6d4a:	d2bd      	bcs.n	6cc8 <memcpy+0x10>
    6d4c:	3230      	adds	r2, #48	; 0x30
    6d4e:	d311      	bcc.n	6d74 <memcpy+0xbc>
    6d50:	f851 3b04 	ldr.w	r3, [r1], #4
    6d54:	f840 3b04 	str.w	r3, [r0], #4
    6d58:	f851 3b04 	ldr.w	r3, [r1], #4
    6d5c:	f840 3b04 	str.w	r3, [r0], #4
    6d60:	f851 3b04 	ldr.w	r3, [r1], #4
    6d64:	f840 3b04 	str.w	r3, [r0], #4
    6d68:	f851 3b04 	ldr.w	r3, [r1], #4
    6d6c:	f840 3b04 	str.w	r3, [r0], #4
    6d70:	3a10      	subs	r2, #16
    6d72:	d2ed      	bcs.n	6d50 <memcpy+0x98>
    6d74:	320c      	adds	r2, #12
    6d76:	d305      	bcc.n	6d84 <memcpy+0xcc>
    6d78:	f851 3b04 	ldr.w	r3, [r1], #4
    6d7c:	f840 3b04 	str.w	r3, [r0], #4
    6d80:	3a04      	subs	r2, #4
    6d82:	d2f9      	bcs.n	6d78 <memcpy+0xc0>
    6d84:	3204      	adds	r2, #4
    6d86:	d008      	beq.n	6d9a <memcpy+0xe2>
    6d88:	07d2      	lsls	r2, r2, #31
    6d8a:	bf1c      	itt	ne
    6d8c:	f811 3b01 	ldrbne.w	r3, [r1], #1
    6d90:	f800 3b01 	strbne.w	r3, [r0], #1
    6d94:	d301      	bcc.n	6d9a <memcpy+0xe2>
    6d96:	880b      	ldrh	r3, [r1, #0]
    6d98:	8003      	strh	r3, [r0, #0]
    6d9a:	4660      	mov	r0, ip
    6d9c:	4770      	bx	lr
    6d9e:	bf00      	nop
    6da0:	2a08      	cmp	r2, #8
    6da2:	d313      	bcc.n	6dcc <memcpy+0x114>
    6da4:	078b      	lsls	r3, r1, #30
    6da6:	d08d      	beq.n	6cc4 <memcpy+0xc>
    6da8:	f010 0303 	ands.w	r3, r0, #3
    6dac:	d08a      	beq.n	6cc4 <memcpy+0xc>
    6dae:	f1c3 0304 	rsb	r3, r3, #4
    6db2:	1ad2      	subs	r2, r2, r3
    6db4:	07db      	lsls	r3, r3, #31
    6db6:	bf1c      	itt	ne
    6db8:	f811 3b01 	ldrbne.w	r3, [r1], #1
    6dbc:	f800 3b01 	strbne.w	r3, [r0], #1
    6dc0:	d380      	bcc.n	6cc4 <memcpy+0xc>
    6dc2:	f831 3b02 	ldrh.w	r3, [r1], #2
    6dc6:	f820 3b02 	strh.w	r3, [r0], #2
    6dca:	e77b      	b.n	6cc4 <memcpy+0xc>
    6dcc:	3a04      	subs	r2, #4
    6dce:	d3d9      	bcc.n	6d84 <memcpy+0xcc>
    6dd0:	3a01      	subs	r2, #1
    6dd2:	f811 3b01 	ldrb.w	r3, [r1], #1
    6dd6:	f800 3b01 	strb.w	r3, [r0], #1
    6dda:	d2f9      	bcs.n	6dd0 <memcpy+0x118>
    6ddc:	780b      	ldrb	r3, [r1, #0]
    6dde:	7003      	strb	r3, [r0, #0]
    6de0:	784b      	ldrb	r3, [r1, #1]
    6de2:	7043      	strb	r3, [r0, #1]
    6de4:	788b      	ldrb	r3, [r1, #2]
    6de6:	7083      	strb	r3, [r0, #2]
    6de8:	4660      	mov	r0, ip
    6dea:	4770      	bx	lr

00006dec <memmove>:
    6dec:	4288      	cmp	r0, r1
    6dee:	b5f0      	push	{r4, r5, r6, r7, lr}
    6df0:	d90d      	bls.n	6e0e <memmove+0x22>
    6df2:	188b      	adds	r3, r1, r2
    6df4:	4298      	cmp	r0, r3
    6df6:	d20a      	bcs.n	6e0e <memmove+0x22>
    6df8:	1881      	adds	r1, r0, r2
    6dfa:	2a00      	cmp	r2, #0
    6dfc:	d051      	beq.n	6ea2 <memmove+0xb6>
    6dfe:	1a9a      	subs	r2, r3, r2
    6e00:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    6e04:	f801 4d01 	strb.w	r4, [r1, #-1]!
    6e08:	4293      	cmp	r3, r2
    6e0a:	d1f9      	bne.n	6e00 <memmove+0x14>
    6e0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6e0e:	2a0f      	cmp	r2, #15
    6e10:	d948      	bls.n	6ea4 <memmove+0xb8>
    6e12:	ea41 0300 	orr.w	r3, r1, r0
    6e16:	079b      	lsls	r3, r3, #30
    6e18:	d146      	bne.n	6ea8 <memmove+0xbc>
    6e1a:	f100 0410 	add.w	r4, r0, #16
    6e1e:	f101 0310 	add.w	r3, r1, #16
    6e22:	4615      	mov	r5, r2
    6e24:	f853 6c10 	ldr.w	r6, [r3, #-16]
    6e28:	f844 6c10 	str.w	r6, [r4, #-16]
    6e2c:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    6e30:	f844 6c0c 	str.w	r6, [r4, #-12]
    6e34:	f853 6c08 	ldr.w	r6, [r3, #-8]
    6e38:	f844 6c08 	str.w	r6, [r4, #-8]
    6e3c:	3d10      	subs	r5, #16
    6e3e:	f853 6c04 	ldr.w	r6, [r3, #-4]
    6e42:	f844 6c04 	str.w	r6, [r4, #-4]
    6e46:	2d0f      	cmp	r5, #15
    6e48:	f103 0310 	add.w	r3, r3, #16
    6e4c:	f104 0410 	add.w	r4, r4, #16
    6e50:	d8e8      	bhi.n	6e24 <memmove+0x38>
    6e52:	f1a2 0310 	sub.w	r3, r2, #16
    6e56:	f023 030f 	bic.w	r3, r3, #15
    6e5a:	f002 0e0f 	and.w	lr, r2, #15
    6e5e:	3310      	adds	r3, #16
    6e60:	f1be 0f03 	cmp.w	lr, #3
    6e64:	4419      	add	r1, r3
    6e66:	4403      	add	r3, r0
    6e68:	d921      	bls.n	6eae <memmove+0xc2>
    6e6a:	1f1e      	subs	r6, r3, #4
    6e6c:	460d      	mov	r5, r1
    6e6e:	4674      	mov	r4, lr
    6e70:	3c04      	subs	r4, #4
    6e72:	f855 7b04 	ldr.w	r7, [r5], #4
    6e76:	f846 7f04 	str.w	r7, [r6, #4]!
    6e7a:	2c03      	cmp	r4, #3
    6e7c:	d8f8      	bhi.n	6e70 <memmove+0x84>
    6e7e:	f1ae 0404 	sub.w	r4, lr, #4
    6e82:	f024 0403 	bic.w	r4, r4, #3
    6e86:	3404      	adds	r4, #4
    6e88:	4423      	add	r3, r4
    6e8a:	4421      	add	r1, r4
    6e8c:	f002 0203 	and.w	r2, r2, #3
    6e90:	b162      	cbz	r2, 6eac <memmove+0xc0>
    6e92:	3b01      	subs	r3, #1
    6e94:	440a      	add	r2, r1
    6e96:	f811 4b01 	ldrb.w	r4, [r1], #1
    6e9a:	f803 4f01 	strb.w	r4, [r3, #1]!
    6e9e:	428a      	cmp	r2, r1
    6ea0:	d1f9      	bne.n	6e96 <memmove+0xaa>
    6ea2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6ea4:	4603      	mov	r3, r0
    6ea6:	e7f3      	b.n	6e90 <memmove+0xa4>
    6ea8:	4603      	mov	r3, r0
    6eaa:	e7f2      	b.n	6e92 <memmove+0xa6>
    6eac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6eae:	4672      	mov	r2, lr
    6eb0:	e7ee      	b.n	6e90 <memmove+0xa4>
    6eb2:	bf00      	nop

00006eb4 <memset>:
    6eb4:	b470      	push	{r4, r5, r6}
    6eb6:	0784      	lsls	r4, r0, #30
    6eb8:	d046      	beq.n	6f48 <memset+0x94>
    6eba:	1e54      	subs	r4, r2, #1
    6ebc:	2a00      	cmp	r2, #0
    6ebe:	d041      	beq.n	6f44 <memset+0x90>
    6ec0:	b2cd      	uxtb	r5, r1
    6ec2:	4603      	mov	r3, r0
    6ec4:	e002      	b.n	6ecc <memset+0x18>
    6ec6:	1e62      	subs	r2, r4, #1
    6ec8:	b3e4      	cbz	r4, 6f44 <memset+0x90>
    6eca:	4614      	mov	r4, r2
    6ecc:	f803 5b01 	strb.w	r5, [r3], #1
    6ed0:	079a      	lsls	r2, r3, #30
    6ed2:	d1f8      	bne.n	6ec6 <memset+0x12>
    6ed4:	2c03      	cmp	r4, #3
    6ed6:	d92e      	bls.n	6f36 <memset+0x82>
    6ed8:	b2cd      	uxtb	r5, r1
    6eda:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    6ede:	2c0f      	cmp	r4, #15
    6ee0:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    6ee4:	d919      	bls.n	6f1a <memset+0x66>
    6ee6:	f103 0210 	add.w	r2, r3, #16
    6eea:	4626      	mov	r6, r4
    6eec:	3e10      	subs	r6, #16
    6eee:	2e0f      	cmp	r6, #15
    6ef0:	f842 5c10 	str.w	r5, [r2, #-16]
    6ef4:	f842 5c0c 	str.w	r5, [r2, #-12]
    6ef8:	f842 5c08 	str.w	r5, [r2, #-8]
    6efc:	f842 5c04 	str.w	r5, [r2, #-4]
    6f00:	f102 0210 	add.w	r2, r2, #16
    6f04:	d8f2      	bhi.n	6eec <memset+0x38>
    6f06:	f1a4 0210 	sub.w	r2, r4, #16
    6f0a:	f022 020f 	bic.w	r2, r2, #15
    6f0e:	f004 040f 	and.w	r4, r4, #15
    6f12:	3210      	adds	r2, #16
    6f14:	2c03      	cmp	r4, #3
    6f16:	4413      	add	r3, r2
    6f18:	d90d      	bls.n	6f36 <memset+0x82>
    6f1a:	461e      	mov	r6, r3
    6f1c:	4622      	mov	r2, r4
    6f1e:	3a04      	subs	r2, #4
    6f20:	2a03      	cmp	r2, #3
    6f22:	f846 5b04 	str.w	r5, [r6], #4
    6f26:	d8fa      	bhi.n	6f1e <memset+0x6a>
    6f28:	1f22      	subs	r2, r4, #4
    6f2a:	f022 0203 	bic.w	r2, r2, #3
    6f2e:	3204      	adds	r2, #4
    6f30:	4413      	add	r3, r2
    6f32:	f004 0403 	and.w	r4, r4, #3
    6f36:	b12c      	cbz	r4, 6f44 <memset+0x90>
    6f38:	b2c9      	uxtb	r1, r1
    6f3a:	441c      	add	r4, r3
    6f3c:	f803 1b01 	strb.w	r1, [r3], #1
    6f40:	42a3      	cmp	r3, r4
    6f42:	d1fb      	bne.n	6f3c <memset+0x88>
    6f44:	bc70      	pop	{r4, r5, r6}
    6f46:	4770      	bx	lr
    6f48:	4614      	mov	r4, r2
    6f4a:	4603      	mov	r3, r0
    6f4c:	e7c2      	b.n	6ed4 <memset+0x20>
    6f4e:	bf00      	nop

00006f50 <__malloc_lock>:
    6f50:	4770      	bx	lr
    6f52:	bf00      	nop

00006f54 <__malloc_unlock>:
    6f54:	4770      	bx	lr
    6f56:	bf00      	nop

00006f58 <realloc>:
    6f58:	4b02      	ldr	r3, [pc, #8]	; (6f64 <realloc+0xc>)
    6f5a:	460a      	mov	r2, r1
    6f5c:	4601      	mov	r1, r0
    6f5e:	6818      	ldr	r0, [r3, #0]
    6f60:	f000 b802 	b.w	6f68 <_realloc_r>
    6f64:	20001dd0 	.word	0x20001dd0

00006f68 <_realloc_r>:
    6f68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6f6c:	4617      	mov	r7, r2
    6f6e:	b083      	sub	sp, #12
    6f70:	2900      	cmp	r1, #0
    6f72:	f000 80c1 	beq.w	70f8 <_realloc_r+0x190>
    6f76:	460e      	mov	r6, r1
    6f78:	4681      	mov	r9, r0
    6f7a:	f107 050b 	add.w	r5, r7, #11
    6f7e:	f7ff ffe7 	bl	6f50 <__malloc_lock>
    6f82:	f856 ec04 	ldr.w	lr, [r6, #-4]
    6f86:	2d16      	cmp	r5, #22
    6f88:	f02e 0403 	bic.w	r4, lr, #3
    6f8c:	f1a6 0808 	sub.w	r8, r6, #8
    6f90:	d840      	bhi.n	7014 <_realloc_r+0xac>
    6f92:	2210      	movs	r2, #16
    6f94:	4615      	mov	r5, r2
    6f96:	42af      	cmp	r7, r5
    6f98:	d841      	bhi.n	701e <_realloc_r+0xb6>
    6f9a:	4294      	cmp	r4, r2
    6f9c:	da75      	bge.n	708a <_realloc_r+0x122>
    6f9e:	4bc9      	ldr	r3, [pc, #804]	; (72c4 <_realloc_r+0x35c>)
    6fa0:	6899      	ldr	r1, [r3, #8]
    6fa2:	eb08 0004 	add.w	r0, r8, r4
    6fa6:	4288      	cmp	r0, r1
    6fa8:	6841      	ldr	r1, [r0, #4]
    6faa:	f000 80d9 	beq.w	7160 <_realloc_r+0x1f8>
    6fae:	f021 0301 	bic.w	r3, r1, #1
    6fb2:	4403      	add	r3, r0
    6fb4:	685b      	ldr	r3, [r3, #4]
    6fb6:	07db      	lsls	r3, r3, #31
    6fb8:	d57d      	bpl.n	70b6 <_realloc_r+0x14e>
    6fba:	f01e 0f01 	tst.w	lr, #1
    6fbe:	d035      	beq.n	702c <_realloc_r+0xc4>
    6fc0:	4639      	mov	r1, r7
    6fc2:	4648      	mov	r0, r9
    6fc4:	f7ff fbaa 	bl	671c <_malloc_r>
    6fc8:	4607      	mov	r7, r0
    6fca:	b1e0      	cbz	r0, 7006 <_realloc_r+0x9e>
    6fcc:	f856 3c04 	ldr.w	r3, [r6, #-4]
    6fd0:	f023 0301 	bic.w	r3, r3, #1
    6fd4:	4443      	add	r3, r8
    6fd6:	f1a0 0208 	sub.w	r2, r0, #8
    6fda:	429a      	cmp	r2, r3
    6fdc:	f000 8144 	beq.w	7268 <_realloc_r+0x300>
    6fe0:	1f22      	subs	r2, r4, #4
    6fe2:	2a24      	cmp	r2, #36	; 0x24
    6fe4:	f200 8131 	bhi.w	724a <_realloc_r+0x2e2>
    6fe8:	2a13      	cmp	r2, #19
    6fea:	f200 8104 	bhi.w	71f6 <_realloc_r+0x28e>
    6fee:	4603      	mov	r3, r0
    6ff0:	4632      	mov	r2, r6
    6ff2:	6811      	ldr	r1, [r2, #0]
    6ff4:	6019      	str	r1, [r3, #0]
    6ff6:	6851      	ldr	r1, [r2, #4]
    6ff8:	6059      	str	r1, [r3, #4]
    6ffa:	6892      	ldr	r2, [r2, #8]
    6ffc:	609a      	str	r2, [r3, #8]
    6ffe:	4631      	mov	r1, r6
    7000:	4648      	mov	r0, r9
    7002:	f000 fda1 	bl	7b48 <_free_r>
    7006:	4648      	mov	r0, r9
    7008:	f7ff ffa4 	bl	6f54 <__malloc_unlock>
    700c:	4638      	mov	r0, r7
    700e:	b003      	add	sp, #12
    7010:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7014:	f025 0507 	bic.w	r5, r5, #7
    7018:	2d00      	cmp	r5, #0
    701a:	462a      	mov	r2, r5
    701c:	dabb      	bge.n	6f96 <_realloc_r+0x2e>
    701e:	230c      	movs	r3, #12
    7020:	2000      	movs	r0, #0
    7022:	f8c9 3000 	str.w	r3, [r9]
    7026:	b003      	add	sp, #12
    7028:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    702c:	f856 3c08 	ldr.w	r3, [r6, #-8]
    7030:	ebc3 0a08 	rsb	sl, r3, r8
    7034:	f8da 3004 	ldr.w	r3, [sl, #4]
    7038:	f023 0c03 	bic.w	ip, r3, #3
    703c:	eb04 030c 	add.w	r3, r4, ip
    7040:	4293      	cmp	r3, r2
    7042:	dbbd      	blt.n	6fc0 <_realloc_r+0x58>
    7044:	4657      	mov	r7, sl
    7046:	f8da 100c 	ldr.w	r1, [sl, #12]
    704a:	f857 0f08 	ldr.w	r0, [r7, #8]!
    704e:	1f22      	subs	r2, r4, #4
    7050:	2a24      	cmp	r2, #36	; 0x24
    7052:	60c1      	str	r1, [r0, #12]
    7054:	6088      	str	r0, [r1, #8]
    7056:	f200 8117 	bhi.w	7288 <_realloc_r+0x320>
    705a:	2a13      	cmp	r2, #19
    705c:	f240 8112 	bls.w	7284 <_realloc_r+0x31c>
    7060:	6831      	ldr	r1, [r6, #0]
    7062:	f8ca 1008 	str.w	r1, [sl, #8]
    7066:	6871      	ldr	r1, [r6, #4]
    7068:	f8ca 100c 	str.w	r1, [sl, #12]
    706c:	2a1b      	cmp	r2, #27
    706e:	f200 812b 	bhi.w	72c8 <_realloc_r+0x360>
    7072:	3608      	adds	r6, #8
    7074:	f10a 0210 	add.w	r2, sl, #16
    7078:	6831      	ldr	r1, [r6, #0]
    707a:	6011      	str	r1, [r2, #0]
    707c:	6871      	ldr	r1, [r6, #4]
    707e:	6051      	str	r1, [r2, #4]
    7080:	68b1      	ldr	r1, [r6, #8]
    7082:	6091      	str	r1, [r2, #8]
    7084:	463e      	mov	r6, r7
    7086:	461c      	mov	r4, r3
    7088:	46d0      	mov	r8, sl
    708a:	1b63      	subs	r3, r4, r5
    708c:	2b0f      	cmp	r3, #15
    708e:	d81d      	bhi.n	70cc <_realloc_r+0x164>
    7090:	f8d8 3004 	ldr.w	r3, [r8, #4]
    7094:	f003 0301 	and.w	r3, r3, #1
    7098:	4323      	orrs	r3, r4
    709a:	4444      	add	r4, r8
    709c:	f8c8 3004 	str.w	r3, [r8, #4]
    70a0:	6863      	ldr	r3, [r4, #4]
    70a2:	f043 0301 	orr.w	r3, r3, #1
    70a6:	6063      	str	r3, [r4, #4]
    70a8:	4648      	mov	r0, r9
    70aa:	f7ff ff53 	bl	6f54 <__malloc_unlock>
    70ae:	4630      	mov	r0, r6
    70b0:	b003      	add	sp, #12
    70b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    70b6:	f021 0103 	bic.w	r1, r1, #3
    70ba:	4421      	add	r1, r4
    70bc:	4291      	cmp	r1, r2
    70be:	db21      	blt.n	7104 <_realloc_r+0x19c>
    70c0:	68c3      	ldr	r3, [r0, #12]
    70c2:	6882      	ldr	r2, [r0, #8]
    70c4:	460c      	mov	r4, r1
    70c6:	60d3      	str	r3, [r2, #12]
    70c8:	609a      	str	r2, [r3, #8]
    70ca:	e7de      	b.n	708a <_realloc_r+0x122>
    70cc:	f8d8 2004 	ldr.w	r2, [r8, #4]
    70d0:	eb08 0105 	add.w	r1, r8, r5
    70d4:	f002 0201 	and.w	r2, r2, #1
    70d8:	4315      	orrs	r5, r2
    70da:	f043 0201 	orr.w	r2, r3, #1
    70de:	440b      	add	r3, r1
    70e0:	f8c8 5004 	str.w	r5, [r8, #4]
    70e4:	604a      	str	r2, [r1, #4]
    70e6:	685a      	ldr	r2, [r3, #4]
    70e8:	f042 0201 	orr.w	r2, r2, #1
    70ec:	3108      	adds	r1, #8
    70ee:	605a      	str	r2, [r3, #4]
    70f0:	4648      	mov	r0, r9
    70f2:	f000 fd29 	bl	7b48 <_free_r>
    70f6:	e7d7      	b.n	70a8 <_realloc_r+0x140>
    70f8:	4611      	mov	r1, r2
    70fa:	b003      	add	sp, #12
    70fc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7100:	f7ff bb0c 	b.w	671c <_malloc_r>
    7104:	f01e 0f01 	tst.w	lr, #1
    7108:	f47f af5a 	bne.w	6fc0 <_realloc_r+0x58>
    710c:	f856 3c08 	ldr.w	r3, [r6, #-8]
    7110:	ebc3 0a08 	rsb	sl, r3, r8
    7114:	f8da 3004 	ldr.w	r3, [sl, #4]
    7118:	f023 0c03 	bic.w	ip, r3, #3
    711c:	eb01 0e0c 	add.w	lr, r1, ip
    7120:	4596      	cmp	lr, r2
    7122:	db8b      	blt.n	703c <_realloc_r+0xd4>
    7124:	68c3      	ldr	r3, [r0, #12]
    7126:	6882      	ldr	r2, [r0, #8]
    7128:	4657      	mov	r7, sl
    712a:	60d3      	str	r3, [r2, #12]
    712c:	609a      	str	r2, [r3, #8]
    712e:	f857 1f08 	ldr.w	r1, [r7, #8]!
    7132:	f8da 300c 	ldr.w	r3, [sl, #12]
    7136:	60cb      	str	r3, [r1, #12]
    7138:	1f22      	subs	r2, r4, #4
    713a:	2a24      	cmp	r2, #36	; 0x24
    713c:	6099      	str	r1, [r3, #8]
    713e:	f200 8099 	bhi.w	7274 <_realloc_r+0x30c>
    7142:	2a13      	cmp	r2, #19
    7144:	d962      	bls.n	720c <_realloc_r+0x2a4>
    7146:	6833      	ldr	r3, [r6, #0]
    7148:	f8ca 3008 	str.w	r3, [sl, #8]
    714c:	6873      	ldr	r3, [r6, #4]
    714e:	f8ca 300c 	str.w	r3, [sl, #12]
    7152:	2a1b      	cmp	r2, #27
    7154:	f200 80a0 	bhi.w	7298 <_realloc_r+0x330>
    7158:	3608      	adds	r6, #8
    715a:	f10a 0310 	add.w	r3, sl, #16
    715e:	e056      	b.n	720e <_realloc_r+0x2a6>
    7160:	f021 0b03 	bic.w	fp, r1, #3
    7164:	44a3      	add	fp, r4
    7166:	f105 0010 	add.w	r0, r5, #16
    716a:	4583      	cmp	fp, r0
    716c:	da59      	bge.n	7222 <_realloc_r+0x2ba>
    716e:	f01e 0f01 	tst.w	lr, #1
    7172:	f47f af25 	bne.w	6fc0 <_realloc_r+0x58>
    7176:	f856 1c08 	ldr.w	r1, [r6, #-8]
    717a:	ebc1 0a08 	rsb	sl, r1, r8
    717e:	f8da 1004 	ldr.w	r1, [sl, #4]
    7182:	f021 0c03 	bic.w	ip, r1, #3
    7186:	44e3      	add	fp, ip
    7188:	4558      	cmp	r0, fp
    718a:	f73f af57 	bgt.w	703c <_realloc_r+0xd4>
    718e:	4657      	mov	r7, sl
    7190:	f8da 100c 	ldr.w	r1, [sl, #12]
    7194:	f857 0f08 	ldr.w	r0, [r7, #8]!
    7198:	1f22      	subs	r2, r4, #4
    719a:	2a24      	cmp	r2, #36	; 0x24
    719c:	60c1      	str	r1, [r0, #12]
    719e:	6088      	str	r0, [r1, #8]
    71a0:	f200 80b4 	bhi.w	730c <_realloc_r+0x3a4>
    71a4:	2a13      	cmp	r2, #19
    71a6:	f240 80a5 	bls.w	72f4 <_realloc_r+0x38c>
    71aa:	6831      	ldr	r1, [r6, #0]
    71ac:	f8ca 1008 	str.w	r1, [sl, #8]
    71b0:	6871      	ldr	r1, [r6, #4]
    71b2:	f8ca 100c 	str.w	r1, [sl, #12]
    71b6:	2a1b      	cmp	r2, #27
    71b8:	f200 80af 	bhi.w	731a <_realloc_r+0x3b2>
    71bc:	3608      	adds	r6, #8
    71be:	f10a 0210 	add.w	r2, sl, #16
    71c2:	6831      	ldr	r1, [r6, #0]
    71c4:	6011      	str	r1, [r2, #0]
    71c6:	6871      	ldr	r1, [r6, #4]
    71c8:	6051      	str	r1, [r2, #4]
    71ca:	68b1      	ldr	r1, [r6, #8]
    71cc:	6091      	str	r1, [r2, #8]
    71ce:	eb0a 0105 	add.w	r1, sl, r5
    71d2:	ebc5 020b 	rsb	r2, r5, fp
    71d6:	f042 0201 	orr.w	r2, r2, #1
    71da:	6099      	str	r1, [r3, #8]
    71dc:	604a      	str	r2, [r1, #4]
    71de:	f8da 3004 	ldr.w	r3, [sl, #4]
    71e2:	f003 0301 	and.w	r3, r3, #1
    71e6:	431d      	orrs	r5, r3
    71e8:	4648      	mov	r0, r9
    71ea:	f8ca 5004 	str.w	r5, [sl, #4]
    71ee:	f7ff feb1 	bl	6f54 <__malloc_unlock>
    71f2:	4638      	mov	r0, r7
    71f4:	e75c      	b.n	70b0 <_realloc_r+0x148>
    71f6:	6833      	ldr	r3, [r6, #0]
    71f8:	6003      	str	r3, [r0, #0]
    71fa:	6873      	ldr	r3, [r6, #4]
    71fc:	6043      	str	r3, [r0, #4]
    71fe:	2a1b      	cmp	r2, #27
    7200:	d827      	bhi.n	7252 <_realloc_r+0x2ea>
    7202:	f100 0308 	add.w	r3, r0, #8
    7206:	f106 0208 	add.w	r2, r6, #8
    720a:	e6f2      	b.n	6ff2 <_realloc_r+0x8a>
    720c:	463b      	mov	r3, r7
    720e:	6832      	ldr	r2, [r6, #0]
    7210:	601a      	str	r2, [r3, #0]
    7212:	6872      	ldr	r2, [r6, #4]
    7214:	605a      	str	r2, [r3, #4]
    7216:	68b2      	ldr	r2, [r6, #8]
    7218:	609a      	str	r2, [r3, #8]
    721a:	463e      	mov	r6, r7
    721c:	4674      	mov	r4, lr
    721e:	46d0      	mov	r8, sl
    7220:	e733      	b.n	708a <_realloc_r+0x122>
    7222:	eb08 0105 	add.w	r1, r8, r5
    7226:	ebc5 0b0b 	rsb	fp, r5, fp
    722a:	f04b 0201 	orr.w	r2, fp, #1
    722e:	6099      	str	r1, [r3, #8]
    7230:	604a      	str	r2, [r1, #4]
    7232:	f856 3c04 	ldr.w	r3, [r6, #-4]
    7236:	f003 0301 	and.w	r3, r3, #1
    723a:	431d      	orrs	r5, r3
    723c:	4648      	mov	r0, r9
    723e:	f846 5c04 	str.w	r5, [r6, #-4]
    7242:	f7ff fe87 	bl	6f54 <__malloc_unlock>
    7246:	4630      	mov	r0, r6
    7248:	e732      	b.n	70b0 <_realloc_r+0x148>
    724a:	4631      	mov	r1, r6
    724c:	f7ff fdce 	bl	6dec <memmove>
    7250:	e6d5      	b.n	6ffe <_realloc_r+0x96>
    7252:	68b3      	ldr	r3, [r6, #8]
    7254:	6083      	str	r3, [r0, #8]
    7256:	68f3      	ldr	r3, [r6, #12]
    7258:	60c3      	str	r3, [r0, #12]
    725a:	2a24      	cmp	r2, #36	; 0x24
    725c:	d028      	beq.n	72b0 <_realloc_r+0x348>
    725e:	f100 0310 	add.w	r3, r0, #16
    7262:	f106 0210 	add.w	r2, r6, #16
    7266:	e6c4      	b.n	6ff2 <_realloc_r+0x8a>
    7268:	f850 3c04 	ldr.w	r3, [r0, #-4]
    726c:	f023 0303 	bic.w	r3, r3, #3
    7270:	441c      	add	r4, r3
    7272:	e70a      	b.n	708a <_realloc_r+0x122>
    7274:	4631      	mov	r1, r6
    7276:	4638      	mov	r0, r7
    7278:	4674      	mov	r4, lr
    727a:	46d0      	mov	r8, sl
    727c:	f7ff fdb6 	bl	6dec <memmove>
    7280:	463e      	mov	r6, r7
    7282:	e702      	b.n	708a <_realloc_r+0x122>
    7284:	463a      	mov	r2, r7
    7286:	e6f7      	b.n	7078 <_realloc_r+0x110>
    7288:	4631      	mov	r1, r6
    728a:	4638      	mov	r0, r7
    728c:	461c      	mov	r4, r3
    728e:	46d0      	mov	r8, sl
    7290:	f7ff fdac 	bl	6dec <memmove>
    7294:	463e      	mov	r6, r7
    7296:	e6f8      	b.n	708a <_realloc_r+0x122>
    7298:	68b3      	ldr	r3, [r6, #8]
    729a:	f8ca 3010 	str.w	r3, [sl, #16]
    729e:	68f3      	ldr	r3, [r6, #12]
    72a0:	f8ca 3014 	str.w	r3, [sl, #20]
    72a4:	2a24      	cmp	r2, #36	; 0x24
    72a6:	d01b      	beq.n	72e0 <_realloc_r+0x378>
    72a8:	3610      	adds	r6, #16
    72aa:	f10a 0318 	add.w	r3, sl, #24
    72ae:	e7ae      	b.n	720e <_realloc_r+0x2a6>
    72b0:	6933      	ldr	r3, [r6, #16]
    72b2:	6103      	str	r3, [r0, #16]
    72b4:	6973      	ldr	r3, [r6, #20]
    72b6:	6143      	str	r3, [r0, #20]
    72b8:	f106 0218 	add.w	r2, r6, #24
    72bc:	f100 0318 	add.w	r3, r0, #24
    72c0:	e697      	b.n	6ff2 <_realloc_r+0x8a>
    72c2:	bf00      	nop
    72c4:	200019c0 	.word	0x200019c0
    72c8:	68b1      	ldr	r1, [r6, #8]
    72ca:	f8ca 1010 	str.w	r1, [sl, #16]
    72ce:	68f1      	ldr	r1, [r6, #12]
    72d0:	f8ca 1014 	str.w	r1, [sl, #20]
    72d4:	2a24      	cmp	r2, #36	; 0x24
    72d6:	d00f      	beq.n	72f8 <_realloc_r+0x390>
    72d8:	3610      	adds	r6, #16
    72da:	f10a 0218 	add.w	r2, sl, #24
    72de:	e6cb      	b.n	7078 <_realloc_r+0x110>
    72e0:	6933      	ldr	r3, [r6, #16]
    72e2:	f8ca 3018 	str.w	r3, [sl, #24]
    72e6:	6973      	ldr	r3, [r6, #20]
    72e8:	f8ca 301c 	str.w	r3, [sl, #28]
    72ec:	3618      	adds	r6, #24
    72ee:	f10a 0320 	add.w	r3, sl, #32
    72f2:	e78c      	b.n	720e <_realloc_r+0x2a6>
    72f4:	463a      	mov	r2, r7
    72f6:	e764      	b.n	71c2 <_realloc_r+0x25a>
    72f8:	6932      	ldr	r2, [r6, #16]
    72fa:	f8ca 2018 	str.w	r2, [sl, #24]
    72fe:	6972      	ldr	r2, [r6, #20]
    7300:	f8ca 201c 	str.w	r2, [sl, #28]
    7304:	3618      	adds	r6, #24
    7306:	f10a 0220 	add.w	r2, sl, #32
    730a:	e6b5      	b.n	7078 <_realloc_r+0x110>
    730c:	4631      	mov	r1, r6
    730e:	4638      	mov	r0, r7
    7310:	9301      	str	r3, [sp, #4]
    7312:	f7ff fd6b 	bl	6dec <memmove>
    7316:	9b01      	ldr	r3, [sp, #4]
    7318:	e759      	b.n	71ce <_realloc_r+0x266>
    731a:	68b1      	ldr	r1, [r6, #8]
    731c:	f8ca 1010 	str.w	r1, [sl, #16]
    7320:	68f1      	ldr	r1, [r6, #12]
    7322:	f8ca 1014 	str.w	r1, [sl, #20]
    7326:	2a24      	cmp	r2, #36	; 0x24
    7328:	d003      	beq.n	7332 <_realloc_r+0x3ca>
    732a:	3610      	adds	r6, #16
    732c:	f10a 0218 	add.w	r2, sl, #24
    7330:	e747      	b.n	71c2 <_realloc_r+0x25a>
    7332:	6932      	ldr	r2, [r6, #16]
    7334:	f8ca 2018 	str.w	r2, [sl, #24]
    7338:	6972      	ldr	r2, [r6, #20]
    733a:	f8ca 201c 	str.w	r2, [sl, #28]
    733e:	3618      	adds	r6, #24
    7340:	f10a 0220 	add.w	r2, sl, #32
    7344:	e73d      	b.n	71c2 <_realloc_r+0x25a>
    7346:	bf00      	nop

00007348 <_sbrk_r>:
    7348:	b538      	push	{r3, r4, r5, lr}
    734a:	4c07      	ldr	r4, [pc, #28]	; (7368 <_sbrk_r+0x20>)
    734c:	2300      	movs	r3, #0
    734e:	4605      	mov	r5, r0
    7350:	4608      	mov	r0, r1
    7352:	6023      	str	r3, [r4, #0]
    7354:	f7fa fde2 	bl	1f1c <_sbrk>
    7358:	1c43      	adds	r3, r0, #1
    735a:	d000      	beq.n	735e <_sbrk_r+0x16>
    735c:	bd38      	pop	{r3, r4, r5, pc}
    735e:	6823      	ldr	r3, [r4, #0]
    7360:	2b00      	cmp	r3, #0
    7362:	d0fb      	beq.n	735c <_sbrk_r+0x14>
    7364:	602b      	str	r3, [r5, #0]
    7366:	bd38      	pop	{r3, r4, r5, pc}
    7368:	200027f4 	.word	0x200027f4
	...
    7380:	eba2 0003 	sub.w	r0, r2, r3
    7384:	4770      	bx	lr
    7386:	bf00      	nop

00007388 <strcmp>:
    7388:	7802      	ldrb	r2, [r0, #0]
    738a:	780b      	ldrb	r3, [r1, #0]
    738c:	2a01      	cmp	r2, #1
    738e:	bf28      	it	cs
    7390:	429a      	cmpcs	r2, r3
    7392:	d1f5      	bne.n	7380 <_sbrk_r+0x38>
    7394:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    7398:	ea40 0401 	orr.w	r4, r0, r1
    739c:	e9cd 6702 	strd	r6, r7, [sp, #8]
    73a0:	f06f 0c00 	mvn.w	ip, #0
    73a4:	ea4f 7244 	mov.w	r2, r4, lsl #29
    73a8:	b312      	cbz	r2, 73f0 <strcmp+0x68>
    73aa:	ea80 0401 	eor.w	r4, r0, r1
    73ae:	f014 0f07 	tst.w	r4, #7
    73b2:	d16a      	bne.n	748a <strcmp+0x102>
    73b4:	f000 0407 	and.w	r4, r0, #7
    73b8:	f020 0007 	bic.w	r0, r0, #7
    73bc:	f004 0503 	and.w	r5, r4, #3
    73c0:	f021 0107 	bic.w	r1, r1, #7
    73c4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    73c8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    73cc:	f014 0f04 	tst.w	r4, #4
    73d0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    73d4:	fa0c f405 	lsl.w	r4, ip, r5
    73d8:	ea62 0204 	orn	r2, r2, r4
    73dc:	ea66 0604 	orn	r6, r6, r4
    73e0:	d00a      	beq.n	73f8 <strcmp+0x70>
    73e2:	ea63 0304 	orn	r3, r3, r4
    73e6:	4662      	mov	r2, ip
    73e8:	ea67 0704 	orn	r7, r7, r4
    73ec:	4666      	mov	r6, ip
    73ee:	e003      	b.n	73f8 <strcmp+0x70>
    73f0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    73f4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    73f8:	fa82 f54c 	uadd8	r5, r2, ip
    73fc:	ea82 0406 	eor.w	r4, r2, r6
    7400:	faa4 f48c 	sel	r4, r4, ip
    7404:	bb6c      	cbnz	r4, 7462 <strcmp+0xda>
    7406:	fa83 f54c 	uadd8	r5, r3, ip
    740a:	ea83 0507 	eor.w	r5, r3, r7
    740e:	faa5 f58c 	sel	r5, r5, ip
    7412:	b995      	cbnz	r5, 743a <strcmp+0xb2>
    7414:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    7418:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    741c:	fa82 f54c 	uadd8	r5, r2, ip
    7420:	ea82 0406 	eor.w	r4, r2, r6
    7424:	faa4 f48c 	sel	r4, r4, ip
    7428:	fa83 f54c 	uadd8	r5, r3, ip
    742c:	ea83 0507 	eor.w	r5, r3, r7
    7430:	faa5 f58c 	sel	r5, r5, ip
    7434:	4325      	orrs	r5, r4
    7436:	d0db      	beq.n	73f0 <strcmp+0x68>
    7438:	b99c      	cbnz	r4, 7462 <strcmp+0xda>
    743a:	ba2d      	rev	r5, r5
    743c:	fab5 f485 	clz	r4, r5
    7440:	f024 0407 	bic.w	r4, r4, #7
    7444:	fa27 f104 	lsr.w	r1, r7, r4
    7448:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    744c:	fa23 f304 	lsr.w	r3, r3, r4
    7450:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    7454:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    7458:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    745c:	eba0 0001 	sub.w	r0, r0, r1
    7460:	4770      	bx	lr
    7462:	ba24      	rev	r4, r4
    7464:	fab4 f484 	clz	r4, r4
    7468:	f024 0407 	bic.w	r4, r4, #7
    746c:	fa26 f104 	lsr.w	r1, r6, r4
    7470:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    7474:	fa22 f204 	lsr.w	r2, r2, r4
    7478:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    747c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    7480:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    7484:	eba0 0001 	sub.w	r0, r0, r1
    7488:	4770      	bx	lr
    748a:	f014 0f03 	tst.w	r4, #3
    748e:	d13c      	bne.n	750a <strcmp+0x182>
    7490:	f010 0403 	ands.w	r4, r0, #3
    7494:	d128      	bne.n	74e8 <strcmp+0x160>
    7496:	f850 2b08 	ldr.w	r2, [r0], #8
    749a:	f851 3b08 	ldr.w	r3, [r1], #8
    749e:	fa82 f54c 	uadd8	r5, r2, ip
    74a2:	ea82 0503 	eor.w	r5, r2, r3
    74a6:	faa5 f58c 	sel	r5, r5, ip
    74aa:	b95d      	cbnz	r5, 74c4 <strcmp+0x13c>
    74ac:	f850 2c04 	ldr.w	r2, [r0, #-4]
    74b0:	f851 3c04 	ldr.w	r3, [r1, #-4]
    74b4:	fa82 f54c 	uadd8	r5, r2, ip
    74b8:	ea82 0503 	eor.w	r5, r2, r3
    74bc:	faa5 f58c 	sel	r5, r5, ip
    74c0:	2d00      	cmp	r5, #0
    74c2:	d0e8      	beq.n	7496 <strcmp+0x10e>
    74c4:	ba2d      	rev	r5, r5
    74c6:	fab5 f485 	clz	r4, r5
    74ca:	f024 0407 	bic.w	r4, r4, #7
    74ce:	fa23 f104 	lsr.w	r1, r3, r4
    74d2:	fa22 f204 	lsr.w	r2, r2, r4
    74d6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    74da:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    74de:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    74e2:	eba0 0001 	sub.w	r0, r0, r1
    74e6:	4770      	bx	lr
    74e8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    74ec:	f020 0003 	bic.w	r0, r0, #3
    74f0:	f850 2b08 	ldr.w	r2, [r0], #8
    74f4:	f021 0103 	bic.w	r1, r1, #3
    74f8:	f851 3b08 	ldr.w	r3, [r1], #8
    74fc:	fa0c f404 	lsl.w	r4, ip, r4
    7500:	ea62 0204 	orn	r2, r2, r4
    7504:	ea63 0304 	orn	r3, r3, r4
    7508:	e7c9      	b.n	749e <strcmp+0x116>
    750a:	f010 0403 	ands.w	r4, r0, #3
    750e:	d01a      	beq.n	7546 <strcmp+0x1be>
    7510:	eba1 0104 	sub.w	r1, r1, r4
    7514:	f020 0003 	bic.w	r0, r0, #3
    7518:	07e4      	lsls	r4, r4, #31
    751a:	f850 2b04 	ldr.w	r2, [r0], #4
    751e:	d006      	beq.n	752e <strcmp+0x1a6>
    7520:	d20f      	bcs.n	7542 <strcmp+0x1ba>
    7522:	788b      	ldrb	r3, [r1, #2]
    7524:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    7528:	1ae4      	subs	r4, r4, r3
    752a:	d106      	bne.n	753a <strcmp+0x1b2>
    752c:	b12b      	cbz	r3, 753a <strcmp+0x1b2>
    752e:	78cb      	ldrb	r3, [r1, #3]
    7530:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    7534:	1ae4      	subs	r4, r4, r3
    7536:	d100      	bne.n	753a <strcmp+0x1b2>
    7538:	b91b      	cbnz	r3, 7542 <strcmp+0x1ba>
    753a:	4620      	mov	r0, r4
    753c:	f85d 4b10 	ldr.w	r4, [sp], #16
    7540:	4770      	bx	lr
    7542:	f101 0104 	add.w	r1, r1, #4
    7546:	f850 2b04 	ldr.w	r2, [r0], #4
    754a:	07cc      	lsls	r4, r1, #31
    754c:	f021 0103 	bic.w	r1, r1, #3
    7550:	f851 3b04 	ldr.w	r3, [r1], #4
    7554:	d848      	bhi.n	75e8 <strcmp+0x260>
    7556:	d224      	bcs.n	75a2 <strcmp+0x21a>
    7558:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    755c:	fa82 f54c 	uadd8	r5, r2, ip
    7560:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    7564:	faa5 f58c 	sel	r5, r5, ip
    7568:	d10a      	bne.n	7580 <strcmp+0x1f8>
    756a:	b965      	cbnz	r5, 7586 <strcmp+0x1fe>
    756c:	f851 3b04 	ldr.w	r3, [r1], #4
    7570:	ea84 0402 	eor.w	r4, r4, r2
    7574:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    7578:	d10e      	bne.n	7598 <strcmp+0x210>
    757a:	f850 2b04 	ldr.w	r2, [r0], #4
    757e:	e7eb      	b.n	7558 <strcmp+0x1d0>
    7580:	ea4f 2313 	mov.w	r3, r3, lsr #8
    7584:	e055      	b.n	7632 <strcmp+0x2aa>
    7586:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    758a:	d14d      	bne.n	7628 <strcmp+0x2a0>
    758c:	7808      	ldrb	r0, [r1, #0]
    758e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    7592:	f1c0 0000 	rsb	r0, r0, #0
    7596:	4770      	bx	lr
    7598:	ea4f 6212 	mov.w	r2, r2, lsr #24
    759c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    75a0:	e047      	b.n	7632 <strcmp+0x2aa>
    75a2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    75a6:	fa82 f54c 	uadd8	r5, r2, ip
    75aa:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    75ae:	faa5 f58c 	sel	r5, r5, ip
    75b2:	d10a      	bne.n	75ca <strcmp+0x242>
    75b4:	b965      	cbnz	r5, 75d0 <strcmp+0x248>
    75b6:	f851 3b04 	ldr.w	r3, [r1], #4
    75ba:	ea84 0402 	eor.w	r4, r4, r2
    75be:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    75c2:	d10c      	bne.n	75de <strcmp+0x256>
    75c4:	f850 2b04 	ldr.w	r2, [r0], #4
    75c8:	e7eb      	b.n	75a2 <strcmp+0x21a>
    75ca:	ea4f 4313 	mov.w	r3, r3, lsr #16
    75ce:	e030      	b.n	7632 <strcmp+0x2aa>
    75d0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    75d4:	d128      	bne.n	7628 <strcmp+0x2a0>
    75d6:	880b      	ldrh	r3, [r1, #0]
    75d8:	ea4f 4212 	mov.w	r2, r2, lsr #16
    75dc:	e029      	b.n	7632 <strcmp+0x2aa>
    75de:	ea4f 4212 	mov.w	r2, r2, lsr #16
    75e2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    75e6:	e024      	b.n	7632 <strcmp+0x2aa>
    75e8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    75ec:	fa82 f54c 	uadd8	r5, r2, ip
    75f0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    75f4:	faa5 f58c 	sel	r5, r5, ip
    75f8:	d10a      	bne.n	7610 <strcmp+0x288>
    75fa:	b965      	cbnz	r5, 7616 <strcmp+0x28e>
    75fc:	f851 3b04 	ldr.w	r3, [r1], #4
    7600:	ea84 0402 	eor.w	r4, r4, r2
    7604:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    7608:	d109      	bne.n	761e <strcmp+0x296>
    760a:	f850 2b04 	ldr.w	r2, [r0], #4
    760e:	e7eb      	b.n	75e8 <strcmp+0x260>
    7610:	ea4f 6313 	mov.w	r3, r3, lsr #24
    7614:	e00d      	b.n	7632 <strcmp+0x2aa>
    7616:	f015 0fff 	tst.w	r5, #255	; 0xff
    761a:	d105      	bne.n	7628 <strcmp+0x2a0>
    761c:	680b      	ldr	r3, [r1, #0]
    761e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    7622:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    7626:	e004      	b.n	7632 <strcmp+0x2aa>
    7628:	f04f 0000 	mov.w	r0, #0
    762c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    7630:	4770      	bx	lr
    7632:	ba12      	rev	r2, r2
    7634:	ba1b      	rev	r3, r3
    7636:	fa82 f44c 	uadd8	r4, r2, ip
    763a:	ea82 0403 	eor.w	r4, r2, r3
    763e:	faa4 f58c 	sel	r5, r4, ip
    7642:	fab5 f485 	clz	r4, r5
    7646:	fa02 f204 	lsl.w	r2, r2, r4
    764a:	fa03 f304 	lsl.w	r3, r3, r4
    764e:	ea4f 6012 	mov.w	r0, r2, lsr #24
    7652:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    7656:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    765a:	4770      	bx	lr

0000765c <strcpy>:
    765c:	ea80 0201 	eor.w	r2, r0, r1
    7660:	4684      	mov	ip, r0
    7662:	f012 0f03 	tst.w	r2, #3
    7666:	d14f      	bne.n	7708 <strcpy+0xac>
    7668:	f011 0f03 	tst.w	r1, #3
    766c:	d132      	bne.n	76d4 <strcpy+0x78>
    766e:	f84d 4d04 	str.w	r4, [sp, #-4]!
    7672:	f011 0f04 	tst.w	r1, #4
    7676:	f851 3b04 	ldr.w	r3, [r1], #4
    767a:	d00b      	beq.n	7694 <strcpy+0x38>
    767c:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    7680:	439a      	bics	r2, r3
    7682:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    7686:	bf04      	itt	eq
    7688:	f84c 3b04 	streq.w	r3, [ip], #4
    768c:	f851 3b04 	ldreq.w	r3, [r1], #4
    7690:	d116      	bne.n	76c0 <strcpy+0x64>
    7692:	bf00      	nop
    7694:	f851 4b04 	ldr.w	r4, [r1], #4
    7698:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    769c:	439a      	bics	r2, r3
    769e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    76a2:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    76a6:	d10b      	bne.n	76c0 <strcpy+0x64>
    76a8:	f84c 3b04 	str.w	r3, [ip], #4
    76ac:	43a2      	bics	r2, r4
    76ae:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    76b2:	bf04      	itt	eq
    76b4:	f851 3b04 	ldreq.w	r3, [r1], #4
    76b8:	f84c 4b04 	streq.w	r4, [ip], #4
    76bc:	d0ea      	beq.n	7694 <strcpy+0x38>
    76be:	4623      	mov	r3, r4
    76c0:	f80c 3b01 	strb.w	r3, [ip], #1
    76c4:	f013 0fff 	tst.w	r3, #255	; 0xff
    76c8:	ea4f 2333 	mov.w	r3, r3, ror #8
    76cc:	d1f8      	bne.n	76c0 <strcpy+0x64>
    76ce:	f85d 4b04 	ldr.w	r4, [sp], #4
    76d2:	4770      	bx	lr
    76d4:	f011 0f01 	tst.w	r1, #1
    76d8:	d006      	beq.n	76e8 <strcpy+0x8c>
    76da:	f811 2b01 	ldrb.w	r2, [r1], #1
    76de:	f80c 2b01 	strb.w	r2, [ip], #1
    76e2:	2a00      	cmp	r2, #0
    76e4:	bf08      	it	eq
    76e6:	4770      	bxeq	lr
    76e8:	f011 0f02 	tst.w	r1, #2
    76ec:	d0bf      	beq.n	766e <strcpy+0x12>
    76ee:	f831 2b02 	ldrh.w	r2, [r1], #2
    76f2:	f012 0fff 	tst.w	r2, #255	; 0xff
    76f6:	bf16      	itet	ne
    76f8:	f82c 2b02 	strhne.w	r2, [ip], #2
    76fc:	f88c 2000 	strbeq.w	r2, [ip]
    7700:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    7704:	d1b3      	bne.n	766e <strcpy+0x12>
    7706:	4770      	bx	lr
    7708:	f811 2b01 	ldrb.w	r2, [r1], #1
    770c:	f80c 2b01 	strb.w	r2, [ip], #1
    7710:	2a00      	cmp	r2, #0
    7712:	d1f9      	bne.n	7708 <strcpy+0xac>
    7714:	4770      	bx	lr
    7716:	bf00      	nop
	...

00007740 <strlen>:
    7740:	f890 f000 	pld	[r0]
    7744:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    7748:	f020 0107 	bic.w	r1, r0, #7
    774c:	f06f 0c00 	mvn.w	ip, #0
    7750:	f010 0407 	ands.w	r4, r0, #7
    7754:	f891 f020 	pld	[r1, #32]
    7758:	f040 8049 	bne.w	77ee <strlen+0xae>
    775c:	f04f 0400 	mov.w	r4, #0
    7760:	f06f 0007 	mvn.w	r0, #7
    7764:	e9d1 2300 	ldrd	r2, r3, [r1]
    7768:	f891 f040 	pld	[r1, #64]	; 0x40
    776c:	f100 0008 	add.w	r0, r0, #8
    7770:	fa82 f24c 	uadd8	r2, r2, ip
    7774:	faa4 f28c 	sel	r2, r4, ip
    7778:	fa83 f34c 	uadd8	r3, r3, ip
    777c:	faa2 f38c 	sel	r3, r2, ip
    7780:	bb4b      	cbnz	r3, 77d6 <strlen+0x96>
    7782:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    7786:	fa82 f24c 	uadd8	r2, r2, ip
    778a:	f100 0008 	add.w	r0, r0, #8
    778e:	faa4 f28c 	sel	r2, r4, ip
    7792:	fa83 f34c 	uadd8	r3, r3, ip
    7796:	faa2 f38c 	sel	r3, r2, ip
    779a:	b9e3      	cbnz	r3, 77d6 <strlen+0x96>
    779c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    77a0:	fa82 f24c 	uadd8	r2, r2, ip
    77a4:	f100 0008 	add.w	r0, r0, #8
    77a8:	faa4 f28c 	sel	r2, r4, ip
    77ac:	fa83 f34c 	uadd8	r3, r3, ip
    77b0:	faa2 f38c 	sel	r3, r2, ip
    77b4:	b97b      	cbnz	r3, 77d6 <strlen+0x96>
    77b6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    77ba:	f101 0120 	add.w	r1, r1, #32
    77be:	fa82 f24c 	uadd8	r2, r2, ip
    77c2:	f100 0008 	add.w	r0, r0, #8
    77c6:	faa4 f28c 	sel	r2, r4, ip
    77ca:	fa83 f34c 	uadd8	r3, r3, ip
    77ce:	faa2 f38c 	sel	r3, r2, ip
    77d2:	2b00      	cmp	r3, #0
    77d4:	d0c6      	beq.n	7764 <strlen+0x24>
    77d6:	2a00      	cmp	r2, #0
    77d8:	bf04      	itt	eq
    77da:	3004      	addeq	r0, #4
    77dc:	461a      	moveq	r2, r3
    77de:	ba12      	rev	r2, r2
    77e0:	fab2 f282 	clz	r2, r2
    77e4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    77e8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    77ec:	4770      	bx	lr
    77ee:	e9d1 2300 	ldrd	r2, r3, [r1]
    77f2:	f004 0503 	and.w	r5, r4, #3
    77f6:	f1c4 0000 	rsb	r0, r4, #0
    77fa:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    77fe:	f014 0f04 	tst.w	r4, #4
    7802:	f891 f040 	pld	[r1, #64]	; 0x40
    7806:	fa0c f505 	lsl.w	r5, ip, r5
    780a:	ea62 0205 	orn	r2, r2, r5
    780e:	bf1c      	itt	ne
    7810:	ea63 0305 	ornne	r3, r3, r5
    7814:	4662      	movne	r2, ip
    7816:	f04f 0400 	mov.w	r4, #0
    781a:	e7a9      	b.n	7770 <strlen+0x30>

0000781c <strncpy>:
    781c:	ea40 0301 	orr.w	r3, r0, r1
    7820:	079b      	lsls	r3, r3, #30
    7822:	b470      	push	{r4, r5, r6}
    7824:	d12b      	bne.n	787e <strncpy+0x62>
    7826:	2a03      	cmp	r2, #3
    7828:	d929      	bls.n	787e <strncpy+0x62>
    782a:	460c      	mov	r4, r1
    782c:	4603      	mov	r3, r0
    782e:	4621      	mov	r1, r4
    7830:	f854 6b04 	ldr.w	r6, [r4], #4
    7834:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
    7838:	ea25 0506 	bic.w	r5, r5, r6
    783c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
    7840:	d106      	bne.n	7850 <strncpy+0x34>
    7842:	3a04      	subs	r2, #4
    7844:	2a03      	cmp	r2, #3
    7846:	f843 6b04 	str.w	r6, [r3], #4
    784a:	4621      	mov	r1, r4
    784c:	d8ef      	bhi.n	782e <strncpy+0x12>
    784e:	b1a2      	cbz	r2, 787a <strncpy+0x5e>
    7850:	780c      	ldrb	r4, [r1, #0]
    7852:	701c      	strb	r4, [r3, #0]
    7854:	3a01      	subs	r2, #1
    7856:	3301      	adds	r3, #1
    7858:	3101      	adds	r1, #1
    785a:	b13c      	cbz	r4, 786c <strncpy+0x50>
    785c:	b16a      	cbz	r2, 787a <strncpy+0x5e>
    785e:	f811 4b01 	ldrb.w	r4, [r1], #1
    7862:	f803 4b01 	strb.w	r4, [r3], #1
    7866:	3a01      	subs	r2, #1
    7868:	2c00      	cmp	r4, #0
    786a:	d1f7      	bne.n	785c <strncpy+0x40>
    786c:	b12a      	cbz	r2, 787a <strncpy+0x5e>
    786e:	441a      	add	r2, r3
    7870:	2100      	movs	r1, #0
    7872:	f803 1b01 	strb.w	r1, [r3], #1
    7876:	429a      	cmp	r2, r3
    7878:	d1fb      	bne.n	7872 <strncpy+0x56>
    787a:	bc70      	pop	{r4, r5, r6}
    787c:	4770      	bx	lr
    787e:	4603      	mov	r3, r0
    7880:	e7e5      	b.n	784e <strncpy+0x32>
    7882:	bf00      	nop

00007884 <_vdprintf_r>:
    7884:	b5f0      	push	{r4, r5, r6, r7, lr}
    7886:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
    788a:	ad04      	add	r5, sp, #16
    788c:	9300      	str	r3, [sp, #0]
    788e:	460f      	mov	r7, r1
    7890:	4613      	mov	r3, r2
    7892:	f44f 7400 	mov.w	r4, #512	; 0x200
    7896:	aa03      	add	r2, sp, #12
    7898:	4629      	mov	r1, r5
    789a:	9403      	str	r4, [sp, #12]
    789c:	4606      	mov	r6, r0
    789e:	f000 fdb1 	bl	8404 <_vasnprintf_r>
    78a2:	b188      	cbz	r0, 78c8 <_vdprintf_r+0x44>
    78a4:	4604      	mov	r4, r0
    78a6:	4602      	mov	r2, r0
    78a8:	4639      	mov	r1, r7
    78aa:	9b03      	ldr	r3, [sp, #12]
    78ac:	4630      	mov	r0, r6
    78ae:	f000 f829 	bl	7904 <_write_r>
    78b2:	42ac      	cmp	r4, r5
    78b4:	9003      	str	r0, [sp, #12]
    78b6:	d004      	beq.n	78c2 <_vdprintf_r+0x3e>
    78b8:	4630      	mov	r0, r6
    78ba:	4621      	mov	r1, r4
    78bc:	f000 f944 	bl	7b48 <_free_r>
    78c0:	9803      	ldr	r0, [sp, #12]
    78c2:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
    78c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    78c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    78cc:	e7f9      	b.n	78c2 <_vdprintf_r+0x3e>
    78ce:	bf00      	nop

000078d0 <vdprintf>:
    78d0:	b410      	push	{r4}
    78d2:	4c04      	ldr	r4, [pc, #16]	; (78e4 <vdprintf+0x14>)
    78d4:	4613      	mov	r3, r2
    78d6:	460a      	mov	r2, r1
    78d8:	4601      	mov	r1, r0
    78da:	6820      	ldr	r0, [r4, #0]
    78dc:	f85d 4b04 	ldr.w	r4, [sp], #4
    78e0:	f7ff bfd0 	b.w	7884 <_vdprintf_r>
    78e4:	20001dd0 	.word	0x20001dd0

000078e8 <__ascii_wctomb>:
    78e8:	b121      	cbz	r1, 78f4 <__ascii_wctomb+0xc>
    78ea:	2aff      	cmp	r2, #255	; 0xff
    78ec:	d804      	bhi.n	78f8 <__ascii_wctomb+0x10>
    78ee:	700a      	strb	r2, [r1, #0]
    78f0:	2001      	movs	r0, #1
    78f2:	4770      	bx	lr
    78f4:	4608      	mov	r0, r1
    78f6:	4770      	bx	lr
    78f8:	238a      	movs	r3, #138	; 0x8a
    78fa:	6003      	str	r3, [r0, #0]
    78fc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7900:	4770      	bx	lr
    7902:	bf00      	nop

00007904 <_write_r>:
    7904:	b570      	push	{r4, r5, r6, lr}
    7906:	460d      	mov	r5, r1
    7908:	4c08      	ldr	r4, [pc, #32]	; (792c <_write_r+0x28>)
    790a:	4611      	mov	r1, r2
    790c:	4606      	mov	r6, r0
    790e:	461a      	mov	r2, r3
    7910:	4628      	mov	r0, r5
    7912:	2300      	movs	r3, #0
    7914:	6023      	str	r3, [r4, #0]
    7916:	f7fb fb61 	bl	2fdc <_write>
    791a:	1c43      	adds	r3, r0, #1
    791c:	d000      	beq.n	7920 <_write_r+0x1c>
    791e:	bd70      	pop	{r4, r5, r6, pc}
    7920:	6823      	ldr	r3, [r4, #0]
    7922:	2b00      	cmp	r3, #0
    7924:	d0fb      	beq.n	791e <_write_r+0x1a>
    7926:	6033      	str	r3, [r6, #0]
    7928:	bd70      	pop	{r4, r5, r6, pc}
    792a:	bf00      	nop
    792c:	200027f4 	.word	0x200027f4

00007930 <__register_exitproc>:
    7930:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7934:	4c25      	ldr	r4, [pc, #148]	; (79cc <__register_exitproc+0x9c>)
    7936:	6825      	ldr	r5, [r4, #0]
    7938:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    793c:	4606      	mov	r6, r0
    793e:	4688      	mov	r8, r1
    7940:	4692      	mov	sl, r2
    7942:	4699      	mov	r9, r3
    7944:	b3c4      	cbz	r4, 79b8 <__register_exitproc+0x88>
    7946:	6860      	ldr	r0, [r4, #4]
    7948:	281f      	cmp	r0, #31
    794a:	dc17      	bgt.n	797c <__register_exitproc+0x4c>
    794c:	1c43      	adds	r3, r0, #1
    794e:	b176      	cbz	r6, 796e <__register_exitproc+0x3e>
    7950:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    7954:	2201      	movs	r2, #1
    7956:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    795a:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    795e:	4082      	lsls	r2, r0
    7960:	4311      	orrs	r1, r2
    7962:	2e02      	cmp	r6, #2
    7964:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    7968:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    796c:	d01e      	beq.n	79ac <__register_exitproc+0x7c>
    796e:	3002      	adds	r0, #2
    7970:	6063      	str	r3, [r4, #4]
    7972:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    7976:	2000      	movs	r0, #0
    7978:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    797c:	4b14      	ldr	r3, [pc, #80]	; (79d0 <__register_exitproc+0xa0>)
    797e:	b303      	cbz	r3, 79c2 <__register_exitproc+0x92>
    7980:	f44f 70c8 	mov.w	r0, #400	; 0x190
    7984:	f7fe feba 	bl	66fc <malloc>
    7988:	4604      	mov	r4, r0
    798a:	b1d0      	cbz	r0, 79c2 <__register_exitproc+0x92>
    798c:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    7990:	2700      	movs	r7, #0
    7992:	e880 0088 	stmia.w	r0, {r3, r7}
    7996:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    799a:	4638      	mov	r0, r7
    799c:	2301      	movs	r3, #1
    799e:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    79a2:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    79a6:	2e00      	cmp	r6, #0
    79a8:	d0e1      	beq.n	796e <__register_exitproc+0x3e>
    79aa:	e7d1      	b.n	7950 <__register_exitproc+0x20>
    79ac:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    79b0:	430a      	orrs	r2, r1
    79b2:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    79b6:	e7da      	b.n	796e <__register_exitproc+0x3e>
    79b8:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    79bc:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    79c0:	e7c1      	b.n	7946 <__register_exitproc+0x16>
    79c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    79c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    79ca:	bf00      	nop
    79cc:	200006d0 	.word	0x200006d0
    79d0:	000066fd 	.word	0x000066fd

000079d4 <__call_exitprocs>:
    79d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    79d8:	4b32      	ldr	r3, [pc, #200]	; (7aa4 <__call_exitprocs+0xd0>)
    79da:	b085      	sub	sp, #20
    79dc:	681b      	ldr	r3, [r3, #0]
    79de:	9302      	str	r3, [sp, #8]
    79e0:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    79e4:	9001      	str	r0, [sp, #4]
    79e6:	460e      	mov	r6, r1
    79e8:	9303      	str	r3, [sp, #12]
    79ea:	9b02      	ldr	r3, [sp, #8]
    79ec:	f8d3 7148 	ldr.w	r7, [r3, #328]	; 0x148
    79f0:	b33f      	cbz	r7, 7a42 <__call_exitprocs+0x6e>
    79f2:	f8dd a00c 	ldr.w	sl, [sp, #12]
    79f6:	f04f 0901 	mov.w	r9, #1
    79fa:	46d3      	mov	fp, sl
    79fc:	687c      	ldr	r4, [r7, #4]
    79fe:	1e65      	subs	r5, r4, #1
    7a00:	d40e      	bmi.n	7a20 <__call_exitprocs+0x4c>
    7a02:	3401      	adds	r4, #1
    7a04:	eb07 0484 	add.w	r4, r7, r4, lsl #2
    7a08:	f04f 0800 	mov.w	r8, #0
    7a0c:	b1e6      	cbz	r6, 7a48 <__call_exitprocs+0x74>
    7a0e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    7a12:	429e      	cmp	r6, r3
    7a14:	d018      	beq.n	7a48 <__call_exitprocs+0x74>
    7a16:	3d01      	subs	r5, #1
    7a18:	1c6b      	adds	r3, r5, #1
    7a1a:	f1a4 0404 	sub.w	r4, r4, #4
    7a1e:	d1f5      	bne.n	7a0c <__call_exitprocs+0x38>
    7a20:	4b21      	ldr	r3, [pc, #132]	; (7aa8 <__call_exitprocs+0xd4>)
    7a22:	b173      	cbz	r3, 7a42 <__call_exitprocs+0x6e>
    7a24:	687b      	ldr	r3, [r7, #4]
    7a26:	2b00      	cmp	r3, #0
    7a28:	d136      	bne.n	7a98 <__call_exitprocs+0xc4>
    7a2a:	683b      	ldr	r3, [r7, #0]
    7a2c:	2b00      	cmp	r3, #0
    7a2e:	d034      	beq.n	7a9a <__call_exitprocs+0xc6>
    7a30:	4638      	mov	r0, r7
    7a32:	f8cb 3000 	str.w	r3, [fp]
    7a36:	f7fe fe69 	bl	670c <free>
    7a3a:	f8db 7000 	ldr.w	r7, [fp]
    7a3e:	2f00      	cmp	r7, #0
    7a40:	d1dc      	bne.n	79fc <__call_exitprocs+0x28>
    7a42:	b005      	add	sp, #20
    7a44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7a48:	687b      	ldr	r3, [r7, #4]
    7a4a:	6822      	ldr	r2, [r4, #0]
    7a4c:	3b01      	subs	r3, #1
    7a4e:	42ab      	cmp	r3, r5
    7a50:	bf0c      	ite	eq
    7a52:	607d      	streq	r5, [r7, #4]
    7a54:	f8c4 8000 	strne.w	r8, [r4]
    7a58:	2a00      	cmp	r2, #0
    7a5a:	d0dc      	beq.n	7a16 <__call_exitprocs+0x42>
    7a5c:	f8d7 1188 	ldr.w	r1, [r7, #392]	; 0x188
    7a60:	f8d7 a004 	ldr.w	sl, [r7, #4]
    7a64:	fa09 f305 	lsl.w	r3, r9, r5
    7a68:	420b      	tst	r3, r1
    7a6a:	d00f      	beq.n	7a8c <__call_exitprocs+0xb8>
    7a6c:	f8d7 118c 	ldr.w	r1, [r7, #396]	; 0x18c
    7a70:	420b      	tst	r3, r1
    7a72:	d10d      	bne.n	7a90 <__call_exitprocs+0xbc>
    7a74:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
    7a78:	9801      	ldr	r0, [sp, #4]
    7a7a:	4790      	blx	r2
    7a7c:	687b      	ldr	r3, [r7, #4]
    7a7e:	4553      	cmp	r3, sl
    7a80:	d1b3      	bne.n	79ea <__call_exitprocs+0x16>
    7a82:	f8db 3000 	ldr.w	r3, [fp]
    7a86:	42bb      	cmp	r3, r7
    7a88:	d0c5      	beq.n	7a16 <__call_exitprocs+0x42>
    7a8a:	e7ae      	b.n	79ea <__call_exitprocs+0x16>
    7a8c:	4790      	blx	r2
    7a8e:	e7f5      	b.n	7a7c <__call_exitprocs+0xa8>
    7a90:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
    7a94:	4790      	blx	r2
    7a96:	e7f1      	b.n	7a7c <__call_exitprocs+0xa8>
    7a98:	683b      	ldr	r3, [r7, #0]
    7a9a:	46bb      	mov	fp, r7
    7a9c:	461f      	mov	r7, r3
    7a9e:	2f00      	cmp	r7, #0
    7aa0:	d1ac      	bne.n	79fc <__call_exitprocs+0x28>
    7aa2:	e7ce      	b.n	7a42 <__call_exitprocs+0x6e>
    7aa4:	200006d0 	.word	0x200006d0
    7aa8:	0000670d 	.word	0x0000670d

00007aac <_malloc_trim_r>:
    7aac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7aae:	4f23      	ldr	r7, [pc, #140]	; (7b3c <_malloc_trim_r+0x90>)
    7ab0:	460c      	mov	r4, r1
    7ab2:	4606      	mov	r6, r0
    7ab4:	f7ff fa4c 	bl	6f50 <__malloc_lock>
    7ab8:	68bb      	ldr	r3, [r7, #8]
    7aba:	685d      	ldr	r5, [r3, #4]
    7abc:	f025 0503 	bic.w	r5, r5, #3
    7ac0:	1b29      	subs	r1, r5, r4
    7ac2:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    7ac6:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    7aca:	f021 010f 	bic.w	r1, r1, #15
    7ace:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    7ad2:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    7ad6:	db07      	blt.n	7ae8 <_malloc_trim_r+0x3c>
    7ad8:	2100      	movs	r1, #0
    7ada:	4630      	mov	r0, r6
    7adc:	f7ff fc34 	bl	7348 <_sbrk_r>
    7ae0:	68bb      	ldr	r3, [r7, #8]
    7ae2:	442b      	add	r3, r5
    7ae4:	4298      	cmp	r0, r3
    7ae6:	d004      	beq.n	7af2 <_malloc_trim_r+0x46>
    7ae8:	4630      	mov	r0, r6
    7aea:	f7ff fa33 	bl	6f54 <__malloc_unlock>
    7aee:	2000      	movs	r0, #0
    7af0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7af2:	4261      	negs	r1, r4
    7af4:	4630      	mov	r0, r6
    7af6:	f7ff fc27 	bl	7348 <_sbrk_r>
    7afa:	3001      	adds	r0, #1
    7afc:	d00d      	beq.n	7b1a <_malloc_trim_r+0x6e>
    7afe:	4b10      	ldr	r3, [pc, #64]	; (7b40 <_malloc_trim_r+0x94>)
    7b00:	68ba      	ldr	r2, [r7, #8]
    7b02:	6819      	ldr	r1, [r3, #0]
    7b04:	1b2d      	subs	r5, r5, r4
    7b06:	f045 0501 	orr.w	r5, r5, #1
    7b0a:	4630      	mov	r0, r6
    7b0c:	1b09      	subs	r1, r1, r4
    7b0e:	6055      	str	r5, [r2, #4]
    7b10:	6019      	str	r1, [r3, #0]
    7b12:	f7ff fa1f 	bl	6f54 <__malloc_unlock>
    7b16:	2001      	movs	r0, #1
    7b18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7b1a:	2100      	movs	r1, #0
    7b1c:	4630      	mov	r0, r6
    7b1e:	f7ff fc13 	bl	7348 <_sbrk_r>
    7b22:	68ba      	ldr	r2, [r7, #8]
    7b24:	1a83      	subs	r3, r0, r2
    7b26:	2b0f      	cmp	r3, #15
    7b28:	ddde      	ble.n	7ae8 <_malloc_trim_r+0x3c>
    7b2a:	4c06      	ldr	r4, [pc, #24]	; (7b44 <_malloc_trim_r+0x98>)
    7b2c:	4904      	ldr	r1, [pc, #16]	; (7b40 <_malloc_trim_r+0x94>)
    7b2e:	6824      	ldr	r4, [r4, #0]
    7b30:	f043 0301 	orr.w	r3, r3, #1
    7b34:	1b00      	subs	r0, r0, r4
    7b36:	6053      	str	r3, [r2, #4]
    7b38:	6008      	str	r0, [r1, #0]
    7b3a:	e7d5      	b.n	7ae8 <_malloc_trim_r+0x3c>
    7b3c:	200019c0 	.word	0x200019c0
    7b40:	200026b4 	.word	0x200026b4
    7b44:	20001dc8 	.word	0x20001dc8

00007b48 <_free_r>:
    7b48:	2900      	cmp	r1, #0
    7b4a:	d045      	beq.n	7bd8 <_free_r+0x90>
    7b4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7b50:	460d      	mov	r5, r1
    7b52:	4680      	mov	r8, r0
    7b54:	f7ff f9fc 	bl	6f50 <__malloc_lock>
    7b58:	f855 7c04 	ldr.w	r7, [r5, #-4]
    7b5c:	496a      	ldr	r1, [pc, #424]	; (7d08 <_free_r+0x1c0>)
    7b5e:	f027 0301 	bic.w	r3, r7, #1
    7b62:	f1a5 0408 	sub.w	r4, r5, #8
    7b66:	18e2      	adds	r2, r4, r3
    7b68:	688e      	ldr	r6, [r1, #8]
    7b6a:	6850      	ldr	r0, [r2, #4]
    7b6c:	42b2      	cmp	r2, r6
    7b6e:	f020 0003 	bic.w	r0, r0, #3
    7b72:	d062      	beq.n	7c3a <_free_r+0xf2>
    7b74:	07fe      	lsls	r6, r7, #31
    7b76:	6050      	str	r0, [r2, #4]
    7b78:	d40b      	bmi.n	7b92 <_free_r+0x4a>
    7b7a:	f855 7c08 	ldr.w	r7, [r5, #-8]
    7b7e:	1be4      	subs	r4, r4, r7
    7b80:	f101 0e08 	add.w	lr, r1, #8
    7b84:	68a5      	ldr	r5, [r4, #8]
    7b86:	4575      	cmp	r5, lr
    7b88:	443b      	add	r3, r7
    7b8a:	d06f      	beq.n	7c6c <_free_r+0x124>
    7b8c:	68e7      	ldr	r7, [r4, #12]
    7b8e:	60ef      	str	r7, [r5, #12]
    7b90:	60bd      	str	r5, [r7, #8]
    7b92:	1815      	adds	r5, r2, r0
    7b94:	686d      	ldr	r5, [r5, #4]
    7b96:	07ed      	lsls	r5, r5, #31
    7b98:	d542      	bpl.n	7c20 <_free_r+0xd8>
    7b9a:	f043 0201 	orr.w	r2, r3, #1
    7b9e:	6062      	str	r2, [r4, #4]
    7ba0:	50e3      	str	r3, [r4, r3]
    7ba2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    7ba6:	d218      	bcs.n	7bda <_free_r+0x92>
    7ba8:	08db      	lsrs	r3, r3, #3
    7baa:	1c5a      	adds	r2, r3, #1
    7bac:	684d      	ldr	r5, [r1, #4]
    7bae:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    7bb2:	60a7      	str	r7, [r4, #8]
    7bb4:	2001      	movs	r0, #1
    7bb6:	109b      	asrs	r3, r3, #2
    7bb8:	fa00 f303 	lsl.w	r3, r0, r3
    7bbc:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    7bc0:	431d      	orrs	r5, r3
    7bc2:	3808      	subs	r0, #8
    7bc4:	60e0      	str	r0, [r4, #12]
    7bc6:	604d      	str	r5, [r1, #4]
    7bc8:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    7bcc:	60fc      	str	r4, [r7, #12]
    7bce:	4640      	mov	r0, r8
    7bd0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7bd4:	f7ff b9be 	b.w	6f54 <__malloc_unlock>
    7bd8:	4770      	bx	lr
    7bda:	0a5a      	lsrs	r2, r3, #9
    7bdc:	2a04      	cmp	r2, #4
    7bde:	d853      	bhi.n	7c88 <_free_r+0x140>
    7be0:	099a      	lsrs	r2, r3, #6
    7be2:	f102 0739 	add.w	r7, r2, #57	; 0x39
    7be6:	007f      	lsls	r7, r7, #1
    7be8:	f102 0538 	add.w	r5, r2, #56	; 0x38
    7bec:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    7bf0:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    7bf4:	4944      	ldr	r1, [pc, #272]	; (7d08 <_free_r+0x1c0>)
    7bf6:	3808      	subs	r0, #8
    7bf8:	4290      	cmp	r0, r2
    7bfa:	d04d      	beq.n	7c98 <_free_r+0x150>
    7bfc:	6851      	ldr	r1, [r2, #4]
    7bfe:	f021 0103 	bic.w	r1, r1, #3
    7c02:	428b      	cmp	r3, r1
    7c04:	d202      	bcs.n	7c0c <_free_r+0xc4>
    7c06:	6892      	ldr	r2, [r2, #8]
    7c08:	4290      	cmp	r0, r2
    7c0a:	d1f7      	bne.n	7bfc <_free_r+0xb4>
    7c0c:	68d0      	ldr	r0, [r2, #12]
    7c0e:	60e0      	str	r0, [r4, #12]
    7c10:	60a2      	str	r2, [r4, #8]
    7c12:	6084      	str	r4, [r0, #8]
    7c14:	60d4      	str	r4, [r2, #12]
    7c16:	4640      	mov	r0, r8
    7c18:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7c1c:	f7ff b99a 	b.w	6f54 <__malloc_unlock>
    7c20:	6895      	ldr	r5, [r2, #8]
    7c22:	4f3a      	ldr	r7, [pc, #232]	; (7d0c <_free_r+0x1c4>)
    7c24:	42bd      	cmp	r5, r7
    7c26:	4403      	add	r3, r0
    7c28:	d03f      	beq.n	7caa <_free_r+0x162>
    7c2a:	68d0      	ldr	r0, [r2, #12]
    7c2c:	60e8      	str	r0, [r5, #12]
    7c2e:	f043 0201 	orr.w	r2, r3, #1
    7c32:	6085      	str	r5, [r0, #8]
    7c34:	6062      	str	r2, [r4, #4]
    7c36:	50e3      	str	r3, [r4, r3]
    7c38:	e7b3      	b.n	7ba2 <_free_r+0x5a>
    7c3a:	07ff      	lsls	r7, r7, #31
    7c3c:	4403      	add	r3, r0
    7c3e:	d407      	bmi.n	7c50 <_free_r+0x108>
    7c40:	f855 2c08 	ldr.w	r2, [r5, #-8]
    7c44:	1aa4      	subs	r4, r4, r2
    7c46:	4413      	add	r3, r2
    7c48:	68a0      	ldr	r0, [r4, #8]
    7c4a:	68e2      	ldr	r2, [r4, #12]
    7c4c:	60c2      	str	r2, [r0, #12]
    7c4e:	6090      	str	r0, [r2, #8]
    7c50:	4a2f      	ldr	r2, [pc, #188]	; (7d10 <_free_r+0x1c8>)
    7c52:	6812      	ldr	r2, [r2, #0]
    7c54:	f043 0001 	orr.w	r0, r3, #1
    7c58:	4293      	cmp	r3, r2
    7c5a:	6060      	str	r0, [r4, #4]
    7c5c:	608c      	str	r4, [r1, #8]
    7c5e:	d3b6      	bcc.n	7bce <_free_r+0x86>
    7c60:	4b2c      	ldr	r3, [pc, #176]	; (7d14 <_free_r+0x1cc>)
    7c62:	4640      	mov	r0, r8
    7c64:	6819      	ldr	r1, [r3, #0]
    7c66:	f7ff ff21 	bl	7aac <_malloc_trim_r>
    7c6a:	e7b0      	b.n	7bce <_free_r+0x86>
    7c6c:	1811      	adds	r1, r2, r0
    7c6e:	6849      	ldr	r1, [r1, #4]
    7c70:	07c9      	lsls	r1, r1, #31
    7c72:	d444      	bmi.n	7cfe <_free_r+0x1b6>
    7c74:	6891      	ldr	r1, [r2, #8]
    7c76:	68d2      	ldr	r2, [r2, #12]
    7c78:	60ca      	str	r2, [r1, #12]
    7c7a:	4403      	add	r3, r0
    7c7c:	f043 0001 	orr.w	r0, r3, #1
    7c80:	6091      	str	r1, [r2, #8]
    7c82:	6060      	str	r0, [r4, #4]
    7c84:	50e3      	str	r3, [r4, r3]
    7c86:	e7a2      	b.n	7bce <_free_r+0x86>
    7c88:	2a14      	cmp	r2, #20
    7c8a:	d817      	bhi.n	7cbc <_free_r+0x174>
    7c8c:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    7c90:	007f      	lsls	r7, r7, #1
    7c92:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    7c96:	e7a9      	b.n	7bec <_free_r+0xa4>
    7c98:	10aa      	asrs	r2, r5, #2
    7c9a:	684b      	ldr	r3, [r1, #4]
    7c9c:	2501      	movs	r5, #1
    7c9e:	fa05 f202 	lsl.w	r2, r5, r2
    7ca2:	4313      	orrs	r3, r2
    7ca4:	604b      	str	r3, [r1, #4]
    7ca6:	4602      	mov	r2, r0
    7ca8:	e7b1      	b.n	7c0e <_free_r+0xc6>
    7caa:	f043 0201 	orr.w	r2, r3, #1
    7cae:	614c      	str	r4, [r1, #20]
    7cb0:	610c      	str	r4, [r1, #16]
    7cb2:	60e5      	str	r5, [r4, #12]
    7cb4:	60a5      	str	r5, [r4, #8]
    7cb6:	6062      	str	r2, [r4, #4]
    7cb8:	50e3      	str	r3, [r4, r3]
    7cba:	e788      	b.n	7bce <_free_r+0x86>
    7cbc:	2a54      	cmp	r2, #84	; 0x54
    7cbe:	d806      	bhi.n	7cce <_free_r+0x186>
    7cc0:	0b1a      	lsrs	r2, r3, #12
    7cc2:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    7cc6:	007f      	lsls	r7, r7, #1
    7cc8:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    7ccc:	e78e      	b.n	7bec <_free_r+0xa4>
    7cce:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    7cd2:	d806      	bhi.n	7ce2 <_free_r+0x19a>
    7cd4:	0bda      	lsrs	r2, r3, #15
    7cd6:	f102 0778 	add.w	r7, r2, #120	; 0x78
    7cda:	007f      	lsls	r7, r7, #1
    7cdc:	f102 0577 	add.w	r5, r2, #119	; 0x77
    7ce0:	e784      	b.n	7bec <_free_r+0xa4>
    7ce2:	f240 5054 	movw	r0, #1364	; 0x554
    7ce6:	4282      	cmp	r2, r0
    7ce8:	d806      	bhi.n	7cf8 <_free_r+0x1b0>
    7cea:	0c9a      	lsrs	r2, r3, #18
    7cec:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    7cf0:	007f      	lsls	r7, r7, #1
    7cf2:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    7cf6:	e779      	b.n	7bec <_free_r+0xa4>
    7cf8:	27fe      	movs	r7, #254	; 0xfe
    7cfa:	257e      	movs	r5, #126	; 0x7e
    7cfc:	e776      	b.n	7bec <_free_r+0xa4>
    7cfe:	f043 0201 	orr.w	r2, r3, #1
    7d02:	6062      	str	r2, [r4, #4]
    7d04:	50e3      	str	r3, [r4, r3]
    7d06:	e762      	b.n	7bce <_free_r+0x86>
    7d08:	200019c0 	.word	0x200019c0
    7d0c:	200019c8 	.word	0x200019c8
    7d10:	20001dcc 	.word	0x20001dcc
    7d14:	200026e4 	.word	0x200026e4

00007d18 <_localeconv_r>:
    7d18:	4a04      	ldr	r2, [pc, #16]	; (7d2c <_localeconv_r+0x14>)
    7d1a:	4b05      	ldr	r3, [pc, #20]	; (7d30 <_localeconv_r+0x18>)
    7d1c:	6812      	ldr	r2, [r2, #0]
    7d1e:	6b50      	ldr	r0, [r2, #52]	; 0x34
    7d20:	2800      	cmp	r0, #0
    7d22:	bf08      	it	eq
    7d24:	4618      	moveq	r0, r3
    7d26:	30f0      	adds	r0, #240	; 0xf0
    7d28:	4770      	bx	lr
    7d2a:	bf00      	nop
    7d2c:	20001dd0 	.word	0x20001dd0
    7d30:	20001854 	.word	0x20001854
	...

00007d40 <memchr>:
    7d40:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    7d44:	2a10      	cmp	r2, #16
    7d46:	db2b      	blt.n	7da0 <memchr+0x60>
    7d48:	f010 0f07 	tst.w	r0, #7
    7d4c:	d008      	beq.n	7d60 <memchr+0x20>
    7d4e:	f810 3b01 	ldrb.w	r3, [r0], #1
    7d52:	3a01      	subs	r2, #1
    7d54:	428b      	cmp	r3, r1
    7d56:	d02d      	beq.n	7db4 <memchr+0x74>
    7d58:	f010 0f07 	tst.w	r0, #7
    7d5c:	b342      	cbz	r2, 7db0 <memchr+0x70>
    7d5e:	d1f6      	bne.n	7d4e <memchr+0xe>
    7d60:	b4f0      	push	{r4, r5, r6, r7}
    7d62:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    7d66:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    7d6a:	f022 0407 	bic.w	r4, r2, #7
    7d6e:	f07f 0700 	mvns.w	r7, #0
    7d72:	2300      	movs	r3, #0
    7d74:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    7d78:	3c08      	subs	r4, #8
    7d7a:	ea85 0501 	eor.w	r5, r5, r1
    7d7e:	ea86 0601 	eor.w	r6, r6, r1
    7d82:	fa85 f547 	uadd8	r5, r5, r7
    7d86:	faa3 f587 	sel	r5, r3, r7
    7d8a:	fa86 f647 	uadd8	r6, r6, r7
    7d8e:	faa5 f687 	sel	r6, r5, r7
    7d92:	b98e      	cbnz	r6, 7db8 <memchr+0x78>
    7d94:	d1ee      	bne.n	7d74 <memchr+0x34>
    7d96:	bcf0      	pop	{r4, r5, r6, r7}
    7d98:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    7d9c:	f002 0207 	and.w	r2, r2, #7
    7da0:	b132      	cbz	r2, 7db0 <memchr+0x70>
    7da2:	f810 3b01 	ldrb.w	r3, [r0], #1
    7da6:	3a01      	subs	r2, #1
    7da8:	ea83 0301 	eor.w	r3, r3, r1
    7dac:	b113      	cbz	r3, 7db4 <memchr+0x74>
    7dae:	d1f8      	bne.n	7da2 <memchr+0x62>
    7db0:	2000      	movs	r0, #0
    7db2:	4770      	bx	lr
    7db4:	3801      	subs	r0, #1
    7db6:	4770      	bx	lr
    7db8:	2d00      	cmp	r5, #0
    7dba:	bf06      	itte	eq
    7dbc:	4635      	moveq	r5, r6
    7dbe:	3803      	subeq	r0, #3
    7dc0:	3807      	subne	r0, #7
    7dc2:	f015 0f01 	tst.w	r5, #1
    7dc6:	d107      	bne.n	7dd8 <memchr+0x98>
    7dc8:	3001      	adds	r0, #1
    7dca:	f415 7f80 	tst.w	r5, #256	; 0x100
    7dce:	bf02      	ittt	eq
    7dd0:	3001      	addeq	r0, #1
    7dd2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    7dd6:	3001      	addeq	r0, #1
    7dd8:	bcf0      	pop	{r4, r5, r6, r7}
    7dda:	3801      	subs	r0, #1
    7ddc:	4770      	bx	lr
    7dde:	bf00      	nop

00007de0 <_Balloc>:
    7de0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    7de2:	b570      	push	{r4, r5, r6, lr}
    7de4:	4605      	mov	r5, r0
    7de6:	460c      	mov	r4, r1
    7de8:	b14b      	cbz	r3, 7dfe <_Balloc+0x1e>
    7dea:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    7dee:	b180      	cbz	r0, 7e12 <_Balloc+0x32>
    7df0:	6802      	ldr	r2, [r0, #0]
    7df2:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    7df6:	2300      	movs	r3, #0
    7df8:	6103      	str	r3, [r0, #16]
    7dfa:	60c3      	str	r3, [r0, #12]
    7dfc:	bd70      	pop	{r4, r5, r6, pc}
    7dfe:	2221      	movs	r2, #33	; 0x21
    7e00:	2104      	movs	r1, #4
    7e02:	f000 fb2f 	bl	8464 <_calloc_r>
    7e06:	64e8      	str	r0, [r5, #76]	; 0x4c
    7e08:	4603      	mov	r3, r0
    7e0a:	2800      	cmp	r0, #0
    7e0c:	d1ed      	bne.n	7dea <_Balloc+0xa>
    7e0e:	2000      	movs	r0, #0
    7e10:	bd70      	pop	{r4, r5, r6, pc}
    7e12:	2101      	movs	r1, #1
    7e14:	fa01 f604 	lsl.w	r6, r1, r4
    7e18:	1d72      	adds	r2, r6, #5
    7e1a:	4628      	mov	r0, r5
    7e1c:	0092      	lsls	r2, r2, #2
    7e1e:	f000 fb21 	bl	8464 <_calloc_r>
    7e22:	2800      	cmp	r0, #0
    7e24:	d0f3      	beq.n	7e0e <_Balloc+0x2e>
    7e26:	6044      	str	r4, [r0, #4]
    7e28:	6086      	str	r6, [r0, #8]
    7e2a:	e7e4      	b.n	7df6 <_Balloc+0x16>

00007e2c <_Bfree>:
    7e2c:	b131      	cbz	r1, 7e3c <_Bfree+0x10>
    7e2e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    7e30:	684a      	ldr	r2, [r1, #4]
    7e32:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    7e36:	6008      	str	r0, [r1, #0]
    7e38:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    7e3c:	4770      	bx	lr
    7e3e:	bf00      	nop

00007e40 <__multadd>:
    7e40:	b5f0      	push	{r4, r5, r6, r7, lr}
    7e42:	690c      	ldr	r4, [r1, #16]
    7e44:	b083      	sub	sp, #12
    7e46:	460d      	mov	r5, r1
    7e48:	4606      	mov	r6, r0
    7e4a:	f101 0e14 	add.w	lr, r1, #20
    7e4e:	2700      	movs	r7, #0
    7e50:	f8de 0000 	ldr.w	r0, [lr]
    7e54:	b281      	uxth	r1, r0
    7e56:	fb02 3101 	mla	r1, r2, r1, r3
    7e5a:	0c0b      	lsrs	r3, r1, #16
    7e5c:	0c00      	lsrs	r0, r0, #16
    7e5e:	fb02 3300 	mla	r3, r2, r0, r3
    7e62:	b289      	uxth	r1, r1
    7e64:	3701      	adds	r7, #1
    7e66:	eb01 4103 	add.w	r1, r1, r3, lsl #16
    7e6a:	42bc      	cmp	r4, r7
    7e6c:	f84e 1b04 	str.w	r1, [lr], #4
    7e70:	ea4f 4313 	mov.w	r3, r3, lsr #16
    7e74:	dcec      	bgt.n	7e50 <__multadd+0x10>
    7e76:	b13b      	cbz	r3, 7e88 <__multadd+0x48>
    7e78:	68aa      	ldr	r2, [r5, #8]
    7e7a:	4294      	cmp	r4, r2
    7e7c:	da07      	bge.n	7e8e <__multadd+0x4e>
    7e7e:	eb05 0284 	add.w	r2, r5, r4, lsl #2
    7e82:	3401      	adds	r4, #1
    7e84:	6153      	str	r3, [r2, #20]
    7e86:	612c      	str	r4, [r5, #16]
    7e88:	4628      	mov	r0, r5
    7e8a:	b003      	add	sp, #12
    7e8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7e8e:	6869      	ldr	r1, [r5, #4]
    7e90:	9301      	str	r3, [sp, #4]
    7e92:	3101      	adds	r1, #1
    7e94:	4630      	mov	r0, r6
    7e96:	f7ff ffa3 	bl	7de0 <_Balloc>
    7e9a:	692a      	ldr	r2, [r5, #16]
    7e9c:	3202      	adds	r2, #2
    7e9e:	f105 010c 	add.w	r1, r5, #12
    7ea2:	4607      	mov	r7, r0
    7ea4:	0092      	lsls	r2, r2, #2
    7ea6:	300c      	adds	r0, #12
    7ea8:	f7fe ff06 	bl	6cb8 <memcpy>
    7eac:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
    7eae:	6869      	ldr	r1, [r5, #4]
    7eb0:	9b01      	ldr	r3, [sp, #4]
    7eb2:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
    7eb6:	6028      	str	r0, [r5, #0]
    7eb8:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
    7ebc:	463d      	mov	r5, r7
    7ebe:	e7de      	b.n	7e7e <__multadd+0x3e>

00007ec0 <__hi0bits>:
    7ec0:	0c03      	lsrs	r3, r0, #16
    7ec2:	041b      	lsls	r3, r3, #16
    7ec4:	b9b3      	cbnz	r3, 7ef4 <__hi0bits+0x34>
    7ec6:	0400      	lsls	r0, r0, #16
    7ec8:	2310      	movs	r3, #16
    7eca:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
    7ece:	bf04      	itt	eq
    7ed0:	0200      	lsleq	r0, r0, #8
    7ed2:	3308      	addeq	r3, #8
    7ed4:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
    7ed8:	bf04      	itt	eq
    7eda:	0100      	lsleq	r0, r0, #4
    7edc:	3304      	addeq	r3, #4
    7ede:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
    7ee2:	bf04      	itt	eq
    7ee4:	0080      	lsleq	r0, r0, #2
    7ee6:	3302      	addeq	r3, #2
    7ee8:	2800      	cmp	r0, #0
    7eea:	db07      	blt.n	7efc <__hi0bits+0x3c>
    7eec:	0042      	lsls	r2, r0, #1
    7eee:	d403      	bmi.n	7ef8 <__hi0bits+0x38>
    7ef0:	2020      	movs	r0, #32
    7ef2:	4770      	bx	lr
    7ef4:	2300      	movs	r3, #0
    7ef6:	e7e8      	b.n	7eca <__hi0bits+0xa>
    7ef8:	1c58      	adds	r0, r3, #1
    7efa:	4770      	bx	lr
    7efc:	4618      	mov	r0, r3
    7efe:	4770      	bx	lr

00007f00 <__lo0bits>:
    7f00:	6803      	ldr	r3, [r0, #0]
    7f02:	f013 0207 	ands.w	r2, r3, #7
    7f06:	d007      	beq.n	7f18 <__lo0bits+0x18>
    7f08:	07d9      	lsls	r1, r3, #31
    7f0a:	d420      	bmi.n	7f4e <__lo0bits+0x4e>
    7f0c:	079a      	lsls	r2, r3, #30
    7f0e:	d420      	bmi.n	7f52 <__lo0bits+0x52>
    7f10:	089b      	lsrs	r3, r3, #2
    7f12:	6003      	str	r3, [r0, #0]
    7f14:	2002      	movs	r0, #2
    7f16:	4770      	bx	lr
    7f18:	b299      	uxth	r1, r3
    7f1a:	b909      	cbnz	r1, 7f20 <__lo0bits+0x20>
    7f1c:	0c1b      	lsrs	r3, r3, #16
    7f1e:	2210      	movs	r2, #16
    7f20:	f013 0fff 	tst.w	r3, #255	; 0xff
    7f24:	bf04      	itt	eq
    7f26:	0a1b      	lsreq	r3, r3, #8
    7f28:	3208      	addeq	r2, #8
    7f2a:	0719      	lsls	r1, r3, #28
    7f2c:	bf04      	itt	eq
    7f2e:	091b      	lsreq	r3, r3, #4
    7f30:	3204      	addeq	r2, #4
    7f32:	0799      	lsls	r1, r3, #30
    7f34:	bf04      	itt	eq
    7f36:	089b      	lsreq	r3, r3, #2
    7f38:	3202      	addeq	r2, #2
    7f3a:	07d9      	lsls	r1, r3, #31
    7f3c:	d404      	bmi.n	7f48 <__lo0bits+0x48>
    7f3e:	085b      	lsrs	r3, r3, #1
    7f40:	d101      	bne.n	7f46 <__lo0bits+0x46>
    7f42:	2020      	movs	r0, #32
    7f44:	4770      	bx	lr
    7f46:	3201      	adds	r2, #1
    7f48:	6003      	str	r3, [r0, #0]
    7f4a:	4610      	mov	r0, r2
    7f4c:	4770      	bx	lr
    7f4e:	2000      	movs	r0, #0
    7f50:	4770      	bx	lr
    7f52:	085b      	lsrs	r3, r3, #1
    7f54:	6003      	str	r3, [r0, #0]
    7f56:	2001      	movs	r0, #1
    7f58:	4770      	bx	lr
    7f5a:	bf00      	nop

00007f5c <__i2b>:
    7f5c:	b510      	push	{r4, lr}
    7f5e:	460c      	mov	r4, r1
    7f60:	2101      	movs	r1, #1
    7f62:	f7ff ff3d 	bl	7de0 <_Balloc>
    7f66:	2201      	movs	r2, #1
    7f68:	6144      	str	r4, [r0, #20]
    7f6a:	6102      	str	r2, [r0, #16]
    7f6c:	bd10      	pop	{r4, pc}
    7f6e:	bf00      	nop

00007f70 <__multiply>:
    7f70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7f74:	690d      	ldr	r5, [r1, #16]
    7f76:	6917      	ldr	r7, [r2, #16]
    7f78:	42bd      	cmp	r5, r7
    7f7a:	b083      	sub	sp, #12
    7f7c:	460c      	mov	r4, r1
    7f7e:	4616      	mov	r6, r2
    7f80:	da04      	bge.n	7f8c <__multiply+0x1c>
    7f82:	462a      	mov	r2, r5
    7f84:	4634      	mov	r4, r6
    7f86:	463d      	mov	r5, r7
    7f88:	460e      	mov	r6, r1
    7f8a:	4617      	mov	r7, r2
    7f8c:	68a3      	ldr	r3, [r4, #8]
    7f8e:	6861      	ldr	r1, [r4, #4]
    7f90:	eb05 0807 	add.w	r8, r5, r7
    7f94:	4598      	cmp	r8, r3
    7f96:	bfc8      	it	gt
    7f98:	3101      	addgt	r1, #1
    7f9a:	f7ff ff21 	bl	7de0 <_Balloc>
    7f9e:	f100 0c14 	add.w	ip, r0, #20
    7fa2:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
    7fa6:	45cc      	cmp	ip, r9
    7fa8:	9000      	str	r0, [sp, #0]
    7faa:	d205      	bcs.n	7fb8 <__multiply+0x48>
    7fac:	4663      	mov	r3, ip
    7fae:	2100      	movs	r1, #0
    7fb0:	f843 1b04 	str.w	r1, [r3], #4
    7fb4:	4599      	cmp	r9, r3
    7fb6:	d8fb      	bhi.n	7fb0 <__multiply+0x40>
    7fb8:	f106 0214 	add.w	r2, r6, #20
    7fbc:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
    7fc0:	f104 0314 	add.w	r3, r4, #20
    7fc4:	4552      	cmp	r2, sl
    7fc6:	eb03 0e85 	add.w	lr, r3, r5, lsl #2
    7fca:	d254      	bcs.n	8076 <__multiply+0x106>
    7fcc:	f8cd 9004 	str.w	r9, [sp, #4]
    7fd0:	4699      	mov	r9, r3
    7fd2:	f852 3b04 	ldr.w	r3, [r2], #4
    7fd6:	fa1f fb83 	uxth.w	fp, r3
    7fda:	f1bb 0f00 	cmp.w	fp, #0
    7fde:	d020      	beq.n	8022 <__multiply+0xb2>
    7fe0:	2000      	movs	r0, #0
    7fe2:	464f      	mov	r7, r9
    7fe4:	4666      	mov	r6, ip
    7fe6:	4605      	mov	r5, r0
    7fe8:	e000      	b.n	7fec <__multiply+0x7c>
    7fea:	461e      	mov	r6, r3
    7fec:	f857 4b04 	ldr.w	r4, [r7], #4
    7ff0:	6830      	ldr	r0, [r6, #0]
    7ff2:	b2a1      	uxth	r1, r4
    7ff4:	b283      	uxth	r3, r0
    7ff6:	fb0b 3101 	mla	r1, fp, r1, r3
    7ffa:	0c24      	lsrs	r4, r4, #16
    7ffc:	0c00      	lsrs	r0, r0, #16
    7ffe:	194b      	adds	r3, r1, r5
    8000:	fb0b 0004 	mla	r0, fp, r4, r0
    8004:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    8008:	b299      	uxth	r1, r3
    800a:	4633      	mov	r3, r6
    800c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    8010:	45be      	cmp	lr, r7
    8012:	ea4f 4510 	mov.w	r5, r0, lsr #16
    8016:	f843 1b04 	str.w	r1, [r3], #4
    801a:	d8e6      	bhi.n	7fea <__multiply+0x7a>
    801c:	6075      	str	r5, [r6, #4]
    801e:	f852 3c04 	ldr.w	r3, [r2, #-4]
    8022:	ea5f 4b13 	movs.w	fp, r3, lsr #16
    8026:	d020      	beq.n	806a <__multiply+0xfa>
    8028:	f8dc 3000 	ldr.w	r3, [ip]
    802c:	4667      	mov	r7, ip
    802e:	4618      	mov	r0, r3
    8030:	464d      	mov	r5, r9
    8032:	2100      	movs	r1, #0
    8034:	e000      	b.n	8038 <__multiply+0xc8>
    8036:	4637      	mov	r7, r6
    8038:	882c      	ldrh	r4, [r5, #0]
    803a:	0c00      	lsrs	r0, r0, #16
    803c:	fb0b 0004 	mla	r0, fp, r4, r0
    8040:	4401      	add	r1, r0
    8042:	b29c      	uxth	r4, r3
    8044:	463e      	mov	r6, r7
    8046:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
    804a:	f846 3b04 	str.w	r3, [r6], #4
    804e:	6878      	ldr	r0, [r7, #4]
    8050:	f855 4b04 	ldr.w	r4, [r5], #4
    8054:	b283      	uxth	r3, r0
    8056:	0c24      	lsrs	r4, r4, #16
    8058:	fb0b 3404 	mla	r4, fp, r4, r3
    805c:	eb04 4311 	add.w	r3, r4, r1, lsr #16
    8060:	45ae      	cmp	lr, r5
    8062:	ea4f 4113 	mov.w	r1, r3, lsr #16
    8066:	d8e6      	bhi.n	8036 <__multiply+0xc6>
    8068:	607b      	str	r3, [r7, #4]
    806a:	4592      	cmp	sl, r2
    806c:	f10c 0c04 	add.w	ip, ip, #4
    8070:	d8af      	bhi.n	7fd2 <__multiply+0x62>
    8072:	f8dd 9004 	ldr.w	r9, [sp, #4]
    8076:	f1b8 0f00 	cmp.w	r8, #0
    807a:	dd0b      	ble.n	8094 <__multiply+0x124>
    807c:	f859 3c04 	ldr.w	r3, [r9, #-4]
    8080:	f1a9 0904 	sub.w	r9, r9, #4
    8084:	b11b      	cbz	r3, 808e <__multiply+0x11e>
    8086:	e005      	b.n	8094 <__multiply+0x124>
    8088:	f859 3d04 	ldr.w	r3, [r9, #-4]!
    808c:	b913      	cbnz	r3, 8094 <__multiply+0x124>
    808e:	f1b8 0801 	subs.w	r8, r8, #1
    8092:	d1f9      	bne.n	8088 <__multiply+0x118>
    8094:	9800      	ldr	r0, [sp, #0]
    8096:	f8c0 8010 	str.w	r8, [r0, #16]
    809a:	b003      	add	sp, #12
    809c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000080a0 <__pow5mult>:
    80a0:	f012 0303 	ands.w	r3, r2, #3
    80a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    80a8:	4614      	mov	r4, r2
    80aa:	4607      	mov	r7, r0
    80ac:	d12e      	bne.n	810c <__pow5mult+0x6c>
    80ae:	460e      	mov	r6, r1
    80b0:	10a4      	asrs	r4, r4, #2
    80b2:	d01c      	beq.n	80ee <__pow5mult+0x4e>
    80b4:	6cbd      	ldr	r5, [r7, #72]	; 0x48
    80b6:	b395      	cbz	r5, 811e <__pow5mult+0x7e>
    80b8:	07e3      	lsls	r3, r4, #31
    80ba:	f04f 0800 	mov.w	r8, #0
    80be:	d406      	bmi.n	80ce <__pow5mult+0x2e>
    80c0:	1064      	asrs	r4, r4, #1
    80c2:	d014      	beq.n	80ee <__pow5mult+0x4e>
    80c4:	6828      	ldr	r0, [r5, #0]
    80c6:	b1a8      	cbz	r0, 80f4 <__pow5mult+0x54>
    80c8:	4605      	mov	r5, r0
    80ca:	07e3      	lsls	r3, r4, #31
    80cc:	d5f8      	bpl.n	80c0 <__pow5mult+0x20>
    80ce:	462a      	mov	r2, r5
    80d0:	4631      	mov	r1, r6
    80d2:	4638      	mov	r0, r7
    80d4:	f7ff ff4c 	bl	7f70 <__multiply>
    80d8:	b1b6      	cbz	r6, 8108 <__pow5mult+0x68>
    80da:	6872      	ldr	r2, [r6, #4]
    80dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    80de:	1064      	asrs	r4, r4, #1
    80e0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    80e4:	6031      	str	r1, [r6, #0]
    80e6:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    80ea:	4606      	mov	r6, r0
    80ec:	d1ea      	bne.n	80c4 <__pow5mult+0x24>
    80ee:	4630      	mov	r0, r6
    80f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    80f4:	462a      	mov	r2, r5
    80f6:	4629      	mov	r1, r5
    80f8:	4638      	mov	r0, r7
    80fa:	f7ff ff39 	bl	7f70 <__multiply>
    80fe:	6028      	str	r0, [r5, #0]
    8100:	f8c0 8000 	str.w	r8, [r0]
    8104:	4605      	mov	r5, r0
    8106:	e7e0      	b.n	80ca <__pow5mult+0x2a>
    8108:	4606      	mov	r6, r0
    810a:	e7d9      	b.n	80c0 <__pow5mult+0x20>
    810c:	1e5a      	subs	r2, r3, #1
    810e:	4d0b      	ldr	r5, [pc, #44]	; (813c <__pow5mult+0x9c>)
    8110:	2300      	movs	r3, #0
    8112:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
    8116:	f7ff fe93 	bl	7e40 <__multadd>
    811a:	4606      	mov	r6, r0
    811c:	e7c8      	b.n	80b0 <__pow5mult+0x10>
    811e:	2101      	movs	r1, #1
    8120:	4638      	mov	r0, r7
    8122:	f7ff fe5d 	bl	7de0 <_Balloc>
    8126:	f240 2171 	movw	r1, #625	; 0x271
    812a:	2201      	movs	r2, #1
    812c:	2300      	movs	r3, #0
    812e:	6141      	str	r1, [r0, #20]
    8130:	6102      	str	r2, [r0, #16]
    8132:	4605      	mov	r5, r0
    8134:	64b8      	str	r0, [r7, #72]	; 0x48
    8136:	6003      	str	r3, [r0, #0]
    8138:	e7be      	b.n	80b8 <__pow5mult+0x18>
    813a:	bf00      	nop
    813c:	20000ae4 	.word	0x20000ae4

00008140 <__lshift>:
    8140:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8144:	4691      	mov	r9, r2
    8146:	690a      	ldr	r2, [r1, #16]
    8148:	688b      	ldr	r3, [r1, #8]
    814a:	ea4f 1469 	mov.w	r4, r9, asr #5
    814e:	eb04 0802 	add.w	r8, r4, r2
    8152:	f108 0501 	add.w	r5, r8, #1
    8156:	429d      	cmp	r5, r3
    8158:	460e      	mov	r6, r1
    815a:	4682      	mov	sl, r0
    815c:	6849      	ldr	r1, [r1, #4]
    815e:	dd04      	ble.n	816a <__lshift+0x2a>
    8160:	005b      	lsls	r3, r3, #1
    8162:	429d      	cmp	r5, r3
    8164:	f101 0101 	add.w	r1, r1, #1
    8168:	dcfa      	bgt.n	8160 <__lshift+0x20>
    816a:	4650      	mov	r0, sl
    816c:	f7ff fe38 	bl	7de0 <_Balloc>
    8170:	2c00      	cmp	r4, #0
    8172:	f100 0214 	add.w	r2, r0, #20
    8176:	dd38      	ble.n	81ea <__lshift+0xaa>
    8178:	eb02 0384 	add.w	r3, r2, r4, lsl #2
    817c:	2100      	movs	r1, #0
    817e:	f842 1b04 	str.w	r1, [r2], #4
    8182:	4293      	cmp	r3, r2
    8184:	d1fb      	bne.n	817e <__lshift+0x3e>
    8186:	6934      	ldr	r4, [r6, #16]
    8188:	f106 0114 	add.w	r1, r6, #20
    818c:	f019 091f 	ands.w	r9, r9, #31
    8190:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
    8194:	d021      	beq.n	81da <__lshift+0x9a>
    8196:	f1c9 0220 	rsb	r2, r9, #32
    819a:	2400      	movs	r4, #0
    819c:	680f      	ldr	r7, [r1, #0]
    819e:	fa07 fc09 	lsl.w	ip, r7, r9
    81a2:	ea4c 0404 	orr.w	r4, ip, r4
    81a6:	469c      	mov	ip, r3
    81a8:	f843 4b04 	str.w	r4, [r3], #4
    81ac:	f851 4b04 	ldr.w	r4, [r1], #4
    81b0:	458e      	cmp	lr, r1
    81b2:	fa24 f402 	lsr.w	r4, r4, r2
    81b6:	d8f1      	bhi.n	819c <__lshift+0x5c>
    81b8:	f8cc 4004 	str.w	r4, [ip, #4]
    81bc:	b10c      	cbz	r4, 81c2 <__lshift+0x82>
    81be:	f108 0502 	add.w	r5, r8, #2
    81c2:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    81c6:	6872      	ldr	r2, [r6, #4]
    81c8:	3d01      	subs	r5, #1
    81ca:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    81ce:	6105      	str	r5, [r0, #16]
    81d0:	6031      	str	r1, [r6, #0]
    81d2:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    81d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    81da:	3b04      	subs	r3, #4
    81dc:	f851 2b04 	ldr.w	r2, [r1], #4
    81e0:	f843 2f04 	str.w	r2, [r3, #4]!
    81e4:	458e      	cmp	lr, r1
    81e6:	d8f9      	bhi.n	81dc <__lshift+0x9c>
    81e8:	e7eb      	b.n	81c2 <__lshift+0x82>
    81ea:	4613      	mov	r3, r2
    81ec:	e7cb      	b.n	8186 <__lshift+0x46>
    81ee:	bf00      	nop

000081f0 <__mcmp>:
    81f0:	6902      	ldr	r2, [r0, #16]
    81f2:	690b      	ldr	r3, [r1, #16]
    81f4:	1ad2      	subs	r2, r2, r3
    81f6:	d113      	bne.n	8220 <__mcmp+0x30>
    81f8:	009b      	lsls	r3, r3, #2
    81fa:	3014      	adds	r0, #20
    81fc:	3114      	adds	r1, #20
    81fe:	4419      	add	r1, r3
    8200:	b410      	push	{r4}
    8202:	4403      	add	r3, r0
    8204:	e001      	b.n	820a <__mcmp+0x1a>
    8206:	4298      	cmp	r0, r3
    8208:	d20c      	bcs.n	8224 <__mcmp+0x34>
    820a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
    820e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
    8212:	4294      	cmp	r4, r2
    8214:	d0f7      	beq.n	8206 <__mcmp+0x16>
    8216:	d309      	bcc.n	822c <__mcmp+0x3c>
    8218:	2001      	movs	r0, #1
    821a:	f85d 4b04 	ldr.w	r4, [sp], #4
    821e:	4770      	bx	lr
    8220:	4610      	mov	r0, r2
    8222:	4770      	bx	lr
    8224:	2000      	movs	r0, #0
    8226:	f85d 4b04 	ldr.w	r4, [sp], #4
    822a:	4770      	bx	lr
    822c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    8230:	e7f3      	b.n	821a <__mcmp+0x2a>
    8232:	bf00      	nop

00008234 <__mdiff>:
    8234:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8238:	690b      	ldr	r3, [r1, #16]
    823a:	460f      	mov	r7, r1
    823c:	6911      	ldr	r1, [r2, #16]
    823e:	1a5b      	subs	r3, r3, r1
    8240:	2b00      	cmp	r3, #0
    8242:	4690      	mov	r8, r2
    8244:	d117      	bne.n	8276 <__mdiff+0x42>
    8246:	0089      	lsls	r1, r1, #2
    8248:	f107 0214 	add.w	r2, r7, #20
    824c:	f108 0514 	add.w	r5, r8, #20
    8250:	1853      	adds	r3, r2, r1
    8252:	4429      	add	r1, r5
    8254:	e001      	b.n	825a <__mdiff+0x26>
    8256:	429a      	cmp	r2, r3
    8258:	d25e      	bcs.n	8318 <__mdiff+0xe4>
    825a:	f853 6d04 	ldr.w	r6, [r3, #-4]!
    825e:	f851 4d04 	ldr.w	r4, [r1, #-4]!
    8262:	42a6      	cmp	r6, r4
    8264:	d0f7      	beq.n	8256 <__mdiff+0x22>
    8266:	d260      	bcs.n	832a <__mdiff+0xf6>
    8268:	463b      	mov	r3, r7
    826a:	4614      	mov	r4, r2
    826c:	4647      	mov	r7, r8
    826e:	f04f 0901 	mov.w	r9, #1
    8272:	4698      	mov	r8, r3
    8274:	e006      	b.n	8284 <__mdiff+0x50>
    8276:	db5d      	blt.n	8334 <__mdiff+0x100>
    8278:	f107 0514 	add.w	r5, r7, #20
    827c:	f102 0414 	add.w	r4, r2, #20
    8280:	f04f 0900 	mov.w	r9, #0
    8284:	6879      	ldr	r1, [r7, #4]
    8286:	f7ff fdab 	bl	7de0 <_Balloc>
    828a:	f8d8 3010 	ldr.w	r3, [r8, #16]
    828e:	693e      	ldr	r6, [r7, #16]
    8290:	f8c0 900c 	str.w	r9, [r0, #12]
    8294:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
    8298:	46a6      	mov	lr, r4
    829a:	eb05 0786 	add.w	r7, r5, r6, lsl #2
    829e:	f100 0414 	add.w	r4, r0, #20
    82a2:	2300      	movs	r3, #0
    82a4:	f85e 1b04 	ldr.w	r1, [lr], #4
    82a8:	f855 8b04 	ldr.w	r8, [r5], #4
    82ac:	b28a      	uxth	r2, r1
    82ae:	fa13 f388 	uxtah	r3, r3, r8
    82b2:	0c09      	lsrs	r1, r1, #16
    82b4:	1a9a      	subs	r2, r3, r2
    82b6:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
    82ba:	eb03 4322 	add.w	r3, r3, r2, asr #16
    82be:	b292      	uxth	r2, r2
    82c0:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    82c4:	45f4      	cmp	ip, lr
    82c6:	f844 2b04 	str.w	r2, [r4], #4
    82ca:	ea4f 4323 	mov.w	r3, r3, asr #16
    82ce:	d8e9      	bhi.n	82a4 <__mdiff+0x70>
    82d0:	42af      	cmp	r7, r5
    82d2:	d917      	bls.n	8304 <__mdiff+0xd0>
    82d4:	46a4      	mov	ip, r4
    82d6:	4629      	mov	r1, r5
    82d8:	f851 eb04 	ldr.w	lr, [r1], #4
    82dc:	fa13 f28e 	uxtah	r2, r3, lr
    82e0:	1413      	asrs	r3, r2, #16
    82e2:	eb03 431e 	add.w	r3, r3, lr, lsr #16
    82e6:	b292      	uxth	r2, r2
    82e8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    82ec:	428f      	cmp	r7, r1
    82ee:	f84c 2b04 	str.w	r2, [ip], #4
    82f2:	ea4f 4323 	mov.w	r3, r3, asr #16
    82f6:	d8ef      	bhi.n	82d8 <__mdiff+0xa4>
    82f8:	43ed      	mvns	r5, r5
    82fa:	443d      	add	r5, r7
    82fc:	f025 0503 	bic.w	r5, r5, #3
    8300:	3504      	adds	r5, #4
    8302:	442c      	add	r4, r5
    8304:	3c04      	subs	r4, #4
    8306:	b922      	cbnz	r2, 8312 <__mdiff+0xde>
    8308:	f854 3d04 	ldr.w	r3, [r4, #-4]!
    830c:	3e01      	subs	r6, #1
    830e:	2b00      	cmp	r3, #0
    8310:	d0fa      	beq.n	8308 <__mdiff+0xd4>
    8312:	6106      	str	r6, [r0, #16]
    8314:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    8318:	2100      	movs	r1, #0
    831a:	f7ff fd61 	bl	7de0 <_Balloc>
    831e:	2201      	movs	r2, #1
    8320:	2300      	movs	r3, #0
    8322:	6102      	str	r2, [r0, #16]
    8324:	6143      	str	r3, [r0, #20]
    8326:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    832a:	462c      	mov	r4, r5
    832c:	f04f 0900 	mov.w	r9, #0
    8330:	4615      	mov	r5, r2
    8332:	e7a7      	b.n	8284 <__mdiff+0x50>
    8334:	463b      	mov	r3, r7
    8336:	f107 0414 	add.w	r4, r7, #20
    833a:	f108 0514 	add.w	r5, r8, #20
    833e:	4647      	mov	r7, r8
    8340:	f04f 0901 	mov.w	r9, #1
    8344:	4698      	mov	r8, r3
    8346:	e79d      	b.n	8284 <__mdiff+0x50>

00008348 <__d2b>:
    8348:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    834c:	ec57 6b10 	vmov	r6, r7, d0
    8350:	b083      	sub	sp, #12
    8352:	4688      	mov	r8, r1
    8354:	2101      	movs	r1, #1
    8356:	463c      	mov	r4, r7
    8358:	f3c7 550a 	ubfx	r5, r7, #20, #11
    835c:	4617      	mov	r7, r2
    835e:	f7ff fd3f 	bl	7de0 <_Balloc>
    8362:	f3c4 0413 	ubfx	r4, r4, #0, #20
    8366:	4681      	mov	r9, r0
    8368:	b10d      	cbz	r5, 836e <__d2b+0x26>
    836a:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
    836e:	9401      	str	r4, [sp, #4]
    8370:	b31e      	cbz	r6, 83ba <__d2b+0x72>
    8372:	a802      	add	r0, sp, #8
    8374:	f840 6d08 	str.w	r6, [r0, #-8]!
    8378:	f7ff fdc2 	bl	7f00 <__lo0bits>
    837c:	2800      	cmp	r0, #0
    837e:	d134      	bne.n	83ea <__d2b+0xa2>
    8380:	e89d 000c 	ldmia.w	sp, {r2, r3}
    8384:	f8c9 2014 	str.w	r2, [r9, #20]
    8388:	2b00      	cmp	r3, #0
    838a:	bf0c      	ite	eq
    838c:	2101      	moveq	r1, #1
    838e:	2102      	movne	r1, #2
    8390:	f8c9 3018 	str.w	r3, [r9, #24]
    8394:	f8c9 1010 	str.w	r1, [r9, #16]
    8398:	b9dd      	cbnz	r5, 83d2 <__d2b+0x8a>
    839a:	eb09 0381 	add.w	r3, r9, r1, lsl #2
    839e:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
    83a2:	f8c8 0000 	str.w	r0, [r8]
    83a6:	6918      	ldr	r0, [r3, #16]
    83a8:	f7ff fd8a 	bl	7ec0 <__hi0bits>
    83ac:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
    83b0:	6038      	str	r0, [r7, #0]
    83b2:	4648      	mov	r0, r9
    83b4:	b003      	add	sp, #12
    83b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    83ba:	a801      	add	r0, sp, #4
    83bc:	f7ff fda0 	bl	7f00 <__lo0bits>
    83c0:	9b01      	ldr	r3, [sp, #4]
    83c2:	f8c9 3014 	str.w	r3, [r9, #20]
    83c6:	2101      	movs	r1, #1
    83c8:	3020      	adds	r0, #32
    83ca:	f8c9 1010 	str.w	r1, [r9, #16]
    83ce:	2d00      	cmp	r5, #0
    83d0:	d0e3      	beq.n	839a <__d2b+0x52>
    83d2:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
    83d6:	4405      	add	r5, r0
    83d8:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
    83dc:	f8c8 5000 	str.w	r5, [r8]
    83e0:	6038      	str	r0, [r7, #0]
    83e2:	4648      	mov	r0, r9
    83e4:	b003      	add	sp, #12
    83e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    83ea:	e89d 000c 	ldmia.w	sp, {r2, r3}
    83ee:	f1c0 0120 	rsb	r1, r0, #32
    83f2:	fa03 f101 	lsl.w	r1, r3, r1
    83f6:	430a      	orrs	r2, r1
    83f8:	40c3      	lsrs	r3, r0
    83fa:	9301      	str	r3, [sp, #4]
    83fc:	f8c9 2014 	str.w	r2, [r9, #20]
    8400:	e7c2      	b.n	8388 <__d2b+0x40>
    8402:	bf00      	nop

00008404 <_vasnprintf_r>:
    8404:	b570      	push	{r4, r5, r6, lr}
    8406:	4615      	mov	r5, r2
    8408:	b09a      	sub	sp, #104	; 0x68
    840a:	6814      	ldr	r4, [r2, #0]
    840c:	b109      	cbz	r1, 8412 <_vasnprintf_r+0xe>
    840e:	2c00      	cmp	r4, #0
    8410:	d11a      	bne.n	8448 <_vasnprintf_r+0x44>
    8412:	2400      	movs	r4, #0
    8414:	f44f 7222 	mov.w	r2, #648	; 0x288
    8418:	f8ad 200c 	strh.w	r2, [sp, #12]
    841c:	9400      	str	r4, [sp, #0]
    841e:	9404      	str	r4, [sp, #16]
    8420:	461a      	mov	r2, r3
    8422:	f64f 76ff 	movw	r6, #65535	; 0xffff
    8426:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    8428:	9402      	str	r4, [sp, #8]
    842a:	4669      	mov	r1, sp
    842c:	9405      	str	r4, [sp, #20]
    842e:	f8ad 600e 	strh.w	r6, [sp, #14]
    8432:	f000 ff21 	bl	9278 <_svfprintf_r>
    8436:	2800      	cmp	r0, #0
    8438:	db11      	blt.n	845e <_vasnprintf_r+0x5a>
    843a:	9b00      	ldr	r3, [sp, #0]
    843c:	6028      	str	r0, [r5, #0]
    843e:	2200      	movs	r2, #0
    8440:	701a      	strb	r2, [r3, #0]
    8442:	9804      	ldr	r0, [sp, #16]
    8444:	b01a      	add	sp, #104	; 0x68
    8446:	bd70      	pop	{r4, r5, r6, pc}
    8448:	f44f 62c1 	mov.w	r2, #1544	; 0x608
    844c:	9100      	str	r1, [sp, #0]
    844e:	9104      	str	r1, [sp, #16]
    8450:	f8ad 200c 	strh.w	r2, [sp, #12]
    8454:	dae4      	bge.n	8420 <_vasnprintf_r+0x1c>
    8456:	238b      	movs	r3, #139	; 0x8b
    8458:	6003      	str	r3, [r0, #0]
    845a:	2000      	movs	r0, #0
    845c:	e7f2      	b.n	8444 <_vasnprintf_r+0x40>
    845e:	2000      	movs	r0, #0
    8460:	e7f0      	b.n	8444 <_vasnprintf_r+0x40>
    8462:	bf00      	nop

00008464 <_calloc_r>:
    8464:	b510      	push	{r4, lr}
    8466:	fb02 f101 	mul.w	r1, r2, r1
    846a:	f7fe f957 	bl	671c <_malloc_r>
    846e:	4604      	mov	r4, r0
    8470:	b1d8      	cbz	r0, 84aa <_calloc_r+0x46>
    8472:	f850 2c04 	ldr.w	r2, [r0, #-4]
    8476:	f022 0203 	bic.w	r2, r2, #3
    847a:	3a04      	subs	r2, #4
    847c:	2a24      	cmp	r2, #36	; 0x24
    847e:	d818      	bhi.n	84b2 <_calloc_r+0x4e>
    8480:	2a13      	cmp	r2, #19
    8482:	d914      	bls.n	84ae <_calloc_r+0x4a>
    8484:	2300      	movs	r3, #0
    8486:	2a1b      	cmp	r2, #27
    8488:	6003      	str	r3, [r0, #0]
    848a:	6043      	str	r3, [r0, #4]
    848c:	d916      	bls.n	84bc <_calloc_r+0x58>
    848e:	2a24      	cmp	r2, #36	; 0x24
    8490:	6083      	str	r3, [r0, #8]
    8492:	60c3      	str	r3, [r0, #12]
    8494:	bf11      	iteee	ne
    8496:	f100 0210 	addne.w	r2, r0, #16
    849a:	6103      	streq	r3, [r0, #16]
    849c:	6143      	streq	r3, [r0, #20]
    849e:	f100 0218 	addeq.w	r2, r0, #24
    84a2:	2300      	movs	r3, #0
    84a4:	6013      	str	r3, [r2, #0]
    84a6:	6053      	str	r3, [r2, #4]
    84a8:	6093      	str	r3, [r2, #8]
    84aa:	4620      	mov	r0, r4
    84ac:	bd10      	pop	{r4, pc}
    84ae:	4602      	mov	r2, r0
    84b0:	e7f7      	b.n	84a2 <_calloc_r+0x3e>
    84b2:	2100      	movs	r1, #0
    84b4:	f7fe fcfe 	bl	6eb4 <memset>
    84b8:	4620      	mov	r0, r4
    84ba:	bd10      	pop	{r4, pc}
    84bc:	f100 0208 	add.w	r2, r0, #8
    84c0:	e7ef      	b.n	84a2 <_calloc_r+0x3e>
    84c2:	bf00      	nop

000084c4 <quorem>:
    84c4:	6902      	ldr	r2, [r0, #16]
    84c6:	690b      	ldr	r3, [r1, #16]
    84c8:	4293      	cmp	r3, r2
    84ca:	f300 808d 	bgt.w	85e8 <quorem+0x124>
    84ce:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    84d2:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    84d6:	f101 0714 	add.w	r7, r1, #20
    84da:	f100 0b14 	add.w	fp, r0, #20
    84de:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
    84e2:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    84e6:	ea4f 0488 	mov.w	r4, r8, lsl #2
    84ea:	b083      	sub	sp, #12
    84ec:	3201      	adds	r2, #1
    84ee:	fbb3 f9f2 	udiv	r9, r3, r2
    84f2:	eb0b 0304 	add.w	r3, fp, r4
    84f6:	9400      	str	r4, [sp, #0]
    84f8:	eb07 0a04 	add.w	sl, r7, r4
    84fc:	9301      	str	r3, [sp, #4]
    84fe:	f1b9 0f00 	cmp.w	r9, #0
    8502:	d039      	beq.n	8578 <quorem+0xb4>
    8504:	2500      	movs	r5, #0
    8506:	46bc      	mov	ip, r7
    8508:	46de      	mov	lr, fp
    850a:	462b      	mov	r3, r5
    850c:	f85c 6b04 	ldr.w	r6, [ip], #4
    8510:	f8de 2000 	ldr.w	r2, [lr]
    8514:	b2b4      	uxth	r4, r6
    8516:	fb09 5504 	mla	r5, r9, r4, r5
    851a:	0c36      	lsrs	r6, r6, #16
    851c:	0c2c      	lsrs	r4, r5, #16
    851e:	fb09 4406 	mla	r4, r9, r6, r4
    8522:	b2ad      	uxth	r5, r5
    8524:	1b5b      	subs	r3, r3, r5
    8526:	b2a6      	uxth	r6, r4
    8528:	fa13 f382 	uxtah	r3, r3, r2
    852c:	ebc6 4612 	rsb	r6, r6, r2, lsr #16
    8530:	eb06 4623 	add.w	r6, r6, r3, asr #16
    8534:	b29b      	uxth	r3, r3
    8536:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    853a:	45e2      	cmp	sl, ip
    853c:	f84e 3b04 	str.w	r3, [lr], #4
    8540:	ea4f 4514 	mov.w	r5, r4, lsr #16
    8544:	ea4f 4326 	mov.w	r3, r6, asr #16
    8548:	d2e0      	bcs.n	850c <quorem+0x48>
    854a:	9b00      	ldr	r3, [sp, #0]
    854c:	f85b 3003 	ldr.w	r3, [fp, r3]
    8550:	b993      	cbnz	r3, 8578 <quorem+0xb4>
    8552:	9c01      	ldr	r4, [sp, #4]
    8554:	1f23      	subs	r3, r4, #4
    8556:	459b      	cmp	fp, r3
    8558:	d20c      	bcs.n	8574 <quorem+0xb0>
    855a:	f854 3c04 	ldr.w	r3, [r4, #-4]
    855e:	b94b      	cbnz	r3, 8574 <quorem+0xb0>
    8560:	f1a4 0308 	sub.w	r3, r4, #8
    8564:	e002      	b.n	856c <quorem+0xa8>
    8566:	681a      	ldr	r2, [r3, #0]
    8568:	3b04      	subs	r3, #4
    856a:	b91a      	cbnz	r2, 8574 <quorem+0xb0>
    856c:	459b      	cmp	fp, r3
    856e:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    8572:	d3f8      	bcc.n	8566 <quorem+0xa2>
    8574:	f8c0 8010 	str.w	r8, [r0, #16]
    8578:	4604      	mov	r4, r0
    857a:	f7ff fe39 	bl	81f0 <__mcmp>
    857e:	2800      	cmp	r0, #0
    8580:	db2e      	blt.n	85e0 <quorem+0x11c>
    8582:	f109 0901 	add.w	r9, r9, #1
    8586:	465d      	mov	r5, fp
    8588:	2300      	movs	r3, #0
    858a:	f857 1b04 	ldr.w	r1, [r7], #4
    858e:	6828      	ldr	r0, [r5, #0]
    8590:	b28a      	uxth	r2, r1
    8592:	1a9a      	subs	r2, r3, r2
    8594:	0c09      	lsrs	r1, r1, #16
    8596:	fa12 f280 	uxtah	r2, r2, r0
    859a:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
    859e:	eb03 4322 	add.w	r3, r3, r2, asr #16
    85a2:	b291      	uxth	r1, r2
    85a4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    85a8:	45ba      	cmp	sl, r7
    85aa:	f845 1b04 	str.w	r1, [r5], #4
    85ae:	ea4f 4323 	mov.w	r3, r3, asr #16
    85b2:	d2ea      	bcs.n	858a <quorem+0xc6>
    85b4:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
    85b8:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
    85bc:	b982      	cbnz	r2, 85e0 <quorem+0x11c>
    85be:	1f1a      	subs	r2, r3, #4
    85c0:	4593      	cmp	fp, r2
    85c2:	d20b      	bcs.n	85dc <quorem+0x118>
    85c4:	f853 2c04 	ldr.w	r2, [r3, #-4]
    85c8:	b942      	cbnz	r2, 85dc <quorem+0x118>
    85ca:	3b08      	subs	r3, #8
    85cc:	e002      	b.n	85d4 <quorem+0x110>
    85ce:	681a      	ldr	r2, [r3, #0]
    85d0:	3b04      	subs	r3, #4
    85d2:	b91a      	cbnz	r2, 85dc <quorem+0x118>
    85d4:	459b      	cmp	fp, r3
    85d6:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    85da:	d3f8      	bcc.n	85ce <quorem+0x10a>
    85dc:	f8c4 8010 	str.w	r8, [r4, #16]
    85e0:	4648      	mov	r0, r9
    85e2:	b003      	add	sp, #12
    85e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    85e8:	2000      	movs	r0, #0
    85ea:	4770      	bx	lr
    85ec:	0000      	movs	r0, r0
	...

000085f0 <_dtoa_r>:
    85f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    85f4:	ec57 6b10 	vmov	r6, r7, d0
    85f8:	b093      	sub	sp, #76	; 0x4c
    85fa:	6c05      	ldr	r5, [r0, #64]	; 0x40
    85fc:	9101      	str	r1, [sp, #4]
    85fe:	4604      	mov	r4, r0
    8600:	4690      	mov	r8, r2
    8602:	9304      	str	r3, [sp, #16]
    8604:	ee10 aa10 	vmov	sl, s0
    8608:	46bb      	mov	fp, r7
    860a:	b14d      	cbz	r5, 8620 <_dtoa_r+0x30>
    860c:	6c42      	ldr	r2, [r0, #68]	; 0x44
    860e:	606a      	str	r2, [r5, #4]
    8610:	2301      	movs	r3, #1
    8612:	4093      	lsls	r3, r2
    8614:	60ab      	str	r3, [r5, #8]
    8616:	4629      	mov	r1, r5
    8618:	f7ff fc08 	bl	7e2c <_Bfree>
    861c:	2300      	movs	r3, #0
    861e:	6423      	str	r3, [r4, #64]	; 0x40
    8620:	f1bb 0f00 	cmp.w	fp, #0
    8624:	465e      	mov	r6, fp
    8626:	db34      	blt.n	8692 <_dtoa_r+0xa2>
    8628:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    862a:	2300      	movs	r3, #0
    862c:	6013      	str	r3, [r2, #0]
    862e:	4bc4      	ldr	r3, [pc, #784]	; (8940 <_dtoa_r+0x350>)
    8630:	461a      	mov	r2, r3
    8632:	4033      	ands	r3, r6
    8634:	4293      	cmp	r3, r2
    8636:	d015      	beq.n	8664 <_dtoa_r+0x74>
    8638:	ec4b ab17 	vmov	d7, sl, fp
    863c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    8640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8644:	e9cd ab02 	strd	sl, fp, [sp, #8]
    8648:	d12a      	bne.n	86a0 <_dtoa_r+0xb0>
    864a:	9a04      	ldr	r2, [sp, #16]
    864c:	2301      	movs	r3, #1
    864e:	6013      	str	r3, [r2, #0]
    8650:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    8652:	2b00      	cmp	r3, #0
    8654:	f000 80b7 	beq.w	87c6 <_dtoa_r+0x1d6>
    8658:	48ba      	ldr	r0, [pc, #744]	; (8944 <_dtoa_r+0x354>)
    865a:	6018      	str	r0, [r3, #0]
    865c:	3801      	subs	r0, #1
    865e:	b013      	add	sp, #76	; 0x4c
    8660:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8664:	9a04      	ldr	r2, [sp, #16]
    8666:	f242 730f 	movw	r3, #9999	; 0x270f
    866a:	6013      	str	r3, [r2, #0]
    866c:	f1ba 0f00 	cmp.w	sl, #0
    8670:	f000 8092 	beq.w	8798 <_dtoa_r+0x1a8>
    8674:	48b4      	ldr	r0, [pc, #720]	; (8948 <_dtoa_r+0x358>)
    8676:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    8678:	2b00      	cmp	r3, #0
    867a:	d0f0      	beq.n	865e <_dtoa_r+0x6e>
    867c:	78c3      	ldrb	r3, [r0, #3]
    867e:	2b00      	cmp	r3, #0
    8680:	f000 80a3 	beq.w	87ca <_dtoa_r+0x1da>
    8684:	f100 0308 	add.w	r3, r0, #8
    8688:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    868a:	6013      	str	r3, [r2, #0]
    868c:	b013      	add	sp, #76	; 0x4c
    868e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8692:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    8694:	2301      	movs	r3, #1
    8696:	f02b 4600 	bic.w	r6, fp, #2147483648	; 0x80000000
    869a:	6013      	str	r3, [r2, #0]
    869c:	46b3      	mov	fp, r6
    869e:	e7c6      	b.n	862e <_dtoa_r+0x3e>
    86a0:	a911      	add	r1, sp, #68	; 0x44
    86a2:	aa10      	add	r2, sp, #64	; 0x40
    86a4:	ed9d 0b02 	vldr	d0, [sp, #8]
    86a8:	4620      	mov	r0, r4
    86aa:	f7ff fe4d 	bl	8348 <__d2b>
    86ae:	0d31      	lsrs	r1, r6, #20
    86b0:	9007      	str	r0, [sp, #28]
    86b2:	d17a      	bne.n	87aa <_dtoa_r+0x1ba>
    86b4:	9810      	ldr	r0, [sp, #64]	; 0x40
    86b6:	9911      	ldr	r1, [sp, #68]	; 0x44
    86b8:	4401      	add	r1, r0
    86ba:	f201 4332 	addw	r3, r1, #1074	; 0x432
    86be:	2b20      	cmp	r3, #32
    86c0:	f340 8241 	ble.w	8b46 <_dtoa_r+0x556>
    86c4:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    86c8:	f201 4212 	addw	r2, r1, #1042	; 0x412
    86cc:	409e      	lsls	r6, r3
    86ce:	fa2a f302 	lsr.w	r3, sl, r2
    86d2:	4333      	orrs	r3, r6
    86d4:	ee07 3a90 	vmov	s15, r3
    86d8:	eeb8 7b67 	vcvt.f64.u32	d7, s15
    86dc:	2501      	movs	r5, #1
    86de:	ec53 2b17 	vmov	r2, r3, d7
    86e2:	3901      	subs	r1, #1
    86e4:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
    86e8:	950a      	str	r5, [sp, #40]	; 0x28
    86ea:	ec43 2b17 	vmov	d7, r2, r3
    86ee:	eeb7 6b08 	vmov.f64	d6, #120	; 0x3fc00000  1.5
    86f2:	ed9f 4b8d 	vldr	d4, [pc, #564]	; 8928 <_dtoa_r+0x338>
    86f6:	ee37 6b46 	vsub.f64	d6, d7, d6
    86fa:	ed9f 7b8d 	vldr	d7, [pc, #564]	; 8930 <_dtoa_r+0x340>
    86fe:	ed9f 5b8e 	vldr	d5, [pc, #568]	; 8938 <_dtoa_r+0x348>
    8702:	eea6 7b04 	vfma.f64	d7, d6, d4
    8706:	ee06 1a90 	vmov	s13, r1
    870a:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    870e:	eea6 7b05 	vfma.f64	d7, d6, d5
    8712:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    8716:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    871a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    871e:	edcd 6a02 	vstr	s13, [sp, #8]
    8722:	f100 811c 	bmi.w	895e <_dtoa_r+0x36e>
    8726:	9d02      	ldr	r5, [sp, #8]
    8728:	2d16      	cmp	r5, #22
    872a:	f200 8115 	bhi.w	8958 <_dtoa_r+0x368>
    872e:	4b87      	ldr	r3, [pc, #540]	; (894c <_dtoa_r+0x35c>)
    8730:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    8734:	ed93 7b00 	vldr	d7, [r3]
    8738:	ec4b ab16 	vmov	d6, sl, fp
    873c:	eeb4 7bc6 	vcmpe.f64	d7, d6
    8740:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8744:	f340 8206 	ble.w	8b54 <_dtoa_r+0x564>
    8748:	1e6b      	subs	r3, r5, #1
    874a:	9302      	str	r3, [sp, #8]
    874c:	2300      	movs	r3, #0
    874e:	930c      	str	r3, [sp, #48]	; 0x30
    8750:	1a41      	subs	r1, r0, r1
    8752:	f1b1 0901 	subs.w	r9, r1, #1
    8756:	f100 8117 	bmi.w	8988 <_dtoa_r+0x398>
    875a:	2300      	movs	r3, #0
    875c:	9306      	str	r3, [sp, #24]
    875e:	9b02      	ldr	r3, [sp, #8]
    8760:	2b00      	cmp	r3, #0
    8762:	f2c0 8108 	blt.w	8976 <_dtoa_r+0x386>
    8766:	4499      	add	r9, r3
    8768:	930b      	str	r3, [sp, #44]	; 0x2c
    876a:	2300      	movs	r3, #0
    876c:	9305      	str	r3, [sp, #20]
    876e:	9b01      	ldr	r3, [sp, #4]
    8770:	2b09      	cmp	r3, #9
    8772:	d82c      	bhi.n	87ce <_dtoa_r+0x1de>
    8774:	2b05      	cmp	r3, #5
    8776:	f340 855f 	ble.w	9238 <_dtoa_r+0xc48>
    877a:	3b04      	subs	r3, #4
    877c:	9301      	str	r3, [sp, #4]
    877e:	2300      	movs	r3, #0
    8780:	930e      	str	r3, [sp, #56]	; 0x38
    8782:	9b01      	ldr	r3, [sp, #4]
    8784:	3b02      	subs	r3, #2
    8786:	2b03      	cmp	r3, #3
    8788:	f200 855f 	bhi.w	924a <_dtoa_r+0xc5a>
    878c:	e8df f013 	tbh	[pc, r3, lsl #1]
    8790:	01e502a9 	.word	0x01e502a9
    8794:	03c802b5 	.word	0x03c802b5
    8798:	4b6b      	ldr	r3, [pc, #428]	; (8948 <_dtoa_r+0x358>)
    879a:	4a6d      	ldr	r2, [pc, #436]	; (8950 <_dtoa_r+0x360>)
    879c:	f3c6 0013 	ubfx	r0, r6, #0, #20
    87a0:	2800      	cmp	r0, #0
    87a2:	bf14      	ite	ne
    87a4:	4618      	movne	r0, r3
    87a6:	4610      	moveq	r0, r2
    87a8:	e765      	b.n	8676 <_dtoa_r+0x86>
    87aa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    87ae:	f3c3 0013 	ubfx	r0, r3, #0, #20
    87b2:	f040 537f 	orr.w	r3, r0, #1069547520	; 0x3fc00000
    87b6:	2500      	movs	r5, #0
    87b8:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
    87bc:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    87c0:	9810      	ldr	r0, [sp, #64]	; 0x40
    87c2:	950a      	str	r5, [sp, #40]	; 0x28
    87c4:	e791      	b.n	86ea <_dtoa_r+0xfa>
    87c6:	4863      	ldr	r0, [pc, #396]	; (8954 <_dtoa_r+0x364>)
    87c8:	e749      	b.n	865e <_dtoa_r+0x6e>
    87ca:	1cc3      	adds	r3, r0, #3
    87cc:	e75c      	b.n	8688 <_dtoa_r+0x98>
    87ce:	2100      	movs	r1, #0
    87d0:	6461      	str	r1, [r4, #68]	; 0x44
    87d2:	4620      	mov	r0, r4
    87d4:	4688      	mov	r8, r1
    87d6:	9101      	str	r1, [sp, #4]
    87d8:	f7ff fb02 	bl	7de0 <_Balloc>
    87dc:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    87e0:	2301      	movs	r3, #1
    87e2:	9008      	str	r0, [sp, #32]
    87e4:	6420      	str	r0, [r4, #64]	; 0x40
    87e6:	970d      	str	r7, [sp, #52]	; 0x34
    87e8:	9309      	str	r3, [sp, #36]	; 0x24
    87ea:	9b11      	ldr	r3, [sp, #68]	; 0x44
    87ec:	2b00      	cmp	r3, #0
    87ee:	db7a      	blt.n	88e6 <_dtoa_r+0x2f6>
    87f0:	9a02      	ldr	r2, [sp, #8]
    87f2:	2a0e      	cmp	r2, #14
    87f4:	dc77      	bgt.n	88e6 <_dtoa_r+0x2f6>
    87f6:	4b55      	ldr	r3, [pc, #340]	; (894c <_dtoa_r+0x35c>)
    87f8:	f1b8 0f00 	cmp.w	r8, #0
    87fc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    8800:	ed93 4b00 	vldr	d4, [r3]
    8804:	f2c0 8284 	blt.w	8d10 <_dtoa_r+0x720>
    8808:	eeb1 2b44 	vneg.f64	d2, d4
    880c:	ec4b ab17 	vmov	d7, sl, fp
    8810:	ee87 6b04 	vdiv.f64	d6, d7, d4
    8814:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    8818:	9a08      	ldr	r2, [sp, #32]
    881a:	ee16 3a10 	vmov	r3, s12
    881e:	2f01      	cmp	r7, #1
    8820:	f103 0330 	add.w	r3, r3, #48	; 0x30
    8824:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    8828:	f102 0b01 	add.w	fp, r2, #1
    882c:	7013      	strb	r3, [r2, #0]
    882e:	eea2 7b05 	vfma.f64	d7, d2, d5
    8832:	d022      	beq.n	887a <_dtoa_r+0x28a>
    8834:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
    8838:	ee27 7b03 	vmul.f64	d7, d7, d3
    883c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    8840:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8844:	d03a      	beq.n	88bc <_dtoa_r+0x2cc>
    8846:	9a08      	ldr	r2, [sp, #32]
    8848:	e006      	b.n	8858 <_dtoa_r+0x268>
    884a:	ee27 7b03 	vmul.f64	d7, d7, d3
    884e:	eeb5 7b40 	vcmp.f64	d7, #0.0
    8852:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8856:	d031      	beq.n	88bc <_dtoa_r+0x2cc>
    8858:	ee87 6b04 	vdiv.f64	d6, d7, d4
    885c:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    8860:	ee16 3a10 	vmov	r3, s12
    8864:	3330      	adds	r3, #48	; 0x30
    8866:	f80b 3b01 	strb.w	r3, [fp], #1
    886a:	ebc2 030b 	rsb	r3, r2, fp
    886e:	42bb      	cmp	r3, r7
    8870:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    8874:	eea2 7b05 	vfma.f64	d7, d2, d5
    8878:	d1e7      	bne.n	884a <_dtoa_r+0x25a>
    887a:	ee37 7b07 	vadd.f64	d7, d7, d7
    887e:	eeb4 4bc7 	vcmpe.f64	d4, d7
    8882:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8886:	d408      	bmi.n	889a <_dtoa_r+0x2aa>
    8888:	eeb4 4b47 	vcmp.f64	d4, d7
    888c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8890:	d114      	bne.n	88bc <_dtoa_r+0x2cc>
    8892:	ee16 3a10 	vmov	r3, s12
    8896:	07db      	lsls	r3, r3, #31
    8898:	d510      	bpl.n	88bc <_dtoa_r+0x2cc>
    889a:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    889e:	9a08      	ldr	r2, [sp, #32]
    88a0:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    88a4:	e004      	b.n	88b0 <_dtoa_r+0x2c0>
    88a6:	429a      	cmp	r2, r3
    88a8:	f000 83e5 	beq.w	9076 <_dtoa_r+0xa86>
    88ac:	f813 0d01 	ldrb.w	r0, [r3, #-1]!
    88b0:	2839      	cmp	r0, #57	; 0x39
    88b2:	f103 0b01 	add.w	fp, r3, #1
    88b6:	d0f6      	beq.n	88a6 <_dtoa_r+0x2b6>
    88b8:	3001      	adds	r0, #1
    88ba:	7018      	strb	r0, [r3, #0]
    88bc:	9907      	ldr	r1, [sp, #28]
    88be:	4620      	mov	r0, r4
    88c0:	f7ff fab4 	bl	7e2c <_Bfree>
    88c4:	2200      	movs	r2, #0
    88c6:	9b02      	ldr	r3, [sp, #8]
    88c8:	f88b 2000 	strb.w	r2, [fp]
    88cc:	9a04      	ldr	r2, [sp, #16]
    88ce:	3301      	adds	r3, #1
    88d0:	6013      	str	r3, [r2, #0]
    88d2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    88d4:	2b00      	cmp	r3, #0
    88d6:	f000 8366 	beq.w	8fa6 <_dtoa_r+0x9b6>
    88da:	9808      	ldr	r0, [sp, #32]
    88dc:	f8c3 b000 	str.w	fp, [r3]
    88e0:	b013      	add	sp, #76	; 0x4c
    88e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    88e6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    88e8:	2a00      	cmp	r2, #0
    88ea:	d053      	beq.n	8994 <_dtoa_r+0x3a4>
    88ec:	9a01      	ldr	r2, [sp, #4]
    88ee:	2a01      	cmp	r2, #1
    88f0:	f340 822e 	ble.w	8d50 <_dtoa_r+0x760>
    88f4:	9905      	ldr	r1, [sp, #20]
    88f6:	1e7a      	subs	r2, r7, #1
    88f8:	4291      	cmp	r1, r2
    88fa:	f2c0 8357 	blt.w	8fac <_dtoa_r+0x9bc>
    88fe:	1a8b      	subs	r3, r1, r2
    8900:	930e      	str	r3, [sp, #56]	; 0x38
    8902:	2f00      	cmp	r7, #0
    8904:	9b06      	ldr	r3, [sp, #24]
    8906:	f2c0 8424 	blt.w	9152 <_dtoa_r+0xb62>
    890a:	930a      	str	r3, [sp, #40]	; 0x28
    890c:	463b      	mov	r3, r7
    890e:	9a06      	ldr	r2, [sp, #24]
    8910:	2101      	movs	r1, #1
    8912:	441a      	add	r2, r3
    8914:	4620      	mov	r0, r4
    8916:	9206      	str	r2, [sp, #24]
    8918:	4499      	add	r9, r3
    891a:	f7ff fb1f 	bl	7f5c <__i2b>
    891e:	4606      	mov	r6, r0
    8920:	e03d      	b.n	899e <_dtoa_r+0x3ae>
    8922:	bf00      	nop
    8924:	f3af 8000 	nop.w
    8928:	636f4361 	.word	0x636f4361
    892c:	3fd287a7 	.word	0x3fd287a7
    8930:	8b60c8b3 	.word	0x8b60c8b3
    8934:	3fc68a28 	.word	0x3fc68a28
    8938:	509f79fb 	.word	0x509f79fb
    893c:	3fd34413 	.word	0x3fd34413
    8940:	7ff00000 	.word	0x7ff00000
    8944:	20000e49 	.word	0x20000e49
    8948:	20000e44 	.word	0x20000e44
    894c:	200002e8 	.word	0x200002e8
    8950:	20000e38 	.word	0x20000e38
    8954:	20000e48 	.word	0x20000e48
    8958:	2301      	movs	r3, #1
    895a:	930c      	str	r3, [sp, #48]	; 0x30
    895c:	e6f8      	b.n	8750 <_dtoa_r+0x160>
    895e:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    8962:	eeb4 7b46 	vcmp.f64	d7, d6
    8966:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    896a:	f43f aedc 	beq.w	8726 <_dtoa_r+0x136>
    896e:	9b02      	ldr	r3, [sp, #8]
    8970:	3b01      	subs	r3, #1
    8972:	9302      	str	r3, [sp, #8]
    8974:	e6d7      	b.n	8726 <_dtoa_r+0x136>
    8976:	9a06      	ldr	r2, [sp, #24]
    8978:	9b02      	ldr	r3, [sp, #8]
    897a:	1ad2      	subs	r2, r2, r3
    897c:	425b      	negs	r3, r3
    897e:	9305      	str	r3, [sp, #20]
    8980:	2300      	movs	r3, #0
    8982:	9206      	str	r2, [sp, #24]
    8984:	930b      	str	r3, [sp, #44]	; 0x2c
    8986:	e6f2      	b.n	876e <_dtoa_r+0x17e>
    8988:	f1c9 0300 	rsb	r3, r9, #0
    898c:	9306      	str	r3, [sp, #24]
    898e:	f04f 0900 	mov.w	r9, #0
    8992:	e6e4      	b.n	875e <_dtoa_r+0x16e>
    8994:	9b05      	ldr	r3, [sp, #20]
    8996:	930e      	str	r3, [sp, #56]	; 0x38
    8998:	9e09      	ldr	r6, [sp, #36]	; 0x24
    899a:	9b06      	ldr	r3, [sp, #24]
    899c:	930a      	str	r3, [sp, #40]	; 0x28
    899e:	990a      	ldr	r1, [sp, #40]	; 0x28
    89a0:	460b      	mov	r3, r1
    89a2:	b161      	cbz	r1, 89be <_dtoa_r+0x3ce>
    89a4:	f1b9 0f00 	cmp.w	r9, #0
    89a8:	dd09      	ble.n	89be <_dtoa_r+0x3ce>
    89aa:	4549      	cmp	r1, r9
    89ac:	9a06      	ldr	r2, [sp, #24]
    89ae:	bfa8      	it	ge
    89b0:	464b      	movge	r3, r9
    89b2:	1ad2      	subs	r2, r2, r3
    89b4:	9206      	str	r2, [sp, #24]
    89b6:	1aca      	subs	r2, r1, r3
    89b8:	920a      	str	r2, [sp, #40]	; 0x28
    89ba:	ebc3 0909 	rsb	r9, r3, r9
    89be:	9b05      	ldr	r3, [sp, #20]
    89c0:	2b00      	cmp	r3, #0
    89c2:	f340 8280 	ble.w	8ec6 <_dtoa_r+0x8d6>
    89c6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    89c8:	2a00      	cmp	r2, #0
    89ca:	f000 819a 	beq.w	8d02 <_dtoa_r+0x712>
    89ce:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    89d0:	2a00      	cmp	r2, #0
    89d2:	f000 8196 	beq.w	8d02 <_dtoa_r+0x712>
    89d6:	4631      	mov	r1, r6
    89d8:	4620      	mov	r0, r4
    89da:	f7ff fb61 	bl	80a0 <__pow5mult>
    89de:	9a07      	ldr	r2, [sp, #28]
    89e0:	4601      	mov	r1, r0
    89e2:	4606      	mov	r6, r0
    89e4:	4620      	mov	r0, r4
    89e6:	f7ff fac3 	bl	7f70 <__multiply>
    89ea:	9907      	ldr	r1, [sp, #28]
    89ec:	4605      	mov	r5, r0
    89ee:	4620      	mov	r0, r4
    89f0:	f7ff fa1c 	bl	7e2c <_Bfree>
    89f4:	9b05      	ldr	r3, [sp, #20]
    89f6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    89f8:	1a9b      	subs	r3, r3, r2
    89fa:	9305      	str	r3, [sp, #20]
    89fc:	f040 8180 	bne.w	8d00 <_dtoa_r+0x710>
    8a00:	2101      	movs	r1, #1
    8a02:	4620      	mov	r0, r4
    8a04:	f7ff faaa 	bl	7f5c <__i2b>
    8a08:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8a0a:	9005      	str	r0, [sp, #20]
    8a0c:	2b00      	cmp	r3, #0
    8a0e:	f000 81ac 	beq.w	8d6a <_dtoa_r+0x77a>
    8a12:	4601      	mov	r1, r0
    8a14:	461a      	mov	r2, r3
    8a16:	4620      	mov	r0, r4
    8a18:	f7ff fb42 	bl	80a0 <__pow5mult>
    8a1c:	9b01      	ldr	r3, [sp, #4]
    8a1e:	9005      	str	r0, [sp, #20]
    8a20:	2b01      	cmp	r3, #1
    8a22:	f340 8280 	ble.w	8f26 <_dtoa_r+0x936>
    8a26:	2300      	movs	r3, #0
    8a28:	9307      	str	r3, [sp, #28]
    8a2a:	9a05      	ldr	r2, [sp, #20]
    8a2c:	6913      	ldr	r3, [r2, #16]
    8a2e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    8a32:	6918      	ldr	r0, [r3, #16]
    8a34:	f7ff fa44 	bl	7ec0 <__hi0bits>
    8a38:	f1c0 0020 	rsb	r0, r0, #32
    8a3c:	4448      	add	r0, r9
    8a3e:	f010 001f 	ands.w	r0, r0, #31
    8a42:	f000 8190 	beq.w	8d66 <_dtoa_r+0x776>
    8a46:	f1c0 0320 	rsb	r3, r0, #32
    8a4a:	2b04      	cmp	r3, #4
    8a4c:	f340 83f8 	ble.w	9240 <_dtoa_r+0xc50>
    8a50:	f1c0 001c 	rsb	r0, r0, #28
    8a54:	9b06      	ldr	r3, [sp, #24]
    8a56:	4403      	add	r3, r0
    8a58:	9306      	str	r3, [sp, #24]
    8a5a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8a5c:	4403      	add	r3, r0
    8a5e:	930a      	str	r3, [sp, #40]	; 0x28
    8a60:	4481      	add	r9, r0
    8a62:	9b06      	ldr	r3, [sp, #24]
    8a64:	2b00      	cmp	r3, #0
    8a66:	dd05      	ble.n	8a74 <_dtoa_r+0x484>
    8a68:	4629      	mov	r1, r5
    8a6a:	461a      	mov	r2, r3
    8a6c:	4620      	mov	r0, r4
    8a6e:	f7ff fb67 	bl	8140 <__lshift>
    8a72:	4605      	mov	r5, r0
    8a74:	f1b9 0f00 	cmp.w	r9, #0
    8a78:	dd05      	ble.n	8a86 <_dtoa_r+0x496>
    8a7a:	464a      	mov	r2, r9
    8a7c:	9905      	ldr	r1, [sp, #20]
    8a7e:	4620      	mov	r0, r4
    8a80:	f7ff fb5e 	bl	8140 <__lshift>
    8a84:	9005      	str	r0, [sp, #20]
    8a86:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    8a88:	2b00      	cmp	r3, #0
    8a8a:	f040 8201 	bne.w	8e90 <_dtoa_r+0x8a0>
    8a8e:	2f00      	cmp	r7, #0
    8a90:	f340 8220 	ble.w	8ed4 <_dtoa_r+0x8e4>
    8a94:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8a96:	2b00      	cmp	r3, #0
    8a98:	f040 817b 	bne.w	8d92 <_dtoa_r+0x7a2>
    8a9c:	f8dd b020 	ldr.w	fp, [sp, #32]
    8aa0:	f8dd a014 	ldr.w	sl, [sp, #20]
    8aa4:	46d8      	mov	r8, fp
    8aa6:	e002      	b.n	8aae <_dtoa_r+0x4be>
    8aa8:	f7ff f9ca 	bl	7e40 <__multadd>
    8aac:	4605      	mov	r5, r0
    8aae:	4651      	mov	r1, sl
    8ab0:	4628      	mov	r0, r5
    8ab2:	f7ff fd07 	bl	84c4 <quorem>
    8ab6:	f100 0930 	add.w	r9, r0, #48	; 0x30
    8aba:	f808 9b01 	strb.w	r9, [r8], #1
    8abe:	ebcb 0308 	rsb	r3, fp, r8
    8ac2:	42bb      	cmp	r3, r7
    8ac4:	f04f 020a 	mov.w	r2, #10
    8ac8:	f04f 0300 	mov.w	r3, #0
    8acc:	4629      	mov	r1, r5
    8ace:	4620      	mov	r0, r4
    8ad0:	dbea      	blt.n	8aa8 <_dtoa_r+0x4b8>
    8ad2:	9b08      	ldr	r3, [sp, #32]
    8ad4:	2f01      	cmp	r7, #1
    8ad6:	bfac      	ite	ge
    8ad8:	19db      	addge	r3, r3, r7
    8ada:	3301      	addlt	r3, #1
    8adc:	469b      	mov	fp, r3
    8ade:	f04f 0a00 	mov.w	sl, #0
    8ae2:	4629      	mov	r1, r5
    8ae4:	2201      	movs	r2, #1
    8ae6:	4620      	mov	r0, r4
    8ae8:	f7ff fb2a 	bl	8140 <__lshift>
    8aec:	9905      	ldr	r1, [sp, #20]
    8aee:	9007      	str	r0, [sp, #28]
    8af0:	f7ff fb7e 	bl	81f0 <__mcmp>
    8af4:	2800      	cmp	r0, #0
    8af6:	f340 828c 	ble.w	9012 <_dtoa_r+0xa22>
    8afa:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
    8afe:	9908      	ldr	r1, [sp, #32]
    8b00:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    8b04:	e004      	b.n	8b10 <_dtoa_r+0x520>
    8b06:	428b      	cmp	r3, r1
    8b08:	f000 8203 	beq.w	8f12 <_dtoa_r+0x922>
    8b0c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    8b10:	2a39      	cmp	r2, #57	; 0x39
    8b12:	f103 0b01 	add.w	fp, r3, #1
    8b16:	d0f6      	beq.n	8b06 <_dtoa_r+0x516>
    8b18:	3201      	adds	r2, #1
    8b1a:	701a      	strb	r2, [r3, #0]
    8b1c:	9905      	ldr	r1, [sp, #20]
    8b1e:	4620      	mov	r0, r4
    8b20:	f7ff f984 	bl	7e2c <_Bfree>
    8b24:	2e00      	cmp	r6, #0
    8b26:	f43f aec9 	beq.w	88bc <_dtoa_r+0x2cc>
    8b2a:	f1ba 0f00 	cmp.w	sl, #0
    8b2e:	d005      	beq.n	8b3c <_dtoa_r+0x54c>
    8b30:	45b2      	cmp	sl, r6
    8b32:	d003      	beq.n	8b3c <_dtoa_r+0x54c>
    8b34:	4651      	mov	r1, sl
    8b36:	4620      	mov	r0, r4
    8b38:	f7ff f978 	bl	7e2c <_Bfree>
    8b3c:	4631      	mov	r1, r6
    8b3e:	4620      	mov	r0, r4
    8b40:	f7ff f974 	bl	7e2c <_Bfree>
    8b44:	e6ba      	b.n	88bc <_dtoa_r+0x2cc>
    8b46:	f1c3 0320 	rsb	r3, r3, #32
    8b4a:	fa0a f303 	lsl.w	r3, sl, r3
    8b4e:	ee07 3a90 	vmov	s15, r3
    8b52:	e5c1      	b.n	86d8 <_dtoa_r+0xe8>
    8b54:	2300      	movs	r3, #0
    8b56:	930c      	str	r3, [sp, #48]	; 0x30
    8b58:	e5fa      	b.n	8750 <_dtoa_r+0x160>
    8b5a:	2300      	movs	r3, #0
    8b5c:	9309      	str	r3, [sp, #36]	; 0x24
    8b5e:	9b02      	ldr	r3, [sp, #8]
    8b60:	4443      	add	r3, r8
    8b62:	1c5f      	adds	r7, r3, #1
    8b64:	2f00      	cmp	r7, #0
    8b66:	930d      	str	r3, [sp, #52]	; 0x34
    8b68:	f340 822d 	ble.w	8fc6 <_dtoa_r+0x9d6>
    8b6c:	463e      	mov	r6, r7
    8b6e:	463d      	mov	r5, r7
    8b70:	2100      	movs	r1, #0
    8b72:	2e17      	cmp	r6, #23
    8b74:	6461      	str	r1, [r4, #68]	; 0x44
    8b76:	d90a      	bls.n	8b8e <_dtoa_r+0x59e>
    8b78:	2201      	movs	r2, #1
    8b7a:	2304      	movs	r3, #4
    8b7c:	005b      	lsls	r3, r3, #1
    8b7e:	f103 0014 	add.w	r0, r3, #20
    8b82:	42b0      	cmp	r0, r6
    8b84:	4611      	mov	r1, r2
    8b86:	f102 0201 	add.w	r2, r2, #1
    8b8a:	d9f7      	bls.n	8b7c <_dtoa_r+0x58c>
    8b8c:	6461      	str	r1, [r4, #68]	; 0x44
    8b8e:	4620      	mov	r0, r4
    8b90:	f7ff f926 	bl	7de0 <_Balloc>
    8b94:	2d0e      	cmp	r5, #14
    8b96:	9008      	str	r0, [sp, #32]
    8b98:	6420      	str	r0, [r4, #64]	; 0x40
    8b9a:	f63f ae26 	bhi.w	87ea <_dtoa_r+0x1fa>
    8b9e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8ba0:	2b00      	cmp	r3, #0
    8ba2:	f43f ae22 	beq.w	87ea <_dtoa_r+0x1fa>
    8ba6:	9902      	ldr	r1, [sp, #8]
    8ba8:	2900      	cmp	r1, #0
    8baa:	e9cd ab0e 	strd	sl, fp, [sp, #56]	; 0x38
    8bae:	f340 8241 	ble.w	9034 <_dtoa_r+0xa44>
    8bb2:	4bc6      	ldr	r3, [pc, #792]	; (8ecc <_dtoa_r+0x8dc>)
    8bb4:	f001 020f 	and.w	r2, r1, #15
    8bb8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    8bbc:	110b      	asrs	r3, r1, #4
    8bbe:	06de      	lsls	r6, r3, #27
    8bc0:	ed92 6b00 	vldr	d6, [r2]
    8bc4:	f140 81fb 	bpl.w	8fbe <_dtoa_r+0x9ce>
    8bc8:	4ac1      	ldr	r2, [pc, #772]	; (8ed0 <_dtoa_r+0x8e0>)
    8bca:	ed92 7b08 	vldr	d7, [r2, #32]
    8bce:	ec4b ab14 	vmov	d4, sl, fp
    8bd2:	f003 030f 	and.w	r3, r3, #15
    8bd6:	2103      	movs	r1, #3
    8bd8:	ee84 5b07 	vdiv.f64	d5, d4, d7
    8bdc:	b15b      	cbz	r3, 8bf6 <_dtoa_r+0x606>
    8bde:	4abc      	ldr	r2, [pc, #752]	; (8ed0 <_dtoa_r+0x8e0>)
    8be0:	07dd      	lsls	r5, r3, #31
    8be2:	d504      	bpl.n	8bee <_dtoa_r+0x5fe>
    8be4:	ed92 7b00 	vldr	d7, [r2]
    8be8:	3101      	adds	r1, #1
    8bea:	ee26 6b07 	vmul.f64	d6, d6, d7
    8bee:	105b      	asrs	r3, r3, #1
    8bf0:	f102 0208 	add.w	r2, r2, #8
    8bf4:	d1f4      	bne.n	8be0 <_dtoa_r+0x5f0>
    8bf6:	ee85 4b06 	vdiv.f64	d4, d5, d6
    8bfa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    8bfc:	b13b      	cbz	r3, 8c0e <_dtoa_r+0x61e>
    8bfe:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    8c02:	eeb4 4bc7 	vcmpe.f64	d4, d7
    8c06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8c0a:	f100 82b7 	bmi.w	917c <_dtoa_r+0xb8c>
    8c0e:	ee07 1a90 	vmov	s15, r1
    8c12:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    8c16:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    8c1a:	eea6 7b04 	vfma.f64	d7, d6, d4
    8c1e:	ec53 2b17 	vmov	r2, r3, d7
    8c22:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    8c26:	2f00      	cmp	r7, #0
    8c28:	f000 81a6 	beq.w	8f78 <_dtoa_r+0x988>
    8c2c:	9e02      	ldr	r6, [sp, #8]
    8c2e:	4639      	mov	r1, r7
    8c30:	9809      	ldr	r0, [sp, #36]	; 0x24
    8c32:	2800      	cmp	r0, #0
    8c34:	f000 824d 	beq.w	90d2 <_dtoa_r+0xae2>
    8c38:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    8c3c:	48a3      	ldr	r0, [pc, #652]	; (8ecc <_dtoa_r+0x8dc>)
    8c3e:	9d08      	ldr	r5, [sp, #32]
    8c40:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
    8c44:	ed10 6b02 	vldr	d6, [r0, #-8]
    8c48:	eebd 7bc4 	vcvt.s32.f64	s14, d4
    8c4c:	ee83 5b06 	vdiv.f64	d5, d3, d6
    8c50:	ee17 0a10 	vmov	r0, s14
    8c54:	ec43 2b16 	vmov	d6, r2, r3
    8c58:	3030      	adds	r0, #48	; 0x30
    8c5a:	b2c0      	uxtb	r0, r0
    8c5c:	ee35 5b46 	vsub.f64	d5, d5, d6
    8c60:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    8c64:	ee34 7b47 	vsub.f64	d7, d4, d7
    8c68:	eeb4 5bc7 	vcmpe.f64	d5, d7
    8c6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8c70:	7028      	strb	r0, [r5, #0]
    8c72:	f105 0b01 	add.w	fp, r5, #1
    8c76:	dc32      	bgt.n	8cde <_dtoa_r+0x6ee>
    8c78:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
    8c7c:	ee33 6b47 	vsub.f64	d6, d3, d7
    8c80:	eeb4 5bc6 	vcmpe.f64	d5, d6
    8c84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8c88:	f300 82ae 	bgt.w	91e8 <_dtoa_r+0xbf8>
    8c8c:	2901      	cmp	r1, #1
    8c8e:	f340 81cd 	ble.w	902c <_dtoa_r+0xa3c>
    8c92:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    8c96:	9b08      	ldr	r3, [sp, #32]
    8c98:	4419      	add	r1, r3
    8c9a:	e00a      	b.n	8cb2 <_dtoa_r+0x6c2>
    8c9c:	ee33 6b47 	vsub.f64	d6, d3, d7
    8ca0:	eeb4 6bc5 	vcmpe.f64	d6, d5
    8ca4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8ca8:	f100 829e 	bmi.w	91e8 <_dtoa_r+0xbf8>
    8cac:	458b      	cmp	fp, r1
    8cae:	f000 81bd 	beq.w	902c <_dtoa_r+0xa3c>
    8cb2:	ee27 7b04 	vmul.f64	d7, d7, d4
    8cb6:	ee25 5b04 	vmul.f64	d5, d5, d4
    8cba:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    8cbe:	ee16 3a10 	vmov	r3, s12
    8cc2:	f103 0030 	add.w	r0, r3, #48	; 0x30
    8cc6:	b2c0      	uxtb	r0, r0
    8cc8:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    8ccc:	ee37 7b46 	vsub.f64	d7, d7, d6
    8cd0:	eeb4 7bc5 	vcmpe.f64	d7, d5
    8cd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8cd8:	f80b 0b01 	strb.w	r0, [fp], #1
    8cdc:	d5de      	bpl.n	8c9c <_dtoa_r+0x6ac>
    8cde:	9602      	str	r6, [sp, #8]
    8ce0:	e5ec      	b.n	88bc <_dtoa_r+0x2cc>
    8ce2:	2300      	movs	r3, #0
    8ce4:	9309      	str	r3, [sp, #36]	; 0x24
    8ce6:	f1b8 0f00 	cmp.w	r8, #0
    8cea:	f340 8170 	ble.w	8fce <_dtoa_r+0x9de>
    8cee:	4646      	mov	r6, r8
    8cf0:	4645      	mov	r5, r8
    8cf2:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    8cf6:	4647      	mov	r7, r8
    8cf8:	e73a      	b.n	8b70 <_dtoa_r+0x580>
    8cfa:	2301      	movs	r3, #1
    8cfc:	9309      	str	r3, [sp, #36]	; 0x24
    8cfe:	e7f2      	b.n	8ce6 <_dtoa_r+0x6f6>
    8d00:	9507      	str	r5, [sp, #28]
    8d02:	9a05      	ldr	r2, [sp, #20]
    8d04:	9907      	ldr	r1, [sp, #28]
    8d06:	4620      	mov	r0, r4
    8d08:	f7ff f9ca 	bl	80a0 <__pow5mult>
    8d0c:	4605      	mov	r5, r0
    8d0e:	e677      	b.n	8a00 <_dtoa_r+0x410>
    8d10:	2f00      	cmp	r7, #0
    8d12:	f73f ad79 	bgt.w	8808 <_dtoa_r+0x218>
    8d16:	f040 8142 	bne.w	8f9e <_dtoa_r+0x9ae>
    8d1a:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    8d1e:	ee24 4b07 	vmul.f64	d4, d4, d7
    8d22:	ec4b ab17 	vmov	d7, sl, fp
    8d26:	eeb4 4bc7 	vcmpe.f64	d4, d7
    8d2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8d2e:	463e      	mov	r6, r7
    8d30:	9705      	str	r7, [sp, #20]
    8d32:	f2c0 80e5 	blt.w	8f00 <_dtoa_r+0x910>
    8d36:	ea6f 0308 	mvn.w	r3, r8
    8d3a:	f8dd b020 	ldr.w	fp, [sp, #32]
    8d3e:	9302      	str	r3, [sp, #8]
    8d40:	9905      	ldr	r1, [sp, #20]
    8d42:	4620      	mov	r0, r4
    8d44:	f7ff f872 	bl	7e2c <_Bfree>
    8d48:	2e00      	cmp	r6, #0
    8d4a:	f43f adb7 	beq.w	88bc <_dtoa_r+0x2cc>
    8d4e:	e6f5      	b.n	8b3c <_dtoa_r+0x54c>
    8d50:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    8d52:	2a00      	cmp	r2, #0
    8d54:	f000 8202 	beq.w	915c <_dtoa_r+0xb6c>
    8d58:	9a05      	ldr	r2, [sp, #20]
    8d5a:	920e      	str	r2, [sp, #56]	; 0x38
    8d5c:	9a06      	ldr	r2, [sp, #24]
    8d5e:	920a      	str	r2, [sp, #40]	; 0x28
    8d60:	f203 4333 	addw	r3, r3, #1075	; 0x433
    8d64:	e5d3      	b.n	890e <_dtoa_r+0x31e>
    8d66:	201c      	movs	r0, #28
    8d68:	e674      	b.n	8a54 <_dtoa_r+0x464>
    8d6a:	9b01      	ldr	r3, [sp, #4]
    8d6c:	2b01      	cmp	r3, #1
    8d6e:	f340 8240 	ble.w	91f2 <_dtoa_r+0xc02>
    8d72:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8d74:	9307      	str	r3, [sp, #28]
    8d76:	2001      	movs	r0, #1
    8d78:	e660      	b.n	8a3c <_dtoa_r+0x44c>
    8d7a:	4631      	mov	r1, r6
    8d7c:	2300      	movs	r3, #0
    8d7e:	220a      	movs	r2, #10
    8d80:	4620      	mov	r0, r4
    8d82:	f7ff f85d 	bl	7e40 <__multadd>
    8d86:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    8d88:	2b00      	cmp	r3, #0
    8d8a:	4606      	mov	r6, r0
    8d8c:	f340 824d 	ble.w	922a <_dtoa_r+0xc3a>
    8d90:	461f      	mov	r7, r3
    8d92:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8d94:	2b00      	cmp	r3, #0
    8d96:	dd05      	ble.n	8da4 <_dtoa_r+0x7b4>
    8d98:	4631      	mov	r1, r6
    8d9a:	461a      	mov	r2, r3
    8d9c:	4620      	mov	r0, r4
    8d9e:	f7ff f9cf 	bl	8140 <__lshift>
    8da2:	4606      	mov	r6, r0
    8da4:	9b07      	ldr	r3, [sp, #28]
    8da6:	2b00      	cmp	r3, #0
    8da8:	f040 816e 	bne.w	9088 <_dtoa_r+0xa98>
    8dac:	46b0      	mov	r8, r6
    8dae:	9b08      	ldr	r3, [sp, #32]
    8db0:	3f01      	subs	r7, #1
    8db2:	19da      	adds	r2, r3, r7
    8db4:	9209      	str	r2, [sp, #36]	; 0x24
    8db6:	f00a 0201 	and.w	r2, sl, #1
    8dba:	920a      	str	r2, [sp, #40]	; 0x28
    8dbc:	461f      	mov	r7, r3
    8dbe:	f8dd b014 	ldr.w	fp, [sp, #20]
    8dc2:	4628      	mov	r0, r5
    8dc4:	4659      	mov	r1, fp
    8dc6:	f7ff fb7d 	bl	84c4 <quorem>
    8dca:	4631      	mov	r1, r6
    8dcc:	4682      	mov	sl, r0
    8dce:	4628      	mov	r0, r5
    8dd0:	f7ff fa0e 	bl	81f0 <__mcmp>
    8dd4:	4642      	mov	r2, r8
    8dd6:	4659      	mov	r1, fp
    8dd8:	4681      	mov	r9, r0
    8dda:	4620      	mov	r0, r4
    8ddc:	f7ff fa2a 	bl	8234 <__mdiff>
    8de0:	68c3      	ldr	r3, [r0, #12]
    8de2:	4683      	mov	fp, r0
    8de4:	f10a 0230 	add.w	r2, sl, #48	; 0x30
    8de8:	2b00      	cmp	r3, #0
    8dea:	d149      	bne.n	8e80 <_dtoa_r+0x890>
    8dec:	4601      	mov	r1, r0
    8dee:	4628      	mov	r0, r5
    8df0:	9207      	str	r2, [sp, #28]
    8df2:	f7ff f9fd 	bl	81f0 <__mcmp>
    8df6:	4659      	mov	r1, fp
    8df8:	9006      	str	r0, [sp, #24]
    8dfa:	4620      	mov	r0, r4
    8dfc:	f7ff f816 	bl	7e2c <_Bfree>
    8e00:	9b06      	ldr	r3, [sp, #24]
    8e02:	9a07      	ldr	r2, [sp, #28]
    8e04:	b92b      	cbnz	r3, 8e12 <_dtoa_r+0x822>
    8e06:	9901      	ldr	r1, [sp, #4]
    8e08:	b919      	cbnz	r1, 8e12 <_dtoa_r+0x822>
    8e0a:	990a      	ldr	r1, [sp, #40]	; 0x28
    8e0c:	2900      	cmp	r1, #0
    8e0e:	f000 81f5 	beq.w	91fc <_dtoa_r+0xc0c>
    8e12:	f1b9 0f00 	cmp.w	r9, #0
    8e16:	f2c0 80df 	blt.w	8fd8 <_dtoa_r+0x9e8>
    8e1a:	d105      	bne.n	8e28 <_dtoa_r+0x838>
    8e1c:	9901      	ldr	r1, [sp, #4]
    8e1e:	b919      	cbnz	r1, 8e28 <_dtoa_r+0x838>
    8e20:	990a      	ldr	r1, [sp, #40]	; 0x28
    8e22:	2900      	cmp	r1, #0
    8e24:	f000 80d8 	beq.w	8fd8 <_dtoa_r+0x9e8>
    8e28:	2b00      	cmp	r3, #0
    8e2a:	f300 8141 	bgt.w	90b0 <_dtoa_r+0xac0>
    8e2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8e30:	703a      	strb	r2, [r7, #0]
    8e32:	f107 0901 	add.w	r9, r7, #1
    8e36:	429f      	cmp	r7, r3
    8e38:	46cb      	mov	fp, r9
    8e3a:	f000 8146 	beq.w	90ca <_dtoa_r+0xada>
    8e3e:	4629      	mov	r1, r5
    8e40:	2300      	movs	r3, #0
    8e42:	220a      	movs	r2, #10
    8e44:	4620      	mov	r0, r4
    8e46:	f7fe fffb 	bl	7e40 <__multadd>
    8e4a:	4546      	cmp	r6, r8
    8e4c:	4605      	mov	r5, r0
    8e4e:	4631      	mov	r1, r6
    8e50:	f04f 0300 	mov.w	r3, #0
    8e54:	f04f 020a 	mov.w	r2, #10
    8e58:	4620      	mov	r0, r4
    8e5a:	d00b      	beq.n	8e74 <_dtoa_r+0x884>
    8e5c:	f7fe fff0 	bl	7e40 <__multadd>
    8e60:	4641      	mov	r1, r8
    8e62:	4606      	mov	r6, r0
    8e64:	2300      	movs	r3, #0
    8e66:	220a      	movs	r2, #10
    8e68:	4620      	mov	r0, r4
    8e6a:	f7fe ffe9 	bl	7e40 <__multadd>
    8e6e:	464f      	mov	r7, r9
    8e70:	4680      	mov	r8, r0
    8e72:	e7a4      	b.n	8dbe <_dtoa_r+0x7ce>
    8e74:	f7fe ffe4 	bl	7e40 <__multadd>
    8e78:	464f      	mov	r7, r9
    8e7a:	4606      	mov	r6, r0
    8e7c:	4680      	mov	r8, r0
    8e7e:	e79e      	b.n	8dbe <_dtoa_r+0x7ce>
    8e80:	4601      	mov	r1, r0
    8e82:	4620      	mov	r0, r4
    8e84:	9206      	str	r2, [sp, #24]
    8e86:	f7fe ffd1 	bl	7e2c <_Bfree>
    8e8a:	2301      	movs	r3, #1
    8e8c:	9a06      	ldr	r2, [sp, #24]
    8e8e:	e7c0      	b.n	8e12 <_dtoa_r+0x822>
    8e90:	9905      	ldr	r1, [sp, #20]
    8e92:	4628      	mov	r0, r5
    8e94:	f7ff f9ac 	bl	81f0 <__mcmp>
    8e98:	2800      	cmp	r0, #0
    8e9a:	f6bf adf8 	bge.w	8a8e <_dtoa_r+0x49e>
    8e9e:	4629      	mov	r1, r5
    8ea0:	9d02      	ldr	r5, [sp, #8]
    8ea2:	2300      	movs	r3, #0
    8ea4:	3d01      	subs	r5, #1
    8ea6:	220a      	movs	r2, #10
    8ea8:	4620      	mov	r0, r4
    8eaa:	9502      	str	r5, [sp, #8]
    8eac:	f7fe ffc8 	bl	7e40 <__multadd>
    8eb0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8eb2:	4605      	mov	r5, r0
    8eb4:	2b00      	cmp	r3, #0
    8eb6:	f47f af60 	bne.w	8d7a <_dtoa_r+0x78a>
    8eba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    8ebc:	2b00      	cmp	r3, #0
    8ebe:	f340 81ad 	ble.w	921c <_dtoa_r+0xc2c>
    8ec2:	461f      	mov	r7, r3
    8ec4:	e5ea      	b.n	8a9c <_dtoa_r+0x4ac>
    8ec6:	9d07      	ldr	r5, [sp, #28]
    8ec8:	e59a      	b.n	8a00 <_dtoa_r+0x410>
    8eca:	bf00      	nop
    8ecc:	200002e8 	.word	0x200002e8
    8ed0:	200002c0 	.word	0x200002c0
    8ed4:	9b01      	ldr	r3, [sp, #4]
    8ed6:	2b02      	cmp	r3, #2
    8ed8:	f77f addc 	ble.w	8a94 <_dtoa_r+0x4a4>
    8edc:	2f00      	cmp	r7, #0
    8ede:	f040 8169 	bne.w	91b4 <_dtoa_r+0xbc4>
    8ee2:	463b      	mov	r3, r7
    8ee4:	9905      	ldr	r1, [sp, #20]
    8ee6:	2205      	movs	r2, #5
    8ee8:	4620      	mov	r0, r4
    8eea:	f7fe ffa9 	bl	7e40 <__multadd>
    8eee:	4601      	mov	r1, r0
    8ef0:	9005      	str	r0, [sp, #20]
    8ef2:	4628      	mov	r0, r5
    8ef4:	f7ff f97c 	bl	81f0 <__mcmp>
    8ef8:	2800      	cmp	r0, #0
    8efa:	9507      	str	r5, [sp, #28]
    8efc:	f77f af1b 	ble.w	8d36 <_dtoa_r+0x746>
    8f00:	9a02      	ldr	r2, [sp, #8]
    8f02:	9908      	ldr	r1, [sp, #32]
    8f04:	2331      	movs	r3, #49	; 0x31
    8f06:	3201      	adds	r2, #1
    8f08:	9202      	str	r2, [sp, #8]
    8f0a:	700b      	strb	r3, [r1, #0]
    8f0c:	f101 0b01 	add.w	fp, r1, #1
    8f10:	e716      	b.n	8d40 <_dtoa_r+0x750>
    8f12:	9a02      	ldr	r2, [sp, #8]
    8f14:	3201      	adds	r2, #1
    8f16:	9202      	str	r2, [sp, #8]
    8f18:	9a08      	ldr	r2, [sp, #32]
    8f1a:	2331      	movs	r3, #49	; 0x31
    8f1c:	7013      	strb	r3, [r2, #0]
    8f1e:	e5fd      	b.n	8b1c <_dtoa_r+0x52c>
    8f20:	2301      	movs	r3, #1
    8f22:	9309      	str	r3, [sp, #36]	; 0x24
    8f24:	e61b      	b.n	8b5e <_dtoa_r+0x56e>
    8f26:	f1ba 0f00 	cmp.w	sl, #0
    8f2a:	f47f ad7c 	bne.w	8a26 <_dtoa_r+0x436>
    8f2e:	f3cb 0313 	ubfx	r3, fp, #0, #20
    8f32:	2b00      	cmp	r3, #0
    8f34:	f040 811b 	bne.w	916e <_dtoa_r+0xb7e>
    8f38:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
    8f3c:	0d1b      	lsrs	r3, r3, #20
    8f3e:	051b      	lsls	r3, r3, #20
    8f40:	2b00      	cmp	r3, #0
    8f42:	f000 8154 	beq.w	91ee <_dtoa_r+0xbfe>
    8f46:	9b06      	ldr	r3, [sp, #24]
    8f48:	3301      	adds	r3, #1
    8f4a:	9306      	str	r3, [sp, #24]
    8f4c:	2301      	movs	r3, #1
    8f4e:	f109 0901 	add.w	r9, r9, #1
    8f52:	9307      	str	r3, [sp, #28]
    8f54:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8f56:	2001      	movs	r0, #1
    8f58:	2b00      	cmp	r3, #0
    8f5a:	f43f ad6f 	beq.w	8a3c <_dtoa_r+0x44c>
    8f5e:	e564      	b.n	8a2a <_dtoa_r+0x43a>
    8f60:	ee07 1a90 	vmov	s15, r1
    8f64:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    8f68:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    8f6c:	eea4 7b06 	vfma.f64	d7, d4, d6
    8f70:	ec53 2b17 	vmov	r2, r3, d7
    8f74:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    8f78:	ec43 2b16 	vmov	d6, r2, r3
    8f7c:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    8f80:	ee34 7b47 	vsub.f64	d7, d4, d7
    8f84:	eeb4 7bc6 	vcmpe.f64	d7, d6
    8f88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8f8c:	f300 80dd 	bgt.w	914a <_dtoa_r+0xb5a>
    8f90:	eeb1 6b46 	vneg.f64	d6, d6
    8f94:	eeb4 7bc6 	vcmpe.f64	d7, d6
    8f98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8f9c:	d546      	bpl.n	902c <_dtoa_r+0xa3c>
    8f9e:	2300      	movs	r3, #0
    8fa0:	9305      	str	r3, [sp, #20]
    8fa2:	461e      	mov	r6, r3
    8fa4:	e6c7      	b.n	8d36 <_dtoa_r+0x746>
    8fa6:	9808      	ldr	r0, [sp, #32]
    8fa8:	f7ff bb59 	b.w	865e <_dtoa_r+0x6e>
    8fac:	9b05      	ldr	r3, [sp, #20]
    8fae:	990b      	ldr	r1, [sp, #44]	; 0x2c
    8fb0:	9205      	str	r2, [sp, #20]
    8fb2:	1ad3      	subs	r3, r2, r3
    8fb4:	4419      	add	r1, r3
    8fb6:	2300      	movs	r3, #0
    8fb8:	910b      	str	r1, [sp, #44]	; 0x2c
    8fba:	930e      	str	r3, [sp, #56]	; 0x38
    8fbc:	e4a1      	b.n	8902 <_dtoa_r+0x312>
    8fbe:	ed9d 5b0e 	vldr	d5, [sp, #56]	; 0x38
    8fc2:	2102      	movs	r1, #2
    8fc4:	e60a      	b.n	8bdc <_dtoa_r+0x5ec>
    8fc6:	463d      	mov	r5, r7
    8fc8:	2100      	movs	r1, #0
    8fca:	6461      	str	r1, [r4, #68]	; 0x44
    8fcc:	e5df      	b.n	8b8e <_dtoa_r+0x59e>
    8fce:	2501      	movs	r5, #1
    8fd0:	950d      	str	r5, [sp, #52]	; 0x34
    8fd2:	462f      	mov	r7, r5
    8fd4:	46a8      	mov	r8, r5
    8fd6:	e7f7      	b.n	8fc8 <_dtoa_r+0x9d8>
    8fd8:	2b00      	cmp	r3, #0
    8fda:	4691      	mov	r9, r2
    8fdc:	dd11      	ble.n	9002 <_dtoa_r+0xa12>
    8fde:	4629      	mov	r1, r5
    8fe0:	2201      	movs	r2, #1
    8fe2:	4620      	mov	r0, r4
    8fe4:	f7ff f8ac 	bl	8140 <__lshift>
    8fe8:	9905      	ldr	r1, [sp, #20]
    8fea:	4605      	mov	r5, r0
    8fec:	f7ff f900 	bl	81f0 <__mcmp>
    8ff0:	2800      	cmp	r0, #0
    8ff2:	f340 810c 	ble.w	920e <_dtoa_r+0xc1e>
    8ff6:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
    8ffa:	f000 80dd 	beq.w	91b8 <_dtoa_r+0xbc8>
    8ffe:	f10a 0931 	add.w	r9, sl, #49	; 0x31
    9002:	46b2      	mov	sl, r6
    9004:	f887 9000 	strb.w	r9, [r7]
    9008:	f107 0b01 	add.w	fp, r7, #1
    900c:	4646      	mov	r6, r8
    900e:	9507      	str	r5, [sp, #28]
    9010:	e584      	b.n	8b1c <_dtoa_r+0x52c>
    9012:	d104      	bne.n	901e <_dtoa_r+0xa2e>
    9014:	f019 0f01 	tst.w	r9, #1
    9018:	d001      	beq.n	901e <_dtoa_r+0xa2e>
    901a:	e56e      	b.n	8afa <_dtoa_r+0x50a>
    901c:	4693      	mov	fp, r2
    901e:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    9022:	2b30      	cmp	r3, #48	; 0x30
    9024:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    9028:	d0f8      	beq.n	901c <_dtoa_r+0xa2c>
    902a:	e577      	b.n	8b1c <_dtoa_r+0x52c>
    902c:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
    9030:	f7ff bbdb 	b.w	87ea <_dtoa_r+0x1fa>
    9034:	9b02      	ldr	r3, [sp, #8]
    9036:	425b      	negs	r3, r3
    9038:	2b00      	cmp	r3, #0
    903a:	f000 809b 	beq.w	9174 <_dtoa_r+0xb84>
    903e:	4a8b      	ldr	r2, [pc, #556]	; (926c <_dtoa_r+0xc7c>)
    9040:	f003 010f 	and.w	r1, r3, #15
    9044:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
    9048:	ed92 7b00 	vldr	d7, [r2]
    904c:	ed9d 6b0e 	vldr	d6, [sp, #56]	; 0x38
    9050:	111b      	asrs	r3, r3, #4
    9052:	ee26 4b07 	vmul.f64	d4, d6, d7
    9056:	f000 80e6 	beq.w	9226 <_dtoa_r+0xc36>
    905a:	4a85      	ldr	r2, [pc, #532]	; (9270 <_dtoa_r+0xc80>)
    905c:	2102      	movs	r1, #2
    905e:	07d8      	lsls	r0, r3, #31
    9060:	d504      	bpl.n	906c <_dtoa_r+0xa7c>
    9062:	ed92 7b00 	vldr	d7, [r2]
    9066:	3101      	adds	r1, #1
    9068:	ee24 4b07 	vmul.f64	d4, d4, d7
    906c:	105b      	asrs	r3, r3, #1
    906e:	f102 0208 	add.w	r2, r2, #8
    9072:	d1f4      	bne.n	905e <_dtoa_r+0xa6e>
    9074:	e5c1      	b.n	8bfa <_dtoa_r+0x60a>
    9076:	9908      	ldr	r1, [sp, #32]
    9078:	2230      	movs	r2, #48	; 0x30
    907a:	700a      	strb	r2, [r1, #0]
    907c:	9a02      	ldr	r2, [sp, #8]
    907e:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    9082:	3201      	adds	r2, #1
    9084:	9202      	str	r2, [sp, #8]
    9086:	e417      	b.n	88b8 <_dtoa_r+0x2c8>
    9088:	6871      	ldr	r1, [r6, #4]
    908a:	4620      	mov	r0, r4
    908c:	f7fe fea8 	bl	7de0 <_Balloc>
    9090:	6933      	ldr	r3, [r6, #16]
    9092:	1c9a      	adds	r2, r3, #2
    9094:	4680      	mov	r8, r0
    9096:	0092      	lsls	r2, r2, #2
    9098:	f106 010c 	add.w	r1, r6, #12
    909c:	300c      	adds	r0, #12
    909e:	f7fd fe0b 	bl	6cb8 <memcpy>
    90a2:	4641      	mov	r1, r8
    90a4:	2201      	movs	r2, #1
    90a6:	4620      	mov	r0, r4
    90a8:	f7ff f84a 	bl	8140 <__lshift>
    90ac:	4680      	mov	r8, r0
    90ae:	e67e      	b.n	8dae <_dtoa_r+0x7be>
    90b0:	2a39      	cmp	r2, #57	; 0x39
    90b2:	f000 8081 	beq.w	91b8 <_dtoa_r+0xbc8>
    90b6:	f102 0901 	add.w	r9, r2, #1
    90ba:	46b2      	mov	sl, r6
    90bc:	f887 9000 	strb.w	r9, [r7]
    90c0:	f107 0b01 	add.w	fp, r7, #1
    90c4:	4646      	mov	r6, r8
    90c6:	9507      	str	r5, [sp, #28]
    90c8:	e528      	b.n	8b1c <_dtoa_r+0x52c>
    90ca:	46b2      	mov	sl, r6
    90cc:	4691      	mov	r9, r2
    90ce:	4646      	mov	r6, r8
    90d0:	e507      	b.n	8ae2 <_dtoa_r+0x4f2>
    90d2:	4866      	ldr	r0, [pc, #408]	; (926c <_dtoa_r+0xc7c>)
    90d4:	eebd 6bc4 	vcvt.s32.f64	s12, d4
    90d8:	1e4d      	subs	r5, r1, #1
    90da:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
    90de:	ec43 2b17 	vmov	d7, r2, r3
    90e2:	ed90 3b00 	vldr	d3, [r0]
    90e6:	ee16 3a10 	vmov	r3, s12
    90ea:	ee23 3b07 	vmul.f64	d3, d3, d7
    90ee:	9808      	ldr	r0, [sp, #32]
    90f0:	3330      	adds	r3, #48	; 0x30
    90f2:	2901      	cmp	r1, #1
    90f4:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    90f8:	7003      	strb	r3, [r0, #0]
    90fa:	f100 0b01 	add.w	fp, r0, #1
    90fe:	ee34 7b46 	vsub.f64	d7, d4, d6
    9102:	d014      	beq.n	912e <_dtoa_r+0xb3e>
    9104:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    9108:	9b08      	ldr	r3, [sp, #32]
    910a:	4419      	add	r1, r3
    910c:	465b      	mov	r3, fp
    910e:	ee27 7b05 	vmul.f64	d7, d7, d5
    9112:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    9116:	ee16 2a10 	vmov	r2, s12
    911a:	3230      	adds	r2, #48	; 0x30
    911c:	f803 2b01 	strb.w	r2, [r3], #1
    9120:	4299      	cmp	r1, r3
    9122:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    9126:	ee37 7b46 	vsub.f64	d7, d7, d6
    912a:	d1f0      	bne.n	910e <_dtoa_r+0xb1e>
    912c:	44ab      	add	fp, r5
    912e:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
    9132:	ee33 5b06 	vadd.f64	d5, d3, d6
    9136:	eeb4 5bc7 	vcmpe.f64	d5, d7
    913a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    913e:	d543      	bpl.n	91c8 <_dtoa_r+0xbd8>
    9140:	9602      	str	r6, [sp, #8]
    9142:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    9146:	f7ff bbaa 	b.w	889e <_dtoa_r+0x2ae>
    914a:	2300      	movs	r3, #0
    914c:	9305      	str	r3, [sp, #20]
    914e:	461e      	mov	r6, r3
    9150:	e6d6      	b.n	8f00 <_dtoa_r+0x910>
    9152:	1bdb      	subs	r3, r3, r7
    9154:	930a      	str	r3, [sp, #40]	; 0x28
    9156:	2300      	movs	r3, #0
    9158:	f7ff bbd9 	b.w	890e <_dtoa_r+0x31e>
    915c:	9a05      	ldr	r2, [sp, #20]
    915e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    9160:	920e      	str	r2, [sp, #56]	; 0x38
    9162:	9a06      	ldr	r2, [sp, #24]
    9164:	920a      	str	r2, [sp, #40]	; 0x28
    9166:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    916a:	f7ff bbd0 	b.w	890e <_dtoa_r+0x31e>
    916e:	2300      	movs	r3, #0
    9170:	9307      	str	r3, [sp, #28]
    9172:	e6ef      	b.n	8f54 <_dtoa_r+0x964>
    9174:	ed9d 4b0e 	vldr	d4, [sp, #56]	; 0x38
    9178:	2102      	movs	r1, #2
    917a:	e53e      	b.n	8bfa <_dtoa_r+0x60a>
    917c:	2f00      	cmp	r7, #0
    917e:	f43f aeef 	beq.w	8f60 <_dtoa_r+0x970>
    9182:	980d      	ldr	r0, [sp, #52]	; 0x34
    9184:	2800      	cmp	r0, #0
    9186:	f77f af51 	ble.w	902c <_dtoa_r+0xa3c>
    918a:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    918e:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    9192:	3101      	adds	r1, #1
    9194:	ee06 1a90 	vmov	s13, r1
    9198:	ee24 4b05 	vmul.f64	d4, d4, d5
    919c:	9b02      	ldr	r3, [sp, #8]
    919e:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    91a2:	1e5e      	subs	r6, r3, #1
    91a4:	eea4 7b06 	vfma.f64	d7, d4, d6
    91a8:	ec53 2b17 	vmov	r2, r3, d7
    91ac:	4601      	mov	r1, r0
    91ae:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    91b2:	e53d      	b.n	8c30 <_dtoa_r+0x640>
    91b4:	9507      	str	r5, [sp, #28]
    91b6:	e5be      	b.n	8d36 <_dtoa_r+0x746>
    91b8:	2239      	movs	r2, #57	; 0x39
    91ba:	46b2      	mov	sl, r6
    91bc:	9507      	str	r5, [sp, #28]
    91be:	4646      	mov	r6, r8
    91c0:	703a      	strb	r2, [r7, #0]
    91c2:	f107 0b01 	add.w	fp, r7, #1
    91c6:	e49a      	b.n	8afe <_dtoa_r+0x50e>
    91c8:	ee36 6b43 	vsub.f64	d6, d6, d3
    91cc:	eeb4 6bc7 	vcmpe.f64	d6, d7
    91d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    91d4:	dc01      	bgt.n	91da <_dtoa_r+0xbea>
    91d6:	e729      	b.n	902c <_dtoa_r+0xa3c>
    91d8:	4693      	mov	fp, r2
    91da:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    91de:	2b30      	cmp	r3, #48	; 0x30
    91e0:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    91e4:	d0f8      	beq.n	91d8 <_dtoa_r+0xbe8>
    91e6:	e57a      	b.n	8cde <_dtoa_r+0x6ee>
    91e8:	9602      	str	r6, [sp, #8]
    91ea:	f7ff bb58 	b.w	889e <_dtoa_r+0x2ae>
    91ee:	9307      	str	r3, [sp, #28]
    91f0:	e6b0      	b.n	8f54 <_dtoa_r+0x964>
    91f2:	f1ba 0f00 	cmp.w	sl, #0
    91f6:	f47f adbc 	bne.w	8d72 <_dtoa_r+0x782>
    91fa:	e698      	b.n	8f2e <_dtoa_r+0x93e>
    91fc:	2a39      	cmp	r2, #57	; 0x39
    91fe:	46cb      	mov	fp, r9
    9200:	4691      	mov	r9, r2
    9202:	d0d9      	beq.n	91b8 <_dtoa_r+0xbc8>
    9204:	f1bb 0f00 	cmp.w	fp, #0
    9208:	f73f aef9 	bgt.w	8ffe <_dtoa_r+0xa0e>
    920c:	e6f9      	b.n	9002 <_dtoa_r+0xa12>
    920e:	f47f aef8 	bne.w	9002 <_dtoa_r+0xa12>
    9212:	f019 0f01 	tst.w	r9, #1
    9216:	f43f aef4 	beq.w	9002 <_dtoa_r+0xa12>
    921a:	e6ec      	b.n	8ff6 <_dtoa_r+0xa06>
    921c:	9b01      	ldr	r3, [sp, #4]
    921e:	2b02      	cmp	r3, #2
    9220:	dc08      	bgt.n	9234 <_dtoa_r+0xc44>
    9222:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    9224:	e43a      	b.n	8a9c <_dtoa_r+0x4ac>
    9226:	2102      	movs	r1, #2
    9228:	e4e7      	b.n	8bfa <_dtoa_r+0x60a>
    922a:	9b01      	ldr	r3, [sp, #4]
    922c:	2b02      	cmp	r3, #2
    922e:	dc01      	bgt.n	9234 <_dtoa_r+0xc44>
    9230:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    9232:	e5ae      	b.n	8d92 <_dtoa_r+0x7a2>
    9234:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    9236:	e651      	b.n	8edc <_dtoa_r+0x8ec>
    9238:	2301      	movs	r3, #1
    923a:	930e      	str	r3, [sp, #56]	; 0x38
    923c:	f7ff baa1 	b.w	8782 <_dtoa_r+0x192>
    9240:	f43f ac0f 	beq.w	8a62 <_dtoa_r+0x472>
    9244:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
    9248:	e404      	b.n	8a54 <_dtoa_r+0x464>
    924a:	2500      	movs	r5, #0
    924c:	6465      	str	r5, [r4, #68]	; 0x44
    924e:	4629      	mov	r1, r5
    9250:	4620      	mov	r0, r4
    9252:	f7fe fdc5 	bl	7de0 <_Balloc>
    9256:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    925a:	2301      	movs	r3, #1
    925c:	9008      	str	r0, [sp, #32]
    925e:	46a8      	mov	r8, r5
    9260:	6420      	str	r0, [r4, #64]	; 0x40
    9262:	970d      	str	r7, [sp, #52]	; 0x34
    9264:	9309      	str	r3, [sp, #36]	; 0x24
    9266:	f7ff bac0 	b.w	87ea <_dtoa_r+0x1fa>
    926a:	bf00      	nop
    926c:	200002e8 	.word	0x200002e8
    9270:	200002c0 	.word	0x200002c0
    9274:	00000000 	.word	0x00000000

00009278 <_svfprintf_r>:
    9278:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    927c:	ed2d 8b06 	vpush	{d8-d10}
    9280:	b0b9      	sub	sp, #228	; 0xe4
    9282:	460c      	mov	r4, r1
    9284:	9103      	str	r1, [sp, #12]
    9286:	4692      	mov	sl, r2
    9288:	9309      	str	r3, [sp, #36]	; 0x24
    928a:	9005      	str	r0, [sp, #20]
    928c:	f7fe fd44 	bl	7d18 <_localeconv_r>
    9290:	6803      	ldr	r3, [r0, #0]
    9292:	9310      	str	r3, [sp, #64]	; 0x40
    9294:	4618      	mov	r0, r3
    9296:	f7fe fa53 	bl	7740 <strlen>
    929a:	89a3      	ldrh	r3, [r4, #12]
    929c:	900f      	str	r0, [sp, #60]	; 0x3c
    929e:	0619      	lsls	r1, r3, #24
    92a0:	d503      	bpl.n	92aa <_svfprintf_r+0x32>
    92a2:	6923      	ldr	r3, [r4, #16]
    92a4:	2b00      	cmp	r3, #0
    92a6:	f001 807d 	beq.w	a3a4 <_svfprintf_r+0x112c>
    92aa:	2300      	movs	r3, #0
    92ac:	ed9f 8ba4 	vldr	d8, [pc, #656]	; 9540 <_svfprintf_r+0x2c8>
    92b0:	ed9f 9ba5 	vldr	d9, [pc, #660]	; 9548 <_svfprintf_r+0x2d0>
    92b4:	930d      	str	r3, [sp, #52]	; 0x34
    92b6:	931d      	str	r3, [sp, #116]	; 0x74
    92b8:	931c      	str	r3, [sp, #112]	; 0x70
    92ba:	9311      	str	r3, [sp, #68]	; 0x44
    92bc:	9306      	str	r3, [sp, #24]
    92be:	ab28      	add	r3, sp, #160	; 0xa0
    92c0:	931b      	str	r3, [sp, #108]	; 0x6c
    92c2:	4699      	mov	r9, r3
    92c4:	f89a 3000 	ldrb.w	r3, [sl]
    92c8:	4654      	mov	r4, sl
    92ca:	b1eb      	cbz	r3, 9308 <_svfprintf_r+0x90>
    92cc:	2b25      	cmp	r3, #37	; 0x25
    92ce:	d102      	bne.n	92d6 <_svfprintf_r+0x5e>
    92d0:	e01a      	b.n	9308 <_svfprintf_r+0x90>
    92d2:	2b25      	cmp	r3, #37	; 0x25
    92d4:	d003      	beq.n	92de <_svfprintf_r+0x66>
    92d6:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    92da:	2b00      	cmp	r3, #0
    92dc:	d1f9      	bne.n	92d2 <_svfprintf_r+0x5a>
    92de:	ebca 0504 	rsb	r5, sl, r4
    92e2:	b18d      	cbz	r5, 9308 <_svfprintf_r+0x90>
    92e4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    92e6:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    92e8:	f8c9 a000 	str.w	sl, [r9]
    92ec:	3301      	adds	r3, #1
    92ee:	442a      	add	r2, r5
    92f0:	2b07      	cmp	r3, #7
    92f2:	f8c9 5004 	str.w	r5, [r9, #4]
    92f6:	921d      	str	r2, [sp, #116]	; 0x74
    92f8:	931c      	str	r3, [sp, #112]	; 0x70
    92fa:	f300 80a3 	bgt.w	9444 <_svfprintf_r+0x1cc>
    92fe:	f109 0908 	add.w	r9, r9, #8
    9302:	9b06      	ldr	r3, [sp, #24]
    9304:	442b      	add	r3, r5
    9306:	9306      	str	r3, [sp, #24]
    9308:	7823      	ldrb	r3, [r4, #0]
    930a:	2b00      	cmp	r3, #0
    930c:	f000 80a3 	beq.w	9456 <_svfprintf_r+0x1de>
    9310:	2300      	movs	r3, #0
    9312:	461a      	mov	r2, r3
    9314:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9318:	4619      	mov	r1, r3
    931a:	9307      	str	r3, [sp, #28]
    931c:	469b      	mov	fp, r3
    931e:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    9322:	7863      	ldrb	r3, [r4, #1]
    9324:	f104 0a01 	add.w	sl, r4, #1
    9328:	4645      	mov	r5, r8
    932a:	f10a 0a01 	add.w	sl, sl, #1
    932e:	f1a3 0020 	sub.w	r0, r3, #32
    9332:	2858      	cmp	r0, #88	; 0x58
    9334:	f200 83f8 	bhi.w	9b28 <_svfprintf_r+0x8b0>
    9338:	e8df f010 	tbh	[pc, r0, lsl #1]
    933c:	03f60363 	.word	0x03f60363
    9340:	036b03f6 	.word	0x036b03f6
    9344:	03f603f6 	.word	0x03f603f6
    9348:	03f603f6 	.word	0x03f603f6
    934c:	03f603f6 	.word	0x03f603f6
    9350:	037e0370 	.word	0x037e0370
    9354:	005d03f6 	.word	0x005d03f6
    9358:	03f600df 	.word	0x03f600df
    935c:	010c00fb 	.word	0x010c00fb
    9360:	010c010c 	.word	0x010c010c
    9364:	010c010c 	.word	0x010c010c
    9368:	010c010c 	.word	0x010c010c
    936c:	010c010c 	.word	0x010c010c
    9370:	03f603f6 	.word	0x03f603f6
    9374:	03f603f6 	.word	0x03f603f6
    9378:	03f603f6 	.word	0x03f603f6
    937c:	03f603f6 	.word	0x03f603f6
    9380:	03f603f6 	.word	0x03f603f6
    9384:	015e011c 	.word	0x015e011c
    9388:	015e03f6 	.word	0x015e03f6
    938c:	03f603f6 	.word	0x03f603f6
    9390:	03f603f6 	.word	0x03f603f6
    9394:	03f602a1 	.word	0x03f602a1
    9398:	02a603f6 	.word	0x02a603f6
    939c:	03f603f6 	.word	0x03f603f6
    93a0:	03f603f6 	.word	0x03f603f6
    93a4:	02d803f6 	.word	0x02d803f6
    93a8:	03f603f6 	.word	0x03f603f6
    93ac:	03f60305 	.word	0x03f60305
    93b0:	03f603f6 	.word	0x03f603f6
    93b4:	03f603f6 	.word	0x03f603f6
    93b8:	03f603f6 	.word	0x03f603f6
    93bc:	03f603f6 	.word	0x03f603f6
    93c0:	034303f6 	.word	0x034303f6
    93c4:	015e0356 	.word	0x015e0356
    93c8:	015e015e 	.word	0x015e015e
    93cc:	0356035e 	.word	0x0356035e
    93d0:	03f603f6 	.word	0x03f603f6
    93d4:	03f603a4 	.word	0x03f603a4
    93d8:	00a203b1 	.word	0x00a203b1
    93dc:	03c30062 	.word	0x03c30062
    93e0:	03c803f6 	.word	0x03c803f6
    93e4:	038303f6 	.word	0x038303f6
    93e8:	03f603f6 	.word	0x03f603f6
    93ec:	038b      	.short	0x038b
    93ee:	9807      	ldr	r0, [sp, #28]
    93f0:	9309      	str	r3, [sp, #36]	; 0x24
    93f2:	4240      	negs	r0, r0
    93f4:	9007      	str	r0, [sp, #28]
    93f6:	f04b 0b04 	orr.w	fp, fp, #4
    93fa:	f89a 3000 	ldrb.w	r3, [sl]
    93fe:	e794      	b.n	932a <_svfprintf_r+0xb2>
    9400:	46a8      	mov	r8, r5
    9402:	9809      	ldr	r0, [sp, #36]	; 0x24
    9404:	2100      	movs	r1, #0
    9406:	2330      	movs	r3, #48	; 0x30
    9408:	2278      	movs	r2, #120	; 0x78
    940a:	4588      	cmp	r8, r1
    940c:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    9410:	6804      	ldr	r4, [r0, #0]
    9412:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    9416:	f100 0704 	add.w	r7, r0, #4
    941a:	f04f 0500 	mov.w	r5, #0
    941e:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    9422:	f04b 0302 	orr.w	r3, fp, #2
    9426:	f2c0 839c 	blt.w	9b62 <_svfprintf_r+0x8ea>
    942a:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    942e:	f043 0b02 	orr.w	fp, r3, #2
    9432:	ea54 0305 	orrs.w	r3, r4, r5
    9436:	9709      	str	r7, [sp, #36]	; 0x24
    9438:	f000 8369 	beq.w	9b0e <_svfprintf_r+0x896>
    943c:	460f      	mov	r7, r1
    943e:	920c      	str	r2, [sp, #48]	; 0x30
    9440:	4843      	ldr	r0, [pc, #268]	; (9550 <_svfprintf_r+0x2d8>)
    9442:	e2ae      	b.n	99a2 <_svfprintf_r+0x72a>
    9444:	aa1b      	add	r2, sp, #108	; 0x6c
    9446:	9903      	ldr	r1, [sp, #12]
    9448:	9805      	ldr	r0, [sp, #20]
    944a:	f001 f9cd 	bl	a7e8 <__ssprint_r>
    944e:	b948      	cbnz	r0, 9464 <_svfprintf_r+0x1ec>
    9450:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9454:	e755      	b.n	9302 <_svfprintf_r+0x8a>
    9456:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9458:	b123      	cbz	r3, 9464 <_svfprintf_r+0x1ec>
    945a:	9805      	ldr	r0, [sp, #20]
    945c:	9903      	ldr	r1, [sp, #12]
    945e:	aa1b      	add	r2, sp, #108	; 0x6c
    9460:	f001 f9c2 	bl	a7e8 <__ssprint_r>
    9464:	9b03      	ldr	r3, [sp, #12]
    9466:	899b      	ldrh	r3, [r3, #12]
    9468:	f013 0f40 	tst.w	r3, #64	; 0x40
    946c:	9b06      	ldr	r3, [sp, #24]
    946e:	bf18      	it	ne
    9470:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    9474:	4618      	mov	r0, r3
    9476:	b039      	add	sp, #228	; 0xe4
    9478:	ecbd 8b06 	vpop	{d8-d10}
    947c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9480:	930c      	str	r3, [sp, #48]	; 0x30
    9482:	46a8      	mov	r8, r5
    9484:	2a00      	cmp	r2, #0
    9486:	f041 819a 	bne.w	a7be <_svfprintf_r+0x1546>
    948a:	f01b 0320 	ands.w	r3, fp, #32
    948e:	f000 8206 	beq.w	989e <_svfprintf_r+0x626>
    9492:	9f09      	ldr	r7, [sp, #36]	; 0x24
    9494:	3707      	adds	r7, #7
    9496:	f027 0307 	bic.w	r3, r7, #7
    949a:	2700      	movs	r7, #0
    949c:	f103 0208 	add.w	r2, r3, #8
    94a0:	45b8      	cmp	r8, r7
    94a2:	9209      	str	r2, [sp, #36]	; 0x24
    94a4:	e9d3 4500 	ldrd	r4, r5, [r3]
    94a8:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    94ac:	f2c0 865e 	blt.w	a16c <_svfprintf_r+0xef4>
    94b0:	ea54 0305 	orrs.w	r3, r4, r5
    94b4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    94b8:	f000 834b 	beq.w	9b52 <_svfprintf_r+0x8da>
    94bc:	ae28      	add	r6, sp, #160	; 0xa0
    94be:	08e2      	lsrs	r2, r4, #3
    94c0:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
    94c4:	08e9      	lsrs	r1, r5, #3
    94c6:	f004 0307 	and.w	r3, r4, #7
    94ca:	460d      	mov	r5, r1
    94cc:	4614      	mov	r4, r2
    94ce:	3330      	adds	r3, #48	; 0x30
    94d0:	ea54 0205 	orrs.w	r2, r4, r5
    94d4:	f806 3d01 	strb.w	r3, [r6, #-1]!
    94d8:	d1f1      	bne.n	94be <_svfprintf_r+0x246>
    94da:	f01b 0f01 	tst.w	fp, #1
    94de:	f000 8227 	beq.w	9930 <_svfprintf_r+0x6b8>
    94e2:	2b30      	cmp	r3, #48	; 0x30
    94e4:	f000 8224 	beq.w	9930 <_svfprintf_r+0x6b8>
    94e8:	2230      	movs	r2, #48	; 0x30
    94ea:	1e73      	subs	r3, r6, #1
    94ec:	f806 2c01 	strb.w	r2, [r6, #-1]
    94f0:	aa28      	add	r2, sp, #160	; 0xa0
    94f2:	1ad2      	subs	r2, r2, r3
    94f4:	9208      	str	r2, [sp, #32]
    94f6:	461e      	mov	r6, r3
    94f8:	e21d      	b.n	9936 <_svfprintf_r+0x6be>
    94fa:	f89a 3000 	ldrb.w	r3, [sl]
    94fe:	2b2a      	cmp	r3, #42	; 0x2a
    9500:	f10a 0401 	add.w	r4, sl, #1
    9504:	f001 812f 	beq.w	a766 <_svfprintf_r+0x14ee>
    9508:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    950c:	2809      	cmp	r0, #9
    950e:	bf98      	it	ls
    9510:	2500      	movls	r5, #0
    9512:	f201 80d5 	bhi.w	a6c0 <_svfprintf_r+0x1448>
    9516:	f814 3b01 	ldrb.w	r3, [r4], #1
    951a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    951e:	eb00 0545 	add.w	r5, r0, r5, lsl #1
    9522:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    9526:	2809      	cmp	r0, #9
    9528:	d9f5      	bls.n	9516 <_svfprintf_r+0x29e>
    952a:	ea45 75e5 	orr.w	r5, r5, r5, asr #31
    952e:	46a2      	mov	sl, r4
    9530:	e6fd      	b.n	932e <_svfprintf_r+0xb6>
    9532:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
    9536:	f89a 3000 	ldrb.w	r3, [sl]
    953a:	e6f6      	b.n	932a <_svfprintf_r+0xb2>
    953c:	f3af 8000 	nop.w
	...
    9548:	ffffffff 	.word	0xffffffff
    954c:	7fefffff 	.word	0x7fefffff
    9550:	20000e70 	.word	0x20000e70
    9554:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    9558:	2300      	movs	r3, #0
    955a:	461c      	mov	r4, r3
    955c:	f81a 3b01 	ldrb.w	r3, [sl], #1
    9560:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    9564:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    9568:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    956c:	2809      	cmp	r0, #9
    956e:	d9f5      	bls.n	955c <_svfprintf_r+0x2e4>
    9570:	9407      	str	r4, [sp, #28]
    9572:	e6dc      	b.n	932e <_svfprintf_r+0xb6>
    9574:	930c      	str	r3, [sp, #48]	; 0x30
    9576:	46a8      	mov	r8, r5
    9578:	2a00      	cmp	r2, #0
    957a:	f041 812c 	bne.w	a7d6 <_svfprintf_r+0x155e>
    957e:	f04b 0b10 	orr.w	fp, fp, #16
    9582:	f01b 0f20 	tst.w	fp, #32
    9586:	f000 8503 	beq.w	9f90 <_svfprintf_r+0xd18>
    958a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    958c:	3707      	adds	r7, #7
    958e:	f027 0707 	bic.w	r7, r7, #7
    9592:	e9d7 2300 	ldrd	r2, r3, [r7]
    9596:	f107 0108 	add.w	r1, r7, #8
    959a:	9109      	str	r1, [sp, #36]	; 0x24
    959c:	4614      	mov	r4, r2
    959e:	461d      	mov	r5, r3
    95a0:	2a00      	cmp	r2, #0
    95a2:	f173 0300 	sbcs.w	r3, r3, #0
    95a6:	f2c0 8537 	blt.w	a018 <_svfprintf_r+0xda0>
    95aa:	f1b8 0f00 	cmp.w	r8, #0
    95ae:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    95b2:	f2c0 81b5 	blt.w	9920 <_svfprintf_r+0x6a8>
    95b6:	ea54 0305 	orrs.w	r3, r4, r5
    95ba:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    95be:	f000 83f6 	beq.w	9dae <_svfprintf_r+0xb36>
    95c2:	2d00      	cmp	r5, #0
    95c4:	bf08      	it	eq
    95c6:	2c0a      	cmpeq	r4, #10
    95c8:	f0c0 81ae 	bcc.w	9928 <_svfprintf_r+0x6b0>
    95cc:	ae28      	add	r6, sp, #160	; 0xa0
    95ce:	4620      	mov	r0, r4
    95d0:	4629      	mov	r1, r5
    95d2:	220a      	movs	r2, #10
    95d4:	2300      	movs	r3, #0
    95d6:	f7fc fec1 	bl	635c <__aeabi_uldivmod>
    95da:	3230      	adds	r2, #48	; 0x30
    95dc:	f806 2d01 	strb.w	r2, [r6, #-1]!
    95e0:	4620      	mov	r0, r4
    95e2:	4629      	mov	r1, r5
    95e4:	2300      	movs	r3, #0
    95e6:	220a      	movs	r2, #10
    95e8:	f7fc feb8 	bl	635c <__aeabi_uldivmod>
    95ec:	4604      	mov	r4, r0
    95ee:	460d      	mov	r5, r1
    95f0:	ea54 0305 	orrs.w	r3, r4, r5
    95f4:	d1eb      	bne.n	95ce <_svfprintf_r+0x356>
    95f6:	e19b      	b.n	9930 <_svfprintf_r+0x6b8>
    95f8:	930c      	str	r3, [sp, #48]	; 0x30
    95fa:	46a8      	mov	r8, r5
    95fc:	2a00      	cmp	r2, #0
    95fe:	f041 80e6 	bne.w	a7ce <_svfprintf_r+0x1556>
    9602:	9f09      	ldr	r7, [sp, #36]	; 0x24
    9604:	f01b 0f08 	tst.w	fp, #8
    9608:	f107 0707 	add.w	r7, r7, #7
    960c:	f000 8640 	beq.w	a290 <_svfprintf_r+0x1018>
    9610:	f027 0307 	bic.w	r3, r7, #7
    9614:	ed93 8b00 	vldr	d8, [r3]
    9618:	f103 0208 	add.w	r2, r3, #8
    961c:	9209      	str	r2, [sp, #36]	; 0x24
    961e:	eeb0 7bc8 	vabs.f64	d7, d8
    9622:	eeb4 7b49 	vcmp.f64	d7, d9
    9626:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    962a:	f340 85bc 	ble.w	a1a6 <_svfprintf_r+0xf2e>
    962e:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
    9632:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9636:	f100 87ca 	bmi.w	a5ce <_svfprintf_r+0x1356>
    963a:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    963e:	4ea7      	ldr	r6, [pc, #668]	; (98dc <_svfprintf_r+0x664>)
    9640:	4ba7      	ldr	r3, [pc, #668]	; (98e0 <_svfprintf_r+0x668>)
    9642:	990c      	ldr	r1, [sp, #48]	; 0x30
    9644:	2203      	movs	r2, #3
    9646:	f04f 0800 	mov.w	r8, #0
    964a:	9204      	str	r2, [sp, #16]
    964c:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9650:	2947      	cmp	r1, #71	; 0x47
    9652:	bfd8      	it	le
    9654:	461e      	movle	r6, r3
    9656:	9208      	str	r2, [sp, #32]
    9658:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    965c:	b117      	cbz	r7, 9664 <_svfprintf_r+0x3ec>
    965e:	9b04      	ldr	r3, [sp, #16]
    9660:	3301      	adds	r3, #1
    9662:	9304      	str	r3, [sp, #16]
    9664:	f01b 0302 	ands.w	r3, fp, #2
    9668:	930a      	str	r3, [sp, #40]	; 0x28
    966a:	d002      	beq.n	9672 <_svfprintf_r+0x3fa>
    966c:	9b04      	ldr	r3, [sp, #16]
    966e:	3302      	adds	r3, #2
    9670:	9304      	str	r3, [sp, #16]
    9672:	f01b 0384 	ands.w	r3, fp, #132	; 0x84
    9676:	930b      	str	r3, [sp, #44]	; 0x2c
    9678:	f040 8280 	bne.w	9b7c <_svfprintf_r+0x904>
    967c:	9b07      	ldr	r3, [sp, #28]
    967e:	9a04      	ldr	r2, [sp, #16]
    9680:	1a9c      	subs	r4, r3, r2
    9682:	2c00      	cmp	r4, #0
    9684:	f340 827a 	ble.w	9b7c <_svfprintf_r+0x904>
    9688:	2c10      	cmp	r4, #16
    968a:	991d      	ldr	r1, [sp, #116]	; 0x74
    968c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    968e:	4f95      	ldr	r7, [pc, #596]	; (98e4 <_svfprintf_r+0x66c>)
    9690:	dd23      	ble.n	96da <_svfprintf_r+0x462>
    9692:	4648      	mov	r0, r9
    9694:	2510      	movs	r5, #16
    9696:	46c1      	mov	r9, r8
    9698:	46b0      	mov	r8, r6
    969a:	9e05      	ldr	r6, [sp, #20]
    969c:	e004      	b.n	96a8 <_svfprintf_r+0x430>
    969e:	3c10      	subs	r4, #16
    96a0:	2c10      	cmp	r4, #16
    96a2:	f100 0008 	add.w	r0, r0, #8
    96a6:	dd15      	ble.n	96d4 <_svfprintf_r+0x45c>
    96a8:	3201      	adds	r2, #1
    96aa:	3110      	adds	r1, #16
    96ac:	2a07      	cmp	r2, #7
    96ae:	911d      	str	r1, [sp, #116]	; 0x74
    96b0:	921c      	str	r2, [sp, #112]	; 0x70
    96b2:	6007      	str	r7, [r0, #0]
    96b4:	6045      	str	r5, [r0, #4]
    96b6:	ddf2      	ble.n	969e <_svfprintf_r+0x426>
    96b8:	aa1b      	add	r2, sp, #108	; 0x6c
    96ba:	9903      	ldr	r1, [sp, #12]
    96bc:	4630      	mov	r0, r6
    96be:	f001 f893 	bl	a7e8 <__ssprint_r>
    96c2:	2800      	cmp	r0, #0
    96c4:	f47f aece 	bne.w	9464 <_svfprintf_r+0x1ec>
    96c8:	3c10      	subs	r4, #16
    96ca:	2c10      	cmp	r4, #16
    96cc:	991d      	ldr	r1, [sp, #116]	; 0x74
    96ce:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    96d0:	a828      	add	r0, sp, #160	; 0xa0
    96d2:	dce9      	bgt.n	96a8 <_svfprintf_r+0x430>
    96d4:	4646      	mov	r6, r8
    96d6:	46c8      	mov	r8, r9
    96d8:	4681      	mov	r9, r0
    96da:	3201      	adds	r2, #1
    96dc:	1863      	adds	r3, r4, r1
    96de:	2a07      	cmp	r2, #7
    96e0:	931d      	str	r3, [sp, #116]	; 0x74
    96e2:	921c      	str	r2, [sp, #112]	; 0x70
    96e4:	f8c9 7000 	str.w	r7, [r9]
    96e8:	f8c9 4004 	str.w	r4, [r9, #4]
    96ec:	f300 83e2 	bgt.w	9eb4 <_svfprintf_r+0xc3c>
    96f0:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    96f4:	f109 0908 	add.w	r9, r9, #8
    96f8:	b177      	cbz	r7, 9718 <_svfprintf_r+0x4a0>
    96fa:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    96fc:	3201      	adds	r2, #1
    96fe:	3301      	adds	r3, #1
    9700:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
    9704:	2101      	movs	r1, #1
    9706:	2a07      	cmp	r2, #7
    9708:	931d      	str	r3, [sp, #116]	; 0x74
    970a:	921c      	str	r2, [sp, #112]	; 0x70
    970c:	e889 0003 	stmia.w	r9, {r0, r1}
    9710:	f300 835f 	bgt.w	9dd2 <_svfprintf_r+0xb5a>
    9714:	f109 0908 	add.w	r9, r9, #8
    9718:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    971a:	b16a      	cbz	r2, 9738 <_svfprintf_r+0x4c0>
    971c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    971e:	3201      	adds	r2, #1
    9720:	3302      	adds	r3, #2
    9722:	a814      	add	r0, sp, #80	; 0x50
    9724:	2102      	movs	r1, #2
    9726:	2a07      	cmp	r2, #7
    9728:	931d      	str	r3, [sp, #116]	; 0x74
    972a:	921c      	str	r2, [sp, #112]	; 0x70
    972c:	e889 0003 	stmia.w	r9, {r0, r1}
    9730:	f300 835b 	bgt.w	9dea <_svfprintf_r+0xb72>
    9734:	f109 0908 	add.w	r9, r9, #8
    9738:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    973a:	2a80      	cmp	r2, #128	; 0x80
    973c:	f000 827e 	beq.w	9c3c <_svfprintf_r+0x9c4>
    9740:	9a08      	ldr	r2, [sp, #32]
    9742:	ebc2 0408 	rsb	r4, r2, r8
    9746:	2c00      	cmp	r4, #0
    9748:	dd34      	ble.n	97b4 <_svfprintf_r+0x53c>
    974a:	2c10      	cmp	r4, #16
    974c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    974e:	4f66      	ldr	r7, [pc, #408]	; (98e8 <_svfprintf_r+0x670>)
    9750:	dd23      	ble.n	979a <_svfprintf_r+0x522>
    9752:	4649      	mov	r1, r9
    9754:	f04f 0810 	mov.w	r8, #16
    9758:	46b1      	mov	r9, r6
    975a:	9d05      	ldr	r5, [sp, #20]
    975c:	9e03      	ldr	r6, [sp, #12]
    975e:	e004      	b.n	976a <_svfprintf_r+0x4f2>
    9760:	3c10      	subs	r4, #16
    9762:	2c10      	cmp	r4, #16
    9764:	f101 0108 	add.w	r1, r1, #8
    9768:	dd15      	ble.n	9796 <_svfprintf_r+0x51e>
    976a:	3201      	adds	r2, #1
    976c:	3310      	adds	r3, #16
    976e:	2a07      	cmp	r2, #7
    9770:	931d      	str	r3, [sp, #116]	; 0x74
    9772:	921c      	str	r2, [sp, #112]	; 0x70
    9774:	e881 0180 	stmia.w	r1, {r7, r8}
    9778:	ddf2      	ble.n	9760 <_svfprintf_r+0x4e8>
    977a:	aa1b      	add	r2, sp, #108	; 0x6c
    977c:	4631      	mov	r1, r6
    977e:	4628      	mov	r0, r5
    9780:	f001 f832 	bl	a7e8 <__ssprint_r>
    9784:	2800      	cmp	r0, #0
    9786:	f47f ae6d 	bne.w	9464 <_svfprintf_r+0x1ec>
    978a:	3c10      	subs	r4, #16
    978c:	2c10      	cmp	r4, #16
    978e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9790:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9792:	a928      	add	r1, sp, #160	; 0xa0
    9794:	dce9      	bgt.n	976a <_svfprintf_r+0x4f2>
    9796:	464e      	mov	r6, r9
    9798:	4689      	mov	r9, r1
    979a:	3201      	adds	r2, #1
    979c:	4423      	add	r3, r4
    979e:	2a07      	cmp	r2, #7
    97a0:	931d      	str	r3, [sp, #116]	; 0x74
    97a2:	921c      	str	r2, [sp, #112]	; 0x70
    97a4:	f8c9 7000 	str.w	r7, [r9]
    97a8:	f8c9 4004 	str.w	r4, [r9, #4]
    97ac:	f300 8305 	bgt.w	9dba <_svfprintf_r+0xb42>
    97b0:	f109 0908 	add.w	r9, r9, #8
    97b4:	f41b 7f80 	tst.w	fp, #256	; 0x100
    97b8:	f040 81e2 	bne.w	9b80 <_svfprintf_r+0x908>
    97bc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    97be:	9808      	ldr	r0, [sp, #32]
    97c0:	f8c9 6000 	str.w	r6, [r9]
    97c4:	3201      	adds	r2, #1
    97c6:	4403      	add	r3, r0
    97c8:	2a07      	cmp	r2, #7
    97ca:	931d      	str	r3, [sp, #116]	; 0x74
    97cc:	f8c9 0004 	str.w	r0, [r9, #4]
    97d0:	921c      	str	r2, [sp, #112]	; 0x70
    97d2:	f300 82c2 	bgt.w	9d5a <_svfprintf_r+0xae2>
    97d6:	f109 0908 	add.w	r9, r9, #8
    97da:	f01b 0f04 	tst.w	fp, #4
    97de:	d03e      	beq.n	985e <_svfprintf_r+0x5e6>
    97e0:	9a07      	ldr	r2, [sp, #28]
    97e2:	9904      	ldr	r1, [sp, #16]
    97e4:	1a54      	subs	r4, r2, r1
    97e6:	2c00      	cmp	r4, #0
    97e8:	dd39      	ble.n	985e <_svfprintf_r+0x5e6>
    97ea:	2c10      	cmp	r4, #16
    97ec:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    97ee:	4f3d      	ldr	r7, [pc, #244]	; (98e4 <_svfprintf_r+0x66c>)
    97f0:	dd22      	ble.n	9838 <_svfprintf_r+0x5c0>
    97f2:	2510      	movs	r5, #16
    97f4:	9e05      	ldr	r6, [sp, #20]
    97f6:	f8dd 800c 	ldr.w	r8, [sp, #12]
    97fa:	e004      	b.n	9806 <_svfprintf_r+0x58e>
    97fc:	3c10      	subs	r4, #16
    97fe:	2c10      	cmp	r4, #16
    9800:	f109 0908 	add.w	r9, r9, #8
    9804:	dd18      	ble.n	9838 <_svfprintf_r+0x5c0>
    9806:	3201      	adds	r2, #1
    9808:	3310      	adds	r3, #16
    980a:	2a07      	cmp	r2, #7
    980c:	931d      	str	r3, [sp, #116]	; 0x74
    980e:	921c      	str	r2, [sp, #112]	; 0x70
    9810:	f8c9 7000 	str.w	r7, [r9]
    9814:	f8c9 5004 	str.w	r5, [r9, #4]
    9818:	ddf0      	ble.n	97fc <_svfprintf_r+0x584>
    981a:	aa1b      	add	r2, sp, #108	; 0x6c
    981c:	4641      	mov	r1, r8
    981e:	4630      	mov	r0, r6
    9820:	f000 ffe2 	bl	a7e8 <__ssprint_r>
    9824:	2800      	cmp	r0, #0
    9826:	f47f ae1d 	bne.w	9464 <_svfprintf_r+0x1ec>
    982a:	3c10      	subs	r4, #16
    982c:	2c10      	cmp	r4, #16
    982e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9830:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9832:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9836:	dce6      	bgt.n	9806 <_svfprintf_r+0x58e>
    9838:	3201      	adds	r2, #1
    983a:	4423      	add	r3, r4
    983c:	2a07      	cmp	r2, #7
    983e:	931d      	str	r3, [sp, #116]	; 0x74
    9840:	921c      	str	r2, [sp, #112]	; 0x70
    9842:	f8c9 7000 	str.w	r7, [r9]
    9846:	f8c9 4004 	str.w	r4, [r9, #4]
    984a:	dd08      	ble.n	985e <_svfprintf_r+0x5e6>
    984c:	aa1b      	add	r2, sp, #108	; 0x6c
    984e:	9903      	ldr	r1, [sp, #12]
    9850:	9805      	ldr	r0, [sp, #20]
    9852:	f000 ffc9 	bl	a7e8 <__ssprint_r>
    9856:	2800      	cmp	r0, #0
    9858:	f47f ae04 	bne.w	9464 <_svfprintf_r+0x1ec>
    985c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    985e:	9a06      	ldr	r2, [sp, #24]
    9860:	9907      	ldr	r1, [sp, #28]
    9862:	9804      	ldr	r0, [sp, #16]
    9864:	4281      	cmp	r1, r0
    9866:	bfac      	ite	ge
    9868:	1852      	addge	r2, r2, r1
    986a:	1812      	addlt	r2, r2, r0
    986c:	9206      	str	r2, [sp, #24]
    986e:	2b00      	cmp	r3, #0
    9870:	f040 827f 	bne.w	9d72 <_svfprintf_r+0xafa>
    9874:	2300      	movs	r3, #0
    9876:	931c      	str	r3, [sp, #112]	; 0x70
    9878:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    987c:	e522      	b.n	92c4 <_svfprintf_r+0x4c>
    987e:	f04b 0b08 	orr.w	fp, fp, #8
    9882:	f89a 3000 	ldrb.w	r3, [sl]
    9886:	e550      	b.n	932a <_svfprintf_r+0xb2>
    9888:	930c      	str	r3, [sp, #48]	; 0x30
    988a:	46a8      	mov	r8, r5
    988c:	2a00      	cmp	r2, #0
    988e:	f040 879a 	bne.w	a7c6 <_svfprintf_r+0x154e>
    9892:	f04b 0b10 	orr.w	fp, fp, #16
    9896:	f01b 0320 	ands.w	r3, fp, #32
    989a:	f47f adfa 	bne.w	9492 <_svfprintf_r+0x21a>
    989e:	f01b 0210 	ands.w	r2, fp, #16
    98a2:	f040 8391 	bne.w	9fc8 <_svfprintf_r+0xd50>
    98a6:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    98aa:	f000 838d 	beq.w	9fc8 <_svfprintf_r+0xd50>
    98ae:	9909      	ldr	r1, [sp, #36]	; 0x24
    98b0:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    98b4:	460b      	mov	r3, r1
    98b6:	f1b8 0f00 	cmp.w	r8, #0
    98ba:	f103 0304 	add.w	r3, r3, #4
    98be:	880c      	ldrh	r4, [r1, #0]
    98c0:	f04f 0500 	mov.w	r5, #0
    98c4:	f2c0 85ab 	blt.w	a41e <_svfprintf_r+0x11a6>
    98c8:	ea54 0105 	orrs.w	r1, r4, r5
    98cc:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    98d0:	9309      	str	r3, [sp, #36]	; 0x24
    98d2:	f000 813e 	beq.w	9b52 <_svfprintf_r+0x8da>
    98d6:	4617      	mov	r7, r2
    98d8:	e5f0      	b.n	94bc <_svfprintf_r+0x244>
    98da:	bf00      	nop
    98dc:	20000e50 	.word	0x20000e50
    98e0:	20000e4c 	.word	0x20000e4c
    98e4:	200006d4 	.word	0x200006d4
    98e8:	20001030 	.word	0x20001030
    98ec:	930c      	str	r3, [sp, #48]	; 0x30
    98ee:	46a8      	mov	r8, r5
    98f0:	2a00      	cmp	r2, #0
    98f2:	f040 8759 	bne.w	a7a8 <_svfprintf_r+0x1530>
    98f6:	f04b 0b10 	orr.w	fp, fp, #16
    98fa:	f01b 0320 	ands.w	r3, fp, #32
    98fe:	f000 82e7 	beq.w	9ed0 <_svfprintf_r+0xc58>
    9902:	9f09      	ldr	r7, [sp, #36]	; 0x24
    9904:	3707      	adds	r7, #7
    9906:	f027 0307 	bic.w	r3, r7, #7
    990a:	2700      	movs	r7, #0
    990c:	f103 0208 	add.w	r2, r3, #8
    9910:	45b8      	cmp	r8, r7
    9912:	9209      	str	r2, [sp, #36]	; 0x24
    9914:	e9d3 4500 	ldrd	r4, r5, [r3]
    9918:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    991c:	f6bf ae4b 	bge.w	95b6 <_svfprintf_r+0x33e>
    9920:	ea54 0305 	orrs.w	r3, r4, r5
    9924:	f47f ae4d 	bne.w	95c2 <_svfprintf_r+0x34a>
    9928:	ae38      	add	r6, sp, #224	; 0xe0
    992a:	3430      	adds	r4, #48	; 0x30
    992c:	f806 4d41 	strb.w	r4, [r6, #-65]!
    9930:	ab28      	add	r3, sp, #160	; 0xa0
    9932:	1b9b      	subs	r3, r3, r6
    9934:	9308      	str	r3, [sp, #32]
    9936:	9b08      	ldr	r3, [sp, #32]
    9938:	4543      	cmp	r3, r8
    993a:	bfb8      	it	lt
    993c:	4643      	movlt	r3, r8
    993e:	9304      	str	r3, [sp, #16]
    9940:	2300      	movs	r3, #0
    9942:	930e      	str	r3, [sp, #56]	; 0x38
    9944:	e68a      	b.n	965c <_svfprintf_r+0x3e4>
    9946:	930c      	str	r3, [sp, #48]	; 0x30
    9948:	46a8      	mov	r8, r5
    994a:	2a00      	cmp	r2, #0
    994c:	f040 8728 	bne.w	a7a0 <_svfprintf_r+0x1528>
    9950:	f01b 0f20 	tst.w	fp, #32
    9954:	48c2      	ldr	r0, [pc, #776]	; (9c60 <_svfprintf_r+0x9e8>)
    9956:	f000 8086 	beq.w	9a66 <_svfprintf_r+0x7ee>
    995a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    995c:	3707      	adds	r7, #7
    995e:	f027 0307 	bic.w	r3, r7, #7
    9962:	e9d3 4500 	ldrd	r4, r5, [r3]
    9966:	f103 0208 	add.w	r2, r3, #8
    996a:	9209      	str	r2, [sp, #36]	; 0x24
    996c:	f01b 0701 	ands.w	r7, fp, #1
    9970:	f000 8247 	beq.w	9e02 <_svfprintf_r+0xb8a>
    9974:	ea54 0305 	orrs.w	r3, r4, r5
    9978:	f000 84a3 	beq.w	a2c2 <_svfprintf_r+0x104a>
    997c:	2700      	movs	r7, #0
    997e:	2330      	movs	r3, #48	; 0x30
    9980:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    9984:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    9988:	45b8      	cmp	r8, r7
    998a:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    998e:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9992:	f04b 0302 	orr.w	r3, fp, #2
    9996:	f2c0 8617 	blt.w	a5c8 <_svfprintf_r+0x1350>
    999a:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    999e:	f043 0b02 	orr.w	fp, r3, #2
    99a2:	ae28      	add	r6, sp, #160	; 0xa0
    99a4:	0923      	lsrs	r3, r4, #4
    99a6:	f004 010f 	and.w	r1, r4, #15
    99aa:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
    99ae:	092a      	lsrs	r2, r5, #4
    99b0:	461c      	mov	r4, r3
    99b2:	4615      	mov	r5, r2
    99b4:	5c43      	ldrb	r3, [r0, r1]
    99b6:	f806 3d01 	strb.w	r3, [r6, #-1]!
    99ba:	ea54 0305 	orrs.w	r3, r4, r5
    99be:	d1f1      	bne.n	99a4 <_svfprintf_r+0x72c>
    99c0:	e7b6      	b.n	9930 <_svfprintf_r+0x6b8>
    99c2:	9909      	ldr	r1, [sp, #36]	; 0x24
    99c4:	930c      	str	r3, [sp, #48]	; 0x30
    99c6:	680a      	ldr	r2, [r1, #0]
    99c8:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    99cc:	2300      	movs	r3, #0
    99ce:	460a      	mov	r2, r1
    99d0:	461f      	mov	r7, r3
    99d2:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    99d6:	3204      	adds	r2, #4
    99d8:	2301      	movs	r3, #1
    99da:	9304      	str	r3, [sp, #16]
    99dc:	46b8      	mov	r8, r7
    99de:	970e      	str	r7, [sp, #56]	; 0x38
    99e0:	9209      	str	r2, [sp, #36]	; 0x24
    99e2:	9308      	str	r3, [sp, #32]
    99e4:	ae1e      	add	r6, sp, #120	; 0x78
    99e6:	e63d      	b.n	9664 <_svfprintf_r+0x3ec>
    99e8:	930c      	str	r3, [sp, #48]	; 0x30
    99ea:	46a8      	mov	r8, r5
    99ec:	2a00      	cmp	r2, #0
    99ee:	f43f adc8 	beq.w	9582 <_svfprintf_r+0x30a>
    99f2:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    99f6:	e5c4      	b.n	9582 <_svfprintf_r+0x30a>
    99f8:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
    99fc:	f89a 3000 	ldrb.w	r3, [sl]
    9a00:	e493      	b.n	932a <_svfprintf_r+0xb2>
    9a02:	f89a 3000 	ldrb.w	r3, [sl]
    9a06:	2900      	cmp	r1, #0
    9a08:	f47f ac8f 	bne.w	932a <_svfprintf_r+0xb2>
    9a0c:	2201      	movs	r2, #1
    9a0e:	2120      	movs	r1, #32
    9a10:	e48b      	b.n	932a <_svfprintf_r+0xb2>
    9a12:	f04b 0b01 	orr.w	fp, fp, #1
    9a16:	f89a 3000 	ldrb.w	r3, [sl]
    9a1a:	e486      	b.n	932a <_svfprintf_r+0xb2>
    9a1c:	9c09      	ldr	r4, [sp, #36]	; 0x24
    9a1e:	6823      	ldr	r3, [r4, #0]
    9a20:	9307      	str	r3, [sp, #28]
    9a22:	4618      	mov	r0, r3
    9a24:	2800      	cmp	r0, #0
    9a26:	4623      	mov	r3, r4
    9a28:	f103 0304 	add.w	r3, r3, #4
    9a2c:	f6ff acdf 	blt.w	93ee <_svfprintf_r+0x176>
    9a30:	9309      	str	r3, [sp, #36]	; 0x24
    9a32:	f89a 3000 	ldrb.w	r3, [sl]
    9a36:	e478      	b.n	932a <_svfprintf_r+0xb2>
    9a38:	f89a 3000 	ldrb.w	r3, [sl]
    9a3c:	2201      	movs	r2, #1
    9a3e:	212b      	movs	r1, #43	; 0x2b
    9a40:	e473      	b.n	932a <_svfprintf_r+0xb2>
    9a42:	930c      	str	r3, [sp, #48]	; 0x30
    9a44:	46a8      	mov	r8, r5
    9a46:	2a00      	cmp	r2, #0
    9a48:	f43f af57 	beq.w	98fa <_svfprintf_r+0x682>
    9a4c:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    9a50:	e753      	b.n	98fa <_svfprintf_r+0x682>
    9a52:	930c      	str	r3, [sp, #48]	; 0x30
    9a54:	46a8      	mov	r8, r5
    9a56:	2a00      	cmp	r2, #0
    9a58:	f040 86aa 	bne.w	a7b0 <_svfprintf_r+0x1538>
    9a5c:	f01b 0f20 	tst.w	fp, #32
    9a60:	4880      	ldr	r0, [pc, #512]	; (9c64 <_svfprintf_r+0x9ec>)
    9a62:	f47f af7a 	bne.w	995a <_svfprintf_r+0x6e2>
    9a66:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9a68:	f01b 0f10 	tst.w	fp, #16
    9a6c:	4613      	mov	r3, r2
    9a6e:	f040 82c1 	bne.w	9ff4 <_svfprintf_r+0xd7c>
    9a72:	f01b 0f40 	tst.w	fp, #64	; 0x40
    9a76:	f000 82bd 	beq.w	9ff4 <_svfprintf_r+0xd7c>
    9a7a:	3304      	adds	r3, #4
    9a7c:	8814      	ldrh	r4, [r2, #0]
    9a7e:	9309      	str	r3, [sp, #36]	; 0x24
    9a80:	2500      	movs	r5, #0
    9a82:	e773      	b.n	996c <_svfprintf_r+0x6f4>
    9a84:	f89a 3000 	ldrb.w	r3, [sl]
    9a88:	2b6c      	cmp	r3, #108	; 0x6c
    9a8a:	bf03      	ittte	eq
    9a8c:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
    9a90:	f04b 0b20 	orreq.w	fp, fp, #32
    9a94:	f10a 0a01 	addeq.w	sl, sl, #1
    9a98:	f04b 0b10 	orrne.w	fp, fp, #16
    9a9c:	e445      	b.n	932a <_svfprintf_r+0xb2>
    9a9e:	2a00      	cmp	r2, #0
    9aa0:	f040 866f 	bne.w	a782 <_svfprintf_r+0x150a>
    9aa4:	f01b 0f20 	tst.w	fp, #32
    9aa8:	f000 8366 	beq.w	a178 <_svfprintf_r+0xf00>
    9aac:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9aae:	9906      	ldr	r1, [sp, #24]
    9ab0:	6813      	ldr	r3, [r2, #0]
    9ab2:	17cd      	asrs	r5, r1, #31
    9ab4:	4608      	mov	r0, r1
    9ab6:	3204      	adds	r2, #4
    9ab8:	4629      	mov	r1, r5
    9aba:	9209      	str	r2, [sp, #36]	; 0x24
    9abc:	e9c3 0100 	strd	r0, r1, [r3]
    9ac0:	e400      	b.n	92c4 <_svfprintf_r+0x4c>
    9ac2:	f04b 0b20 	orr.w	fp, fp, #32
    9ac6:	f89a 3000 	ldrb.w	r3, [sl]
    9aca:	e42e      	b.n	932a <_svfprintf_r+0xb2>
    9acc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9ace:	930c      	str	r3, [sp, #48]	; 0x30
    9ad0:	6816      	ldr	r6, [r2, #0]
    9ad2:	2400      	movs	r4, #0
    9ad4:	f88d 404f 	strb.w	r4, [sp, #79]	; 0x4f
    9ad8:	1d17      	adds	r7, r2, #4
    9ada:	2e00      	cmp	r6, #0
    9adc:	f000 8565 	beq.w	a5aa <_svfprintf_r+0x1332>
    9ae0:	2d00      	cmp	r5, #0
    9ae2:	f2c0 84a2 	blt.w	a42a <_svfprintf_r+0x11b2>
    9ae6:	462a      	mov	r2, r5
    9ae8:	4621      	mov	r1, r4
    9aea:	4630      	mov	r0, r6
    9aec:	f7fe f928 	bl	7d40 <memchr>
    9af0:	2800      	cmp	r0, #0
    9af2:	f000 85cc 	beq.w	a68e <_svfprintf_r+0x1416>
    9af6:	1b83      	subs	r3, r0, r6
    9af8:	9308      	str	r3, [sp, #32]
    9afa:	46a0      	mov	r8, r4
    9afc:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9b00:	9709      	str	r7, [sp, #36]	; 0x24
    9b02:	9304      	str	r3, [sp, #16]
    9b04:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    9b08:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9b0c:	e5a6      	b.n	965c <_svfprintf_r+0x3e4>
    9b0e:	4855      	ldr	r0, [pc, #340]	; (9c64 <_svfprintf_r+0x9ec>)
    9b10:	920c      	str	r2, [sp, #48]	; 0x30
    9b12:	f1b8 0f00 	cmp.w	r8, #0
    9b16:	f040 8184 	bne.w	9e22 <_svfprintf_r+0xbaa>
    9b1a:	4647      	mov	r7, r8
    9b1c:	f04f 0800 	mov.w	r8, #0
    9b20:	f8cd 8020 	str.w	r8, [sp, #32]
    9b24:	ae28      	add	r6, sp, #160	; 0xa0
    9b26:	e706      	b.n	9936 <_svfprintf_r+0x6be>
    9b28:	930c      	str	r3, [sp, #48]	; 0x30
    9b2a:	2a00      	cmp	r2, #0
    9b2c:	f040 862d 	bne.w	a78a <_svfprintf_r+0x1512>
    9b30:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9b32:	2a00      	cmp	r2, #0
    9b34:	f43f ac8f 	beq.w	9456 <_svfprintf_r+0x1de>
    9b38:	2300      	movs	r3, #0
    9b3a:	2101      	movs	r1, #1
    9b3c:	461f      	mov	r7, r3
    9b3e:	9104      	str	r1, [sp, #16]
    9b40:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    9b44:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9b48:	4698      	mov	r8, r3
    9b4a:	930e      	str	r3, [sp, #56]	; 0x38
    9b4c:	9108      	str	r1, [sp, #32]
    9b4e:	ae1e      	add	r6, sp, #120	; 0x78
    9b50:	e588      	b.n	9664 <_svfprintf_r+0x3ec>
    9b52:	f1b8 0f00 	cmp.w	r8, #0
    9b56:	f000 858b 	beq.w	a670 <_svfprintf_r+0x13f8>
    9b5a:	2700      	movs	r7, #0
    9b5c:	2400      	movs	r4, #0
    9b5e:	2500      	movs	r5, #0
    9b60:	e4ac      	b.n	94bc <_svfprintf_r+0x244>
    9b62:	4840      	ldr	r0, [pc, #256]	; (9c64 <_svfprintf_r+0x9ec>)
    9b64:	920c      	str	r2, [sp, #48]	; 0x30
    9b66:	469b      	mov	fp, r3
    9b68:	ea54 0305 	orrs.w	r3, r4, r5
    9b6c:	9709      	str	r7, [sp, #36]	; 0x24
    9b6e:	f04f 0700 	mov.w	r7, #0
    9b72:	f47f af16 	bne.w	99a2 <_svfprintf_r+0x72a>
    9b76:	2400      	movs	r4, #0
    9b78:	2500      	movs	r5, #0
    9b7a:	e712      	b.n	99a2 <_svfprintf_r+0x72a>
    9b7c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9b7e:	e5bb      	b.n	96f8 <_svfprintf_r+0x480>
    9b80:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9b82:	2a65      	cmp	r2, #101	; 0x65
    9b84:	f340 80a1 	ble.w	9cca <_svfprintf_r+0xa52>
    9b88:	eeb5 8b40 	vcmp.f64	d8, #0.0
    9b8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9b90:	f040 8149 	bne.w	9e26 <_svfprintf_r+0xbae>
    9b94:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9b96:	4934      	ldr	r1, [pc, #208]	; (9c68 <_svfprintf_r+0x9f0>)
    9b98:	f8c9 1000 	str.w	r1, [r9]
    9b9c:	3201      	adds	r2, #1
    9b9e:	3301      	adds	r3, #1
    9ba0:	2101      	movs	r1, #1
    9ba2:	2a07      	cmp	r2, #7
    9ba4:	931d      	str	r3, [sp, #116]	; 0x74
    9ba6:	921c      	str	r2, [sp, #112]	; 0x70
    9ba8:	f8c9 1004 	str.w	r1, [r9, #4]
    9bac:	f300 8392 	bgt.w	a2d4 <_svfprintf_r+0x105c>
    9bb0:	f109 0908 	add.w	r9, r9, #8
    9bb4:	9a15      	ldr	r2, [sp, #84]	; 0x54
    9bb6:	990d      	ldr	r1, [sp, #52]	; 0x34
    9bb8:	428a      	cmp	r2, r1
    9bba:	db03      	blt.n	9bc4 <_svfprintf_r+0x94c>
    9bbc:	f01b 0f01 	tst.w	fp, #1
    9bc0:	f43f ae0b 	beq.w	97da <_svfprintf_r+0x562>
    9bc4:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9bc6:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9bc8:	9910      	ldr	r1, [sp, #64]	; 0x40
    9bca:	f8c9 1000 	str.w	r1, [r9]
    9bce:	3201      	adds	r2, #1
    9bd0:	4403      	add	r3, r0
    9bd2:	2a07      	cmp	r2, #7
    9bd4:	931d      	str	r3, [sp, #116]	; 0x74
    9bd6:	f8c9 0004 	str.w	r0, [r9, #4]
    9bda:	921c      	str	r2, [sp, #112]	; 0x70
    9bdc:	f300 83d6 	bgt.w	a38c <_svfprintf_r+0x1114>
    9be0:	f109 0908 	add.w	r9, r9, #8
    9be4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9be6:	1e54      	subs	r4, r2, #1
    9be8:	2c00      	cmp	r4, #0
    9bea:	f77f adf6 	ble.w	97da <_svfprintf_r+0x562>
    9bee:	2c10      	cmp	r4, #16
    9bf0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9bf2:	4f1e      	ldr	r7, [pc, #120]	; (9c6c <_svfprintf_r+0x9f4>)
    9bf4:	f340 81dc 	ble.w	9fb0 <_svfprintf_r+0xd38>
    9bf8:	2510      	movs	r5, #16
    9bfa:	9e05      	ldr	r6, [sp, #20]
    9bfc:	f8dd 800c 	ldr.w	r8, [sp, #12]
    9c00:	e005      	b.n	9c0e <_svfprintf_r+0x996>
    9c02:	f109 0908 	add.w	r9, r9, #8
    9c06:	3c10      	subs	r4, #16
    9c08:	2c10      	cmp	r4, #16
    9c0a:	f340 81d1 	ble.w	9fb0 <_svfprintf_r+0xd38>
    9c0e:	3201      	adds	r2, #1
    9c10:	3310      	adds	r3, #16
    9c12:	2a07      	cmp	r2, #7
    9c14:	931d      	str	r3, [sp, #116]	; 0x74
    9c16:	921c      	str	r2, [sp, #112]	; 0x70
    9c18:	f8c9 7000 	str.w	r7, [r9]
    9c1c:	f8c9 5004 	str.w	r5, [r9, #4]
    9c20:	ddef      	ble.n	9c02 <_svfprintf_r+0x98a>
    9c22:	aa1b      	add	r2, sp, #108	; 0x6c
    9c24:	4641      	mov	r1, r8
    9c26:	4630      	mov	r0, r6
    9c28:	f000 fdde 	bl	a7e8 <__ssprint_r>
    9c2c:	2800      	cmp	r0, #0
    9c2e:	f47f ac19 	bne.w	9464 <_svfprintf_r+0x1ec>
    9c32:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9c34:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9c36:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9c3a:	e7e4      	b.n	9c06 <_svfprintf_r+0x98e>
    9c3c:	9a07      	ldr	r2, [sp, #28]
    9c3e:	9904      	ldr	r1, [sp, #16]
    9c40:	1a54      	subs	r4, r2, r1
    9c42:	2c00      	cmp	r4, #0
    9c44:	f77f ad7c 	ble.w	9740 <_svfprintf_r+0x4c8>
    9c48:	2c10      	cmp	r4, #16
    9c4a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9c4c:	4f07      	ldr	r7, [pc, #28]	; (9c6c <_svfprintf_r+0x9f4>)
    9c4e:	dd2e      	ble.n	9cae <_svfprintf_r+0xa36>
    9c50:	4649      	mov	r1, r9
    9c52:	2510      	movs	r5, #16
    9c54:	46c1      	mov	r9, r8
    9c56:	4618      	mov	r0, r3
    9c58:	46b0      	mov	r8, r6
    9c5a:	9e05      	ldr	r6, [sp, #20]
    9c5c:	e00d      	b.n	9c7a <_svfprintf_r+0xa02>
    9c5e:	bf00      	nop
    9c60:	20000e5c 	.word	0x20000e5c
    9c64:	20000e70 	.word	0x20000e70
    9c68:	20000e48 	.word	0x20000e48
    9c6c:	20001030 	.word	0x20001030
    9c70:	3c10      	subs	r4, #16
    9c72:	2c10      	cmp	r4, #16
    9c74:	f101 0108 	add.w	r1, r1, #8
    9c78:	dd15      	ble.n	9ca6 <_svfprintf_r+0xa2e>
    9c7a:	3201      	adds	r2, #1
    9c7c:	3010      	adds	r0, #16
    9c7e:	2a07      	cmp	r2, #7
    9c80:	901d      	str	r0, [sp, #116]	; 0x74
    9c82:	921c      	str	r2, [sp, #112]	; 0x70
    9c84:	600f      	str	r7, [r1, #0]
    9c86:	604d      	str	r5, [r1, #4]
    9c88:	ddf2      	ble.n	9c70 <_svfprintf_r+0x9f8>
    9c8a:	aa1b      	add	r2, sp, #108	; 0x6c
    9c8c:	9903      	ldr	r1, [sp, #12]
    9c8e:	4630      	mov	r0, r6
    9c90:	f000 fdaa 	bl	a7e8 <__ssprint_r>
    9c94:	2800      	cmp	r0, #0
    9c96:	f47f abe5 	bne.w	9464 <_svfprintf_r+0x1ec>
    9c9a:	3c10      	subs	r4, #16
    9c9c:	2c10      	cmp	r4, #16
    9c9e:	981d      	ldr	r0, [sp, #116]	; 0x74
    9ca0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9ca2:	a928      	add	r1, sp, #160	; 0xa0
    9ca4:	dce9      	bgt.n	9c7a <_svfprintf_r+0xa02>
    9ca6:	4646      	mov	r6, r8
    9ca8:	4603      	mov	r3, r0
    9caa:	46c8      	mov	r8, r9
    9cac:	4689      	mov	r9, r1
    9cae:	3201      	adds	r2, #1
    9cb0:	4423      	add	r3, r4
    9cb2:	2a07      	cmp	r2, #7
    9cb4:	931d      	str	r3, [sp, #116]	; 0x74
    9cb6:	921c      	str	r2, [sp, #112]	; 0x70
    9cb8:	f8c9 7000 	str.w	r7, [r9]
    9cbc:	f8c9 4004 	str.w	r4, [r9, #4]
    9cc0:	f300 8246 	bgt.w	a150 <_svfprintf_r+0xed8>
    9cc4:	f109 0908 	add.w	r9, r9, #8
    9cc8:	e53a      	b.n	9740 <_svfprintf_r+0x4c8>
    9cca:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9ccc:	f8c9 6000 	str.w	r6, [r9]
    9cd0:	2a01      	cmp	r2, #1
    9cd2:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9cd4:	f103 0301 	add.w	r3, r3, #1
    9cd8:	f102 0201 	add.w	r2, r2, #1
    9cdc:	f04f 0101 	mov.w	r1, #1
    9ce0:	931d      	str	r3, [sp, #116]	; 0x74
    9ce2:	921c      	str	r2, [sp, #112]	; 0x70
    9ce4:	f8c9 1004 	str.w	r1, [r9, #4]
    9ce8:	f340 8210 	ble.w	a10c <_svfprintf_r+0xe94>
    9cec:	2a07      	cmp	r2, #7
    9cee:	f300 8215 	bgt.w	a11c <_svfprintf_r+0xea4>
    9cf2:	f109 0908 	add.w	r9, r9, #8
    9cf6:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9cf8:	9910      	ldr	r1, [sp, #64]	; 0x40
    9cfa:	f8c9 1000 	str.w	r1, [r9]
    9cfe:	3201      	adds	r2, #1
    9d00:	4403      	add	r3, r0
    9d02:	2a07      	cmp	r2, #7
    9d04:	931d      	str	r3, [sp, #116]	; 0x74
    9d06:	921c      	str	r2, [sp, #112]	; 0x70
    9d08:	f8c9 0004 	str.w	r0, [r9, #4]
    9d0c:	f300 8213 	bgt.w	a136 <_svfprintf_r+0xebe>
    9d10:	f109 0908 	add.w	r9, r9, #8
    9d14:	eeb5 8b40 	vcmp.f64	d8, #0.0
    9d18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9d1c:	990d      	ldr	r1, [sp, #52]	; 0x34
    9d1e:	f000 80f5 	beq.w	9f0c <_svfprintf_r+0xc94>
    9d22:	3901      	subs	r1, #1
    9d24:	3201      	adds	r2, #1
    9d26:	3601      	adds	r6, #1
    9d28:	440b      	add	r3, r1
    9d2a:	2a07      	cmp	r2, #7
    9d2c:	f8c9 6000 	str.w	r6, [r9]
    9d30:	921c      	str	r2, [sp, #112]	; 0x70
    9d32:	931d      	str	r3, [sp, #116]	; 0x74
    9d34:	f8c9 1004 	str.w	r1, [r9, #4]
    9d38:	f300 811d 	bgt.w	9f76 <_svfprintf_r+0xcfe>
    9d3c:	f109 0908 	add.w	r9, r9, #8
    9d40:	9811      	ldr	r0, [sp, #68]	; 0x44
    9d42:	f8c9 0004 	str.w	r0, [r9, #4]
    9d46:	3201      	adds	r2, #1
    9d48:	4403      	add	r3, r0
    9d4a:	a917      	add	r1, sp, #92	; 0x5c
    9d4c:	2a07      	cmp	r2, #7
    9d4e:	931d      	str	r3, [sp, #116]	; 0x74
    9d50:	921c      	str	r2, [sp, #112]	; 0x70
    9d52:	f8c9 1000 	str.w	r1, [r9]
    9d56:	f77f ad3e 	ble.w	97d6 <_svfprintf_r+0x55e>
    9d5a:	aa1b      	add	r2, sp, #108	; 0x6c
    9d5c:	9903      	ldr	r1, [sp, #12]
    9d5e:	9805      	ldr	r0, [sp, #20]
    9d60:	f000 fd42 	bl	a7e8 <__ssprint_r>
    9d64:	2800      	cmp	r0, #0
    9d66:	f47f ab7d 	bne.w	9464 <_svfprintf_r+0x1ec>
    9d6a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9d6c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9d70:	e533      	b.n	97da <_svfprintf_r+0x562>
    9d72:	aa1b      	add	r2, sp, #108	; 0x6c
    9d74:	9903      	ldr	r1, [sp, #12]
    9d76:	9805      	ldr	r0, [sp, #20]
    9d78:	f000 fd36 	bl	a7e8 <__ssprint_r>
    9d7c:	2800      	cmp	r0, #0
    9d7e:	f43f ad79 	beq.w	9874 <_svfprintf_r+0x5fc>
    9d82:	f7ff bb6f 	b.w	9464 <_svfprintf_r+0x1ec>
    9d86:	9909      	ldr	r1, [sp, #36]	; 0x24
    9d88:	f1b8 0f00 	cmp.w	r8, #0
    9d8c:	680c      	ldr	r4, [r1, #0]
    9d8e:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9d92:	f101 0704 	add.w	r7, r1, #4
    9d96:	f04f 0500 	mov.w	r5, #0
    9d9a:	f2c0 8371 	blt.w	a480 <_svfprintf_r+0x1208>
    9d9e:	ea54 0205 	orrs.w	r2, r4, r5
    9da2:	9709      	str	r7, [sp, #36]	; 0x24
    9da4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9da8:	461f      	mov	r7, r3
    9daa:	f47f ac0a 	bne.w	95c2 <_svfprintf_r+0x34a>
    9dae:	f1b8 0f00 	cmp.w	r8, #0
    9db2:	f43f aeb3 	beq.w	9b1c <_svfprintf_r+0x8a4>
    9db6:	2400      	movs	r4, #0
    9db8:	e5b6      	b.n	9928 <_svfprintf_r+0x6b0>
    9dba:	aa1b      	add	r2, sp, #108	; 0x6c
    9dbc:	9903      	ldr	r1, [sp, #12]
    9dbe:	9805      	ldr	r0, [sp, #20]
    9dc0:	f000 fd12 	bl	a7e8 <__ssprint_r>
    9dc4:	2800      	cmp	r0, #0
    9dc6:	f47f ab4d 	bne.w	9464 <_svfprintf_r+0x1ec>
    9dca:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9dcc:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9dd0:	e4f0      	b.n	97b4 <_svfprintf_r+0x53c>
    9dd2:	aa1b      	add	r2, sp, #108	; 0x6c
    9dd4:	9903      	ldr	r1, [sp, #12]
    9dd6:	9805      	ldr	r0, [sp, #20]
    9dd8:	f000 fd06 	bl	a7e8 <__ssprint_r>
    9ddc:	2800      	cmp	r0, #0
    9dde:	f47f ab41 	bne.w	9464 <_svfprintf_r+0x1ec>
    9de2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9de4:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9de8:	e496      	b.n	9718 <_svfprintf_r+0x4a0>
    9dea:	aa1b      	add	r2, sp, #108	; 0x6c
    9dec:	9903      	ldr	r1, [sp, #12]
    9dee:	9805      	ldr	r0, [sp, #20]
    9df0:	f000 fcfa 	bl	a7e8 <__ssprint_r>
    9df4:	2800      	cmp	r0, #0
    9df6:	f47f ab35 	bne.w	9464 <_svfprintf_r+0x1ec>
    9dfa:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9dfc:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9e00:	e49a      	b.n	9738 <_svfprintf_r+0x4c0>
    9e02:	f1b8 0f00 	cmp.w	r8, #0
    9e06:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9e0a:	f2c0 826f 	blt.w	a2ec <_svfprintf_r+0x1074>
    9e0e:	ea54 0305 	orrs.w	r3, r4, r5
    9e12:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9e16:	f47f adc4 	bne.w	99a2 <_svfprintf_r+0x72a>
    9e1a:	f1b8 0f00 	cmp.w	r8, #0
    9e1e:	f43f ae7c 	beq.w	9b1a <_svfprintf_r+0x8a2>
    9e22:	2700      	movs	r7, #0
    9e24:	e6a7      	b.n	9b76 <_svfprintf_r+0x8fe>
    9e26:	9c15      	ldr	r4, [sp, #84]	; 0x54
    9e28:	2c00      	cmp	r4, #0
    9e2a:	f340 8261 	ble.w	a2f0 <_svfprintf_r+0x1078>
    9e2e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    9e30:	990d      	ldr	r1, [sp, #52]	; 0x34
    9e32:	428a      	cmp	r2, r1
    9e34:	bfa8      	it	ge
    9e36:	460a      	movge	r2, r1
    9e38:	2a00      	cmp	r2, #0
    9e3a:	4614      	mov	r4, r2
    9e3c:	dd0d      	ble.n	9e5a <_svfprintf_r+0xbe2>
    9e3e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9e40:	f8c9 6000 	str.w	r6, [r9]
    9e44:	3201      	adds	r2, #1
    9e46:	4423      	add	r3, r4
    9e48:	2a07      	cmp	r2, #7
    9e4a:	931d      	str	r3, [sp, #116]	; 0x74
    9e4c:	f8c9 4004 	str.w	r4, [r9, #4]
    9e50:	921c      	str	r2, [sp, #112]	; 0x70
    9e52:	f300 8372 	bgt.w	a53a <_svfprintf_r+0x12c2>
    9e56:	f109 0908 	add.w	r9, r9, #8
    9e5a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    9e5c:	2c00      	cmp	r4, #0
    9e5e:	bfa8      	it	ge
    9e60:	1b12      	subge	r2, r2, r4
    9e62:	2a00      	cmp	r2, #0
    9e64:	4614      	mov	r4, r2
    9e66:	f340 80f1 	ble.w	a04c <_svfprintf_r+0xdd4>
    9e6a:	2c10      	cmp	r4, #16
    9e6c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9e6e:	4fc1      	ldr	r7, [pc, #772]	; (a174 <_svfprintf_r+0xefc>)
    9e70:	f340 8219 	ble.w	a2a6 <_svfprintf_r+0x102e>
    9e74:	4649      	mov	r1, r9
    9e76:	2510      	movs	r5, #16
    9e78:	46b1      	mov	r9, r6
    9e7a:	f8dd 8014 	ldr.w	r8, [sp, #20]
    9e7e:	9e03      	ldr	r6, [sp, #12]
    9e80:	e004      	b.n	9e8c <_svfprintf_r+0xc14>
    9e82:	3108      	adds	r1, #8
    9e84:	3c10      	subs	r4, #16
    9e86:	2c10      	cmp	r4, #16
    9e88:	f340 820b 	ble.w	a2a2 <_svfprintf_r+0x102a>
    9e8c:	3201      	adds	r2, #1
    9e8e:	3310      	adds	r3, #16
    9e90:	2a07      	cmp	r2, #7
    9e92:	931d      	str	r3, [sp, #116]	; 0x74
    9e94:	921c      	str	r2, [sp, #112]	; 0x70
    9e96:	600f      	str	r7, [r1, #0]
    9e98:	604d      	str	r5, [r1, #4]
    9e9a:	ddf2      	ble.n	9e82 <_svfprintf_r+0xc0a>
    9e9c:	aa1b      	add	r2, sp, #108	; 0x6c
    9e9e:	4631      	mov	r1, r6
    9ea0:	4640      	mov	r0, r8
    9ea2:	f000 fca1 	bl	a7e8 <__ssprint_r>
    9ea6:	2800      	cmp	r0, #0
    9ea8:	f47f aadc 	bne.w	9464 <_svfprintf_r+0x1ec>
    9eac:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9eae:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9eb0:	a928      	add	r1, sp, #160	; 0xa0
    9eb2:	e7e7      	b.n	9e84 <_svfprintf_r+0xc0c>
    9eb4:	aa1b      	add	r2, sp, #108	; 0x6c
    9eb6:	9903      	ldr	r1, [sp, #12]
    9eb8:	9805      	ldr	r0, [sp, #20]
    9eba:	f000 fc95 	bl	a7e8 <__ssprint_r>
    9ebe:	2800      	cmp	r0, #0
    9ec0:	f47f aad0 	bne.w	9464 <_svfprintf_r+0x1ec>
    9ec4:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9ec8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9eca:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9ece:	e413      	b.n	96f8 <_svfprintf_r+0x480>
    9ed0:	f01b 0210 	ands.w	r2, fp, #16
    9ed4:	f47f af57 	bne.w	9d86 <_svfprintf_r+0xb0e>
    9ed8:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    9edc:	f43f af53 	beq.w	9d86 <_svfprintf_r+0xb0e>
    9ee0:	9909      	ldr	r1, [sp, #36]	; 0x24
    9ee2:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    9ee6:	460b      	mov	r3, r1
    9ee8:	f1b8 0f00 	cmp.w	r8, #0
    9eec:	f103 0304 	add.w	r3, r3, #4
    9ef0:	880c      	ldrh	r4, [r1, #0]
    9ef2:	f04f 0500 	mov.w	r5, #0
    9ef6:	f2c0 8294 	blt.w	a422 <_svfprintf_r+0x11aa>
    9efa:	ea54 0105 	orrs.w	r1, r4, r5
    9efe:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9f02:	9309      	str	r3, [sp, #36]	; 0x24
    9f04:	4617      	mov	r7, r2
    9f06:	f47f ab5c 	bne.w	95c2 <_svfprintf_r+0x34a>
    9f0a:	e750      	b.n	9dae <_svfprintf_r+0xb36>
    9f0c:	1e4c      	subs	r4, r1, #1
    9f0e:	2c00      	cmp	r4, #0
    9f10:	f77f af16 	ble.w	9d40 <_svfprintf_r+0xac8>
    9f14:	2c10      	cmp	r4, #16
    9f16:	4f97      	ldr	r7, [pc, #604]	; (a174 <_svfprintf_r+0xefc>)
    9f18:	dd22      	ble.n	9f60 <_svfprintf_r+0xce8>
    9f1a:	2510      	movs	r5, #16
    9f1c:	9e05      	ldr	r6, [sp, #20]
    9f1e:	f8dd 800c 	ldr.w	r8, [sp, #12]
    9f22:	e004      	b.n	9f2e <_svfprintf_r+0xcb6>
    9f24:	3c10      	subs	r4, #16
    9f26:	2c10      	cmp	r4, #16
    9f28:	f109 0908 	add.w	r9, r9, #8
    9f2c:	dd18      	ble.n	9f60 <_svfprintf_r+0xce8>
    9f2e:	3201      	adds	r2, #1
    9f30:	3310      	adds	r3, #16
    9f32:	2a07      	cmp	r2, #7
    9f34:	931d      	str	r3, [sp, #116]	; 0x74
    9f36:	921c      	str	r2, [sp, #112]	; 0x70
    9f38:	f8c9 7000 	str.w	r7, [r9]
    9f3c:	f8c9 5004 	str.w	r5, [r9, #4]
    9f40:	ddf0      	ble.n	9f24 <_svfprintf_r+0xcac>
    9f42:	aa1b      	add	r2, sp, #108	; 0x6c
    9f44:	4641      	mov	r1, r8
    9f46:	4630      	mov	r0, r6
    9f48:	f000 fc4e 	bl	a7e8 <__ssprint_r>
    9f4c:	2800      	cmp	r0, #0
    9f4e:	f47f aa89 	bne.w	9464 <_svfprintf_r+0x1ec>
    9f52:	3c10      	subs	r4, #16
    9f54:	2c10      	cmp	r4, #16
    9f56:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9f58:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9f5a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9f5e:	dce6      	bgt.n	9f2e <_svfprintf_r+0xcb6>
    9f60:	3201      	adds	r2, #1
    9f62:	4423      	add	r3, r4
    9f64:	2a07      	cmp	r2, #7
    9f66:	931d      	str	r3, [sp, #116]	; 0x74
    9f68:	921c      	str	r2, [sp, #112]	; 0x70
    9f6a:	f8c9 7000 	str.w	r7, [r9]
    9f6e:	f8c9 4004 	str.w	r4, [r9, #4]
    9f72:	f77f aee3 	ble.w	9d3c <_svfprintf_r+0xac4>
    9f76:	aa1b      	add	r2, sp, #108	; 0x6c
    9f78:	9903      	ldr	r1, [sp, #12]
    9f7a:	9805      	ldr	r0, [sp, #20]
    9f7c:	f000 fc34 	bl	a7e8 <__ssprint_r>
    9f80:	2800      	cmp	r0, #0
    9f82:	f47f aa6f 	bne.w	9464 <_svfprintf_r+0x1ec>
    9f86:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9f88:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9f8a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9f8e:	e6d7      	b.n	9d40 <_svfprintf_r+0xac8>
    9f90:	f01b 0f10 	tst.w	fp, #16
    9f94:	d133      	bne.n	9ffe <_svfprintf_r+0xd86>
    9f96:	f01b 0f40 	tst.w	fp, #64	; 0x40
    9f9a:	d030      	beq.n	9ffe <_svfprintf_r+0xd86>
    9f9c:	9909      	ldr	r1, [sp, #36]	; 0x24
    9f9e:	f9b1 4000 	ldrsh.w	r4, [r1]
    9fa2:	3104      	adds	r1, #4
    9fa4:	17e5      	asrs	r5, r4, #31
    9fa6:	4622      	mov	r2, r4
    9fa8:	462b      	mov	r3, r5
    9faa:	9109      	str	r1, [sp, #36]	; 0x24
    9fac:	f7ff baf8 	b.w	95a0 <_svfprintf_r+0x328>
    9fb0:	3201      	adds	r2, #1
    9fb2:	4423      	add	r3, r4
    9fb4:	2a07      	cmp	r2, #7
    9fb6:	931d      	str	r3, [sp, #116]	; 0x74
    9fb8:	921c      	str	r2, [sp, #112]	; 0x70
    9fba:	f8c9 7000 	str.w	r7, [r9]
    9fbe:	f8c9 4004 	str.w	r4, [r9, #4]
    9fc2:	f77f ac08 	ble.w	97d6 <_svfprintf_r+0x55e>
    9fc6:	e6c8      	b.n	9d5a <_svfprintf_r+0xae2>
    9fc8:	9909      	ldr	r1, [sp, #36]	; 0x24
    9fca:	f1b8 0f00 	cmp.w	r8, #0
    9fce:	680c      	ldr	r4, [r1, #0]
    9fd0:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9fd4:	f101 0704 	add.w	r7, r1, #4
    9fd8:	f04f 0500 	mov.w	r5, #0
    9fdc:	f2c0 80c5 	blt.w	a16a <_svfprintf_r+0xef2>
    9fe0:	ea54 0205 	orrs.w	r2, r4, r5
    9fe4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9fe8:	9709      	str	r7, [sp, #36]	; 0x24
    9fea:	f43f adb2 	beq.w	9b52 <_svfprintf_r+0x8da>
    9fee:	461f      	mov	r7, r3
    9ff0:	f7ff ba64 	b.w	94bc <_svfprintf_r+0x244>
    9ff4:	681c      	ldr	r4, [r3, #0]
    9ff6:	3304      	adds	r3, #4
    9ff8:	9309      	str	r3, [sp, #36]	; 0x24
    9ffa:	2500      	movs	r5, #0
    9ffc:	e4b6      	b.n	996c <_svfprintf_r+0x6f4>
    9ffe:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a000:	6814      	ldr	r4, [r2, #0]
    a002:	4613      	mov	r3, r2
    a004:	3304      	adds	r3, #4
    a006:	17e5      	asrs	r5, r4, #31
    a008:	4622      	mov	r2, r4
    a00a:	9309      	str	r3, [sp, #36]	; 0x24
    a00c:	2a00      	cmp	r2, #0
    a00e:	462b      	mov	r3, r5
    a010:	f173 0300 	sbcs.w	r3, r3, #0
    a014:	f6bf aac9 	bge.w	95aa <_svfprintf_r+0x332>
    a018:	4264      	negs	r4, r4
    a01a:	f04f 072d 	mov.w	r7, #45	; 0x2d
    a01e:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
    a022:	f1b8 0f00 	cmp.w	r8, #0
    a026:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    a02a:	f6ff aaca 	blt.w	95c2 <_svfprintf_r+0x34a>
    a02e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    a032:	f7ff bac6 	b.w	95c2 <_svfprintf_r+0x34a>
    a036:	aa1b      	add	r2, sp, #108	; 0x6c
    a038:	9903      	ldr	r1, [sp, #12]
    a03a:	9805      	ldr	r0, [sp, #20]
    a03c:	f000 fbd4 	bl	a7e8 <__ssprint_r>
    a040:	2800      	cmp	r0, #0
    a042:	f47f aa0f 	bne.w	9464 <_svfprintf_r+0x1ec>
    a046:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a048:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a04c:	990e      	ldr	r1, [sp, #56]	; 0x38
    a04e:	9a15      	ldr	r2, [sp, #84]	; 0x54
    a050:	4431      	add	r1, r6
    a052:	460d      	mov	r5, r1
    a054:	990d      	ldr	r1, [sp, #52]	; 0x34
    a056:	428a      	cmp	r2, r1
    a058:	db47      	blt.n	a0ea <_svfprintf_r+0xe72>
    a05a:	f01b 0f01 	tst.w	fp, #1
    a05e:	d144      	bne.n	a0ea <_svfprintf_r+0xe72>
    a060:	980d      	ldr	r0, [sp, #52]	; 0x34
    a062:	4406      	add	r6, r0
    a064:	1b74      	subs	r4, r6, r5
    a066:	1a82      	subs	r2, r0, r2
    a068:	4294      	cmp	r4, r2
    a06a:	bfa8      	it	ge
    a06c:	4614      	movge	r4, r2
    a06e:	2c00      	cmp	r4, #0
    a070:	4626      	mov	r6, r4
    a072:	dd0d      	ble.n	a090 <_svfprintf_r+0xe18>
    a074:	991c      	ldr	r1, [sp, #112]	; 0x70
    a076:	f8c9 5000 	str.w	r5, [r9]
    a07a:	3101      	adds	r1, #1
    a07c:	4423      	add	r3, r4
    a07e:	2907      	cmp	r1, #7
    a080:	931d      	str	r3, [sp, #116]	; 0x74
    a082:	f8c9 4004 	str.w	r4, [r9, #4]
    a086:	911c      	str	r1, [sp, #112]	; 0x70
    a088:	f300 8280 	bgt.w	a58c <_svfprintf_r+0x1314>
    a08c:	f109 0908 	add.w	r9, r9, #8
    a090:	2e00      	cmp	r6, #0
    a092:	bfac      	ite	ge
    a094:	1b94      	subge	r4, r2, r6
    a096:	4614      	movlt	r4, r2
    a098:	2c00      	cmp	r4, #0
    a09a:	f77f ab9e 	ble.w	97da <_svfprintf_r+0x562>
    a09e:	2c10      	cmp	r4, #16
    a0a0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a0a2:	4f34      	ldr	r7, [pc, #208]	; (a174 <_svfprintf_r+0xefc>)
    a0a4:	dd84      	ble.n	9fb0 <_svfprintf_r+0xd38>
    a0a6:	2510      	movs	r5, #16
    a0a8:	9e05      	ldr	r6, [sp, #20]
    a0aa:	f8dd 800c 	ldr.w	r8, [sp, #12]
    a0ae:	e005      	b.n	a0bc <_svfprintf_r+0xe44>
    a0b0:	f109 0908 	add.w	r9, r9, #8
    a0b4:	3c10      	subs	r4, #16
    a0b6:	2c10      	cmp	r4, #16
    a0b8:	f77f af7a 	ble.w	9fb0 <_svfprintf_r+0xd38>
    a0bc:	3201      	adds	r2, #1
    a0be:	3310      	adds	r3, #16
    a0c0:	2a07      	cmp	r2, #7
    a0c2:	931d      	str	r3, [sp, #116]	; 0x74
    a0c4:	921c      	str	r2, [sp, #112]	; 0x70
    a0c6:	f8c9 7000 	str.w	r7, [r9]
    a0ca:	f8c9 5004 	str.w	r5, [r9, #4]
    a0ce:	ddef      	ble.n	a0b0 <_svfprintf_r+0xe38>
    a0d0:	aa1b      	add	r2, sp, #108	; 0x6c
    a0d2:	4641      	mov	r1, r8
    a0d4:	4630      	mov	r0, r6
    a0d6:	f000 fb87 	bl	a7e8 <__ssprint_r>
    a0da:	2800      	cmp	r0, #0
    a0dc:	f47f a9c2 	bne.w	9464 <_svfprintf_r+0x1ec>
    a0e0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a0e2:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a0e4:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a0e8:	e7e4      	b.n	a0b4 <_svfprintf_r+0xe3c>
    a0ea:	991c      	ldr	r1, [sp, #112]	; 0x70
    a0ec:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    a0ee:	9810      	ldr	r0, [sp, #64]	; 0x40
    a0f0:	f8c9 0000 	str.w	r0, [r9]
    a0f4:	3101      	adds	r1, #1
    a0f6:	4423      	add	r3, r4
    a0f8:	2907      	cmp	r1, #7
    a0fa:	931d      	str	r3, [sp, #116]	; 0x74
    a0fc:	f8c9 4004 	str.w	r4, [r9, #4]
    a100:	911c      	str	r1, [sp, #112]	; 0x70
    a102:	f300 8226 	bgt.w	a552 <_svfprintf_r+0x12da>
    a106:	f109 0908 	add.w	r9, r9, #8
    a10a:	e7a9      	b.n	a060 <_svfprintf_r+0xde8>
    a10c:	f01b 0f01 	tst.w	fp, #1
    a110:	f47f adec 	bne.w	9cec <_svfprintf_r+0xa74>
    a114:	2a07      	cmp	r2, #7
    a116:	f77f ae11 	ble.w	9d3c <_svfprintf_r+0xac4>
    a11a:	e72c      	b.n	9f76 <_svfprintf_r+0xcfe>
    a11c:	aa1b      	add	r2, sp, #108	; 0x6c
    a11e:	9903      	ldr	r1, [sp, #12]
    a120:	9805      	ldr	r0, [sp, #20]
    a122:	f000 fb61 	bl	a7e8 <__ssprint_r>
    a126:	2800      	cmp	r0, #0
    a128:	f47f a99c 	bne.w	9464 <_svfprintf_r+0x1ec>
    a12c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a12e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a130:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a134:	e5df      	b.n	9cf6 <_svfprintf_r+0xa7e>
    a136:	aa1b      	add	r2, sp, #108	; 0x6c
    a138:	9903      	ldr	r1, [sp, #12]
    a13a:	9805      	ldr	r0, [sp, #20]
    a13c:	f000 fb54 	bl	a7e8 <__ssprint_r>
    a140:	2800      	cmp	r0, #0
    a142:	f47f a98f 	bne.w	9464 <_svfprintf_r+0x1ec>
    a146:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a148:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a14a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a14e:	e5e1      	b.n	9d14 <_svfprintf_r+0xa9c>
    a150:	aa1b      	add	r2, sp, #108	; 0x6c
    a152:	9903      	ldr	r1, [sp, #12]
    a154:	9805      	ldr	r0, [sp, #20]
    a156:	f000 fb47 	bl	a7e8 <__ssprint_r>
    a15a:	2800      	cmp	r0, #0
    a15c:	f47f a982 	bne.w	9464 <_svfprintf_r+0x1ec>
    a160:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a162:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a166:	f7ff baeb 	b.w	9740 <_svfprintf_r+0x4c8>
    a16a:	9709      	str	r7, [sp, #36]	; 0x24
    a16c:	2700      	movs	r7, #0
    a16e:	f7ff b9a5 	b.w	94bc <_svfprintf_r+0x244>
    a172:	bf00      	nop
    a174:	20001030 	.word	0x20001030
    a178:	f01b 0f10 	tst.w	fp, #16
    a17c:	d10b      	bne.n	a196 <_svfprintf_r+0xf1e>
    a17e:	f01b 0f40 	tst.w	fp, #64	; 0x40
    a182:	d008      	beq.n	a196 <_svfprintf_r+0xf1e>
    a184:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a186:	6813      	ldr	r3, [r2, #0]
    a188:	3204      	adds	r2, #4
    a18a:	9209      	str	r2, [sp, #36]	; 0x24
    a18c:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    a190:	801a      	strh	r2, [r3, #0]
    a192:	f7ff b897 	b.w	92c4 <_svfprintf_r+0x4c>
    a196:	9a09      	ldr	r2, [sp, #36]	; 0x24
    a198:	6813      	ldr	r3, [r2, #0]
    a19a:	3204      	adds	r2, #4
    a19c:	9209      	str	r2, [sp, #36]	; 0x24
    a19e:	9a06      	ldr	r2, [sp, #24]
    a1a0:	601a      	str	r2, [r3, #0]
    a1a2:	f7ff b88f 	b.w	92c4 <_svfprintf_r+0x4c>
    a1a6:	eeb4 8b48 	vcmp.f64	d8, d8
    a1aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a1ae:	f180 829e 	bvs.w	a6ee <_svfprintf_r+0x1476>
    a1b2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a1b4:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    a1b8:	f023 0520 	bic.w	r5, r3, #32
    a1bc:	f000 8225 	beq.w	a60a <_svfprintf_r+0x1392>
    a1c0:	2d47      	cmp	r5, #71	; 0x47
    a1c2:	f000 8126 	beq.w	a412 <_svfprintf_r+0x119a>
    a1c6:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
    a1ca:	930a      	str	r3, [sp, #40]	; 0x28
    a1cc:	ee18 3a90 	vmov	r3, s17
    a1d0:	2b00      	cmp	r3, #0
    a1d2:	f2c0 821d 	blt.w	a610 <_svfprintf_r+0x1398>
    a1d6:	eeb0 ab48 	vmov.f64	d10, d8
    a1da:	2700      	movs	r7, #0
    a1dc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a1de:	2b66      	cmp	r3, #102	; 0x66
    a1e0:	f000 8202 	beq.w	a5e8 <_svfprintf_r+0x1370>
    a1e4:	2b46      	cmp	r3, #70	; 0x46
    a1e6:	f000 80ec 	beq.w	a3c2 <_svfprintf_r+0x114a>
    a1ea:	eeb0 0b4a 	vmov.f64	d0, d10
    a1ee:	2d45      	cmp	r5, #69	; 0x45
    a1f0:	bf0c      	ite	eq
    a1f2:	f108 0401 	addeq.w	r4, r8, #1
    a1f6:	4644      	movne	r4, r8
    a1f8:	aa19      	add	r2, sp, #100	; 0x64
    a1fa:	ab16      	add	r3, sp, #88	; 0x58
    a1fc:	9201      	str	r2, [sp, #4]
    a1fe:	9300      	str	r3, [sp, #0]
    a200:	4622      	mov	r2, r4
    a202:	ab15      	add	r3, sp, #84	; 0x54
    a204:	2102      	movs	r1, #2
    a206:	9805      	ldr	r0, [sp, #20]
    a208:	f7fe f9f2 	bl	85f0 <_dtoa_r>
    a20c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a20e:	2b67      	cmp	r3, #103	; 0x67
    a210:	4606      	mov	r6, r0
    a212:	f040 820e 	bne.w	a632 <_svfprintf_r+0x13ba>
    a216:	f01b 0f01 	tst.w	fp, #1
    a21a:	f000 8266 	beq.w	a6ea <_svfprintf_r+0x1472>
    a21e:	1931      	adds	r1, r6, r4
    a220:	eeb5 ab40 	vcmp.f64	d10, #0.0
    a224:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a228:	f000 8185 	beq.w	a536 <_svfprintf_r+0x12be>
    a22c:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a22e:	4299      	cmp	r1, r3
    a230:	d906      	bls.n	a240 <_svfprintf_r+0xfc8>
    a232:	2030      	movs	r0, #48	; 0x30
    a234:	1c5a      	adds	r2, r3, #1
    a236:	9219      	str	r2, [sp, #100]	; 0x64
    a238:	7018      	strb	r0, [r3, #0]
    a23a:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a23c:	4299      	cmp	r1, r3
    a23e:	d8f9      	bhi.n	a234 <_svfprintf_r+0xfbc>
    a240:	1b9b      	subs	r3, r3, r6
    a242:	2d47      	cmp	r5, #71	; 0x47
    a244:	930d      	str	r3, [sp, #52]	; 0x34
    a246:	f000 811f 	beq.w	a488 <_svfprintf_r+0x1210>
    a24a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a24c:	2b65      	cmp	r3, #101	; 0x65
    a24e:	f340 81ff 	ble.w	a650 <_svfprintf_r+0x13d8>
    a252:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a254:	2b66      	cmp	r3, #102	; 0x66
    a256:	9b15      	ldr	r3, [sp, #84]	; 0x54
    a258:	f000 81fc 	beq.w	a654 <_svfprintf_r+0x13dc>
    a25c:	930e      	str	r3, [sp, #56]	; 0x38
    a25e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    a260:	990d      	ldr	r1, [sp, #52]	; 0x34
    a262:	428a      	cmp	r2, r1
    a264:	f2c0 81d8 	blt.w	a618 <_svfprintf_r+0x13a0>
    a268:	f01b 0f01 	tst.w	fp, #1
    a26c:	f040 8234 	bne.w	a6d8 <_svfprintf_r+0x1460>
    a270:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    a274:	9208      	str	r2, [sp, #32]
    a276:	2267      	movs	r2, #103	; 0x67
    a278:	920c      	str	r2, [sp, #48]	; 0x30
    a27a:	2f00      	cmp	r7, #0
    a27c:	f040 80f6 	bne.w	a46c <_svfprintf_r+0x11f4>
    a280:	46b8      	mov	r8, r7
    a282:	9304      	str	r3, [sp, #16]
    a284:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    a288:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    a28c:	f7ff b9e6 	b.w	965c <_svfprintf_r+0x3e4>
    a290:	f027 0707 	bic.w	r7, r7, #7
    a294:	f107 0308 	add.w	r3, r7, #8
    a298:	ed97 8b00 	vldr	d8, [r7]
    a29c:	9309      	str	r3, [sp, #36]	; 0x24
    a29e:	f7ff b9be 	b.w	961e <_svfprintf_r+0x3a6>
    a2a2:	464e      	mov	r6, r9
    a2a4:	4689      	mov	r9, r1
    a2a6:	3201      	adds	r2, #1
    a2a8:	4423      	add	r3, r4
    a2aa:	2a07      	cmp	r2, #7
    a2ac:	931d      	str	r3, [sp, #116]	; 0x74
    a2ae:	921c      	str	r2, [sp, #112]	; 0x70
    a2b0:	f8c9 7000 	str.w	r7, [r9]
    a2b4:	f8c9 4004 	str.w	r4, [r9, #4]
    a2b8:	f73f aebd 	bgt.w	a036 <_svfprintf_r+0xdbe>
    a2bc:	f109 0908 	add.w	r9, r9, #8
    a2c0:	e6c4      	b.n	a04c <_svfprintf_r+0xdd4>
    a2c2:	2700      	movs	r7, #0
    a2c4:	45b8      	cmp	r8, r7
    a2c6:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    a2ca:	f6ff ac54 	blt.w	9b76 <_svfprintf_r+0x8fe>
    a2ce:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    a2d2:	e41e      	b.n	9b12 <_svfprintf_r+0x89a>
    a2d4:	aa1b      	add	r2, sp, #108	; 0x6c
    a2d6:	9903      	ldr	r1, [sp, #12]
    a2d8:	9805      	ldr	r0, [sp, #20]
    a2da:	f000 fa85 	bl	a7e8 <__ssprint_r>
    a2de:	2800      	cmp	r0, #0
    a2e0:	f47f a8c0 	bne.w	9464 <_svfprintf_r+0x1ec>
    a2e4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a2e6:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a2ea:	e463      	b.n	9bb4 <_svfprintf_r+0x93c>
    a2ec:	9f09      	ldr	r7, [sp, #36]	; 0x24
    a2ee:	e43b      	b.n	9b68 <_svfprintf_r+0x8f0>
    a2f0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a2f2:	49b9      	ldr	r1, [pc, #740]	; (a5d8 <_svfprintf_r+0x1360>)
    a2f4:	f8c9 1000 	str.w	r1, [r9]
    a2f8:	3201      	adds	r2, #1
    a2fa:	3301      	adds	r3, #1
    a2fc:	2101      	movs	r1, #1
    a2fe:	2a07      	cmp	r2, #7
    a300:	931d      	str	r3, [sp, #116]	; 0x74
    a302:	921c      	str	r2, [sp, #112]	; 0x70
    a304:	f8c9 1004 	str.w	r1, [r9, #4]
    a308:	dc76      	bgt.n	a3f8 <_svfprintf_r+0x1180>
    a30a:	f109 0908 	add.w	r9, r9, #8
    a30e:	b92c      	cbnz	r4, a31c <_svfprintf_r+0x10a4>
    a310:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    a312:	b91a      	cbnz	r2, a31c <_svfprintf_r+0x10a4>
    a314:	f01b 0f01 	tst.w	fp, #1
    a318:	f43f aa5f 	beq.w	97da <_svfprintf_r+0x562>
    a31c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a31e:	980f      	ldr	r0, [sp, #60]	; 0x3c
    a320:	9910      	ldr	r1, [sp, #64]	; 0x40
    a322:	f8c9 1000 	str.w	r1, [r9]
    a326:	3201      	adds	r2, #1
    a328:	4403      	add	r3, r0
    a32a:	2a07      	cmp	r2, #7
    a32c:	931d      	str	r3, [sp, #116]	; 0x74
    a32e:	f8c9 0004 	str.w	r0, [r9, #4]
    a332:	921c      	str	r2, [sp, #112]	; 0x70
    a334:	f300 81b6 	bgt.w	a6a4 <_svfprintf_r+0x142c>
    a338:	f109 0908 	add.w	r9, r9, #8
    a33c:	4264      	negs	r4, r4
    a33e:	2c00      	cmp	r4, #0
    a340:	f340 8087 	ble.w	a452 <_svfprintf_r+0x11da>
    a344:	2c10      	cmp	r4, #16
    a346:	4fa5      	ldr	r7, [pc, #660]	; (a5dc <_svfprintf_r+0x1364>)
    a348:	f340 8112 	ble.w	a570 <_svfprintf_r+0x12f8>
    a34c:	4649      	mov	r1, r9
    a34e:	2510      	movs	r5, #16
    a350:	46b1      	mov	r9, r6
    a352:	f8dd 8014 	ldr.w	r8, [sp, #20]
    a356:	9e03      	ldr	r6, [sp, #12]
    a358:	e004      	b.n	a364 <_svfprintf_r+0x10ec>
    a35a:	3108      	adds	r1, #8
    a35c:	3c10      	subs	r4, #16
    a35e:	2c10      	cmp	r4, #16
    a360:	f340 8104 	ble.w	a56c <_svfprintf_r+0x12f4>
    a364:	3201      	adds	r2, #1
    a366:	3310      	adds	r3, #16
    a368:	2a07      	cmp	r2, #7
    a36a:	931d      	str	r3, [sp, #116]	; 0x74
    a36c:	921c      	str	r2, [sp, #112]	; 0x70
    a36e:	600f      	str	r7, [r1, #0]
    a370:	604d      	str	r5, [r1, #4]
    a372:	ddf2      	ble.n	a35a <_svfprintf_r+0x10e2>
    a374:	aa1b      	add	r2, sp, #108	; 0x6c
    a376:	4631      	mov	r1, r6
    a378:	4640      	mov	r0, r8
    a37a:	f000 fa35 	bl	a7e8 <__ssprint_r>
    a37e:	2800      	cmp	r0, #0
    a380:	f47f a870 	bne.w	9464 <_svfprintf_r+0x1ec>
    a384:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a386:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a388:	a928      	add	r1, sp, #160	; 0xa0
    a38a:	e7e7      	b.n	a35c <_svfprintf_r+0x10e4>
    a38c:	aa1b      	add	r2, sp, #108	; 0x6c
    a38e:	9903      	ldr	r1, [sp, #12]
    a390:	9805      	ldr	r0, [sp, #20]
    a392:	f000 fa29 	bl	a7e8 <__ssprint_r>
    a396:	2800      	cmp	r0, #0
    a398:	f47f a864 	bne.w	9464 <_svfprintf_r+0x1ec>
    a39c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a39e:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a3a2:	e41f      	b.n	9be4 <_svfprintf_r+0x96c>
    a3a4:	2140      	movs	r1, #64	; 0x40
    a3a6:	9805      	ldr	r0, [sp, #20]
    a3a8:	f7fc f9b8 	bl	671c <_malloc_r>
    a3ac:	9a03      	ldr	r2, [sp, #12]
    a3ae:	6010      	str	r0, [r2, #0]
    a3b0:	6110      	str	r0, [r2, #16]
    a3b2:	2800      	cmp	r0, #0
    a3b4:	f000 81ed 	beq.w	a792 <_svfprintf_r+0x151a>
    a3b8:	9a03      	ldr	r2, [sp, #12]
    a3ba:	2340      	movs	r3, #64	; 0x40
    a3bc:	6153      	str	r3, [r2, #20]
    a3be:	f7fe bf74 	b.w	92aa <_svfprintf_r+0x32>
    a3c2:	aa19      	add	r2, sp, #100	; 0x64
    a3c4:	ab16      	add	r3, sp, #88	; 0x58
    a3c6:	9201      	str	r2, [sp, #4]
    a3c8:	9300      	str	r3, [sp, #0]
    a3ca:	4642      	mov	r2, r8
    a3cc:	ab15      	add	r3, sp, #84	; 0x54
    a3ce:	2103      	movs	r1, #3
    a3d0:	eeb0 0b4a 	vmov.f64	d0, d10
    a3d4:	9805      	ldr	r0, [sp, #20]
    a3d6:	f7fe f90b 	bl	85f0 <_dtoa_r>
    a3da:	4644      	mov	r4, r8
    a3dc:	4606      	mov	r6, r0
    a3de:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a3e0:	2b46      	cmp	r3, #70	; 0x46
    a3e2:	eb06 0104 	add.w	r1, r6, r4
    a3e6:	f47f af1b 	bne.w	a220 <_svfprintf_r+0xfa8>
    a3ea:	7833      	ldrb	r3, [r6, #0]
    a3ec:	2b30      	cmp	r3, #48	; 0x30
    a3ee:	f000 818d 	beq.w	a70c <_svfprintf_r+0x1494>
    a3f2:	9c15      	ldr	r4, [sp, #84]	; 0x54
    a3f4:	4421      	add	r1, r4
    a3f6:	e713      	b.n	a220 <_svfprintf_r+0xfa8>
    a3f8:	aa1b      	add	r2, sp, #108	; 0x6c
    a3fa:	9903      	ldr	r1, [sp, #12]
    a3fc:	9805      	ldr	r0, [sp, #20]
    a3fe:	f000 f9f3 	bl	a7e8 <__ssprint_r>
    a402:	2800      	cmp	r0, #0
    a404:	f47f a82e 	bne.w	9464 <_svfprintf_r+0x1ec>
    a408:	9c15      	ldr	r4, [sp, #84]	; 0x54
    a40a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a40c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a410:	e77d      	b.n	a30e <_svfprintf_r+0x1096>
    a412:	f1b8 0f00 	cmp.w	r8, #0
    a416:	bf08      	it	eq
    a418:	f04f 0801 	moveq.w	r8, #1
    a41c:	e6d3      	b.n	a1c6 <_svfprintf_r+0xf4e>
    a41e:	9309      	str	r3, [sp, #36]	; 0x24
    a420:	e6a4      	b.n	a16c <_svfprintf_r+0xef4>
    a422:	9309      	str	r3, [sp, #36]	; 0x24
    a424:	4617      	mov	r7, r2
    a426:	f7ff ba7b 	b.w	9920 <_svfprintf_r+0x6a8>
    a42a:	4630      	mov	r0, r6
    a42c:	f7fd f988 	bl	7740 <strlen>
    a430:	46a0      	mov	r8, r4
    a432:	4603      	mov	r3, r0
    a434:	9008      	str	r0, [sp, #32]
    a436:	f7ff bb61 	b.w	9afc <_svfprintf_r+0x884>
    a43a:	aa1b      	add	r2, sp, #108	; 0x6c
    a43c:	9903      	ldr	r1, [sp, #12]
    a43e:	9805      	ldr	r0, [sp, #20]
    a440:	f000 f9d2 	bl	a7e8 <__ssprint_r>
    a444:	2800      	cmp	r0, #0
    a446:	f47f a80d 	bne.w	9464 <_svfprintf_r+0x1ec>
    a44a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a44c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a44e:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a452:	980d      	ldr	r0, [sp, #52]	; 0x34
    a454:	f8c9 6000 	str.w	r6, [r9]
    a458:	3201      	adds	r2, #1
    a45a:	4403      	add	r3, r0
    a45c:	2a07      	cmp	r2, #7
    a45e:	931d      	str	r3, [sp, #116]	; 0x74
    a460:	921c      	str	r2, [sp, #112]	; 0x70
    a462:	f8c9 0004 	str.w	r0, [r9, #4]
    a466:	f77f a9b6 	ble.w	97d6 <_svfprintf_r+0x55e>
    a46a:	e476      	b.n	9d5a <_svfprintf_r+0xae2>
    a46c:	272d      	movs	r7, #45	; 0x2d
    a46e:	9304      	str	r3, [sp, #16]
    a470:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    a474:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    a478:	f04f 0800 	mov.w	r8, #0
    a47c:	f7ff b8ef 	b.w	965e <_svfprintf_r+0x3e6>
    a480:	9709      	str	r7, [sp, #36]	; 0x24
    a482:	461f      	mov	r7, r3
    a484:	f7ff ba4c 	b.w	9920 <_svfprintf_r+0x6a8>
    a488:	9b15      	ldr	r3, [sp, #84]	; 0x54
    a48a:	1cda      	adds	r2, r3, #3
    a48c:	db02      	blt.n	a494 <_svfprintf_r+0x121c>
    a48e:	4598      	cmp	r8, r3
    a490:	f6bf aee4 	bge.w	a25c <_svfprintf_r+0xfe4>
    a494:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    a496:	3a02      	subs	r2, #2
    a498:	920c      	str	r2, [sp, #48]	; 0x30
    a49a:	3b01      	subs	r3, #1
    a49c:	2b00      	cmp	r3, #0
    a49e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    a4a2:	9315      	str	r3, [sp, #84]	; 0x54
    a4a4:	bfb8      	it	lt
    a4a6:	425b      	neglt	r3, r3
    a4a8:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
    a4ac:	bfb4      	ite	lt
    a4ae:	222d      	movlt	r2, #45	; 0x2d
    a4b0:	222b      	movge	r2, #43	; 0x2b
    a4b2:	2b09      	cmp	r3, #9
    a4b4:	f88d 205d 	strb.w	r2, [sp, #93]	; 0x5d
    a4b8:	f340 8106 	ble.w	a6c8 <_svfprintf_r+0x1450>
    a4bc:	f10d 006b 	add.w	r0, sp, #107	; 0x6b
    a4c0:	4604      	mov	r4, r0
    a4c2:	4a47      	ldr	r2, [pc, #284]	; (a5e0 <_svfprintf_r+0x1368>)
    a4c4:	fb82 2103 	smull	r2, r1, r2, r3
    a4c8:	17da      	asrs	r2, r3, #31
    a4ca:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
    a4ce:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    a4d2:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
    a4d6:	f103 0130 	add.w	r1, r3, #48	; 0x30
    a4da:	2a09      	cmp	r2, #9
    a4dc:	4613      	mov	r3, r2
    a4de:	f804 1d01 	strb.w	r1, [r4, #-1]!
    a4e2:	dcee      	bgt.n	a4c2 <_svfprintf_r+0x124a>
    a4e4:	4621      	mov	r1, r4
    a4e6:	3330      	adds	r3, #48	; 0x30
    a4e8:	b2da      	uxtb	r2, r3
    a4ea:	f801 2d01 	strb.w	r2, [r1, #-1]!
    a4ee:	4288      	cmp	r0, r1
    a4f0:	f240 8162 	bls.w	a7b8 <_svfprintf_r+0x1540>
    a4f4:	f10d 015e 	add.w	r1, sp, #94	; 0x5e
    a4f8:	4623      	mov	r3, r4
    a4fa:	e001      	b.n	a500 <_svfprintf_r+0x1288>
    a4fc:	f813 2b01 	ldrb.w	r2, [r3], #1
    a500:	f801 2b01 	strb.w	r2, [r1], #1
    a504:	4298      	cmp	r0, r3
    a506:	d1f9      	bne.n	a4fc <_svfprintf_r+0x1284>
    a508:	1c43      	adds	r3, r0, #1
    a50a:	1b1b      	subs	r3, r3, r4
    a50c:	f10d 025e 	add.w	r2, sp, #94	; 0x5e
    a510:	4413      	add	r3, r2
    a512:	aa17      	add	r2, sp, #92	; 0x5c
    a514:	1a9b      	subs	r3, r3, r2
    a516:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    a518:	9311      	str	r3, [sp, #68]	; 0x44
    a51a:	2a01      	cmp	r2, #1
    a51c:	4413      	add	r3, r2
    a51e:	9308      	str	r3, [sp, #32]
    a520:	f340 80ff 	ble.w	a722 <_svfprintf_r+0x14aa>
    a524:	9b08      	ldr	r3, [sp, #32]
    a526:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a528:	4413      	add	r3, r2
    a52a:	2200      	movs	r2, #0
    a52c:	9308      	str	r3, [sp, #32]
    a52e:	920e      	str	r2, [sp, #56]	; 0x38
    a530:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a534:	e6a1      	b.n	a27a <_svfprintf_r+0x1002>
    a536:	460b      	mov	r3, r1
    a538:	e682      	b.n	a240 <_svfprintf_r+0xfc8>
    a53a:	aa1b      	add	r2, sp, #108	; 0x6c
    a53c:	9903      	ldr	r1, [sp, #12]
    a53e:	9805      	ldr	r0, [sp, #20]
    a540:	f000 f952 	bl	a7e8 <__ssprint_r>
    a544:	2800      	cmp	r0, #0
    a546:	f47e af8d 	bne.w	9464 <_svfprintf_r+0x1ec>
    a54a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a54c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a550:	e483      	b.n	9e5a <_svfprintf_r+0xbe2>
    a552:	aa1b      	add	r2, sp, #108	; 0x6c
    a554:	9903      	ldr	r1, [sp, #12]
    a556:	9805      	ldr	r0, [sp, #20]
    a558:	f000 f946 	bl	a7e8 <__ssprint_r>
    a55c:	2800      	cmp	r0, #0
    a55e:	f47e af81 	bne.w	9464 <_svfprintf_r+0x1ec>
    a562:	9a15      	ldr	r2, [sp, #84]	; 0x54
    a564:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a566:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a56a:	e579      	b.n	a060 <_svfprintf_r+0xde8>
    a56c:	464e      	mov	r6, r9
    a56e:	4689      	mov	r9, r1
    a570:	3201      	adds	r2, #1
    a572:	4423      	add	r3, r4
    a574:	2a07      	cmp	r2, #7
    a576:	931d      	str	r3, [sp, #116]	; 0x74
    a578:	921c      	str	r2, [sp, #112]	; 0x70
    a57a:	f8c9 7000 	str.w	r7, [r9]
    a57e:	f8c9 4004 	str.w	r4, [r9, #4]
    a582:	f73f af5a 	bgt.w	a43a <_svfprintf_r+0x11c2>
    a586:	f109 0908 	add.w	r9, r9, #8
    a58a:	e762      	b.n	a452 <_svfprintf_r+0x11da>
    a58c:	aa1b      	add	r2, sp, #108	; 0x6c
    a58e:	9903      	ldr	r1, [sp, #12]
    a590:	9805      	ldr	r0, [sp, #20]
    a592:	f000 f929 	bl	a7e8 <__ssprint_r>
    a596:	2800      	cmp	r0, #0
    a598:	f47e af64 	bne.w	9464 <_svfprintf_r+0x1ec>
    a59c:	9a15      	ldr	r2, [sp, #84]	; 0x54
    a59e:	990d      	ldr	r1, [sp, #52]	; 0x34
    a5a0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a5a2:	1a8a      	subs	r2, r1, r2
    a5a4:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a5a8:	e572      	b.n	a090 <_svfprintf_r+0xe18>
    a5aa:	2d06      	cmp	r5, #6
    a5ac:	462b      	mov	r3, r5
    a5ae:	bf28      	it	cs
    a5b0:	2306      	movcs	r3, #6
    a5b2:	9308      	str	r3, [sp, #32]
    a5b4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a5b8:	46b0      	mov	r8, r6
    a5ba:	9709      	str	r7, [sp, #36]	; 0x24
    a5bc:	960e      	str	r6, [sp, #56]	; 0x38
    a5be:	4637      	mov	r7, r6
    a5c0:	9304      	str	r3, [sp, #16]
    a5c2:	4e08      	ldr	r6, [pc, #32]	; (a5e4 <_svfprintf_r+0x136c>)
    a5c4:	f7ff b84a 	b.w	965c <_svfprintf_r+0x3e4>
    a5c8:	469b      	mov	fp, r3
    a5ca:	f7ff b9ea 	b.w	99a2 <_svfprintf_r+0x72a>
    a5ce:	272d      	movs	r7, #45	; 0x2d
    a5d0:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    a5d4:	f7ff b833 	b.w	963e <_svfprintf_r+0x3c6>
    a5d8:	20000e48 	.word	0x20000e48
    a5dc:	20001030 	.word	0x20001030
    a5e0:	66666667 	.word	0x66666667
    a5e4:	20000e84 	.word	0x20000e84
    a5e8:	aa19      	add	r2, sp, #100	; 0x64
    a5ea:	ab16      	add	r3, sp, #88	; 0x58
    a5ec:	9201      	str	r2, [sp, #4]
    a5ee:	9300      	str	r3, [sp, #0]
    a5f0:	2103      	movs	r1, #3
    a5f2:	ab15      	add	r3, sp, #84	; 0x54
    a5f4:	4642      	mov	r2, r8
    a5f6:	eeb0 0b4a 	vmov.f64	d0, d10
    a5fa:	9805      	ldr	r0, [sp, #20]
    a5fc:	f7fd fff8 	bl	85f0 <_dtoa_r>
    a600:	4644      	mov	r4, r8
    a602:	4606      	mov	r6, r0
    a604:	eb00 0108 	add.w	r1, r0, r8
    a608:	e6ef      	b.n	a3ea <_svfprintf_r+0x1172>
    a60a:	f04f 0806 	mov.w	r8, #6
    a60e:	e5da      	b.n	a1c6 <_svfprintf_r+0xf4e>
    a610:	eeb1 ab48 	vneg.f64	d10, d8
    a614:	272d      	movs	r7, #45	; 0x2d
    a616:	e5e1      	b.n	a1dc <_svfprintf_r+0xf64>
    a618:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a61a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    a61c:	4413      	add	r3, r2
    a61e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    a620:	9308      	str	r3, [sp, #32]
    a622:	2a00      	cmp	r2, #0
    a624:	f340 8086 	ble.w	a734 <_svfprintf_r+0x14bc>
    a628:	2267      	movs	r2, #103	; 0x67
    a62a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a62e:	920c      	str	r2, [sp, #48]	; 0x30
    a630:	e623      	b.n	a27a <_svfprintf_r+0x1002>
    a632:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a634:	2b47      	cmp	r3, #71	; 0x47
    a636:	f47f adf2 	bne.w	a21e <_svfprintf_r+0xfa6>
    a63a:	f01b 0f01 	tst.w	fp, #1
    a63e:	f47f aece 	bne.w	a3de <_svfprintf_r+0x1166>
    a642:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a644:	2d47      	cmp	r5, #71	; 0x47
    a646:	eba3 0306 	sub.w	r3, r3, r6
    a64a:	930d      	str	r3, [sp, #52]	; 0x34
    a64c:	f43f af1c 	beq.w	a488 <_svfprintf_r+0x1210>
    a650:	9b15      	ldr	r3, [sp, #84]	; 0x54
    a652:	e722      	b.n	a49a <_svfprintf_r+0x1222>
    a654:	2b00      	cmp	r3, #0
    a656:	461a      	mov	r2, r3
    a658:	930e      	str	r3, [sp, #56]	; 0x38
    a65a:	dd73      	ble.n	a744 <_svfprintf_r+0x14cc>
    a65c:	f1b8 0f00 	cmp.w	r8, #0
    a660:	d14b      	bne.n	a6fa <_svfprintf_r+0x1482>
    a662:	f01b 0f01 	tst.w	fp, #1
    a666:	d148      	bne.n	a6fa <_svfprintf_r+0x1482>
    a668:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a66c:	9208      	str	r2, [sp, #32]
    a66e:	e604      	b.n	a27a <_svfprintf_r+0x1002>
    a670:	f01b 0f01 	tst.w	fp, #1
    a674:	4647      	mov	r7, r8
    a676:	d005      	beq.n	a684 <_svfprintf_r+0x140c>
    a678:	ae38      	add	r6, sp, #224	; 0xe0
    a67a:	2330      	movs	r3, #48	; 0x30
    a67c:	f806 3d41 	strb.w	r3, [r6, #-65]!
    a680:	f7ff b956 	b.w	9930 <_svfprintf_r+0x6b8>
    a684:	f8cd 8020 	str.w	r8, [sp, #32]
    a688:	ae28      	add	r6, sp, #160	; 0xa0
    a68a:	f7ff b954 	b.w	9936 <_svfprintf_r+0x6be>
    a68e:	ea25 73e5 	bic.w	r3, r5, r5, asr #31
    a692:	9709      	str	r7, [sp, #36]	; 0x24
    a694:	9304      	str	r3, [sp, #16]
    a696:	9508      	str	r5, [sp, #32]
    a698:	4680      	mov	r8, r0
    a69a:	900e      	str	r0, [sp, #56]	; 0x38
    a69c:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    a6a0:	f7fe bfdc 	b.w	965c <_svfprintf_r+0x3e4>
    a6a4:	aa1b      	add	r2, sp, #108	; 0x6c
    a6a6:	9903      	ldr	r1, [sp, #12]
    a6a8:	9805      	ldr	r0, [sp, #20]
    a6aa:	f000 f89d 	bl	a7e8 <__ssprint_r>
    a6ae:	2800      	cmp	r0, #0
    a6b0:	f47e aed8 	bne.w	9464 <_svfprintf_r+0x1ec>
    a6b4:	9c15      	ldr	r4, [sp, #84]	; 0x54
    a6b6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    a6b8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    a6ba:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    a6be:	e63d      	b.n	a33c <_svfprintf_r+0x10c4>
    a6c0:	46a2      	mov	sl, r4
    a6c2:	2500      	movs	r5, #0
    a6c4:	f7fe be33 	b.w	932e <_svfprintf_r+0xb6>
    a6c8:	3330      	adds	r3, #48	; 0x30
    a6ca:	2230      	movs	r2, #48	; 0x30
    a6cc:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    a6d0:	f88d 205e 	strb.w	r2, [sp, #94]	; 0x5e
    a6d4:	ab18      	add	r3, sp, #96	; 0x60
    a6d6:	e71c      	b.n	a512 <_svfprintf_r+0x129a>
    a6d8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a6da:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a6dc:	4413      	add	r3, r2
    a6de:	2267      	movs	r2, #103	; 0x67
    a6e0:	9308      	str	r3, [sp, #32]
    a6e2:	920c      	str	r2, [sp, #48]	; 0x30
    a6e4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a6e8:	e5c7      	b.n	a27a <_svfprintf_r+0x1002>
    a6ea:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a6ec:	e5a8      	b.n	a240 <_svfprintf_r+0xfc8>
    a6ee:	4e3c      	ldr	r6, [pc, #240]	; (a7e0 <_svfprintf_r+0x1568>)
    a6f0:	4b3c      	ldr	r3, [pc, #240]	; (a7e4 <_svfprintf_r+0x156c>)
    a6f2:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    a6f6:	f7fe bfa4 	b.w	9642 <_svfprintf_r+0x3ca>
    a6fa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a6fc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a6fe:	189d      	adds	r5, r3, r2
    a700:	eb05 0308 	add.w	r3, r5, r8
    a704:	9308      	str	r3, [sp, #32]
    a706:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a70a:	e5b6      	b.n	a27a <_svfprintf_r+0x1002>
    a70c:	eeb5 ab40 	vcmp.f64	d10, #0.0
    a710:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a714:	f43f ae6d 	beq.w	a3f2 <_svfprintf_r+0x117a>
    a718:	f1c4 0401 	rsb	r4, r4, #1
    a71c:	9415      	str	r4, [sp, #84]	; 0x54
    a71e:	4421      	add	r1, r4
    a720:	e57e      	b.n	a220 <_svfprintf_r+0xfa8>
    a722:	f01b 0301 	ands.w	r3, fp, #1
    a726:	f47f aefd 	bne.w	a524 <_svfprintf_r+0x12ac>
    a72a:	930e      	str	r3, [sp, #56]	; 0x38
    a72c:	9b08      	ldr	r3, [sp, #32]
    a72e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a732:	e5a2      	b.n	a27a <_svfprintf_r+0x1002>
    a734:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a736:	9a08      	ldr	r2, [sp, #32]
    a738:	f1c3 0301 	rsb	r3, r3, #1
    a73c:	441a      	add	r2, r3
    a73e:	4613      	mov	r3, r2
    a740:	9208      	str	r2, [sp, #32]
    a742:	e771      	b.n	a628 <_svfprintf_r+0x13b0>
    a744:	f1b8 0f00 	cmp.w	r8, #0
    a748:	d102      	bne.n	a750 <_svfprintf_r+0x14d8>
    a74a:	f01b 0f01 	tst.w	fp, #1
    a74e:	d007      	beq.n	a760 <_svfprintf_r+0x14e8>
    a750:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    a752:	1c5d      	adds	r5, r3, #1
    a754:	eb05 0308 	add.w	r3, r5, r8
    a758:	9308      	str	r3, [sp, #32]
    a75a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a75e:	e58c      	b.n	a27a <_svfprintf_r+0x1002>
    a760:	2301      	movs	r3, #1
    a762:	9308      	str	r3, [sp, #32]
    a764:	e589      	b.n	a27a <_svfprintf_r+0x1002>
    a766:	9809      	ldr	r0, [sp, #36]	; 0x24
    a768:	f89a 3001 	ldrb.w	r3, [sl, #1]
    a76c:	6805      	ldr	r5, [r0, #0]
    a76e:	3004      	adds	r0, #4
    a770:	2d00      	cmp	r5, #0
    a772:	9009      	str	r0, [sp, #36]	; 0x24
    a774:	46a2      	mov	sl, r4
    a776:	f6be add8 	bge.w	932a <_svfprintf_r+0xb2>
    a77a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    a77e:	f7fe bdd4 	b.w	932a <_svfprintf_r+0xb2>
    a782:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a786:	f7ff b98d 	b.w	9aa4 <_svfprintf_r+0x82c>
    a78a:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a78e:	f7ff b9cf 	b.w	9b30 <_svfprintf_r+0x8b8>
    a792:	9a05      	ldr	r2, [sp, #20]
    a794:	230c      	movs	r3, #12
    a796:	6013      	str	r3, [r2, #0]
    a798:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a79c:	f7fe be6b 	b.w	9476 <_svfprintf_r+0x1fe>
    a7a0:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a7a4:	f7ff b8d4 	b.w	9950 <_svfprintf_r+0x6d8>
    a7a8:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a7ac:	f7ff b8a3 	b.w	98f6 <_svfprintf_r+0x67e>
    a7b0:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a7b4:	f7ff b952 	b.w	9a5c <_svfprintf_r+0x7e4>
    a7b8:	f10d 035e 	add.w	r3, sp, #94	; 0x5e
    a7bc:	e6a9      	b.n	a512 <_svfprintf_r+0x129a>
    a7be:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a7c2:	f7fe be62 	b.w	948a <_svfprintf_r+0x212>
    a7c6:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a7ca:	f7ff b862 	b.w	9892 <_svfprintf_r+0x61a>
    a7ce:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a7d2:	f7fe bf16 	b.w	9602 <_svfprintf_r+0x38a>
    a7d6:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a7da:	f7fe bed0 	b.w	957e <_svfprintf_r+0x306>
    a7de:	bf00      	nop
    a7e0:	20000e58 	.word	0x20000e58
    a7e4:	20000e54 	.word	0x20000e54

0000a7e8 <__ssprint_r>:
    a7e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a7ec:	6893      	ldr	r3, [r2, #8]
    a7ee:	b083      	sub	sp, #12
    a7f0:	4690      	mov	r8, r2
    a7f2:	2b00      	cmp	r3, #0
    a7f4:	d072      	beq.n	a8dc <__ssprint_r+0xf4>
    a7f6:	4683      	mov	fp, r0
    a7f8:	f04f 0900 	mov.w	r9, #0
    a7fc:	6816      	ldr	r6, [r2, #0]
    a7fe:	6808      	ldr	r0, [r1, #0]
    a800:	688b      	ldr	r3, [r1, #8]
    a802:	460d      	mov	r5, r1
    a804:	464c      	mov	r4, r9
    a806:	2c00      	cmp	r4, #0
    a808:	d045      	beq.n	a896 <__ssprint_r+0xae>
    a80a:	429c      	cmp	r4, r3
    a80c:	461f      	mov	r7, r3
    a80e:	469a      	mov	sl, r3
    a810:	d346      	bcc.n	a8a0 <__ssprint_r+0xb8>
    a812:	89ab      	ldrh	r3, [r5, #12]
    a814:	f413 6f90 	tst.w	r3, #1152	; 0x480
    a818:	d02d      	beq.n	a876 <__ssprint_r+0x8e>
    a81a:	696f      	ldr	r7, [r5, #20]
    a81c:	6929      	ldr	r1, [r5, #16]
    a81e:	eb07 0747 	add.w	r7, r7, r7, lsl #1
    a822:	ebc1 0a00 	rsb	sl, r1, r0
    a826:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
    a82a:	1c60      	adds	r0, r4, #1
    a82c:	107f      	asrs	r7, r7, #1
    a82e:	4450      	add	r0, sl
    a830:	42b8      	cmp	r0, r7
    a832:	463a      	mov	r2, r7
    a834:	bf84      	itt	hi
    a836:	4607      	movhi	r7, r0
    a838:	463a      	movhi	r2, r7
    a83a:	055b      	lsls	r3, r3, #21
    a83c:	d533      	bpl.n	a8a6 <__ssprint_r+0xbe>
    a83e:	4611      	mov	r1, r2
    a840:	4658      	mov	r0, fp
    a842:	f7fb ff6b 	bl	671c <_malloc_r>
    a846:	2800      	cmp	r0, #0
    a848:	d037      	beq.n	a8ba <__ssprint_r+0xd2>
    a84a:	4652      	mov	r2, sl
    a84c:	6929      	ldr	r1, [r5, #16]
    a84e:	9001      	str	r0, [sp, #4]
    a850:	f7fc fa32 	bl	6cb8 <memcpy>
    a854:	89aa      	ldrh	r2, [r5, #12]
    a856:	9b01      	ldr	r3, [sp, #4]
    a858:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    a85c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    a860:	81aa      	strh	r2, [r5, #12]
    a862:	ebca 0207 	rsb	r2, sl, r7
    a866:	eb03 000a 	add.w	r0, r3, sl
    a86a:	616f      	str	r7, [r5, #20]
    a86c:	612b      	str	r3, [r5, #16]
    a86e:	6028      	str	r0, [r5, #0]
    a870:	60aa      	str	r2, [r5, #8]
    a872:	4627      	mov	r7, r4
    a874:	46a2      	mov	sl, r4
    a876:	4652      	mov	r2, sl
    a878:	4649      	mov	r1, r9
    a87a:	f7fc fab7 	bl	6dec <memmove>
    a87e:	f8d8 2008 	ldr.w	r2, [r8, #8]
    a882:	68ab      	ldr	r3, [r5, #8]
    a884:	6828      	ldr	r0, [r5, #0]
    a886:	1bdb      	subs	r3, r3, r7
    a888:	4450      	add	r0, sl
    a88a:	1b14      	subs	r4, r2, r4
    a88c:	60ab      	str	r3, [r5, #8]
    a88e:	6028      	str	r0, [r5, #0]
    a890:	f8c8 4008 	str.w	r4, [r8, #8]
    a894:	b314      	cbz	r4, a8dc <__ssprint_r+0xf4>
    a896:	f8d6 9000 	ldr.w	r9, [r6]
    a89a:	6874      	ldr	r4, [r6, #4]
    a89c:	3608      	adds	r6, #8
    a89e:	e7b2      	b.n	a806 <__ssprint_r+0x1e>
    a8a0:	4627      	mov	r7, r4
    a8a2:	46a2      	mov	sl, r4
    a8a4:	e7e7      	b.n	a876 <__ssprint_r+0x8e>
    a8a6:	4658      	mov	r0, fp
    a8a8:	f7fc fb5e 	bl	6f68 <_realloc_r>
    a8ac:	4603      	mov	r3, r0
    a8ae:	2800      	cmp	r0, #0
    a8b0:	d1d7      	bne.n	a862 <__ssprint_r+0x7a>
    a8b2:	6929      	ldr	r1, [r5, #16]
    a8b4:	4658      	mov	r0, fp
    a8b6:	f7fd f947 	bl	7b48 <_free_r>
    a8ba:	230c      	movs	r3, #12
    a8bc:	f8cb 3000 	str.w	r3, [fp]
    a8c0:	89ab      	ldrh	r3, [r5, #12]
    a8c2:	2200      	movs	r2, #0
    a8c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a8c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a8cc:	81ab      	strh	r3, [r5, #12]
    a8ce:	f8c8 2008 	str.w	r2, [r8, #8]
    a8d2:	f8c8 2004 	str.w	r2, [r8, #4]
    a8d6:	b003      	add	sp, #12
    a8d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a8dc:	2000      	movs	r0, #0
    a8de:	f8c8 0004 	str.w	r0, [r8, #4]
    a8e2:	b003      	add	sp, #12
    a8e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000a8e8 <___init_veneer>:
    a8e8:	f85f f000 	ldr.w	pc, [pc]	; a8ec <___init_veneer+0x4>
    a8ec:	6000204d 	.word	0x6000204d

0000a8f0 <___ZN7TwoWire5beginEv_veneer>:
    a8f0:	f85f f000 	ldr.w	pc, [pc]	; a8f4 <___ZN7TwoWire5beginEv_veneer+0x4>
    a8f4:	60001e19 	.word	0x60001e19

0000a8f8 <___reboot_Teensyduino__veneer>:
    a8f8:	f85f f000 	ldr.w	pc, [pc]	; a8fc <___reboot_Teensyduino__veneer+0x4>
    a8fc:	60001dc5 	.word	0x60001dc5

Disassembly of section .fini:

0000a900 <_fini>:
    a900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a902:	bf00      	nop

Disassembly of section .text.csf:

6000ee48 <_heap_end+0x3fd8ee48>:
6000ee48:	ffffffff 	.word	0xffffffff
6000ee4c:	ffffffff 	.word	0xffffffff
6000ee50:	ffffffff 	.word	0xffffffff
6000ee54:	ffffffff 	.word	0xffffffff
6000ee58:	ffffffff 	.word	0xffffffff
6000ee5c:	ffffffff 	.word	0xffffffff
6000ee60:	ffffffff 	.word	0xffffffff
6000ee64:	ffffffff 	.word	0xffffffff
6000ee68:	ffffffff 	.word	0xffffffff
6000ee6c:	ffffffff 	.word	0xffffffff
6000ee70:	ffffffff 	.word	0xffffffff
6000ee74:	ffffffff 	.word	0xffffffff
6000ee78:	ffffffff 	.word	0xffffffff
6000ee7c:	ffffffff 	.word	0xffffffff
6000ee80:	ffffffff 	.word	0xffffffff
6000ee84:	ffffffff 	.word	0xffffffff
6000ee88:	ffffffff 	.word	0xffffffff
6000ee8c:	ffffffff 	.word	0xffffffff
6000ee90:	ffffffff 	.word	0xffffffff
6000ee94:	ffffffff 	.word	0xffffffff
6000ee98:	ffffffff 	.word	0xffffffff
6000ee9c:	ffffffff 	.word	0xffffffff
6000eea0:	ffffffff 	.word	0xffffffff
6000eea4:	ffffffff 	.word	0xffffffff
6000eea8:	ffffffff 	.word	0xffffffff
6000eeac:	ffffffff 	.word	0xffffffff
6000eeb0:	ffffffff 	.word	0xffffffff
6000eeb4:	ffffffff 	.word	0xffffffff
6000eeb8:	ffffffff 	.word	0xffffffff
6000eebc:	ffffffff 	.word	0xffffffff
6000eec0:	ffffffff 	.word	0xffffffff
6000eec4:	ffffffff 	.word	0xffffffff
6000eec8:	ffffffff 	.word	0xffffffff
6000eecc:	ffffffff 	.word	0xffffffff
6000eed0:	ffffffff 	.word	0xffffffff
6000eed4:	ffffffff 	.word	0xffffffff
6000eed8:	ffffffff 	.word	0xffffffff
6000eedc:	ffffffff 	.word	0xffffffff
6000eee0:	ffffffff 	.word	0xffffffff
6000eee4:	ffffffff 	.word	0xffffffff
6000eee8:	ffffffff 	.word	0xffffffff
6000eeec:	ffffffff 	.word	0xffffffff
6000eef0:	ffffffff 	.word	0xffffffff
6000eef4:	ffffffff 	.word	0xffffffff
6000eef8:	ffffffff 	.word	0xffffffff
6000eefc:	ffffffff 	.word	0xffffffff
6000ef00:	ffffffff 	.word	0xffffffff
6000ef04:	ffffffff 	.word	0xffffffff
6000ef08:	ffffffff 	.word	0xffffffff
6000ef0c:	ffffffff 	.word	0xffffffff
6000ef10:	ffffffff 	.word	0xffffffff
6000ef14:	ffffffff 	.word	0xffffffff
6000ef18:	ffffffff 	.word	0xffffffff
6000ef1c:	ffffffff 	.word	0xffffffff
6000ef20:	ffffffff 	.word	0xffffffff
6000ef24:	ffffffff 	.word	0xffffffff
6000ef28:	ffffffff 	.word	0xffffffff
6000ef2c:	ffffffff 	.word	0xffffffff
6000ef30:	ffffffff 	.word	0xffffffff
6000ef34:	ffffffff 	.word	0xffffffff
6000ef38:	ffffffff 	.word	0xffffffff
6000ef3c:	ffffffff 	.word	0xffffffff
6000ef40:	ffffffff 	.word	0xffffffff
6000ef44:	ffffffff 	.word	0xffffffff
6000ef48:	ffffffff 	.word	0xffffffff
6000ef4c:	ffffffff 	.word	0xffffffff
6000ef50:	ffffffff 	.word	0xffffffff
6000ef54:	ffffffff 	.word	0xffffffff
6000ef58:	ffffffff 	.word	0xffffffff
6000ef5c:	ffffffff 	.word	0xffffffff
6000ef60:	ffffffff 	.word	0xffffffff
6000ef64:	ffffffff 	.word	0xffffffff
6000ef68:	ffffffff 	.word	0xffffffff
6000ef6c:	ffffffff 	.word	0xffffffff
6000ef70:	ffffffff 	.word	0xffffffff
6000ef74:	ffffffff 	.word	0xffffffff
6000ef78:	ffffffff 	.word	0xffffffff
6000ef7c:	ffffffff 	.word	0xffffffff
6000ef80:	ffffffff 	.word	0xffffffff
6000ef84:	ffffffff 	.word	0xffffffff
6000ef88:	ffffffff 	.word	0xffffffff
6000ef8c:	ffffffff 	.word	0xffffffff
6000ef90:	ffffffff 	.word	0xffffffff
6000ef94:	ffffffff 	.word	0xffffffff
6000ef98:	ffffffff 	.word	0xffffffff
6000ef9c:	ffffffff 	.word	0xffffffff
6000efa0:	ffffffff 	.word	0xffffffff
6000efa4:	ffffffff 	.word	0xffffffff
6000efa8:	ffffffff 	.word	0xffffffff
6000efac:	ffffffff 	.word	0xffffffff
6000efb0:	ffffffff 	.word	0xffffffff
6000efb4:	ffffffff 	.word	0xffffffff
6000efb8:	ffffffff 	.word	0xffffffff
6000efbc:	ffffffff 	.word	0xffffffff
6000efc0:	ffffffff 	.word	0xffffffff
6000efc4:	ffffffff 	.word	0xffffffff
6000efc8:	ffffffff 	.word	0xffffffff
6000efcc:	ffffffff 	.word	0xffffffff
6000efd0:	ffffffff 	.word	0xffffffff
6000efd4:	ffffffff 	.word	0xffffffff
6000efd8:	ffffffff 	.word	0xffffffff
6000efdc:	ffffffff 	.word	0xffffffff
6000efe0:	ffffffff 	.word	0xffffffff
6000efe4:	ffffffff 	.word	0xffffffff
6000efe8:	ffffffff 	.word	0xffffffff
6000efec:	ffffffff 	.word	0xffffffff
6000eff0:	ffffffff 	.word	0xffffffff
6000eff4:	ffffffff 	.word	0xffffffff
6000eff8:	ffffffff 	.word	0xffffffff
6000effc:	ffffffff 	.word	0xffffffff

6000f000 <hab_csf>:
	...
