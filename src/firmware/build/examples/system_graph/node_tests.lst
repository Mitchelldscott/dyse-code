
/Users/mitchellscott/Desktop/rufous/src/firmware/build/examples/system_graph/node_tests.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001400:	4288      	cmp	r0, r1
60001402:	d007      	beq.n	60001414 <memory_copy+0x14>
	while (dest < dest_end) {
60001404:	4290      	cmp	r0, r2
60001406:	d205      	bcs.n	60001414 <memory_copy+0x14>
		*dest++ = *src++;
60001408:	f851 3b04 	ldr.w	r3, [r1], #4
6000140c:	f840 3b04 	str.w	r3, [r0], #4

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001410:	4282      	cmp	r2, r0
60001412:	d8f9      	bhi.n	60001408 <memory_copy+0x8>
60001414:	4770      	bx	lr
60001416:	bf00      	nop

60001418 <memory_clear>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001418:	4288      	cmp	r0, r1
6000141a:	d204      	bcs.n	60001426 <memory_clear+0xe>
		*dest++ = 0;
6000141c:	2300      	movs	r3, #0
6000141e:	f840 3b04 	str.w	r3, [r0], #4
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001422:	4281      	cmp	r1, r0
60001424:	d8fb      	bhi.n	6000141e <memory_clear+0x6>
60001426:	4770      	bx	lr

60001428 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001428:	4b66      	ldr	r3, [pc, #408]	; (600015c4 <ResetHandler+0x19c>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000142a:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000142e:	4a66      	ldr	r2, [pc, #408]	; (600015c8 <ResetHandler+0x1a0>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001430:	4866      	ldr	r0, [pc, #408]	; (600015cc <ResetHandler+0x1a4>)
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
void startup_late_hook(void)	__attribute__ ((weak, alias("startup_default_late_hook")));
__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
void ResetHandler(void)
{
60001432:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001436:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001438:	6418      	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143a:	4a65      	ldr	r2, [pc, #404]	; (600015d0 <ResetHandler+0x1a8>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000143c:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143e:	4695      	mov	sp, r2
	__asm__ volatile("dsb":::"memory");
60001440:	f3bf 8f4f 	dsb	sy
	__asm__ volatile("isb":::"memory");
60001444:	f3bf 8f6f 	isb	sy
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
60001448:	f000 f930 	bl	600016ac <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000144c:	4b61      	ldr	r3, [pc, #388]	; (600015d4 <ResetHandler+0x1ac>)
6000144e:	2008      	movs	r0, #8
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001450:	4a61      	ldr	r2, [pc, #388]	; (600015d8 <ResetHandler+0x1b0>)
60001452:	4962      	ldr	r1, [pc, #392]	; (600015dc <ResetHandler+0x1b4>)
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
	__asm__ volatile("dsb":::"memory");
	__asm__ volatile("isb":::"memory");
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001454:	f8c3 0154 	str.w	r0, [r3, #340]	; 0x154
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001458:	4861      	ldr	r0, [pc, #388]	; (600015e0 <ResetHandler+0x1b8>)
6000145a:	f7ff ffd1 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
6000145e:	4a61      	ldr	r2, [pc, #388]	; (600015e4 <ResetHandler+0x1bc>)
60001460:	4961      	ldr	r1, [pc, #388]	; (600015e8 <ResetHandler+0x1c0>)
60001462:	4862      	ldr	r0, [pc, #392]	; (600015ec <ResetHandler+0x1c4>)
60001464:	f7ff ffcc 	bl	60001400 <memory_copy>
	memory_clear(&_sbss, &_ebss);
60001468:	4961      	ldr	r1, [pc, #388]	; (600015f0 <ResetHandler+0x1c8>)
6000146a:	4862      	ldr	r0, [pc, #392]	; (600015f4 <ResetHandler+0x1cc>)
6000146c:	f7ff ffd4 	bl	60001418 <memory_clear>
60001470:	4c61      	ldr	r4, [pc, #388]	; (600015f8 <ResetHandler+0x1d0>)

	// enable FPU
	SCB_CPACR = 0x00F00000;
60001472:	4962      	ldr	r1, [pc, #392]	; (600015fc <ResetHandler+0x1d4>)
60001474:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001478:	2300      	movs	r3, #0
6000147a:	4a61      	ldr	r2, [pc, #388]	; (60001600 <ResetHandler+0x1d8>)
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
6000147c:	6008      	str	r0, [r1, #0]

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000147e:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
60001482:	3301      	adds	r3, #1
60001484:	2bb0      	cmp	r3, #176	; 0xb0
60001486:	d1fa      	bne.n	6000147e <ResetHandler+0x56>
60001488:	4b5e      	ldr	r3, [pc, #376]	; (60001604 <ResetHandler+0x1dc>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
6000148a:	2180      	movs	r1, #128	; 0x80
6000148c:	4a5e      	ldr	r2, [pc, #376]	; (60001608 <ResetHandler+0x1e0>)
6000148e:	f803 1b01 	strb.w	r1, [r3], #1
60001492:	4293      	cmp	r3, r2
60001494:	d1fb      	bne.n	6000148e <ResetHandler+0x66>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001496:	4d4f      	ldr	r5, [pc, #316]	; (600015d4 <ResetHandler+0x1ac>)
60001498:	f04f 3880 	mov.w	r8, #2155905152	; 0x80808080
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
6000149c:	495b      	ldr	r1, [pc, #364]	; (6000160c <ResetHandler+0x1e4>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
6000149e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014a2:	4b5b      	ldr	r3, [pc, #364]	; (60001610 <ResetHandler+0x1e8>)
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600014a4:	2600      	movs	r6, #0

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014a6:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 6000164c <ResetHandler+0x224>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014aa:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 60001650 <ResetHandler+0x228>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014ae:	601c      	str	r4, [r3, #0]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014b0:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014b4:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014b8:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014bc:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c0:	680b      	ldr	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014c2:	4f54      	ldr	r7, [pc, #336]	; (60001614 <ResetHandler+0x1ec>)
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c4:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
600014c8:	600b      	str	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ca:	69fb      	ldr	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014cc:	493d      	ldr	r1, [pc, #244]	; (600015c4 <ResetHandler+0x19c>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ce:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014d6:	61fb      	str	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
600014da:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014e2:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014e4:	668a      	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
600014e6:	66ca      	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
600014e8:	670a      	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
600014ea:	674a      	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
600014ec:	f000 f8e4 	bl	600016b8 <configure_cache>
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f0:	4a49      	ldr	r2, [pc, #292]	; (60001618 <ResetHandler+0x1f0>)
	_VectorsRam[15] = systick_isr;
600014f2:	4b4a      	ldr	r3, [pc, #296]	; (6000161c <ResetHandler+0x1f4>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014f4:	2063      	movs	r0, #99	; 0x63
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f6:	63a2      	str	r2, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
600014f8:	2103      	movs	r1, #3

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
600014fa:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014fc:	4a48      	ldr	r2, [pc, #288]	; (60001620 <ResetHandler+0x1f8>)
	SYST_CVR = 0;
600014fe:	4b49      	ldr	r3, [pc, #292]	; (60001624 <ResetHandler+0x1fc>)
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001500:	6010      	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001502:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
60001506:	601e      	str	r6, [r3, #0]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001508:	f842 1c04 	str.w	r1, [r2, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000150c:	f600 70a1 	addw	r0, r0, #4001	; 0xfa1
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001510:	4945      	ldr	r1, [pc, #276]	; (60001628 <ResetHandler+0x200>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001512:	4a46      	ldr	r2, [pc, #280]	; (6000162c <ResetHandler+0x204>)
60001514:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001518:	680b      	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000151a:	4a45      	ldr	r2, [pc, #276]	; (60001630 <ResetHandler+0x208>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000151c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
60001520:	600b      	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001522:	6813      	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001524:	4943      	ldr	r1, [pc, #268]	; (60001634 <ResetHandler+0x20c>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001526:	f043 0301 	orr.w	r3, r3, #1
6000152a:	6013      	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000152c:	6803      	ldr	r3, [r0, #0]
6000152e:	600b      	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
60001530:	f000 fb12 	bl	60001b58 <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001534:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001538:	483f      	ldr	r0, [pc, #252]	; (60001638 <ResetHandler+0x210>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000153a:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000153e:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001542:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001546:	f000 fd9f 	bl	60002088 <__set_arm_clock_veneer>
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154a:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
6000154c:	4a3b      	ldr	r2, [pc, #236]	; (6000163c <ResetHandler+0x214>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154e:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001552:	4b3b      	ldr	r3, [pc, #236]	; (60001640 <ResetHandler+0x218>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001554:	66f9      	str	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
60001556:	6016      	str	r6, [r2, #0]
	PIT_TCTRL0 = 0;
60001558:	f8c2 6108 	str.w	r6, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000155c:	f8c2 6118 	str.w	r6, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001560:	f8c2 6128 	str.w	r6, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001564:	f8c2 6138 	str.w	r6, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001568:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000156a:	07d2      	lsls	r2, r2, #31
6000156c:	d408      	bmi.n	60001580 <ResetHandler+0x158>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000156e:	f642 6215 	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
60001572:	4934      	ldr	r1, [pc, #208]	; (60001644 <ResetHandler+0x21c>)
60001574:	6559      	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001576:	651a      	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001578:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000157a:	f042 0201 	orr.w	r2, r2, #1
6000157e:	639a      	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
60001580:	4a2f      	ldr	r2, [pc, #188]	; (60001640 <ResetHandler+0x218>)
60001582:	4c31      	ldr	r4, [pc, #196]	; (60001648 <ResetHandler+0x220>)
60001584:	6893      	ldr	r3, [r2, #8]
60001586:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
6000158a:	6093      	str	r3, [r2, #8]

#ifdef ARDUINO_TEENSY41
	configure_external_ram();
6000158c:	f000 f906 	bl	6000179c <configure_external_ram>
#endif
	analog_init();
60001590:	f000 f860 	bl	60001654 <analog_init>
	pwm_init();
60001594:	f000 fd6c 	bl	60002070 <__pwm_init_veneer>
	tempmon_init();
60001598:	f000 fb10 	bl	60001bbc <tempmon_init>
	startup_middle_hook();
6000159c:	f000 f888 	bl	600016b0 <startup_default_middle_hook>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
600015a0:	6823      	ldr	r3, [r4, #0]
#endif
	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290?p=87273&viewfull=1#post87273

	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015a2:	2b13      	cmp	r3, #19
600015a4:	d9fc      	bls.n	600015a0 <ResetHandler+0x178>
	usb_init();
600015a6:	f000 fb97 	bl	60001cd8 <usb_init>
600015aa:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015ac:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
600015b0:	d3fb      	bcc.n	600015aa <ResetHandler+0x182>
	//printf("before C++ constructors\n");
	startup_late_hook();
600015b2:	f000 f87f 	bl	600016b4 <startup_default_late_hook>
	__libc_init_array();
600015b6:	f000 fd53 	bl	60002060 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
600015ba:	f000 fd61 	bl	60002080 <__main_veneer>
	
	while (1) asm("WFI");
600015be:	bf30      	wfi
600015c0:	e7fd      	b.n	600015be <ResetHandler+0x196>
600015c2:	bf00      	nop
600015c4:	400ac000 	.word	0x400ac000
600015c8:	aaaaaaaf 	.word	0xaaaaaaaf
600015cc:	00200007 	.word	0x00200007
600015d0:	20070000 	.word	0x20070000
600015d4:	400d8000 	.word	0x400d8000
600015d8:	0000a248 	.word	0x0000a248
600015dc:	60002278 	.word	0x60002278
600015e0:	00000000 	.word	0x00000000
600015e4:	200022c0 	.word	0x200022c0
600015e8:	6000c4c4 	.word	0x6000c4c4
600015ec:	20000000 	.word	0x20000000
600015f0:	200027e0 	.word	0x200027e0
600015f4:	200022c0 	.word	0x200022c0
600015f8:	20002000 	.word	0x20002000
600015fc:	e000ed88 	.word	0xe000ed88
60001600:	00001791 	.word	0x00001791
60001604:	e000e400 	.word	0xe000e400
60001608:	e000e4a0 	.word	0xe000e4a0
6000160c:	e000ed24 	.word	0xe000ed24
60001610:	e000ed08 	.word	0xe000ed08
60001614:	400fc000 	.word	0x400fc000
60001618:	000028f1 	.word	0x000028f1
6000161c:	000028f5 	.word	0x000028f5
60001620:	e000e014 	.word	0xe000e014
60001624:	e000e018 	.word	0xe000e018
60001628:	e000edfc 	.word	0xe000edfc
6000162c:	20200000 	.word	0x20200000
60001630:	e0001000 	.word	0xe0001000
60001634:	2000273c 	.word	0x2000273c
60001638:	23c34600 	.word	0x23c34600
6000163c:	40084000 	.word	0x40084000
60001640:	400d4000 	.word	0x400d4000
60001644:	56c00000 	.word	0x56c00000
60001648:	20002740 	.word	0x20002740
6000164c:	2018101b 	.word	0x2018101b
60001650:	13110d0c 	.word	0x13110d0c

60001654 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001654:	4b11      	ldr	r3, [pc, #68]	; (6000169c <analog_init+0x48>)
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001656:	4912      	ldr	r1, [pc, #72]	; (600016a0 <analog_init+0x4c>)
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001658:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
6000165a:	460a      	mov	r2, r1
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
6000165c:	f440 3040 	orr.w	r0, r0, #196608	; 0x30000
}

#define MAX_ADC_CLOCK 20000000

FLASHMEM void analog_init(void)
{
60001660:	b430      	push	{r4, r5}
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001662:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001664:	f240 6537 	movw	r5, #1591	; 0x637
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001668:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
6000166a:	24a0      	movs	r4, #160	; 0xa0
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
6000166c:	f440 7040 	orr.w	r0, r0, #768	; 0x300
60001670:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001672:	644d      	str	r5, [r1, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001674:	648c      	str	r4, [r1, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
60001676:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001678:	061b      	lsls	r3, r3, #24
6000167a:	d4fc      	bmi.n	60001676 <analog_init+0x22>
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
6000167c:	4b09      	ldr	r3, [pc, #36]	; (600016a4 <analog_init+0x50>)
6000167e:	f240 6037 	movw	r0, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001682:	21a0      	movs	r1, #160	; 0xa0
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
60001684:	461a      	mov	r2, r3
	while (ADC1_GC & ADC_GC_CAL) {
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001686:	6458      	str	r0, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001688:	6499      	str	r1, [r3, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
6000168a:	6c93      	ldr	r3, [r2, #72]	; 0x48
6000168c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
60001690:	d1fb      	bne.n	6000168a <analog_init+0x36>
		//yield();
	}
	calibrating = 0;
60001692:	4a05      	ldr	r2, [pc, #20]	; (600016a8 <analog_init+0x54>)
60001694:	7013      	strb	r3, [r2, #0]
}
60001696:	bc30      	pop	{r4, r5}
60001698:	4770      	bx	lr
6000169a:	bf00      	nop
6000169c:	400fc000 	.word	0x400fc000
600016a0:	400c4000 	.word	0x400c4000
600016a4:	400c8000 	.word	0x400c8000
600016a8:	20002751 	.word	0x20002751

600016ac <startup_default_early_hook>:
600016ac:	4770      	bx	lr
600016ae:	bf00      	nop

600016b0 <startup_default_middle_hook>:
600016b0:	4770      	bx	lr
600016b2:	bf00      	nop

600016b4 <startup_default_late_hook>:
extern int main (void);
FLASHMEM void startup_default_early_hook(void) {}
void startup_early_hook(void)	__attribute__ ((weak, alias("startup_default_early_hook")));
FLASHMEM void startup_default_middle_hook(void) {}
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
600016b4:	4770      	bx	lr
600016b6:	bf00      	nop

600016b8 <configure_cache>:
#define SIZE_2G		(SCB_MPU_RASR_SIZE(30) | SCB_MPU_RASR_ENABLE)
#define SIZE_4G		(SCB_MPU_RASR_SIZE(31) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
600016b8:	b5f0      	push	{r4, r5, r6, r7, lr}
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016ba:	4a24      	ldr	r2, [pc, #144]	; (6000174c <configure_cache+0x94>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016bc:	2000      	movs	r0, #0

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016be:	4b24      	ldr	r3, [pc, #144]	; (60001750 <configure_cache+0x98>)
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016c0:	f04f 0c10 	mov.w	ip, #16
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016c4:	4c23      	ldr	r4, [pc, #140]	; (60001754 <configure_cache+0x9c>)

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016c6:	2611      	movs	r6, #17

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016c8:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 60001794 <configure_cache+0xdc>
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016cc:	2712      	movs	r7, #18
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016ce:	6020      	str	r0, [r4, #0]
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600016d0:	2501      	movs	r5, #1
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016d2:	f8c2 c000 	str.w	ip, [r2]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016d6:	f8c3 e000 	str.w	lr, [r3]
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016da:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016dc:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 60001798 <configure_cache+0xe0>

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016e0:	4e1d      	ldr	r6, [pc, #116]	; (60001758 <configure_cache+0xa0>)
	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016e2:	f8c3 e000 	str.w	lr, [r3]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016e6:	491d      	ldr	r1, [pc, #116]	; (6000175c <configure_cache+0xa4>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016e8:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016ea:	601e      	str	r6, [r3, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016ec:	f041 0115 	orr.w	r1, r1, #21
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f0:	4f1b      	ldr	r7, [pc, #108]	; (60001760 <configure_cache+0xa8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f2:	4e1c      	ldr	r6, [pc, #112]	; (60001764 <configure_cache+0xac>)
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f4:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f6:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016f8:	4f1b      	ldr	r7, [pc, #108]	; (60001768 <configure_cache+0xb0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fa:	4e1c      	ldr	r6, [pc, #112]	; (6000176c <configure_cache+0xb4>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016fc:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fe:	601e      	str	r6, [r3, #0]
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001700:	4f1b      	ldr	r7, [pc, #108]	; (60001770 <configure_cache+0xb8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
60001702:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
60001704:	4e1b      	ldr	r6, [pc, #108]	; (60001774 <configure_cache+0xbc>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
60001706:	491c      	ldr	r1, [pc, #112]	; (60001778 <configure_cache+0xc0>)

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001708:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
6000170a:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
6000170c:	4f1b      	ldr	r7, [pc, #108]	; (6000177c <configure_cache+0xc4>)
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
6000170e:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001710:	4e1b      	ldr	r6, [pc, #108]	; (60001780 <configure_cache+0xc8>)

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
60001712:	491c      	ldr	r1, [pc, #112]	; (60001784 <configure_cache+0xcc>)
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
60001714:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001716:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001718:	4f1b      	ldr	r7, [pc, #108]	; (60001788 <configure_cache+0xd0>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
6000171a:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
6000171c:	4e1b      	ldr	r6, [pc, #108]	; (6000178c <configure_cache+0xd4>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
6000171e:	491c      	ldr	r1, [pc, #112]	; (60001790 <configure_cache+0xd8>)

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001720:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
60001722:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
60001724:	6019      	str	r1, [r3, #0]

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
60001726:	6025      	str	r5, [r4, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
60001728:	f3bf 8f4f 	dsb	sy
	asm("isb");
6000172c:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
60001730:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0

	asm("dsb");
60001734:	f3bf 8f4f 	dsb	sy
	asm("isb");
60001738:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000173c:	f852 3c88 	ldr.w	r3, [r2, #-136]
60001740:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
60001744:	f842 3c88 	str.w	r3, [r2, #-136]
60001748:	bdf0      	pop	{r4, r5, r6, r7, pc}
6000174a:	bf00      	nop
6000174c:	e000ed9c 	.word	0xe000ed9c
60001750:	e000eda0 	.word	0xe000eda0
60001754:	e000ed94 	.word	0xe000ed94
60001758:	00100009 	.word	0x00100009
6000175c:	200027e0 	.word	0x200027e0
60001760:	00200013 	.word	0x00200013
60001764:	07020021 	.word	0x07020021
60001768:	20000014 	.word	0x20000014
6000176c:	13080025 	.word	0x13080025
60001770:	10000009 	.word	0x10000009
60001774:	20200016 	.word	0x20200016
60001778:	130b0027 	.word	0x130b0027
6000177c:	40000017 	.word	0x40000017
60001780:	13100033 	.word	0x13100033
60001784:	60000018 	.word	0x60000018
60001788:	070b002f 	.word	0x070b002f
6000178c:	70000019 	.word	0x70000019
60001790:	130b002f 	.word	0x130b002f
60001794:	1000003f 	.word	0x1000003f
60001798:	03080025 	.word	0x03080025

6000179c <configure_external_ram>:
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
6000179c:	b5f0      	push	{r4, r5, r6, r7, lr}
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
6000179e:	4b8d      	ldr	r3, [pc, #564]	; (600019d4 <configure_external_ram+0x238>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017a0:	2218      	movs	r2, #24
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017a2:	4e8d      	ldr	r6, [pc, #564]	; (600019d8 <configure_external_ram+0x23c>)
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017a4:	2001      	movs	r0, #1
}

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017a6:	498d      	ldr	r1, [pc, #564]	; (600019dc <configure_external_ram+0x240>)
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
600017a8:	f248 7e0c 	movw	lr, #34572	; 0x870c

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ac:	4d8c      	ldr	r5, [pc, #560]	; (600019e0 <configure_external_ram+0x244>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
600017ae:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017b2:	4c8c      	ldr	r4, [pc, #560]	; (600019e4 <configure_external_ram+0x248>)
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
600017b4:	b083      	sub	sp, #12
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017b6:	f8c3 125c 	str.w	r1, [r3, #604]	; 0x25c
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ba:	f8c3 5260 	str.w	r5, [r3, #608]	; 0x260
	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
600017be:	2500      	movs	r5, #0
FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017c0:	f8c3 1264 	str.w	r1, [r3, #612]	; 0x264
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017c4:	f8c3 4268 	str.w	r4, [r3, #616]	; 0x268
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600017c8:	f44f 5400 	mov.w	r4, #8192	; 0x2000
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017cc:	f8c3 626c 	str.w	r6, [r3, #620]	; 0x26c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017d0:	4985      	ldr	r1, [pc, #532]	; (600019e8 <configure_external_ram+0x24c>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d2:	f8c3 6270 	str.w	r6, [r3, #624]	; 0x270
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d6:	f8c3 6274 	str.w	r6, [r3, #628]	; 0x274
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017da:	f8c3 6278 	str.w	r6, [r3, #632]	; 0x278
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
600017de:	4e83      	ldr	r6, [pc, #524]	; (600019ec <configure_external_ram+0x250>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017e0:	66da      	str	r2, [r3, #108]	; 0x6c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DQS
600017e2:	671a      	str	r2, [r3, #112]	; 0x70
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS0_B (RAM)
600017e4:	675a      	str	r2, [r3, #116]	; 0x74
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SCLK
600017e6:	679a      	str	r2, [r3, #120]	; 0x78
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
600017e8:	67da      	str	r2, [r3, #124]	; 0x7c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
600017ea:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
600017ee:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3
600017f2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600017f6:	f240 6205 	movw	r2, #1541	; 0x605
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017fa:	f8c1 032c 	str.w	r0, [r1, #812]	; 0x32c
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT = 1; // GPIO_EMC_26 for Mode: ALT8
600017fe:	f8c1 0330 	str.w	r0, [r1, #816]	; 0x330
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT = 1; // GPIO_EMC_27 for Mode: ALT8
60001802:	f8c1 0334 	str.w	r0, [r1, #820]	; 0x334
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
60001806:	f8c1 0338 	str.w	r0, [r1, #824]	; 0x338
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
6000180a:	f8c1 033c 	str.w	r0, [r1, #828]	; 0x33c
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8
6000180e:	f8c1 0350 	str.w	r0, [r1, #848]	; 0x350
	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
60001812:	4629      	mov	r1, r5
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001814:	69b3      	ldr	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
60001816:	4876      	ldr	r0, [pc, #472]	; (600019f0 <configure_external_ram+0x254>)
60001818:	4018      	ands	r0, r3
6000181a:	4b76      	ldr	r3, [pc, #472]	; (600019f4 <configure_external_ram+0x258>)
6000181c:	4303      	orrs	r3, r0
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
6000181e:	4876      	ldr	r0, [pc, #472]	; (600019f8 <configure_external_ram+0x25c>)
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001820:	61b3      	str	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);
60001822:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
60001826:	f043 030c 	orr.w	r3, r3, #12
6000182a:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
6000182e:	2602      	movs	r6, #2
	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
60001830:	6803      	ldr	r3, [r0, #0]
60001832:	4333      	orrs	r3, r6
60001834:	6003      	str	r3, [r0, #0]
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001836:	6803      	ldr	r3, [r0, #0]
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
60001838:	ea03 0e0e 	and.w	lr, r3, lr
6000183c:	4b6f      	ldr	r3, [pc, #444]	; (600019fc <configure_external_ram+0x260>)
6000183e:	ea4e 0303 	orr.w	r3, lr, r3
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001842:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 60001a34 <configure_external_ram+0x298>
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001846:	6003      	str	r3, [r0, #0]
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001848:	4b6d      	ldr	r3, [pc, #436]	; (60001a00 <configure_external_ram+0x264>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
6000184a:	6047      	str	r7, [r0, #4]
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
6000184c:	f8de 7008 	ldr.w	r7, [lr, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001850:	403b      	ands	r3, r7
	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001852:	4f6c      	ldr	r7, [pc, #432]	; (60001a04 <configure_external_ram+0x268>)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001854:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001858:	6083      	str	r3, [r0, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
6000185a:	68c3      	ldr	r3, [r0, #12]
6000185c:	f023 0378 	bic.w	r3, r3, #120	; 0x78
60001860:	60c3      	str	r3, [r0, #12]
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001862:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001864:	401f      	ands	r7, r3
60001866:	4b68      	ldr	r3, [pc, #416]	; (60001a08 <configure_external_ram+0x26c>)
60001868:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
6000186a:	4f66      	ldr	r7, [pc, #408]	; (60001a04 <configure_external_ram+0x268>)

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186c:	6203      	str	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186e:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001870:	401f      	ands	r7, r3
60001872:	4b65      	ldr	r3, [pc, #404]	; (60001a08 <configure_external_ram+0x26c>)
60001874:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF2CR0 = mask;
60001876:	4f65      	ldr	r7, [pc, #404]	; (60001a0c <configure_external_ram+0x270>)
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001878:	6243      	str	r3, [r0, #36]	; 0x24
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
6000187a:	6287      	str	r7, [r0, #40]	; 0x28
	FLEXSPI2_AHBRXBUF3CR0 = mask;
6000187c:	62c7      	str	r7, [r0, #44]	; 0x2c

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
6000187e:	f8de 30b8 	ldr.w	r3, [lr, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
60001882:	4f63      	ldr	r7, [pc, #396]	; (60001a10 <configure_external_ram+0x274>)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
60001884:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
60001888:	f043 0301 	orr.w	r3, r3, #1
6000188c:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001890:	f8de 30bc 	ldr.w	r3, [lr, #188]	; 0xbc
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
60001894:	f8df e184 	ldr.w	lr, [pc, #388]	; 60001a1c <configure_external_ram+0x280>
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001898:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
6000189c:	f043 0301 	orr.w	r3, r3, #1
600018a0:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc

	FLEXSPI2_INTEN = 0;
600018a4:	6105      	str	r5, [r0, #16]
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600018a6:	6604      	str	r4, [r0, #96]	; 0x60
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018a8:	6707      	str	r7, [r0, #112]	; 0x70
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018aa:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_FLSHA2CR0 = 0x2000; // 8 MByte
600018ae:	6644      	str	r4, [r0, #100]	; 0x64
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018b0:	6747      	str	r7, [r0, #116]	; 0x74
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018b2:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018b6:	6804      	ldr	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018b8:	4b56      	ldr	r3, [pc, #344]	; (60001a14 <configure_external_ram+0x278>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018ba:	f024 0402 	bic.w	r4, r4, #2

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018be:	4a56      	ldr	r2, [pc, #344]	; (60001a18 <configure_external_ram+0x27c>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018c0:	6004      	str	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018c2:	f8c0 e018 	str.w	lr, [r0, #24]
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018c6:	61c6      	str	r6, [r0, #28]
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018c8:	f843 1b04 	str.w	r1, [r3], #4
600018cc:	4293      	cmp	r3, r2
600018ce:	d1fb      	bne.n	600018c8 <configure_external_ram+0x12c>
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d0:	4b49      	ldr	r3, [pc, #292]	; (600019f8 <configure_external_ram+0x25c>)
600018d2:	681a      	ldr	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018d4:	4619      	mov	r1, r3

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d6:	f042 0201 	orr.w	r2, r2, #1
600018da:	601a      	str	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018dc:	680b      	ldr	r3, [r1, #0]
600018de:	4a46      	ldr	r2, [pc, #280]	; (600019f8 <configure_external_ram+0x25c>)
600018e0:	f013 0301 	ands.w	r3, r3, #1
600018e4:	d1fa      	bne.n	600018dc <configure_external_ram+0x140>

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018e6:	4e4d      	ldr	r6, [pc, #308]	; (60001a1c <configure_external_ram+0x280>)
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018e8:	2502      	movs	r5, #2

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
600018ea:	f240 64f5 	movw	r4, #1781	; 0x6f5
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
600018ee:	f240 4066 	movw	r0, #1126	; 0x466
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
600018f2:	f240 4199 	movw	r1, #1177	; 0x499
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
600018f6:	4f4a      	ldr	r7, [pc, #296]	; (60001a20 <configure_external_ram+0x284>)
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018f8:	6196      	str	r6, [r2, #24]
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
600018fa:	f242 4601 	movw	r6, #9217	; 0x2401
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018fe:	61d5      	str	r5, [r2, #28]
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001900:	f240 4535 	movw	r5, #1077	; 0x435

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
60001904:	f8c2 4200 	str.w	r4, [r2, #512]	; 0x200
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
60001908:	f242 2401 	movw	r4, #8705	; 0x2201
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
6000190c:	f8c2 0210 	str.w	r0, [r2, #528]	; 0x210

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001910:	2001      	movs	r0, #1
	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
60001912:	f8c2 1220 	str.w	r1, [r2, #544]	; 0x220
FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001916:	4611      	mov	r1, r2
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
60001918:	f8c2 7230 	str.w	r7, [r2, #560]	; 0x230
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
6000191c:	f107 475a 	add.w	r7, r7, #3657433088	; 0xda000000
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
60001920:	f8c2 6234 	str.w	r6, [r2, #564]	; 0x234
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001924:	f507 7713 	add.w	r7, r7, #588	; 0x24c
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001928:	f8c2 5240 	str.w	r5, [r2, #576]	; 0x240
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
6000192c:	4e3d      	ldr	r6, [pc, #244]	; (60001a24 <configure_external_ram+0x288>)
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
6000192e:	4d3e      	ldr	r5, [pc, #248]	; (60001a28 <configure_external_ram+0x28c>)
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001930:	f8c2 7250 	str.w	r7, [r2, #592]	; 0x250
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
60001934:	f8c2 6254 	str.w	r6, [r2, #596]	; 0x254
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
60001938:	f8c2 5260 	str.w	r5, [r2, #608]	; 0x260
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
6000193c:	f8c2 4264 	str.w	r4, [r2, #612]	; 0x264
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001940:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001944:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001948:	f8c2 00b0 	str.w	r0, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000194c:	694b      	ldr	r3, [r1, #20]
6000194e:	4a2a      	ldr	r2, [pc, #168]	; (600019f8 <configure_external_ram+0x25c>)
60001950:	07dd      	lsls	r5, r3, #31
60001952:	d5fb      	bpl.n	6000194c <configure_external_ram+0x1b0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001954:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001956:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001958:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000195c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000195e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001960:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001964:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001968:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000196c:	694b      	ldr	r3, [r1, #20]
6000196e:	4a22      	ldr	r2, [pc, #136]	; (600019f8 <configure_external_ram+0x25c>)
60001970:	07dc      	lsls	r4, r3, #31
60001972:	d5fb      	bpl.n	6000196c <configure_external_ram+0x1d0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001974:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001976:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001978:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000197c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000197e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001980:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001984:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001988:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000198c:	694b      	ldr	r3, [r1, #20]
6000198e:	4a1a      	ldr	r2, [pc, #104]	; (600019f8 <configure_external_ram+0x25c>)
60001990:	07d8      	lsls	r0, r3, #31
60001992:	d5fb      	bpl.n	6000198c <configure_external_ram+0x1f0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001994:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001996:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001998:	4824      	ldr	r0, [pc, #144]	; (60001a2c <configure_external_ram+0x290>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000199a:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000199c:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000199e:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
600019a2:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
600019a6:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
600019aa:	694b      	ldr	r3, [r1, #20]
600019ac:	4a12      	ldr	r2, [pc, #72]	; (600019f8 <configure_external_ram+0x25c>)
600019ae:	07db      	lsls	r3, r3, #31
600019b0:	d5fb      	bpl.n	600019aa <configure_external_ram+0x20e>
	uint32_t id = FLEXSPI2_RFDR0;
600019b2:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019b6:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019ba:	2021      	movs	r0, #33	; 0x21

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019bc:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019be:	6150      	str	r0, [r2, #20]

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019c0:	428b      	cmp	r3, r1
600019c2:	d039      	beq.n	60001a38 <configure_external_ram+0x29c>
			external_psram_size * 0x100000 -
			((uint32_t)&_extram_end - (uint32_t)&_extram_start),
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
600019c4:	4b1a      	ldr	r3, [pc, #104]	; (60001a30 <configure_external_ram+0x294>)
600019c6:	2200      	movs	r2, #0
600019c8:	601a      	str	r2, [r3, #0]
600019ca:	605a      	str	r2, [r3, #4]
600019cc:	609a      	str	r2, [r3, #8]
600019ce:	60da      	str	r2, [r3, #12]
	}
}
600019d0:	b003      	add	sp, #12
600019d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
600019d4:	401f8000 	.word	0x401f8000
600019d8:	000170f9 	.word	0x000170f9
600019dc:	0001b0f9 	.word	0x0001b0f9
600019e0:	000110f9 	.word	0x000110f9
600019e4:	000100f9 	.word	0x000100f9
600019e8:	401f8400 	.word	0x401f8400
600019ec:	400fc000 	.word	0x400fc000
600019f0:	1ffffcff 	.word	0x1ffffcff
600019f4:	a0000300 	.word	0xa0000300
600019f8:	402a4000 	.word	0x402a4000
600019fc:	ffff0012 	.word	0xffff0012
60001a00:	00f737ff 	.word	0x00f737ff
60001a04:	7cf0ff00 	.word	0x7cf0ff00
60001a08:	80000040 	.word	0x80000040
60001a0c:	830f00ff 	.word	0x830f00ff
60001a10:	00020063 	.word	0x00020063
60001a14:	402a4200 	.word	0x402a4200
60001a18:	402a4300 	.word	0x402a4300
60001a1c:	5af05af0 	.word	0x5af05af0
60001a20:	3018049f 	.word	0x3018049f
60001a24:	26013206 	.word	0x26013206
60001a28:	0a180638 	.word	0x0a180638
60001a2c:	00030004 	.word	0x00030004
60001a30:	200027a4 	.word	0x200027a4
60001a34:	402a8000 	.word	0x402a8000
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a38:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a3a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a3e:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a40:	4611      	mov	r1, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a42:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a46:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a4a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a4e:	694b      	ldr	r3, [r1, #20]
60001a50:	4a3b      	ldr	r2, [pc, #236]	; (60001b40 <configure_external_ram+0x3a4>)
60001a52:	07df      	lsls	r7, r3, #31
60001a54:	d5fb      	bpl.n	60001a4e <configure_external_ram+0x2b2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a56:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a58:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a5c:	2000      	movs	r0, #0
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a5e:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a60:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a62:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a66:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a6a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a6e:	694b      	ldr	r3, [r1, #20]
60001a70:	4a33      	ldr	r2, [pc, #204]	; (60001b40 <configure_external_ram+0x3a4>)
60001a72:	07de      	lsls	r6, r3, #31
60001a74:	d5fb      	bpl.n	60001a6e <configure_external_ram+0x2d2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a76:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a78:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a7c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a80:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a82:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a84:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a88:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a8c:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a90:	694b      	ldr	r3, [r1, #20]
60001a92:	4a2b      	ldr	r2, [pc, #172]	; (60001b40 <configure_external_ram+0x3a4>)
60001a94:	07dd      	lsls	r5, r3, #31
60001a96:	d5fb      	bpl.n	60001a90 <configure_external_ram+0x2f4>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a98:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a9a:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a9e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001aa2:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aa4:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001aa6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001aaa:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001aae:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ab2:	694b      	ldr	r3, [r1, #20]
60001ab4:	4a22      	ldr	r2, [pc, #136]	; (60001b40 <configure_external_ram+0x3a4>)
60001ab6:	07dc      	lsls	r4, r3, #31
60001ab8:	d5fb      	bpl.n	60001ab2 <configure_external_ram+0x316>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aba:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001abc:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001ac0:	4820      	ldr	r0, [pc, #128]	; (60001b44 <configure_external_ram+0x3a8>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ac2:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001ac4:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001ac6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001aca:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001ace:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ad2:	694b      	ldr	r3, [r1, #20]
60001ad4:	4a1a      	ldr	r2, [pc, #104]	; (60001b40 <configure_external_ram+0x3a4>)
60001ad6:	07d8      	lsls	r0, r3, #31
60001ad8:	d5fb      	bpl.n	60001ad2 <configure_external_ram+0x336>
	uint32_t id = FLEXSPI2_RFDR0;
60001ada:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ade:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae2:	2021      	movs	r0, #33	; 0x21
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae4:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae6:	6150      	str	r0, [r2, #20]
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae8:	428b      	cmp	r3, r1
60001aea:	d010      	beq.n	60001b0e <configure_external_ram+0x372>
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
		} else {
			// One PSRAM chip is present, 8 MByte
			external_psram_size = 8;
60001aec:	4b16      	ldr	r3, [pc, #88]	; (60001b48 <configure_external_ram+0x3ac>)
60001aee:	2208      	movs	r2, #8
60001af0:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
60001af4:	701a      	strb	r2, [r3, #0]
		}
		// TODO: zero uninitialized EXTMEM variables
		// TODO: copy from flash to initialize EXTMEM variables
		sm_set_pool(&extmem_smalloc_pool, &_extram_end,
60001af6:	4915      	ldr	r1, [pc, #84]	; (60001b4c <configure_external_ram+0x3b0>)
60001af8:	2000      	movs	r0, #0
60001afa:	4a15      	ldr	r2, [pc, #84]	; (60001b50 <configure_external_ram+0x3b4>)
60001afc:	2301      	movs	r3, #1
60001afe:	9000      	str	r0, [sp, #0]
60001b00:	1a52      	subs	r2, r2, r1
60001b02:	4814      	ldr	r0, [pc, #80]	; (60001b54 <configure_external_ram+0x3b8>)
60001b04:	4422      	add	r2, r4
60001b06:	f000 fac3 	bl	60002090 <__sm_set_pool_veneer>
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
	}
}
60001b0a:	b003      	add	sp, #12
60001b0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b0e:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b12:	f44f 2180 	mov.w	r1, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b16:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b18:	4610      	mov	r0, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b1a:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b1e:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b22:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b26:	6943      	ldr	r3, [r0, #20]
60001b28:	4905      	ldr	r1, [pc, #20]	; (60001b40 <configure_external_ram+0x3a4>)
60001b2a:	07db      	lsls	r3, r3, #31
60001b2c:	d5fb      	bpl.n	60001b26 <configure_external_ram+0x38a>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b2e:	2001      	movs	r0, #1
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b30:	4b05      	ldr	r3, [pc, #20]	; (60001b48 <configure_external_ram+0x3ac>)
60001b32:	2210      	movs	r2, #16
60001b34:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b38:	6148      	str	r0, [r1, #20]
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b3a:	701a      	strb	r2, [r3, #0]
60001b3c:	e7db      	b.n	60001af6 <configure_external_ram+0x35a>
60001b3e:	bf00      	nop
60001b40:	402a4000 	.word	0x402a4000
60001b44:	00030004 	.word	0x00030004
60001b48:	20002752 	.word	0x20002752
60001b4c:	70000000 	.word	0x70000000
60001b50:	70000000 	.word	0x70000000
60001b54:	200027a4 	.word	0x200027a4

60001b58 <usb_pll_start>:

#endif // ARDUINO_TEENSY41


FLASHMEM void usb_pll_start()
{
60001b58:	b4f0      	push	{r4, r5, r6, r7}
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b5a:	4a17      	ldr	r2, [pc, #92]	; (60001bb8 <usb_pll_start+0x60>)
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001b5c:	2740      	movs	r7, #64	; 0x40
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001b5e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b62:	f44f 5680 	mov.w	r6, #4096	; 0x1000
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b66:	f44f 5500 	mov.w	r5, #8192	; 0x2000
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b6a:	f44f 4440 	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b6e:	f243 0042 	movw	r0, #12354	; 0x3042


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b72:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b74:	f013 0f02 	tst.w	r3, #2
60001b78:	d006      	beq.n	60001b88 <usb_pll_start+0x30>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b7a:	6194      	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001b7c:	6151      	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b7e:	6190      	str	r0, [r2, #24]


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b80:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b82:	f013 0f02 	tst.w	r3, #2
60001b86:	d1f8      	bne.n	60001b7a <usb_pll_start+0x22>
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
60001b88:	f413 5f00 	tst.w	r3, #8192	; 0x2000
60001b8c:	d101      	bne.n	60001b92 <usb_pll_start+0x3a>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b8e:	6155      	str	r5, [r2, #20]
			continue;
60001b90:	e7ef      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001b92:	f413 5f80 	tst.w	r3, #4096	; 0x1000
60001b96:	d101      	bne.n	60001b9c <usb_pll_start+0x44>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b98:	6156      	str	r6, [r2, #20]
			continue;
60001b9a:	e7ea      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
60001b9c:	2b00      	cmp	r3, #0
60001b9e:	dae8      	bge.n	60001b72 <usb_pll_start+0x1a>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
60001ba0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
60001ba4:	d001      	beq.n	60001baa <usb_pll_start+0x52>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001ba6:	6191      	str	r1, [r2, #24]
			continue;
60001ba8:	e7e3      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
60001baa:	065b      	lsls	r3, r3, #25
60001bac:	d401      	bmi.n	60001bb2 <usb_pll_start+0x5a>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001bae:	6157      	str	r7, [r2, #20]
			continue;
60001bb0:	e7df      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		return; // everything is as it should be  :-)
	}
}
60001bb2:	bcf0      	pop	{r4, r5, r6, r7}
60001bb4:	4770      	bx	lr
60001bb6:	bf00      	nop
60001bb8:	400d8000 	.word	0x400d8000

60001bbc <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bbc:	4a39      	ldr	r2, [pc, #228]	; (60001ca4 <tempmon_init+0xe8>)

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bbe:	2003      	movs	r0, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bc0:	4939      	ldr	r1, [pc, #228]	; (60001ca8 <tempmon_init+0xec>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bc2:	eef3 5a09 	vmov.f32	s11, #57	; 0x41c80000  25.0
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bc6:	6813      	ldr	r3, [r2, #0]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001bc8:	ed9f 6a38 	vldr	s12, [pc, #224]	; 60001cac <tempmon_init+0xf0>
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bcc:	f023 0301 	bic.w	r3, r3, #1
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001bd0:	eddf 6a37 	vldr	s13, [pc, #220]	; 60001cb0 <tempmon_init+0xf4>
  //asm volatile ("dsb":::"memory");
  //while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
60001bd4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bd6:	6013      	str	r3, [r2, #0]
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001bd8:	2400      	movs	r4, #0
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bda:	6110      	str	r0, [r2, #16]
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bdc:	f8d1 30e0 	ldr.w	r3, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be0:	4f34      	ldr	r7, [pc, #208]	; (60001cb4 <tempmon_init+0xf8>)
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001be2:	b2d8      	uxtb	r0, r3
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001be4:	f3c3 210b 	ubfx	r1, r3, #8, #12
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be8:	0d1b      	lsrs	r3, r3, #20
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001bea:	4e33      	ldr	r6, [pc, #204]	; (60001cb8 <tempmon_init+0xfc>)
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bec:	ee07 0a10 	vmov	s14, r0
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bf0:	ee05 1a10 	vmov	s10, r1
60001bf4:	ee07 3a90 	vmov	s15, r3
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bf8:	4b30      	ldr	r3, [pc, #192]	; (60001cbc <tempmon_init+0x100>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bfa:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001bfe:	4d30      	ldr	r5, [pc, #192]	; (60001cc0 <tempmon_init+0x104>)
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c00:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001c04:	6030      	str	r0, [r6, #0]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001c0a:	6029      	str	r1, [r5, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c0c:	492d      	ldr	r1, [pc, #180]	; (60001cc4 <tempmon_init+0x108>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c0e:	ee37 6a46 	vsub.f32	s12, s14, s12
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c12:	4e2d      	ldr	r6, [pc, #180]	; (60001cc8 <tempmon_init+0x10c>)
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c14:	ee77 7ac5 	vsub.f32	s15, s15, s10
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
60001c18:	482c      	ldr	r0, [pc, #176]	; (60001ccc <tempmon_init+0x110>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c1a:	ee77 6a66 	vsub.f32	s13, s14, s13
60001c1e:	4d2c      	ldr	r5, [pc, #176]	; (60001cd0 <tempmon_init+0x114>)
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c20:	ee37 7a65 	vsub.f32	s14, s14, s11
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c24:	ee26 6a27 	vmul.f32	s12, s12, s15
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c28:	edc7 7a00 	vstr	s15, [r7]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c2c:	ee66 6aa7 	vmul.f32	s13, s13, s15
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c30:	6817      	ldr	r7, [r2, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c32:	ee67 7a27 	vmul.f32	s15, s14, s15
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c36:	ed83 7a00 	vstr	s14, [r3]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c3a:	eec6 5a07 	vdiv.f32	s11, s12, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c3e:	ee86 6a87 	vdiv.f32	s12, s13, s14
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c42:	eec7 6a87 	vdiv.f32	s13, s15, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c46:	ee35 7a85 	vadd.f32	s14, s11, s10
60001c4a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c4e:	ee36 7a05 	vadd.f32	s14, s12, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c52:	ee17 3a90 	vmov	r3, s15
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c56:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c5a:	ea47 5303 	orr.w	r3, r7, r3, lsl #20
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c5e:	ee76 7a85 	vadd.f32	s15, s13, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c62:	6013      	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c64:	ee17 3a10 	vmov	r3, s14
60001c68:	f8d2 7110 	ldr.w	r7, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c6c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c70:	ea01 4103 	and.w	r1, r1, r3, lsl #16
60001c74:	4339      	orrs	r1, r7
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c76:	ee17 3a90 	vmov	r3, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c7a:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c7e:	f3c3 030b 	ubfx	r3, r3, #0, #12
60001c82:	f8d2 1110 	ldr.w	r1, [r2, #272]	; 0x110
60001c86:	430b      	orrs	r3, r1
60001c88:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
60001c8c:	6813      	ldr	r3, [r2, #0]
60001c8e:	f043 0302 	orr.w	r3, r3, #2
60001c92:	6013      	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c94:	7034      	strb	r4, [r6, #0]
60001c96:	f8c0 5140 	str.w	r5, [r0, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001c9a:	4b0e      	ldr	r3, [pc, #56]	; (60001cd4 <tempmon_init+0x118>)
60001c9c:	2201      	movs	r2, #1
}
60001c9e:	bcf0      	pop	{r4, r5, r6, r7}
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001ca0:	601a      	str	r2, [r3, #0]
}
60001ca2:	4770      	bx	lr
60001ca4:	400d8180 	.word	0x400d8180
60001ca8:	401f4400 	.word	0x401f4400
60001cac:	42aa0000 	.word	0x42aa0000
60001cb0:	42b40000 	.word	0x42b40000
60001cb4:	20002734 	.word	0x20002734
60001cb8:	2000272c 	.word	0x2000272c
60001cbc:	20002730 	.word	0x20002730
60001cc0:	20002728 	.word	0x20002728
60001cc4:	0fff0000 	.word	0x0fff0000
60001cc8:	e000e440 	.word	0xe000e440
60001ccc:	20002000 	.word	0x20002000
60001cd0:	00001955 	.word	0x00001955
60001cd4:	e000e108 	.word	0xe000e108

60001cd8 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001cd8:	4b30      	ldr	r3, [pc, #192]	; (60001d9c <usb_init+0xc4>)
60001cda:	f640 7261 	movw	r2, #3937	; 0xf61

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
60001cde:	b570      	push	{r4, r5, r6, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001ce0:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001ce4:	f240 4504 	movw	r5, #1028	; 0x404
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
60001ce8:	f000 f9c6 	bl	60002078 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cec:	492c      	ldr	r1, [pc, #176]	; (60001da0 <usb_init+0xc8>)
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001cee:	482d      	ldr	r0, [pc, #180]	; (60001da4 <usb_init+0xcc>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf0:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cf4:	4c2c      	ldr	r4, [pc, #176]	; (60001da8 <usb_init+0xd0>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf6:	f042 0203 	orr.w	r2, r2, #3
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cfa:	4b2c      	ldr	r3, [pc, #176]	; (60001dac <usb_init+0xd4>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cfc:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001d00:	f8c0 5160 	str.w	r5, [r0, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001d04:	6822      	ldr	r2, [r4, #0]
60001d06:	4013      	ands	r3, r2
60001d08:	b91b      	cbnz	r3, 60001d12 <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
60001d0a:	f8d0 31a8 	ldr.w	r3, [r0, #424]	; 0x1a8
60001d0e:	079a      	lsls	r2, r3, #30
60001d10:	d01a      	beq.n	60001d48 <usb_init+0x70>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d12:	4b24      	ldr	r3, [pc, #144]	; (60001da4 <usb_init+0xcc>)
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001d14:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
60001d18:	4a23      	ldr	r2, [pc, #140]	; (60001da8 <usb_init+0xd0>)
60001d1a:	6351      	str	r1, [r2, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d1c:	461a      	mov	r2, r3
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d1e:	f8d3 1140 	ldr.w	r1, [r3, #320]	; 0x140
60001d22:	f041 0102 	orr.w	r1, r1, #2
60001d26:	f8c3 1140 	str.w	r1, [r3, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d2a:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001d2e:	079b      	lsls	r3, r3, #30
60001d30:	d4fb      	bmi.n	60001d2a <usb_init+0x52>
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d32:	f44f 3000 	mov.w	r0, #131072	; 0x20000
60001d36:	491e      	ldr	r1, [pc, #120]	; (60001db0 <usb_init+0xd8>)
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d38:	4b1b      	ldr	r3, [pc, #108]	; (60001da8 <usb_init+0xd0>)
60001d3a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d3e:	6008      	str	r0, [r1, #0]
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d40:	2019      	movs	r0, #25
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d42:	639a      	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d44:	f000 f990 	bl	60002068 <__delay_veneer>
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d48:	4d1a      	ldr	r5, [pc, #104]	; (60001db4 <usb_init+0xdc>)
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d4a:	2200      	movs	r2, #0
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d4c:	4b16      	ldr	r3, [pc, #88]	; (60001da8 <usb_init+0xd0>)
60001d4e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d52:	4c14      	ldr	r4, [pc, #80]	; (60001da4 <usb_init+0xcc>)
60001d54:	260a      	movs	r6, #10
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d56:	6399      	str	r1, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d58:	4628      	mov	r0, r5
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d5a:	601a      	str	r2, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d5c:	4611      	mov	r1, r2
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d5e:	f8c4 61a8 	str.w	r6, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d62:	f44f 7220 	mov.w	r2, #640	; 0x280
60001d66:	f000 f977 	bl	60002058 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d6a:	f44f 0681 	mov.w	r6, #4227072	; 0x408000
	endpoint_queue_head[1].config = (64 << 16);
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d6e:	f240 1143 	movw	r1, #323	; 0x143
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
	endpoint_queue_head[1].config = (64 << 16);
60001d72:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
60001d76:	4b10      	ldr	r3, [pc, #64]	; (60001db8 <usb_init+0xe0>)
60001d78:	4a10      	ldr	r2, [pc, #64]	; (60001dbc <usb_init+0xe4>)
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d7a:	602e      	str	r6, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
60001d7c:	6428      	str	r0, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001d7e:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d82:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
60001d86:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d8a:	4a0d      	ldr	r2, [pc, #52]	; (60001dc0 <usb_init+0xe8>)
60001d8c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d90:	2301      	movs	r3, #1
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d92:	6011      	str	r1, [r2, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d94:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
60001d98:	bd70      	pop	{r4, r5, r6, pc}
60001d9a:	bf00      	nop
60001d9c:	400d8000 	.word	0x400d8000
60001da0:	400fc000 	.word	0x400fc000
60001da4:	402e0000 	.word	0x402e0000
60001da8:	400d9000 	.word	0x400d9000
60001dac:	001e1c00 	.word	0x001e1c00
60001db0:	e000e28c 	.word	0xe000e28c
60001db4:	20000000 	.word	0x20000000
60001db8:	20002000 	.word	0x20002000
60001dbc:	00001b21 	.word	0x00001b21
60001dc0:	e000e10c 	.word	0xe000e10c

60001dc4 <_reboot_Teensyduino_>:
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


FLASHMEM void _reboot_Teensyduino_(void)
{
60001dc4:	b508      	push	{r3, lr}
	if (!(HW_OCOTP_CFG5 & 0x02)) {
60001dc6:	4b0e      	ldr	r3, [pc, #56]	; (60001e00 <_reboot_Teensyduino_+0x3c>)
60001dc8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
60001dca:	079b      	lsls	r3, r3, #30
60001dcc:	d400      	bmi.n	60001dd0 <_reboot_Teensyduino_+0xc>
		asm("bkpt #251"); // run bootloader
60001dce:	befb      	bkpt	0x00fb
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
60001dd0:	b672      	cpsid	i
		USB1_USBCMD = 0;
60001dd2:	4b0c      	ldr	r3, [pc, #48]	; (60001e04 <_reboot_Teensyduino_+0x40>)
60001dd4:	2000      	movs	r0, #0
		IOMUXC_GPR_GPR16 = 0x00200003;
60001dd6:	4a0c      	ldr	r2, [pc, #48]	; (60001e08 <_reboot_Teensyduino_+0x44>)
{
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
60001dd8:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001ddc:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de0:	490a      	ldr	r1, [pc, #40]	; (60001e0c <_reboot_Teensyduino_+0x48>)
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de2:	f5a3 235f 	sub.w	r3, r3, #913408	; 0xdf000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de6:	6411      	str	r1, [r2, #64]	; 0x40
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de8:	469d      	mov	sp, r3
		__asm__ volatile("dsb":::"memory");
60001dea:	f3bf 8f4f 	dsb	sy
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dee:	4a08      	ldr	r2, [pc, #32]	; (60001e10 <_reboot_Teensyduino_+0x4c>)
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001df0:	f503 43e0 	add.w	r3, r3, #28672	; 0x7000
60001df4:	4907      	ldr	r1, [pc, #28]	; (60001e14 <_reboot_Teensyduino_+0x50>)
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001df6:	6812      	ldr	r2, [r2, #0]
60001df8:	4618      	mov	r0, r3
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001dfa:	6019      	str	r1, [r3, #0]
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dfc:	6893      	ldr	r3, [r2, #8]
60001dfe:	4798      	blx	r3
60001e00:	401f4400 	.word	0x401f4400
60001e04:	402e0000 	.word	0x402e0000
60001e08:	400ac000 	.word	0x400ac000
60001e0c:	00200003 	.word	0x00200003
60001e10:	0020001c 	.word	0x0020001c
60001e14:	eb120000 	.word	0xeb120000

60001e18 <TwoWire::begin()>:
//***************************************************
//  Master Mode
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
60001e18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e1c:	4f29      	ldr	r7, [pc, #164]	; (60001ec4 <TwoWire::begin()+0xac>)
#define CLOCK_STRETCH_TIMEOUT 15000


void TwoWire::setClock(uint32_t frequency)
{
	port->MCR = 0;
60001e1e:	2500      	movs	r5, #0

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e20:	6942      	ldr	r2, [r0, #20]
	port->MCR = 0;
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
60001e22:	2401      	movs	r4, #1
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e24:	6bb9      	ldr	r1, [r7, #56]	; 0x38
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e26:	f04f 0e02 	mov.w	lr, #2

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e2a:	6816      	ldr	r6, [r2, #0]
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1);
60001e2c:	f44f 3830 	mov.w	r8, #180224	; 0x2c000
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e30:	f421 017c 	bic.w	r1, r1, #16515072	; 0xfc0000
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e34:	6903      	ldr	r3, [r0, #16]
{
	port->MCR = 0;
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
60001e36:	f8df c09c 	ldr.w	ip, [pc, #156]	; 60001ed4 <TwoWire::begin()+0xbc>
//***************************************************

FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
60001e3a:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
60001e3e:	63b9      	str	r1, [r7, #56]	; 0x38
	hardware.clock_gate_register |= hardware.clock_gate_mask;
60001e40:	6831      	ldr	r1, [r6, #0]
60001e42:	6857      	ldr	r7, [r2, #4]
60001e44:	4339      	orrs	r1, r7
60001e46:	6031      	str	r1, [r6, #0]
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
	port->MCFGR0 = 0;
	port->MFCR = LPI2C_MFCR_RXWATER(1) | LPI2C_MFCR_TXWATER(1);
60001e48:	f04f 1601 	mov.w	r6, #65537	; 0x10001
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
60001e4c:	491e      	ldr	r1, [pc, #120]	; (60001ec8 <TwoWire::begin()+0xb0>)
FLASHMEM void TwoWire::begin(void)
{
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
60001e4e:	f8c3 e010 	str.w	lr, [r3, #16]
#define CLOCK_STRETCH_TIMEOUT 15000


void TwoWire::setClock(uint32_t frequency)
{
	port->MCR = 0;
60001e52:	611d      	str	r5, [r3, #16]
	if (frequency < 400000) {
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
60001e54:	f8c3 c048 	str.w	ip, [r3, #72]	; 0x48
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
60001e58:	625c      	str	r4, [r3, #36]	; 0x24
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
60001e5a:	6299      	str	r1, [r3, #40]	; 0x28
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1);
60001e5c:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | LPI2C_MCFGR2_FILTSCL(1) |
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
60001e60:	6c9f      	ldr	r7, [r3, #72]	; 0x48
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001e62:	491a      	ldr	r1, [pc, #104]	; (60001ecc <TwoWire::begin()+0xb4>)
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | LPI2C_MCFGR2_FILTSCL(1) |
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
	}
	port->MCCR1 = port->MCCR0;
60001e64:	651f      	str	r7, [r3, #80]	; 0x50
	port->MCFGR0 = 0;
60001e66:	621d      	str	r5, [r3, #32]
	port->MFCR = LPI2C_MFCR_RXWATER(1) | LPI2C_MFCR_TXWATER(1);
60001e68:	659e      	str	r6, [r3, #88]	; 0x58
	port->MCR = LPI2C_MCR_MEN;
60001e6a:	611c      	str	r4, [r3, #16]
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
	setClock(100000);
	// setSDA() & setSCL() may be called before or after begin()
	configSDApin(sda_pin_index_); // Setup SDA register
60001e6c:	7e03      	ldrb	r3, [r0, #24]
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001e6e:	4e18      	ldr	r6, [pc, #96]	; (60001ed0 <TwoWire::begin()+0xb8>)
60001e70:	eb02 1503 	add.w	r5, r2, r3, lsl #4
60001e74:	7a2c      	ldrb	r4, [r5, #8]
60001e76:	462b      	mov	r3, r5
60001e78:	eb01 1404 	add.w	r4, r1, r4, lsl #4
60001e7c:	68a4      	ldr	r4, [r4, #8]
60001e7e:	6026      	str	r6, [r4, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001e80:	7a2c      	ldrb	r4, [r5, #8]
60001e82:	68ed      	ldr	r5, [r5, #12]
60001e84:	eb01 1404 	add.w	r4, r1, r4, lsl #4
60001e88:	6864      	ldr	r4, [r4, #4]
60001e8a:	6025      	str	r5, [r4, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001e8c:	691c      	ldr	r4, [r3, #16]
60001e8e:	b10c      	cbz	r4, 60001e94 <TwoWire::begin()+0x7c>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001e90:	695b      	ldr	r3, [r3, #20]
60001e92:	6023      	str	r3, [r4, #0]
	hardware.clock_gate_register |= hardware.clock_gate_mask;
	port->MCR = LPI2C_MCR_RST;
	setClock(100000);
	// setSDA() & setSCL() may be called before or after begin()
	configSDApin(sda_pin_index_); // Setup SDA register
	configSCLpin(scl_pin_index_); // setup SCL register
60001e94:	7e40      	ldrb	r0, [r0, #25]
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001e96:	4c0e      	ldr	r4, [pc, #56]	; (60001ed0 <TwoWire::begin()+0xb8>)
60001e98:	eb02 1300 	add.w	r3, r2, r0, lsl #4
60001e9c:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
60001ea0:	461a      	mov	r2, r3
60001ea2:	eb01 1000 	add.w	r0, r1, r0, lsl #4
60001ea6:	6880      	ldr	r0, [r0, #8]
60001ea8:	6004      	str	r4, [r0, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60001eaa:	f893 4028 	ldrb.w	r4, [r3, #40]	; 0x28
60001eae:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
60001eb0:	eb01 1104 	add.w	r1, r1, r4, lsl #4
60001eb4:	684b      	ldr	r3, [r1, #4]
60001eb6:	6018      	str	r0, [r3, #0]
	if (hardware.scl_pins[i].select_input_register) {
60001eb8:	6b13      	ldr	r3, [r2, #48]	; 0x30
60001eba:	b10b      	cbz	r3, 60001ec0 <TwoWire::begin()+0xa8>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
60001ebc:	6b52      	ldr	r2, [r2, #52]	; 0x34
60001ebe:	601a      	str	r2, [r3, #0]
60001ec0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
60001ec4:	400fc000 	.word	0x400fc000
60001ec8:	05050bb8 	.word	0x05050bb8
60001ecc:	200006dc 	.word	0x200006dc
60001ed0:	0001f861 	.word	0x0001f861
60001ed4:	1928373b 	.word	0x1928373b

60001ed8 <TwoWire::setSDA(unsigned char)>:
//  Pins Configuration
//***************************************************


FLASHMEM void TwoWire::setSDA(uint8_t pin) {
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
60001ed8:	6943      	ldr	r3, [r0, #20]
60001eda:	7e02      	ldrb	r2, [r0, #24]
60001edc:	eb03 1202 	add.w	r2, r3, r2, lsl #4
//***************************************************
//  Pins Configuration
//***************************************************


FLASHMEM void TwoWire::setSDA(uint8_t pin) {
60001ee0:	b4f0      	push	{r4, r5, r6, r7}
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
60001ee2:	7a14      	ldrb	r4, [r2, #8]
60001ee4:	428c      	cmp	r4, r1
60001ee6:	d009      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
60001ee8:	7a1a      	ldrb	r2, [r3, #8]
		if (sda_pin == 255) return;
60001eea:	2aff      	cmp	r2, #255	; 0xff
60001eec:	d006      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
		if (sda_pin == pin) break;
60001eee:	428a      	cmp	r2, r1
60001ef0:	d028      	beq.n	60001f44 <TwoWire::setSDA(unsigned char)+0x6c>

FLASHMEM void TwoWire::setSDA(uint8_t pin) {
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
60001ef2:	7e1a      	ldrb	r2, [r3, #24]
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
60001ef4:	2aff      	cmp	r2, #255	; 0xff
60001ef6:	d001      	beq.n	60001efc <TwoWire::setSDA(unsigned char)+0x24>
60001ef8:	428a      	cmp	r2, r1
60001efa:	d001      	beq.n	60001f00 <TwoWire::setSDA(unsigned char)+0x28>
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
		// setup new one...
		configSDApin(newindex);
	}
	sda_pin_index_ = newindex;
}
60001efc:	bcf0      	pop	{r4, r5, r6, r7}
60001efe:	4770      	bx	lr
60001f00:	2501      	movs	r5, #1
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
60001f02:	462e      	mov	r6, r5
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
60001f04:	e893 0006 	ldmia.w	r3, {r1, r2}
60001f08:	6809      	ldr	r1, [r1, #0]
60001f0a:	4211      	tst	r1, r2
60001f0c:	d017      	beq.n	60001f3e <TwoWire::setSDA(unsigned char)+0x66>
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f0e:	4a0f      	ldr	r2, [pc, #60]	; (60001f4c <TwoWire::setSDA(unsigned char)+0x74>)
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f10:	eb03 1306 	add.w	r3, r3, r6, lsl #4
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f14:	2705      	movs	r7, #5
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f16:	4e0e      	ldr	r6, [pc, #56]	; (60001f50 <TwoWire::setSDA(unsigned char)+0x78>)
		if (sda_pin == pin) break;
		if (++newindex >= sizeof(hardware.sda_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
60001f18:	eb02 1404 	add.w	r4, r2, r4, lsl #4
60001f1c:	6861      	ldr	r1, [r4, #4]
60001f1e:	600f      	str	r7, [r1, #0]
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f20:	7a19      	ldrb	r1, [r3, #8]
60001f22:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001f26:	6889      	ldr	r1, [r1, #8]
60001f28:	600e      	str	r6, [r1, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001f2a:	7a1c      	ldrb	r4, [r3, #8]
60001f2c:	68d9      	ldr	r1, [r3, #12]
60001f2e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001f32:	6852      	ldr	r2, [r2, #4]
60001f34:	6011      	str	r1, [r2, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001f36:	691a      	ldr	r2, [r3, #16]
60001f38:	b10a      	cbz	r2, 60001f3e <TwoWire::setSDA(unsigned char)+0x66>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001f3a:	695b      	ldr	r3, [r3, #20]
60001f3c:	6013      	str	r3, [r2, #0]
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = 5;
		// setup new one...
		configSDApin(newindex);
	}
	sda_pin_index_ = newindex;
60001f3e:	7605      	strb	r5, [r0, #24]
}
60001f40:	bcf0      	pop	{r4, r5, r6, r7}
60001f42:	4770      	bx	lr
	if (pin == hardware.sda_pins[sda_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t sda_pin = hardware.sda_pins[newindex].pin;
		if (sda_pin == 255) return;
		if (sda_pin == pin) break;
60001f44:	2500      	movs	r5, #0
60001f46:	462e      	mov	r6, r5
60001f48:	e7dc      	b.n	60001f04 <TwoWire::setSDA(unsigned char)+0x2c>
60001f4a:	bf00      	nop
60001f4c:	200006dc 	.word	0x200006dc
60001f50:	0001f861 	.word	0x0001f861

60001f54 <TwoWire::configSDApin(unsigned char)>:
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f54:	6943      	ldr	r3, [r0, #20]
60001f56:	4a0b      	ldr	r2, [pc, #44]	; (60001f84 <TwoWire::configSDApin(unsigned char)+0x30>)
60001f58:	eb03 1001 	add.w	r0, r3, r1, lsl #4
	}
	sda_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSDApin(uint8_t i)
{
60001f5c:	b410      	push	{r4}
	*(portControlRegister(hardware.sda_pins[i].pin)) = PINCONFIG;
60001f5e:	7a01      	ldrb	r1, [r0, #8]
60001f60:	4c09      	ldr	r4, [pc, #36]	; (60001f88 <TwoWire::configSDApin(unsigned char)+0x34>)
60001f62:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001f66:	6889      	ldr	r1, [r1, #8]
60001f68:	600c      	str	r4, [r1, #0]
	*(portConfigRegister(hardware.sda_pins[i].pin)) = hardware.sda_pins[i].mux_val;
60001f6a:	7a04      	ldrb	r4, [r0, #8]
60001f6c:	68c1      	ldr	r1, [r0, #12]
60001f6e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001f72:	6852      	ldr	r2, [r2, #4]
60001f74:	6011      	str	r1, [r2, #0]
	if (hardware.sda_pins[i].select_input_register) {
60001f76:	6902      	ldr	r2, [r0, #16]
60001f78:	b10a      	cbz	r2, 60001f7e <TwoWire::configSDApin(unsigned char)+0x2a>
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
60001f7a:	6943      	ldr	r3, [r0, #20]
60001f7c:	6013      	str	r3, [r2, #0]
	}
}
60001f7e:	f85d 4b04 	ldr.w	r4, [sp], #4
60001f82:	4770      	bx	lr
60001f84:	200006dc 	.word	0x200006dc
60001f88:	0001f861 	.word	0x0001f861

60001f8c <TwoWire::setSCL(unsigned char)>:

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
60001f8c:	6943      	ldr	r3, [r0, #20]
60001f8e:	7e42      	ldrb	r2, [r0, #25]
60001f90:	eb03 1202 	add.w	r2, r3, r2, lsl #4
	if (hardware.sda_pins[i].select_input_register) {
		*(hardware.sda_pins[i].select_input_register) = hardware.sda_pins[i].select_val;
	}
}

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
60001f94:	b4f0      	push	{r4, r5, r6, r7}
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
60001f96:	f892 4028 	ldrb.w	r4, [r2, #40]	; 0x28
60001f9a:	428c      	cmp	r4, r1
60001f9c:	d00b      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
60001f9e:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
		if (scl_pin == 255) return;
60001fa2:	2aff      	cmp	r2, #255	; 0xff
60001fa4:	d007      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
		if (scl_pin == pin) break;
60001fa6:	428a      	cmp	r2, r1
60001fa8:	d02b      	beq.n	60002002 <TwoWire::setSCL(unsigned char)+0x76>

FLASHMEM void TwoWire::setSCL(uint8_t pin) {
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
60001faa:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
60001fae:	2aff      	cmp	r2, #255	; 0xff
60001fb0:	d001      	beq.n	60001fb6 <TwoWire::setSCL(unsigned char)+0x2a>
60001fb2:	428a      	cmp	r2, r1
60001fb4:	d001      	beq.n	60001fba <TwoWire::setSCL(unsigned char)+0x2e>
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
		// setup new one...
		configSCLpin(newindex);
	}
	scl_pin_index_ = newindex;
}
60001fb6:	bcf0      	pop	{r4, r5, r6, r7}
60001fb8:	4770      	bx	lr
60001fba:	2501      	movs	r5, #1
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
60001fbc:	462e      	mov	r6, r5
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
60001fbe:	e893 0006 	ldmia.w	r3, {r1, r2}
60001fc2:	6809      	ldr	r1, [r1, #0]
60001fc4:	4211      	tst	r1, r2
60001fc6:	d019      	beq.n	60001ffc <TwoWire::setSCL(unsigned char)+0x70>
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fc8:	4a0f      	ldr	r2, [pc, #60]	; (60002008 <TwoWire::setSCL(unsigned char)+0x7c>)
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fca:	eb03 1306 	add.w	r3, r3, r6, lsl #4
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fce:	2705      	movs	r7, #5
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fd0:	4e0e      	ldr	r6, [pc, #56]	; (6000200c <TwoWire::setSCL(unsigned char)+0x80>)
		if (scl_pin == pin) break;
		if (++newindex >= sizeof(hardware.scl_pins)) return;
	}
	if ((hardware.clock_gate_register & hardware.clock_gate_mask)) {
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
60001fd2:	eb02 1404 	add.w	r4, r2, r4, lsl #4
60001fd6:	6861      	ldr	r1, [r4, #4]
60001fd8:	600f      	str	r7, [r1, #0]
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60001fda:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
60001fde:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60001fe2:	6889      	ldr	r1, [r1, #8]
60001fe4:	600e      	str	r6, [r1, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60001fe6:	f893 4028 	ldrb.w	r4, [r3, #40]	; 0x28
60001fea:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
60001fec:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60001ff0:	6852      	ldr	r2, [r2, #4]
60001ff2:	6011      	str	r1, [r2, #0]
	if (hardware.scl_pins[i].select_input_register) {
60001ff4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
60001ff6:	b10a      	cbz	r2, 60001ffc <TwoWire::setSCL(unsigned char)+0x70>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
60001ff8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
60001ffa:	6013      	str	r3, [r2, #0]
		// disable old pin, hard to know what to go back to?
		*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = 5;
		// setup new one...
		configSCLpin(newindex);
	}
	scl_pin_index_ = newindex;
60001ffc:	7645      	strb	r5, [r0, #25]
}
60001ffe:	bcf0      	pop	{r4, r5, r6, r7}
60002000:	4770      	bx	lr
	if (pin == hardware.scl_pins[scl_pin_index_].pin) return;
	uint32_t newindex=0;
	while (1) {
		uint32_t scl_pin = hardware.scl_pins[newindex].pin;
		if (scl_pin == 255) return;
		if (scl_pin == pin) break;
60002002:	2500      	movs	r5, #0
60002004:	462e      	mov	r6, r5
60002006:	e7da      	b.n	60001fbe <TwoWire::setSCL(unsigned char)+0x32>
60002008:	200006dc 	.word	0x200006dc
6000200c:	0001f861 	.word	0x0001f861

60002010 <TwoWire::configSCLpin(unsigned char)>:
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
60002010:	6943      	ldr	r3, [r0, #20]
60002012:	4a0c      	ldr	r2, [pc, #48]	; (60002044 <TwoWire::configSCLpin(unsigned char)+0x34>)
60002014:	eb03 1001 	add.w	r0, r3, r1, lsl #4
	}
	scl_pin_index_ = newindex;
}

FLASHMEM void TwoWire::configSCLpin(uint8_t i)
{
60002018:	b410      	push	{r4}
	*(portControlRegister(hardware.scl_pins[i].pin)) = PINCONFIG;
6000201a:	f890 1028 	ldrb.w	r1, [r0, #40]	; 0x28
6000201e:	4c0a      	ldr	r4, [pc, #40]	; (60002048 <TwoWire::configSCLpin(unsigned char)+0x38>)
60002020:	eb02 1101 	add.w	r1, r2, r1, lsl #4
60002024:	6889      	ldr	r1, [r1, #8]
60002026:	600c      	str	r4, [r1, #0]
	*(portConfigRegister(hardware.scl_pins[i].pin)) = hardware.scl_pins[i].mux_val;
60002028:	f890 4028 	ldrb.w	r4, [r0, #40]	; 0x28
6000202c:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
6000202e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
60002032:	6852      	ldr	r2, [r2, #4]
60002034:	6011      	str	r1, [r2, #0]
	if (hardware.scl_pins[i].select_input_register) {
60002036:	6b02      	ldr	r2, [r0, #48]	; 0x30
60002038:	b10a      	cbz	r2, 6000203e <TwoWire::configSCLpin(unsigned char)+0x2e>
		*(hardware.scl_pins[i].select_input_register) = hardware.scl_pins[i].select_val;
6000203a:	6b43      	ldr	r3, [r0, #52]	; 0x34
6000203c:	6013      	str	r3, [r2, #0]
	}
}
6000203e:	f85d 4b04 	ldr.w	r4, [sp], #4
60002042:	4770      	bx	lr
60002044:	200006dc 	.word	0x200006dc
60002048:	0001f861 	.word	0x0001f861

6000204c <_init>:
6000204c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000204e:	bf00      	nop
60002050:	bcf8      	pop	{r3, r4, r5, r6, r7}
60002052:	bc08      	pop	{r3}
60002054:	469e      	mov	lr, r3
60002056:	4770      	bx	lr

60002058 <__memset_veneer>:
60002058:	f85f f000 	ldr.w	pc, [pc]	; 6000205c <__memset_veneer+0x4>
6000205c:	00006815 	.word	0x00006815

60002060 <____libc_init_array_veneer>:
60002060:	f85f f000 	ldr.w	pc, [pc]	; 60002064 <____libc_init_array_veneer+0x4>
60002064:	0000600d 	.word	0x0000600d

60002068 <__delay_veneer>:
60002068:	f85f f000 	ldr.w	pc, [pc]	; 6000206c <__delay_veneer+0x4>
6000206c:	0000122d 	.word	0x0000122d

60002070 <__pwm_init_veneer>:
60002070:	f85f f000 	ldr.w	pc, [pc]	; 60002074 <__pwm_init_veneer+0x4>
60002074:	000013c9 	.word	0x000013c9

60002078 <__usb_init_serialnumber_veneer>:
60002078:	f85f f000 	ldr.w	pc, [pc]	; 6000207c <__usb_init_serialnumber_veneer+0x4>
6000207c:	00002285 	.word	0x00002285

60002080 <__main_veneer>:
60002080:	f85f f000 	ldr.w	pc, [pc]	; 60002084 <__main_veneer+0x4>
60002084:	00000479 	.word	0x00000479

60002088 <__set_arm_clock_veneer>:
60002088:	f85f f000 	ldr.w	pc, [pc]	; 6000208c <__set_arm_clock_veneer+0x4>
6000208c:	00000f69 	.word	0x00000f69

60002090 <__sm_set_pool_veneer>:
60002090:	f85f f000 	ldr.w	pc, [pc]	; 60002094 <__sm_set_pool_veneer+0x4>
60002094:	00001701 	.word	0x00001701

60002098 <__init_array_start>:
60002098:	00000045 	.word	0x00000045
6000209c:	000029d1 	.word	0x000029d1

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      20:	4c05b510 	.word	0x4c05b510
      24:	7823      	ldrb	r3, [r4, #0]
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      26:	b933      	.short	0xb933
      28:	4b04      	ldr	r3, [pc, #16]	; (3c <_teensy_model_identifier+0x17>)
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      2a:	b113      	.short	0xb113
      2c:	4804      	ldr	r0, [pc, #16]	; (40 <_teensy_model_identifier+0x1b>)
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      2e:	f3af 8000 	nop.w
      32:	2301      	.short	0x2301
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      34:	7023      	strb	r3, [r4, #0]
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
      36:	bd10      	.short	0xbd10
      38:	2668      	movs	r6, #104	; 0x68
      3a:	2000      	.short	0x2000
      3c:	0000      	movs	r0, r0
      3e:	0000      	.short	0x0000
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
      40:	a244      	add	r2, pc, #272	; (adr r2, 154 <ComplimentaryFilter::run(Vector<float>*, Vector<float>*)+0xbc>)
	...

00000044 <frame_dummy>:

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      44:	b5104b08 	.word	0xb5104b08
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      48:	b11b      	cbz	r3, 52 <frame_dummy+0xe>
      4a:	4908      	.short	0x4908
      4c:	4808      	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	f3af      	.short	0xf3af
      50:	8000      	strh	r0, [r0, #0]
      52:	4808      	.short	0x4808
      54:	6803      	ldr	r3, [r0, #0]
      56:	b903      	.short	0xb903
      58:	bd10      	pop	{r4, pc}
      5a:	4b07      	.short	0x4b07
      5c:	2b00      	cmp	r3, #0
      5e:	d0fb      	.short	0xd0fb
      60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      64:	4718      	bx	r3
      66:	bf00      	nop
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      68:	0000      	movs	r0, r0
      6a:	0000      	movs	r0, r0
			yield(); // TODO: what happens if yield-called code uses analogRead()
      6c:	266c      	movs	r6, #108	; 0x6c
      6e:	2000      	movs	r0, #0
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      70:	a244      	add	r2, pc, #272	; (adr r2, 184 <ComplimentaryFilter::run(Vector<float>*, Vector<float>*)+0xec>)
      72:	0000      	.short	0x0000
      74:	22c0      	movs	r2, #192	; 0xc0
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC2_R0;
      76:	2000      	movs	r0, #0
      78:	0000      	movs	r0, r0
	...

0000007c <ComplimentaryFilter::clear()>:
			K = DEFAULT_GAIN;
			clear();
		}

		void clear() {
			axz_norm = 0;
      7c:	2300      	movs	r3, #0
      7e:	6343      	str	r3, [r0, #52]	; 0x34
			ayz_norm = 0;
      80:	6383      	str	r3, [r0, #56]	; 0x38
			mag_norm = 0;
      82:	63c3      	str	r3, [r0, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
      84:	6443      	str	r3, [r0, #68]	; 0x44
				q_accel[i] = 0;
      86:	6503      	str	r3, [r0, #80]	; 0x50
				bias_accel[i] = 0;
      88:	648365c3 	.word	0x648365c3
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
				q_accel[i] = 0;
      8c:	6543      	str	r3, [r0, #84]	; 0x54
				bias_accel[i] = 0;
      8e:	6603      	.short	0x6603
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
      90:	64c3      	str	r3, [r0, #76]	; 0x4c
				q_accel[i] = 0;
      92:	6583      	.short	0x6583
				bias_accel[i] = 0;
      94:	6643      	str	r3, [r0, #100]	; 0x64
      96:	4770      	.short	0x4770

00000098 <ComplimentaryFilter::run(Vector<float>*, Vector<float>*)>:
	configSDApin(sda_pin_index_); // Setup SDA register
	configSCLpin(scl_pin_index_); // setup SCL register
	port->SCR = LPI2C_SCR_RST;
	port->SCR = 0;
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
      98:	b5f0      	push	{r4, r5, r6, r7, lr}
	port->SAMR = LPI2C_SAMR_ADDR0(address);
      9a:	f100      	.short	0xf100
      9c:	060c      	lsls	r4, r1, #24


#ifdef __cplusplus
extern "C" void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
      9e:	4604      	.short	0x4604
      a0:	460d      	mov	r5, r1
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
      a2:	2100      	movs	r1, #0
      a4:	46174630 	.word	0x46174630
	NVIC_ENABLE_IRQ(hardware.irq_number);
      a8:	ed2d 8b0e 	vpush	{d8-d14}
	port->SCR = 0;
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
      ac:	b091      	sub	sp, #68	; 0x44
	NVIC_ENABLE_IRQ(hardware.irq_number);
	port->SIER = LPI2C_SIER_TDIE |  LPI2C_SIER_RDIE | LPI2C_SIER_SDIE;
      ae:	f000 fdeb 	bl	c88 <FTYK::micros(int)>
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
	NVIC_ENABLE_IRQ(hardware.irq_number);
      b2:	4630      	mov	r0, r6
	port->SCR = 0;
	port->SCFGR1 = LPI2C_SCFGR1_TXDSTALL | LPI2C_SCFGR1_RXSTALL; // page 2841
	port->SCFGR2 = 0; // page 2843;
	port->SAMR = LPI2C_SAMR_ADDR0(address);
	attachInterruptVector(hardware.irq_number, hardware.irq_function);
	NVIC_SET_PRIORITY(hardware.irq_number, 144);
      b4:	2100      	movs	r1, #0
	NVIC_ENABLE_IRQ(hardware.irq_number);
      b6:	eeb0 ea40 	vmov.f32	s28, s0
      ba:	f000      	.short	0xf000
      bc:	fddb 4628 	ldc2l	6, cr4, [fp, #160]	; 0xa0
      c0:	a904      	add	r1, sp, #16
      c2:	2303      	.short	0x2303
      c4:	2200      	movs	r2, #0
      c6:	f000      	.short	0xf000
      c8:	ff2b 4628 	vmax.u32	d4, d11, d24
	port->SIER = LPI2C_SIER_TDIE |  LPI2C_SIER_RDIE | LPI2C_SIER_SDIE;
      cc:	2306      	movs	r3, #6
      ce:	2203      	movs	r2, #3
	transmitting = 0;
      d0:	a907      	add	r1, sp, #28
      d2:	f000 ff25 	bl	f20 <Vector<float>::slice(float*, int, int)>
	slave_mode = 1;
      d6:	4628      	mov	r0, r5
	port->SCR = LPI2C_SCR_SEN;
      d8:	a90a      	add	r1, sp, #40	; 0x28
      da:	2309      	.short	0x2309
      dc:	2206      	movs	r2, #6
      de:	f000      	.short	0xf000
      e0:	ff1f 4628 	vmax.u16	d4, d15, d24
      e4:	230ca90d 	.word	0x230ca90d
      e8:	2209      	movs	r2, #9
      ea:	f000      	.short	0xf000
      ec:	ff19 9b09 	vqrdmulh.s16	d9, d9, d9
      f0:	21029a08 	.word	0x21029a08
      f4:	9d07      	ldr	r5, [sp, #28]
      f6:	4668      	.short	0x4668
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
      f8:	9301      	str	r3, [sp, #4]
			float ayz[2] = {accel[1], accel[2]};
      fa:	9303      	.short	0x9303
      fc:	9202      	str	r2, [sp, #8]
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
      fe:	9500      	str	r5, [sp, #0]
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     100:	f000 fada 	bl	6b8 <nd_norm(float*, int)>
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     104:	2102      	movs	r1, #2
     106:	a802      	add	r0, sp, #8
		}

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
     108:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     10c:	f000 fad4 	bl	6b8 <nd_norm(float*, int)>
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     110:	2103a80d 	.word	0x2103a80d

		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
     114:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     118:	f000 face 	bl	6b8 <nd_norm(float*, int)>

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     11c:	7a08eddd 	.word	0x7a08eddd
     120:	ed94 1a0d 	vldr	s2, [r4, #52]	; 0x34
		void filter(float* accel, float* gyro, float* mag, float dt, float* estimate) {
			float axz[2] = {accel[0], accel[2]};
			float ayz[2] = {accel[1], accel[2]};
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);
     124:	ed84 0a0f 	vstr	s0, [r4, #60]	; 0x3c

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     128:	0ae7eeb7 	.word	0x0ae7eeb7
     12c:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
     130:	fc06f004 	.word	0xfc06f004
			q_accel[1] = atan2(-accel[0], ayz_norm);
     134:	eddd 7a07 	vldr	s15, [sp, #28]
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     138:	0bc0eeb7 	.word	0x0bc0eeb7
			q_accel[1] = atan2(-accel[0], ayz_norm);
     13c:	ed94 1a0e 	vldr	s2, [r4, #56]	; 0x38
     140:	7a67eef1 	.word	0x7a67eef1
     144:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
			axz_norm = nd_norm(axz, ATTITUDE_DIM - 1);
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
     148:	0a14ed84 	.word	0x0a14ed84
			q_accel[1] = atan2(-accel[0], ayz_norm);
     14c:	eeb7 0ae7 	vcvt.f64.f32	d0, s15
     150:	fbf6f004 	.word	0xfbf6f004

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     154:	ed94 8a14 	vldr	s16, [r4, #80]	; 0x50
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
			q_accel[1] = atan2(-accel[0], ayz_norm);
     158:	0bc0eeb7 	.word	0x0bc0eeb7

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     15c:	ed9d ba0f 	vldr	s22, [sp, #60]	; 0x3c
     160:	8ac8eeb7 	.word	0x8ac8eeb7
     164:	eeb7 bacb 	vcvt.f64.f32	d11, s22
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;
     168:	9ac0eeb7 	.word	0x9ac0eeb7
			ayz_norm = nd_norm(ayz, ATTITUDE_DIM - 1);
			mag_norm = nd_norm(mag, ATTITUDE_DIM);

			// Calulate attitude using accelerations + magnetometer and trig
			q_accel[0] = atan2(accel[1], axz_norm);
			q_accel[1] = atan2(-accel[0], ayz_norm);
     16c:	ed84 0a15 	vstr	s0, [r4, #84]	; 0x54

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
     170:	0b48eeb0 	.word	0x0b48eeb0
     174:	f004 fb94 	bl	48a0 <sin>
     178:	db40eeb0 	.word	0xdb40eeb0
     17c:	eeb0 0b48 	vmov.f64	d0, d8
     180:	f004 fb3e 	bl	4800 <cos>
     184:	8a0eed9d 	.word	0x8a0eed9d
     188:	ed94 aa0f 	vldr	s20, [r4, #60]	; 0x3c
     18c:	8ac8eeb7 	.word	0x8ac8eeb7
     190:	eeb7 aaca 	vcvt.f64.f32	d10, s20
     194:	8b00ee28 	.word	0x8b00ee28
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;
     198:	eeb0 0b49 	vmov.f64	d0, d9
     19c:	fb30f004 	.word	0xfb30f004
     1a0:	eeb0 cb40 	vmov.f64	d12, d0
     1a4:	0b49eeb0 	.word	0x0b49eeb0
     1a8:	f004 fb7a 	bl	48a0 <sin>

			q_accel[2] = atan2(opposite, adjacent);
     1ac:	ee28 0b00 	vmul.f64	d0, d8, d0
     1b0:	6a0ded9d 	.word	0x6a0ded9d
     1b4:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     1b8:	8b0dee9b 	.word	0x8b0dee9b
     1bc:	eeab 0b0d 	vfma.f64	d0, d11, d13
     1c0:	7b0aee88 	.word	0x7b0aee88
     1c4:	eea6 0b0c 	vfma.f64	d0, d6, d12
     1c8:	1b0aee80 	.word	0x1b0aee80
     1cc:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
     1d0:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
     1d4:	eeb7 1bc1 	vcvt.f32.f64	s2, d1
     1d8:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
     1dc:	f004 fbb0 	bl	4940 <atan2>
     1e0:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
			if (isnan(q_accel[2])) {
     1e4:	eeb4 0a40 	vcmp.f32	s0, s0
			q_accel[1] = atan2(-accel[0], ayz_norm);

			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;

			q_accel[2] = atan2(opposite, adjacent);
     1e8:	ed84 0a16 	vstr	s0, [r4, #88]	; 0x58
			if (isnan(q_accel[2])) {
     1ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     1f0:	f104d625 	.word	0xf104d625
				q_accel[2] = 0;
			}

			// integrate gyro measurements over time
			weighted_vector_addition(estimate, gyro, 1, dt, 3, q_gyro);
     1f4:	0544      	lsls	r4, r0, #21
     1f6:	eef0      	.short	0xeef0
     1f8:	0a4e      	lsrs	r6, r1, #9
     1fa:	a90a      	.short	0xa90a
     1fc:	a804      	add	r0, sp, #16
     1fe:	462b      	.short	0x462b
     200:	2203      	movs	r2, #3
     202:	eeb7      	.short	0xeeb7
     204:	0a00      	lsrs	r0, r0, #8
     206:	f000 fa81 	bl	70c <weighted_vector_addition(float*, float*, float, float, int, float*)>

			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
     20a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
     20e:	ed94 0a10 	vldr	s0, [r4, #64]	; 0x40
     212:	ab04      	.short	0xab04
     214:	4629      	mov	r1, r5
     216:	2203      	movs	r2, #3
     218:	ee70 0ac0 	vsub.f32	s1, s1, s0
     21c:	f104 0050 	add.w	r0, r4, #80	; 0x50
     220:	f000 fa74 	bl	70c <weighted_vector_addition(float*, float*, float, float, int, float*)>
			inputs->slice(gyro, 6, 9);
			inputs->slice(mag, 9, 12);
			
			filter(accel, gyro, mag, dt, estimate);

			outputs->from_array(estimate, dimensions[OUTPUT_DIMENSION]);
     224:	1d20      	adds	r0, r4, #4
     226:	2102      	movs	r1, #2
     228:	fdaef000 	.word	0xfdaef000
     22c:	a904      	add	r1, sp, #16
     22e:	6802      	.short	0x6802
     230:	4638      	mov	r0, r7
     232:	f000      	.short	0xf000
     234:	fdf1 b011 	ldc2l	0, cr11, [r1, #68]!	; 0x44
		}
     238:	8b0eecbd 	.word	0x8b0eecbd
     23c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			float opposite = ((mag[2]*sin(q_accel[0])) - (mag[1]*cos(q_accel[0]))) / mag_norm;
			float adjacent = ((mag[0]*cos(q_accel[1])) + (sin(q_accel[1]) * (mag[1]*cos(q_accel[0])) + (mag[2]*sin(q_accel[0])))) / mag_norm;

			q_accel[2] = atan2(opposite, adjacent);
			if (isnan(q_accel[2])) {
				q_accel[2] = 0;
     23e:	2300      	.short	0x2300
     240:	65a3      	str	r3, [r4, #88]	; 0x58
     242:	e7d6      	.short	0xe7d6

00000244 <ComplimentaryFilter::context(Vector<float>*)>:
				q_accel[i] = 0;
				q_gyro[i] = 0;
			}
		}

		void context(Vector<float>* context) {
     244:	b570      	push	{r4, r5, r6, lr}
     246:	460c      	.short	0x460c
     248:	4605      	mov	r5, r0
			context->reset(dimensions[CONTEXT_DIMENSION]);
     24a:	2101      	.short	0x2101
     24c:	3004      	adds	r0, #4
     24e:	f000 fd9b 	bl	d88 <Vector<int>::operator[](int)>
     252:	6801      	ldr	r1, [r0, #0]
     254:	4620      	mov	r0, r4
     256:	f000      	.short	0xf000
     258:	fdc9 f105 	stc2l	1, cr15, [r9, #20]
			context->insert(q_gyro, 0, ATTITUDE_DIM);
     25c:	0144      	lsls	r4, r0, #5
     25e:	4620      	mov	r0, r4
     260:	2303      	movs	r3, #3
     262:	2200      	.short	0x2200
     264:	f000 fe36 	bl	ed4 <Vector<float>::insert(float*, int, int)>
			context->insert(q_accel, 3, ATTITUDE_DIM);
     268:	f1052303 	.word	0xf1052303
     26c:	0150      	lsls	r0, r2, #5
     26e:	4620      	mov	r0, r4
     270:	461a      	mov	r2, r3
		}
     272:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		}

		void context(Vector<float>* context) {
			context->reset(dimensions[CONTEXT_DIMENSION]);
			context->insert(q_gyro, 0, ATTITUDE_DIM);
			context->insert(q_accel, 3, ATTITUDE_DIM);
     276:	f000 be2d 	b.w	ed4 <Vector<float>::insert(float*, int, int)>
	uint32_t ctrl = CTRL_TX_INACTIVE;

	// Now process the bits in the Format value passed in
	// Bits 0-2 - Parity plus 9  bit. 
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
     27a:	bf00      	nop

0000027c <ComplimentaryFilter::setup(Vector<float>*)>:
			watches.set(0);
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
     27c:	460b      	mov	r3, r1
			K = (*config)[0];
     27e:	2100      	movs	r1, #0
			watches.set(0);
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
     280:	b510      	push	{r4, lr}
     282:	4604      	mov	r4, r0
			K = (*config)[0];
     284:	f0004618 	.word	0xf0004618
     288:	fe61 6803 	cdp2	8, 6, cr6, cr1, cr3, {0}
			watches.set(0);
     28c:	f1042100 	.word	0xf1042100
     290:	000c      	movs	r4, r1
			reset();
			clear();
		}

		void setup(Vector<float>* config) {
			K = (*config)[0];
     292:	6423      	.short	0x6423
			watches.set(0);
     294:	f000 fcee 	bl	c74 <FTYK::set(int)>
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     298:	2300      	movs	r3, #0
     29a:	6523      	.short	0x6523
				q_gyro[i] = 0;
     29c:	6463      	str	r3, [r4, #68]	; 0x44

		void setup(Vector<float>* config) {
			K = (*config)[0];
			watches.set(0);
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     29e:	6563      	str	r3, [r4, #84]	; 0x54
				q_gyro[i] = 0;
     2a0:	64a3      	str	r3, [r4, #72]	; 0x48

		void setup(Vector<float>* config) {
			K = (*config)[0];
			watches.set(0);
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_accel[i] = 0;
     2a2:	65a3      	str	r3, [r4, #88]	; 0x58
				q_gyro[i] = 0;
     2a4:	64e3      	str	r3, [r4, #76]	; 0x4c
     2a6:	bd10      	pop	{r4, pc}

000002a8 <ComplimentaryFilter::reset()>:
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
     2a8:	490d6802 	.word	0x490d6802
     2ac:	6912      	ldr	r2, [r2, #16]

			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
     2ae:	b410      	.short	0xb410
     2b0:	428a      	cmp	r2, r1
			K = DEFAULT_GAIN;
     2b2:	4c0c      	.short	0x4c0c
     2b4:	6404      	str	r4, [r0, #64]	; 0x40
     2b6:	d10f      	bne.n	2d8 <ComplimentaryFilter::reset()+0x30>
			clear();
		}

		void clear() {
			axz_norm = 0;
     2b8:	2200      	movs	r2, #0
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
		}
     2ba:	f85d      	.short	0xf85d
     2bc:	4b04      	ldr	r3, [pc, #16]	; (2d0 <ComplimentaryFilter::reset()+0x28>)

		void clear() {
			axz_norm = 0;
     2be:	6342      	str	r2, [r0, #52]	; 0x34
			ayz_norm = 0;
     2c0:	6382      	str	r2, [r0, #56]	; 0x38
			mag_norm = 0;
     2c2:	63c2      	str	r2, [r0, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     2c4:	6442      	str	r2, [r0, #68]	; 0x44
				q_accel[i] = 0;
     2c6:	6502      	str	r2, [r0, #80]	; 0x50
				bias_accel[i] = 0;
     2c8:	65c2      	str	r2, [r0, #92]	; 0x5c
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     2ca:	6482      	str	r2, [r0, #72]	; 0x48
				q_accel[i] = 0;
     2cc:	6542      	str	r2, [r0, #84]	; 0x54
				bias_accel[i] = 0;
     2ce:	6602      	str	r2, [r0, #96]	; 0x60
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     2d0:	64c2      	str	r2, [r0, #76]	; 0x4c
				q_accel[i] = 0;
     2d2:	6582      	str	r2, [r0, #88]	; 0x58
				bias_accel[i] = 0;
     2d4:	6642      	str	r2, [r0, #100]	; 0x64
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
		}
     2d6:	4770      	bx	lr
     2d8:	4b04f85d 	.word	0x4b04f85d
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
			clear();
     2dc:	4710      	bx	r2
     2de:	bf00      	nop
     2e0:	007d      	lsls	r5, r7, #1
     2e2:	0000      	movs	r0, r0
     2e4:	cccd      	ldmia	r4!, {r0, r2, r3, r6, r7}
     2e6:	3ecc      	subs	r6, #204	; 0xcc

000002e8 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]>:
*/
class Process_Factory {
	// private:
		
	public:
		Process* new_proc(String index) {
     2e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	//unsigned char equals(const __FlashStringHelper *pgmstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
     2ec:	492d      	ldr	r1, [pc, #180]	; (3a4 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xbc>)
     2ee:	4604      	mov	r4, r0
     2f0:	f002 fbce 	bl	2a90 <String::equals(char const*) const>
			if (index == LSM6DSOX_ID) {
     2f4:	2800      	cmp	r0, #0
     2f6:	d14b      	bne.n	390 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xa8>
     2f8:	4607      	mov	r7, r0
     2fa:	492b      	ldr	r1, [pc, #172]	; (3a8 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xc0>)
     2fc:	4620      	mov	r0, r4
     2fe:	f002 fbc7 	bl	2a90 <String::equals(char const*) const>
				return new LSM6DSOX();
			}
			else if (index == COMPLIMENTARYFILTER_ID) {
     302:	2800      	cmp	r0, #0
     304:	2068d042 	.word	0x2068d042
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     308:	2500      	movs	r5, #0
				return new ComplimentaryFilter();
     30a:	f002 fbd7 	bl	2abc <operator new(unsigned int)>
	Base class for all user defined processes.
	Must override the functions below, constructor
	optional... I think.
*/

class Process {	
     30e:	4b27      	ldr	r3, [pc, #156]	; (3ac <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xc4>)
     310:	4606      	mov	r6, r0
     312:	4604      	.short	0x4604
     314:	4680      	mov	r8, r0
     316:	f8df 909c 	ldr.w	r9, [pc, #156]	; 3b4 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xcc>
     31a:	f846      	.short	0xf846
     31c:	3b04      	subs	r3, #4
     31e:	4630      	.short	0x4630
     320:	f000 fd04 	bl	d2c <Vector<int>::Vector()>
     324:	4b22      	ldr	r3, [pc, #136]	; (3b0 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0xc8>)
     326:	f848      	.short	0xf848
     328:	3b0c      	subs	r3, #12
     32a:	4640      	.short	0x4640
     32c:	f000 fc92 	bl	c54 <FTYK::FTYK()>
			dimensions.reset(PROCESS_DIMENSIONS);
     330:	4630      	mov	r0, r6
     332:	2103      	.short	0x2103
		float q_accel[ATTITUDE_DIM];
		float bias_accel[ATTITUDE_DIM];


	public:
		ComplimentaryFilter() {
     334:	6365      	str	r5, [r4, #52]	; 0x34
     336:	63a5      	.short	0x63a5
     338:	63e5      	str	r5, [r4, #60]	; 0x3c
     33a:	f8c4      	.short	0xf8c4
     33c:	9040      	str	r0, [sp, #256]	; 0x100
			dimensions.reset(PROCESS_DIMENSIONS);
     33e:	f000      	.short	0xf000
     340:	fcff 4639 	ldc2l	6, cr4, [pc], #228	; 428 <ComplimentaryFilter::print()+0x70>
			dimensions[INPUT_DIMENSION] = CMF_INPUT_DIMS;
     344:	f0004630 	.word	0xf0004630
     348:	fd1f 230c 	ldc2	3, cr2, [pc, #-48]	; 31c <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]+0x34>
			dimensions[CONTEXT_DIMENSION] = CMF_STATE_SIZE;
     34c:	60032101 	.word	0x60032101
     350:	4630      	mov	r0, r6
     352:	f000      	.short	0xf000
     354:	fd19 2306 	ldc2	3, cr2, [r9, #-24]	; 0xffffffe8
			dimensions[OUTPUT_DIMENSION] = ATTITUDE_DIM;
     358:	60032102 	.word	0x60032102
     35c:	4630      	mov	r0, r6
     35e:	f000      	.short	0xf000
     360:	fd13 2303 	ldc2	3, cr2, [r3, #-12]
			watches.set(0);
     364:	60034639 	.word	0x60034639
     368:	4640      	mov	r0, r8
     36a:	f000      	.short	0xf000
     36c:	fc83 4620 	stc2	6, cr4, [r3], {32}
			// fuse the accel and gyro estimates
			weighted_vector_addition(q_accel, q_gyro, K, 1-K, 3, estimate);
		}

		void reset() {
			K = DEFAULT_GAIN;
     370:	9040f8c4 	.word	0x9040f8c4
			clear();
		}

		void clear() {
			axz_norm = 0;
     374:	6365      	str	r5, [r4, #52]	; 0x34
			ayz_norm = 0;
     376:	63a5      	.short	0x63a5
			mag_norm = 0;
     378:	63e5      	str	r5, [r4, #60]	; 0x3c
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     37a:	6465      	.short	0x6465
				q_accel[i] = 0;
     37c:	6525      	str	r5, [r4, #80]	; 0x50
				bias_accel[i] = 0;
     37e:	65e5      	.short	0x65e5
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     380:	64a5      	str	r5, [r4, #72]	; 0x48
				q_accel[i] = 0;
     382:	6565      	.short	0x6565
				bias_accel[i] = 0;
     384:	6625      	str	r5, [r4, #96]	; 0x60
		void clear() {
			axz_norm = 0;
			ayz_norm = 0;
			mag_norm = 0;
			for (int i = 0; i < ATTITUDE_DIM; i++) {
				q_gyro[i] = 0;
     386:	64e5      	str	r5, [r4, #76]	; 0x4c
				q_accel[i] = 0;
     388:	666565a5 	.word	0x666565a5
			}
			else {
				return nullptr;
			}
		}
     38c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	// private:
		
	public:
		Process* new_proc(String index) {
			if (index == LSM6DSOX_ID) {
				return new LSM6DSOX();
     390:	f00220b0 	.word	0xf00220b0
     394:	fb93 4604 			; <UNDEFINED> instruction: 0xfb934604
     398:	f000 fabc 	bl	914 <LSM6DSOX::LSM6DSOX()>
     39c:	e8bd4620 	.word	0xe8bd4620
     3a0:	83f8      	strh	r0, [r7, #30]
     3a2:	bf00      	.short	0xbf00
     3a4:	0ae8      	lsrs	r0, r5, #11
     3a6:	2000      	.short	0x2000
     3a8:	0aec      	lsrs	r4, r5, #11
     3aa:	2000      	.short	0x2000
     3ac:	0540      	lsls	r0, r0, #21
     3ae:	2000      	.short	0x2000
     3b0:	04c0      	lsls	r0, r0, #19
     3b2:	2000      	movs	r0, #0
     3b4:	3ecccccd 	.word	0x3ecccccd

000003b8 <ComplimentaryFilter::print()>:
			filter(accel, gyro, mag, dt, estimate);

			outputs->from_array(estimate, dimensions[OUTPUT_DIMENSION]);
		}

		void print() {
     3b8:	b530      	push	{r4, r5, lr}
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     3ba:	4d21      	.short	0x4d21
     3bc:	b085      	sub	sp, #20
     3be:	4604      	mov	r4, r0
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
     3c0:	2113      	movs	r1, #19
     3c2:	4820      	.short	0x4820
     3c4:	f002 fa46 	bl	2854 <usb_seremu_write>
     3c8:	f0024628 	.word	0xf0024628
     3cc:	fad3 edd4 			; <UNDEFINED> instruction: 0xfad3edd4
			Serial.println("ComplimentaryFilter");
			Serial.printf("\tgain: [%f]\n", K);
     3d0:	46287a10 	.word	0x46287a10
     3d4:	491c      	ldr	r1, [pc, #112]	; (448 <ComplimentaryFilter::print()+0x90>)
     3d6:	eeb7      	.short	0xeeb7
     3d8:	7ae7      	ldrb	r7, [r4, #11]
     3da:	ec53      	.short	0xec53
     3dc:	2b17      	cmp	r3, #23
     3de:	f002      	.short	0xf002
     3e0:	fae1 ed94 			; <UNDEFINED> instruction: 0xfae1ed94
			Serial.printf("\tq_accel: [%f, %f, %f]\n", q_accel[0], q_accel[1], q_accel[2]);
     3e4:	6a16      	ldr	r6, [r2, #32]
     3e6:	ed94 7a15 	vldr	s14, [r4, #84]	; 0x54
     3ea:	4628      	mov	r0, r5
     3ec:	5a14edd4 	.word	0x5a14edd4
     3f0:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     3f4:	7ac7eeb7 	.word	0x7ac7eeb7
     3f8:	4914      	ldr	r1, [pc, #80]	; (44c <ComplimentaryFilter::print()+0x94>)
     3fa:	eeb7      	.short	0xeeb7
     3fc:	5ae5      	ldrh	r5, [r4, r3]
     3fe:	ed8d      	.short	0xed8d
     400:	6b02      	ldr	r2, [r0, #48]	; 0x30
     402:	ec53 2b15 	vmov	r2, r3, d5
     406:	ed8d 7b00 	vstr	d7, [sp]
     40a:	f002 facb 	bl	29a4 <Print::printf(char const*, ...)>
			Serial.printf("\tq_gyro: [%f, %f, %f]\n", q_gyro[0], q_gyro[1], q_gyro[2]);
     40e:	ed94 6a13 	vldr	s12, [r4, #76]	; 0x4c
     412:	ed94 7a12 	vldr	s14, [r4, #72]	; 0x48
     416:	4628      	mov	r0, r5
     418:	edd4 5a11 	vldr	s11, [r4, #68]	; 0x44
     41c:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     420:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     424:	490a      	ldr	r1, [pc, #40]	; (450 <ComplimentaryFilter::print()+0x98>)
     426:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     42a:	ed8d 6b02 	vstr	d6, [sp, #8]
     42e:	ec53 2b15 	vmov	r2, r3, d5
     432:	ed8d 7b00 	vstr	d7, [sp]
     436:	f002 fab5 	bl	29a4 <Print::printf(char const*, ...)>
		}
     43a:	b005      	add	sp, #20
     43c:	bd30      	pop	{r4, r5, pc}
     43e:	bf00      	nop
     440:	2000147c 	.word	0x2000147c
     444:	0af0      	lsrs	r0, r6, #11
     446:	2000      	.short	0x2000
     448:	0b04      	lsrs	r4, r0, #12
     44a:	2000      	.short	0x2000
     44c:	0b14      	lsrs	r4, r2, #12
     44e:	2000      	.short	0x2000
     450:	0b2c      	lsrs	r4, r5, #12
     452:	2000      	.short	0x2000

00000454 <Print::println(char const*)>:
     454:	b538      	push	{r3, r4, r5, lr}
     456:	4604      	mov	r4, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     458:	4608      	mov	r0, r1
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     45a:	460d      	mov	r5, r1
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     45c:	f006 fe10 	bl	7080 <strlen>
     460:	6823      	ldr	r3, [r4, #0]
     462:	4602      	mov	r2, r0
     464:	4629      	mov	r1, r5
     466:	4620      	mov	r0, r4
     468:	4798685b 	.word	0x4798685b
     46c:	4605      	mov	r5, r0
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     46e:	4620      	.short	0x4620
     470:	f002 fa80 	bl	2974 <Print::println()>
     474:	bd384428 	.word	0xbd384428

00000478 <main>:
#include "syncor/syncor_node.h"
#include "syncor/process_factory.h"

#include "sensors/lsm6dsox.h"

int main() {
     478:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     47c:	b08a4c7b 	.word	0xb08a4c7b
     480:	4d7b      	ldr	r5, [pc, #492]	; (670 <main+0x1f8>)
        uint8_t stopbits(void) { return 1; }
        uint8_t paritytype(void) { return 0; }
        uint8_t numbits(void) { return 8; }
        uint8_t dtr(void) { return 1; }
        uint8_t rts(void) { return 1; }
        operator bool() { yield(); return usb_configuration && usb_seremu_online; }
     482:	f002      	.short	0xf002
     484:	fb35 7823 			; <UNDEFINED> instruction: 0xfb357823
     488:	d0fa2b00 	.word	0xd0fa2b00
     48c:	782b      	ldrb	r3, [r5, #0]
     48e:	2b00      	cmp	r3, #0
     490:	d0f7      	beq.n	482 <main+0xa>
	while(!Serial){}

	Serial.println("=== Starting SynCorNode tests ===");
     492:	4978      	ldr	r1, [pc, #480]	; (674 <main+0x1fc>)

	int empty = 0;
     494:	48782500 	.word	0x48782500
	float tmp[1] = {0.6};
	int cmf_inputs[2] = {1, 0};
     498:	2701      	movs	r7, #1
#include "sensors/lsm6dsox.h"

int main() {
	while(!Serial){}

	Serial.println("=== Starting SynCorNode tests ===");
     49a:	f7ff      	.short	0xf7ff
     49c:	ffdb 4b77 			; <UNDEFINED> instruction: 0xffdb4b77
	int empty = 0;
	float tmp[1] = {0.6};
	int cmf_inputs[2] = {1, 0};


	Serial.println("=== Init Process Factory ===");
     4a0:	4977      	ldr	r1, [pc, #476]	; (680 <main+0x208>)

	Serial.println("=== Init Graph Node ===");
	SynCorNode* nodelist[2];

	Serial.println("=== Add LSM6DSOX ===");
	nodelist[0] = new SynCorNode(p_fact.new_proc("LSM"), 0, 0, &empty);
     4a2:	ac02      	add	r4, sp, #8
	int empty = 0;
	float tmp[1] = {0.6};
	int cmf_inputs[2] = {1, 0};


	Serial.println("=== Init Process Factory ===");
     4a4:	4874      	ldr	r0, [pc, #464]	; (678 <main+0x200>)
	while(!Serial){}

	Serial.println("=== Starting SynCorNode tests ===");

	int empty = 0;
	float tmp[1] = {0.6};
     4a6:	9303      	str	r3, [sp, #12]
int main() {
	while(!Serial){}

	Serial.println("=== Starting SynCorNode tests ===");

	int empty = 0;
     4a8:	9502      	str	r5, [sp, #8]
	float tmp[1] = {0.6};
	int cmf_inputs[2] = {1, 0};
     4aa:	9505      	str	r5, [sp, #20]
     4ac:	f7ff9704 	.word	0xf7ff9704


	Serial.println("=== Init Process Factory ===");
     4b0:	ffd1 4974 	vqrshrn.u32	d20, q10, #15
	Process_Factory p_fact;

	Serial.println("=== Init Graph Node ===");
     4b4:	f7ff4870 	.word	0xf7ff4870
     4b8:	ffcd 4973 	vqrshrn.u16	d20, <illegal reg q9.5>, #3
	SynCorNode* nodelist[2];

	Serial.println("=== Add LSM6DSOX ===");
     4bc:	486e      	ldr	r0, [pc, #440]	; (678 <main+0x200>)
     4be:	f7ff ffc9 	bl	454 <Print::println(char const*)>
	nodelist[0] = new SynCorNode(p_fact.new_proc("LSM"), 0, 0, &empty);
     4c2:	4972      	ldr	r1, [pc, #456]	; (68c <main+0x214>)
     4c4:	a806      	add	r0, sp, #24
     4c6:	f002 facf 	bl	2a68 <String::String(char const*)>
     4ca:	a806      	add	r0, sp, #24
     4cc:	f7ff ff0c 	bl	2e8 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]>
     4d0:	4680      	mov	r8, r0
     4d2:	2028      	movs	r0, #40	; 0x28
     4d4:	f002 faf2 	bl	2abc <operator new(unsigned int)>
     4d8:	462b      	mov	r3, r5
     4da:	462a      	mov	r2, r5
     4dc:	4641      	mov	r1, r8
     4de:	9400      	str	r4, [sp, #0]
     4e0:	4606      	mov	r6, r0
     4e2:	f000 fb49 	bl	b78 <SynCorNode::SynCorNode(Process*, int, int, int*)>
     4e6:	a806      	add	r0, sp, #24
     4e8:	f002 fa7e 	bl	29e8 <String::~String()>

	Serial.println("=== Add Complimentary Filter ===");
     4ec:	4968      	ldr	r1, [pc, #416]	; (690 <main+0x218>)
     4ee:	4862      	ldr	r0, [pc, #392]	; (678 <main+0x200>)
     4f0:	f7ff ffb0 	bl	454 <Print::println(char const*)>
	nodelist[1] = new SynCorNode(p_fact.new_proc("CMF"), 1, 2, cmf_inputs);
     4f4:	4967      	ldr	r1, [pc, #412]	; (694 <main+0x21c>)
     4f6:	a806      	add	r0, sp, #24
     4f8:	f002 fab6 	bl	2a68 <String::String(char const*)>
     4fc:	a806      	add	r0, sp, #24
     4fe:	f7ff fef3 	bl	2e8 <Process_Factory::new_proc(String) [clone .isra.1] [clone .constprop.3]>
     502:	4680      	mov	r8, r0
     504:	2028      	movs	r0, #40	; 0x28
     506:	f002 fad9 	bl	2abc <operator new(unsigned int)>
     50a:	ab04      	add	r3, sp, #16
     50c:	463a      	mov	r2, r7
     50e:	4641      	mov	r1, r8
     510:	9300      	str	r3, [sp, #0]
     512:	2302      	movs	r3, #2
     514:	4604      	mov	r4, r0
     516:	f000 fb2f 	bl	b78 <SynCorNode::SynCorNode(Process*, int, int, int*)>
     51a:	a806      	add	r0, sp, #24
     51c:	f002 fa64 	bl	29e8 <String::~String()>

	Serial.println("=== Init input Vector ===");
     520:	495d      	ldr	r1, [pc, #372]	; (698 <main+0x220>)
     522:	4855      	ldr	r0, [pc, #340]	; (678 <main+0x200>)
     524:	f7ff ff96 	bl	454 <Print::println(char const*)>
	Vector<float> input(0);
     528:	4629      	mov	r1, r5
     52a:	a806      	add	r0, sp, #24
     52c:	f000 fc4c 	bl	dc8 <Vector<float>::Vector(int)>

	Serial.println("=== Run Process 0 ===");
     530:	495a      	ldr	r1, [pc, #360]	; (69c <main+0x224>)
     532:	4851      	ldr	r0, [pc, #324]	; (678 <main+0x200>)
     534:	f7ff ff8e 	bl	454 <Print::println(char const*)>
	nodelist[0]->run_proc(&input);
     538:	a906      	add	r1, sp, #24
     53a:	4630      	mov	r0, r6
     53c:	f000 fb5a 	bl	bf4 <SynCorNode::run_proc(Vector<float>*)>
	nodelist[0]->run_proc(&input);
     540:	a906      	add	r1, sp, #24
     542:	4630      	mov	r0, r6
     544:	f000 fb56 	bl	bf4 <SynCorNode::run_proc(Vector<float>*)>
	nodelist[0]->run_proc(&input);
     548:	a906      	add	r1, sp, #24
     54a:	4630      	mov	r0, r6
     54c:	f000 fb52 	bl	bf4 <SynCorNode::run_proc(Vector<float>*)>
	nodelist[0]->print_proc();
     550:	4630      	mov	r0, r6
     552:	f000 fb6d 	bl	c30 <SynCorNode::print_proc()>
	nodelist[0]->print_output();
     556:	4630      	mov	r0, r6
     558:	f000 fb6e 	bl	c38 <SynCorNode::print_output()>

	Serial.println("=== Setup Process 1 ===");
     55c:	4950      	ldr	r1, [pc, #320]	; (6a0 <main+0x228>)
     55e:	4846      	ldr	r0, [pc, #280]	; (678 <main+0x200>)
     560:	f7ff ff78 	bl	454 <Print::println(char const*)>
	input.reset(0);
     564:	4629      	mov	r1, r5
     566:	a806      	add	r0, sp, #24
     568:	f000 fc40 	bl	dec <Vector<float>::reset(int)>
	input.append(nodelist[1]->output());				// get inputs from the nodes, this case input(0:3) is empty
     56c:	4620      	mov	r0, r4
     56e:	f000 fae7 	bl	b40 <SynCorNode::output()>
     572:	4601      	mov	r1, r0
     574:	a806      	add	r0, sp, #24
     576:	f000 fc83 	bl	e80 <Vector<float>::append(Vector<float>*)>
	input.append(nodelist[0]->output());				// Add output of nodelist[0] to inputs, append is a heavy function don't use in runtime
     57a:	4630      	mov	r0, r6
     57c:	f000 fae0 	bl	b40 <SynCorNode::output()>
     580:	4601      	mov	r1, r0
     582:	a806      	add	r0, sp, #24
     584:	f000 fc7c 	bl	e80 <Vector<float>::append(Vector<float>*)>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     588:	220b      	movs	r2, #11
     58a:	4946      	ldr	r1, [pc, #280]	; (6a4 <main+0x22c>)
     58c:	483a      	ldr	r0, [pc, #232]	; (678 <main+0x200>)
     58e:	f002 faa7 	bl	2ae0 <usb_seremu_class::write(unsigned char const*, unsigned int)>
	Serial.print("CMF inputs\t"); input.print();		// display the inputs
     592:	a806      	add	r0, sp, #24
     594:	f000 fb8e 	bl	cb4 <Vector<float>::print()>
	
	bool status = nodelist[1]->run_proc(&input);		// try to run the process without calling setup
     598:	a906      	add	r1, sp, #24
     59a:	4620      	mov	r0, r4
     59c:	f000 fb2a 	bl	bf4 <SynCorNode::run_proc(Vector<float>*)>
	Serial.printf("No setup Run status %i\n", status);
     5a0:	4941      	ldr	r1, [pc, #260]	; (6a8 <main+0x230>)
     5a2:	4602      	mov	r2, r0
     5a4:	4834      	ldr	r0, [pc, #208]	; (678 <main+0x200>)
     5a6:	f002 f9fd 	bl	29a4 <Print::printf(char const*, ...)>
	
	Vector<float>* config = nodelist[1]->config();		// Get the config buffer
     5aa:	4620      	mov	r0, r4
     5ac:	f000 faca 	bl	b44 <SynCorNode::config()>
	config->from_array(tmp, 1);							// set the config, make sure if the config gets filled setup is called (config.size() is how configuration is checked)
     5b0:	463a      	mov	r2, r7
     5b2:	a903      	add	r1, sp, #12
     5b4:	f000 fc30 	bl	e18 <Vector<float>::from_array(float*, int)>
	nodelist[1]->setup_proc();							// call setup to initialize the process	
     5b8:	4620      	mov	r0, r4
     5ba:	f000 fb07 	bl	bcc <SynCorNode::setup_proc()>
	status = nodelist[1]->run_proc(&input);				// Run the process with setup
     5be:	a906      	add	r1, sp, #24
     5c0:	4620      	mov	r0, r4
     5c2:	f000 fb17 	bl	bf4 <SynCorNode::run_proc(Vector<float>*)>
	
	Serial.printf("Setup Run status %i\n", status);
     5c6:	4939      	ldr	r1, [pc, #228]	; (6ac <main+0x234>)
     5c8:	4602      	mov	r2, r0
     5ca:	482b      	ldr	r0, [pc, #172]	; (678 <main+0x200>)
     5cc:	f002 f9ea 	bl	29a4 <Print::printf(char const*, ...)>
	nodelist[1]->print_proc();
     5d0:	4620      	mov	r0, r4
     5d2:	f000 fb2d 	bl	c30 <SynCorNode::print_proc()>
	nodelist[1]->print_output();
     5d6:	4620      	mov	r0, r4
     5d8:	f000 fb2e 	bl	c38 <SynCorNode::print_output()>


	Serial.println("=== Reconfigure and Setup Process 1 ===");
     5dc:	4934      	ldr	r1, [pc, #208]	; (6b0 <main+0x238>)
     5de:	4826      	ldr	r0, [pc, #152]	; (678 <main+0x200>)
     5e0:	f7ff ff38 	bl	454 <Print::println(char const*)>
	nodelist[1]->set_config(1);
     5e4:	4639      	mov	r1, r7
     5e6:	4620      	mov	r0, r4
     5e8:	f000 faae 	bl	b48 <SynCorNode::set_config(int)>

	status = nodelist[1]->run_proc(&input);				// try to run the process without calling setup
     5ec:	a906      	add	r1, sp, #24
     5ee:	4620      	mov	r0, r4
     5f0:	f000 fb00 	bl	bf4 <SynCorNode::run_proc(Vector<float>*)>
	Serial.printf("No setup Run status %i\n", status);
     5f4:	492c      	ldr	r1, [pc, #176]	; (6a8 <main+0x230>)
     5f6:	4602      	mov	r2, r0
     5f8:	481f      	ldr	r0, [pc, #124]	; (678 <main+0x200>)
     5fa:	f002 f9d3 	bl	29a4 <Print::printf(char const*, ...)>

	config = nodelist[1]->config();						// Get the config buffer
     5fe:	4620      	mov	r0, r4
     600:	f000 faa0 	bl	b44 <SynCorNode::config()>
	config->from_array(tmp, 1);							// set the config, make sure if the config gets filled setup is called (config.size() is how configuration is checked)
     604:	463a      	mov	r2, r7
     606:	a903      	add	r1, sp, #12
     608:	f000 fc06 	bl	e18 <Vector<float>::from_array(float*, int)>
	nodelist[1]->setup_proc();							// call setup to initialize the process
     60c:	4620      	mov	r0, r4
     60e:	f000 fadd 	bl	bcc <SynCorNode::setup_proc()>

	input.reset(0);
     612:	4629      	mov	r1, r5
     614:	a806      	add	r0, sp, #24
     616:	f000 fbe9 	bl	dec <Vector<float>::reset(int)>
	input.append(nodelist[1]->output());				// get inputs from the nodes, this case input(0:3) is empty
     61a:	4620      	mov	r0, r4
     61c:	f000 fa90 	bl	b40 <SynCorNode::output()>
     620:	4601      	mov	r1, r0
     622:	a806      	add	r0, sp, #24
     624:	f000 fc2c 	bl	e80 <Vector<float>::append(Vector<float>*)>
	input.append(nodelist[0]->output());				// Add output of nodelist[0] to inputs, append is a heavy function don't use in runtime
     628:	4630      	mov	r0, r6
     62a:	f000 fa89 	bl	b40 <SynCorNode::output()>
     62e:	4601      	mov	r1, r0
     630:	a806      	add	r0, sp, #24
     632:	f000 fc25 	bl	e80 <Vector<float>::append(Vector<float>*)>
	status = nodelist[1]->run_proc(&input);				// Run the process with setup
     636:	a906      	add	r1, sp, #24
     638:	4620      	mov	r0, r4
     63a:	f000 fadb 	bl	bf4 <SynCorNode::run_proc(Vector<float>*)>
	
	Serial.printf("Setup Run status %i\n", status);
     63e:	491b      	ldr	r1, [pc, #108]	; (6ac <main+0x234>)
     640:	4602      	mov	r2, r0
     642:	480d      	ldr	r0, [pc, #52]	; (678 <main+0x200>)
     644:	f002 f9ae 	bl	29a4 <Print::printf(char const*, ...)>
	nodelist[1]->print_proc();
     648:	4620      	mov	r0, r4
     64a:	f000 faf1 	bl	c30 <SynCorNode::print_proc()>
	nodelist[1]->print_output();
     64e:	4620      	mov	r0, r4
     650:	f000 faf2 	bl	c38 <SynCorNode::print_output()>


	Serial.println("=== Finished Graph Node tests ===");
     654:	4917      	ldr	r1, [pc, #92]	; (6b4 <main+0x23c>)
     656:	4808      	ldr	r0, [pc, #32]	; (678 <main+0x200>)
     658:	f7ff fefc 	bl	454 <Print::println(char const*)>

	Serial.println("=== Add Complimentary Filter ===");
	nodelist[1] = new SynCorNode(p_fact.new_proc("CMF"), 1, 2, cmf_inputs);

	Serial.println("=== Init input Vector ===");
	Vector<float> input(0);
     65c:	a806      	add	r0, sp, #24
     65e:	f000 fba5 	bl	dac <Vector<float>::~Vector()>
	nodelist[1]->print_proc();
	nodelist[1]->print_output();


	Serial.println("=== Finished Graph Node tests ===");
     662:	4628      	mov	r0, r5
     664:	b00a      	add	sp, #40	; 0x28
     666:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     66a:	bf00      	nop
     66c:	2000275c 	.word	0x2000275c
     670:	2000275f 	.word	0x2000275f
     674:	20000b44 	.word	0x20000b44
     678:	2000147c 	.word	0x2000147c
     67c:	3f19999a 	.word	0x3f19999a
     680:	20000b68 	.word	0x20000b68
     684:	20000b88 	.word	0x20000b88
     688:	20000ba0 	.word	0x20000ba0
     68c:	20000ae8 	.word	0x20000ae8
     690:	20000bb8 	.word	0x20000bb8
     694:	20000aec 	.word	0x20000aec
     698:	20000bdc 	.word	0x20000bdc
     69c:	20000bf8 	.word	0x20000bf8
     6a0:	20000c10 	.word	0x20000c10
     6a4:	20000c28 	.word	0x20000c28
     6a8:	20000c34 	.word	0x20000c34
     6ac:	20000c4c 	.word	0x20000c4c
     6b0:	20000c64 	.word	0x20000c64
     6b4:	20000c8c 	.word	0x20000c8c

000006b8 <nd_norm(float*, int)>:
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     6b8:	2900      	cmp	r1, #0
     6ba:	dd15      	ble.n	6e8 <nd_norm(float*, int)+0x30>
     6bc:	ed9f 7a12 	vldr	s14, [pc, #72]	; 708 <nd_norm(float*, int)+0x50>
     6c0:	eb00 0181 	add.w	r1, r0, r1, lsl #2
		sum += v[i] * v[i];
     6c4:	ecf0 7a01 	vldmia	r0!, {s15}
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     6c8:	4281      	cmp	r1, r0
		sum += v[i] * v[i];
     6ca:	eea7 7aa7 	vfma.f32	s14, s15, s15
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     6ce:	d1f9      	bne.n	6c4 <nd_norm(float*, int)+0xc>
     6d0:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
		sum += v[i] * v[i];
	}
	return sqrt(sum);
     6d4:	eeb1 0bc7 	vsqrt.f64	d0, d7
     6d8:	eeb4 0b40 	vcmp.f64	d0, d0
     6dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     6e0:	d105      	bne.n	6ee <nd_norm(float*, int)+0x36>
}
     6e2:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     6e6:	4770      	bx	lr
	Vector ops
*/

float nd_norm(float* v, int n) {
	float sum = 0;
	for (int i = 0; i < n; i++) {
     6e8:	ed9f 7b05 	vldr	d7, [pc, #20]	; 700 <nd_norm(float*, int)+0x48>
     6ec:	e7f2      	b.n	6d4 <nd_norm(float*, int)+0x1c>

/*
	Vector ops
*/

float nd_norm(float* v, int n) {
     6ee:	b508      	push	{r3, lr}
	float sum = 0;
	for (int i = 0; i < n; i++) {
		sum += v[i] * v[i];
	}
	return sqrt(sum);
     6f0:	eeb0 0b47 	vmov.f64	d0, d7
     6f4:	f004 f928 	bl	4948 <sqrt>
}
     6f8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     6fc:	bd08      	pop	{r3, pc}
     6fe:	bf00      	nop
	...

0000070c <weighted_vector_addition(float*, float*, float, float, int, float*)>:

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     70c:	2a00      	cmp	r2, #0
     70e:	dd0d      	ble.n	72c <weighted_vector_addition(float*, float*, float, float, int, float*)+0x20>
     710:	eb00 0282 	add.w	r2, r0, r2, lsl #2
		output[i] = (k1 * a[i]) + (k2 * b[i]);
     714:	ecf1 7a01 	vldmia	r1!, {s15}
     718:	ecb0 7a01 	vldmia	r0!, {s14}
     71c:	ee67 7aa0 	vmul.f32	s15, s15, s1

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     720:	4290      	cmp	r0, r2
		output[i] = (k1 * a[i]) + (k2 * b[i]);
     722:	eee7 7a00 	vfma.f32	s15, s14, s0
     726:	ece3 7a01 	vstmia	r3!, {s15}

	return ret;
}

void weighted_vector_addition(float* a, float* b, float k1, float k2, int n, float* output) {
	for (int i = 0; i < n; i++) {
     72a:	d1f3      	bne.n	714 <weighted_vector_addition(float*, float*, float, float, int, float*)+0x8>
     72c:	4770      	bx	lr
     72e:	bf00      	nop

00000730 <LSM6DSOX::reset()>:
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     730:	2300      	movs	r3, #0
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     732:	2200      	movs	r2, #0
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     734:	6103      	str	r3, [r0, #16]
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     736:	60c2      	str	r2, [r0, #12]
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
     738:	61c3      	str	r3, [r0, #28]
		mag[i] = 0;
     73a:	6283      	str	r3, [r0, #40]	; 0x28
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     73c:	6143      	str	r3, [r0, #20]
		gyro[i] = 0;
     73e:	6203      	str	r3, [r0, #32]
		mag[i] = 0;
     740:	62c3      	str	r3, [r0, #44]	; 0x2c
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     742:	6183      	str	r3, [r0, #24]
		gyro[i] = 0;
     744:	6243      	str	r3, [r0, #36]	; 0x24
		mag[i] = 0;
     746:	6303      	str	r3, [r0, #48]	; 0x30
     748:	4770      	bx	lr
     74a:	bf00      	nop

0000074c <LSM6DSOX::clear()>:
	}
}

void LSM6DSOX::clear() {
	reset();
     74c:	6803      	ldr	r3, [r0, #0]
     74e:	68db      	ldr	r3, [r3, #12]
     750:	4718      	bx	r3
     752:	bf00      	nop

00000754 <LSM6DSOX::setup(Vector<float>*)>:
}

void LSM6DSOX::setup(Vector<float>* config) {
	reset();
     754:	6803      	ldr	r3, [r0, #0]
     756:	68db      	ldr	r3, [r3, #12]
     758:	4718      	bx	r3
     75a:	bf00      	nop

0000075c <LSM6DSOX::context(Vector<float>*)>:
}

void LSM6DSOX::context(Vector<float>* context) {
     75c:	b538      	push	{r3, r4, r5, lr}
     75e:	460c      	mov	r4, r1
     760:	4605      	mov	r5, r0
	context->reset(dimensions[2]);
     762:	2102      	movs	r1, #2
     764:	3004      	adds	r0, #4
     766:	f000 fb0f 	bl	d88 <Vector<int>::operator[](int)>
     76a:	6801      	ldr	r1, [r0, #0]
     76c:	4620      	mov	r0, r4
     76e:	f000 fb3d 	bl	dec <Vector<float>::reset(int)>
	context->push(sensor_index);
     772:	ed95 0a03 	vldr	s0, [r5, #12]
     776:	4620      	mov	r0, r4
     778:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
}
     77c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	reset();
}

void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
     780:	f000 bb58 	b.w	e34 <Vector<float>::push(float)>

00000784 <LSM6DSOX::run(Vector<float>*, Vector<float>*)>:
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
	switch (sensor_index) {
     784:	68c3      	ldr	r3, [r0, #12]
     786:	2b01      	cmp	r3, #1
void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
     788:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     78c:	4604      	mov	r4, r0
     78e:	b08a      	sub	sp, #40	; 0x28
     790:	4617      	mov	r7, r2
	switch (sensor_index) {
     792:	d04c      	beq.n	82e <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0xaa>
     794:	2b02      	cmp	r3, #2
     796:	d039      	beq.n	80c <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x88>
     798:	b333      	cbz	r3, 7e8 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x64>
			read_lis3mdl();
			sensor_index = 0;
			break;

		default:
			sensor_index = 0;
     79a:	2300      	movs	r3, #0
     79c:	f100 0810 	add.w	r8, r0, #16
     7a0:	f100 061c 	add.w	r6, r0, #28
     7a4:	f100 0528 	add.w	r5, r0, #40	; 0x28
     7a8:	60c3      	str	r3, [r0, #12]
     7aa:	46c6      	mov	lr, r8
     7ac:	4631      	mov	r1, r6
     7ae:	4628      	mov	r0, r5
     7b0:	ab01      	add	r3, sp, #4
void LSM6DSOX::context(Vector<float>* context) {
	context->reset(dimensions[2]);
	context->push(sensor_index);
}

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
     7b2:	2203      	movs	r2, #3
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		tmp[i] = accel[i];
     7b4:	f85e cb04 	ldr.w	ip, [lr], #4
			sensor_index = 0;
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
     7b8:	3a01      	subs	r2, #1
		tmp[i] = accel[i];
		tmp[i+3] = gyro[i];
     7ba:	f851 6b04 	ldr.w	r6, [r1], #4
     7be:	f103 0304 	add.w	r3, r3, #4
		tmp[i+6] = mag[i];
     7c2:	f850 5b04 	ldr.w	r5, [r0], #4
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		tmp[i] = accel[i];
     7c6:	f843 cc04 	str.w	ip, [r3, #-4]
		tmp[i+3] = gyro[i];
     7ca:	609e      	str	r6, [r3, #8]
		tmp[i+6] = mag[i];
     7cc:	615d      	str	r5, [r3, #20]
			sensor_index = 0;
			break;
	}

	float tmp[LSM6DSOX_DOF];
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
     7ce:	d1f1      	bne.n	7b4 <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x30>
		tmp[i] = accel[i];
		tmp[i+3] = gyro[i];
		tmp[i+6] = mag[i];
	}

	output->from_array(tmp, dimensions[OUTPUT_DIMENSION]);
     7d0:	1d20      	adds	r0, r4, #4
     7d2:	2102      	movs	r1, #2
     7d4:	f000 fad8 	bl	d88 <Vector<int>::operator[](int)>
     7d8:	a901      	add	r1, sp, #4
     7da:	6802      	ldr	r2, [r0, #0]
     7dc:	4638      	mov	r0, r7
     7de:	f000 fb1b 	bl	e18 <Vector<float>::from_array(float*, int)>
}
     7e2:	b00a      	add	sp, #40	; 0x28
     7e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

void LSM6DSOX::read_lsm6dsox_accel(){
	/*
		Get the jawns from the jimmys
	*/
	lsm6dsox.readAcceleration(accel[0], accel[1], accel[2]);
     7e8:	f100 0810 	add.w	r8, r0, #16
     7ec:	f100 0318 	add.w	r3, r0, #24
     7f0:	f100 0214 	add.w	r2, r0, #20
     7f4:	305c      	adds	r0, #92	; 0x5c
     7f6:	4641      	mov	r1, r8
     7f8:	f104 061c 	add.w	r6, r4, #28
     7fc:	f003 fc28 	bl	4050 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)>

void LSM6DSOX::run(Vector<float>* unused, Vector<float>* output) {
	switch (sensor_index) {
		case 0:
			read_lsm6dsox_accel();
			sensor_index ++;
     800:	68e3      	ldr	r3, [r4, #12]
     802:	f104 0528 	add.w	r5, r4, #40	; 0x28
     806:	3301      	adds	r3, #1
     808:	60e3      	str	r3, [r4, #12]
			break;
     80a:	e7ce      	b.n	7aa <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>

void LSM6DSOX::read_lis3mdl(){
	/*
		Get the jawns from the jimmys
	*/
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
     80c:	f100 0528 	add.w	r5, r0, #40	; 0x28
     810:	f100 0330 	add.w	r3, r0, #48	; 0x30
     814:	f100 022c 	add.w	r2, r0, #44	; 0x2c
     818:	3034      	adds	r0, #52	; 0x34
     81a:	4629      	mov	r1, r5
     81c:	f104 0810 	add.w	r8, r4, #16
     820:	f003 f81e 	bl	3860 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)>
			sensor_index ++;
			break;

		case 2:
			read_lis3mdl();
			sensor_index = 0;
     824:	2300      	movs	r3, #0
     826:	f104 061c 	add.w	r6, r4, #28
     82a:	60e3      	str	r3, [r4, #12]
			break;
     82c:	e7bd      	b.n	7aa <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>

void LSM6DSOX::read_lsm6dsox_gyro(){
	/*
		Get the jawns from the jimmys
	*/
	lsm6dsox.readGyroscope(gyro[0], gyro[1], gyro[2]);
     82e:	f100 061c 	add.w	r6, r0, #28
     832:	f100 0324 	add.w	r3, r0, #36	; 0x24
     836:	f100 0220 	add.w	r2, r0, #32
     83a:	305c      	adds	r0, #92	; 0x5c
     83c:	4631      	mov	r1, r6
     83e:	f104 0810 	add.w	r8, r4, #16
     842:	f003 fc69 	bl	4118 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)>
			sensor_index ++;
			break;

		case 1:
			read_lsm6dsox_gyro();
			sensor_index ++;
     846:	68e3      	ldr	r3, [r4, #12]
     848:	f104 0528 	add.w	r5, r4, #40	; 0x28
     84c:	3301      	adds	r3, #1
     84e:	60e3      	str	r3, [r4, #12]
			break;
     850:	e7ab      	b.n	7aa <LSM6DSOX::run(Vector<float>*, Vector<float>*)+0x26>
     852:	bf00      	nop

00000854 <LSM6DSOX::print()>:

	output->from_array(tmp, dimensions[OUTPUT_DIMENSION]);
}


void LSM6DSOX::print() {
     854:	b530      	push	{r4, r5, lr}
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
     856:	4d29      	ldr	r5, [pc, #164]	; (8fc <LSM6DSOX::print()+0xa8>)
     858:	b085      	sub	sp, #20
     85a:	4604      	mov	r4, r0
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
     85c:	2108      	movs	r1, #8
     85e:	4828      	ldr	r0, [pc, #160]	; (900 <LSM6DSOX::print()+0xac>)
     860:	f001 fff8 	bl	2854 <usb_seremu_write>
     864:	4628      	mov	r0, r5
     866:	f002 f885 	bl	2974 <Print::println()>
	Serial.println("LSM6DSOX");
	Serial.printf("\tsensor_index: %i\n", sensor_index);
     86a:	68e2      	ldr	r2, [r4, #12]
     86c:	4628      	mov	r0, r5
     86e:	4925      	ldr	r1, [pc, #148]	; (904 <LSM6DSOX::print()+0xb0>)
     870:	f002 f898 	bl	29a4 <Print::printf(char const*, ...)>
	Serial.printf("\taccel: [%f, %f, %f]\n", accel[0], accel[1], accel[2]);
     874:	ed94 6a06 	vldr	s12, [r4, #24]
     878:	ed94 7a05 	vldr	s14, [r4, #20]
     87c:	4628      	mov	r0, r5
     87e:	edd4 5a04 	vldr	s11, [r4, #16]
     882:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     886:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     88a:	491f      	ldr	r1, [pc, #124]	; (908 <LSM6DSOX::print()+0xb4>)
     88c:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     890:	ed8d 6b02 	vstr	d6, [sp, #8]
     894:	ec53 2b15 	vmov	r2, r3, d5
     898:	ed8d 7b00 	vstr	d7, [sp]
     89c:	f002 f882 	bl	29a4 <Print::printf(char const*, ...)>
	Serial.printf("\tgyro: [%f, %f, %f]\n", gyro[0], gyro[1], gyro[2]);
     8a0:	ed94 6a09 	vldr	s12, [r4, #36]	; 0x24
     8a4:	ed94 7a08 	vldr	s14, [r4, #32]
     8a8:	4628      	mov	r0, r5
     8aa:	edd4 5a07 	vldr	s11, [r4, #28]
     8ae:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     8b2:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     8b6:	4915      	ldr	r1, [pc, #84]	; (90c <LSM6DSOX::print()+0xb8>)
     8b8:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     8bc:	ed8d 6b02 	vstr	d6, [sp, #8]
     8c0:	ec53 2b15 	vmov	r2, r3, d5
     8c4:	ed8d 7b00 	vstr	d7, [sp]
     8c8:	f002 f86c 	bl	29a4 <Print::printf(char const*, ...)>
	Serial.printf("\tmag: [%f, %f, %f]\n", mag[0], mag[1], mag[2]);
     8cc:	ed94 6a0c 	vldr	s12, [r4, #48]	; 0x30
     8d0:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
     8d4:	4628      	mov	r0, r5
     8d6:	edd4 5a0a 	vldr	s11, [r4, #40]	; 0x28
     8da:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     8de:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
     8e2:	490b      	ldr	r1, [pc, #44]	; (910 <LSM6DSOX::print()+0xbc>)
     8e4:	eeb7 5ae5 	vcvt.f64.f32	d5, s11
     8e8:	ed8d 6b02 	vstr	d6, [sp, #8]
     8ec:	ec53 2b15 	vmov	r2, r3, d5
     8f0:	ed8d 7b00 	vstr	d7, [sp]
     8f4:	f002 f856 	bl	29a4 <Print::printf(char const*, ...)>
	// data.print();
}
     8f8:	b005      	add	sp, #20
     8fa:	bd30      	pop	{r4, r5, pc}
     8fc:	2000147c 	.word	0x2000147c
     900:	20000cb0 	.word	0x20000cb0
     904:	20000cbc 	.word	0x20000cbc
     908:	20000cd0 	.word	0x20000cd0
     90c:	20000ce8 	.word	0x20000ce8
     910:	20000d00 	.word	0x20000d00

00000914 <LSM6DSOX::LSM6DSOX()>:
#include "lsm6dsox.h"

LSM6DSOX::LSM6DSOX() {
     914:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     918:	4b48      	ldr	r3, [pc, #288]	; (a3c <LSM6DSOX::LSM6DSOX()+0x128>)
     91a:	4680      	mov	r8, r0
     91c:	b084      	sub	sp, #16
     91e:	4605      	mov	r5, r0
     920:	f100 075c 	add.w	r7, r0, #92	; 0x5c
     924:	4606      	mov	r6, r0
     926:	f848 3b04 	str.w	r3, [r8], #4
     92a:	4640      	mov	r0, r8
     92c:	f000 f9fe 	bl	d2c <Vector<int>::Vector()>
     930:	4b43      	ldr	r3, [pc, #268]	; (a40 <LSM6DSOX::LSM6DSOX()+0x12c>)
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     932:	2400      	movs	r4, #0
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     934:	f8df a10c 	ldr.w	sl, [pc, #268]	; a44 <LSM6DSOX::LSM6DSOX()+0x130>
#include "lsm6dsox.h"

LSM6DSOX::LSM6DSOX() {
     938:	f846 3b34 	str.w	r3, [r6], #52
     93c:	4630      	mov	r0, r6
     93e:	f002 fda3 	bl	3488 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()>
     942:	4638      	mov	r0, r7
     944:	f003 fc66 	bl	4214 <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()>
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     948:	f04f 0e00 	mov.w	lr, #0
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     94c:	4623      	mov	r3, r4
     94e:	4652      	mov	r2, sl
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     950:	f8c5 e010 	str.w	lr, [r5, #16]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     954:	4638      	mov	r0, r7

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
     956:	f8c5 e01c 	str.w	lr, [r5, #28]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     95a:	216a      	movs	r1, #106	; 0x6a
void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
		gyro[i] = 0;
		mag[i] = 0;
     95c:	f8c5 e028 	str.w	lr, [r5, #40]	; 0x28
	lis3mdl.setOperationMode(IMU_M_OP_MODE);
	
	lis3mdl.configInterrupt(false, false, false,   // enable z axis
											true,  // polarity
											false, // don't latch
											true); // enabled!
     960:	f04f 0901 	mov.w	r9, #1
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     964:	f8c5 e014 	str.w	lr, [r5, #20]
		gyro[i] = 0;
     968:	f8c5 e020 	str.w	lr, [r5, #32]
		mag[i] = 0;
     96c:	f8c5 e02c 	str.w	lr, [r5, #44]	; 0x2c
}

void LSM6DSOX::reset() {
	sensor_index = 0;
	for (int i = 0; i < LSM6DSOX_SENSOR_DOF; i++) {
		accel[i] = 0;
     970:	f8c5 e018 	str.w	lr, [r5, #24]
		gyro[i] = 0;
     974:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
		mag[i] = 0;
     978:	f8c5 e030 	str.w	lr, [r5, #48]	; 0x30
	lis3mdl.readMagneticField(mag[0], mag[1], mag[2]);
	// Serial.print("LIS3MDL mag read time: "); Serial.println(micros() - read_start);
}

void LSM6DSOX::reset() {
	sensor_index = 0;
     97c:	60ec      	str	r4, [r5, #12]
	*/	

	reset();

	// LSM6DSOX Setup
	lsm6dsox.begin_I2C();
     97e:	f003 f9cd 	bl	3d1c <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)>
	lsm6dsox.setAccelRange(IMU_A_RANGE);
     982:	4638      	mov	r0, r7
     984:	2102      	movs	r1, #2
     986:	f003 fa2f 	bl	3de8 <Adafruit_LSM6DS::setAccelRange(accel_range)>
	lsm6dsox.setGyroRange(IMU_G_RANGE);
     98a:	4638      	mov	r0, r7
     98c:	2108      	movs	r1, #8
     98e:	f003 fa6b 	bl	3e68 <Adafruit_LSM6DS::setGyroRange(gyro_range)>
	lsm6dsox.setAccelDataRate(IMU_A_DATA_RATE);
     992:	4638      	mov	r0, r7
     994:	2108      	movs	r1, #8
     996:	f003 fa07 	bl	3da8 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>
	lsm6dsox.setGyroDataRate(IMU_G_DATA_RATE);
     99a:	4638      	mov	r0, r7
     99c:	2108      	movs	r1, #8
     99e:	f003 fa45 	bl	3e2c <Adafruit_LSM6DS::setGyroDataRate(data_rate)>
		@param active_low true to set the pins  as active high, false to set the
		mode to active low
		@param open_drain true to set the pin mode as open-drain, false to set the
		mode to push-pull
	*/
	lsm6dsox.configIntOutputs(false, true);
     9a2:	4638      	mov	r0, r7
     9a4:	4621      	mov	r1, r4
     9a6:	464a      	mov	r2, r9
     9a8:	f003 faca 	bl	3f40 <Adafruit_LSM6DS::configIntOutputs(bool, bool)>
		@param drdy_g true to output the data ready gyro interrupt
		@param drdy_xl true to output the data ready accelerometer interrupt
		@param step_detect true to output the step detection interrupt (default off)
		@param wakeup true to output the wake up interrupt (default off)
	*/
	lsm6dsox.configInt1(false, false, false, false, false);
     9ac:	4638      	mov	r0, r7
     9ae:	4623      	mov	r3, r4
     9b0:	4622      	mov	r2, r4
     9b2:	4621      	mov	r1, r4
     9b4:	9401      	str	r4, [sp, #4]
     9b6:	9400      	str	r4, [sp, #0]
     9b8:	f003 fae4 	bl	3f84 <Adafruit_LSM6DS::configInt1(bool, bool, bool, bool, bool)>
		@brief Enables and disables the data ready interrupt on INT 2.
		@param drdy_temp true to output the data ready temperature interrupt
		@param drdy_g true to output the data ready gyro interrupt
		@param drdy_xl true to output the data ready accelerometer interrupt
	*/
	lsm6dsox.configInt2(false, false, false);
     9bc:	4623      	mov	r3, r4
     9be:	4622      	mov	r2, r4
     9c0:	4621      	mov	r1, r4
     9c2:	4638      	mov	r0, r7
     9c4:	f003 fb1c 	bl	4000 <Adafruit_LSM6DS::configInt2(bool, bool, bool)>

	// LIS3MDL Setup
	lis3mdl.begin_I2C();
     9c8:	4652      	mov	r2, sl
     9ca:	4630      	mov	r0, r6
     9cc:	211c      	movs	r1, #28
     9ce:	f002 fefb 	bl	37c8 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)>
	lis3mdl.setRange(IMU_M_RANGE);
     9d2:	4630      	mov	r0, r6
     9d4:	4649      	mov	r1, r9
     9d6:	f002 fe6d 	bl	36b4 <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>
	lis3mdl.setDataRate(IMU_M_DATA_RATE);
     9da:	4630      	mov	r0, r6
     9dc:	2107      	movs	r1, #7
     9de:	f002 fe15 	bl	360c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>
	lis3mdl.setPerformanceMode(IMU_M_PERFORMANCE);
     9e2:	4630      	mov	r0, r6
     9e4:	2103      	movs	r1, #3
     9e6:	f002 fddb 	bl	35a0 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
	lis3mdl.setOperationMode(IMU_M_OP_MODE);
     9ea:	4621      	mov	r1, r4
     9ec:	4630      	mov	r0, r6
     9ee:	f002 fe45 	bl	367c <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>
	
	lis3mdl.configInterrupt(false, false, false,   // enable z axis
											true,  // polarity
											false, // don't latch
											true); // enabled!
     9f2:	4622      	mov	r2, r4
     9f4:	4623      	mov	r3, r4
     9f6:	4630      	mov	r0, r6
     9f8:	4621      	mov	r1, r4
     9fa:	9401      	str	r4, [sp, #4]
     9fc:	f8cd 9008 	str.w	r9, [sp, #8]
     a00:	f8cd 9000 	str.w	r9, [sp]
     a04:	f002 ff00 	bl	3808 <Adafruit_LIS3MDL::configInterrupt(bool, bool, bool, bool, bool, bool)>

	dimensions.reset(PROCESS_DIMENSIONS);
     a08:	4640      	mov	r0, r8
     a0a:	2103      	movs	r1, #3
     a0c:	f000 f998 	bl	d40 <Vector<int>::reset(int)>
	dimensions[INPUT_DIMENSION] = 0;
     a10:	4621      	mov	r1, r4
     a12:	4640      	mov	r0, r8
     a14:	f000 f9b8 	bl	d88 <Vector<int>::operator[](int)>
     a18:	4603      	mov	r3, r0
	dimensions[CONTEXT_DIMENSION] = 1;
     a1a:	4649      	mov	r1, r9
     a1c:	4640      	mov	r0, r8
											true,  // polarity
											false, // don't latch
											true); // enabled!

	dimensions.reset(PROCESS_DIMENSIONS);
	dimensions[INPUT_DIMENSION] = 0;
     a1e:	601c      	str	r4, [r3, #0]
	dimensions[CONTEXT_DIMENSION] = 1;
     a20:	f000 f9b2 	bl	d88 <Vector<int>::operator[](int)>
	dimensions[OUTPUT_DIMENSION] = LSM6DSOX_DOF;
     a24:	2102      	movs	r1, #2
											false, // don't latch
											true); // enabled!

	dimensions.reset(PROCESS_DIMENSIONS);
	dimensions[INPUT_DIMENSION] = 0;
	dimensions[CONTEXT_DIMENSION] = 1;
     a26:	f8c0 9000 	str.w	r9, [r0]
	dimensions[OUTPUT_DIMENSION] = LSM6DSOX_DOF;
     a2a:	4640      	mov	r0, r8
     a2c:	f000 f9ac 	bl	d88 <Vector<int>::operator[](int)>
     a30:	2309      	movs	r3, #9
     a32:	6003      	str	r3, [r0, #0]
}
     a34:	4628      	mov	r0, r5
     a36:	b004      	add	sp, #16
     a38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     a3c:	20000540 	.word	0x20000540
     a40:	20000590 	.word	0x20000590
     a44:	2000148c 	.word	0x2000148c

00000a48 <Process::input_dim()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Print");
}

int Process::input_dim() {
     a48:	b508      	push	{r3, lr}
		Base implementation of process functions.
		returns dimensions of the input.
		@return
			dimension: (int) size of input
	*/
	return dimensions[0];
     a4a:	2100      	movs	r1, #0
     a4c:	3004      	adds	r0, #4
     a4e:	f000 f99b 	bl	d88 <Vector<int>::operator[](int)>
}
     a52:	6800      	ldr	r0, [r0, #0]
     a54:	bd08      	pop	{r3, pc}
     a56:	bf00      	nop

00000a58 <Process::context_dim()>:

int Process::context_dim() {
     a58:	b508      	push	{r3, lr}
		Base implementation of process functions.
		returns dimensions of the context.
		@return
			dimension: (int) size of input
	*/
	return dimensions[1];
     a5a:	2101      	movs	r1, #1
     a5c:	3004      	adds	r0, #4
     a5e:	f000 f993 	bl	d88 <Vector<int>::operator[](int)>
}
     a62:	6800      	ldr	r0, [r0, #0]
     a64:	bd08      	pop	{r3, pc}
     a66:	bf00      	nop

00000a68 <Process::output_dim()>:

int Process::output_dim() {
     a68:	b508      	push	{r3, lr}
		Base implementation of process functions.
		returns dimensions of the output.
		@return
			dimension: (int) size of input
	*/
	return dimensions[2];
     a6a:	2102      	movs	r1, #2
     a6c:	3004      	adds	r0, #4
     a6e:	f000 f98b 	bl	d88 <Vector<int>::operator[](int)>
}
     a72:	6800      	ldr	r0, [r0, #0]
     a74:	bd08      	pop	{r3, pc}
     a76:	bf00      	nop

00000a78 <Process::reset()>:
#include "syncor/process.h"

// Drivers
#include "sensors/lsm6dsox.h"

void Process::reset() {
     a78:	b508      	push	{r3, lr}
     a7a:	2109      	movs	r1, #9
     a7c:	4803      	ldr	r0, [pc, #12]	; (a8c <Process::reset()+0x14>)
     a7e:	f001 fee9 	bl	2854 <usb_seremu_write>
     a82:	4803      	ldr	r0, [pc, #12]	; (a90 <Process::reset()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Reset");
}
     a84:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     a88:	f001 bf74 	b.w	2974 <Print::println()>
     a8c:	20000d14 	.word	0x20000d14
     a90:	2000147c 	.word	0x2000147c

00000a94 <Process::print()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Clear");
}

void Process::print() {
     a94:	b508      	push	{r3, lr}
     a96:	2109      	movs	r1, #9
     a98:	4803      	ldr	r0, [pc, #12]	; (aa8 <Process::print()+0x14>)
     a9a:	f001 fedb 	bl	2854 <usb_seremu_write>
     a9e:	4803      	ldr	r0, [pc, #12]	; (aac <Process::print()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Print");
}
     aa0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     aa4:	f001 bf66 	b.w	2974 <Print::println()>
     aa8:	20000d20 	.word	0x20000d20
     aac:	2000147c 	.word	0x2000147c

00000ab0 <Process::clear()>:
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Reset");
}

void Process::clear() {
     ab0:	b508      	push	{r3, lr}
     ab2:	2109      	movs	r1, #9
     ab4:	4803      	ldr	r0, [pc, #12]	; (ac4 <Process::clear()+0x14>)
     ab6:	f001 fecd 	bl	2854 <usb_seremu_write>
     aba:	4803      	ldr	r0, [pc, #12]	; (ac8 <Process::clear()+0x18>)
	/*
		Base implementation of process functions.
		Only defined to show user when inheritance has issues.
	*/
	Serial.println("PBO Clear");
}
     abc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     ac0:	f001 bf58 	b.w	2974 <Print::println()>
     ac4:	20000d2c 	.word	0x20000d2c
     ac8:	2000147c 	.word	0x2000147c

00000acc <Process::setup(Vector<float>*)>:
			dimension: (int) size of input
	*/
	return dimensions[2];
}

void Process::setup(Vector<float>* config) {
     acc:	b510      	push	{r4, lr}
     ace:	4806      	ldr	r0, [pc, #24]	; (ae8 <Process::setup(Vector<float>*)+0x1c>)
     ad0:	460c      	mov	r4, r1
     ad2:	2109      	movs	r1, #9
     ad4:	f001 febe 	bl	2854 <usb_seremu_write>
     ad8:	4804      	ldr	r0, [pc, #16]	; (aec <Process::setup(Vector<float>*)+0x20>)
     ada:	f001 ff4b 	bl	2974 <Print::println()>
		@param
			config: (Vector<float>) Vector of configuration data, 
				organization is handled by user
	*/
	Serial.println("PBO Setup");
	config->print();
     ade:	4620      	mov	r0, r4
}
     ae0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		@param
			config: (Vector<float>) Vector of configuration data, 
				organization is handled by user
	*/
	Serial.println("PBO Setup");
	config->print();
     ae4:	f000 b8e6 	b.w	cb4 <Vector<float>::print()>
     ae8:	20000d38 	.word	0x20000d38
     aec:	2000147c 	.word	0x2000147c

00000af0 <Process::context(Vector<float>*)>:
}

void Process::context(Vector<float>* context) {
     af0:	b510      	push	{r4, lr}
     af2:	4807      	ldr	r0, [pc, #28]	; (b10 <Process::context(Vector<float>*)+0x20>)
     af4:	460c      	mov	r4, r1
     af6:	2115      	movs	r1, #21
     af8:	f001 feac 	bl	2854 <usb_seremu_write>
     afc:	4805      	ldr	r0, [pc, #20]	; (b14 <Process::context(Vector<float>*)+0x24>)
     afe:	f001 ff39 	bl	2974 <Print::println()>
		Only defined to show user when inheritance has issues.
		@param
			context: (Vector<float>*) empty vector to fill with the context
	*/
	Serial.println("Requested PBO context");
	context->reset(0);
     b02:	4620      	mov	r0, r4
     b04:	2100      	movs	r1, #0
}
     b06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		Only defined to show user when inheritance has issues.
		@param
			context: (Vector<float>*) empty vector to fill with the context
	*/
	Serial.println("Requested PBO context");
	context->reset(0);
     b0a:	f000 b96f 	b.w	dec <Vector<float>::reset(int)>
     b0e:	bf00      	nop
     b10:	20000d44 	.word	0x20000d44
     b14:	2000147c 	.word	0x2000147c

00000b18 <Process::run(Vector<float>*, Vector<float>*)>:
}

void Process::run(Vector<float>* input, Vector<float>* output) {
     b18:	b510      	push	{r4, lr}
     b1a:	2107      	movs	r1, #7
     b1c:	4614      	mov	r4, r2
     b1e:	4806      	ldr	r0, [pc, #24]	; (b38 <Process::run(Vector<float>*, Vector<float>*)+0x20>)
     b20:	f001 fe98 	bl	2854 <usb_seremu_write>
     b24:	4805      	ldr	r0, [pc, #20]	; (b3c <Process::run(Vector<float>*, Vector<float>*)+0x24>)
     b26:	f001 ff25 	bl	2974 <Print::println()>
		@param
			input: (Vector<float>*) flattened Vector of input data for process
			output: (Vector<float>*) flattened Vector of output data from process
	*/
	Serial.println("PBO Run");
	output->reset(0);
     b2a:	4620      	mov	r0, r4
     b2c:	2100      	movs	r1, #0
}
     b2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		@param
			input: (Vector<float>*) flattened Vector of input data for process
			output: (Vector<float>*) flattened Vector of output data from process
	*/
	Serial.println("PBO Run");
	output->reset(0);
     b32:	f000 b95b 	b.w	dec <Vector<float>::reset(int)>
     b36:	bf00      	nop
     b38:	20000d5c 	.word	0x20000d5c
     b3c:	2000147c 	.word	0x2000147c

00000b40 <SynCorNode::output()>:
		Get a pointer to the output buffer
		@return
			output: (Vector<float>*) buffer of output data
	*/
	return &output_buffer;
}
     b40:	3010      	adds	r0, #16
     b42:	4770      	bx	lr

00000b44 <SynCorNode::config()>:
		Get a pointer to the setup buffer
		@return
			config: (Vector<float>*) buffer of setup data
	*/
	return &config_buffer;
}
     b44:	3018      	adds	r0, #24
     b46:	4770      	bx	lr

00000b48 <SynCorNode::set_config(int)>:
		called when setting up a process or new node.
		Will also zero the current config to ensure reinitialization.
		@param
			configs: (int) number of config values (floats)
	*/
	config_shape = configs;
     b48:	f840 1b18 	str.w	r1, [r0], #24
	config_buffer.reset(0);
     b4c:	2100      	movs	r1, #0
     b4e:	f000 b94d 	b.w	dec <Vector<float>::reset(int)>
     b52:	bf00      	nop

00000b54 <SynCorNode::set_process(Process*)>:
			n_inputs: (int) number of input nodes.
	*/
	inputs.from_array(input_ids, n_inputs);
}

void SynCorNode::set_process(Process* process) {
     b54:	b510      	push	{r4, lr}
		state is the zero state.
		@param
			process: (Process) User defined process.
	*/
	proc = process;
	proc->reset();
     b56:	680b      	ldr	r3, [r1, #0]
			n_inputs: (int) number of input nodes.
	*/
	inputs.from_array(input_ids, n_inputs);
}

void SynCorNode::set_process(Process* process) {
     b58:	4604      	mov	r4, r0
		state is the zero state.
		@param
			process: (Process) User defined process.
	*/
	proc = process;
	proc->reset();
     b5a:	4608      	mov	r0, r1
		Also resets the process and output vector to ensure initial
		state is the zero state.
		@param
			process: (Process) User defined process.
	*/
	proc = process;
     b5c:	6061      	str	r1, [r4, #4]
	proc->reset();
     b5e:	68db      	ldr	r3, [r3, #12]
     b60:	4798      	blx	r3
	output_buffer.reset(proc->output_dim());
     b62:	6860      	ldr	r0, [r4, #4]
     b64:	6803      	ldr	r3, [r0, #0]
     b66:	689b      	ldr	r3, [r3, #8]
     b68:	4798      	blx	r3
     b6a:	4601      	mov	r1, r0
     b6c:	f104 0010 	add.w	r0, r4, #16
}
     b70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		@param
			process: (Process) User defined process.
	*/
	proc = process;
	proc->reset();
	output_buffer.reset(proc->output_dim());
     b74:	f000 b93a 	b.w	dec <Vector<float>::reset(int)>

00000b78 <SynCorNode::SynCorNode(Process*, int, int, int*)>:
	inputs.reset(0);
	output_buffer.reset(0);
	config_buffer.reset(0);
}

SynCorNode::SynCorNode(Process* p, int n_configs, int n_inputs, int* input_ids) {
     b78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     b7c:	f100 0508 	add.w	r5, r0, #8
     b80:	4604      	mov	r4, r0
     b82:	f100 0618 	add.w	r6, r0, #24
     b86:	4690      	mov	r8, r2
     b88:	4628      	mov	r0, r5
     b8a:	461f      	mov	r7, r3
     b8c:	4689      	mov	r9, r1
     b8e:	f000 f8cd 	bl	d2c <Vector<int>::Vector()>
     b92:	f104 0010 	add.w	r0, r4, #16
     b96:	f000 f905 	bl	da4 <Vector<float>::Vector()>
     b9a:	4630      	mov	r0, r6
     b9c:	f000 f902 	bl	da4 <Vector<float>::Vector()>
     ba0:	f104 0020 	add.w	r0, r4, #32
     ba4:	f000 f8fe 	bl	da4 <Vector<float>::Vector()>
			n_inputs: (int) number of input nodes
			input_ids: (int*) the identifiers of input nodes (in order of concatenation),
				does not specify the process index in the syncor list but a unique 
				process id associated with each process.
	*/
	set_process(p);
     ba8:	4649      	mov	r1, r9
     baa:	4620      	mov	r0, r4
     bac:	f7ff ffd2 	bl	b54 <SynCorNode::set_process(Process*)>
		Will also zero the current config to ensure reinitialization.
		@param
			configs: (int) number of config values (floats)
	*/
	config_shape = configs;
	config_buffer.reset(0);
     bb0:	4630      	mov	r0, r6
		called when setting up a process or new node.
		Will also zero the current config to ensure reinitialization.
		@param
			configs: (int) number of config values (floats)
	*/
	config_shape = configs;
     bb2:	f8c4 8000 	str.w	r8, [r4]
	config_buffer.reset(0);
     bb6:	2100      	movs	r1, #0
     bb8:	f000 f918 	bl	dec <Vector<float>::reset(int)>
		Set the unique IDs of all input nodes.
		@param
			input_ids: (int*) unique IDs of input nodes.
			n_inputs: (int) number of input nodes.
	*/
	inputs.from_array(input_ids, n_inputs);
     bbc:	4628      	mov	r0, r5
     bbe:	463a      	mov	r2, r7
     bc0:	9908      	ldr	r1, [sp, #32]
     bc2:	f000 f8d3 	bl	d6c <Vector<int>::from_array(int*, int)>
				process id associated with each process.
	*/
	set_process(p);
	set_config(n_configs);
	set_inputs(input_ids, n_inputs);
}
     bc6:	4620      	mov	r0, r4
     bc8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00000bcc <SynCorNode::setup_proc()>:
	proc = process;
	proc->reset();
	output_buffer.reset(proc->output_dim());
}

bool SynCorNode::setup_proc() {
     bcc:	b570      	push	{r4, r5, r6, lr}
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     bce:	4604      	mov	r4, r0
	proc = process;
	proc->reset();
	output_buffer.reset(proc->output_dim());
}

bool SynCorNode::setup_proc() {
     bd0:	4605      	mov	r5, r0
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     bd2:	f854 6b18 	ldr.w	r6, [r4], #24
     bd6:	4620      	mov	r0, r4
     bd8:	f000 f94e 	bl	e78 <Vector<float>::size()>
		Call the processes user defined setup function with the config buffer.
		Does nothing when not configured.
		@return
			status: (bool) if setup was called.
	*/
	if (is_configured()) {
     bdc:	4286      	cmp	r6, r0
     bde:	d001      	beq.n	be4 <SynCorNode::setup_proc()+0x18>
		proc->setup(&config_buffer);
		return true;		
	}
	return false;
     be0:	2000      	movs	r0, #0
}
     be2:	bd70      	pop	{r4, r5, r6, pc}
		Does nothing when not configured.
		@return
			status: (bool) if setup was called.
	*/
	if (is_configured()) {
		proc->setup(&config_buffer);
     be4:	6868      	ldr	r0, [r5, #4]
     be6:	4621      	mov	r1, r4
     be8:	6803      	ldr	r3, [r0, #0]
     bea:	699b      	ldr	r3, [r3, #24]
     bec:	4798      	blx	r3
		return true;		
     bee:	2001      	movs	r0, #1
     bf0:	bd70      	pop	{r4, r5, r6, pc}
     bf2:	bf00      	nop

00000bf4 <SynCorNode::run_proc(Vector<float>*)>:
	}
	return false;
}

bool SynCorNode::run_proc(Vector<float>* input_buffer) {
     bf4:	b570      	push	{r4, r5, r6, lr}
     bf6:	4604      	mov	r4, r0
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     bf8:	f850 5b18 	ldr.w	r5, [r0], #24
		return true;		
	}
	return false;
}

bool SynCorNode::run_proc(Vector<float>* input_buffer) {
     bfc:	460e      	mov	r6, r1
		Check if the process is configured. Needed because
		setup data may be sent in chunks.
		@return
			status: (bool) if process is configured
	*/
	return config_shape == config_buffer.size();
     bfe:	f000 f93b 	bl	e78 <Vector<float>::size()>
			input_buffer: (Vector<float>*) concatenated outputs of processes
				listed in input_ids
		@return
			status: (bool) if run was called.
	*/
	if (is_configured() && input_buffer->size() == proc->input_dim()) {
     c02:	4285      	cmp	r5, r0
     c04:	d001      	beq.n	c0a <SynCorNode::run_proc(Vector<float>*)+0x16>
		proc->run(input_buffer, &output_buffer);
		return true;		
	}
	return false;
     c06:	2000      	movs	r0, #0
     c08:	bd70      	pop	{r4, r5, r6, pc}
			input_buffer: (Vector<float>*) concatenated outputs of processes
				listed in input_ids
		@return
			status: (bool) if run was called.
	*/
	if (is_configured() && input_buffer->size() == proc->input_dim()) {
     c0a:	4630      	mov	r0, r6
     c0c:	f000 f934 	bl	e78 <Vector<float>::size()>
     c10:	4605      	mov	r5, r0
     c12:	6860      	ldr	r0, [r4, #4]
     c14:	6803      	ldr	r3, [r0, #0]
     c16:	681b      	ldr	r3, [r3, #0]
     c18:	4798      	blx	r3
     c1a:	4285      	cmp	r5, r0
     c1c:	d1f3      	bne.n	c06 <SynCorNode::run_proc(Vector<float>*)+0x12>
		proc->run(input_buffer, &output_buffer);
     c1e:	6860      	ldr	r0, [r4, #4]
     c20:	4631      	mov	r1, r6
     c22:	f104 0210 	add.w	r2, r4, #16
     c26:	6803      	ldr	r3, [r0, #0]
     c28:	6a1b      	ldr	r3, [r3, #32]
     c2a:	4798      	blx	r3
		return true;		
     c2c:	2001      	movs	r0, #1
	}
	return false;
}
     c2e:	bd70      	pop	{r4, r5, r6, pc}

00000c30 <SynCorNode::print_proc()>:
void SynCorNode::print_proc() {
	/*
		Dump all process info. Requires that the user defined a print
		for their process.
	*/
	proc->print();
     c30:	6840      	ldr	r0, [r0, #4]
     c32:	6803      	ldr	r3, [r0, #0]
     c34:	695b      	ldr	r3, [r3, #20]
     c36:	4718      	bx	r3

00000c38 <SynCorNode::print_output()>:
}

void SynCorNode::print_output() {
     c38:	b510      	push	{r4, lr}
     c3a:	4604      	mov	r4, r0
     c3c:	2101      	movs	r1, #1
     c3e:	4804      	ldr	r0, [pc, #16]	; (c50 <SynCorNode::print_output()+0x18>)
     c40:	f001 fe08 	bl	2854 <usb_seremu_write>
	/*
		Dump output buffer.
	*/
	Serial.print("\t");
	output_buffer.print();
     c44:	f104 0010 	add.w	r0, r4, #16
}
     c48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void SynCorNode::print_output() {
	/*
		Dump output buffer.
	*/
	Serial.print("\t");
	output_buffer.print();
     c4c:	f000 b832 	b.w	cb4 <Vector<float>::print()>
     c50:	20000d74 	.word	0x20000d74

00000c54 <FTYK::FTYK()>:
	uint32_t delta_ns = CYCLES_2_NS(delta_cycles); 
	Serial.printf( "\t%1lu cycles, %1lu ns\n", delta_cycles, delta_ns);
	return delta_ns;
}

FTYK::FTYK() {
     c54:	b410      	push	{r4}
     c56:	1f03      	subs	r3, r0, #4
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
		timers[i] = ARM_DWT_CYCCNT;
     c58:	4c05      	ldr	r4, [pc, #20]	; (c70 <FTYK::FTYK()+0x1c>)
     c5a:	f100 0124 	add.w	r1, r0, #36	; 0x24
     c5e:	6822      	ldr	r2, [r4, #0]
     c60:	f843 2f04 	str.w	r2, [r3, #4]!
			- add rollover support: ARM_DWT_CYCCNT is a cycle count that resets every 8
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
     c64:	428b      	cmp	r3, r1
     c66:	d1fa      	bne.n	c5e <FTYK::FTYK()+0xa>
		timers[i] = ARM_DWT_CYCCNT;
	}
}
     c68:	f85d 4b04 	ldr.w	r4, [sp], #4
     c6c:	4770      	bx	lr
     c6e:	bf00      	nop
     c70:	e0001004 	.word	0xe0001004

00000c74 <FTYK::set(int)>:
	/*
		  Set the timer at idx to the current cycle count.
		@param:
			idx: (int) index of the timer to set.
	*/
	timers[idx] = ARM_DWT_CYCCNT;
     c74:	4b02      	ldr	r3, [pc, #8]	; (c80 <FTYK::set(int)+0xc>)
     c76:	681b      	ldr	r3, [r3, #0]
     c78:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
     c7c:	4770      	bx	lr
     c7e:	bf00      	nop
     c80:	e0001004 	.word	0xe0001004
     c84:	00000000 	.word	0x00000000

00000c88 <FTYK::micros(int)>:
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     c88:	4b09      	ldr	r3, [pc, #36]	; (cb0 <FTYK::micros(int)+0x28>)
	/*
		  Get the number of microseconds since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return CYCLES_2_US(cycles(idx)); 
     c8a:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
	/*
		  Get the number of cycles since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return ARM_DWT_CYCCNT - timers[idx];
     c8e:	681b      	ldr	r3, [r3, #0]
	/*
		  Get the number of microseconds since last timer.set().
		@param:
			idx: (int) index of the timer to get cycles from.
	*/
	return CYCLES_2_US(cycles(idx)); 
     c90:	1a9b      	subs	r3, r3, r2
     c92:	ee00 3a10 	vmov	s0, r3
     c96:	ed9f 7b04 	vldr	d7, [pc, #16]	; ca8 <FTYK::micros(int)+0x20>
     c9a:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
     c9e:	ee20 0b07 	vmul.f64	d0, d0, d7
}
     ca2:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
     ca6:	4770      	bx	lr
     ca8:	b4e81b4f 	.word	0xb4e81b4f
     cac:	3f5b4e81 	.word	0x3f5b4e81
     cb0:	e0001004 	.word	0xe0001004

00000cb4 <Vector<float>::print()>:
	}
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
	if (length == 0) {
     cb4:	6802      	ldr	r2, [r0, #0]
     cb6:	b352      	cbz	r2, d0e <Vector<float>::print()+0x5a>
		Serial.printf("Vectorf [%i]\n", length);
		return;
	}
	Serial.printf("Vectorf [%i]: [", length);
     cb8:	4917      	ldr	r1, [pc, #92]	; (d18 <Vector<float>::print()+0x64>)
		Serial.printf("%i, ", buffer[i]);
	}
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
     cba:	b570      	push	{r4, r5, r6, lr}
     cbc:	4605      	mov	r5, r0
	if (length == 0) {
		Serial.printf("Vectorf [%i]\n", length);
		return;
	}
	Serial.printf("Vectorf [%i]: [", length);
     cbe:	4817      	ldr	r0, [pc, #92]	; (d1c <Vector<float>::print()+0x68>)
     cc0:	f001 fe70 	bl	29a4 <Print::printf(char const*, ...)>
	for (int i = 0; i < length-1; i++) {
     cc4:	682b      	ldr	r3, [r5, #0]
     cc6:	2b01      	cmp	r3, #1
     cc8:	dd12      	ble.n	cf0 <Vector<float>::print()+0x3c>
     cca:	2400      	movs	r4, #0
		Serial.printf("%f, ", buffer[i]);
     ccc:	686b      	ldr	r3, [r5, #4]
     cce:	4914      	ldr	r1, [pc, #80]	; (d20 <Vector<float>::print()+0x6c>)
     cd0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
     cd4:	4811      	ldr	r0, [pc, #68]	; (d1c <Vector<float>::print()+0x68>)
	if (length == 0) {
		Serial.printf("Vectorf [%i]\n", length);
		return;
	}
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
     cd6:	3401      	adds	r4, #1
		Serial.printf("%f, ", buffer[i]);
     cd8:	edd3 7a00 	vldr	s15, [r3]
     cdc:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
     ce0:	ec53 2b17 	vmov	r2, r3, d7
     ce4:	f001 fe5e 	bl	29a4 <Print::printf(char const*, ...)>
	if (length == 0) {
		Serial.printf("Vectorf [%i]\n", length);
		return;
	}
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
     ce8:	682b      	ldr	r3, [r5, #0]
     cea:	1e5a      	subs	r2, r3, #1
     cec:	42a2      	cmp	r2, r4
     cee:	dced      	bgt.n	ccc <Vector<float>::print()+0x18>
		Serial.printf("%f, ", buffer[i]);
	}
	Serial.printf("%f]\n", buffer[length-1]);
     cf0:	686a      	ldr	r2, [r5, #4]
     cf2:	490c      	ldr	r1, [pc, #48]	; (d24 <Vector<float>::print()+0x70>)
     cf4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
     cf8:	4808      	ldr	r0, [pc, #32]	; (d1c <Vector<float>::print()+0x68>)
     cfa:	ed53 7a01 	vldr	s15, [r3, #-4]
     cfe:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
}
     d02:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	}
	Serial.printf("Vectorf [%i]: [", length);
	for (int i = 0; i < length-1; i++) {
		Serial.printf("%f, ", buffer[i]);
	}
	Serial.printf("%f]\n", buffer[length-1]);
     d06:	ec53 2b17 	vmov	r2, r3, d7
     d0a:	f001 be4b 	b.w	29a4 <Print::printf(char const*, ...)>
	Serial.printf("%i]\n", buffer[length-1]);
}

template <> void Vector<float>::print() {
	if (length == 0) {
		Serial.printf("Vectorf [%i]\n", length);
     d0e:	4906      	ldr	r1, [pc, #24]	; (d28 <Vector<float>::print()+0x74>)
     d10:	4802      	ldr	r0, [pc, #8]	; (d1c <Vector<float>::print()+0x68>)
     d12:	f001 be47 	b.w	29a4 <Print::printf(char const*, ...)>
     d16:	bf00      	nop
     d18:	20000db8 	.word	0x20000db8
     d1c:	2000147c 	.word	0x2000147c
     d20:	20000dc8 	.word	0x20000dc8
     d24:	20000cf8 	.word	0x20000cf8
     d28:	20000da8 	.word	0x20000da8

00000d2c <Vector<int>::Vector()>:
#include "utilities/vector.h"
#include "syncor/process.h"
#include "syncor/syncor_node.h"

template <typename T> Vector<T>::Vector() {
	length = 0;
     d2c:	2200      	movs	r2, #0
     d2e:	6002      	str	r2, [r0, #0]
	buffer = NULL;
     d30:	6042      	str	r2, [r0, #4]
}
     d32:	4770      	bx	lr

00000d34 <Vector<int>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
     d34:	6802      	ldr	r2, [r0, #0]
     d36:	2100      	movs	r1, #0
     d38:	6840      	ldr	r0, [r0, #4]
     d3a:	0092      	lsls	r2, r2, #2
     d3c:	f005 bd6a 	b.w	6814 <memset>

00000d40 <Vector<int>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
     d40:	b538      	push	{r3, r4, r5, lr}
     d42:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
     d44:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
     d46:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
     d48:	b110      	cbz	r0, d50 <Vector<int>::reset(int)+0x10>
		delete buffer;
     d4a:	2104      	movs	r1, #4
     d4c:	f001 feba 	bl	2ac4 <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
     d50:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
     d54:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
     d56:	bf94      	ite	ls
     d58:	00a0      	lslls	r0, r4, #2
     d5a:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
     d5e:	f001 feaf 	bl	2ac0 <operator new[](unsigned int)>
     d62:	6068      	str	r0, [r5, #4]
	clear();
     d64:	4628      	mov	r0, r5
     d66:	f7ff ffe5 	bl	d34 <Vector<int>::clear()>
     d6a:	bd38      	pop	{r3, r4, r5, pc}

00000d6c <Vector<int>::from_array(int*, int)>:
}

template <typename T> void Vector<T>::from_array(T* data, int size) {
     d6c:	b570      	push	{r4, r5, r6, lr}
     d6e:	4614      	mov	r4, r2
     d70:	460e      	mov	r6, r1
     d72:	4605      	mov	r5, r0
		  reset the buffer to size n with data T*.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
     d74:	4611      	mov	r1, r2
     d76:	f7ff ffe3 	bl	d40 <Vector<int>::reset(int)>
	memcpy(buffer, data, size * sizeof(T));
     d7a:	4631      	mov	r1, r6
     d7c:	00a2      	lsls	r2, r4, #2
     d7e:	6868      	ldr	r0, [r5, #4]
}
     d80:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
	memcpy(buffer, data, size * sizeof(T));
     d84:	f005 bc48 	b.w	6618 <memcpy>

00000d88 <Vector<int>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
     d88:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
     d8a:	6803      	ldr	r3, [r0, #0]
     d8c:	428b      	cmp	r3, r1
     d8e:	dd05      	ble.n	d9c <Vector<int>::operator[](int)+0x14>
     d90:	2900      	cmp	r1, #0
     d92:	db03      	blt.n	d9c <Vector<int>::operator[](int)+0x14>
		return buffer[index];
     d94:	6840      	ldr	r0, [r0, #4]
     d96:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
     d9a:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
     d9c:	2000      	movs	r0, #0
     d9e:	f005 f925 	bl	5fec <exit>
     da2:	bf00      	nop

00000da4 <Vector<float>::Vector()>:
#include "utilities/vector.h"
#include "syncor/process.h"
#include "syncor/syncor_node.h"

template <typename T> Vector<T>::Vector() {
	length = 0;
     da4:	2200      	movs	r2, #0
     da6:	6002      	str	r2, [r0, #0]
	buffer = NULL;
     da8:	6042      	str	r2, [r0, #4]
}
     daa:	4770      	bx	lr

00000dac <Vector<float>::~Vector()>:

template <typename T> Vector<T>::~Vector() {
     dac:	b510      	push	{r4, lr}
     dae:	4604      	mov	r4, r0
	delete buffer;
     db0:	2104      	movs	r1, #4
     db2:	6840      	ldr	r0, [r0, #4]
     db4:	f001 fe86 	bl	2ac4 <operator delete(void*, unsigned int)>
}
     db8:	4620      	mov	r0, r4
     dba:	bd10      	pop	{r4, pc}

00000dbc <Vector<float>::clear()>:

template <typename T> void Vector<T>::clear() {
	/*
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
     dbc:	6802      	ldr	r2, [r0, #0]
     dbe:	2100      	movs	r1, #0
     dc0:	6840      	ldr	r0, [r0, #4]
     dc2:	0092      	lsls	r2, r2, #2
     dc4:	f005 bd26 	b.w	6814 <memset>

00000dc8 <Vector<float>::Vector(int)>:
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
	buffer = new T[size];
     dc8:	f1b1 5ffe 	cmp.w	r1, #532676608	; 0x1fc00000

template <typename T> Vector<T>::~Vector() {
	delete buffer;
}

template <typename T> Vector<T>::Vector(int size) {
     dcc:	b510      	push	{r4, lr}
     dce:	4604      	mov	r4, r0
	/*
		  Constructor for Vector with length = size.
		@param:
			size: (int) length of the buffer with type T
	*/
	length = size;
     dd0:	6001      	str	r1, [r0, #0]
	buffer = new T[size];
     dd2:	bf94      	ite	ls
     dd4:	0088      	lslls	r0, r1, #2
     dd6:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
     dda:	f001 fe71 	bl	2ac0 <operator new[](unsigned int)>
     dde:	6060      	str	r0, [r4, #4]
	clear();
     de0:	4620      	mov	r0, r4
     de2:	f7ff ffeb 	bl	dbc <Vector<float>::clear()>
}
     de6:	4620      	mov	r0, r4
     de8:	bd10      	pop	{r4, pc}
     dea:	bf00      	nop

00000dec <Vector<float>::reset(int)>:
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
     dec:	b538      	push	{r3, r4, r5, lr}
     dee:	4605      	mov	r5, r0
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
     df0:	6840      	ldr	r0, [r0, #4]
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
	from_array(tmp, length+1);
}

template <typename T> void Vector<T>::reset(int size) {
     df2:	460c      	mov	r4, r1
		  Resize buffer and set data to zero.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
     df4:	b110      	cbz	r0, dfc <Vector<float>::reset(int)+0x10>
		delete buffer;
     df6:	2104      	movs	r1, #4
     df8:	f001 fe64 	bl	2ac4 <operator delete(void*, unsigned int)>
	}
	length = size;
	buffer = new T[size];
     dfc:	f1b4 5ffe 	cmp.w	r4, #532676608	; 0x1fc00000
			size: (int) length of the buffer with type T
	*/
	if (buffer != NULL) {
		delete buffer;
	}
	length = size;
     e00:	602c      	str	r4, [r5, #0]
	buffer = new T[size];
     e02:	bf94      	ite	ls
     e04:	00a0      	lslls	r0, r4, #2
     e06:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
     e0a:	f001 fe59 	bl	2ac0 <operator new[](unsigned int)>
     e0e:	6068      	str	r0, [r5, #4]
	clear();
     e10:	4628      	mov	r0, r5
     e12:	f7ff ffd3 	bl	dbc <Vector<float>::clear()>
     e16:	bd38      	pop	{r3, r4, r5, pc}

00000e18 <Vector<float>::from_array(float*, int)>:
}

template <typename T> void Vector<T>::from_array(T* data, int size) {
     e18:	b570      	push	{r4, r5, r6, lr}
     e1a:	4614      	mov	r4, r2
     e1c:	460e      	mov	r6, r1
     e1e:	4605      	mov	r5, r0
		  reset the buffer to size n with data T*.
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
     e20:	4611      	mov	r1, r2
     e22:	f7ff ffe3 	bl	dec <Vector<float>::reset(int)>
	memcpy(buffer, data, size * sizeof(T));
     e26:	4631      	mov	r1, r6
     e28:	00a2      	lsls	r2, r4, #2
     e2a:	6868      	ldr	r0, [r5, #4]
}
     e2c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		@param:
			data: (T*) data to fill buffer with
			size: (int) length of the buffer with type T
	*/
	reset(size);
	memcpy(buffer, data, size * sizeof(T));
     e30:	f005 bbf2 	b.w	6618 <memcpy>

00000e34 <Vector<float>::push(float)>:
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
     e34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
     e36:	6806      	ldr	r6, [r0, #0]
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
     e38:	4604      	mov	r4, r0
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
     e3a:	6841      	ldr	r1, [r0, #4]
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
     e3c:	1c75      	adds	r5, r6, #1
     e3e:	00aa      	lsls	r2, r5, #2
     e40:	f102 000a 	add.w	r0, r2, #10
	memcpy(tmp, buffer, length * sizeof(T));
     e44:	3a04      	subs	r2, #4
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
     e46:	f020 0007 	bic.w	r0, r0, #7
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
     e4a:	ed2d 8b02 	vpush	{d8}
     e4e:	af00      	add	r7, sp, #0
		  Add a single item T to the buffer.
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
     e50:	ebad 0d00 	sub.w	sp, sp, r0
		  Clear data in the buffer (set to 0).
	*/
	memset(buffer, 0, length * sizeof(T));
}

template <typename T> void Vector<T>::push(T item) {
     e54:	eeb0 8a40 	vmov.f32	s16, s0
		Basically and append wraper. (maybe rename this)
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
     e58:	4668      	mov	r0, sp
     e5a:	f005 fbdd 	bl	6618 <memcpy>
	tmp[length] = item;
	from_array(tmp, length+1);
     e5e:	462a      	mov	r2, r5
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
     e60:	eb00 0386 	add.w	r3, r0, r6, lsl #2
	from_array(tmp, length+1);
     e64:	4601      	mov	r1, r0
     e66:	4620      	mov	r0, r4
		@param:
			item: (T) data to add to buffer
	*/
	T tmp[length + 1];
	memcpy(tmp, buffer, length * sizeof(T));
	tmp[length] = item;
     e68:	ed83 8a00 	vstr	s16, [r3]
	from_array(tmp, length+1);
     e6c:	f7ff ffd4 	bl	e18 <Vector<float>::from_array(float*, int)>
}
     e70:	46bd      	mov	sp, r7
     e72:	ecbd 8b02 	vpop	{d8}
     e76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00000e78 <Vector<float>::size()>:
		  Get the size of buffer (not necessarily elements available)
		@return
			length: (int) size of buffer
	*/
	return length;
}
     e78:	6800      	ldr	r0, [r0, #0]
     e7a:	4770      	bx	lr

00000e7c <Vector<float>::as_array()>:
	return -1;
}

template <typename T> T* Vector<T>::as_array() {
	return buffer;
}
     e7c:	6840      	ldr	r0, [r0, #4]
     e7e:	4770      	bx	lr

00000e80 <Vector<float>::append(Vector<float>*)>:
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
     e80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		  Add n values to the buffer. Stores the current buffer and
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
     e84:	f8d0 8000 	ldr.w	r8, [r0]
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
     e88:	af00      	add	r7, sp, #0
     e8a:	4604      	mov	r4, r0
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();
     e8c:	4608      	mov	r0, r1

	T tmp1[n];
     e8e:	ea4f 0588 	mov.w	r5, r8, lsl #2
	}
	// memcpy(buffer, tmp1, n * sizeof(T));
	// memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::append(Vector<T>* data) {
     e92:	4689      	mov	r9, r1
		data to add a temp. Calls reset and then copies buffer into resized buffer.
		@param:
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();
     e94:	f7ff fff0 	bl	e78 <Vector<float>::size()>
     e98:	4606      	mov	r6, r0

	T tmp1[n];
     e9a:	f105 030a 	add.w	r3, r5, #10
	T* tmp2 = data->as_array();
     e9e:	4648      	mov	r0, r9
			data: (Vector<T>*) data to fill buffer with
	*/
	int n = length;
	int m = data->size();

	T tmp1[n];
     ea0:	f023 0307 	bic.w	r3, r3, #7
     ea4:	ebad 0d03 	sub.w	sp, sp, r3
	T* tmp2 = data->as_array();
     ea8:	f7ff ffe8 	bl	e7c <Vector<float>::as_array()>

	reset(n + m);
     eac:	eb08 0106 	add.w	r1, r8, r6
	*/
	int n = length;
	int m = data->size();

	T tmp1[n];
	T* tmp2 = data->as_array();
     eb0:	4681      	mov	r9, r0

	reset(n + m);
     eb2:	4620      	mov	r0, r4
     eb4:	f7ff ff9a 	bl	dec <Vector<float>::reset(int)>
	memcpy(buffer, tmp1, n * sizeof(T));
     eb8:	462a      	mov	r2, r5
     eba:	4669      	mov	r1, sp
     ebc:	6860      	ldr	r0, [r4, #4]
     ebe:	f005 fbab 	bl	6618 <memcpy>
	memcpy(&buffer[n], tmp2, m * sizeof(T));
     ec2:	6860      	ldr	r0, [r4, #4]
     ec4:	00b2      	lsls	r2, r6, #2
     ec6:	4649      	mov	r1, r9
     ec8:	4428      	add	r0, r5
     eca:	f005 fba5 	bl	6618 <memcpy>
}
     ece:	46bd      	mov	sp, r7
     ed0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00000ed4 <Vector<float>::insert(float*, int, int)>:

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
     ed4:	b5f0      	push	{r4, r5, r6, r7, lr}
     ed6:	461d      	mov	r5, r3
     ed8:	460c      	mov	r4, r1
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
     eda:	6803      	ldr	r3, [r0, #0]
	reset(n + m);
	memcpy(buffer, tmp1, n * sizeof(T));
	memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
     edc:	b083      	sub	sp, #12
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
     ede:	1951      	adds	r1, r2, r5
	reset(n + m);
	memcpy(buffer, tmp1, n * sizeof(T));
	memcpy(&buffer[n], tmp2, m * sizeof(T));
}

template <typename T> void Vector<T>::insert(T* data, int index, int size) {
     ee0:	4606      	mov	r6, r0
     ee2:	4617      	mov	r7, r2
		@param:
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
     ee4:	4299      	cmp	r1, r3
     ee6:	dc0f      	bgt.n	f08 <Vector<float>::insert(float*, int, int)+0x34>
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
     ee8:	2d00      	cmp	r5, #0
     eea:	dd0b      	ble.n	f04 <Vector<float>::insert(float*, int, int)+0x30>
     eec:	6870      	ldr	r0, [r6, #4]
     eee:	4621      	mov	r1, r4
     ef0:	eb04 0385 	add.w	r3, r4, r5, lsl #2
     ef4:	eb00 0287 	add.w	r2, r0, r7, lsl #2
		buffer[i + index] = data[i];
     ef8:	f851 0b04 	ldr.w	r0, [r1], #4
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
     efc:	428b      	cmp	r3, r1
		buffer[i + index] = data[i];
     efe:	f842 0b04 	str.w	r0, [r2], #4
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
		append(&empty);
	}
	for (int i = 0; i < size; i++) {
     f02:	d1f9      	bne.n	ef8 <Vector<float>::insert(float*, int, int)+0x24>
		buffer[i + index] = data[i];
	}
}
     f04:	b003      	add	sp, #12
     f06:	bdf0      	pop	{r4, r5, r6, r7, pc}
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
     f08:	1ac9      	subs	r1, r1, r3
     f0a:	4668      	mov	r0, sp
     f0c:	f7ff ff5c 	bl	dc8 <Vector<float>::Vector(int)>
		append(&empty);
     f10:	4630      	mov	r0, r6
     f12:	4669      	mov	r1, sp
     f14:	f7ff ffb4 	bl	e80 <Vector<float>::append(Vector<float>*)>
			data: (T*) data to fill buffer with
			index: (int) index to start insertion
			size: (int) number of items to insert
	*/
	if (index + size > length) {
		Vector<T> empty((index + size) - length);
     f18:	4668      	mov	r0, sp
     f1a:	f7ff ff47 	bl	dac <Vector<float>::~Vector()>
     f1e:	e7e3      	b.n	ee8 <Vector<float>::insert(float*, int, int)+0x14>

00000f20 <Vector<float>::slice(float*, int, int)>:

template <typename T> T* Vector<T>::as_array() {
	return buffer;
}

template <typename T> void Vector<T>::slice(T* data, int start, int n) {
     f20:	b430      	push	{r4, r5}
		@return
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
     f22:	1e14      	subs	r4, r2, #0
     f24:	db03      	blt.n	f2e <Vector<float>::slice(float*, int, int)+0xe>
     f26:	18e2      	adds	r2, r4, r3
     f28:	6805      	ldr	r5, [r0, #0]
     f2a:	42aa      	cmp	r2, r5
     f2c:	dd05      	ble.n	f3a <Vector<float>::slice(float*, int, int)+0x1a>
		memcpy(data, &buffer[start], n * sizeof(T));
	}
	else {
		memset(data, 0, n * sizeof(T));
     f2e:	4608      	mov	r0, r1
     f30:	009a      	lsls	r2, r3, #2
     f32:	2100      	movs	r1, #0
	}
}
     f34:	bc30      	pop	{r4, r5}
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
	}
	else {
		memset(data, 0, n * sizeof(T));
     f36:	f005 bc6d 	b.w	6814 <memset>
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
     f3a:	6845      	ldr	r5, [r0, #4]
     f3c:	009a      	lsls	r2, r3, #2
     f3e:	4608      	mov	r0, r1
     f40:	eb05 0184 	add.w	r1, r5, r4, lsl #2
	}
	else {
		memset(data, 0, n * sizeof(T));
	}
}
     f44:	bc30      	pop	{r4, r5}
			data: (T*) buffer to put slice
			start: (int) start index of buffer
			n: (int) number of items in slice
	*/
	if (start >= 0 && start + n <= length) {
		memcpy(data, &buffer[start], n * sizeof(T));
     f46:	f005 bb67 	b.w	6618 <memcpy>
     f4a:	bf00      	nop

00000f4c <Vector<float>::operator[](int)>:
	}
}

///// operators /////

template <typename T> T& Vector<T>::operator[](int index) {
     f4c:	b508      	push	{r3, lr}
		@return
			item: (T&) item at index
		@exit
			when index is invalid 
	*/
	if (length > index && index >= 0) {
     f4e:	6803      	ldr	r3, [r0, #0]
     f50:	428b      	cmp	r3, r1
     f52:	dd05      	ble.n	f60 <Vector<float>::operator[](int)+0x14>
     f54:	2900      	cmp	r1, #0
     f56:	db03      	blt.n	f60 <Vector<float>::operator[](int)+0x14>
		return buffer[index];
     f58:	6840      	ldr	r0, [r0, #4]
     f5a:	eb00 0081 	add.w	r0, r0, r1, lsl #2
	}
	exit(0);
}
     f5e:	bd08      	pop	{r3, pc}
			when index is invalid 
	*/
	if (length > index && index >= 0) {
		return buffer[index];
	}
	exit(0);
     f60:	2000      	movs	r0, #0
     f62:	f005 f843 	bl	5fec <exit>
     f66:	bf00      	nop

00000f68 <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
     f68:	4a96      	ldr	r2, [pc, #600]	; (11c4 <set_arm_clock+0x25c>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
     f6a:	4b97      	ldr	r3, [pc, #604]	; (11c8 <set_arm_clock+0x260>)
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
     f6c:	4290      	cmp	r0, r2
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
     f6e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;
     f72:	4c96      	ldr	r4, [pc, #600]	; (11cc <set_arm_clock+0x264>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
     f74:	f8d3 e014 	ldr.w	lr, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
     f78:	6999      	ldr	r1, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
     f7a:	68e6      	ldr	r6, [r4, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
     f7c:	d91c      	bls.n	fb8 <set_arm_clock+0x50>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
     f7e:	4b94      	ldr	r3, [pc, #592]	; (11d0 <set_arm_clock+0x268>)
     f80:	4298      	cmp	r0, r3
     f82:	f240 8115 	bls.w	11b0 <set_arm_clock+0x248>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
     f86:	4b93      	ldr	r3, [pc, #588]	; (11d4 <set_arm_clock+0x26c>)
     f88:	f240 6527 	movw	r5, #1575	; 0x627
     f8c:	4f92      	ldr	r7, [pc, #584]	; (11d8 <set_arm_clock+0x270>)
     f8e:	4403      	add	r3, r0
     f90:	4c92      	ldr	r4, [pc, #584]	; (11dc <set_arm_clock+0x274>)
     f92:	0a1a      	lsrs	r2, r3, #8
     f94:	fba7 3202 	umull	r3, r2, r7, r2
     f98:	09d3      	lsrs	r3, r2, #7
     f9a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
     f9e:	eb03 0283 	add.w	r2, r3, r3, lsl #2
     fa2:	f202 43e2 	addw	r3, r2, #1250	; 0x4e2
     fa6:	42ab      	cmp	r3, r5
     fa8:	bf28      	it	cs
     faa:	462b      	movcs	r3, r5
     fac:	f5a3 7348 	sub.w	r3, r3, #800	; 0x320
     fb0:	fba4 3503 	umull	r3, r5, r4, r3
     fb4:	08ed      	lsrs	r5, r5, #3
     fb6:	e004      	b.n	fc2 <set_arm_clock+0x5a>
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
		}
#endif
	} else if (frequency <= 24000000) {
     fb8:	4d89      	ldr	r5, [pc, #548]	; (11e0 <set_arm_clock+0x278>)
     fba:	42a8      	cmp	r0, r5
     fbc:	bf94      	ite	ls
     fbe:	2506      	movls	r5, #6
     fc0:	250e      	movhi	r5, #14
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
     fc2:	4a81      	ldr	r2, [pc, #516]	; (11c8 <set_arm_clock+0x260>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
     fc4:	f006 071f 	and.w	r7, r6, #31
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
     fc8:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
     fcc:	42af      	cmp	r7, r5
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
     fce:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
     fd2:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
     fd6:	d20a      	bcs.n	fee <set_arm_clock+0x86>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
     fd8:	4b7c      	ldr	r3, [pc, #496]	; (11cc <set_arm_clock+0x264>)

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
     fda:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
     fde:	461a      	mov	r2, r3
	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
     fe0:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
     fe2:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
     fe4:	6813      	ldr	r3, [r2, #0]
     fe6:	2b00      	cmp	r3, #0
     fe8:	dafc      	bge.n	fe4 <set_arm_clock+0x7c>
     fea:	f006 071f 	and.w	r7, r6, #31
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
     fee:	f01e 7300 	ands.w	r3, lr, #33554432	; 0x2000000
     ff2:	d131      	bne.n	1058 <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
     ff4:	4c7b      	ldr	r4, [pc, #492]	; (11e4 <set_arm_clock+0x27c>)
     ff6:	4a7c      	ldr	r2, [pc, #496]	; (11e8 <set_arm_clock+0x280>)
     ff8:	f8d4 c010 	ldr.w	ip, [r4, #16]
     ffc:	4614      	mov	r4, r2
     ffe:	ea0c 0202 	and.w	r2, ip, r2
    1002:	42a2      	cmp	r2, r4
    1004:	bf0a      	itet	eq
    1006:	f04f 53c0 	moveq.w	r3, #402653184	; 0x18000000
    100a:	f44f 5280 	movne.w	r2, #4096	; 0x1000
    100e:	2200      	moveq	r2, #0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    1010:	ea8e 0403 	eor.w	r4, lr, r3
    1014:	f014 5f60 	tst.w	r4, #939524096	; 0x38000000
    1018:	d008      	beq.n	102c <set_arm_clock+0xc4>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    101a:	f02e 5e60 	bic.w	lr, lr, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    101e:	f003 5360 	and.w	r3, r3, #939524096	; 0x38000000
			CCM_CBCDR = cbcdr;
    1022:	4c69      	ldr	r4, [pc, #420]	; (11c8 <set_arm_clock+0x260>)
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    1024:	ea43 0e0e 	orr.w	lr, r3, lr
			CCM_CBCDR = cbcdr;
    1028:	f8c4 e014 	str.w	lr, [r4, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    102c:	ea81 0302 	eor.w	r3, r1, r2
    1030:	f413 5f40 	tst.w	r3, #12288	; 0x3000
    1034:	d008      	beq.n	1048 <set_arm_clock+0xe0>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    1036:	4b64      	ldr	r3, [pc, #400]	; (11c8 <set_arm_clock+0x260>)
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
			CCM_CBCDR = cbcdr;
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    1038:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    103c:	4311      	orrs	r1, r2
			CCM_CBCMR = cbcmr;
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    103e:	461a      	mov	r2, r3
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    1040:	6199      	str	r1, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    1042:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1044:	071c      	lsls	r4, r3, #28
    1046:	d4fc      	bmi.n	1042 <set_arm_clock+0xda>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    1048:	f04e 7e00 	orr.w	lr, lr, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    104c:	4a5e      	ldr	r2, [pc, #376]	; (11c8 <set_arm_clock+0x260>)
    104e:	f8c2 e014 	str.w	lr, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    1052:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1054:	0699      	lsls	r1, r3, #26
    1056:	d4fc      	bmi.n	1052 <set_arm_clock+0xea>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
    1058:	2101      	movs	r1, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    105a:	4c64      	ldr	r4, [pc, #400]	; (11ec <set_arm_clock+0x284>)
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
    105c:	460a      	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    105e:	fb01 f302 	mul.w	r3, r1, r2
    1062:	fb00 f303 	mul.w	r3, r0, r3
    1066:	42a3      	cmp	r3, r4
    1068:	d809      	bhi.n	107e <set_arm_clock+0x116>
		if (div_arm < 8) {
    106a:	2a07      	cmp	r2, #7
    106c:	f200 8095 	bhi.w	119a <set_arm_clock+0x232>
			div_arm = div_arm + 1;
    1070:	3201      	adds	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    1072:	fb01 f302 	mul.w	r3, r1, r2
    1076:	fb00 f303 	mul.w	r3, r0, r3
    107a:	42a3      	cmp	r3, r4
    107c:	d9f5      	bls.n	106a <set_arm_clock+0x102>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    107e:	485c      	ldr	r0, [pc, #368]	; (11f0 <set_arm_clock+0x288>)
    1080:	4c5c      	ldr	r4, [pc, #368]	; (11f4 <set_arm_clock+0x28c>)
    1082:	4418      	add	r0, r3
    1084:	fba4 0300 	umull	r0, r3, r4, r0
    1088:	0d1b      	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
    108a:	2b6c      	cmp	r3, #108	; 0x6c
    108c:	f200 808b 	bhi.w	11a6 <set_arm_clock+0x23e>
	if (mult < 54) mult = 54;
    1090:	2b35      	cmp	r3, #53	; 0x35
    1092:	f200 808f 	bhi.w	11b4 <set_arm_clock+0x24c>
    1096:	f8df 8188 	ldr.w	r8, [pc, #392]	; 1220 <set_arm_clock+0x2b8>
    109a:	2336      	movs	r3, #54	; 0x36
    109c:	4856      	ldr	r0, [pc, #344]	; (11f8 <set_arm_clock+0x290>)

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    109e:	f8df c144 	ldr.w	ip, [pc, #324]	; 11e4 <set_arm_clock+0x27c>
    10a2:	4c56      	ldr	r4, [pc, #344]	; (11fc <set_arm_clock+0x294>)
    10a4:	f8dc 9000 	ldr.w	r9, [ip]
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    10a8:	fbb0 f0f2 	udiv	r0, r0, r2

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    10ac:	ea09 0404 	and.w	r4, r9, r4
    10b0:	4544      	cmp	r4, r8
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    10b2:	fbb0 f0f1 	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    10b6:	d00b      	beq.n	10d0 <set_arm_clock+0x168>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    10b8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    10bc:	f44f 5880 	mov.w	r8, #4096	; 0x1000
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    10c0:	4664      	mov	r4, ip
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    10c2:	f8cc 8000 	str.w	r8, [ip]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    10c6:	f8cc 3000 	str.w	r3, [ip]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    10ca:	6823      	ldr	r3, [r4, #0]
    10cc:	2b00      	cmp	r3, #0
    10ce:	dafc      	bge.n	10ca <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    10d0:	f8df c0f4 	ldr.w	ip, [pc, #244]	; 11c8 <set_arm_clock+0x260>
    10d4:	3a01      	subs	r2, #1
    10d6:	f8dc 3010 	ldr.w	r3, [ip, #16]
    10da:	f003 0307 	and.w	r3, r3, #7
    10de:	4293      	cmp	r3, r2
    10e0:	d007      	beq.n	10f2 <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    10e2:	f002 0207 	and.w	r2, r2, #7
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    10e6:	4664      	mov	r4, ip
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    10e8:	f8cc 2010 	str.w	r2, [ip, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    10ec:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    10ee:	03db      	lsls	r3, r3, #15
    10f0:	d4fc      	bmi.n	10ec <set_arm_clock+0x184>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    10f2:	3901      	subs	r1, #1
    10f4:	0289      	lsls	r1, r1, #10
    10f6:	ea8e 0301 	eor.w	r3, lr, r1
    10fa:	f413 5fe0 	tst.w	r3, #7168	; 0x1c00
    10fe:	d00c      	beq.n	111a <set_arm_clock+0x1b2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
		CCM_CBCDR = cbcdr;
    1100:	4b31      	ldr	r3, [pc, #196]	; (11c8 <set_arm_clock+0x260>)
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    1102:	f42e 5ee0 	bic.w	lr, lr, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    1106:	f401 51e0 	and.w	r1, r1, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    110a:	461a      	mov	r2, r3
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    110c:	ea41 0e0e 	orr.w	lr, r1, lr
		CCM_CBCDR = cbcdr;
    1110:	f8c3 e014 	str.w	lr, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    1114:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1116:	0799      	lsls	r1, r3, #30
    1118:	d4fc      	bmi.n	1114 <set_arm_clock+0x1ac>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    111a:	4b39      	ldr	r3, [pc, #228]	; (1200 <set_arm_clock+0x298>)
    111c:	4939      	ldr	r1, [pc, #228]	; (1204 <set_arm_clock+0x29c>)
    111e:	4403      	add	r3, r0
    1120:	09db      	lsrs	r3, r3, #7
    1122:	fba1 3103 	umull	r3, r1, r1, r3
    1126:	0b09      	lsrs	r1, r1, #12
    1128:	2904      	cmp	r1, #4
    112a:	bf28      	it	cs
    112c:	2104      	movcs	r1, #4
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    112e:	1e4b      	subs	r3, r1, #1
    1130:	021b      	lsls	r3, r3, #8
    1132:	ea8e 0203 	eor.w	r2, lr, r3
    1136:	f412 7f40 	tst.w	r2, #768	; 0x300
    113a:	d007      	beq.n	114c <set_arm_clock+0x1e4>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    113c:	f42e 7e40 	bic.w	lr, lr, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    1140:	f403 7340 	and.w	r3, r3, #768	; 0x300
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    1144:	4a20      	ldr	r2, [pc, #128]	; (11c8 <set_arm_clock+0x260>)

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    1146:	ea43 030e 	orr.w	r3, r3, lr
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    114a:	6153      	str	r3, [r2, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    114c:	4b1e      	ldr	r3, [pc, #120]	; (11c8 <set_arm_clock+0x260>)
    114e:	695c      	ldr	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    1150:	461a      	mov	r2, r3
		CCM_CBCDR = cbcdr;
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    1152:	f024 7400 	bic.w	r4, r4, #33554432	; 0x2000000
    1156:	615c      	str	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    1158:	6c93      	ldr	r3, [r2, #72]	; 0x48
    115a:	069b      	lsls	r3, r3, #26
    115c:	d4fc      	bmi.n	1158 <set_arm_clock+0x1f0>

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    115e:	4b2a      	ldr	r3, [pc, #168]	; (1208 <set_arm_clock+0x2a0>)
    1160:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    1164:	4c29      	ldr	r4, [pc, #164]	; (120c <set_arm_clock+0x2a4>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    1166:	42bd      	cmp	r5, r7
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    1168:	fba3 e300 	umull	lr, r3, r3, r0
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    116c:	6020      	str	r0, [r4, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    116e:	ea4f 4393 	mov.w	r3, r3, lsr #18
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    1172:	4c27      	ldr	r4, [pc, #156]	; (1210 <set_arm_clock+0x2a8>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    1174:	fbb2 f3f3 	udiv	r3, r2, r3
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    1178:	fbb0 f1f1 	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    117c:	4a25      	ldr	r2, [pc, #148]	; (1214 <set_arm_clock+0x2ac>)
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    117e:	6021      	str	r1, [r4, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    1180:	6013      	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    1182:	d208      	bcs.n	1196 <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    1184:	4b11      	ldr	r3, [pc, #68]	; (11cc <set_arm_clock+0x264>)
	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    1186:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    118a:	461a      	mov	r2, r3

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    118c:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
    118e:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    1190:	6813      	ldr	r3, [r2, #0]
    1192:	2b00      	cmp	r3, #0
    1194:	dafc      	bge.n	1190 <set_arm_clock+0x228>
	}

	return frequency;
}
    1196:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
		if (div_arm < 8) {
			div_arm = div_arm + 1;
		} else {
			if (div_ahb < 5) {
    119a:	2904      	cmp	r1, #4
    119c:	f63f af6f 	bhi.w	107e <set_arm_clock+0x116>
				div_ahb = div_ahb + 1;
    11a0:	3101      	adds	r1, #1
				div_arm = 1;
    11a2:	2201      	movs	r2, #1
    11a4:	e75b      	b.n	105e <set_arm_clock+0xf6>
    11a6:	f8df 807c 	ldr.w	r8, [pc, #124]	; 1224 <set_arm_clock+0x2bc>
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
    11aa:	236c      	movs	r3, #108	; 0x6c
    11ac:	481a      	ldr	r0, [pc, #104]	; (1218 <set_arm_clock+0x2b0>)
    11ae:	e776      	b.n	109e <set_arm_clock+0x136>
    11b0:	2512      	movs	r5, #18
    11b2:	e706      	b.n	fc2 <set_arm_clock+0x5a>
    11b4:	4819      	ldr	r0, [pc, #100]	; (121c <set_arm_clock+0x2b4>)
    11b6:	f8df 8070 	ldr.w	r8, [pc, #112]	; 1228 <set_arm_clock+0x2c0>
    11ba:	fb00 f003 	mul.w	r0, r0, r3
    11be:	ea43 0808 	orr.w	r8, r3, r8
    11c2:	e76c      	b.n	109e <set_arm_clock+0x136>
    11c4:	1f78a400 	.word	0x1f78a400
    11c8:	400fc000 	.word	0x400fc000
    11cc:	40080000 	.word	0x40080000
    11d0:	23c34600 	.word	0x23c34600
    11d4:	dc3cba00 	.word	0xdc3cba00
    11d8:	004cb223 	.word	0x004cb223
    11dc:	51eb851f 	.word	0x51eb851f
    11e0:	016e3600 	.word	0x016e3600
    11e4:	400d8000 	.word	0x400d8000
    11e8:	80003040 	.word	0x80003040
    11ec:	269fb1ff 	.word	0x269fb1ff
    11f0:	005b8d80 	.word	0x005b8d80
    11f4:	165e9f81 	.word	0x165e9f81
    11f8:	269fb200 	.word	0x269fb200
    11fc:	8001307f 	.word	0x8001307f
    1200:	08f0d17f 	.word	0x08f0d17f
    1204:	00e5109f 	.word	0x00e5109f
    1208:	431bde83 	.word	0x431bde83
    120c:	20001478 	.word	0x20001478
    1210:	20001474 	.word	0x20001474
    1214:	20002738 	.word	0x20002738
    1218:	4d3f6400 	.word	0x4d3f6400
    121c:	00b71b00 	.word	0x00b71b00
    1220:	80002036 	.word	0x80002036
    1224:	8000206c 	.word	0x8000206c
    1228:	80002000 	.word	0x80002000

0000122c <delay>:
// or delayNanoseconds().
void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
    122c:	2800      	cmp	r0, #0
    122e:	d057      	beq.n	12e0 <delay+0xb4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    1230:	2201      	movs	r2, #1
// active, but the rest of your program becomes effectively stalled.  Usually
// delay() is used in very simple programs.  To achieve delay without waiting
// use millis() or elapsedMillis.  For shorter delay, use delayMicroseconds()
// or delayNanoseconds().
void delay(uint32_t msec)
{
    1232:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1236:	b085      	sub	sp, #20
    1238:	4683      	mov	fp, r0
    123a:	4c2a      	ldr	r4, [pc, #168]	; (12e4 <delay+0xb8>)
    123c:	4d2a      	ldr	r5, [pc, #168]	; (12e8 <delay+0xbc>)
    123e:	4e2b      	ldr	r6, [pc, #172]	; (12ec <delay+0xc0>)
    1240:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    1244:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    1248:	6828      	ldr	r0, [r5, #0]
		scc = systick_cycle_count;
    124a:	6833      	ldr	r3, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    124c:	e844 2100 	strex	r1, r2, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    1250:	2900      	cmp	r1, #0
    1252:	d1f7      	bne.n	1244 <delay+0x18>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    1254:	4f26      	ldr	r7, [pc, #152]	; (12f0 <delay+0xc4>)
    1256:	e9cd 8902 	strd	r8, r9, [sp, #8]
    125a:	683a      	ldr	r2, [r7, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    125c:	1ad3      	subs	r3, r2, r3
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    125e:	4a25      	ldr	r2, [pc, #148]	; (12f4 <delay+0xc8>)
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    1260:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    1264:	9701      	str	r7, [sp, #4]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1266:	6812      	ldr	r2, [r2, #0]
    1268:	2701      	movs	r7, #1
    126a:	fba3 2302 	umull	r2, r3, r3, r2
	if (frac > 1000) frac = 1000;
    126e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1272:	4698      	mov	r8, r3
	if (frac > 1000) frac = 1000;
    1274:	2300      	movs	r3, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    1276:	428b      	cmp	r3, r1
    1278:	bf08      	it	eq
    127a:	4542      	cmpeq	r2, r8
    127c:	bf2c      	ite	cs
    127e:	46c2      	movcs	sl, r8
    1280:	46f2      	movcc	sl, lr
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    1282:	fb0e aa00 	mla	sl, lr, r0, sl
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    1286:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    128a:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    128c:	6831      	ldr	r1, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    128e:	e844 7300 	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    1292:	2b00      	cmp	r3, #0
    1294:	d1f7      	bne.n	1286 <delay+0x5a>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    1296:	9801      	ldr	r0, [sp, #4]
    1298:	6800      	ldr	r0, [r0, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    129a:	1a41      	subs	r1, r0, r1
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    129c:	4815      	ldr	r0, [pc, #84]	; (12f4 <delay+0xc8>)
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    129e:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    12a2:	6800      	ldr	r0, [r0, #0]
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    12a4:	fb0e f202 	mul.w	r2, lr, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    12a8:	fba1 0100 	umull	r0, r1, r1, r0
	if (frac > 1000) frac = 1000;
    12ac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    12b0:	ebca 0202 	rsb	r2, sl, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    12b4:	4688      	mov	r8, r1
	if (frac > 1000) frac = 1000;
    12b6:	2100      	movs	r1, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    12b8:	4299      	cmp	r1, r3
    12ba:	bf08      	it	eq
    12bc:	4540      	cmpeq	r0, r8
    12be:	bf2c      	ite	cs
    12c0:	4643      	movcs	r3, r8
    12c2:	4673      	movcc	r3, lr
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    12c4:	441a      	add	r2, r3
    12c6:	4572      	cmp	r2, lr
    12c8:	d307      	bcc.n	12da <delay+0xae>
			if (--msec == 0) return;
    12ca:	f1bb 0b01 	subs.w	fp, fp, #1
			start += 1000;
    12ce:	f50a 7a7a 	add.w	sl, sl, #1000	; 0x3e8

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
    12d2:	d1d8      	bne.n	1286 <delay+0x5a>
			start += 1000;
		}
		yield();
	}
	// TODO...
}
    12d4:	b005      	add	sp, #20
    12d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
    12da:	f001 fc09 	bl	2af0 <yield>
	}
    12de:	e7d2      	b.n	1286 <delay+0x5a>
    12e0:	4770      	bx	lr
    12e2:	bf00      	nop
    12e4:	200027a0 	.word	0x200027a0
    12e8:	20002740 	.word	0x20002740
    12ec:	2000273c 	.word	0x2000273c
    12f0:	e0001004 	.word	0xe0001004
    12f4:	20002738 	.word	0x20002738

000012f8 <digitalWrite.part.0>:
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    12f8:	0100      	lsls	r0, r0, #4
    12fa:	4b0f      	ldr	r3, [pc, #60]	; (1338 <digitalWrite.part.0+0x40>)
    12fc:	181a      	adds	r2, r3, r0
	pinmode = *(p->reg + 1);
    12fe:	581b      	ldr	r3, [r3, r0]
	{&CORE_PIN53_PORTREG, &CORE_PIN53_CONFIG, &CORE_PIN53_PADCONFIG, CORE_PIN53_BITMASK},
	{&CORE_PIN54_PORTREG, &CORE_PIN54_CONFIG, &CORE_PIN54_PADCONFIG, CORE_PIN54_BITMASK},
#endif
};

void digitalWrite(uint8_t pin, uint8_t val)
    1300:	b410      	push	{r4}
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
	mask = p->mask;
    1302:	68d0      	ldr	r0, [r2, #12]
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
    1304:	685c      	ldr	r4, [r3, #4]
	mask = p->mask;
	if (pinmode & mask) {
    1306:	4204      	tst	r4, r0
    1308:	d005      	beq.n	1316 <digitalWrite.part.0+0x1e>
		// pin is configured for output mode
		if (val) {
    130a:	b159      	cbz	r1, 1324 <digitalWrite.part.0+0x2c>
			*(p->reg + 0x21) = mask; // set register
    130c:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    1310:	f85d 4b04 	ldr.w	r4, [sp], #4
    1314:	4770      	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    1316:	6893      	ldr	r3, [r2, #8]
			*(p->reg + 0x22) = mask; // clear register
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
    1318:	b949      	cbnz	r1, 132e <digitalWrite.part.0+0x36>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    131a:	4a08      	ldr	r2, [pc, #32]	; (133c <digitalWrite.part.0+0x44>)
		}
	}
}
    131c:	f85d 4b04 	ldr.w	r4, [sp], #4
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    1320:	601a      	str	r2, [r3, #0]
		}
	}
}
    1322:	4770      	bx	lr
	if (pinmode & mask) {
		// pin is configured for output mode
		if (val) {
			*(p->reg + 0x21) = mask; // set register
		} else {
			*(p->reg + 0x22) = mask; // clear register
    1324:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    1328:	f85d 4b04 	ldr.w	r4, [sp], #4
    132c:	4770      	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    132e:	4a04      	ldr	r2, [pc, #16]	; (1340 <digitalWrite.part.0+0x48>)
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    1330:	f85d 4b04 	ldr.w	r4, [sp], #4
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    1334:	601a      	str	r2, [r3, #0]
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    1336:	4770      	bx	lr
    1338:	200006dc 	.word	0x200006dc
    133c:	00013038 	.word	0x00013038
    1340:	0001f038 	.word	0x0001f038

00001344 <digitalRead.part.1>:
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    1344:	0100      	lsls	r0, r0, #4
    1346:	4b05      	ldr	r3, [pc, #20]	; (135c <digitalRead.part.1+0x18>)
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    1348:	581a      	ldr	r2, [r3, r0]
uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
	p = digital_pin_to_info_PGM + pin;
    134a:	1819      	adds	r1, r3, r0
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
    134c:	6892      	ldr	r2, [r2, #8]
    134e:	68cb      	ldr	r3, [r1, #12]
    1350:	421a      	tst	r2, r3
}
    1352:	bf14      	ite	ne
    1354:	2001      	movne	r0, #1
    1356:	2000      	moveq	r0, #0
    1358:	4770      	bx	lr
    135a:	bf00      	nop
    135c:	200006dc 	.word	0x200006dc

00001360 <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    1360:	2836      	cmp	r0, #54	; 0x36
    1362:	d801      	bhi.n	1368 <digitalWrite+0x8>
    1364:	f7ff bfc8 	b.w	12f8 <digitalWrite.part.0>
    1368:	4770      	bx	lr
    136a:	bf00      	nop

0000136c <digitalRead>:

uint8_t digitalRead(uint8_t pin)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return 0;
    136c:	2836      	cmp	r0, #54	; 0x36
    136e:	d801      	bhi.n	1374 <digitalRead+0x8>
    1370:	f7ff bfe8 	b.w	1344 <digitalRead.part.1>
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}
    1374:	2000      	movs	r0, #0
    1376:	4770      	bx	lr

00001378 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    1378:	b4f0      	push	{r4, r5, r6, r7}
    137a:	1e4e      	subs	r6, r1, #1
	unsigned digit;
	int i=0, j;
    137c:	2500      	movs	r5, #0
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    137e:	4637      	mov	r7, r6
    1380:	e000      	b.n	1384 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    1382:	3501      	adds	r5, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    1384:	fbb0 f3f2 	udiv	r3, r0, r2
    1388:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    138c:	f100 0437 	add.w	r4, r0, #55	; 0x37
    1390:	2809      	cmp	r0, #9
    1392:	f100 0030 	add.w	r0, r0, #48	; 0x30
    1396:	b2e4      	uxtb	r4, r4
    1398:	bf98      	it	ls
    139a:	b2c4      	uxtbls	r4, r0
		val /= radix;
		if (val == 0) break;
    139c:	4618      	mov	r0, r3
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    139e:	f807 4f01 	strb.w	r4, [r7, #1]!
		val /= radix;
		if (val == 0) break;
    13a2:	2b00      	cmp	r3, #0
    13a4:	d1ed      	bne.n	1382 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    13a6:	194a      	adds	r2, r1, r5
    13a8:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    13aa:	b14d      	cbz	r5, 13c0 <ultoa+0x48>
    13ac:	3301      	adds	r3, #1
		t = buf[j];
    13ae:	f816 4f01 	ldrb.w	r4, [r6, #1]!
		buf[j] = buf[i];
    13b2:	7817      	ldrb	r7, [r2, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    13b4:	1ae8      	subs	r0, r5, r3
		t = buf[j];
		buf[j] = buf[i];
    13b6:	7037      	strb	r7, [r6, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    13b8:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    13ba:	f802 4901 	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    13be:	dbf5      	blt.n	13ac <ultoa+0x34>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    13c0:	4608      	mov	r0, r1
    13c2:	bcf0      	pop	{r4, r5, r6, r7}
    13c4:	4770      	bx	lr
    13c6:	bf00      	nop

000013c8 <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    13c8:	48a4      	ldr	r0, [pc, #656]	; (165c <pwm_init+0x294>)
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    13ca:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    13ce:	4ba4      	ldr	r3, [pc, #656]	; (1660 <pwm_init+0x298>)
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    13d0:	6f82      	ldr	r2, [r0, #120]	; 0x78
    13d2:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}

void pwm_init(void)
{
    13d6:	b5f0      	push	{r4, r5, r6, r7, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    13d8:	6782      	str	r2, [r0, #120]	; 0x78
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    13da:	2500      	movs	r5, #0
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    13dc:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    13e0:	f44f 4670 	mov.w	r6, #61440	; 0xf000
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    13e4:	4c9f      	ldr	r4, [pc, #636]	; (1664 <pwm_init+0x29c>)
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    13e6:	f44f 4e60 	mov.w	lr, #57344	; 0xe000

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    13ea:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    13ec:	f44f 6780 	mov.w	r7, #1024	; 0x400
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    13f0:	4314      	orrs	r4, r2
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    13f2:	462a      	mov	r2, r5
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    13f4:	f8c0 4080 	str.w	r4, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    13f8:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    13fc:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1400:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    1404:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1408:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    140c:	b280      	uxth	r0, r0
    140e:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1412:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    1416:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    141a:	4b91      	ldr	r3, [pc, #580]	; (1660 <pwm_init+0x298>)
	for (i=0; i < 4; i++) {
    141c:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    141e:	2500      	movs	r5, #0
    1420:	0140      	lsls	r0, r0, #5
    1422:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1424:	2904      	cmp	r1, #4
    1426:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1428:	f8a3 e004 	strh.w	lr, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    142c:	80df      	strh	r7, [r3, #6]
		p->SM[i].OCTRL = 0;
    142e:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1430:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    1432:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    1434:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    1436:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    1438:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    143a:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    143c:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    143e:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1440:	d1e9      	bne.n	1416 <pwm_init+0x4e>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1442:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1446:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    144a:	4b87      	ldr	r3, [pc, #540]	; (1668 <pwm_init+0x2a0>)
    144c:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1450:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1452:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1454:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1458:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    145a:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    145e:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1462:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    1466:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    146a:	b280      	uxth	r0, r0
    146c:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    1470:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1474:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    1478:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    147c:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    1480:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1484:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    1488:	b280      	uxth	r0, r0
    148a:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    148e:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    1492:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    1496:	4b74      	ldr	r3, [pc, #464]	; (1668 <pwm_init+0x2a0>)
	for (i=0; i < 4; i++) {
    1498:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    149a:	2500      	movs	r5, #0
    149c:	0140      	lsls	r0, r0, #5
    149e:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    14a0:	2904      	cmp	r1, #4
    14a2:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    14a4:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    14a6:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    14aa:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    14ac:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    14ae:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    14b0:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    14b2:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    14b4:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    14b6:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    14b8:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    14ba:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    14bc:	d1e9      	bne.n	1492 <pwm_init+0xca>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    14be:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    14c2:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    14c6:	4b69      	ldr	r3, [pc, #420]	; (166c <pwm_init+0x2a4>)
    14c8:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    14cc:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    14ce:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    14d0:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    14d4:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    14d6:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    14da:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    14de:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    14e2:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    14e6:	b280      	uxth	r0, r0
    14e8:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    14ec:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    14f0:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    14f4:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    14f8:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    14fc:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    1500:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    1504:	b280      	uxth	r0, r0
    1506:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    150a:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    150e:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    1512:	4b56      	ldr	r3, [pc, #344]	; (166c <pwm_init+0x2a4>)
	for (i=0; i < 4; i++) {
    1514:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1516:	2500      	movs	r5, #0
    1518:	0140      	lsls	r0, r0, #5
    151a:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    151c:	2904      	cmp	r1, #4
    151e:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    1520:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1522:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    1526:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    1528:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    152a:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    152c:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    152e:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    1530:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    1532:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    1534:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    1536:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    1538:	d1e9      	bne.n	150e <pwm_init+0x146>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    153a:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    153e:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    1542:	4b4b      	ldr	r3, [pc, #300]	; (1670 <pwm_init+0x2a8>)
    1544:	f44f 4770 	mov.w	r7, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1548:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    154a:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    154c:	f44f 4660 	mov.w	r6, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    1550:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    1552:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    1556:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    155a:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    155e:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
    1562:	b280      	uxth	r0, r0
    1564:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
    1568:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    156c:	f8a3 718c 	strh.w	r7, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    1570:	f248 27b8 	movw	r7, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    1574:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    1578:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    157c:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
    1580:	b280      	uxth	r0, r0
    1582:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
    1586:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
    158a:	eb01 0041 	add.w	r0, r1, r1, lsl #1
    158e:	4b38      	ldr	r3, [pc, #224]	; (1670 <pwm_init+0x2a8>)
	for (i=0; i < 4; i++) {
    1590:	3101      	adds	r1, #1
    1592:	0140      	lsls	r0, r0, #5
    1594:	461c      	mov	r4, r3
    1596:	2904      	cmp	r1, #4
    1598:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    159a:	809e      	strh	r6, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    159c:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    15a0:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    15a2:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    15a4:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    15a6:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    15a8:	81df      	strh	r7, [r3, #14]
		p->SM[i].VAL2 = 0;
    15aa:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    15ac:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    15ae:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    15b0:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    15b2:	d1ea      	bne.n	158a <pwm_init+0x1c2>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    15b4:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    15b8:	270f      	movs	r7, #15

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    15ba:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    15bc:	f241 0601 	movw	r6, #4097	; 0x1001
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    15c0:	b29b      	uxth	r3, r3
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    15c2:	f645 5ec0 	movw	lr, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    15c6:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    15c8:	f243 0526 	movw	r5, #12326	; 0x3026
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    15cc:	433b      	orrs	r3, r7
    15ce:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    15d2:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
    15d6:	b29b      	uxth	r3, r3
    15d8:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
    15dc:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    15e0:	0150      	lsls	r0, r2, #5
    15e2:	4b24      	ldr	r3, [pc, #144]	; (1674 <pwm_init+0x2ac>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    15e4:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    15e6:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    15e8:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    15ea:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    15ec:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    15ee:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    15f0:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    15f2:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    15f6:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    15f8:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    15fa:	819d      	strh	r5, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    15fc:	d1f0      	bne.n	15e0 <pwm_init+0x218>
    15fe:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    1600:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1602:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1606:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    160a:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    160c:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1610:	0150      	lsls	r0, r2, #5
    1612:	4b19      	ldr	r3, [pc, #100]	; (1678 <pwm_init+0x2b0>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1614:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    1616:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1618:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    161a:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    161c:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    161e:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1620:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1622:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    1624:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    1626:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1628:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    162a:	d1f1      	bne.n	1610 <pwm_init+0x248>
    162c:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    162e:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    1630:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1634:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    1638:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    163a:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    163e:	0150      	lsls	r0, r2, #5
    1640:	4b0e      	ldr	r3, [pc, #56]	; (167c <pwm_init+0x2b4>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1642:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    1644:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1646:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    1648:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    164a:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    164c:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    164e:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    1650:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    1652:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    1654:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    1656:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    1658:	d1f1      	bne.n	163e <pwm_init+0x276>
	flexpwm_init(&IMXRT_FLEXPWM3);
	flexpwm_init(&IMXRT_FLEXPWM4);
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    165a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    165c:	400fc000 	.word	0x400fc000
    1660:	403dc000 	.word	0x403dc000
    1664:	fc030000 	.word	0xfc030000
    1668:	403e0000 	.word	0x403e0000
    166c:	403e4000 	.word	0x403e4000
    1670:	403e8000 	.word	0x403e8000
    1674:	401dc000 	.word	0x401dc000
    1678:	401e0000 	.word	0x401e0000
    167c:	401e4000 	.word	0x401e4000

00001680 <rtc_get>:
#include "debug/printf.h"


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
    1680:	4b0a      	ldr	r3, [pc, #40]	; (16ac <rtc_get+0x2c>)
#include "imxrt.h"
#include "debug/printf.h"


unsigned long rtc_get(void)
{
    1682:	b430      	push	{r4, r5}
	uint32_t hi1 = SNVS_HPRTCMR;
    1684:	6a58      	ldr	r0, [r3, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    1686:	461c      	mov	r4, r3


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
    1688:	6a99      	ldr	r1, [r3, #40]	; 0x28
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    168a:	6a62      	ldr	r2, [r4, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
    168c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
    168e:	4299      	cmp	r1, r3
    1690:	bf08      	it	eq
    1692:	4290      	cmpeq	r0, r2
unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    1694:	4610      	mov	r0, r2
		uint32_t lo2 = SNVS_HPRTCLR;
    1696:	4619      	mov	r1, r3
		if (lo1 == lo2 && hi1 == hi2) {
    1698:	bf0c      	ite	eq
    169a:	2501      	moveq	r5, #1
    169c:	2500      	movne	r5, #0
    169e:	2d00      	cmp	r5, #0
    16a0:	d0f3      	beq.n	168a <rtc_get+0xa>
			return (hi2 << 17) | (lo2 >> 15);
    16a2:	0bd9      	lsrs	r1, r3, #15
		}
		hi1 = hi2;
		lo1 = lo2;
	}
}
    16a4:	bc30      	pop	{r4, r5}
    16a6:	ea41 4042 	orr.w	r0, r1, r2, lsl #17
    16aa:	4770      	bx	lr
    16ac:	400d4000 	.word	0x400d4000

000016b0 <sm_align_pool>:
	if (spool->pool_size % HEADER_SZ) return 0;
	return 1;
}

int sm_align_pool(struct smalloc_pool *spool)
{
    16b0:	b508      	push	{r3, lr}

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    16b2:	6803      	ldr	r3, [r0, #0]
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    16b4:	6842      	ldr	r2, [r0, #4]

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    16b6:	b1bb      	cbz	r3, 16e8 <sm_align_pool+0x38>
    16b8:	b17a      	cbz	r2, 16da <sm_align_pool+0x2a>
	if (spool->pool_size % HEADER_SZ) return 0;
    16ba:	4b10      	ldr	r3, [pc, #64]	; (16fc <sm_align_pool+0x4c>)
    16bc:	fba3 1302 	umull	r1, r3, r3, r2
    16c0:	08db      	lsrs	r3, r3, #3
    16c2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    16c6:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
    16ca:	d003      	beq.n	16d4 <sm_align_pool+0x24>
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
    16cc:	1ad2      	subs	r2, r2, r3
    16ce:	6042      	str	r2, [r0, #4]
	if (spool->pool_size <= MIN_POOL_SZ) {
    16d0:	2af0      	cmp	r2, #240	; 0xf0
    16d2:	d902      	bls.n	16da <sm_align_pool+0x2a>

int sm_align_pool(struct smalloc_pool *spool)
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;
    16d4:	2301      	movs	r3, #1
		errno = ENOSPC;
		return 0;
	}

	return 1;
}
    16d6:	4618      	mov	r0, r3
    16d8:	bd08      	pop	{r3, pc}
	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
	if (spool->pool_size <= MIN_POOL_SZ) {
		errno = ENOSPC;
    16da:	f004 fc81 	bl	5fe0 <__errno>
    16de:	221c      	movs	r2, #28
    16e0:	2300      	movs	r3, #0
    16e2:	6002      	str	r2, [r0, #0]
		return 0;
	}

	return 1;
}
    16e4:	4618      	mov	r0, r3
    16e6:	bd08      	pop	{r3, pc}
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    16e8:	4b04      	ldr	r3, [pc, #16]	; (16fc <sm_align_pool+0x4c>)
    16ea:	fba3 1302 	umull	r1, r3, r3, r2
    16ee:	08db      	lsrs	r3, r3, #3
    16f0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (x) spool->pool_size -= x;
    16f4:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
    16f8:	d1e8      	bne.n	16cc <sm_align_pool+0x1c>
    16fa:	e7e9      	b.n	16d0 <sm_align_pool+0x20>
    16fc:	aaaaaaab 	.word	0xaaaaaaab

00001700 <sm_set_pool>:

	return 1;
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
    1700:	b570      	push	{r4, r5, r6, lr}
	if (!spool) {
    1702:	4604      	mov	r4, r0
    1704:	2800      	cmp	r0, #0
    1706:	d03a      	beq.n	177e <sm_set_pool+0x7e>
		errno = EINVAL;
		return 0;
	}

	if (!new_pool || !new_pool_size) {
    1708:	b119      	cbz	r1, 1712 <sm_set_pool+0x12>
    170a:	fab2 f582 	clz	r5, r2
    170e:	096d      	lsrs	r5, r5, #5
    1710:	b1fd      	cbz	r5, 1752 <sm_set_pool+0x52>

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    1712:	6820      	ldr	r0, [r4, #0]
    1714:	b108      	cbz	r0, 171a <sm_set_pool+0x1a>
    1716:	6862      	ldr	r2, [r4, #4]
    1718:	b932      	cbnz	r2, 1728 <sm_set_pool+0x28>
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    171a:	f004 fc61 	bl	5fe0 <__errno>
    171e:	2316      	movs	r3, #22
		return 0;
    1720:	2200      	movs	r2, #0
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    1722:	6003      	str	r3, [r0, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1724:	4610      	mov	r0, r2
    1726:	bd70      	pop	{r4, r5, r6, pc}
struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
	if (spool->pool_size % HEADER_SZ) return 0;
    1728:	4918      	ldr	r1, [pc, #96]	; (178c <sm_set_pool+0x8c>)
    172a:	fba1 3102 	umull	r3, r1, r1, r2
    172e:	08c9      	lsrs	r1, r1, #3
    1730:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    1734:	ebb2 0181 	subs.w	r1, r2, r1, lsl #2
    1738:	d1ef      	bne.n	171a <sm_set_pool+0x1a>
		return 0;
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
    173a:	68a3      	ldr	r3, [r4, #8]
    173c:	b10b      	cbz	r3, 1742 <sm_set_pool+0x42>
    173e:	f005 f869 	bl	6814 <memset>
			memset(spool, 0, sizeof(struct smalloc_pool));
    1742:	2300      	movs	r3, #0
			return 1;
    1744:	2201      	movs	r2, #1
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    1746:	6023      	str	r3, [r4, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1748:	4610      	mov	r0, r2
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    174a:	6063      	str	r3, [r4, #4]
    174c:	60a3      	str	r3, [r4, #8]
    174e:	60e3      	str	r3, [r4, #12]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    1750:	bd70      	pop	{r4, r5, r6, pc}
    1752:	461e      	mov	r6, r3
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
    1754:	9b04      	ldr	r3, [sp, #16]
		errno = EINVAL;
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
    1756:	e880 0006 	stmia.w	r0, {r1, r2}
	spool->oomfn = oom_handler;
    175a:	60c3      	str	r3, [r0, #12]
	if (!sm_align_pool(spool)) return 0;
    175c:	f7ff ffa8 	bl	16b0 <sm_align_pool>
    1760:	4602      	mov	r2, r0
    1762:	2800      	cmp	r0, #0
    1764:	d0de      	beq.n	1724 <sm_set_pool+0x24>

	if (do_zero) {
    1766:	b916      	cbnz	r6, 176e <sm_set_pool+0x6e>
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
    1768:	2201      	movs	r2, #1
}
    176a:	4610      	mov	r0, r2
    176c:	bd70      	pop	{r4, r5, r6, pc}
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
    176e:	e894 0005 	ldmia.w	r4, {r0, r2}
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
    1772:	60a6      	str	r6, [r4, #8]
		memset(spool->pool, 0, spool->pool_size);
    1774:	4629      	mov	r1, r5
    1776:	f005 f84d 	bl	6814 <memset>
	}

	return 1;
    177a:	2201      	movs	r2, #1
    177c:	e7d2      	b.n	1724 <sm_set_pool+0x24>
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    177e:	f004 fc2f 	bl	5fe0 <__errno>
    1782:	2316      	movs	r3, #22
		return 0;
    1784:	4622      	mov	r2, r4
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    1786:	6003      	str	r3, [r0, #0]
		return 0;
    1788:	e7cc      	b.n	1724 <sm_set_pool+0x24>
    178a:	bf00      	nop
    178c:	aaaaaaab 	.word	0xaaaaaaab

00001790 <unused_interrupt_vector>:
	const uint32_t *stack;
	struct arm_fault_info_struct *info;
	const uint32_t *p, *end;

	// disallow any nested interrupts
	__disable_irq();
    1790:	b672      	cpsid	i
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
    1792:	f3ef 8305 	mrs	r3, IPSR
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
    1796:	4d49      	ldr	r5, [pc, #292]	; (18bc <unused_interrupt_vector+0x12c>)
    1798:	606b      	str	r3, [r5, #4]
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
    179a:	f3ef 8308 	mrs	r3, MSP
	info->cfsr = SCB_CFSR;
    179e:	4c48      	ldr	r4, [pc, #288]	; (18c0 <unused_interrupt_vector+0x130>)
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
	info->len = sizeof(*info) / 4;
    17a0:	462e      	mov	r6, r5
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
    17a2:	4848      	ldr	r0, [pc, #288]	; (18c4 <unused_interrupt_vector+0x134>)
	info->mmfar = SCB_MMFAR;
    17a4:	4948      	ldr	r1, [pc, #288]	; (18c8 <unused_interrupt_vector+0x138>)
	info->bfar = SCB_BFAR;
    17a6:	4a49      	ldr	r2, [pc, #292]	; (18cc <unused_interrupt_vector+0x13c>)
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    17a8:	6824      	ldr	r4, [r4, #0]
	info->hfsr = SCB_HFSR;
    17aa:	6800      	ldr	r0, [r0, #0]
	info->mmfar = SCB_MMFAR;
    17ac:	6809      	ldr	r1, [r1, #0]
	info->bfar = SCB_BFAR;
    17ae:	6812      	ldr	r2, [r2, #0]
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
    17b0:	6129      	str	r1, [r5, #16]
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    17b2:	60ac      	str	r4, [r5, #8]
	info->hfsr = SCB_HFSR;
    17b4:	60e8      	str	r0, [r5, #12]
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
    17b6:	616a      	str	r2, [r5, #20]
	info->ret = stack[6];
    17b8:	699a      	ldr	r2, [r3, #24]
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    17ba:	4c45      	ldr	r4, [pc, #276]	; (18d0 <unused_interrupt_vector+0x140>)
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
    17bc:	61aa      	str	r2, [r5, #24]
	info->xpsr = stack[7];
    17be:	69db      	ldr	r3, [r3, #28]
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    17c0:	4f44      	ldr	r7, [pc, #272]	; (18d4 <unused_interrupt_vector+0x144>)
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
    17c2:	61eb      	str	r3, [r5, #28]
	info->temp = tempmonGetTemp();
    17c4:	f000 f8c8 	bl	1958 <tempmonGetTemp>
    17c8:	ed85 0a08 	vstr	s0, [r5, #32]
	info->time = rtc_get();
    17cc:	f7ff ff58 	bl	1680 <rtc_get>
	info->len = sizeof(*info) / 4;
    17d0:	230b      	movs	r3, #11
	// add CRC to crash report
	crc = 0xFFFFFFFF;
    17d2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
    17d6:	6268      	str	r0, [r5, #36]	; 0x24
	info->len = sizeof(*info) / 4;
    17d8:	4619      	mov	r1, r3
    17da:	602b      	str	r3, [r5, #0]
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
    17dc:	404a      	eors	r2, r1
    17de:	2120      	movs	r1, #32
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    17e0:	f002 0301 	and.w	r3, r2, #1
    17e4:	3901      	subs	r1, #1
    17e6:	fb04 f303 	mul.w	r3, r4, r3
    17ea:	ea83 0252 	eor.w	r2, r3, r2, lsr #1
    17ee:	d1f7      	bne.n	17e0 <unused_interrupt_vector+0x50>
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    17f0:	42be      	cmp	r6, r7
    17f2:	d002      	beq.n	17fa <unused_interrupt_vector+0x6a>
    17f4:	f856 1f04 	ldr.w	r1, [r6, #4]!
    17f8:	e7f0      	b.n	17dc <unused_interrupt_vector+0x4c>
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
	}
	info->crc = crc;
    17fa:	4930      	ldr	r1, [pc, #192]	; (18bc <unused_interrupt_vector+0x12c>)
    17fc:	628a      	str	r2, [r1, #40]	; 0x28
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    17fe:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    1802:	4b35      	ldr	r3, [pc, #212]	; (18d8 <unused_interrupt_vector+0x148>)
    1804:	4a35      	ldr	r2, [pc, #212]	; (18dc <unused_interrupt_vector+0x14c>)
    1806:	6019      	str	r1, [r3, #0]
    1808:	601a      	str	r2, [r3, #0]
		location += 32;
	} while (location < end_addr);
	asm("dsb");
    180a:	f3bf 8f4f 	dsb	sy
	asm("isb");
    180e:	f3bf 8f6f 	isb	sy
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1812:	4a33      	ldr	r2, [pc, #204]	; (18e0 <unused_interrupt_vector+0x150>)
	PIT_MCR = PIT_MCR_MDIS;
    1814:	2502      	movs	r5, #2
    1816:	4c33      	ldr	r4, [pc, #204]	; (18e4 <unused_interrupt_vector+0x154>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1818:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    181a:	4933      	ldr	r1, [pc, #204]	; (18e8 <unused_interrupt_vector+0x158>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    181c:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1820:	4832      	ldr	r0, [pc, #200]	; (18ec <unused_interrupt_vector+0x15c>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1822:	66d3      	str	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
    1824:	6025      	str	r5, [r4, #0]
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    1826:	69d3      	ldr	r3, [r2, #28]
    1828:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    182c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1830:	61d3      	str	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1832:	680b      	ldr	r3, [r1, #0]
    1834:	4283      	cmp	r3, r0
    1836:	d83e      	bhi.n	18b6 <unused_interrupt_vector+0x126>
	PIT_MCR = 0;
    1838:	4a2a      	ldr	r2, [pc, #168]	; (18e4 <unused_interrupt_vector+0x154>)
    183a:	2100      	movs	r1, #0
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    183c:	2001      	movs	r0, #1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    183e:	4e2c      	ldr	r6, [pc, #176]	; (18f0 <unused_interrupt_vector+0x160>)
	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
    1840:	6011      	str	r1, [r2, #0]
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    1842:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
    1846:	f8c2 1108 	str.w	r1, [r2, #264]	; 0x108
	NVIC_ICER4 = 0xFFFFFFFF;

	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
    184a:	460c      	mov	r4, r1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    184c:	f8c2 6100 	str.w	r6, [r2, #256]	; 0x100
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    1850:	4615      	mov	r5, r2
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    1852:	f8c2 0108 	str.w	r0, [r2, #264]	; 0x108
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    1856:	4607      	mov	r7, r0
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    1858:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 191c <unused_interrupt_vector+0x18c>
	NVIC_ICER1 = 0xFFFFFFFF;
    185c:	4e25      	ldr	r6, [pc, #148]	; (18f4 <unused_interrupt_vector+0x164>)
	NVIC_ICER2 = 0xFFFFFFFF;
    185e:	4826      	ldr	r0, [pc, #152]	; (18f8 <unused_interrupt_vector+0x168>)
	NVIC_ICER3 = 0xFFFFFFFF;
    1860:	4926      	ldr	r1, [pc, #152]	; (18fc <unused_interrupt_vector+0x16c>)
	NVIC_ICER4 = 0xFFFFFFFF;
    1862:	4a27      	ldr	r2, [pc, #156]	; (1900 <unused_interrupt_vector+0x170>)
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    1864:	f8ce 3000 	str.w	r3, [lr]
	NVIC_ICER1 = 0xFFFFFFFF;
    1868:	6033      	str	r3, [r6, #0]
	NVIC_ICER2 = 0xFFFFFFFF;
    186a:	6003      	str	r3, [r0, #0]
	NVIC_ICER3 = 0xFFFFFFFF;
    186c:	600b      	str	r3, [r1, #0]
	NVIC_ICER4 = 0xFFFFFFFF;
    186e:	6013      	str	r3, [r2, #0]
    1870:	e001      	b.n	1876 <unused_interrupt_vector+0xe6>
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
		}
		usb_isr();
    1872:	f000 f955 	bl	1b20 <usb_isr>
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    1876:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
    187a:	4b1a      	ldr	r3, [pc, #104]	; (18e4 <unused_interrupt_vector+0x154>)
    187c:	2a00      	cmp	r2, #0
    187e:	d0f8      	beq.n	1872 <unused_interrupt_vector+0xe2>
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
    1880:	3401      	adds	r4, #1
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    1882:	f8c5 710c 	str.w	r7, [r5, #268]	; 0x10c
			if (++count >= 80) break;  // reboot after 8 seconds
    1886:	2c4f      	cmp	r4, #79	; 0x4f
    1888:	d9f3      	bls.n	1872 <unused_interrupt_vector+0xe2>
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    188a:	4a1e      	ldr	r2, [pc, #120]	; (1904 <unused_interrupt_vector+0x174>)
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    188c:	2402      	movs	r4, #2
    188e:	481e      	ldr	r0, [pc, #120]	; (1908 <unused_interrupt_vector+0x178>)
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    1890:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    1894:	f8c0 4140 	str.w	r4, [r0, #320]	; 0x140
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    1898:	6351      	str	r1, [r2, #52]	; 0x34
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    189a:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    189e:	b932      	cbnz	r2, 18ae <unused_interrupt_vector+0x11e>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
    18a0:	491a      	ldr	r1, [pc, #104]	; (190c <unused_interrupt_vector+0x17c>)
    18a2:	4a1b      	ldr	r2, [pc, #108]	; (1910 <unused_interrupt_vector+0x180>)
    18a4:	630a      	str	r2, [r1, #48]	; 0x30
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    18a6:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    18aa:	2800      	cmp	r0, #0
    18ac:	d0fa      	beq.n	18a4 <unused_interrupt_vector+0x114>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
	SCB_AIRCR = 0x05FA0004;
    18ae:	4b19      	ldr	r3, [pc, #100]	; (1914 <unused_interrupt_vector+0x184>)
    18b0:	4a19      	ldr	r2, [pc, #100]	; (1918 <unused_interrupt_vector+0x188>)
    18b2:	601a      	str	r2, [r3, #0]
    18b4:	e7fe      	b.n	18b4 <unused_interrupt_vector+0x124>

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    18b6:	f7ff fb57 	bl	f68 <set_arm_clock>
    18ba:	e7bd      	b.n	1838 <unused_interrupt_vector+0xa8>
    18bc:	2027ff80 	.word	0x2027ff80
    18c0:	e000ed28 	.word	0xe000ed28
    18c4:	e000ed2c 	.word	0xe000ed2c
    18c8:	e000ed34 	.word	0xe000ed34
    18cc:	e000ed38 	.word	0xe000ed38
    18d0:	edb88320 	.word	0xedb88320
    18d4:	2027ffa4 	.word	0x2027ffa4
    18d8:	e000ef70 	.word	0xe000ef70
    18dc:	2027ffa0 	.word	0x2027ffa0
    18e0:	400fc000 	.word	0x400fc000
    18e4:	40084000 	.word	0x40084000
    18e8:	20001478 	.word	0x20001478
    18ec:	0bcd3d80 	.word	0x0bcd3d80
    18f0:	00249f00 	.word	0x00249f00
    18f4:	e000e184 	.word	0xe000e184
    18f8:	e000e188 	.word	0xe000e188
    18fc:	e000e18c 	.word	0xe000e18c
    1900:	e000e190 	.word	0xe000e190
    1904:	400d9000 	.word	0x400d9000
    1908:	402e0000 	.word	0x402e0000
    190c:	400f8000 	.word	0x400f8000
    1910:	0bad00f1 	.word	0x0bad00f1
    1914:	e000ed0c 	.word	0xe000ed0c
    1918:	05fa0004 	.word	0x05fa0004
    191c:	e000e180 	.word	0xe000e180

00001920 <_sbrk>:

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
        char *prev = __brkval;
    1920:	4a09      	ldr	r2, [pc, #36]	; (1948 <_sbrk+0x28>)
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
    1922:	b508      	push	{r3, lr}
        char *prev = __brkval;
    1924:	6813      	ldr	r3, [r2, #0]
        if (incr != 0) {
    1926:	b120      	cbz	r0, 1932 <_sbrk+0x12>
                if (prev + incr > (char *)&_heap_end) {
    1928:	4418      	add	r0, r3
    192a:	4908      	ldr	r1, [pc, #32]	; (194c <_sbrk+0x2c>)
    192c:	4288      	cmp	r0, r1
    192e:	d802      	bhi.n	1936 <_sbrk+0x16>
                        errno = ENOMEM;
                        return (void *)-1;
                }
                __brkval = prev + incr;
    1930:	6010      	str	r0, [r2, #0]
        }
        return prev;
}
    1932:	4618      	mov	r0, r3
    1934:	bd08      	pop	{r3, pc}
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    1936:	f004 fb53 	bl	5fe0 <__errno>
    193a:	220c      	movs	r2, #12
                        return (void *)-1;
    193c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    1940:	6002      	str	r2, [r0, #0]
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    1942:	4618      	mov	r0, r3
    1944:	bd08      	pop	{r3, pc}
    1946:	bf00      	nop
    1948:	20001858 	.word	0x20001858
    194c:	20280000 	.word	0x20280000

00001950 <_exit>:
}

__attribute__((weak))
void _exit(int status)
{
	while (1) asm ("WFI");
    1950:	bf30      	wfi
    1952:	e7fd      	b.n	1950 <_exit>

00001954 <Panic_Temp_isr>:
static float s_hot_ROOM, s_roomC_hotC;

extern void unused_interrupt_vector(void); // startup.c

void Panic_Temp_isr(void) {
  unused_interrupt_vector();
    1954:	f7ff bf1c 	b.w	1790 <unused_interrupt_vector>

00001958 <tempmonGetTemp>:
float tempmonGetTemp(void)
{
    uint32_t nmeas;
    float tmeas;

    while (!(TEMPMON_TEMPSENSE0 & 0x4U))
    1958:	4912      	ldr	r1, [pc, #72]	; (19a4 <tempmonGetTemp+0x4c>)
    195a:	680b      	ldr	r3, [r1, #0]
    195c:	4a11      	ldr	r2, [pc, #68]	; (19a4 <tempmonGetTemp+0x4c>)
    195e:	075b      	lsls	r3, r3, #29
    1960:	d5fb      	bpl.n	195a <tempmonGetTemp+0x2>
    {
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    1962:	6813      	ldr	r3, [r2, #0]
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1964:	4910      	ldr	r1, [pc, #64]	; (19a8 <tempmonGetTemp+0x50>)

    return tmeas;
    1966:	f3c3 230b 	ubfx	r3, r3, #8, #12
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    196a:	4a10      	ldr	r2, [pc, #64]	; (19ac <tempmonGetTemp+0x54>)

    return tmeas;
    196c:	ee07 3a90 	vmov	s15, r3
    1970:	680b      	ldr	r3, [r1, #0]
    1972:	ed92 6a00 	vldr	s12, [r2]
    1976:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    197a:	ee07 3a90 	vmov	s15, r3
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    197e:	4a0c      	ldr	r2, [pc, #48]	; (19b0 <tempmonGetTemp+0x58>)

    return tmeas;
    1980:	eef8 7a67 	vcvt.f32.u32	s15, s15
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    1984:	4b0b      	ldr	r3, [pc, #44]	; (19b4 <tempmonGetTemp+0x5c>)

    return tmeas;
    1986:	edd2 6a00 	vldr	s13, [r2]
    198a:	ee77 7a67 	vsub.f32	s15, s14, s15
    198e:	ed93 7a00 	vldr	s14, [r3]
    1992:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    1996:	ee67 7a86 	vmul.f32	s15, s15, s12
    199a:	ee87 0aa6 	vdiv.f32	s0, s15, s13
}
    199e:	ee37 0a40 	vsub.f32	s0, s14, s0
    19a2:	4770      	bx	lr
    19a4:	400d8180 	.word	0x400d8180
    19a8:	20002728 	.word	0x20002728
    19ac:	20002730 	.word	0x20002730
    19b0:	20002734 	.word	0x20002734
    19b4:	2000272c 	.word	0x2000272c

000019b8 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    19b8:	6b83      	ldr	r3, [r0, #56]	; 0x38
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
    19ba:	b4f0      	push	{r4, r5, r6, r7}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    19bc:	b11b      	cbz	r3, 19c6 <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    19be:	6853      	ldr	r3, [r2, #4]
    19c0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    19c4:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    19c6:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    19c8:	6b44      	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    19ca:	b35c      	cbz	r4, 1a24 <schedule_transfer+0x6c>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    19cc:	4b1c      	ldr	r3, [pc, #112]	; (1a40 <schedule_transfer+0x88>)
	__disable_irq();
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
	if (last) {
		last->next = (uint32_t)transfer;
    19ce:	6022      	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    19d0:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    19d4:	420c      	tst	r4, r1
    19d6:	d115      	bne.n	1a04 <schedule_transfer+0x4c>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    19d8:	4e1a      	ldr	r6, [pc, #104]	; (1a44 <schedule_transfer+0x8c>)
    19da:	6837      	ldr	r7, [r6, #0]
    19dc:	e004      	b.n	19e8 <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    19de:	6834      	ldr	r4, [r6, #0]
    19e0:	1be4      	subs	r4, r4, r7
    19e2:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
    19e6:	d20b      	bcs.n	1a00 <schedule_transfer+0x48>
		if (USB1_ENDPTPRIME & epmask) goto end;
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    19e8:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    19ec:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    19f0:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    19f4:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    19f8:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    19fc:	0464      	lsls	r4, r4, #17
    19fe:	d5ee      	bpl.n	19de <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    1a00:	400d      	ands	r5, r1
    1a02:	d003      	beq.n	1a0c <schedule_transfer+0x54>
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    1a04:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    1a06:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1a08:	bcf0      	pop	{r4, r5, r6, r7}
    1a0a:	4770      	bx	lr
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
    1a0c:	4c0c      	ldr	r4, [pc, #48]	; (1a40 <schedule_transfer+0x88>)
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
    1a0e:	6082      	str	r2, [r0, #8]
		endpoint->status = 0;
    1a10:	60c5      	str	r5, [r0, #12]
		USB1_ENDPTPRIME |= epmask;
    1a12:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1a16:	4319      	orrs	r1, r3
    1a18:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    1a1c:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    1a1e:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1a20:	bcf0      	pop	{r4, r5, r6, r7}
    1a22:	4770      	bx	lr
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
    1a24:	4d06      	ldr	r5, [pc, #24]	; (1a40 <schedule_transfer+0x88>)
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
    1a26:	6082      	str	r2, [r0, #8]
	endpoint->status = 0;
    1a28:	60c4      	str	r4, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
    1a2a:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
    1a2e:	4319      	orrs	r1, r3
    1a30:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    1a34:	6302      	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
    1a36:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    1a38:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1a3a:	bcf0      	pop	{r4, r5, r6, r7}
    1a3c:	4770      	bx	lr
    1a3e:	bf00      	nop
    1a40:	402e0000 	.word	0x402e0000
    1a44:	e0001004 	.word	0xe0001004

00001a48 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    1a48:	b570      	push	{r4, r5, r6, lr}
    1a4a:	4606      	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    1a4c:	6b00      	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
    1a4e:	b190      	cbz	r0, 1a76 <run_callbacks+0x2e>
    1a50:	4602      	mov	r2, r0
    1a52:	2400      	movs	r4, #0
    1a54:	e003      	b.n	1a5e <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    1a56:	6812      	ldr	r2, [r2, #0]
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
    1a58:	3401      	adds	r4, #1
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
    1a5a:	2a01      	cmp	r2, #1
    1a5c:	d00c      	beq.n	1a78 <run_callbacks+0x30>

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
    1a5e:	6853      	ldr	r3, [r2, #4]
    1a60:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    1a64:	d0f7      	beq.n	1a56 <run_callbacks+0xe>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
    1a66:	6332      	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    1a68:	b12c      	cbz	r4, 1a76 <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
    1a6a:	6bb3      	ldr	r3, [r6, #56]	; 0x38
			break;
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
    1a6c:	6805      	ldr	r5, [r0, #0]
		ep->callback_function(first);
    1a6e:	4798      	blx	r3
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    1a70:	3c01      	subs	r4, #1
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
    1a72:	4628      	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    1a74:	d1f9      	bne.n	1a6a <run_callbacks+0x22>
    1a76:	bd70      	pop	{r4, r5, r6, pc}
		count++;
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
    1a78:	6333      	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
    1a7a:	6373      	str	r3, [r6, #52]	; 0x34
			break;
    1a7c:	e7f4      	b.n	1a68 <run_callbacks+0x20>
    1a7e:	bf00      	nop

00001a80 <endpoint0_transmit.constprop.1>:
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    1a80:	b5f0      	push	{r4, r5, r6, r7, lr}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
    1a82:	b9e1      	cbnz	r1, 1abe <endpoint0_transmit.constprop.1+0x3e>
    1a84:	4c21      	ldr	r4, [pc, #132]	; (1b0c <endpoint0_transmit.constprop.1+0x8c>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1a86:	4922      	ldr	r1, [pc, #136]	; (1b10 <endpoint0_transmit.constprop.1+0x90>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1a88:	2000      	movs	r0, #0
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1a8a:	4b22      	ldr	r3, [pc, #136]	; (1b14 <endpoint0_transmit.constprop.1+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1a8c:	2201      	movs	r2, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1a8e:	f04f 1501 	mov.w	r5, #65537	; 0x10001
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1a92:	2680      	movs	r6, #128	; 0x80
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1a94:	600a      	str	r2, [r1, #0]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
	while (USB1_ENDPTPRIME) ;
    1a96:	461a      	mov	r2, r3
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
    1a98:	60a1      	str	r1, [r4, #8]
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1a9a:	604e      	str	r6, [r1, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
    1a9c:	60e0      	str	r0, [r4, #12]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1a9e:	f8c3 51bc 	str.w	r5, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    1aa2:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    1aa6:	4d1c      	ldr	r5, [pc, #112]	; (1b18 <endpoint0_transmit.constprop.1+0x98>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    1aa8:	f044 0401 	orr.w	r4, r4, #1
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1aac:	6088      	str	r0, [r1, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    1aae:	f8c3 41b0 	str.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    1ab2:	6028      	str	r0, [r5, #0]
	while (USB1_ENDPTPRIME) ;
    1ab4:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    1ab8:	2b00      	cmp	r3, #0
    1aba:	d1fb      	bne.n	1ab4 <endpoint0_transmit.constprop.1+0x34>
}
    1abc:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1abe:	0409      	lsls	r1, r1, #16
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1ac0:	4b16      	ldr	r3, [pc, #88]	; (1b1c <endpoint0_transmit.constprop.1+0x9c>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1ac2:	4d14      	ldr	r5, [pc, #80]	; (1b14 <endpoint0_transmit.constprop.1+0x94>)
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1ac4:	2601      	movs	r6, #1
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    1ac6:	4c11      	ldr	r4, [pc, #68]	; (1b0c <endpoint0_transmit.constprop.1+0x8c>)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1ac8:	f041 0180 	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    1acc:	2200      	movs	r2, #0
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1ace:	601e      	str	r6, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1ad0:	6059      	str	r1, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1ad2:	f500 5c80 	add.w	ip, r0, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    1ad6:	64e2      	str	r2, [r4, #76]	; 0x4c
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1ad8:	f500 5e00 	add.w	lr, r0, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    1adc:	64a3      	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1ade:	f500 5740 	add.w	r7, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1ae2:	f8d5 11b0 	ldr.w	r1, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1ae6:	f500 4680 	add.w	r6, r0, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
    1aea:	462a      	mov	r2, r5
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    1aec:	6098      	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1aee:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1af2:	f8c3 c00c 	str.w	ip, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1af6:	f8c3 e010 	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1afa:	615f      	str	r7, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1afc:	619e      	str	r6, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1afe:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    1b02:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    1b06:	2b00      	cmp	r3, #0
    1b08:	d1fb      	bne.n	1b02 <endpoint0_transmit.constprop.1+0x82>
    1b0a:	e7bc      	b.n	1a86 <endpoint0_transmit.constprop.1+0x6>
    1b0c:	20000000 	.word	0x20000000
    1b10:	20002780 	.word	0x20002780
    1b14:	402e0000 	.word	0x402e0000
    1b18:	200026f0 	.word	0x200026f0
    1b1c:	20002760 	.word	0x20002760

00001b20 <usb_isr>:
	__builtin_unreachable();
}


void usb_isr(void)
{
    1b20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    1b24:	4cb0      	ldr	r4, [pc, #704]	; (1de8 <usb_isr+0x2c8>)
	__builtin_unreachable();
}


void usb_isr(void)
{
    1b26:	b083      	sub	sp, #12
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    1b28:	f8d4 8144 	ldr.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    1b2c:	f018 0f01 	tst.w	r8, #1
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
	USB1_USBSTS = status;
    1b30:	f8c4 8144 	str.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    1b34:	d06f      	beq.n	1c16 <usb_isr+0xf6>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    1b36:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1b3a:	2b00      	cmp	r3, #0
    1b3c:	d066      	beq.n	1c0c <usb_isr+0xec>
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    1b3e:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
    1b42:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 1e0c <usb_isr+0x2ec>
    1b46:	4fa9      	ldr	r7, [pc, #676]	; (1dec <usb_isr+0x2cc>)
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    1b48:	4626      	mov	r6, r4
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    1b4a:	46da      	mov	sl, fp
	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
    1b4c:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
    1b50:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    1b52:	6afa      	ldr	r2, [r7, #44]	; 0x2c
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    1b54:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    1b58:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    1b5c:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    1b60:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    1b64:	049d      	lsls	r5, r3, #18
    1b66:	d5f5      	bpl.n	1b54 <usb_isr+0x34>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    1b68:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
    1b6c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    1b70:	f8c6 3140 	str.w	r3, [r6, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    1b74:	f8c6 a1b4 	str.w	sl, [r6, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    1b78:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
    1b7c:	f013 1301 	ands.w	r3, r3, #65537	; 0x10001
    1b80:	d1fa      	bne.n	1b78 <usb_isr+0x58>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1b82:	b281      	uxth	r1, r0
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
    1b84:	f8c9 3000 	str.w	r3, [r9]
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1b88:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    1b8c:	f000 8148 	beq.w	1e20 <usb_isr+0x300>
    1b90:	f200 80bb 	bhi.w	1d0a <usb_isr+0x1ea>
    1b94:	2982      	cmp	r1, #130	; 0x82
    1b96:	f000 8193 	beq.w	1ec0 <usb_isr+0x3a0>
    1b9a:	f240 80cf 	bls.w	1d3c <usb_isr+0x21c>
    1b9e:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    1ba2:	f000 815d 	beq.w	1e60 <usb_isr+0x340>
    1ba6:	f240 3302 	movw	r3, #770	; 0x302
    1baa:	4299      	cmp	r1, r3
    1bac:	f040 80be 	bne.w	1d2c <usb_isr+0x20c>
			reply_buffer[0] = 1;
		}
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    1bb0:	b292      	uxth	r2, r2
    1bb2:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    1bb6:	2b07      	cmp	r3, #7
    1bb8:	f200 80b8 	bhi.w	1d2c <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    1bbc:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    1bc0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1bc4:	4a8a      	ldr	r2, [pc, #552]	; (1df0 <usb_isr+0x2d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1bc6:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1bca:	f04f 0001 	mov.w	r0, #1
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    1bce:	441a      	add	r2, r3
    1bd0:	6813      	ldr	r3, [r2, #0]
    1bd2:	bf14      	ite	ne
    1bd4:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    1bd8:	f043 0301 	orreq.w	r3, r3, #1
    1bdc:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1bde:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1be0:	4b84      	ldr	r3, [pc, #528]	; (1df4 <usb_isr+0x2d4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1be2:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1be4:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1be6:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1be8:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1bea:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1bee:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1bf2:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1bf4:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    1bf8:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    1bfc:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1c00:	2b00      	cmp	r3, #0
    1c02:	d1fb      	bne.n	1bfc <usb_isr+0xdc>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1c04:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1c08:	2b00      	cmp	r3, #0
    1c0a:	d19f      	bne.n	1b4c <usb_isr+0x2c>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    1c0c:	4a76      	ldr	r2, [pc, #472]	; (1de8 <usb_isr+0x2c8>)
    1c0e:	f8d2 31bc 	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    1c12:	2b00      	cmp	r3, #0
    1c14:	d147      	bne.n	1ca6 <usb_isr+0x186>
			}
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
    1c16:	f018 0f40 	tst.w	r8, #64	; 0x40
    1c1a:	d016      	beq.n	1c4a <usb_isr+0x12a>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    1c1c:	4b72      	ldr	r3, [pc, #456]	; (1de8 <usb_isr+0x2c8>)
    1c1e:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    1c22:	4619      	mov	r1, r3
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    1c24:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    1c28:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    1c2c:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    1c30:	f8d1 31b0 	ldr.w	r3, [r1, #432]	; 0x1b0
    1c34:	4a6c      	ldr	r2, [pc, #432]	; (1de8 <usb_isr+0x2c8>)
    1c36:	2b00      	cmp	r3, #0
    1c38:	d1fa      	bne.n	1c30 <usb_isr+0x110>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    1c3a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    1c3e:	496e      	ldr	r1, [pc, #440]	; (1df8 <usb_isr+0x2d8>)
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    1c40:	f8c2 01b4 	str.w	r0, [r2, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    1c44:	f8d2 2184 	ldr.w	r2, [r2, #388]	; 0x184
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    1c48:	600b      	str	r3, [r1, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
    1c4a:	f018 7f80 	tst.w	r8, #16777216	; 0x1000000
    1c4e:	d003      	beq.n	1c58 <usb_isr+0x138>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    1c50:	4b6a      	ldr	r3, [pc, #424]	; (1dfc <usb_isr+0x2dc>)
    1c52:	681b      	ldr	r3, [r3, #0]
    1c54:	b103      	cbz	r3, 1c58 <usb_isr+0x138>
    1c56:	4798      	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
    1c58:	f018 7f00 	tst.w	r8, #33554432	; 0x2000000
    1c5c:	d003      	beq.n	1c66 <usb_isr+0x146>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    1c5e:	4b68      	ldr	r3, [pc, #416]	; (1e00 <usb_isr+0x2e0>)
    1c60:	681b      	ldr	r3, [r3, #0]
    1c62:	b103      	cbz	r3, 1c66 <usb_isr+0x146>
    1c64:	4798      	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
    1c66:	f018 0f04 	tst.w	r8, #4
    1c6a:	d008      	beq.n	1c7e <usb_isr+0x15e>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    1c6c:	4b5e      	ldr	r3, [pc, #376]	; (1de8 <usb_isr+0x2c8>)
    1c6e:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    1c72:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    1c76:	d045      	beq.n	1d04 <usb_isr+0x1e4>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
    1c78:	4b62      	ldr	r3, [pc, #392]	; (1e04 <usb_isr+0x2e4>)
    1c7a:	2201      	movs	r2, #1
    1c7c:	701a      	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    1c7e:	4b5a      	ldr	r3, [pc, #360]	; (1de8 <usb_isr+0x2c8>)
    1c80:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    1c84:	0612      	lsls	r2, r2, #24
    1c86:	d50b      	bpl.n	1ca0 <usb_isr+0x180>
    1c88:	f018 0f80 	tst.w	r8, #128	; 0x80
    1c8c:	d008      	beq.n	1ca0 <usb_isr+0x180>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
    1c8e:	495e      	ldr	r1, [pc, #376]	; (1e08 <usb_isr+0x2e8>)
    1c90:	780a      	ldrb	r2, [r1, #0]
    1c92:	b12a      	cbz	r2, 1ca0 <usb_isr+0x180>
			if (--usb_reboot_timer == 0) {
    1c94:	3a01      	subs	r2, #1
    1c96:	b2d2      	uxtb	r2, r2
    1c98:	700a      	strb	r2, [r1, #0]
    1c9a:	2a00      	cmp	r2, #0
    1c9c:	f000 8217 	beq.w	20ce <usb_isr+0x5ae>
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
    1ca0:	b003      	add	sp, #12
    1ca2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    1ca6:	4959      	ldr	r1, [pc, #356]	; (1e0c <usb_isr+0x2ec>)
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
    1ca8:	f8c2 31bc 	str.w	r3, [r2, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    1cac:	6808      	ldr	r0, [r1, #0]
    1cae:	4203      	tst	r3, r0
    1cb0:	f040 81b1 	bne.w	2016 <usb_isr+0x4f6>
				endpoint0_notify_mask = 0;
				endpoint0_complete();
			}
			completestatus &= endpointN_notify_mask;
    1cb4:	4a50      	ldr	r2, [pc, #320]	; (1df8 <usb_isr+0x2d8>)
    1cb6:	6815      	ldr	r5, [r2, #0]
#if 1
			if (completestatus) {
    1cb8:	401d      	ands	r5, r3
    1cba:	d0ac      	beq.n	1c16 <usb_isr+0xf6>

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    1cbc:	0c2e      	lsrs	r6, r5, #16
    1cbe:	d00f      	beq.n	1ce0 <usb_isr+0x1c0>
    1cc0:	4f4a      	ldr	r7, [pc, #296]	; (1dec <usb_isr+0x2cc>)
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
    1cc2:	f04f 0901 	mov.w	r9, #1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
    1cc6:	fa96 f4a6 	rbit	r4, r6
    1cca:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    1cce:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					tx &= ~(1<<p);
    1cd2:	fa09 f404 	lsl.w	r4, r9, r4

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    1cd6:	3040      	adds	r0, #64	; 0x40
    1cd8:	f7ff feb6 	bl	1a48 <run_callbacks>
#if 1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    1cdc:	43a6      	bics	r6, r4
    1cde:	d1f2      	bne.n	1cc6 <usb_isr+0x1a6>
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
    1ce0:	b2ad      	uxth	r5, r5
				while(rx) {
    1ce2:	2d00      	cmp	r5, #0
    1ce4:	d097      	beq.n	1c16 <usb_isr+0xf6>
    1ce6:	4f41      	ldr	r7, [pc, #260]	; (1dec <usb_isr+0x2cc>)
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
					rx &= ~(1<<p);
    1ce8:	2601      	movs	r6, #1
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
    1cea:	fa95 f4a5 	rbit	r4, r5
    1cee:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2);
    1cf2:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					rx &= ~(1<<p);
    1cf6:	fa06 f404 	lsl.w	r4, r6, r4

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
    1cfa:	f7ff fea5 	bl	1a48 <run_callbacks>
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
    1cfe:	43a5      	bics	r5, r4
    1d00:	d1f3      	bne.n	1cea <usb_isr+0x1ca>
    1d02:	e788      	b.n	1c16 <usb_isr+0xf6>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
    1d04:	4a3f      	ldr	r2, [pc, #252]	; (1e04 <usb_isr+0x2e4>)
    1d06:	7013      	strb	r3, [r2, #0]
    1d08:	e7b9      	b.n	1c7e <usb_isr+0x15e>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1d0a:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    1d0e:	f000 80f5 	beq.w	1efc <usb_isr+0x3dc>
    1d12:	d922      	bls.n	1d5a <usb_isr+0x23a>
    1d14:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    1d18:	f000 80fe 	beq.w	1f18 <usb_isr+0x3f8>
    1d1c:	f640 1521 	movw	r5, #2337	; 0x921
    1d20:	42a9      	cmp	r1, r5
    1d22:	d103      	bne.n	1d2c <usb_isr+0x20c>
		endpoint0_receive(endpoint0_buffer, 7, 1);
		return;
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
    1d24:	0c11      	lsrs	r1, r2, #16
    1d26:	2908      	cmp	r1, #8
    1d28:	f240 8126 	bls.w	1f78 <usb_isr+0x458>
		}
		break;
#endif
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    1d2c:	f8c4 b1c0 	str.w	fp, [r4, #448]	; 0x1c0
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1d30:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1d34:	2b00      	cmp	r3, #0
    1d36:	f47f af09 	bne.w	1b4c <usb_isr+0x2c>
    1d3a:	e767      	b.n	1c0c <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1d3c:	2980      	cmp	r1, #128	; 0x80
    1d3e:	d1f5      	bne.n	1d2c <usb_isr+0x20c>
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    1d40:	4a33      	ldr	r2, [pc, #204]	; (1e10 <usb_isr+0x2f0>)
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
    1d42:	2102      	movs	r1, #2
    1d44:	4610      	mov	r0, r2
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    1d46:	7013      	strb	r3, [r2, #0]
		reply_buffer[1] = 0;
    1d48:	7053      	strb	r3, [r2, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
    1d4a:	f7ff fe99 	bl	1a80 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1d4e:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1d52:	2b00      	cmp	r3, #0
    1d54:	f47f aefa 	bne.w	1b4c <usb_isr+0x2c>
    1d58:	e758      	b.n	1c0c <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    1d5a:	f5a1 61d0 	sub.w	r1, r1, #1664	; 0x680
    1d5e:	2901      	cmp	r1, #1
    1d60:	d8e4      	bhi.n	1d2c <usb_isr+0x20c>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    1d62:	4b2c      	ldr	r3, [pc, #176]	; (1e14 <usb_isr+0x2f4>)
    1d64:	6859      	ldr	r1, [r3, #4]
    1d66:	2900      	cmp	r1, #0
    1d68:	d0e0      	beq.n	1d2c <usb_isr+0x20c>
    1d6a:	0c00      	lsrs	r0, r0, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    1d6c:	fa1f fe82 	uxth.w	lr, r2
    1d70:	e003      	b.n	1d7a <usb_isr+0x25a>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    1d72:	330c      	adds	r3, #12
    1d74:	6859      	ldr	r1, [r3, #4]
    1d76:	2900      	cmp	r1, #0
    1d78:	d0d8      	beq.n	1d2c <usb_isr+0x20c>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    1d7a:	881d      	ldrh	r5, [r3, #0]
    1d7c:	4285      	cmp	r5, r0
    1d7e:	d1f8      	bne.n	1d72 <usb_isr+0x252>
    1d80:	885d      	ldrh	r5, [r3, #2]
    1d82:	4575      	cmp	r5, lr
    1d84:	d1f5      	bne.n	1d72 <usb_isr+0x252>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
    1d86:	0a05      	lsrs	r5, r0, #8
    1d88:	2d03      	cmp	r5, #3
    1d8a:	f000 817b 	beq.w	2084 <usb_isr+0x564>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
    1d8e:	891b      	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    1d90:	0c12      	lsrs	r2, r2, #16
    1d92:	4293      	cmp	r3, r2
    1d94:	bf28      	it	cs
    1d96:	4613      	movcs	r3, r2

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
    1d98:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    1d9c:	f000 8163 	beq.w	2066 <usb_isr+0x546>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
    1da0:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    1da4:	f000 814c 	beq.w	2040 <usb_isr+0x520>
    1da8:	4d1b      	ldr	r5, [pc, #108]	; (1e18 <usb_isr+0x2f8>)
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
					usb_descriptor_buffer[1] = 7;
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    1daa:	461a      	mov	r2, r3
    1dac:	9301      	str	r3, [sp, #4]
    1dae:	4628      	mov	r0, r5
    1db0:	f004 fc32 	bl	6618 <memcpy>
    1db4:	9b01      	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    1db6:	f025 021f 	bic.w	r2, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    1dba:	441d      	add	r5, r3
	asm volatile("": : :"memory");
	asm("dsb");
    1dbc:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    1dc0:	4916      	ldr	r1, [pc, #88]	; (1e1c <usb_isr+0x2fc>)
    1dc2:	600a      	str	r2, [r1, #0]
		location += 32;
    1dc4:	3220      	adds	r2, #32
	} while (location < end_addr);
    1dc6:	4295      	cmp	r5, r2
    1dc8:	d8fa      	bhi.n	1dc0 <usb_isr+0x2a0>
	asm("dsb");
    1dca:	f3bf 8f4f 	dsb	sy
	asm("isb");
    1dce:	f3bf 8f6f 	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    1dd2:	4811      	ldr	r0, [pc, #68]	; (1e18 <usb_isr+0x2f8>)
    1dd4:	4619      	mov	r1, r3
    1dd6:	f7ff fe53 	bl	1a80 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1dda:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1dde:	2b00      	cmp	r3, #0
    1de0:	f47f aeb4 	bne.w	1b4c <usb_isr+0x2c>
    1de4:	e712      	b.n	1c0c <usb_isr+0xec>
    1de6:	bf00      	nop
    1de8:	402e0000 	.word	0x402e0000
    1dec:	20000000 	.word	0x20000000
    1df0:	402e01c0 	.word	0x402e01c0
    1df4:	20002780 	.word	0x20002780
    1df8:	200026f4 	.word	0x200026f4
    1dfc:	20002744 	.word	0x20002744
    1e00:	20002748 	.word	0x20002748
    1e04:	2000275d 	.word	0x2000275d
    1e08:	2000275e 	.word	0x2000275e
    1e0c:	200026f0 	.word	0x200026f0
    1e10:	200026f8 	.word	0x200026f8
    1e14:	20000f98 	.word	0x20000f98
    1e18:	20200000 	.word	0x20200000
    1e1c:	e000ef70 	.word	0xe000ef70
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e20:	4ab2      	ldr	r2, [pc, #712]	; (20ec <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1e22:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e24:	2501      	movs	r5, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1e26:	64fb      	str	r3, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1e28:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e2a:	6015      	str	r5, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1e2c:	6051      	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1e2e:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1e32:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1e36:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1e38:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
    1e3c:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    1e40:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1e44:	2b00      	cmp	r3, #0
    1e46:	d1fb      	bne.n	1e40 <usb_isr+0x320>

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    1e48:	0c03      	lsrs	r3, r0, #16
    1e4a:	065b      	lsls	r3, r3, #25
    1e4c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    1e50:	f8c6 3154 	str.w	r3, [r6, #340]	; 0x154
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1e54:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1e58:	2b00      	cmp	r3, #0
    1e5a:	f47f ae77 	bne.w	1b4c <usb_isr+0x2c>
    1e5e:	e6d5      	b.n	1c0c <usb_isr+0xec>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    1e60:	b292      	uxth	r2, r2
    1e62:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    1e66:	2b07      	cmp	r3, #7
    1e68:	f63f af60 	bhi.w	1d2c <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    1e6c:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    1e70:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1e74:	4a9e      	ldr	r2, [pc, #632]	; (20f0 <usb_isr+0x5d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1e76:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e7a:	f04f 0001 	mov.w	r0, #1
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    1e7e:	441a      	add	r2, r3
    1e80:	6813      	ldr	r3, [r2, #0]
    1e82:	bf14      	ite	ne
    1e84:	f423 3380 	bicne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    1e88:	f023 0301 	biceq.w	r3, r3, #1
    1e8c:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1e8e:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e90:	4b96      	ldr	r3, [pc, #600]	; (20ec <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1e92:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1e94:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1e96:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1e98:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1e9a:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1e9e:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1ea2:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1ea4:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    1ea8:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    1eac:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1eb0:	2b00      	cmp	r3, #0
    1eb2:	d1fb      	bne.n	1eac <usb_isr+0x38c>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1eb4:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1eb8:	2b00      	cmp	r3, #0
    1eba:	f47f ae47 	bne.w	1b4c <usb_isr+0x2c>
    1ebe:	e6a5      	b.n	1c0c <usb_isr+0xec>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
    1ec0:	b292      	uxth	r2, r2
    1ec2:	f002 017f 	and.w	r1, r2, #127	; 0x7f
		if (endpoint > 7) break;
    1ec6:	2907      	cmp	r1, #7
    1ec8:	f63f af30 	bhi.w	1d2c <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    1ecc:	0089      	lsls	r1, r1, #2
    1ece:	4888      	ldr	r0, [pc, #544]	; (20f0 <usb_isr+0x5d0>)
		reply_buffer[0] = 0;
    1ed0:	4d88      	ldr	r5, [pc, #544]	; (20f4 <usb_isr+0x5d4>)
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    1ed2:	4408      	add	r0, r1
    1ed4:	6801      	ldr	r1, [r0, #0]
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    1ed6:	0610      	lsls	r0, r2, #24
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
    1ed8:	702b      	strb	r3, [r5, #0]
		reply_buffer[1] = 0;
    1eda:	706b      	strb	r3, [r5, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    1edc:	f140 8097 	bpl.w	200e <usb_isr+0x4ee>
    1ee0:	03ca      	lsls	r2, r1, #15
    1ee2:	d501      	bpl.n	1ee8 <usb_isr+0x3c8>
			reply_buffer[0] = 1;
    1ee4:	2301      	movs	r3, #1
    1ee6:	702b      	strb	r3, [r5, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
    1ee8:	2102      	movs	r1, #2
    1eea:	4882      	ldr	r0, [pc, #520]	; (20f4 <usb_isr+0x5d4>)
    1eec:	f7ff fdc8 	bl	1a80 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1ef0:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1ef4:	2b00      	cmp	r3, #0
    1ef6:	f47f ae29 	bne.w	1b4c <usb_isr+0x2c>
    1efa:	e687      	b.n	1c0c <usb_isr+0xec>
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    1efc:	4a7e      	ldr	r2, [pc, #504]	; (20f8 <usb_isr+0x5d8>)
		endpoint0_transmit(reply_buffer, 1, 0);
    1efe:	2101      	movs	r1, #1
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    1f00:	4b7c      	ldr	r3, [pc, #496]	; (20f4 <usb_isr+0x5d4>)
    1f02:	7812      	ldrb	r2, [r2, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    1f04:	4618      	mov	r0, r3
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    1f06:	701a      	strb	r2, [r3, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    1f08:	f7ff fdba 	bl	1a80 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1f0c:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1f10:	2b00      	cmp	r3, #0
    1f12:	f47f ae1b 	bne.w	1b4c <usb_isr+0x2c>
    1f16:	e679      	b.n	1c0c <usb_isr+0xec>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    1f18:	f3c0 4007 	ubfx	r0, r0, #16, #8
    1f1c:	4a76      	ldr	r2, [pc, #472]	; (20f8 <usb_isr+0x5d8>)
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    1f1e:	4977      	ldr	r1, [pc, #476]	; (20fc <usb_isr+0x5dc>)
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    1f20:	f04f 15cc 	mov.w	r5, #13369548	; 0xcc00cc
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    1f24:	7010      	strb	r0, [r2, #0]
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    1f26:	4a76      	ldr	r2, [pc, #472]	; (2100 <usb_isr+0x5e0>)
    1f28:	9301      	str	r3, [sp, #4]
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    1f2a:	f8c6 51c8 	str.w	r5, [r6, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    1f2e:	f8c6 11cc 	str.w	r1, [r6, #460]	; 0x1cc
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    1f32:	f8c6 21d0 	str.w	r2, [r6, #464]	; 0x1d0
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
		#elif defined(SEREMU_INTERFACE)
		usb_seremu_configure();
    1f36:	f000 fab3 	bl	24a0 <usb_seremu_configure>
		#endif
		#if defined(CDC3_STATUS_INTERFACE) && defined(CDC3_DATA_INTERFACE)
		usb_serial3_configure();
		#endif
		#if defined(RAWHID_INTERFACE)
		usb_rawhid_configure();
    1f3a:	f000 fa19 	bl	2370 <usb_rawhid_configure>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1f3e:	4a6b      	ldr	r2, [pc, #428]	; (20ec <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1f40:	9b01      	ldr	r3, [sp, #4]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1f42:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1f44:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1f46:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1f48:	6051      	str	r1, [r2, #4]
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1f4a:	6010      	str	r0, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1f4c:	64fb      	str	r3, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1f4e:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1f52:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1f56:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1f58:	f441 3280 	orr.w	r2, r1, #65536	; 0x10000
    1f5c:	f8c6 21b0 	str.w	r2, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    1f60:	4a68      	ldr	r2, [pc, #416]	; (2104 <usb_isr+0x5e4>)
    1f62:	6013      	str	r3, [r2, #0]
	while (USB1_ENDPTPRIME) ;
    1f64:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1f68:	2b00      	cmp	r3, #0
    1f6a:	d1fb      	bne.n	1f64 <usb_isr+0x444>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1f6c:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1f70:	2b00      	cmp	r3, #0
    1f72:	f47f adeb 	bne.w	1b4c <usb_isr+0x2c>
    1f76:	e649      	b.n	1c0c <usb_isr+0xec>
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    1f78:	f8df e194 	ldr.w	lr, [pc, #404]	; 2110 <usb_isr+0x5f0>
			endpoint0_buffer[0] = 0xE9;
    1f7c:	f04f 0ce9 	mov.w	ip, #233	; 0xe9
    1f80:	4d61      	ldr	r5, [pc, #388]	; (2108 <usb_isr+0x5e8>)
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    1f82:	e88e 0005 	stmia.w	lr, {r0, r2}
			endpoint0_buffer[0] = 0xE9;
    1f86:	f885 c000 	strb.w	ip, [r5]
}

static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
    1f8a:	b301      	cbz	r1, 1fce <usb_isr+0x4ae>
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1f8c:	0409      	lsls	r1, r1, #16
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1f8e:	4a5f      	ldr	r2, [pc, #380]	; (210c <usb_isr+0x5ec>)
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
    1f90:	60fb      	str	r3, [r7, #12]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1f92:	2001      	movs	r0, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1f94:	f041 0380 	orr.w	r3, r1, #128	; 0x80
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    1f98:	60ba      	str	r2, [r7, #8]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1f9a:	6010      	str	r0, [r2, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1f9c:	f505 5e00 	add.w	lr, r5, #8192	; 0x2000
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1fa0:	6053      	str	r3, [r2, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1fa2:	f505 5080 	add.w	r0, r5, #4096	; 0x1000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    1fa6:	f8d6 31b0 	ldr.w	r3, [r6, #432]	; 0x1b0
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1faa:	f505 5140 	add.w	r1, r5, #12288	; 0x3000
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    1fae:	6095      	str	r5, [r2, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1fb0:	f505 4580 	add.w	r5, r5, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    1fb4:	f043 0301 	orr.w	r3, r3, #1
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1fb8:	60d0      	str	r0, [r2, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1fba:	f8c2 e010 	str.w	lr, [r2, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    1fbe:	6151      	str	r1, [r2, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1fc0:	6195      	str	r5, [r2, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    1fc2:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    1fc6:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1fca:	2b00      	cmp	r3, #0
    1fcc:	d1fb      	bne.n	1fc6 <usb_isr+0x4a6>
	}
	endpoint0_transfer_ack.next = 1;
    1fce:	4b47      	ldr	r3, [pc, #284]	; (20ec <usb_isr+0x5cc>)
    1fd0:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1fd2:	f248 0280 	movw	r2, #32896	; 0x8080
	endpoint0_transfer_ack.pointer0 = 0;
    1fd6:	2100      	movs	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1fd8:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    1fda:	f44f 3080 	mov.w	r0, #65536	; 0x10000
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1fde:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1fe0:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1fe2:	64f9      	str	r1, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1fe4:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1fe8:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1fec:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1fee:	ea42 0300 	orr.w	r3, r2, r0
    1ff2:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    1ff6:	f8c9 0000 	str.w	r0, [r9]
	while (USB1_ENDPTPRIME) ;
    1ffa:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1ffe:	2b00      	cmp	r3, #0
    2000:	d1fb      	bne.n	1ffa <usb_isr+0x4da>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    2002:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    2006:	2b00      	cmp	r3, #0
    2008:	f47f ada0 	bne.w	1b4c <usb_isr+0x2c>
    200c:	e5fe      	b.n	1c0c <usb_isr+0xec>
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    200e:	07cb      	lsls	r3, r1, #31
    2010:	f57f af6a 	bpl.w	1ee8 <usb_isr+0x3c8>
    2014:	e766      	b.n	1ee4 <usb_isr+0x3c4>

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    2016:	483e      	ldr	r0, [pc, #248]	; (2110 <usb_isr+0x5f0>)
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    2018:	2600      	movs	r6, #0
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    201a:	4c3e      	ldr	r4, [pc, #248]	; (2114 <usb_isr+0x5f4>)

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    201c:	6805      	ldr	r5, [r0, #0]
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    201e:	600e      	str	r6, [r1, #0]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    2020:	42a5      	cmp	r5, r4

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    2022:	6840      	ldr	r0, [r0, #4]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    2024:	f47f ae46 	bne.w	1cb4 <usb_isr+0x194>
    2028:	493b      	ldr	r1, [pc, #236]	; (2118 <usb_isr+0x5f8>)
    202a:	4288      	cmp	r0, r1
    202c:	f47f ae42 	bne.w	1cb4 <usb_isr+0x194>
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    2030:	4935      	ldr	r1, [pc, #212]	; (2108 <usb_isr+0x5e8>)
    2032:	7808      	ldrb	r0, [r1, #0]
    2034:	28a9      	cmp	r0, #169	; 0xa9
    2036:	d02b      	beq.n	2090 <usb_isr+0x570>
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
		} else {
			// any other feature report means Arduino Serial Monitor is open
			usb_seremu_online = 1;
    2038:	4a38      	ldr	r2, [pc, #224]	; (211c <usb_isr+0x5fc>)
    203a:	2101      	movs	r1, #1
    203c:	7011      	strb	r1, [r2, #0]
    203e:	e639      	b.n	1cb4 <usb_isr+0x194>
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    2040:	4837      	ldr	r0, [pc, #220]	; (2120 <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    2042:	461a      	mov	r2, r3
    2044:	4d37      	ldr	r5, [pc, #220]	; (2124 <usb_isr+0x604>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    2046:	f890 e000 	ldrb.w	lr, [r0]
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
    204a:	4937      	ldr	r1, [pc, #220]	; (2128 <usb_isr+0x608>)
    204c:	4837      	ldr	r0, [pc, #220]	; (212c <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
    204e:	9301      	str	r3, [sp, #4]
    2050:	f1be 0f00 	cmp.w	lr, #0
    2054:	bf08      	it	eq
    2056:	4601      	moveq	r1, r0
    2058:	4628      	mov	r0, r5
    205a:	f004 fadd 	bl	6618 <memcpy>
					usb_descriptor_buffer[1] = 7;
    205e:	2207      	movs	r2, #7
    2060:	9b01      	ldr	r3, [sp, #4]
    2062:	706a      	strb	r2, [r5, #1]
    2064:	e6a7      	b.n	1db6 <usb_isr+0x296>

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
    2066:	482e      	ldr	r0, [pc, #184]	; (2120 <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    2068:	461a      	mov	r2, r3
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    206a:	4930      	ldr	r1, [pc, #192]	; (212c <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_480;
    206c:	7805      	ldrb	r5, [r0, #0]
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    206e:	482e      	ldr	r0, [pc, #184]	; (2128 <usb_isr+0x608>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
    2070:	9301      	str	r3, [sp, #4]
    2072:	2d00      	cmp	r5, #0
    2074:	bf08      	it	eq
    2076:	4601      	moveq	r1, r0
    2078:	482a      	ldr	r0, [pc, #168]	; (2124 <usb_isr+0x604>)
    207a:	f004 facd 	bl	6618 <memcpy>
    207e:	4d29      	ldr	r5, [pc, #164]	; (2124 <usb_isr+0x604>)
    2080:	9b01      	ldr	r3, [sp, #4]
    2082:	e698      	b.n	1db6 <usb_isr+0x296>
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    2084:	0c12      	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
    2086:	780b      	ldrb	r3, [r1, #0]
    2088:	4293      	cmp	r3, r2
    208a:	bf28      	it	cs
    208c:	4613      	movcs	r3, r2
    208e:	e687      	b.n	1da0 <usb_isr+0x280>
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    2090:	7848      	ldrb	r0, [r1, #1]
    2092:	2845      	cmp	r0, #69	; 0x45
    2094:	d1d0      	bne.n	2038 <usb_isr+0x518>
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
    2096:	7888      	ldrb	r0, [r1, #2]
    2098:	28c2      	cmp	r0, #194	; 0xc2
    209a:	d1cd      	bne.n	2038 <usb_isr+0x518>
    209c:	78c9      	ldrb	r1, [r1, #3]
    209e:	296b      	cmp	r1, #107	; 0x6b
    20a0:	d1ca      	bne.n	2038 <usb_isr+0x518>
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
    20a2:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    20a4:	4822      	ldr	r0, [pc, #136]	; (2130 <usb_isr+0x610>)
    20a6:	7801      	ldrb	r1, [r0, #0]
    20a8:	f041 0104 	orr.w	r1, r1, #4
    20ac:	7001      	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    20ae:	f8d2 1148 	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    20b2:	0608      	lsls	r0, r1, #24
    20b4:	d406      	bmi.n	20c4 <usb_isr+0x5a4>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    20b6:	f041 0180 	orr.w	r1, r1, #128	; 0x80
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    20ba:	2080      	movs	r0, #128	; 0x80
    20bc:	f8c2 0144 	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    20c0:	f8c2 1148 	str.w	r1, [r2, #328]	; 0x148
	}
	__enable_irq();
    20c4:	b662      	cpsie	i
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    20c6:	4a1b      	ldr	r2, [pc, #108]	; (2134 <usb_isr+0x614>)
    20c8:	2150      	movs	r1, #80	; 0x50
    20ca:	7011      	strb	r1, [r2, #0]
    20cc:	e5f2      	b.n	1cb4 <usb_isr+0x194>
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
    20ce:	4918      	ldr	r1, [pc, #96]	; (2130 <usb_isr+0x610>)
    20d0:	780a      	ldrb	r2, [r1, #0]
    20d2:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    20d6:	700a      	strb	r2, [r1, #0]
	if (sof_usage == 0) {
    20d8:	b92a      	cbnz	r2, 20e6 <usb_isr+0x5c6>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    20da:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    20de:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    20e2:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
			if (--usb_reboot_timer == 0) {
				usb_stop_sof_interrupts(NUM_INTERFACE);
				_reboot_Teensyduino_();
    20e6:	f008 f8a7 	bl	a238 <___reboot_Teensyduino__veneer>
    20ea:	bf00      	nop
    20ec:	20002780 	.word	0x20002780
    20f0:	402e01c0 	.word	0x402e01c0
    20f4:	200026f8 	.word	0x200026f8
    20f8:	2000275c 	.word	0x2000275c
    20fc:	00cc0002 	.word	0x00cc0002
    2100:	000200cc 	.word	0x000200cc
    2104:	200026f0 	.word	0x200026f0
    2108:	200026e8 	.word	0x200026e8
    210c:	20002760 	.word	0x20002760
    2110:	20002660 	.word	0x20002660
    2114:	03000921 	.word	0x03000921
    2118:	00040001 	.word	0x00040001
    211c:	2000275f 	.word	0x2000275f
    2120:	2000275d 	.word	0x2000275d
    2124:	20200000 	.word	0x20200000
    2128:	600020e4 	.word	0x600020e4
    212c:	60002130 	.word	0x60002130
    2130:	20002757 	.word	0x20002757
    2134:	2000275e 	.word	0x2000275e

00002138 <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    2138:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    213a:	f1a0 0202 	sub.w	r2, r0, #2
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    213e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    2142:	bf14      	ite	ne
    2144:	2700      	movne	r7, #0
    2146:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    214a:	2a02      	cmp	r2, #2
    214c:	d901      	bls.n	2152 <usb_config_rx+0x1a>
    214e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    2152:	ea4f 19c0 	mov.w	r9, r0, lsl #7
    2156:	f8df a040 	ldr.w	sl, [pc, #64]	; 2198 <usb_config_rx+0x60>
    215a:	460d      	mov	r5, r1
    215c:	4604      	mov	r4, r0
    215e:	eb0a 0609 	add.w	r6, sl, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    2162:	2100      	movs	r1, #0
    2164:	2240      	movs	r2, #64	; 0x40
    2166:	4698      	mov	r8, r3
    2168:	4630      	mov	r0, r6
    216a:	f004 fb53 	bl	6814 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    216e:	2001      	movs	r0, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    2170:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
    2174:	f84a 1009 	str.w	r1, [sl, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    2178:	f8c6 8038 	str.w	r8, [r6, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    217c:	60b0      	str	r0, [r6, #8]
void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
    217e:	f1b8 0f00 	cmp.w	r8, #0
    2182:	d0e4      	beq.n	214e <usb_config_rx+0x16>
    2184:	4b03      	ldr	r3, [pc, #12]	; (2194 <usb_config_rx+0x5c>)
    2186:	40a0      	lsls	r0, r4
    2188:	681c      	ldr	r4, [r3, #0]
    218a:	4320      	orrs	r0, r4
    218c:	6018      	str	r0, [r3, #0]
    218e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2192:	bf00      	nop
    2194:	200026f4 	.word	0x200026f4
    2198:	20000000 	.word	0x20000000

0000219c <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    219c:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    219e:	f1a0 0202 	sub.w	r2, r0, #2
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    21a2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    21a6:	bf14      	ite	ne
    21a8:	2700      	movne	r7, #0
    21aa:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    21ae:	2a02      	cmp	r2, #2
    21b0:	d901      	bls.n	21b6 <usb_config_tx+0x1a>
    21b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    21b6:	2240      	movs	r2, #64	; 0x40

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    21b8:	01c5      	lsls	r5, r0, #7
    21ba:	f8df 9044 	ldr.w	r9, [pc, #68]	; 2200 <usb_config_tx+0x64>
    21be:	4688      	mov	r8, r1
    21c0:	4415      	add	r5, r2
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    21c2:	2100      	movs	r1, #0
    21c4:	4604      	mov	r4, r0
    21c6:	461e      	mov	r6, r3

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    21c8:	eb09 0a05 	add.w	sl, r9, r5
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    21cc:	4650      	mov	r0, sl
    21ce:	f004 fb21 	bl	6814 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    21d2:	2201      	movs	r2, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    21d4:	ea47 4108 	orr.w	r1, r7, r8, lsl #16
    21d8:	f849 1005 	str.w	r1, [r9, r5]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    21dc:	f8ca 6038 	str.w	r6, [sl, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    21e0:	f8ca 2008 	str.w	r2, [sl, #8]
void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    21e4:	2e00      	cmp	r6, #0
    21e6:	d0e4      	beq.n	21b2 <usb_config_tx+0x16>
    21e8:	f104 0010 	add.w	r0, r4, #16
    21ec:	4b03      	ldr	r3, [pc, #12]	; (21fc <usb_config_tx+0x60>)
    21ee:	4082      	lsls	r2, r0
    21f0:	6818      	ldr	r0, [r3, #0]
    21f2:	4302      	orrs	r2, r0
    21f4:	601a      	str	r2, [r3, #0]
    21f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    21fa:	bf00      	nop
    21fc:	200026f4 	.word	0x200026f4
    2200:	20000000 	.word	0x20000000

00002204 <usb_prepare_transfer>:


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    2204:	0412      	lsls	r2, r2, #16
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
    2206:	6081      	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
	transfer->pointer2 = addr + 8192;
	transfer->pointer3 = addr + 12288;
	transfer->pointer4 = addr + 16384;
	transfer->callback_param = param;
    2208:	61c3      	str	r3, [r0, #28]


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    220a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
    220e:	b4f0      	push	{r4, r5, r6, r7}
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    2210:	6042      	str	r2, [r0, #4]



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    2212:	2701      	movs	r7, #1
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    2214:	f501 5680 	add.w	r6, r1, #4096	; 0x1000
	transfer->pointer2 = addr + 8192;
    2218:	f501 5500 	add.w	r5, r1, #8192	; 0x2000
	transfer->pointer3 = addr + 12288;
    221c:	f501 5440 	add.w	r4, r1, #12288	; 0x3000
	transfer->pointer4 = addr + 16384;
    2220:	f501 4280 	add.w	r2, r1, #16384	; 0x4000



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    2224:	6007      	str	r7, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    2226:	60c6      	str	r6, [r0, #12]
	transfer->pointer2 = addr + 8192;
    2228:	6105      	str	r5, [r0, #16]
	transfer->pointer3 = addr + 12288;
    222a:	6144      	str	r4, [r0, #20]
	transfer->pointer4 = addr + 16384;
    222c:	6182      	str	r2, [r0, #24]
	transfer->callback_param = param;
}
    222e:	bcf0      	pop	{r4, r5, r6, r7}
    2230:	4770      	bx	lr
    2232:	bf00      	nop

00002234 <usb_transmit>:
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    2234:	1e83      	subs	r3, r0, #2
    2236:	2b02      	cmp	r3, #2
    2238:	d900      	bls.n	223c <usb_transmit+0x8>
    223a:	4770      	bx	lr
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    223c:	4b06      	ldr	r3, [pc, #24]	; (2258 <usb_transmit+0x24>)
    223e:	460a      	mov	r2, r1
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
    2240:	b430      	push	{r4, r5}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    2242:	f100 0410 	add.w	r4, r0, #16
    2246:	2501      	movs	r5, #1
    2248:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    224c:	fa05 f104 	lsl.w	r1, r5, r4
    2250:	3040      	adds	r0, #64	; 0x40
}
    2252:	bc30      	pop	{r4, r5}
void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    2254:	f7ff bbb0 	b.w	19b8 <schedule_transfer>
    2258:	20000000 	.word	0x20000000

0000225c <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    225c:	1e83      	subs	r3, r0, #2
    225e:	2b02      	cmp	r3, #2
    2260:	d900      	bls.n	2264 <usb_receive+0x8>
    2262:	4770      	bx	lr
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
    2264:	b410      	push	{r4}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    2266:	4b05      	ldr	r3, [pc, #20]	; (227c <usb_receive+0x20>)
    2268:	2401      	movs	r4, #1
    226a:	460a      	mov	r2, r1
    226c:	fa04 f100 	lsl.w	r1, r4, r0
    2270:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
}
    2274:	f85d 4b04 	ldr.w	r4, [sp], #4
void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    2278:	f7ff bb9e 	b.w	19b8 <schedule_transfer>
    227c:	20000000 	.word	0x20000000

00002280 <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    2280:	6840      	ldr	r0, [r0, #4]
#endif
}
    2282:	4770      	bx	lr

00002284 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    2284:	4a12      	ldr	r2, [pc, #72]	; (22d0 <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    2286:	4b13      	ldr	r3, [pc, #76]	; (22d4 <usb_init_serialnumber+0x50>)
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    2288:	f8d2 0220 	ldr.w	r0, [r2, #544]	; 0x220
    228c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    2290:	4298      	cmp	r0, r3
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    2292:	b510      	push	{r4, lr}
    2294:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    2296:	d802      	bhi.n	229e <usb_init_serialnumber+0x1a>
    2298:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    229c:	0040      	lsls	r0, r0, #1
    229e:	4c0e      	ldr	r4, [pc, #56]	; (22d8 <usb_init_serialnumber+0x54>)
	ultoa(num, buf, 10);
    22a0:	a901      	add	r1, sp, #4
    22a2:	220a      	movs	r2, #10
    22a4:	f7ff f868 	bl	1378 <ultoa>
    22a8:	a901      	add	r1, sp, #4
	for (i=0; i<10; i++) {
    22aa:	2300      	movs	r3, #0
    22ac:	4620      	mov	r0, r4
		char c = buf[i];
    22ae:	f811 2b01 	ldrb.w	r2, [r1], #1
    22b2:	3301      	adds	r3, #1
		if (!c) break;
    22b4:	b13a      	cbz	r2, 22c6 <usb_init_serialnumber+0x42>

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    22b6:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    22b8:	f820 2f02 	strh.w	r2, [r0, #2]!

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    22bc:	d1f7      	bne.n	22ae <usb_init_serialnumber+0x2a>
    22be:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    22c0:	7023      	strb	r3, [r4, #0]
}
    22c2:	b004      	add	sp, #16
    22c4:	bd10      	pop	{r4, pc}
    22c6:	005b      	lsls	r3, r3, #1
    22c8:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    22ca:	7023      	strb	r3, [r4, #0]
}
    22cc:	b004      	add	sp, #16
    22ce:	bd10      	pop	{r4, pc}
    22d0:	401f4400 	.word	0x401f4400
    22d4:	0098967f 	.word	0x0098967f
    22d8:	20001e30 	.word	0x20001e30

000022dc <rx_event>:
static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    22dc:	4a0a      	ldr	r2, [pc, #40]	; (2308 <rx_event+0x2c>)
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
    22de:	b410      	push	{r4}
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    22e0:	7813      	ldrb	r3, [r2, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
    22e2:	69c4      	ldr	r4, [r0, #28]
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    22e4:	3301      	adds	r3, #1
    22e6:	2b04      	cmp	r3, #4
    22e8:	d907      	bls.n	22fa <rx_event+0x1e>
    22ea:	2100      	movs	r1, #0
	rx_list[head] = i;
    22ec:	4807      	ldr	r0, [pc, #28]	; (230c <rx_event+0x30>)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    22ee:	460b      	mov	r3, r1
	rx_list[head] = i;
	rx_head = head;
    22f0:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    22f2:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    22f4:	f85d 4b04 	ldr.w	r4, [sp], #4
    22f8:	4770      	bx	lr
    22fa:	b2d9      	uxtb	r1, r3
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    22fc:	4803      	ldr	r0, [pc, #12]	; (230c <rx_event+0x30>)
	rx_head = head;
    22fe:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    2300:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    2302:	f85d 4b04 	ldr.w	r4, [sp], #4
    2306:	4770      	bx	lr
    2308:	20002753 	.word	0x20002753
    230c:	20002714 	.word	0x20002714

00002310 <rx_queue_transfer>:
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
    2310:	4912      	ldr	r1, [pc, #72]	; (235c <rx_queue_transfer+0x4c>)
    2312:	eb01 1180 	add.w	r1, r1, r0, lsl #6
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    2316:	b538      	push	{r3, r4, r5, lr}
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    2318:	f021 021f 	bic.w	r2, r1, #31
    231c:	4603      	mov	r3, r0
	uint32_t end_addr = (uint32_t)addr + size;
    231e:	f101 0540 	add.w	r5, r1, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    2322:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    2326:	4c0e      	ldr	r4, [pc, #56]	; (2360 <rx_queue_transfer+0x50>)
    2328:	6022      	str	r2, [r4, #0]
		location += 32;
    232a:	3220      	adds	r2, #32
	} while (location < end_addr);
    232c:	4295      	cmp	r5, r2
    232e:	d8fb      	bhi.n	2328 <rx_queue_transfer+0x18>
	asm("dsb");
    2330:	f3bf 8f4f 	dsb	sy
	asm("isb");
    2334:	f3bf 8f6f 	isb	sy
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    2338:	4c0a      	ldr	r4, [pc, #40]	; (2364 <rx_queue_transfer+0x54>)
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    233a:	f44f 3500 	mov.w	r5, #131072	; 0x20000
    233e:	4a0a      	ldr	r2, [pc, #40]	; (2368 <rx_queue_transfer+0x58>)
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    2340:	eb04 1443 	add.w	r4, r4, r3, lsl #5
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    2344:	6015      	str	r5, [r2, #0]
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    2346:	2240      	movs	r2, #64	; 0x40
    2348:	4620      	mov	r0, r4
    234a:	f7ff ff5b 	bl	2204 <usb_prepare_transfer>
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
    234e:	4621      	mov	r1, r4
    2350:	2004      	movs	r0, #4
    2352:	f7ff ff83 	bl	225c <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    2356:	4b05      	ldr	r3, [pc, #20]	; (236c <rx_queue_transfer+0x5c>)
    2358:	601d      	str	r5, [r3, #0]
    235a:	bd38      	pop	{r3, r4, r5, pc}
    235c:	20200060 	.word	0x20200060
    2360:	e000ef5c 	.word	0xe000ef5c
    2364:	200022e0 	.word	0x200022e0
    2368:	e000e18c 	.word	0xe000e18c
    236c:	e000e10c 	.word	0xe000e10c

00002370 <usb_rawhid_configure>:


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    2370:	2100      	movs	r1, #0
    2372:	4816      	ldr	r0, [pc, #88]	; (23cc <usb_rawhid_configure+0x5c>)
static void rx_event(transfer_t *t);
extern volatile uint8_t usb_configuration;


void usb_rawhid_configure(void)
{
    2374:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    2376:	2580      	movs	r5, #128	; 0x80
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    2378:	460c      	mov	r4, r1
	rx_head = 0;
    237a:	4f15      	ldr	r7, [pc, #84]	; (23d0 <usb_rawhid_configure+0x60>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    237c:	462a      	mov	r2, r5
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    237e:	4e15      	ldr	r6, [pc, #84]	; (23d4 <usb_rawhid_configure+0x64>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    2380:	f004 fa48 	bl	6814 <memset>
	memset(rx_transfer, 0, sizeof(rx_transfer));
    2384:	462a      	mov	r2, r5
    2386:	4621      	mov	r1, r4
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
    2388:	4d13      	ldr	r5, [pc, #76]	; (23d8 <usb_rawhid_configure+0x68>)

void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
    238a:	4814      	ldr	r0, [pc, #80]	; (23dc <usb_rawhid_configure+0x6c>)
    238c:	f004 fa42 	bl	6814 <memset>
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    2390:	4623      	mov	r3, r4
    2392:	4622      	mov	r2, r4
    2394:	2140      	movs	r1, #64	; 0x40
    2396:	2003      	movs	r0, #3
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
	rx_head = 0;
    2398:	703c      	strb	r4, [r7, #0]
void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    239a:	7034      	strb	r4, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
    239c:	702c      	strb	r4, [r5, #0]
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    239e:	f7ff fefd 	bl	219c <usb_config_tx>
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
    23a2:	4622      	mov	r2, r4
    23a4:	4b0e      	ldr	r3, [pc, #56]	; (23e0 <usb_rawhid_configure+0x70>)
    23a6:	2140      	movs	r1, #64	; 0x40
    23a8:	2004      	movs	r0, #4
    23aa:	f7ff fec5 	bl	2138 <usb_config_rx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    23ae:	4620      	mov	r0, r4
    23b0:	f7ff ffae 	bl	2310 <rx_queue_transfer>
    23b4:	2001      	movs	r0, #1
    23b6:	f7ff ffab 	bl	2310 <rx_queue_transfer>
    23ba:	2002      	movs	r0, #2
    23bc:	f7ff ffa8 	bl	2310 <rx_queue_transfer>
    23c0:	2003      	movs	r0, #3
}
    23c2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    23c6:	f7ff bfa3 	b.w	2310 <rx_queue_transfer>
    23ca:	bf00      	nop
    23cc:	20002460 	.word	0x20002460
    23d0:	20002753 	.word	0x20002753
    23d4:	20002759 	.word	0x20002759
    23d8:	20002755 	.word	0x20002755
    23dc:	200022e0 	.word	0x200022e0
    23e0:	000022dd 	.word	0x000022dd

000023e4 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    23e4:	b570      	push	{r4, r5, r6, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    23e6:	0141      	lsls	r1, r0, #5
    23e8:	4c12      	ldr	r4, [pc, #72]	; (2434 <rx_queue_transfer+0x50>)
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    23ea:	4d13      	ldr	r5, [pc, #76]	; (2438 <rx_queue_transfer+0x54>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    23ec:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    23ee:	440c      	add	r4, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    23f0:	f44f 3600 	mov.w	r6, #131072	; 0x20000
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    23f4:	440d      	add	r5, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    23f6:	4811      	ldr	r0, [pc, #68]	; (243c <rx_queue_transfer+0x58>)
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    23f8:	4621      	mov	r1, r4
    23fa:	2220      	movs	r2, #32
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    23fc:	6006      	str	r6, [r0, #0]
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    23fe:	4628      	mov	r0, r5
    2400:	f7ff ff00 	bl	2204 <usb_prepare_transfer>
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    2404:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    2408:	f104 0120 	add.w	r1, r4, #32
	asm volatile("": : :"memory");
	asm("dsb");
    240c:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    2410:	4a0b      	ldr	r2, [pc, #44]	; (2440 <rx_queue_transfer+0x5c>)
    2412:	6013      	str	r3, [r2, #0]
		location += 32;
    2414:	3320      	adds	r3, #32
	} while (location < end_addr);
    2416:	4299      	cmp	r1, r3
    2418:	d8fb      	bhi.n	2412 <rx_queue_transfer+0x2e>
	asm("dsb");
    241a:	f3bf 8f4f 	dsb	sy
	asm("isb");
    241e:	f3bf 8f6f 	isb	sy
	arm_dcache_delete(buffer, SEREMU_RX_SIZE);
	usb_receive(SEREMU_RX_ENDPOINT, rx_transfer + i);
    2422:	2002      	movs	r0, #2
    2424:	4629      	mov	r1, r5
    2426:	f7ff ff19 	bl	225c <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    242a:	4b06      	ldr	r3, [pc, #24]	; (2444 <rx_queue_transfer+0x60>)
    242c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    2430:	601a      	str	r2, [r3, #0]
    2432:	bd70      	pop	{r4, r5, r6, pc}
    2434:	20200260 	.word	0x20200260
    2438:	20002360 	.word	0x20002360
    243c:	e000e18c 	.word	0xe000e18c
    2440:	e000ef5c 	.word	0xe000ef5c
    2444:	e000e10c 	.word	0xe000e10c

00002448 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
    2448:	6843      	ldr	r3, [r0, #4]
	int i = t->callback_param;
    244a:	69c0      	ldr	r0, [r0, #28]
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    244c:	f3c3 430e 	ubfx	r3, r3, #16, #15
    2450:	b10b      	cbz	r3, 2456 <rx_event+0xe>
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
    2452:	f7ff bfc7 	b.w	23e4 <rx_queue_transfer>
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    2456:	490d      	ldr	r1, [pc, #52]	; (248c <rx_event+0x44>)
    2458:	0142      	lsls	r2, r0, #5
    245a:	5c8a      	ldrb	r2, [r1, r2]
    245c:	2a00      	cmp	r2, #0
    245e:	d0f8      	beq.n	2452 <rx_event+0xa>
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
    2460:	490b      	ldr	r1, [pc, #44]	; (2490 <rx_event+0x48>)
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
    2462:	b410      	push	{r4}
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    2464:	4c0b      	ldr	r4, [pc, #44]	; (2494 <rx_event+0x4c>)
		rx_index[i] = 0;
    2466:	f821 3010 	strh.w	r3, [r1, r0, lsl #1]
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    246a:	7822      	ldrb	r2, [r4, #0]
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
    246c:	490a      	ldr	r1, [pc, #40]	; (2498 <rx_event+0x50>)
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    246e:	3201      	adds	r2, #1
    2470:	2a08      	cmp	r2, #8
    2472:	bf94      	ite	ls
    2474:	b2d3      	uxtbls	r3, r2
    2476:	461a      	movhi	r2, r3
		rx_list[head] = i;
		rx_head = head;
    2478:	7023      	strb	r3, [r4, #0]
		rx_available += len;
    247a:	680b      	ldr	r3, [r1, #0]
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    247c:	4c07      	ldr	r4, [pc, #28]	; (249c <rx_event+0x54>)
		rx_head = head;
		rx_available += len;
    247e:	3320      	adds	r3, #32
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    2480:	54a0      	strb	r0, [r4, r2]
		rx_head = head;
		rx_available += len;
    2482:	600b      	str	r3, [r1, #0]
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
	}
}
    2484:	f85d 4b04 	ldr.w	r4, [sp], #4
    2488:	4770      	bx	lr
    248a:	bf00      	nop
    248c:	20200260 	.word	0x20200260
    2490:	20002704 	.word	0x20002704
    2494:	20002754 	.word	0x20002754
    2498:	20002700 	.word	0x20002700
    249c:	2000271c 	.word	0x2000271c

000024a0 <usb_seremu_configure>:


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    24a0:	2100      	movs	r1, #0
    24a2:	f44f 72c0 	mov.w	r2, #384	; 0x180
    24a6:	481f      	ldr	r0, [pc, #124]	; (2524 <usb_seremu_configure+0x84>)
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_seremu_configure(void)
{
    24a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    24aa:	460d      	mov	r5, r1
    24ac:	4c1e      	ldr	r4, [pc, #120]	; (2528 <usb_seremu_configure+0x88>)


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    24ae:	f004 f9b1 	bl	6814 <memset>
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    24b2:	4e1e      	ldr	r6, [pc, #120]	; (252c <usb_seremu_configure+0x8c>)
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    24b4:	4b1e      	ldr	r3, [pc, #120]	; (2530 <usb_seremu_configure+0x90>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    24b6:	4629      	mov	r1, r5
    24b8:	f44f 7280 	mov.w	r2, #256	; 0x100
    24bc:	481d      	ldr	r0, [pc, #116]	; (2534 <usb_seremu_configure+0x94>)

void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    24be:	7025      	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    24c0:	462c      	mov	r4, r5
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    24c2:	801d      	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    24c4:	f004 f9a6 	bl	6814 <memset>
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    24c8:	7035      	strb	r5, [r6, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    24ca:	462a      	mov	r2, r5
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    24cc:	4e1a      	ldr	r6, [pc, #104]	; (2538 <usb_seremu_configure+0x98>)
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    24ce:	2120      	movs	r1, #32
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    24d0:	4b1a      	ldr	r3, [pc, #104]	; (253c <usb_seremu_configure+0x9c>)
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    24d2:	2002      	movs	r0, #2
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    24d4:	4f1a      	ldr	r7, [pc, #104]	; (2540 <usb_seremu_configure+0xa0>)
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    24d6:	701d      	strb	r5, [r3, #0]
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    24d8:	6035      	str	r5, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    24da:	4b1a      	ldr	r3, [pc, #104]	; (2544 <usb_seremu_configure+0xa4>)
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    24dc:	6075      	str	r5, [r6, #4]
    24de:	60b5      	str	r5, [r6, #8]
    24e0:	60f5      	str	r5, [r6, #12]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    24e2:	603d      	str	r5, [r7, #0]
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    24e4:	f7ff fe28 	bl	2138 <usb_config_rx>
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
    24e8:	462b      	mov	r3, r5
    24ea:	462a      	mov	r2, r5
    24ec:	2140      	movs	r1, #64	; 0x40
    24ee:	2002      	movs	r0, #2
    24f0:	f7ff fe54 	bl	219c <usb_config_tx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    24f4:	4620      	mov	r0, r4
    24f6:	3401      	adds	r4, #1
    24f8:	f7ff ff74 	bl	23e4 <rx_queue_transfer>
    24fc:	2c08      	cmp	r4, #8
    24fe:	d1f9      	bne.n	24f4 <usb_seremu_configure+0x54>
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
	USB1_GPTIMER0CTRL = 0;
    2500:	4b11      	ldr	r3, [pc, #68]	; (2548 <usb_seremu_configure+0xa8>)
	USB1_GPTIMER0LD = microseconds - 1;
    2502:	224a      	movs	r2, #74	; 0x4a
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    2504:	4811      	ldr	r0, [pc, #68]	; (254c <usb_seremu_configure+0xac>)
	USB1_GPTIMER0CTRL = 0;
    2506:	2100      	movs	r1, #0
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    2508:	4c11      	ldr	r4, [pc, #68]	; (2550 <usb_seremu_configure+0xb0>)
    250a:	6004      	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    250c:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    2510:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    2514:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    2518:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    251c:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    2520:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2522:	bf00      	nop
    2524:	200024e0 	.word	0x200024e0
    2528:	2000275a 	.word	0x2000275a
    252c:	20002754 	.word	0x20002754
    2530:	2000274c 	.word	0x2000274c
    2534:	20002360 	.word	0x20002360
    2538:	20002704 	.word	0x20002704
    253c:	20002756 	.word	0x20002756
    2540:	20002700 	.word	0x20002700
    2544:	00002449 	.word	0x00002449
    2548:	402e0000 	.word	0x402e0000
    254c:	20002744 	.word	0x20002744
    2550:	000026bd 	.word	0x000026bd

00002554 <usb_seremu_getchar>:
	}
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
    2554:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t tail = rx_tail;
    2556:	4d14      	ldr	r5, [pc, #80]	; (25a8 <usb_seremu_getchar+0x54>)

	if (tail == rx_head) return -1;
    2558:	4a14      	ldr	r2, [pc, #80]	; (25ac <usb_seremu_getchar+0x58>)
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    255a:	782b      	ldrb	r3, [r5, #0]

	if (tail == rx_head) return -1;
    255c:	7812      	ldrb	r2, [r2, #0]
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    255e:	b2db      	uxtb	r3, r3

	if (tail == rx_head) return -1;
    2560:	4293      	cmp	r3, r2
    2562:	d01d      	beq.n	25a0 <usb_seremu_getchar+0x4c>
	if (++tail > RX_NUM) tail = 0;
    2564:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    2566:	4a12      	ldr	r2, [pc, #72]	; (25b0 <usb_seremu_getchar+0x5c>)
	uint32_t index = rx_index[i];
    2568:	4e12      	ldr	r6, [pc, #72]	; (25b4 <usb_seremu_getchar+0x60>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    256a:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    256c:	4c12      	ldr	r4, [pc, #72]	; (25b8 <usb_seremu_getchar+0x64>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    256e:	bf28      	it	cs
    2570:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    2572:	5cd0      	ldrb	r0, [r2, r3]
	uint32_t index = rx_index[i];
    2574:	f836 2010 	ldrh.w	r2, [r6, r0, lsl #1]
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    2578:	eb02 1140 	add.w	r1, r2, r0, lsl #5
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    257c:	3201      	adds	r2, #1
    257e:	2a1f      	cmp	r2, #31

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    2580:	eb04 0701 	add.w	r7, r4, r1
	int c = *p;
    2584:	5c64      	ldrb	r4, [r4, r1]
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    2586:	d805      	bhi.n	2594 <usb_seremu_getchar+0x40>
    2588:	7879      	ldrb	r1, [r7, #1]
    258a:	b119      	cbz	r1, 2594 <usb_seremu_getchar+0x40>
		rx_tail = tail;
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
    258c:	f826 2010 	strh.w	r2, [r6, r0, lsl #1]
	}
	return c;
    2590:	4620      	mov	r0, r4
    2592:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
    2594:	b2db      	uxtb	r3, r3
    2596:	702b      	strb	r3, [r5, #0]
		rx_queue_transfer(i);
    2598:	f7ff ff24 	bl	23e4 <rx_queue_transfer>
	} else {
		rx_index[i] = index;
	}
	return c;
    259c:	4620      	mov	r0, r4
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
		rx_queue_transfer(i);
    259e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
    25a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
	}
	return c;
}
    25a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    25a6:	bf00      	nop
    25a8:	20002756 	.word	0x20002756
    25ac:	20002754 	.word	0x20002754
    25b0:	2000271c 	.word	0x2000271c
    25b4:	20002704 	.word	0x20002704
    25b8:	20200260 	.word	0x20200260

000025bc <usb_seremu_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    25bc:	4b0b      	ldr	r3, [pc, #44]	; (25ec <usb_seremu_peekchar+0x30>)
	if (tail == rx_head) return -1;
    25be:	4a0c      	ldr	r2, [pc, #48]	; (25f0 <usb_seremu_peekchar+0x34>)
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    25c0:	781b      	ldrb	r3, [r3, #0]
	if (tail == rx_head) return -1;
    25c2:	7812      	ldrb	r2, [r2, #0]
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    25c4:	b2db      	uxtb	r3, r3
	if (tail == rx_head) return -1;
    25c6:	4293      	cmp	r3, r2
    25c8:	d00d      	beq.n	25e6 <usb_seremu_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    25ca:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    25cc:	4a09      	ldr	r2, [pc, #36]	; (25f4 <usb_seremu_peekchar+0x38>)
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    25ce:	480a      	ldr	r0, [pc, #40]	; (25f8 <usb_seremu_peekchar+0x3c>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    25d0:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    25d2:	490a      	ldr	r1, [pc, #40]	; (25fc <usb_seremu_peekchar+0x40>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    25d4:	bf28      	it	cs
    25d6:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    25d8:	5cd2      	ldrb	r2, [r2, r3]
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    25da:	f830 3012 	ldrh.w	r3, [r0, r2, lsl #1]
    25de:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    25e2:	5cc8      	ldrb	r0, [r1, r3]
    25e4:	4770      	bx	lr

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
    25e6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
}
    25ea:	4770      	bx	lr
    25ec:	20002756 	.word	0x20002756
    25f0:	20002754 	.word	0x20002754
    25f4:	2000271c 	.word	0x2000271c
    25f8:	20002704 	.word	0x20002704
    25fc:	20200260 	.word	0x20200260

00002600 <usb_seremu_available>:

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
    2600:	b508      	push	{r3, lr}
	uint32_t tail = rx_tail;
    2602:	4a06      	ldr	r2, [pc, #24]	; (261c <usb_seremu_available+0x1c>)
	if (tail == rx_head) {
    2604:	4b06      	ldr	r3, [pc, #24]	; (2620 <usb_seremu_available+0x20>)
}

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
    2606:	7812      	ldrb	r2, [r2, #0]
	if (tail == rx_head) {
    2608:	781b      	ldrb	r3, [r3, #0]
    260a:	429a      	cmp	r2, r3
    260c:	d001      	beq.n	2612 <usb_seremu_available+0x12>
		yield();
		return 0;
	}
	// TODO: how much is actually available?
	return 1;
    260e:	2001      	movs	r0, #1
}
    2610:	bd08      	pop	{r3, pc}
// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) {
		yield();
    2612:	f000 fa6d 	bl	2af0 <yield>
		return 0;
    2616:	2000      	movs	r0, #0
    2618:	bd08      	pop	{r3, pc}
    261a:	bf00      	nop
    261c:	20002756 	.word	0x20002756
    2620:	20002754 	.word	0x20002754

00002624 <tx_zero_pad>:
	USB1_GPTIMER0CTRL = 0;
}


void tx_zero_pad(void)
{
    2624:	b538      	push	{r3, r4, r5, lr}
	if (!tx_available) return;
    2626:	4c08      	ldr	r4, [pc, #32]	; (2648 <tx_zero_pad+0x24>)
    2628:	8822      	ldrh	r2, [r4, #0]
    262a:	b162      	cbz	r2, 2646 <tx_zero_pad+0x22>
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    262c:	4907      	ldr	r1, [pc, #28]	; (264c <tx_zero_pad+0x28>)
	memset(txdata, 0, tx_available);
    262e:	f1c2 0340 	rsb	r3, r2, #64	; 0x40
    2632:	4807      	ldr	r0, [pc, #28]	; (2650 <tx_zero_pad+0x2c>)


void tx_zero_pad(void)
{
	if (!tx_available) return;
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    2634:	780d      	ldrb	r5, [r1, #0]
	memset(txdata, 0, tx_available);
    2636:	2100      	movs	r1, #0
    2638:	eb03 1385 	add.w	r3, r3, r5, lsl #6
    263c:	4418      	add	r0, r3
    263e:	f004 f8e9 	bl	6814 <memset>
	tx_available = 0;
    2642:	2300      	movs	r3, #0
    2644:	8023      	strh	r3, [r4, #0]
    2646:	bd38      	pop	{r3, r4, r5, pc}
    2648:	2000274c 	.word	0x2000274c
    264c:	2000275a 	.word	0x2000275a
    2650:	20200360 	.word	0x20200360

00002654 <tx_queue_transfer>:
}

void tx_queue_transfer(void)
{
    2654:	b570      	push	{r4, r5, r6, lr}
	transfer_t *xfer = tx_transfer + tx_head;
    2656:	4e15      	ldr	r6, [pc, #84]	; (26ac <tx_queue_transfer+0x58>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    2658:	2300      	movs	r3, #0
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    265a:	4d15      	ldr	r5, [pc, #84]	; (26b0 <tx_queue_transfer+0x5c>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    265c:	2240      	movs	r2, #64	; 0x40
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    265e:	7831      	ldrb	r1, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    2660:	4c14      	ldr	r4, [pc, #80]	; (26b4 <tx_queue_transfer+0x60>)
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    2662:	eb05 1541 	add.w	r5, r5, r1, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    2666:	eb04 1481 	add.w	r4, r4, r1, lsl #6
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    266a:	4628      	mov	r0, r5
    266c:	4621      	mov	r1, r4
    266e:	f7ff fdc9 	bl	2204 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    2672:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    2676:	f104 0140 	add.w	r1, r4, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    267a:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    267e:	4a0e      	ldr	r2, [pc, #56]	; (26b8 <tx_queue_transfer+0x64>)
    2680:	6013      	str	r3, [r2, #0]
		location += 32;
    2682:	3320      	adds	r3, #32
	} while (location < end_addr);
    2684:	4299      	cmp	r1, r3
    2686:	d8fb      	bhi.n	2680 <tx_queue_transfer+0x2c>
	asm("dsb");
    2688:	f3bf 8f4f 	dsb	sy
	asm("isb");
    268c:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
    2690:	2002      	movs	r0, #2
    2692:	4629      	mov	r1, r5
    2694:	f7ff fdce 	bl	2234 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    2698:	7833      	ldrb	r3, [r6, #0]
    269a:	4a04      	ldr	r2, [pc, #16]	; (26ac <tx_queue_transfer+0x58>)
    269c:	3301      	adds	r3, #1
    269e:	b2db      	uxtb	r3, r3
    26a0:	2b0b      	cmp	r3, #11
    26a2:	bf88      	it	hi
    26a4:	2300      	movhi	r3, #0
    26a6:	7013      	strb	r3, [r2, #0]
    26a8:	bd70      	pop	{r4, r5, r6, pc}
    26aa:	bf00      	nop
    26ac:	2000275a 	.word	0x2000275a
    26b0:	200024e0 	.word	0x200024e0
    26b4:	20200360 	.word	0x20200360
    26b8:	e000ef70 	.word	0xe000ef70

000026bc <usb_seremu_flush_callback>:
	timer_stop();
	tx_noautoflush = 0;
}

static void usb_seremu_flush_callback(void)
{
    26bc:	b508      	push	{r3, lr}
	if (tx_noautoflush) return;
    26be:	4b08      	ldr	r3, [pc, #32]	; (26e0 <usb_seremu_flush_callback+0x24>)
    26c0:	781b      	ldrb	r3, [r3, #0]
    26c2:	b92b      	cbnz	r3, 26d0 <usb_seremu_flush_callback+0x14>
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
    26c4:	4b07      	ldr	r3, [pc, #28]	; (26e4 <usb_seremu_flush_callback+0x28>)
    26c6:	881b      	ldrh	r3, [r3, #0]
    26c8:	3b01      	subs	r3, #1
    26ca:	b29b      	uxth	r3, r3
    26cc:	2b3e      	cmp	r3, #62	; 0x3e
    26ce:	d900      	bls.n	26d2 <usb_seremu_flush_callback+0x16>
    26d0:	bd08      	pop	{r3, pc}
	tx_zero_pad();
    26d2:	f7ff ffa7 	bl	2624 <tx_zero_pad>
	tx_queue_transfer();
}
    26d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
static void usb_seremu_flush_callback(void)
{
	if (tx_noautoflush) return;
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
	tx_zero_pad();
	tx_queue_transfer();
    26da:	f7ff bfbb 	b.w	2654 <tx_queue_transfer>
    26de:	bf00      	nop
    26e0:	2000275b 	.word	0x2000275b
    26e4:	2000274c 	.word	0x2000274c

000026e8 <usb_seremu_write.part.1>:
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
	if (++tx_head >= TX_NUM) tx_head = 0;
}

int usb_seremu_write(const void *buffer, uint32_t size)
    26e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    26ec:	b085      	sub	sp, #20
    26ee:	9002      	str	r0, [sp, #8]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    26f0:	9100      	str	r1, [sp, #0]
    26f2:	2900      	cmp	r1, #0
    26f4:	f000 8084 	beq.w	2800 <usb_seremu_write.part.1+0x118>
    26f8:	2300      	movs	r3, #0
    26fa:	4f42      	ldr	r7, [pc, #264]	; (2804 <usb_seremu_write.part.1+0x11c>)
    26fc:	f8df 8120 	ldr.w	r8, [pc, #288]	; 2820 <usb_seremu_write.part.1+0x138>
    2700:	f8df a110 	ldr.w	sl, [pc, #272]	; 2814 <usb_seremu_write.part.1+0x12c>
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
    2704:	4e40      	ldr	r6, [pc, #256]	; (2808 <usb_seremu_write.part.1+0x120>)
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    2706:	f8df b11c 	ldr.w	fp, [pc, #284]	; 2824 <usb_seremu_write.part.1+0x13c>
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    270a:	9301      	str	r3, [sp, #4]
		tx_noautoflush = 1;
    270c:	2101      	movs	r1, #1
		transfer_t *xfer = tx_transfer + tx_head;
    270e:	4b3f      	ldr	r3, [pc, #252]	; (280c <usb_seremu_write.part.1+0x124>)
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
    2710:	7039      	strb	r1, [r7, #0]
		transfer_t *xfer = tx_transfer + tx_head;
    2712:	781a      	ldrb	r2, [r3, #0]
    2714:	493e      	ldr	r1, [pc, #248]	; (2810 <usb_seremu_write.part.1+0x128>)
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    2716:	f8b8 3000 	ldrh.w	r3, [r8]
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
    271a:	eb01 1942 	add.w	r9, r1, r2, lsl #5
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    271e:	bb0b      	cbnz	r3, 2764 <usb_seremu_write.part.1+0x7c>
    2720:	461d      	mov	r5, r3
    2722:	461c      	mov	r4, r3
			uint32_t status = usb_transfer_status(xfer);
    2724:	4648      	mov	r0, r9
    2726:	f7ff fdab 	bl	2280 <usb_transfer_status>
			if (!(status & 0x80)) {
    272a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    272e:	f04f 0300 	mov.w	r3, #0
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2732:	4938      	ldr	r1, [pc, #224]	; (2814 <usb_seremu_write.part.1+0x12c>)
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
			uint32_t status = usb_transfer_status(xfer);
			if (!(status & 0x80)) {
    2734:	d056      	beq.n	27e4 <usb_seremu_write.part.1+0xfc>
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2736:	f89a 2000 	ldrb.w	r2, [sl]
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    273a:	703b      	strb	r3, [r7, #0]
			if (!waiting) {
    273c:	b904      	cbnz	r4, 2740 <usb_seremu_write.part.1+0x58>
				wait_begin_at = systick_millis_count;
    273e:	6835      	ldr	r5, [r6, #0]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    2740:	2a00      	cmp	r2, #0
    2742:	d134      	bne.n	27ae <usb_seremu_write.part.1+0xc6>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    2744:	6833      	ldr	r3, [r6, #0]
    2746:	2401      	movs	r4, #1
    2748:	1b5b      	subs	r3, r3, r5
    274a:	2b32      	cmp	r3, #50	; 0x32
    274c:	d853      	bhi.n	27f6 <usb_seremu_write.part.1+0x10e>
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    274e:	f89b 3000 	ldrb.w	r3, [fp]
    2752:	b363      	cbz	r3, 27ae <usb_seremu_write.part.1+0xc6>
			yield();
    2754:	f000 f9cc 	bl	2af0 <yield>
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    2758:	f8b8 3000 	ldrh.w	r3, [r8]
    275c:	2b00      	cmp	r3, #0
    275e:	d0e1      	beq.n	2724 <usb_seremu_write.part.1+0x3c>
    2760:	4a2a      	ldr	r2, [pc, #168]	; (280c <usb_seremu_write.part.1+0x124>)
    2762:	7812      	ldrb	r2, [r2, #0]
    2764:	461c      	mov	r4, r3
    2766:	f1c3 0040 	rsb	r0, r3, #64	; 0x40
				return sent;
			}
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    276a:	eb00 1082 	add.w	r0, r0, r2, lsl #6
    276e:	4a2a      	ldr	r2, [pc, #168]	; (2818 <usb_seremu_write.part.1+0x130>)
    2770:	4410      	add	r0, r2
		if (size >= tx_available) {
    2772:	9a00      	ldr	r2, [sp, #0]
    2774:	42a2      	cmp	r2, r4
    2776:	d31e      	bcc.n	27b6 <usb_seremu_write.part.1+0xce>
			memcpy(txdata, data, tx_available);
			size -= tx_available;
    2778:	9b00      	ldr	r3, [sp, #0]
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    277a:	2500      	movs	r5, #0
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    277c:	f8dd 9008 	ldr.w	r9, [sp, #8]
    2780:	4622      	mov	r2, r4
			size -= tx_available;
    2782:	1b1b      	subs	r3, r3, r4
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    2784:	4649      	mov	r1, r9
			size -= tx_available;
    2786:	9300      	str	r3, [sp, #0]
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    2788:	f003 ff46 	bl	6618 <memcpy>
			size -= tx_available;
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    278c:	f8a8 5000 	strh.w	r5, [r8]
			tx_queue_transfer();
    2790:	f7ff ff60 	bl	2654 <tx_queue_transfer>
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    2794:	9a01      	ldr	r2, [sp, #4]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    2796:	4b21      	ldr	r3, [pc, #132]	; (281c <usb_seremu_write.part.1+0x134>)
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    2798:	4422      	add	r2, r4
    279a:	9201      	str	r2, [sp, #4]
			data += tx_available;
    279c:	464a      	mov	r2, r9
    279e:	4422      	add	r2, r4
    27a0:	9202      	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    27a2:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    27a6:	9b00      	ldr	r3, [sp, #0]
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    27a8:	703d      	strb	r5, [r7, #0]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    27aa:	2b00      	cmp	r3, #0
    27ac:	d1ae      	bne.n	270c <usb_seremu_write.part.1+0x24>
    27ae:	9801      	ldr	r0, [sp, #4]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    27b0:	b005      	add	sp, #20
    27b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    27b6:	9d00      	ldr	r5, [sp, #0]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    27b8:	f04f 4440 	mov.w	r4, #3221225472	; 0xc0000000
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    27bc:	9902      	ldr	r1, [sp, #8]
    27be:	462a      	mov	r2, r5
    27c0:	9303      	str	r3, [sp, #12]
    27c2:	f003 ff29 	bl	6618 <memcpy>
			tx_available -= size;
    27c6:	9b03      	ldr	r3, [sp, #12]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    27c8:	4914      	ldr	r1, [pc, #80]	; (281c <usb_seremu_write.part.1+0x134>)
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    27ca:	2200      	movs	r2, #0
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
			tx_available -= size;
    27cc:	1b5b      	subs	r3, r3, r5
    27ce:	f8a8 3000 	strh.w	r3, [r8]
    27d2:	9b01      	ldr	r3, [sp, #4]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    27d4:	f8c1 4084 	str.w	r4, [r1, #132]	; 0x84
    27d8:	4618      	mov	r0, r3
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    27da:	703a      	strb	r2, [r7, #0]
    27dc:	4428      	add	r0, r5
	}
	return sent;
}
    27de:	b005      	add	sp, #20
    27e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    27e4:	2340      	movs	r3, #64	; 0x40
    27e6:	4a09      	ldr	r2, [pc, #36]	; (280c <usb_seremu_write.part.1+0x124>)
				transmit_previous_timeout = 0;
    27e8:	f88a 0000 	strb.w	r0, [sl]
    27ec:	7812      	ldrb	r2, [r2, #0]
    27ee:	461c      	mov	r4, r3
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    27f0:	f8a8 3000 	strh.w	r3, [r8]
    27f4:	e7b9      	b.n	276a <usb_seremu_write.part.1+0x82>
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
    27f6:	9801      	ldr	r0, [sp, #4]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    27f8:	700c      	strb	r4, [r1, #0]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    27fa:	b005      	add	sp, #20
    27fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2800:	9800      	ldr	r0, [sp, #0]
    2802:	e7d5      	b.n	27b0 <usb_seremu_write.part.1+0xc8>
    2804:	2000275b 	.word	0x2000275b
    2808:	20002740 	.word	0x20002740
    280c:	2000275a 	.word	0x2000275a
    2810:	200024e0 	.word	0x200024e0
    2814:	20002758 	.word	0x20002758
    2818:	20200360 	.word	0x20200360
    281c:	402e0000 	.word	0x402e0000
    2820:	2000274c 	.word	0x2000274c
    2824:	2000275c 	.word	0x2000275c

00002828 <usb_seremu_putchar>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2828:	4b09      	ldr	r3, [pc, #36]	; (2850 <usb_seremu_putchar+0x28>)
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    282a:	b500      	push	{lr}
    282c:	b083      	sub	sp, #12
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    282e:	781b      	ldrb	r3, [r3, #0]
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    2830:	f88d 0007 	strb.w	r0, [sp, #7]
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2834:	b923      	cbnz	r3, 2840 <usb_seremu_putchar+0x18>
    2836:	f003 00ff 	and.w	r0, r3, #255	; 0xff

// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
	return usb_seremu_write(&c, 1);
}
    283a:	b003      	add	sp, #12
    283c:	f85d fb04 	ldr.w	pc, [sp], #4
    2840:	2101      	movs	r1, #1
    2842:	f10d 0007 	add.w	r0, sp, #7
    2846:	f7ff ff4f 	bl	26e8 <usb_seremu_write.part.1>
    284a:	b003      	add	sp, #12
    284c:	f85d fb04 	ldr.w	pc, [sp], #4
    2850:	2000275c 	.word	0x2000275c

00002854 <usb_seremu_write>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2854:	4b04      	ldr	r3, [pc, #16]	; (2868 <usb_seremu_write+0x14>)
    2856:	781b      	ldrb	r3, [r3, #0]
    2858:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    285c:	b10b      	cbz	r3, 2862 <usb_seremu_write+0xe>
    285e:	f7ff bf43 	b.w	26e8 <usb_seremu_write.part.1>
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    2862:	4610      	mov	r0, r2
    2864:	4770      	bx	lr
    2866:	bf00      	nop
    2868:	2000275c 	.word	0x2000275c

0000286c <usb_seremu_write_buffer_free>:

int usb_seremu_write_buffer_free(void)
{
	return 1;
}
    286c:	2001      	movs	r0, #1
    286e:	4770      	bx	lr

00002870 <usb_seremu_flush_output>:

void usb_seremu_flush_output(void)
{
	if (!usb_configuration) return;
    2870:	4b0a      	ldr	r3, [pc, #40]	; (289c <usb_seremu_flush_output+0x2c>)
    2872:	781b      	ldrb	r3, [r3, #0]
    2874:	b113      	cbz	r3, 287c <usb_seremu_flush_output+0xc>
	if (tx_available == 0) return;
    2876:	4b0a      	ldr	r3, [pc, #40]	; (28a0 <usb_seremu_flush_output+0x30>)
    2878:	881b      	ldrh	r3, [r3, #0]
    287a:	b903      	cbnz	r3, 287e <usb_seremu_flush_output+0xe>
    287c:	4770      	bx	lr
{
	return 1;
}

void usb_seremu_flush_output(void)
{
    287e:	b510      	push	{r4, lr}
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    2880:	2301      	movs	r3, #1
    2882:	4c08      	ldr	r4, [pc, #32]	; (28a4 <usb_seremu_flush_output+0x34>)
    2884:	7023      	strb	r3, [r4, #0]
	tx_zero_pad();
    2886:	f7ff fecd 	bl	2624 <tx_zero_pad>
	tx_queue_transfer();
    288a:	f7ff fee3 	bl	2654 <tx_queue_transfer>
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    288e:	2300      	movs	r3, #0
    2890:	4a05      	ldr	r2, [pc, #20]	; (28a8 <usb_seremu_flush_output+0x38>)
    2892:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	tx_zero_pad();
	tx_queue_transfer();
	timer_stop();
	tx_noautoflush = 0;
    2896:	7023      	strb	r3, [r4, #0]
    2898:	bd10      	pop	{r4, pc}
    289a:	bf00      	nop
    289c:	2000275c 	.word	0x2000275c
    28a0:	2000274c 	.word	0x2000274c
    28a4:	2000275b 	.word	0x2000275b
    28a8:	402e0000 	.word	0x402e0000

000028ac <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    28ac:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    28ae:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    28b2:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    28b4:	4c0c      	ldr	r4, [pc, #48]	; (28e8 <EventResponder::runFromInterrupt()+0x3c>)
    28b6:	6823      	ldr	r3, [r4, #0]
		if (first) {
    28b8:	b18b      	cbz	r3, 28de <EventResponder::runFromInterrupt()+0x32>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    28ba:	4e0c      	ldr	r6, [pc, #48]	; (28ec <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    28bc:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    28be:	695a      	ldr	r2, [r3, #20]
    28c0:	6022      	str	r2, [r4, #0]
			if (firstInterrupt) {
    28c2:	b17a      	cbz	r2, 28e4 <EventResponder::runFromInterrupt()+0x38>
				firstInterrupt->_prev = nullptr;
    28c4:	6195      	str	r5, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    28c6:	b901      	cbnz	r1, 28ca <EventResponder::runFromInterrupt()+0x1e>
    28c8:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    28ca:	775d      	strb	r5, [r3, #29]
			(*(first->_function))(*first);
    28cc:	4618      	mov	r0, r3
    28ce:	689b      	ldr	r3, [r3, #8]
    28d0:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    28d2:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    28d6:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    28d8:	6823      	ldr	r3, [r4, #0]
		if (first) {
    28da:	2b00      	cmp	r3, #0
    28dc:	d1ef      	bne.n	28be <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    28de:	b901      	cbnz	r1, 28e2 <EventResponder::runFromInterrupt()+0x36>
    28e0:	b662      	cpsie	i
    28e2:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    28e4:	6032      	str	r2, [r6, #0]
    28e6:	e7ee      	b.n	28c6 <EventResponder::runFromInterrupt()+0x1a>
    28e8:	2000268c 	.word	0x2000268c
    28ec:	20002688 	.word	0x20002688

000028f0 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    28f0:	f7ff bfdc 	b.w	28ac <EventResponder::runFromInterrupt()>

000028f4 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    28f4:	4a04      	ldr	r2, [pc, #16]	; (2908 <systick_isr+0x14>)
    28f6:	4b05      	ldr	r3, [pc, #20]	; (290c <systick_isr+0x18>)
    28f8:	6811      	ldr	r1, [r2, #0]
	systick_millis_count++;
    28fa:	4a05      	ldr	r2, [pc, #20]	; (2910 <systick_isr+0x1c>)
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    28fc:	6019      	str	r1, [r3, #0]
	systick_millis_count++;
    28fe:	6813      	ldr	r3, [r2, #0]
    2900:	3301      	adds	r3, #1
    2902:	6013      	str	r3, [r2, #0]
    2904:	4770      	bx	lr
    2906:	bf00      	nop
    2908:	e0001004 	.word	0xe0001004
    290c:	2000273c 	.word	0x2000273c
    2910:	20002740 	.word	0x20002740

00002914 <IntervalTimer::end()>:
}


void IntervalTimer::end() {
#if 1
	if (channel) {
    2914:	6802      	ldr	r2, [r0, #0]
    2916:	b30a      	cbz	r2, 295c <IntervalTimer::end()+0x48>
		int index = channel - IMXRT_PIT_CHANNELS;
    2918:	4b11      	ldr	r3, [pc, #68]	; (2960 <IntervalTimer::end()+0x4c>)
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    291a:	4912      	ldr	r1, [pc, #72]	; (2964 <IntervalTimer::end()+0x50>)


void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    291c:	4413      	add	r3, r2
	NVIC_ENABLE_IRQ(IRQ_PIT);
	return true;
}


void IntervalTimer::end() {
    291e:	b5f0      	push	{r4, r5, r6, r7, lr}
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    2920:	111b      	asrs	r3, r3, #4
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2922:	25ff      	movs	r5, #255	; 0xff
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    2924:	2400      	movs	r4, #0
    2926:	f8df e044 	ldr.w	lr, [pc, #68]	; 296c <IntervalTimer::end()+0x58>
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    292a:	54cd      	strb	r5, [r1, r3]
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    292c:	780e      	ldrb	r6, [r1, #0]
    292e:	784d      	ldrb	r5, [r1, #1]
    2930:	2eff      	cmp	r6, #255	; 0xff
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
    2932:	6094      	str	r4, [r2, #8]
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    2934:	f84e 4023 	str.w	r4, [lr, r3, lsl #2]
    2938:	bf28      	it	cs
    293a:	26ff      	movcs	r6, #255	; 0xff
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    293c:	788a      	ldrb	r2, [r1, #2]
    293e:	78c9      	ldrb	r1, [r1, #3]
    2940:	42ae      	cmp	r6, r5
    2942:	4633      	mov	r3, r6
		}
		NVIC_SET_PRIORITY(IRQ_PIT, top_priority);
    2944:	4f08      	ldr	r7, [pc, #32]	; (2968 <IntervalTimer::end()+0x54>)
    2946:	bf28      	it	cs
    2948:	462b      	movcs	r3, r5
    294a:	4293      	cmp	r3, r2
    294c:	bf28      	it	cs
    294e:	4613      	movcs	r3, r2
    2950:	428b      	cmp	r3, r1
    2952:	bf28      	it	cs
    2954:	460b      	movcs	r3, r1
    2956:	703b      	strb	r3, [r7, #0]
		channel = 0;
    2958:	6004      	str	r4, [r0, #0]
    295a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    295c:	4770      	bx	lr
    295e:	bf00      	nop
    2960:	bff7bf00 	.word	0xbff7bf00
    2964:	20001854 	.word	0x20001854
    2968:	e000e47a 	.word	0xe000e47a
    296c:	200022c0 	.word	0x200022c0

00002970 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
    2970:	2000      	movs	r0, #0
    2972:	4770      	bx	lr

00002974 <Print::println()>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    2974:	b510      	push	{r4, lr}
	uint8_t buf[2]={'\r', '\n'};
    2976:	4c06      	ldr	r4, [pc, #24]	; (2990 <Print::println()+0x1c>)
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    2978:	b082      	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    297a:	6803      	ldr	r3, [r0, #0]
    297c:	2202      	movs	r2, #2
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    297e:	8824      	ldrh	r4, [r4, #0]
	return write(buf, 2);
    2980:	a901      	add	r1, sp, #4
    2982:	685b      	ldr	r3, [r3, #4]
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    2984:	f8ad 4004 	strh.w	r4, [sp, #4]
	return write(buf, 2);
    2988:	4798      	blx	r3
}
    298a:	b002      	add	sp, #8
    298c:	bd10      	pop	{r4, pc}
    298e:	bf00      	nop
    2990:	200003f0 	.word	0x200003f0

00002994 <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
	((class Print *)file)->write((uint8_t *)ptr, len);
    2994:	6803      	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    2996:	b510      	push	{r4, lr}
    2998:	4614      	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    299a:	685b      	ldr	r3, [r3, #4]
    299c:	4798      	blx	r3
	return len;
}
    299e:	4620      	mov	r0, r4
    29a0:	bd10      	pop	{r4, pc}
    29a2:	bf00      	nop

000029a4 <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    29a4:	b40e      	push	{r1, r2, r3}
    29a6:	b500      	push	{lr}
    29a8:	b082      	sub	sp, #8
    29aa:	ab03      	add	r3, sp, #12
    29ac:	f853 1b04 	ldr.w	r1, [r3], #4
	va_start(ap, format);
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    29b0:	461a      	mov	r2, r3
}

int Print::printf(const char *format, ...)
{
	va_list ap;
	va_start(ap, format);
    29b2:	9301      	str	r3, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    29b4:	f004 fc2c 	bl	7210 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    29b8:	b002      	add	sp, #8
    29ba:	f85d eb04 	ldr.w	lr, [sp], #4
    29be:	b003      	add	sp, #12
    29c0:	4770      	bx	lr
    29c2:	bf00      	nop

000029c4 <IntervalTimer::~IntervalTimer()>:
private:
	static const uint32_t MAX_PERIOD = UINT32_MAX / (24000000 / 1000000);
public:
	constexpr IntervalTimer() {
	}
	~IntervalTimer() {
    29c4:	b510      	push	{r4, lr}
    29c6:	4604      	mov	r4, r0
		end();
    29c8:	f7ff ffa4 	bl	2914 <IntervalTimer::end()>
	}
    29cc:	4620      	mov	r0, r4
    29ce:	bd10      	pop	{r4, pc}

000029d0 <_GLOBAL__sub_I__Z4tonehtm>:
static uint32_t tone_toggle_count;
static volatile uint32_t *tone_reg;
static uint32_t tone_mask;
static float tone_usec=0.0;
static uint32_t tone_new_count=0;
static IntervalTimer tone_timer;
    29d0:	4a02      	ldr	r2, [pc, #8]	; (29dc <_GLOBAL__sub_I__Z4tonehtm+0xc>)
    29d2:	4903      	ldr	r1, [pc, #12]	; (29e0 <_GLOBAL__sub_I__Z4tonehtm+0x10>)
    29d4:	4803      	ldr	r0, [pc, #12]	; (29e4 <_GLOBAL__sub_I__Z4tonehtm+0x14>)
    29d6:	f003 b96b 	b.w	5cb0 <__aeabi_atexit>
    29da:	bf00      	nop
    29dc:	20001470 	.word	0x20001470
    29e0:	000029c5 	.word	0x000029c5
    29e4:	2000184c 	.word	0x2000184c

000029e8 <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    29e8:	b510      	push	{r4, lr}
    29ea:	4604      	mov	r4, r0
{
	free(buffer);
    29ec:	6800      	ldr	r0, [r0, #0]
    29ee:	f003 fb3d 	bl	606c <free>
}
    29f2:	4620      	mov	r0, r4
    29f4:	bd10      	pop	{r4, pc}
    29f6:	bf00      	nop

000029f8 <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    29f8:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    29fa:	6843      	ldr	r3, [r0, #4]
    29fc:	428b      	cmp	r3, r1
    29fe:	d301      	bcc.n	2a04 <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2a00:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    2a02:	bd38      	pop	{r3, r4, r5, pc}
    2a04:	460d      	mov	r5, r1
    2a06:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    2a08:	3101      	adds	r1, #1
    2a0a:	6800      	ldr	r0, [r0, #0]
    2a0c:	f003 ff54 	bl	68b8 <realloc>
	if (newbuffer) {
    2a10:	2800      	cmp	r0, #0
    2a12:	d0f6      	beq.n	2a02 <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2a14:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    2a16:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2a1a:	2b00      	cmp	r3, #0
    2a1c:	d1f0      	bne.n	2a00 <String::reserve(unsigned int)+0x8>
    2a1e:	7003      	strb	r3, [r0, #0]
    2a20:	e7ee      	b.n	2a00 <String::reserve(unsigned int)+0x8>
    2a22:	bf00      	nop

00002a24 <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    2a24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2a26:	4604      	mov	r4, r0
	if (length == 0) {
    2a28:	4615      	mov	r5, r2
    2a2a:	b932      	cbnz	r2, 2a3a <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    2a2c:	6803      	ldr	r3, [r0, #0]
    2a2e:	b103      	cbz	r3, 2a32 <String::copy(char const*, unsigned int)+0xe>
    2a30:	701a      	strb	r2, [r3, #0]
		len = 0;
    2a32:	2300      	movs	r3, #0
    2a34:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    2a36:	4620      	mov	r0, r4
    2a38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2a3a:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    2a3c:	4611      	mov	r1, r2
    2a3e:	f7ff ffdb 	bl	29f8 <String::reserve(unsigned int)>
    2a42:	4607      	mov	r7, r0
    2a44:	b948      	cbnz	r0, 2a5a <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    2a46:	6820      	ldr	r0, [r4, #0]
    2a48:	b110      	cbz	r0, 2a50 <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    2a4a:	f003 fb0f 	bl	606c <free>
			buffer = NULL;
    2a4e:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    2a50:	2300      	movs	r3, #0
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    2a52:	4620      	mov	r0, r4
	if (!reserve(length)) {
		if (buffer) {
			free(buffer);
			buffer = NULL;
		}
		len = capacity = 0;
    2a54:	6063      	str	r3, [r4, #4]
    2a56:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    2a58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    2a5a:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    2a5c:	4631      	mov	r1, r6
    2a5e:	6820      	ldr	r0, [r4, #0]
    2a60:	f004 faac 	bl	6fbc <strcpy>
	return *this;
    2a64:	e7e7      	b.n	2a36 <String::copy(char const*, unsigned int)+0x12>
    2a66:	bf00      	nop

00002a68 <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    2a68:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2a6a:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    2a6c:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2a6e:	6003      	str	r3, [r0, #0]
	capacity = 0;
    2a70:	6043      	str	r3, [r0, #4]
	len = 0;
    2a72:	6083      	str	r3, [r0, #8]
	flags = 0;
    2a74:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    2a76:	b141      	cbz	r1, 2a8a <String::String(char const*)+0x22>
    2a78:	460d      	mov	r5, r1
    2a7a:	4608      	mov	r0, r1
    2a7c:	f004 fb00 	bl	7080 <strlen>
    2a80:	4602      	mov	r2, r0
    2a82:	4629      	mov	r1, r5
    2a84:	4620      	mov	r0, r4
    2a86:	f7ff ffcd 	bl	2a24 <String::copy(char const*, unsigned int)>
}
    2a8a:	4620      	mov	r0, r4
    2a8c:	bd38      	pop	{r3, r4, r5, pc}
    2a8e:	bf00      	nop

00002a90 <String::equals(char const*) const>:
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    2a90:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
    2a92:	b508      	push	{r3, lr}
    2a94:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
    2a96:	b92a      	cbnz	r2, 2aa4 <String::equals(char const*) const+0x14>
    2a98:	b171      	cbz	r1, 2ab8 <String::equals(char const*) const+0x28>
	if (cstr == NULL) return buffer[0] == 0;
    2a9a:	7818      	ldrb	r0, [r3, #0]
    2a9c:	fab0 f080 	clz	r0, r0
    2aa0:	0940      	lsrs	r0, r0, #5
    2aa2:	bd08      	pop	{r3, pc}
    2aa4:	b131      	cbz	r1, 2ab4 <String::equals(char const*) const+0x24>
	return strcmp(buffer, cstr) == 0;
    2aa6:	6800      	ldr	r0, [r0, #0]
    2aa8:	f004 f91e 	bl	6ce8 <strcmp>
    2aac:	fab0 f080 	clz	r0, r0
    2ab0:	0940      	lsrs	r0, r0, #5
}
    2ab2:	bd08      	pop	{r3, pc}
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
	if (cstr == NULL) return buffer[0] == 0;
    2ab4:	6803      	ldr	r3, [r0, #0]
    2ab6:	e7f0      	b.n	2a9a <String::equals(char const*) const+0xa>
    2ab8:	2001      	movs	r0, #1
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    2aba:	bd08      	pop	{r3, pc}

00002abc <operator new(unsigned int)>:
    2abc:	f003 bace 	b.w	605c <malloc>

00002ac0 <operator new[](unsigned int)>:
	return malloc(size);
}

void * operator new[](size_t size)
{
	return malloc(size);
    2ac0:	f003 bacc 	b.w	605c <malloc>

00002ac4 <operator delete(void*, unsigned int)>:
    2ac4:	f003 bad2 	b.w	606c <free>

00002ac8 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    2ac8:	4770      	bx	lr
    2aca:	bf00      	nop

00002acc <usb_seremu_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
    2acc:	f7ff bd76 	b.w	25bc <usb_seremu_peekchar>

00002ad0 <usb_seremu_class::read()>:
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
    2ad0:	f7ff bd40 	b.w	2554 <usb_seremu_getchar>

00002ad4 <usb_seremu_class::available()>:
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    2ad4:	f7ff bd94 	b.w	2600 <usb_seremu_available>

00002ad8 <usb_seremu_class::flush()>:
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
    2ad8:	f7ff beca 	b.w	2870 <usb_seremu_flush_output>

00002adc <usb_seremu_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
        size_t write(unsigned long n) { return write((uint8_t)n); }
        size_t write(long n) { return write((uint8_t)n); }
        size_t write(unsigned int n) { return write((uint8_t)n); }
        size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_seremu_write_buffer_free(); }
    2adc:	f7ff bec6 	b.w	286c <usb_seremu_write_buffer_free>

00002ae0 <usb_seremu_class::write(unsigned char const*, unsigned int)>:
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
    2ae0:	4608      	mov	r0, r1
    2ae2:	4611      	mov	r1, r2
    2ae4:	f7ff beb6 	b.w	2854 <usb_seremu_write>

00002ae8 <usb_seremu_class::write(unsigned char)>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
    2ae8:	4608      	mov	r0, r1
    2aea:	f7ff be9d 	b.w	2828 <usb_seremu_putchar>
    2aee:	bf00      	nop

00002af0 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    2af0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    2af4:	4e32      	ldr	r6, [pc, #200]	; (2bc0 <yield+0xd0>)
    2af6:	7833      	ldrb	r3, [r6, #0]
    2af8:	b193      	cbz	r3, 2b20 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    2afa:	4f32      	ldr	r7, [pc, #200]	; (2bc4 <yield+0xd4>)
    2afc:	783a      	ldrb	r2, [r7, #0]
    2afe:	b97a      	cbnz	r2, 2b20 <yield+0x30>
	running = 1;
    2b00:	2201      	movs	r2, #1


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    2b02:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    2b04:	703a      	strb	r2, [r7, #0]


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    2b06:	d437      	bmi.n	2b78 <yield+0x88>
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
    2b08:	079a      	lsls	r2, r3, #30
    2b0a:	d419      	bmi.n	2b40 <yield+0x50>

	running = 0;
    2b0c:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    2b0e:	075b      	lsls	r3, r3, #29
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();

	running = 0;
    2b10:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    2b12:	d505      	bpl.n	2b20 <yield+0x30>
	// Wait for event(s) to occur.  These are most likely to be useful when
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);
	static void runFromYield() {
		if (!firstYield) return;  
    2b14:	4b2c      	ldr	r3, [pc, #176]	; (2bc8 <yield+0xd8>)
    2b16:	681a      	ldr	r2, [r3, #0]
    2b18:	b112      	cbz	r2, 2b20 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    2b1a:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    2b1e:	b10a      	cbz	r2, 2b24 <yield+0x34>
    2b20:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2b24:	f3ef 8010 	mrs	r0, PRIMASK
		__disable_irq();
    2b28:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    2b2a:	681a      	ldr	r2, [r3, #0]
		if (first == nullptr) {
    2b2c:	b11a      	cbz	r2, 2b36 <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    2b2e:	4c27      	ldr	r4, [pc, #156]	; (2bcc <yield+0xdc>)
    2b30:	7821      	ldrb	r1, [r4, #0]
    2b32:	2900      	cmp	r1, #0
    2b34:	d02f      	beq.n	2b96 <yield+0xa6>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2b36:	2800      	cmp	r0, #0
    2b38:	d1f2      	bne.n	2b20 <yield+0x30>
    2b3a:	b662      	cpsie	i
    2b3c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    2b40:	f8df 8094 	ldr.w	r8, [pc, #148]	; 2bd8 <yield+0xe8>
    2b44:	f898 2000 	ldrb.w	r2, [r8]
    2b48:	2a00      	cmp	r2, #0
    2b4a:	d0df      	beq.n	2b0c <yield+0x1c>
    2b4c:	2400      	movs	r4, #0
    2b4e:	f8df 908c 	ldr.w	r9, [pc, #140]	; 2bdc <yield+0xec>
    2b52:	e005      	b.n	2b60 <yield+0x70>
    2b54:	3401      	adds	r4, #1
    2b56:	f898 3000 	ldrb.w	r3, [r8]
    2b5a:	b2e4      	uxtb	r4, r4
    2b5c:	42a3      	cmp	r3, r4
    2b5e:	d913      	bls.n	2b88 <yield+0x98>
			s_serials_with_serial_events[i]->doYieldCode();
    2b60:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    2b64:	682b      	ldr	r3, [r5, #0]
    2b66:	4628      	mov	r0, r5
    2b68:	691b      	ldr	r3, [r3, #16]
    2b6a:	4798      	blx	r3
    2b6c:	2800      	cmp	r0, #0
    2b6e:	d0f1      	beq.n	2b54 <yield+0x64>
    2b70:	696b      	ldr	r3, [r5, #20]
    2b72:	689b      	ldr	r3, [r3, #8]
    2b74:	4798      	blx	r3
    2b76:	e7ed      	b.n	2b54 <yield+0x64>
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    2b78:	f7ff fd42 	bl	2600 <usb_seremu_available>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    2b7c:	b9d0      	cbnz	r0, 2bb4 <yield+0xc4>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    2b7e:	4b14      	ldr	r3, [pc, #80]	; (2bd0 <yield+0xe0>)
    2b80:	781b      	ldrb	r3, [r3, #0]
    2b82:	b91b      	cbnz	r3, 2b8c <yield+0x9c>
    2b84:	7833      	ldrb	r3, [r6, #0]
    2b86:	e7bf      	b.n	2b08 <yield+0x18>
    2b88:	7833      	ldrb	r3, [r6, #0]
    2b8a:	e7bf      	b.n	2b0c <yield+0x1c>
    2b8c:	7833      	ldrb	r3, [r6, #0]
    2b8e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    2b92:	7033      	strb	r3, [r6, #0]
    2b94:	e7b8      	b.n	2b08 <yield+0x18>
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    2b96:	2601      	movs	r6, #1
		firstYield = first->_next;
    2b98:	6955      	ldr	r5, [r2, #20]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    2b9a:	7026      	strb	r6, [r4, #0]
		firstYield = first->_next;
    2b9c:	601d      	str	r5, [r3, #0]
		if (firstYield) {
    2b9e:	b165      	cbz	r5, 2bba <yield+0xca>
			firstYield->_prev = nullptr;
    2ba0:	61a9      	str	r1, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2ba2:	b900      	cbnz	r0, 2ba6 <yield+0xb6>
    2ba4:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    2ba6:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    2ba8:	6893      	ldr	r3, [r2, #8]
    2baa:	4610      	mov	r0, r2
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    2bac:	7755      	strb	r5, [r2, #29]
		(*(first->_function))(*first);
    2bae:	4798      	blx	r3
		runningFromYield = false;
    2bb0:	7025      	strb	r5, [r4, #0]
    2bb2:	e7b5      	b.n	2b20 <yield+0x30>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    2bb4:	f7ff ff88 	bl	2ac8 <serialEvent()>
    2bb8:	e7e1      	b.n	2b7e <yield+0x8e>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    2bba:	4b06      	ldr	r3, [pc, #24]	; (2bd4 <yield+0xe4>)
    2bbc:	601d      	str	r5, [r3, #0]
    2bbe:	e7f0      	b.n	2ba2 <yield+0xb2>
    2bc0:	20001e47 	.word	0x20001e47
    2bc4:	20002750 	.word	0x20002750
    2bc8:	20002684 	.word	0x20002684
    2bcc:	2000274e 	.word	0x2000274e
    2bd0:	60002186 	.word	0x60002186
    2bd4:	20002690 	.word	0x20002690
    2bd8:	2000274f 	.word	0x2000274f
    2bdc:	20002694 	.word	0x20002694

00002be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>:
 *    @param  byteorder The byte order of the register (used when width is > 1),
 * defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    2be0:	b5f0      	push	{r4, r5, r6, r7, lr}
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
  _spidevice = spidevice;
    2be2:	6042      	str	r2, [r0, #4]
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
    2be4:	f04f 0e00 	mov.w	lr, #0
 *    @param  byteorder The byte order of the register (used when width is > 1),
 * defaults to LSBFIRST
 *    @param  address_width The width of the register address itself, defaults
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    2be8:	f89d 7020 	ldrb.w	r7, [sp, #32]
    2bec:	f8bd 6014 	ldrh.w	r6, [sp, #20]
    2bf0:	f89d 501c 	ldrb.w	r5, [sp, #28]
    2bf4:	f89d 2018 	ldrb.w	r2, [sp, #24]
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
  _spidevice = spidevice;
  _i2cdevice = i2cdevice;
    2bf8:	6001      	str	r1, [r0, #0]
  _spiregtype = type;
    2bfa:	7203      	strb	r3, [r0, #8]
 * to 1 byte
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(
    Adafruit_I2CDevice *i2cdevice, Adafruit_SPIDevice *spidevice,
    Adafruit_BusIO_SPIRegType type, uint16_t reg_addr, uint8_t width,
    uint8_t byteorder, uint8_t address_width) {
    2bfc:	f8c0 e014 	str.w	lr, [r0, #20]
  _spidevice = spidevice;
  _i2cdevice = i2cdevice;
  _spiregtype = type;
  _addrwidth = address_width;
    2c00:	7347      	strb	r7, [r0, #13]
  _address = reg_addr;
    2c02:	8146      	strh	r6, [r0, #10]
  _byteorder = byteorder;
    2c04:	7385      	strb	r5, [r0, #14]
  _width = width;
    2c06:	7302      	strb	r2, [r0, #12]
}
    2c08:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2c0a:	bf00      	nop

00002c0c <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>:
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
    2c0c:	8943      	ldrh	r3, [r0, #10]
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    2c0e:	b5f0      	push	{r4, r5, r6, r7, lr}

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2c10:	b2dd      	uxtb	r5, r3
 *    @param  buffer Pointer to data to write
 *    @param  len Number of bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
    2c12:	b085      	sub	sp, #20

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2c14:	0a1b      	lsrs	r3, r3, #8

  if (_i2cdevice) {
    2c16:	6804      	ldr	r4, [r0, #0]
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {

  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2c18:	f88d 500c 	strb.w	r5, [sp, #12]
    2c1c:	f88d 300d 	strb.w	r3, [sp, #13]

  if (_i2cdevice) {
    2c20:	b14c      	cbz	r4, 2c36 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x2a>
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
    2c22:	7b46      	ldrb	r6, [r0, #13]
    2c24:	ad03      	add	r5, sp, #12
    2c26:	4620      	mov	r0, r4
    2c28:	2301      	movs	r3, #1
    2c2a:	e88d 0060 	stmia.w	sp, {r5, r6}
    2c2e:	f000 f949 	bl	2ec4 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>
      addrbuffer[0] |= 0x40;
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
  }
  return false;
}
    2c32:	b005      	add	sp, #20
    2c34:	bdf0      	pop	{r4, r5, r6, r7, pc}
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    return _i2cdevice->write(buffer, len, true, addrbuffer, _addrwidth);
  }
  if (_spidevice) {
    2c36:	f8d0 e004 	ldr.w	lr, [r0, #4]
    2c3a:	f1be 0f00 	cmp.w	lr, #0
    2c3e:	d023      	beq.n	2c88 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x7c>
    if (_spiregtype == ADDRESSED_OPCODE_BIT0_LOW_TO_WRITE) {
    2c40:	7a04      	ldrb	r4, [r0, #8]
    2c42:	2c03      	cmp	r4, #3
    2c44:	d022      	beq.n	2c8c <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x80>
    2c46:	460e      	mov	r6, r1
    2c48:	4617      	mov	r7, r2
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    }

    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    2c4a:	b96c      	cbnz	r4, 2c68 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x5c>
      addrbuffer[0] &= ~0x80;
    2c4c:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    2c50:	f88d 500c 	strb.w	r5, [sp, #12]
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
      addrbuffer[0] &= ~0x80;
      addrbuffer[0] |= 0x40;
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
    2c54:	7b43      	ldrb	r3, [r0, #13]
    2c56:	463a      	mov	r2, r7
    2c58:	4631      	mov	r1, r6
    2c5a:	4670      	mov	r0, lr
    2c5c:	9300      	str	r3, [sp, #0]
    2c5e:	ab03      	add	r3, sp, #12
    2c60:	f000 fb72 	bl	3348 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>
  }
  return false;
}
    2c64:	b005      	add	sp, #20
    2c66:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }

    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] &= ~0x80;
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOWRITE) {
    2c68:	2c02      	cmp	r4, #2
    2c6a:	d104      	bne.n	2c76 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x6a>
      addrbuffer[0] |= 0x80;
    2c6c:	f065 057f 	orn	r5, r5, #127	; 0x7f
    2c70:	f88d 500c 	strb.w	r5, [sp, #12]
    2c74:	e7ee      	b.n	2c54 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
    2c76:	2c01      	cmp	r4, #1
    2c78:	d1ec      	bne.n	2c54 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
      addrbuffer[0] &= ~0x80;
      addrbuffer[0] |= 0x40;
    2c7a:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    2c7e:	f045 0540 	orr.w	r5, r5, #64	; 0x40
    2c82:	f88d 500c 	strb.w	r5, [sp, #12]
    2c86:	e7e5      	b.n	2c54 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x48>
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
  }
  return false;
    2c88:	4670      	mov	r0, lr
    2c8a:	e7d2      	b.n	2c32 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x26>
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    2c8c:	7b46      	ldrb	r6, [r0, #13]
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
    2c8e:	f023 0401 	bic.w	r4, r3, #1
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    2c92:	4670      	mov	r0, lr
    2c94:	ab03      	add	r3, sp, #12
    2c96:	3601      	adds	r6, #1
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) & ~0x01; // set bottom bit low to write
    2c98:	f88d 400c 	strb.w	r4, [sp, #12]
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
    2c9c:	f88d 500d 	strb.w	r5, [sp, #13]
      // the address appears to be a byte longer
      return _spidevice->write(buffer, len, addrbuffer, _addrwidth + 1);
    2ca0:	9600      	str	r6, [sp, #0]
    2ca2:	f000 fb51 	bl	3348 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>
    2ca6:	e7c4      	b.n	2c32 <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)+0x26>

00002ca8 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>:
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
  if (numbytes == 0) {
    2ca8:	b902      	cbnz	r2, 2cac <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x4>
    numbytes = _width;
    2caa:	7b02      	ldrb	r2, [r0, #12]
  }
  if (numbytes > 4) {
    2cac:	2a04      	cmp	r2, #4
    2cae:	d818      	bhi.n	2ce2 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x3a>
 *    @param  value Data to write
 *    @param  numbytes How many bytes from 'value' to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint32_t value, uint8_t numbytes) {
    2cb0:	b4f0      	push	{r4, r5, r6, r7}
  if (numbytes > 4) {
    return false;
  }

  // store a copy
  _cached = value;
    2cb2:	6141      	str	r1, [r0, #20]
    2cb4:	f100 070f 	add.w	r7, r0, #15

  for (int i = 0; i < numbytes; i++) {
    2cb8:	b16a      	cbz	r2, 2cd6 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x2e>
    2cba:	f102 030e 	add.w	r3, r2, #14
    2cbe:	7b86      	ldrb	r6, [r0, #14]
    2cc0:	f100 050e 	add.w	r5, r0, #14
    2cc4:	463c      	mov	r4, r7
    2cc6:	4403      	add	r3, r0
    if (_byteorder == LSBFIRST) {
    2cc8:	b94e      	cbnz	r6, 2cde <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x36>
      _buffer[i] = value & 0xFF;
    2cca:	7021      	strb	r1, [r4, #0]
    2ccc:	3b01      	subs	r3, #1
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
    2cce:	0a09      	lsrs	r1, r1, #8
    2cd0:	3401      	adds	r4, #1
  }

  // store a copy
  _cached = value;

  for (int i = 0; i < numbytes; i++) {
    2cd2:	42ab      	cmp	r3, r5
    2cd4:	d1f8      	bne.n	2cc8 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x20>
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    2cd6:	4639      	mov	r1, r7
}
    2cd8:	bcf0      	pop	{r4, r5, r6, r7}
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
    2cda:	f7ff bf97 	b.w	2c0c <Adafruit_BusIO_Register::write(unsigned char*, unsigned char)>

  for (int i = 0; i < numbytes; i++) {
    if (_byteorder == LSBFIRST) {
      _buffer[i] = value & 0xFF;
    } else {
      _buffer[numbytes - i - 1] = value & 0xFF;
    2cde:	7019      	strb	r1, [r3, #0]
    2ce0:	e7f4      	b.n	2ccc <Adafruit_BusIO_Register::write(unsigned long, unsigned char)+0x24>
    }
    value >>= 8;
  }
  return write(_buffer, numbytes);
}
    2ce2:	2000      	movs	r0, #0
    2ce4:	4770      	bx	lr
    2ce6:	bf00      	nop

00002ce8 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>:
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    2ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
    2cea:	8944      	ldrh	r4, [r0, #10]
 *    @param  buffer Pointer to data to read into
 *    @param  len Number of bytes to read
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
    2cec:	b085      	sub	sp, #20
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    2cee:	6805      	ldr	r5, [r0, #0]
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2cf0:	b2e6      	uxtb	r6, r4
    2cf2:	0a24      	lsrs	r4, r4, #8
    2cf4:	f88d 600c 	strb.w	r6, [sp, #12]
    2cf8:	f88d 400d 	strb.w	r4, [sp, #13]

  if (_i2cdevice) {
    2cfc:	b15d      	cbz	r5, 2d16 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2e>
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    2cfe:	7b40      	ldrb	r0, [r0, #13]
    2d00:	2400      	movs	r4, #0
    2d02:	9200      	str	r2, [sp, #0]
    2d04:	460b      	mov	r3, r1
    2d06:	4602      	mov	r2, r0
    2d08:	9401      	str	r4, [sp, #4]
    2d0a:	4628      	mov	r0, r5
    2d0c:	a903      	add	r1, sp, #12
    2d0e:	f000 f96b 	bl	2fe8 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>
      addrbuffer[0] |= 0x80 | 0x40;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
}
    2d12:	b005      	add	sp, #20
    2d14:	bdf0      	pop	{r4, r5, r6, r7, pc}
                           (uint8_t)(_address >> 8)};

  if (_i2cdevice) {
    return _i2cdevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  if (_spidevice) {
    2d16:	6845      	ldr	r5, [r0, #4]
    2d18:	b30d      	cbz	r5, 2d5e <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x76>
    if (_spiregtype == ADDRESSED_OPCODE_BIT0_LOW_TO_WRITE) {
    2d1a:	7a03      	ldrb	r3, [r0, #8]
    2d1c:	2b03      	cmp	r3, #3
    2d1e:	d020      	beq.n	2d62 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x7a>
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
    2d20:	b97b      	cbnz	r3, 2d42 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x5a>
      addrbuffer[0] |= 0x80;
    2d22:	f066 067f 	orn	r6, r6, #127	; 0x7f
    2d26:	f88d 600c 	strb.w	r6, [sp, #12]
      addrbuffer[0] &= ~0x80;
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
      addrbuffer[0] |= 0x80 | 0x40;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
    2d2a:	7b40      	ldrb	r0, [r0, #13]
    2d2c:	24ff      	movs	r4, #255	; 0xff
    2d2e:	9200      	str	r2, [sp, #0]
    2d30:	460b      	mov	r3, r1
    2d32:	4602      	mov	r2, r0
    2d34:	a903      	add	r1, sp, #12
    2d36:	4628      	mov	r0, r5
    2d38:	9401      	str	r4, [sp, #4]
    2d3a:	f000 fb3b 	bl	33b4 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>
  }
  return false;
}
    2d3e:	b005      	add	sp, #20
    2d40:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         len);
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOREAD) {
      addrbuffer[0] |= 0x80;
    }
    if (_spiregtype == ADDRBIT8_HIGH_TOWRITE) {
    2d42:	2b02      	cmp	r3, #2
    2d44:	d104      	bne.n	2d50 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x68>
      addrbuffer[0] &= ~0x80;
    2d46:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    2d4a:	f88d 600c 	strb.w	r6, [sp, #12]
    2d4e:	e7ec      	b.n	2d2a <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
    }
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
    2d50:	2b01      	cmp	r3, #1
    2d52:	d1ea      	bne.n	2d2a <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
      addrbuffer[0] |= 0x80 | 0x40;
    2d54:	f066 063f 	orn	r6, r6, #63	; 0x3f
    2d58:	f88d 600c 	strb.w	r6, [sp, #12]
    2d5c:	e7e5      	b.n	2d2a <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x42>
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  return false;
    2d5e:	4628      	mov	r0, r5
    2d60:	e7d7      	b.n	2d12 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2a>
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    2d62:	7b43      	ldrb	r3, [r0, #13]
    2d64:	27ff      	movs	r7, #255	; 0xff
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
    2d66:	f044 0401 	orr.w	r4, r4, #1
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    2d6a:	9200      	str	r2, [sp, #0]
    2d6c:	4628      	mov	r0, r5
    2d6e:	1c5a      	adds	r2, r3, #1
    2d70:	9701      	str	r7, [sp, #4]
    2d72:	460b      	mov	r3, r1
    2d74:	a903      	add	r1, sp, #12
      // very special case!

      // pass the special opcode address which we set as the high byte of the
      // regaddr
      addrbuffer[0] =
          (uint8_t)(_address >> 8) | 0x01; // set bottom bit high to read
    2d76:	f88d 400c 	strb.w	r4, [sp, #12]
      // the 'actual' reg addr is the second byte then
      addrbuffer[1] = (uint8_t)(_address & 0xFF);
    2d7a:	f88d 600d 	strb.w	r6, [sp, #13]
      // the address appears to be a byte longer
      return _spidevice->write_then_read(addrbuffer, _addrwidth + 1, buffer,
                                         len);
    2d7e:	f000 fb19 	bl	33b4 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>
    2d82:	e7c6      	b.n	2d12 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)+0x2a>

00002d84 <Adafruit_BusIO_Register::read()>:
/*!
 *    @brief  Read data from the register location. This does not do any error
 * checking!
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    2d84:	b538      	push	{r3, r4, r5, lr}
  if (!read(_buffer, _width)) {
    2d86:	f100 040f 	add.w	r4, r0, #15
    2d8a:	7b02      	ldrb	r2, [r0, #12]
/*!
 *    @brief  Read data from the register location. This does not do any error
 * checking!
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
    2d8c:	4605      	mov	r5, r0
  if (!read(_buffer, _width)) {
    2d8e:	4621      	mov	r1, r4
    2d90:	f7ff ffaa 	bl	2ce8 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    2d94:	b910      	cbnz	r0, 2d9c <Adafruit_BusIO_Register::read()+0x18>
    return -1;
    2d96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
      value |= _buffer[i];
    }
  }

  return value;
}
    2d9a:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2d9c:	7b28      	ldrb	r0, [r5, #12]
    2d9e:	2800      	cmp	r0, #0
    2da0:	d0fb      	beq.n	2d9a <Adafruit_BusIO_Register::read()+0x16>
    2da2:	300e      	adds	r0, #14
    2da4:	4621      	mov	r1, r4
    2da6:	f105 020e 	add.w	r2, r5, #14
    2daa:	7bac      	ldrb	r4, [r5, #14]
    2dac:	182b      	adds	r3, r5, r0
    2dae:	2000      	movs	r0, #0
    2db0:	e006      	b.n	2dc0 <Adafruit_BusIO_Register::read()+0x3c>
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    2db2:	781d      	ldrb	r5, [r3, #0]
    2db4:	3b01      	subs	r3, #1
    2db6:	3101      	adds	r1, #1
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2db8:	4293      	cmp	r3, r2
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    2dba:	ea40 0005 	orr.w	r0, r0, r5
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2dbe:	d009      	beq.n	2dd4 <Adafruit_BusIO_Register::read()+0x50>
    value <<= 8;
    2dc0:	0200      	lsls	r0, r0, #8
    if (_byteorder == LSBFIRST) {
    2dc2:	2c00      	cmp	r4, #0
    2dc4:	d0f5      	beq.n	2db2 <Adafruit_BusIO_Register::read()+0x2e>
    2dc6:	3b01      	subs	r3, #1
      value |= _buffer[_width - i - 1];
    } else {
      value |= _buffer[i];
    2dc8:	780d      	ldrb	r5, [r1, #0]
    2dca:	3101      	adds	r1, #1
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2dcc:	4293      	cmp	r3, r2
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    } else {
      value |= _buffer[i];
    2dce:	ea40 0005 	orr.w	r0, r0, r5
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2dd2:	d1f5      	bne.n	2dc0 <Adafruit_BusIO_Register::read()+0x3c>
    2dd4:	bd38      	pop	{r3, r4, r5, pc}
    2dd6:	bf00      	nop

00002dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>:
 * touching other bits
 *    @param  reg The Adafruit_BusIO_Register which defines the bus/register
 *    @param  bits The number of bits wide we are slicing
 *    @param  shift The number of bits that our bit-slice is shifted from LSB
 */
Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(
    2dd8:	b410      	push	{r4}
    Adafruit_BusIO_Register *reg, uint8_t bits, uint8_t shift) {
  _register = reg;
    2dda:	6001      	str	r1, [r0, #0]
  _bits = bits;
    2ddc:	7102      	strb	r2, [r0, #4]
  _shift = shift;
    2dde:	7143      	strb	r3, [r0, #5]
}
    2de0:	f85d 4b04 	ldr.w	r4, [sp], #4
    2de4:	4770      	bx	lr
    2de6:	bf00      	nop

00002de8 <Adafruit_BusIO_RegisterBits::read()>:

/*!
 *    @brief  Read 4 bytes of data from the register
 *    @return  data The 4 bytes to read
 */
uint32_t Adafruit_BusIO_RegisterBits::read(void) {
    2de8:	b510      	push	{r4, lr}
    2dea:	4604      	mov	r4, r0
  uint32_t val = _register->read();
    2dec:	6800      	ldr	r0, [r0, #0]
    2dee:	f7ff ffc9 	bl	2d84 <Adafruit_BusIO_Register::read()>
  val >>= _shift;
  return val & ((1 << (_bits)) - 1);
    2df2:	2301      	movs	r3, #1
    2df4:	7921      	ldrb	r1, [r4, #4]
    2df6:	7962      	ldrb	r2, [r4, #5]
    2df8:	408b      	lsls	r3, r1
    2dfa:	40d0      	lsrs	r0, r2
    2dfc:	3b01      	subs	r3, #1
}
    2dfe:	4018      	ands	r0, r3
    2e00:	bd10      	pop	{r4, pc}
    2e02:	bf00      	nop

00002e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>:
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    2e04:	b538      	push	{r3, r4, r5, lr}
    2e06:	4605      	mov	r5, r0
  uint32_t val = _register->read();
    2e08:	6800      	ldr	r0, [r0, #0]
 *    @brief  Write 4 bytes of data to the register
 *    @param  data The 4 bytes to write
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
    2e0a:	460c      	mov	r4, r1
  uint32_t val = _register->read();
    2e0c:	f7ff ffba 	bl	2d84 <Adafruit_BusIO_Register::read()>

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    2e10:	792a      	ldrb	r2, [r5, #4]
    2e12:	2301      	movs	r3, #1
  data &= mask;

  mask <<= _shift;
    2e14:	7969      	ldrb	r1, [r5, #5]
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
  uint32_t val = _register->read();

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    2e16:	4093      	lsls	r3, r2

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2e18:	682d      	ldr	r5, [r5, #0]
 */
bool Adafruit_BusIO_RegisterBits::write(uint32_t data) {
  uint32_t val = _register->read();

  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
    2e1a:	3b01      	subs	r3, #1

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2e1c:	7b2a      	ldrb	r2, [r5, #12]
    2e1e:	401c      	ands	r4, r3
  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
  data &= mask;

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
    2e20:	408b      	lsls	r3, r1
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2e22:	fa04 f101 	lsl.w	r1, r4, r1
  // mask off the data before writing
  uint32_t mask = (1 << (_bits)) - 1;
  data &= mask;

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
    2e26:	ea20 0303 	bic.w	r3, r0, r3
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2e2a:	4628      	mov	r0, r5
    2e2c:	4319      	orrs	r1, r3
}
    2e2e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  mask <<= _shift;
  val &= ~mask;          // remove the current data at that spot
  val |= data << _shift; // and add in the new data

  return _register->write(val, _register->width());
    2e32:	f7ff bf39 	b.w	2ca8 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>
    2e36:	bf00      	nop

00002e38 <TwoWire::read()>:
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2e38:	f890 30a2 	ldrb.w	r3, [r0, #162]	; 0xa2
    2e3c:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    2e40:	429a      	cmp	r2, r3
    2e42:	d905      	bls.n	2e50 <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    2e44:	1c5a      	adds	r2, r3, #1
    2e46:	4403      	add	r3, r0
    2e48:	f880 20a2 	strb.w	r2, [r0, #162]	; 0xa2
    2e4c:	7e98      	ldrb	r0, [r3, #26]
    2e4e:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2e50:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    2e54:	4770      	bx	lr
    2e56:	bf00      	nop

00002e58 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>:
/*!
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
    2e58:	b430      	push	{r4, r5}
  _addr = addr;
  _wire = theWire;
  _begun = false;
    2e5a:	2500      	movs	r5, #0
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
    2e5c:	2420      	movs	r4, #32
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
    2e5e:	7001      	strb	r1, [r0, #0]
  _wire = theWire;
  _begun = false;
    2e60:	7205      	strb	r5, [r0, #8]
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
    2e62:	60c4      	str	r4, [r0, #12]
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
  _wire = theWire;
    2e64:	6042      	str	r2, [r0, #4]
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
#endif
}
    2e66:	bc30      	pop	{r4, r5}
    2e68:	4770      	bx	lr
    2e6a:	bf00      	nop

00002e6c <Adafruit_I2CDevice::detected()>:
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    2e6c:	7a03      	ldrb	r3, [r0, #8]
/*!
 *    @brief  Scans I2C for the address - note will give a false-positive
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
    2e6e:	b510      	push	{r4, lr}
    2e70:	4604      	mov	r4, r0
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    2e72:	b18b      	cbz	r3, 2e98 <Adafruit_I2CDevice::detected()+0x2c>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2e74:	7820      	ldrb	r0, [r4, #0]
		transmitting = 1;
    2e76:	2201      	movs	r2, #1
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
    2e78:	6863      	ldr	r3, [r4, #4]
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2e7a:	4090      	lsls	r0, r2
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    2e7c:	4611      	mov	r1, r2
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    2e7e:	f883 2130 	strb.w	r2, [r3, #304]	; 0x130
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2e82:	f883 00a5 	strb.w	r0, [r3, #165]	; 0xa5
		transmitting = 1;
		txBufferLength = 1;
    2e86:	f883 212f 	strb.w	r2, [r3, #303]	; 0x12f
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    2e8a:	6860      	ldr	r0, [r4, #4]
    2e8c:	f001 fb4a 	bl	4524 <TwoWire::endTransmission(unsigned char)>
  if (_wire->endTransmission() == 0) {
    2e90:	fab0 f080 	clz	r0, r0
    2e94:	0940      	lsrs	r0, r0, #5
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    2e96:	bd10      	pop	{r4, pc}
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    2e98:	2101      	movs	r1, #1
    2e9a:	f000 f803 	bl	2ea4 <Adafruit_I2CDevice::begin(bool)>
    2e9e:	2800      	cmp	r0, #0
    2ea0:	d1e8      	bne.n	2e74 <Adafruit_I2CDevice::detected()+0x8>
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
    2ea2:	bd10      	pop	{r4, pc}

00002ea4 <Adafruit_I2CDevice::begin(bool)>:
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    2ea4:	b538      	push	{r3, r4, r5, lr}
    2ea6:	4604      	mov	r4, r0
  _wire->begin();
    2ea8:	6840      	ldr	r0, [r0, #4]
 *    @param  addr_detect Whether we should attempt to detect the I2C address
 * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
    2eaa:	460d      	mov	r5, r1
  _wire->begin();
    2eac:	f007 f9bc 	bl	a228 <___ZN7TwoWire5beginEv_veneer>
  _begun = true;
    2eb0:	2001      	movs	r0, #1
    2eb2:	7220      	strb	r0, [r4, #8]

  if (addr_detect) {
    2eb4:	b905      	cbnz	r5, 2eb8 <Adafruit_I2CDevice::begin(bool)+0x14>
    return detected();
  }
  return true;
}
    2eb6:	bd38      	pop	{r3, r4, r5, pc}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    2eb8:	4620      	mov	r0, r4
  }
  return true;
}
    2eba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;

  if (addr_detect) {
    return detected();
    2ebe:	f7ff bfd5 	b.w	2e6c <Adafruit_I2CDevice::detected()>
    2ec2:	bf00      	nop

00002ec4 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>:
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    2ec4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2ec8:	9e07      	ldr	r6, [sp, #28]
  if ((len + prefix_len) > maxBufferSize()) {
    2eca:	68c4      	ldr	r4, [r0, #12]
    2ecc:	1995      	adds	r5, r2, r6
    2ece:	42a5      	cmp	r5, r4
    2ed0:	d818      	bhi.n	2f04 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x40>
    2ed2:	4698      	mov	r8, r3
    2ed4:	460f      	mov	r7, r1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2ed6:	7803      	ldrb	r3, [r0, #0]
		transmitting = 1;
    2ed8:	2101      	movs	r1, #1
    2eda:	4615      	mov	r5, r2
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    2edc:	6842      	ldr	r2, [r0, #4]
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2ede:	408b      	lsls	r3, r1
    2ee0:	4604      	mov	r4, r0
		transmitting = 1;
    2ee2:	f882 1130 	strb.w	r1, [r2, #304]	; 0x130
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2ee6:	f882 30a5 	strb.w	r3, [r2, #165]	; 0xa5
		transmitting = 1;
		txBufferLength = 1;
    2eea:	f882 112f 	strb.w	r1, [r2, #303]	; 0x12f

  // Write the prefix data (usually an address)
  if ((prefix_len != 0) && (prefix_buffer != nullptr)) {
    2eee:	b166      	cbz	r6, 2f0a <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    2ef0:	9b06      	ldr	r3, [sp, #24]
    2ef2:	b153      	cbz	r3, 2f0a <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {
    2ef4:	6840      	ldr	r0, [r0, #4]
    2ef6:	4632      	mov	r2, r6
    2ef8:	9906      	ldr	r1, [sp, #24]
    2efa:	6803      	ldr	r3, [r0, #0]
    2efc:	685b      	ldr	r3, [r3, #4]
    2efe:	4798      	blx	r3
    2f00:	4286      	cmp	r6, r0
    2f02:	d002      	beq.n	2f0a <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x46>
    // we will need to find out if some platforms have larger
    // I2C buffer sizes :/
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
    2f04:	2000      	movs	r0, #0
    2f06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    2f0a:	6860      	ldr	r0, [r4, #4]
    2f0c:	4639      	mov	r1, r7
    2f0e:	462a      	mov	r2, r5
    2f10:	6803      	ldr	r3, [r0, #0]
    2f12:	685b      	ldr	r3, [r3, #4]
    2f14:	4798      	blx	r3
    2f16:	4285      	cmp	r5, r0
    2f18:	d1f4      	bne.n	2f04 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)+0x40>
  if (stop) {
    DEBUG_SERIAL.print("\tSTOP");
  }
#endif

  if (_wire->endTransmission(stop) == 0) {
    2f1a:	4641      	mov	r1, r8
    2f1c:	6860      	ldr	r0, [r4, #4]
    2f1e:	f001 fb01 	bl	4524 <TwoWire::endTransmission(unsigned char)>
    2f22:	fab0 f080 	clz	r0, r0
    2f26:	0940      	lsrs	r0, r0, #5
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("\tFailed to send!");
#endif
    return false;
  }
}
    2f28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00002f2c <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>:
    pos += read_len;
  }
  return true;
}

bool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {
    2f2c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2f30:	4615      	mov	r5, r2
    2f32:	4606      	mov	r6, r0
    2f34:	460f      	mov	r7, r1
#if defined(TinyWireM_h)
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#elif defined(ARDUINO_ARCH_MEGAAVR)
  size_t recv = _wire->requestFrom(_addr, len, stop);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
    2f36:	b2d2      	uxtb	r2, r2
    2f38:	7801      	ldrb	r1, [r0, #0]
    2f3a:	6840      	ldr	r0, [r0, #4]
    2f3c:	f001 fb62 	bl	4604 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
#endif

  if (recv != len) {
    2f40:	4285      	cmp	r5, r0
    2f42:	d002      	beq.n	2f4a <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x1e>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    2f44:	2000      	movs	r0, #0
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    2f46:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    2f4a:	b30d      	cbz	r5, 2f90 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x64>
    2f4c:	2300      	movs	r3, #0
    2f4e:	f8df 904c 	ldr.w	r9, [pc, #76]	; 2f9c <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x70>
    2f52:	461c      	mov	r4, r3
    2f54:	e012      	b.n	2f7c <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x50>
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2f56:	f890 20a2 	ldrb.w	r2, [r0, #162]	; 0xa2
    2f5a:	f890 30a3 	ldrb.w	r3, [r0, #163]	; 0xa3
		return rxBuffer[rxBufferIndex++];
    2f5e:	f102 0e01 	add.w	lr, r2, #1
    2f62:	1881      	adds	r1, r0, r2
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2f64:	4293      	cmp	r3, r2
    2f66:	d916      	bls.n	2f96 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x6a>
		return rxBuffer[rxBufferIndex++];
    2f68:	f880 e0a2 	strb.w	lr, [r0, #162]	; 0xa2
    2f6c:	7e88      	ldrb	r0, [r1, #26]
    2f6e:	3401      	adds	r4, #1
    buffer[i] = _wire->read();
    2f70:	f888 0000 	strb.w	r0, [r8]
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    2f74:	b2a4      	uxth	r4, r4
    2f76:	42a5      	cmp	r5, r4
    2f78:	4623      	mov	r3, r4
    2f7a:	d909      	bls.n	2f90 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x64>
    buffer[i] = _wire->read();
    2f7c:	6870      	ldr	r0, [r6, #4]
    2f7e:	eb07 0803 	add.w	r8, r7, r3
    2f82:	6803      	ldr	r3, [r0, #0]
    2f84:	695a      	ldr	r2, [r3, #20]
    2f86:	454a      	cmp	r2, r9
    2f88:	d0e5      	beq.n	2f56 <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x2a>
    2f8a:	4790      	blx	r2
    2f8c:	b2c0      	uxtb	r0, r0
    2f8e:	e7ee      	b.n	2f6e <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x42>
    // Not enough data available to fulfill our obligation!
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.print(F("\tI2CDevice did not receive enough data: "));
    DEBUG_SERIAL.println(recv);
#endif
    return false;
    2f90:	2001      	movs	r0, #1
    2f92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2f96:	20ff      	movs	r0, #255	; 0xff
    2f98:	e7e9      	b.n	2f6e <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)+0x42>
    2f9a:	bf00      	nop
    2f9c:	00002e39 	.word	0x00002e39

00002fa0 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    2fa0:	b302      	cbz	r2, 2fe4 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x44>
 *    @param  buffer Pointer to buffer of data to read into
 *    @param  len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
    2fa2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2fa6:	4616      	mov	r6, r2
    2fa8:	4699      	mov	r9, r3
    2faa:	4688      	mov	r8, r1
    2fac:	4607      	mov	r7, r0
  size_t pos = 0;
  while (pos < len) {
    2fae:	2400      	movs	r4, #0
    2fb0:	e001      	b.n	2fb6 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x16>
    2fb2:	42a6      	cmp	r6, r4
    2fb4:	d913      	bls.n	2fde <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x3e>
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    2fb6:	1b32      	subs	r2, r6, r4
    2fb8:	68fd      	ldr	r5, [r7, #12]
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
    2fba:	eb08 0104 	add.w	r1, r8, r4
    2fbe:	4638      	mov	r0, r7
    2fc0:	42aa      	cmp	r2, r5
    2fc2:	bf28      	it	cs
    2fc4:	462a      	movcs	r2, r5
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    2fc6:	1ab3      	subs	r3, r6, r2
    if (!_read(buffer + pos, read_len, read_stop))
    2fc8:	42a3      	cmp	r3, r4
    2fca:	bf94      	ite	ls
    2fcc:	464b      	movls	r3, r9
    2fce:	2300      	movhi	r3, #0
      return false;
    pos += read_len;
    2fd0:	4414      	add	r4, r2
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
    2fd2:	f7ff ffab 	bl	2f2c <Adafruit_I2CDevice::_read(unsigned char*, unsigned int, bool)>
    2fd6:	2800      	cmp	r0, #0
    2fd8:	d1eb      	bne.n	2fb2 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)+0x12>
      return false;
    pos += read_len;
  }
  return true;
}
    2fda:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
      return false;
    pos += read_len;
  }
  return true;
    2fde:	2001      	movs	r0, #1
    2fe0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2fe4:	2001      	movs	r0, #1
}
    2fe6:	4770      	bx	lr

00002fe8 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)>:
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    2fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2fea:	b083      	sub	sp, #12
  if (!write(write_buffer, write_len, stop)) {
    2fec:	2400      	movs	r4, #0
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    2fee:	461f      	mov	r7, r3
    2ff0:	4606      	mov	r6, r0
    2ff2:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  if (!write(write_buffer, write_len, stop)) {
    2ff6:	9401      	str	r4, [sp, #4]
    2ff8:	9400      	str	r4, [sp, #0]
    2ffa:	462b      	mov	r3, r5
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
    2ffc:	9c08      	ldr	r4, [sp, #32]
  if (!write(write_buffer, write_len, stop)) {
    2ffe:	f7ff ff61 	bl	2ec4 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int)>
    3002:	b908      	cbnz	r0, 3008 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool)+0x20>
    return false;
  }

  return read(read_buffer, read_len);
}
    3004:	b003      	add	sp, #12
    3006:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
    3008:	4622      	mov	r2, r4
    300a:	4639      	mov	r1, r7
    300c:	4630      	mov	r0, r6
    300e:	2301      	movs	r3, #1
}
    3010:	b003      	add	sp, #12
    3012:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
    3016:	f7ff bfc3 	b.w	2fa0 <Adafruit_I2CDevice::read(unsigned char*, unsigned int, bool)>
    301a:	bf00      	nop

0000301c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>:
 *    @brief  Transfer (send/receive) a buffer over hard/soft SPI, without
 * transaction management
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    301c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // HARDWARE SPI
  //
  if (_spi) {
    3020:	6804      	ldr	r4, [r0, #0]
 *    @brief  Transfer (send/receive) a buffer over hard/soft SPI, without
 * transaction management
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
    3022:	4613      	mov	r3, r2
    3024:	b085      	sub	sp, #20
    3026:	460a      	mov	r2, r1
  //
  // HARDWARE SPI
  //
  if (_spi) {
    3028:	b12c      	cbz	r4, 3036 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x1a>
				transfer16(buf, buf, count >> 1);
				return;
			}
		}
#endif
		transfer(buf, buf, count);
    302a:	4620      	mov	r0, r4
        buffer[i] = reply;
      }
    }
  }
  return;
}
    302c:	b005      	add	sp, #20
    302e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3032:	f001 b97f 	b.w	4334 <SPIClass::transfer(void const*, void*, unsigned int)>

  //
  // SOFTWARE SPI
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    3036:	7b04      	ldrb	r4, [r0, #12]
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    3038:	4959      	ldr	r1, [pc, #356]	; (31a0 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x184>)
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    303a:	2c00      	cmp	r4, #0
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    303c:	6886      	ldr	r6, [r0, #8]
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    303e:	7814      	ldrb	r4, [r2, #0]
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    3040:	bf0c      	ite	eq
    3042:	2501      	moveq	r5, #1
    3044:	2580      	movne	r5, #128	; 0x80
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    3046:	fbb1 f6f6 	udiv	r6, r1, r6
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    304a:	4225      	tst	r5, r4
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    startbit = 0x1;
  } else {
    startbit = 0x80;
    304c:	9502      	str	r5, [sp, #8]
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    304e:	b2f6      	uxtb	r6, r6
    startbit = 0x1;
  } else {
    startbit = 0x80;
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    3050:	bf0c      	ite	eq
    3052:	2101      	moveq	r1, #1
    3054:	2100      	movne	r1, #0
    3056:	9100      	str	r1, [sp, #0]
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    3058:	2b00      	cmp	r3, #0
    305a:	d063      	beq.n	3124 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x108>
    305c:	4690      	mov	r8, r2
    305e:	4683      	mov	fp, r0
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3060:	4c50      	ldr	r4, [pc, #320]	; (31a4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x188>)
    3062:	4443      	add	r3, r8
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3064:	f8df 9144 	ldr.w	r9, [pc, #324]	; 31ac <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x190>
    3068:	9303      	str	r3, [sp, #12]
    uint8_t reply = 0;
    uint8_t send = buffer[i];
    306a:	f818 ab01 	ldrb.w	sl, [r8], #1
    306e:	465b      	mov	r3, fp
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    3070:	9d02      	ldr	r5, [sp, #8]

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    uint8_t reply = 0;
    3072:	2700      	movs	r7, #0
    3074:	46c3      	mov	fp, r8
    3076:	4698      	mov	r8, r3

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
    3078:	2e00      	cmp	r6, #0
    307a:	d05a      	beq.n	3132 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x116>
    307c:	4a4a      	ldr	r2, [pc, #296]	; (31a8 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x18c>)
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    307e:	6823      	ldr	r3, [r4, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3080:	6810      	ldr	r0, [r2, #0]
    3082:	fba9 1000 	umull	r1, r0, r9, r0
    3086:	0c80      	lsrs	r0, r0, #18
    3088:	fb00 f006 	mul.w	r0, r0, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    308c:	6821      	ldr	r1, [r4, #0]
    308e:	1ac9      	subs	r1, r1, r3
    3090:	4288      	cmp	r0, r1
    3092:	d8fb      	bhi.n	308c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x70>
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    3094:	f898 100d 	ldrb.w	r1, [r8, #13]
    3098:	f011 0ff7 	tst.w	r1, #247	; 0xf7
    309c:	d16c      	bne.n	3178 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x15c>
        towrite = send & b;
    309e:	ea1a 0f05 	tst.w	sl, r5
        if ((_mosi != -1) && (lastmosi != towrite)) {
    30a2:	f998 0010 	ldrsb.w	r0, [r8, #16]
      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
        towrite = send & b;
    30a6:	bf14      	ite	ne
    30a8:	2101      	movne	r1, #1
    30aa:	2100      	moveq	r1, #0
        if ((_mosi != -1) && (lastmosi != towrite)) {
    30ac:	1c43      	adds	r3, r0, #1
    30ae:	d006      	beq.n	30be <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xa2>
    30b0:	9b00      	ldr	r3, [sp, #0]
    30b2:	4299      	cmp	r1, r3
    30b4:	d003      	beq.n	30be <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xa2>
          if (towrite)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
#else
          digitalWrite(_mosi, towrite);
    30b6:	b2c0      	uxtb	r0, r0
    30b8:	9100      	str	r1, [sp, #0]
    30ba:	f7fe f951 	bl	1360 <digitalWrite>
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    30be:	2101      	movs	r1, #1
    30c0:	f898 000f 	ldrb.w	r0, [r8, #15]
    30c4:	f7fe f94c 	bl	1360 <digitalWrite>
#endif

        if (bitdelay_us) {
    30c8:	b15e      	cbz	r6, 30e2 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xc6>
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    30ca:	4a37      	ldr	r2, [pc, #220]	; (31a8 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x18c>)
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    30cc:	6820      	ldr	r0, [r4, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    30ce:	6811      	ldr	r1, [r2, #0]
    30d0:	fba9 3101 	umull	r3, r1, r9, r1
    30d4:	0c89      	lsrs	r1, r1, #18
    30d6:	fb01 f106 	mul.w	r1, r1, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    30da:	6823      	ldr	r3, [r4, #0]
    30dc:	1a1b      	subs	r3, r3, r0
    30de:	4299      	cmp	r1, r3
    30e0:	d8fb      	bhi.n	30da <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xbe>
          delayMicroseconds(bitdelay_us);
        }

        if (_miso != -1) {
    30e2:	f998 0011 	ldrsb.w	r0, [r8, #17]
    30e6:	1c41      	adds	r1, r0, #1
    30e8:	d004      	beq.n	30f4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xd8>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
#else
          if (digitalRead(_miso)) {
    30ea:	b2c0      	uxtb	r0, r0
    30ec:	f7fe f93e 	bl	136c <digitalRead>
    30f0:	b100      	cbz	r0, 30f4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xd8>
#endif
            reply |= b;
    30f2:	432f      	orrs	r7, r5
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
#else
        digitalWrite(_sck, LOW);
    30f4:	2100      	movs	r1, #0
    30f6:	f898 000f 	ldrb.w	r0, [r8, #15]
    30fa:	f7fe f931 	bl	1360 <digitalWrite>
#endif
            reply |= b;
          }
        }
      }
      if (_miso != -1) {
    30fe:	f998 2011 	ldrsb.w	r2, [r8, #17]
    3102:	3201      	adds	r2, #1
        buffer[i] = reply;
    3104:	bf18      	it	ne
    3106:	f80b 7c01 	strbne.w	r7, [fp, #-1]
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    310a:	f898 200c 	ldrb.w	r2, [r8, #12]
    310e:	b962      	cbnz	r2, 312a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x10e>
    3110:	006d      	lsls	r5, r5, #1
    3112:	b2ed      	uxtb	r5, r5
    3114:	2d00      	cmp	r5, #0
    3116:	d1af      	bne.n	3078 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
    3118:	4643      	mov	r3, r8
    311a:	46d8      	mov	r8, fp
    311c:	469b      	mov	fp, r3
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  for (size_t i = 0; i < len; i++) {
    311e:	9b03      	ldr	r3, [sp, #12]
    3120:	4543      	cmp	r3, r8
    3122:	d1a2      	bne.n	306a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x4e>
        buffer[i] = reply;
      }
    }
  }
  return;
}
    3124:	b005      	add	sp, #20
    3126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    312a:	086d      	lsrs	r5, r5, #1
    312c:	2d00      	cmp	r5, #0
    312e:	d1a3      	bne.n	3078 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x5c>
    3130:	e7f2      	b.n	3118 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xfc>

      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    3132:	f898 200d 	ldrb.w	r2, [r8, #13]
    3136:	f012 0ff7 	tst.w	r2, #247	; 0xf7
    313a:	d0b0      	beq.n	309e <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x82>
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    313c:	2101      	movs	r1, #1
    313e:	f898 000f 	ldrb.w	r0, [r8, #15]
    3142:	f7fe f90d 	bl	1360 <digitalWrite>

        if (bitdelay_us) {
          delayMicroseconds(bitdelay_us);
        }

        if (_mosi != -1) {
    3146:	f998 0010 	ldrsb.w	r0, [r8, #16]
    314a:	1c42      	adds	r2, r0, #1
    314c:	d004      	beq.n	3158 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x13c>
          if (send & b)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
#else
          digitalWrite(_mosi, send & b);
    314e:	b2c0      	uxtb	r0, r0
    3150:	ea0a 0105 	and.w	r1, sl, r5
    3154:	f7fe f904 	bl	1360 <digitalWrite>
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
#else
        digitalWrite(_sck, LOW);
    3158:	f898 000f 	ldrb.w	r0, [r8, #15]
    315c:	2100      	movs	r1, #0
    315e:	f7fe f8ff 	bl	1360 <digitalWrite>
#endif

        if (_miso != -1) {
    3162:	f998 0011 	ldrsb.w	r0, [r8, #17]
    3166:	1c43      	adds	r3, r0, #1
    3168:	d0cf      	beq.n	310a <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xee>
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
#else
          if (digitalRead(_miso)) {
    316a:	b2c0      	uxtb	r0, r0
    316c:	f7fe f8fe 	bl	136c <digitalRead>
    3170:	2800      	cmp	r0, #0
    3172:	d0c4      	beq.n	30fe <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xe2>
#endif
            reply |= b;
    3174:	432f      	orrs	r7, r5
    3176:	e7c2      	b.n	30fe <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0xe2>
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
#else
        digitalWrite(_sck, HIGH);
    3178:	2101      	movs	r1, #1
    317a:	f898 000f 	ldrb.w	r0, [r8, #15]
    317e:	9201      	str	r2, [sp, #4]
    3180:	f7fe f8ee 	bl	1360 <digitalWrite>
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3184:	4b07      	ldr	r3, [pc, #28]	; (31a4 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x188>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3186:	9a01      	ldr	r2, [sp, #4]
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3188:	6818      	ldr	r0, [r3, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    318a:	6811      	ldr	r1, [r2, #0]
    318c:	fba9 3101 	umull	r3, r1, r9, r1
    3190:	0c89      	lsrs	r1, r1, #18
    3192:	fb01 f106 	mul.w	r1, r1, r6
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    3196:	6823      	ldr	r3, [r4, #0]
    3198:	1a1b      	subs	r3, r3, r0
    319a:	4299      	cmp	r1, r3
    319c:	d8fb      	bhi.n	3196 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x17a>
    319e:	e7d2      	b.n	3146 <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)+0x12a>
    31a0:	0007a120 	.word	0x0007a120
    31a4:	e0001004 	.word	0xe0001004
    31a8:	20001478 	.word	0x20001478
    31ac:	431bde83 	.word	0x431bde83

000031b0 <Adafruit_SPIDevice::endTransaction()>:

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 */
void Adafruit_SPIDevice::endTransaction(void) {
  if (_spi) {
    31b0:	6802      	ldr	r2, [r0, #0]
    31b2:	b1f2      	cbz	r2, 31f2 <Adafruit_SPIDevice::endTransaction()+0x42>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    31b4:	7cd3      	ldrb	r3, [r2, #19]
    31b6:	b1e3      	cbz	r3, 31f2 <Adafruit_SPIDevice::endTransaction()+0x42>
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
    31b8:	07d8      	lsls	r0, r3, #31
    31ba:	d503      	bpl.n	31c4 <Adafruit_SPIDevice::endTransaction()+0x14>
    31bc:	4b0d      	ldr	r3, [pc, #52]	; (31f4 <Adafruit_SPIDevice::endTransaction()+0x44>)
    31be:	6a91      	ldr	r1, [r2, #40]	; 0x28
    31c0:	6019      	str	r1, [r3, #0]
    31c2:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
    31c4:	0799      	lsls	r1, r3, #30
    31c6:	d503      	bpl.n	31d0 <Adafruit_SPIDevice::endTransaction()+0x20>
    31c8:	4b0b      	ldr	r3, [pc, #44]	; (31f8 <Adafruit_SPIDevice::endTransaction()+0x48>)
    31ca:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    31cc:	6019      	str	r1, [r3, #0]
    31ce:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
    31d0:	0758      	lsls	r0, r3, #29
    31d2:	d503      	bpl.n	31dc <Adafruit_SPIDevice::endTransaction()+0x2c>
    31d4:	4b09      	ldr	r3, [pc, #36]	; (31fc <Adafruit_SPIDevice::endTransaction()+0x4c>)
    31d6:	6b11      	ldr	r1, [r2, #48]	; 0x30
    31d8:	6019      	str	r1, [r3, #0]
    31da:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
    31dc:	0719      	lsls	r1, r3, #28
    31de:	d503      	bpl.n	31e8 <Adafruit_SPIDevice::endTransaction()+0x38>
    31e0:	4b07      	ldr	r3, [pc, #28]	; (3200 <Adafruit_SPIDevice::endTransaction()+0x50>)
    31e2:	6b51      	ldr	r1, [r2, #52]	; 0x34
    31e4:	6019      	str	r1, [r3, #0]
    31e6:	7cd3      	ldrb	r3, [r2, #19]
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
    31e8:	06db      	lsls	r3, r3, #27
    31ea:	d502      	bpl.n	31f2 <Adafruit_SPIDevice::endTransaction()+0x42>
    31ec:	6b92      	ldr	r2, [r2, #56]	; 0x38
    31ee:	4b05      	ldr	r3, [pc, #20]	; (3204 <Adafruit_SPIDevice::endTransaction()+0x54>)
    31f0:	601a      	str	r2, [r3, #0]
    31f2:	4770      	bx	lr
    31f4:	e000e100 	.word	0xe000e100
    31f8:	e000e104 	.word	0xe000e104
    31fc:	e000e108 	.word	0xe000e108
    3200:	e000e10c 	.word	0xe000e10c
    3204:	e000e110 	.word	0xe000e110

00003208 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>:
/*!
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 * SPI)
 */
void Adafruit_SPIDevice::beginTransaction(void) {
  if (_spi) {
    3208:	6803      	ldr	r3, [r0, #0]
 *    @brief  Write a buffer or two to the SPI device, with transaction
 * management.
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
    320a:	b470      	push	{r4, r5, r6}
/*!
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 * SPI)
 */
void Adafruit_SPIDevice::beginTransaction(void) {
  if (_spi) {
    320c:	2b00      	cmp	r3, #0
    320e:	d02d      	beq.n	326c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x64>
#ifdef BUSIO_HAS_HW_SPI
    _spi->beginTransaction(*_spiSetting);
    3210:	6842      	ldr	r2, [r0, #4]

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    3212:	7cdc      	ldrb	r4, [r3, #19]
    3214:	e892 0022 	ldmia.w	r2, {r1, r5}
    3218:	2c00      	cmp	r4, #0
    321a:	d130      	bne.n	327e <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x76>
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
    321c:	689a      	ldr	r2, [r3, #8]
    321e:	428a      	cmp	r2, r1
    3220:	d05f      	beq.n	32e2 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xda>
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
    3222:	4a39      	ldr	r2, [pc, #228]	; (3308 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x100>)
						     720000000,  // PLL3 PFD0
						     528000000,  // PLL2
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();
    3224:	6099      	str	r1, [r3, #8]

			uint32_t cbcmr = CCM_CBCMR;
    3226:	6992      	ldr	r2, [r2, #24]
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
    3228:	4c38      	ldr	r4, [pc, #224]	; (330c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x104>)
    322a:	f3c2 1601 	ubfx	r6, r2, #4, #2
    322e:	f3c2 6282 	ubfx	r2, r2, #26, #3
    3232:	f854 4026 	ldr.w	r4, [r4, r6, lsl #2]
    3236:	3201      	adds	r2, #1
    3238:	fbb4 f4f2 	udiv	r4, r4, r2
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
    323c:	2900      	cmp	r1, #0
    323e:	d052      	beq.n	32e6 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xde>
    3240:	fbb4 f2f1 	udiv	r2, r4, r1

			if (d && clkhz/d > _clock) d++;
    3244:	b142      	cbz	r2, 3258 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    3246:	fbb4 f4f2 	udiv	r4, r4, r2
    324a:	428c      	cmp	r4, r1
    324c:	bf88      	it	hi
    324e:	3201      	addhi	r2, #1
			if (d > 257) d= 257;  // max div
    3250:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
    3254:	d34b      	bcc.n	32ee <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xe6>
    3256:	4a2e      	ldr	r2, [pc, #184]	; (3310 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x108>)
				div = d-2;
			} else {
				div =0;
			}
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);
    3258:	60da      	str	r2, [r3, #12]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    325a:	681b      	ldr	r3, [r3, #0]
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
    325c:	2600      	movs	r6, #0
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
    325e:	2403      	movs	r4, #3
		port().CCR = _ccr;
		port().TCR = settings.tcr;
		port().CR = LPSPI_CR_MEN;
    3260:	2101      	movs	r1, #1
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
    3262:	611e      	str	r6, [r3, #16]
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
    3264:	625c      	str	r4, [r3, #36]	; 0x24
		port().CCR = _ccr;
    3266:	641a      	str	r2, [r3, #64]	; 0x40
		port().TCR = settings.tcr;
    3268:	661d      	str	r5, [r3, #96]	; 0x60
		port().CR = LPSPI_CR_MEN;
    326a:	6119      	str	r1, [r3, #16]
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    326c:	f990 000e 	ldrsb.w	r0, [r0, #14]
    3270:	1c43      	adds	r3, r0, #1
    3272:	d03a      	beq.n	32ea <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xe2>
    digitalWrite(_cs, value);
    3274:	b2c0      	uxtb	r0, r0
    3276:	2100      	movs	r1, #0
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    3278:	bc70      	pop	{r4, r5, r6}
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    digitalWrite(_cs, value);
    327a:	f7fe b871 	b.w	1360 <digitalWrite>
	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
			__disable_irq();
    327e:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    3280:	7cda      	ldrb	r2, [r3, #19]
    3282:	07d6      	lsls	r6, r2, #31
    3284:	d506      	bpl.n	3294 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x8c>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    3286:	4c23      	ldr	r4, [pc, #140]	; (3314 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x10c>)
    3288:	695a      	ldr	r2, [r3, #20]
    328a:	6826      	ldr	r6, [r4, #0]
    328c:	4032      	ands	r2, r6
    328e:	629a      	str	r2, [r3, #40]	; 0x28
				NVIC_ICER0 = interruptSave[0];
    3290:	6022      	str	r2, [r4, #0]
    3292:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x02) {
    3294:	0794      	lsls	r4, r2, #30
    3296:	d506      	bpl.n	32a6 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x9e>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    3298:	4c1f      	ldr	r4, [pc, #124]	; (3318 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x110>)
    329a:	699a      	ldr	r2, [r3, #24]
    329c:	6826      	ldr	r6, [r4, #0]
    329e:	4032      	ands	r2, r6
    32a0:	62da      	str	r2, [r3, #44]	; 0x2c
				NVIC_ICER1 = interruptSave[1];
    32a2:	6022      	str	r2, [r4, #0]
    32a4:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x04) {
    32a6:	0756      	lsls	r6, r2, #29
    32a8:	d506      	bpl.n	32b8 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xb0>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    32aa:	4c1c      	ldr	r4, [pc, #112]	; (331c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x114>)
    32ac:	69da      	ldr	r2, [r3, #28]
    32ae:	6826      	ldr	r6, [r4, #0]
    32b0:	4032      	ands	r2, r6
    32b2:	631a      	str	r2, [r3, #48]	; 0x30
				NVIC_ICER2 = interruptSave[2];
    32b4:	6022      	str	r2, [r4, #0]
    32b6:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x08) {
    32b8:	0714      	lsls	r4, r2, #28
    32ba:	d506      	bpl.n	32ca <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xc2>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    32bc:	4c18      	ldr	r4, [pc, #96]	; (3320 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x118>)
    32be:	6a1a      	ldr	r2, [r3, #32]
    32c0:	6826      	ldr	r6, [r4, #0]
    32c2:	4032      	ands	r2, r6
    32c4:	635a      	str	r2, [r3, #52]	; 0x34
				NVIC_ICER3 = interruptSave[3];
    32c6:	6022      	str	r2, [r4, #0]
    32c8:	7cda      	ldrb	r2, [r3, #19]
			}
			if (interruptMasksUsed & 0x10) {
    32ca:	06d2      	lsls	r2, r2, #27
    32cc:	d505      	bpl.n	32da <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xd2>
				interruptSave[4] = NVIC_ICER4 & interruptMask[4];
    32ce:	4c15      	ldr	r4, [pc, #84]	; (3324 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x11c>)
    32d0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    32d2:	6826      	ldr	r6, [r4, #0]
    32d4:	4032      	ands	r2, r6
    32d6:	639a      	str	r2, [r3, #56]	; 0x38
				NVIC_ICER4 = interruptSave[4];
    32d8:	6022      	str	r2, [r4, #0]
			}
			__enable_irq();
    32da:	b662      	cpsie	i
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
    32dc:	689a      	ldr	r2, [r3, #8]
    32de:	428a      	cmp	r2, r1
    32e0:	d19f      	bne.n	3222 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x1a>
    32e2:	68da      	ldr	r2, [r3, #12]
    32e4:	e7b9      	b.n	325a <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x52>

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
    32e6:	4622      	mov	r2, r4
    32e8:	e7ac      	b.n	3244 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x3c>
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    32ea:	bc70      	pop	{r4, r5, r6}
    32ec:	4770      	bx	lr

			if (d && clkhz/d > _clock) d++;
			if (d > 257) d= 257;  // max div
			if (d > 2) {
    32ee:	2a02      	cmp	r2, #2
    32f0:	d908      	bls.n	3304 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0xfc>
    32f2:	3a02      	subs	r2, #2
    32f4:	0854      	lsrs	r4, r2, #1
    32f6:	0421      	lsls	r1, r4, #16
    32f8:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
    32fc:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    3300:	430a      	orrs	r2, r1
    3302:	e7a9      	b.n	3258 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    3304:	2200      	movs	r2, #0
    3306:	e7a7      	b.n	3258 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x50>
    3308:	400fc000 	.word	0x400fc000
    330c:	200005b4 	.word	0x200005b4
    3310:	007f7fff 	.word	0x007f7fff
    3314:	e000e180 	.word	0xe000e180
    3318:	e000e184 	.word	0xe000e184
    331c:	e000e188 	.word	0xe000e188
    3320:	e000e18c 	.word	0xe000e18c
    3324:	e000e190 	.word	0xe000e190

00003328 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>:

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
    3328:	b510      	push	{r4, lr}
    332a:	4604      	mov	r4, r0
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    332c:	f990 000e 	ldrsb.w	r0, [r0, #14]
    3330:	1c43      	adds	r3, r0, #1
    3332:	d003      	beq.n	333c <Adafruit_SPIDevice::endTransactionWithDeassertingCS()+0x14>
    digitalWrite(_cs, value);
    3334:	b2c0      	uxtb	r0, r0
    3336:	2101      	movs	r1, #1
    3338:	f7fe f812 	bl	1360 <digitalWrite>
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
    333c:	4620      	mov	r0, r4
}
    333e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
    3342:	f7ff bf35 	b.w	31b0 <Adafruit_SPIDevice::endTransaction()>
    3346:	bf00      	nop

00003348 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>:
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(const uint8_t *buffer, size_t len,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    3348:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    334c:	b083      	sub	sp, #12
    334e:	460c      	mov	r4, r1
    3350:	4690      	mov	r8, r2
    3352:	461d      	mov	r5, r3
    3354:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    3358:	4606      	mov	r6, r0
  beginTransactionWithAssertingCS();
    335a:	f7ff ff55 	bl	3208 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
      _spi->transferBytes(buffer, nullptr, len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
    335e:	f1b9 0f00 	cmp.w	r9, #0
    3362:	d00d      	beq.n	3380 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x38>
    3364:	f10d 0707 	add.w	r7, sp, #7
    3368:	44a9      	add	r9, r5
      transfer(prefix_buffer[i]);
    336a:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    336e:	2201      	movs	r2, #1
    3370:	4639      	mov	r1, r7
    3372:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    3374:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    3378:	f7ff fe50 	bl	301c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
      _spi->transferBytes(buffer, nullptr, len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
    337c:	454d      	cmp	r5, r9
    337e:	d1f4      	bne.n	336a <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x22>
      transfer(prefix_buffer[i]);
    }
    for (size_t i = 0; i < len; i++) {
    3380:	f1b8 0f00 	cmp.w	r8, #0
    3384:	d00e      	beq.n	33a4 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x5c>
    3386:	f10d 0707 	add.w	r7, sp, #7
    338a:	eb04 0508 	add.w	r5, r4, r8
      transfer(buffer[i]);
    338e:	f814 3b01 	ldrb.w	r3, [r4], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    3392:	2201      	movs	r2, #1
    3394:	4639      	mov	r1, r7
    3396:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    3398:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    339c:	f7ff fe3e 	bl	301c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
      transfer(prefix_buffer[i]);
    }
    for (size_t i = 0; i < len; i++) {
    33a0:	42ac      	cmp	r4, r5
    33a2:	d1f4      	bne.n	338e <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x46>
      transfer(buffer[i]);
    }
  }
  endTransactionWithDeassertingCS();
    33a4:	4630      	mov	r0, r6
    33a6:	f7ff ffbf 	bl	3328 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    33aa:	2001      	movs	r0, #1
    33ac:	b003      	add	sp, #12
    33ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    33b2:	bf00      	nop

000033b4 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)>:
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
    33b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    33b8:	4692      	mov	sl, r2
    33ba:	b082      	sub	sp, #8
    33bc:	460d      	mov	r5, r1
    33be:	461c      	mov	r4, r3
    33c0:	4606      	mov	r6, r0
    33c2:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    33c6:	f89d 802c 	ldrb.w	r8, [sp, #44]	; 0x2c
  beginTransactionWithAssertingCS();
    33ca:	f7ff ff1d 	bl	3208 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
      _spi->transferBytes(write_buffer, nullptr, write_len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
    33ce:	f1ba 0f00 	cmp.w	sl, #0
    33d2:	d00d      	beq.n	33f0 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x3c>
    33d4:	f10d 0707 	add.w	r7, sp, #7
    33d8:	44aa      	add	sl, r5
      transfer(write_buffer[i]);
    33da:	f815 3b01 	ldrb.w	r3, [r5], #1
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    33de:	2201      	movs	r2, #1
    33e0:	4639      	mov	r1, r7
    33e2:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    33e4:	f88d 3007 	strb.w	r3, [sp, #7]
  transfer(&data, 1);
    33e8:	f7ff fe18 	bl	301c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
      _spi->transferBytes(write_buffer, nullptr, write_len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
    33ec:	4555      	cmp	r5, sl
    33ee:	d1f4      	bne.n	33da <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x26>
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    33f0:	f1b9 0f00 	cmp.w	r9, #0
    33f4:	d00f      	beq.n	3416 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x62>
    33f6:	f10d 0707 	add.w	r7, sp, #7
    33fa:	44a1      	add	r9, r4
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
    33fc:	2201      	movs	r2, #1
    33fe:	4639      	mov	r1, r7
    3400:	4630      	mov	r0, r6
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
    3402:	f88d 8007 	strb.w	r8, [sp, #7]
  transfer(&data, 1);
    3406:	f7ff fe09 	bl	301c <Adafruit_SPIDevice::transfer(unsigned char*, unsigned int)>
  return data;
    340a:	f89d 3007 	ldrb.w	r3, [sp, #7]
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    read_buffer[i] = transfer(sendvalue);
    340e:	f804 3b01 	strb.w	r3, [r4], #1
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    3412:	454c      	cmp	r4, r9
    3414:	d1f2      	bne.n	33fc <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char)+0x48>
    }
  }
  DEBUG_SERIAL.println();
#endif

  endTransactionWithDeassertingCS();
    3416:	4630      	mov	r0, r6
    3418:	f7ff ff86 	bl	3328 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>

  return true;
}
    341c:	2001      	movs	r0, #1
    341e:	b002      	add	sp, #8
    3420:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00003424 <Adafruit_Sensor::enableAutoRange(bool)>:
  // These must be defined by the subclass

  /*! @brief Whether we should automatically change the range (if possible) for
     higher precision
      @param enabled True if we will try to autorange */
  virtual void enableAutoRange(bool enabled) {
    3424:	4770      	bx	lr
    3426:	bf00      	nop

00003428 <Adafruit_LIS3MDL::~Adafruit_LIS3MDL()>:
  LIS3MDL_SINGLEMODE = 0b01,     ///< Single-shot conversion
  LIS3MDL_POWERDOWNMODE = 0b11,  ///< Powered-down mode
} lis3mdl_operationmode_t;

/** Class for hardware interfacing with an LIS3MDL magnetometer */
class Adafruit_LIS3MDL : public Adafruit_Sensor {
    3428:	4770      	bx	lr
    342a:	bf00      	nop

0000342c <Adafruit_LIS3MDL::getSensor(sensor_t*)>:
    @brief  Gets the sensor_t device data, Adafruit Unified Sensor format
    @param  sensor Pointer to an Adafruit Unified sensor_t object that we'll
   fill in
*/
/**************************************************************************/
void Adafruit_LIS3MDL::getSensor(sensor_t *sensor) {
    342c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    342e:	460c      	mov	r4, r1
    3430:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3432:	2228      	movs	r2, #40	; 0x28
    3434:	2100      	movs	r1, #0
    3436:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3438:	2701      	movs	r7, #1
   fill in
*/
/**************************************************************************/
void Adafruit_LIS3MDL::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    343a:	f003 f9eb 	bl	6814 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
    343e:	220b      	movs	r2, #11
    3440:	4909      	ldr	r1, [pc, #36]	; (3468 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x3c>)
    3442:	4620      	mov	r0, r4
    3444:	f003 fe8a 	bl	715c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3448:	2300      	movs	r3, #0
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
    344a:	2502      	movs	r5, #2
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
    344c:	4807      	ldr	r0, [pc, #28]	; (346c <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    344e:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
  sensor->max_value = 1600;   // +16 gauss in uTesla
    3450:	4907      	ldr	r1, [pc, #28]	; (3470 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3452:	6a76      	ldr	r6, [r6, #36]	; 0x24
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
  sensor->max_value = 1600;   // +16 gauss in uTesla
  sensor->resolution = 0.015; // 100/6842 uTesla per LSB at +-4 gauss range
    3454:	4a07      	ldr	r2, [pc, #28]	; (3474 <Adafruit_LIS3MDL::getSensor(sensor_t*)+0x48>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3456:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    3458:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
  sensor->min_delay = 0;
    345a:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LIS3MDL", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_MAGNETIC_FIELD;
    345c:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -1600;  // -16 gauss in uTesla
    345e:	61e0      	str	r0, [r4, #28]
  sensor->max_value = 1600;   // +16 gauss in uTesla
    3460:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 0.015; // 100/6842 uTesla per LSB at +-4 gauss range
    3462:	6222      	str	r2, [r4, #32]
    3464:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3466:	bf00      	nop
    3468:	20000df8 	.word	0x20000df8
    346c:	c4c80000 	.word	0xc4c80000
    3470:	44c80000 	.word	0x44c80000
    3474:	3c75c28f 	.word	0x3c75c28f

00003478 <Adafruit_LIS3MDL::~Adafruit_LIS3MDL()>:
    3478:	b510      	push	{r4, lr}
    347a:	4604      	mov	r4, r0
    347c:	2128      	movs	r1, #40	; 0x28
    347e:	f7ff fb21 	bl	2ac4 <operator delete(void*, unsigned int)>
    3482:	4620      	mov	r0, r4
    3484:	bd10      	pop	{r4, pc}
    3486:	bf00      	nop

00003488 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()>:
/**************************************************************************/
/*!
    @brief  Instantiates a new LIS3MDL class
*/
/**************************************************************************/
Adafruit_LIS3MDL::Adafruit_LIS3MDL() {}
    3488:	2200      	movs	r2, #0
    348a:	4903      	ldr	r1, [pc, #12]	; (3498 <Adafruit_LIS3MDL::Adafruit_LIS3MDL()+0x10>)
    348c:	7602      	strb	r2, [r0, #24]
    348e:	6001      	str	r1, [r0, #0]
    3490:	61c2      	str	r2, [r0, #28]
    3492:	6202      	str	r2, [r0, #32]
    3494:	4770      	bx	lr
    3496:	bf00      	nop
    3498:	20000468 	.word	0x20000468

0000349c <Adafruit_LIS3MDL::read()>:
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    349c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    349e:	2301      	movs	r3, #1
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    34a0:	b08d      	sub	sp, #52	; 0x34
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    34a2:	2506      	movs	r5, #6
    34a4:	2700      	movs	r7, #0
    34a6:	2628      	movs	r6, #40	; 0x28
    34a8:	6a02      	ldr	r2, [r0, #32]
    34aa:	69c1      	ldr	r1, [r0, #28]
  @brief  Read the XYZ data from the magnetometer and store in the internal
  x, y and z (and x_g, y_g, z_g) member variables.
*/
/**************************************************************************/

void Adafruit_LIS3MDL::read(void) {
    34ac:	4604      	mov	r4, r0
  uint8_t buffer[6];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    34ae:	9303      	str	r3, [sp, #12]
    34b0:	a806      	add	r0, sp, #24
    34b2:	9501      	str	r5, [sp, #4]
    34b4:	9702      	str	r7, [sp, #8]
    34b6:	9600      	str	r6, [sp, #0]
    34b8:	f7ff fb92 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  XYZDataReg.read(buffer, 6);
    34bc:	462a      	mov	r2, r5
    34be:	a904      	add	r1, sp, #16
    34c0:	a806      	add	r0, sp, #24
    34c2:	f7ff fc11 	bl	2ce8 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
  x = buffer[0];
  x |= buffer[1] << 8;
    34c6:	f89d 3010 	ldrb.w	r3, [sp, #16]
    34ca:	f89d 1011 	ldrb.w	r1, [sp, #17]
  y = buffer[2];
  y |= buffer[3] << 8;
    34ce:	f89d 0013 	ldrb.w	r0, [sp, #19]

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    34d2:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
  y = buffer[2];
  y |= buffer[3] << 8;
    34d6:	f89d 2012 	ldrb.w	r2, [sp, #18]
  z = buffer[4];
  z |= buffer[5] << 8;
    34da:	f89d 5015 	ldrb.w	r5, [sp, #21]
    34de:	f89d 3014 	ldrb.w	r3, [sp, #20]
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
  y = buffer[2];
  y |= buffer[3] << 8;
    34e2:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  z = buffer[4];
  z |= buffer[5] << 8;

  float scale = 1; // LSB per gauss
  switch (rangeBuffered) {
    34e6:	7e20      	ldrb	r0, [r4, #24]

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    34e8:	b209      	sxth	r1, r1
  y = buffer[2];
  y |= buffer[3] << 8;
  z = buffer[4];
  z |= buffer[5] << 8;
    34ea:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
  y = buffer[2];
  y |= buffer[3] << 8;
    34ee:	b212      	sxth	r2, r2
    34f0:	2803      	cmp	r0, #3
  z = buffer[4];
  z |= buffer[5] << 8;
    34f2:	b21b      	sxth	r3, r3

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
  XYZDataReg.read(buffer, 6);
  x = buffer[0];
  x |= buffer[1] << 8;
    34f4:	80e1      	strh	r1, [r4, #6]
  y = buffer[2];
  y |= buffer[3] << 8;
    34f6:	8122      	strh	r2, [r4, #8]
  z = buffer[4];
  z |= buffer[5] << 8;
    34f8:	8163      	strh	r3, [r4, #10]
    34fa:	d81e      	bhi.n	353a <Adafruit_LIS3MDL::read()+0x9e>
    34fc:	4d10      	ldr	r5, [pc, #64]	; (3540 <Adafruit_LIS3MDL::read()+0xa4>)
    34fe:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    3502:	ed90 6a00 	vldr	s12, [r0]
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    3506:	ee07 1a90 	vmov	s15, r1
    350a:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  y_gauss = (float)y / scale;
    350e:	ee07 2a90 	vmov	s15, r2
    3512:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  z_gauss = (float)z / scale;
    3516:	ee07 3a90 	vmov	s15, r3
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    351a:	eec6 5a86 	vdiv.f32	s11, s13, s12
  y_gauss = (float)y / scale;
  z_gauss = (float)z / scale;
    351e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
  y_gauss = (float)y / scale;
    3522:	eec7 6a06 	vdiv.f32	s13, s14, s12
  z_gauss = (float)z / scale;
    3526:	ee87 7a86 	vdiv.f32	s14, s15, s12
  case LIS3MDL_RANGE_4_GAUSS:
    scale = 6842;
    break;
  }

  x_gauss = (float)x / scale;
    352a:	edc4 5a03 	vstr	s11, [r4, #12]
  y_gauss = (float)y / scale;
    352e:	edc4 6a04 	vstr	s13, [r4, #16]
  z_gauss = (float)z / scale;
    3532:	ed84 7a05 	vstr	s14, [r4, #20]
}
    3536:	b00d      	add	sp, #52	; 0x34
    3538:	bdf0      	pop	{r4, r5, r6, r7, pc}
  y |= buffer[3] << 8;
  z = buffer[4];
  z |= buffer[5] << 8;

  float scale = 1; // LSB per gauss
  switch (rangeBuffered) {
    353a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    353e:	e7e2      	b.n	3506 <Adafruit_LIS3MDL::read()+0x6a>
    3540:	20000428 	.word	0x20000428

00003544 <Adafruit_LIS3MDL::getEvent(sensors_event_t*)>:
    @param  event Pointer to an Adafruit Unified sensor_event_t object that
   we'll fill in
    @returns True on successful read
*/
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
    3544:	b570      	push	{r4, r5, r6, lr}
    3546:	460c      	mov	r4, r1
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    3548:	2624      	movs	r6, #36	; 0x24
    @param  event Pointer to an Adafruit Unified sensor_event_t object that
   we'll fill in
    @returns True on successful read
*/
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
    354a:	4605      	mov	r5, r0
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
    354c:	2100      	movs	r1, #0
    354e:	4632      	mov	r2, r6
    3550:	4620      	mov	r0, r4
    3552:	f003 f95f 	bl	6814 <memset>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
    3556:	4b10      	ldr	r3, [pc, #64]	; (3598 <Adafruit_LIS3MDL::getEvent(sensors_event_t*)+0x54>)

  event->version = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
    3558:	6a69      	ldr	r1, [r5, #36]	; 0x24
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
    355a:	2202      	movs	r2, #2
    355c:	681b      	ldr	r3, [r3, #0]
  event->timestamp = millis();

  read();
    355e:	4628      	mov	r0, r5
/**************************************************************************/
bool Adafruit_LIS3MDL::getEvent(sensors_event_t *event) {
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));

  event->version = sizeof(sensors_event_t);
    3560:	6026      	str	r6, [r4, #0]
  event->sensor_id = _sensorID;
    3562:	6061      	str	r1, [r4, #4]
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
    3564:	60a2      	str	r2, [r4, #8]
  event->timestamp = millis();
    3566:	6123      	str	r3, [r4, #16]

  read();
    3568:	f7ff ff98 	bl	349c <Adafruit_LIS3MDL::read()>

  event->magnetic.x = x_gauss * 100; // microTesla per gauss
    356c:	edd5 7a03 	vldr	s15, [r5, #12]
    3570:	ed9f 7a0a 	vldr	s14, [pc, #40]	; 359c <Adafruit_LIS3MDL::getEvent(sensors_event_t*)+0x58>
  event->magnetic.y = y_gauss * 100; // microTesla per gauss
  event->magnetic.z = z_gauss * 100; // microTesla per gauss

  return true;
}
    3574:	2001      	movs	r0, #1
  event->type = SENSOR_TYPE_MAGNETIC_FIELD;
  event->timestamp = millis();

  read();

  event->magnetic.x = x_gauss * 100; // microTesla per gauss
    3576:	ee67 7a87 	vmul.f32	s15, s15, s14
    357a:	edc4 7a05 	vstr	s15, [r4, #20]
  event->magnetic.y = y_gauss * 100; // microTesla per gauss
    357e:	edd5 7a04 	vldr	s15, [r5, #16]
    3582:	ee67 7a87 	vmul.f32	s15, s15, s14
    3586:	edc4 7a06 	vstr	s15, [r4, #24]
  event->magnetic.z = z_gauss * 100; // microTesla per gauss
    358a:	edd5 7a05 	vldr	s15, [r5, #20]
    358e:	ee67 7a87 	vmul.f32	s15, s15, s14
    3592:	edc4 7a07 	vstr	s15, [r4, #28]

  return true;
}
    3596:	bd70      	pop	{r4, r5, r6, pc}
    3598:	20002740 	.word	0x20002740
    359c:	42c80000 	.word	0x42c80000

000035a0 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>:
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    35a0:	b5f0      	push	{r4, r5, r6, r7, lr}
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    35a2:	69c3      	ldr	r3, [r0, #28]
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    35a4:	b095      	sub	sp, #84	; 0x54
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    35a6:	f04f 0e20 	mov.w	lr, #32
    35aa:	2401      	movs	r4, #1
    35ac:	2700      	movs	r7, #0
    35ae:	6a02      	ldr	r2, [r0, #32]
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    35b0:	4605      	mov	r5, r0
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    35b2:	f8cd e000 	str.w	lr, [sp]
    35b6:	eb0d 000e 	add.w	r0, sp, lr
    @brief Set the performance mode, LIS3MDL_LOWPOWERMODE, LIS3MDL_MEDIUMMODE,
    LIS3MDL_HIGHMODE or LIS3MDL_ULTRAHIGHMODE
    @param mode Enumerated lis3mdl_performancemode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t mode) {
    35ba:	460e      	mov	r6, r1
  // write xy
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    35bc:	9403      	str	r4, [sp, #12]
    35be:	4619      	mov	r1, r3
    35c0:	9401      	str	r4, [sp, #4]
    35c2:	4623      	mov	r3, r4
    35c4:	9702      	str	r7, [sp, #8]
    35c6:	f7ff fb0b 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits performancemodebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG1, 2, 5);
    35ca:	a908      	add	r1, sp, #32
    35cc:	2305      	movs	r3, #5
    35ce:	2202      	movs	r2, #2
    35d0:	a804      	add	r0, sp, #16
    35d2:	f7ff fc01 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  performancemodebits.write((uint8_t)mode);
    35d6:	4631      	mov	r1, r6
    35d8:	a804      	add	r0, sp, #16
    35da:	f7ff fc13 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // write z
  Adafruit_BusIO_Register CTRL_REG4 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG4, 1);
    35de:	6a2a      	ldr	r2, [r5, #32]
    35e0:	69e9      	ldr	r1, [r5, #28]
    35e2:	2523      	movs	r5, #35	; 0x23
    35e4:	4623      	mov	r3, r4
    35e6:	9702      	str	r7, [sp, #8]
    35e8:	9403      	str	r4, [sp, #12]
    35ea:	a80e      	add	r0, sp, #56	; 0x38
    35ec:	9401      	str	r4, [sp, #4]
    35ee:	9500      	str	r5, [sp, #0]
    35f0:	f7ff faf6 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits performancemodezbits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG4, 2, 2);
    35f4:	2302      	movs	r3, #2
    35f6:	a90e      	add	r1, sp, #56	; 0x38
    35f8:	a806      	add	r0, sp, #24
    35fa:	461a      	mov	r2, r3
    35fc:	f7ff fbec 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  performancemodezbits.write((uint8_t)mode);
    3600:	4631      	mov	r1, r6
    3602:	a806      	add	r0, sp, #24
    3604:	f7ff fbfe 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3608:	b015      	add	sp, #84	; 0x54
    360a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000360c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>:
    from 0.625 Hz to 80Hz
    @param dataRate Enumerated lis3mdl_dataRate_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    360c:	2901      	cmp	r1, #1
    @brief  Sets the data rate for the LIS3MDL (controls power consumption)
    from 0.625 Hz to 80Hz
    @param dataRate Enumerated lis3mdl_dataRate_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
    360e:	b5f0      	push	{r4, r5, r6, r7, lr}
    3610:	460c      	mov	r4, r1
    3612:	b08d      	sub	sp, #52	; 0x34
    3614:	4606      	mov	r6, r0
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    3616:	d025      	beq.n	3664 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x58>
    // set OP to UHP
    setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_300_HZ) {
    3618:	2903      	cmp	r1, #3
    361a:	d027      	beq.n	366c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x60>
    // set OP to HP
    setPerformanceMode(LIS3MDL_HIGHMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_560_HZ) {
    361c:	2905      	cmp	r1, #5
    361e:	d029      	beq.n	3674 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x68>
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    3620:	2907      	cmp	r1, #7
    3622:	d01b      	beq.n	365c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x50>
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
  }
  delay(10);
    3624:	200a      	movs	r0, #10
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    3626:	2501      	movs	r5, #1
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
  }
  delay(10);
    3628:	f7fd fe00 	bl	122c <delay>
  Adafruit_BusIO_Register CTRL_REG1 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG1, 1);
    362c:	2700      	movs	r7, #0
    362e:	6a32      	ldr	r2, [r6, #32]
    3630:	462b      	mov	r3, r5
    3632:	69f1      	ldr	r1, [r6, #28]
    3634:	2620      	movs	r6, #32
    3636:	a806      	add	r0, sp, #24
    3638:	9503      	str	r5, [sp, #12]
    363a:	9501      	str	r5, [sp, #4]
    363c:	9702      	str	r7, [sp, #8]
    363e:	9600      	str	r6, [sp, #0]
    3640:	f7ff face 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits dataratebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG1, 4, 1); // includes FAST_ODR
    3644:	462b      	mov	r3, r5
    3646:	a906      	add	r1, sp, #24
    3648:	2204      	movs	r2, #4
    364a:	a804      	add	r0, sp, #16
    364c:	f7ff fbc4 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  dataratebits.write((uint8_t)dataRate);
    3650:	4621      	mov	r1, r4
    3652:	a804      	add	r0, sp, #16
    3654:	f7ff fbd6 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3658:	b00d      	add	sp, #52	; 0x34
    365a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
  }
  if (dataRate == LIS3MDL_DATARATE_1000_HZ) {
    // set OP to LP
    setPerformanceMode(LIS3MDL_LOWPOWERMODE);
    365c:	2100      	movs	r1, #0
    365e:	f7ff ff9f 	bl	35a0 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3662:	e7df      	b.n	3624 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t dataRate) {
  if (dataRate == LIS3MDL_DATARATE_155_HZ) {
    // set OP to UHP
    setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
    3664:	2103      	movs	r1, #3
    3666:	f7ff ff9b 	bl	35a0 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    366a:	e7db      	b.n	3624 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
  }
  if (dataRate == LIS3MDL_DATARATE_300_HZ) {
    // set OP to HP
    setPerformanceMode(LIS3MDL_HIGHMODE);
    366c:	2102      	movs	r1, #2
    366e:	f7ff ff97 	bl	35a0 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    3672:	e7d7      	b.n	3624 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>
  }
  if (dataRate == LIS3MDL_DATARATE_560_HZ) {
    // set OP to MP
    setPerformanceMode(LIS3MDL_MEDIUMMODE);
    3674:	2101      	movs	r1, #1
    3676:	f7ff ff93 	bl	35a0 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>
    367a:	e7d3      	b.n	3624 <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)+0x18>

0000367c <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>:
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    367c:	b570      	push	{r4, r5, r6, lr}
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    367e:	6a02      	ldr	r2, [r0, #32]
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    3680:	b08c      	sub	sp, #48	; 0x30
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    3682:	69c0      	ldr	r0, [r0, #28]
    3684:	2301      	movs	r3, #1
    3686:	2400      	movs	r4, #0
    3688:	2622      	movs	r6, #34	; 0x22
    @brief Set the operation mode, LIS3MDL_CONTINUOUSMODE,
    LIS3MDL_SINGLEMODE or LIS3MDL_POWERDOWNMODE
    @param mode Enumerated lis3mdl_operationmode_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t mode) {
    368a:	460d      	mov	r5, r1
  // write x and y
  Adafruit_BusIO_Register CTRL_REG3 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG3, 1);
    368c:	9303      	str	r3, [sp, #12]
    368e:	4601      	mov	r1, r0
    3690:	9301      	str	r3, [sp, #4]
    3692:	a806      	add	r0, sp, #24
    3694:	9402      	str	r4, [sp, #8]
    3696:	9600      	str	r6, [sp, #0]
    3698:	f7ff faa2 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits opmodebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG3, 2, 0);
    369c:	4623      	mov	r3, r4
    369e:	a906      	add	r1, sp, #24
    36a0:	2202      	movs	r2, #2
    36a2:	a804      	add	r0, sp, #16
    36a4:	f7ff fb98 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  opmodebits.write((uint8_t)mode);
    36a8:	4629      	mov	r1, r5
    36aa:	a804      	add	r0, sp, #16
    36ac:	f7ff fbaa 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    36b0:	b00c      	add	sp, #48	; 0x30
    36b2:	bd70      	pop	{r4, r5, r6, pc}

000036b4 <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>:
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    36b4:	b5f0      	push	{r4, r5, r6, r7, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    36b6:	2301      	movs	r3, #1
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    36b8:	b08d      	sub	sp, #52	; 0x34
    36ba:	4604      	mov	r4, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    36bc:	2700      	movs	r7, #0
    36be:	2621      	movs	r6, #33	; 0x21
    36c0:	6a02      	ldr	r2, [r0, #32]
/*!
    @brief Set the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @param range Enumerated lis3mdl_range_t
*/
/**************************************************************************/
void Adafruit_LIS3MDL::setRange(lis3mdl_range_t range) {
    36c2:	460d      	mov	r5, r1
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    36c4:	a806      	add	r0, sp, #24
    36c6:	69e1      	ldr	r1, [r4, #28]
    36c8:	9303      	str	r3, [sp, #12]
    36ca:	9301      	str	r3, [sp, #4]
    36cc:	9702      	str	r7, [sp, #8]
    36ce:	9600      	str	r6, [sp, #0]
    36d0:	f7ff fa86 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits rangebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 2, 5);
    36d4:	a906      	add	r1, sp, #24
    36d6:	2305      	movs	r3, #5
    36d8:	2202      	movs	r2, #2
    36da:	a804      	add	r0, sp, #16
    36dc:	f7ff fb7c 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  rangebits.write((uint8_t)range);
    36e0:	4629      	mov	r1, r5
    36e2:	a804      	add	r0, sp, #16
    36e4:	f7ff fb8e 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  rangeBuffered = range;
    36e8:	7625      	strb	r5, [r4, #24]
}
    36ea:	b00d      	add	sp, #52	; 0x34
    36ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
    36ee:	bf00      	nop

000036f0 <Adafruit_LIS3MDL::getRange()>:
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    36f0:	b570      	push	{r4, r5, r6, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    36f2:	2301      	movs	r3, #1
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    36f4:	b08c      	sub	sp, #48	; 0x30
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    36f6:	2600      	movs	r6, #0
    36f8:	2521      	movs	r5, #33	; 0x21
    36fa:	6a02      	ldr	r2, [r0, #32]
/*!
    @brief Read the resolution range: +-4 gauss, 8 gauss, 12 gauss, or 16 gauss.
    @returns Enumerated lis3mdl_range_t
*/
/**************************************************************************/
lis3mdl_range_t Adafruit_LIS3MDL::getRange(void) {
    36fc:	4604      	mov	r4, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    36fe:	69c1      	ldr	r1, [r0, #28]
    3700:	a806      	add	r0, sp, #24
    3702:	9303      	str	r3, [sp, #12]
    3704:	9301      	str	r3, [sp, #4]
    3706:	9602      	str	r6, [sp, #8]
    3708:	9500      	str	r5, [sp, #0]
    370a:	f7ff fa69 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits rangebits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 2, 5);
    370e:	a906      	add	r1, sp, #24
    3710:	2305      	movs	r3, #5
    3712:	2202      	movs	r2, #2
    3714:	a804      	add	r0, sp, #16
    3716:	f7ff fb5f 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  rangeBuffered = (lis3mdl_range_t)rangebits.read();
    371a:	a804      	add	r0, sp, #16
    371c:	f7ff fb64 	bl	2de8 <Adafruit_BusIO_RegisterBits::read()>
    3720:	b2c0      	uxtb	r0, r0
    3722:	7620      	strb	r0, [r4, #24]

  return rangeBuffered;
}
    3724:	b00c      	add	sp, #48	; 0x30
    3726:	bd70      	pop	{r4, r5, r6, pc}

00003728 <Adafruit_LIS3MDL::reset()>:
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3728:	b5f0      	push	{r4, r5, r6, r7, lr}
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    372a:	2401      	movs	r4, #1
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    372c:	b08d      	sub	sp, #52	; 0x34
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    372e:	2700      	movs	r7, #0
    3730:	2621      	movs	r6, #33	; 0x21
    3732:	6a02      	ldr	r2, [r0, #32]
/**************************************************************************/
/*!
@brief  Performs a software reset
*/
/**************************************************************************/
void Adafruit_LIS3MDL::reset(void) {
    3734:	4605      	mov	r5, r0
  Adafruit_BusIO_Register CTRL_REG2 =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_CTRL_REG2, 1);
    3736:	69c1      	ldr	r1, [r0, #28]
    3738:	4623      	mov	r3, r4
    373a:	a806      	add	r0, sp, #24
    373c:	9403      	str	r4, [sp, #12]
    373e:	9401      	str	r4, [sp, #4]
    3740:	9702      	str	r7, [sp, #8]
    3742:	9600      	str	r6, [sp, #0]
    3744:	f7ff fa4c 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits resetbits =
      Adafruit_BusIO_RegisterBits(&CTRL_REG2, 1, 2);
    3748:	4622      	mov	r2, r4
    374a:	2302      	movs	r3, #2
    374c:	a906      	add	r1, sp, #24
    374e:	a804      	add	r0, sp, #16
    3750:	f7ff fb42 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  resetbits.write(0x1);
    3754:	4621      	mov	r1, r4
    3756:	a804      	add	r0, sp, #16
    3758:	f7ff fb54 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
  delay(10);
    375c:	200a      	movs	r0, #10
    375e:	f7fd fd65 	bl	122c <delay>

  getRange();
    3762:	4628      	mov	r0, r5
    3764:	f7ff ffc4 	bl	36f0 <Adafruit_LIS3MDL::getRange()>
}
    3768:	b00d      	add	sp, #52	; 0x34
    376a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000376c <Adafruit_LIS3MDL::_init()>:

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    376c:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    376e:	2501      	movs	r5, #1

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    3770:	b08b      	sub	sp, #44	; 0x2c
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    3772:	2400      	movs	r4, #0
    3774:	270f      	movs	r7, #15
    3776:	6a02      	ldr	r2, [r0, #32]
    3778:	462b      	mov	r3, r5
    377a:	69c1      	ldr	r1, [r0, #28]

/*!
 *    @brief  Common initialization code for I2C & SPI
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::_init(void) {
    377c:	4606      	mov	r6, r0
  // Check connection
  Adafruit_BusIO_Register chip_id =
      Adafruit_BusIO_Register(i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC,
                              LIS3MDL_REG_WHO_AM_I, 1);
    377e:	9503      	str	r5, [sp, #12]
    3780:	a804      	add	r0, sp, #16
    3782:	9501      	str	r5, [sp, #4]
    3784:	9402      	str	r4, [sp, #8]
    3786:	9700      	str	r7, [sp, #0]
    3788:	f7ff fa2a 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  // make sure we're talking to the right chip
  if (chip_id.read() != 0x3D) {
    378c:	a804      	add	r0, sp, #16
    378e:	f7ff faf9 	bl	2d84 <Adafruit_BusIO_Register::read()>
    3792:	283d      	cmp	r0, #61	; 0x3d
    3794:	d002      	beq.n	379c <Adafruit_LIS3MDL::_init()+0x30>
    // No LIS3MDL detected ... return false
    return false;
    3796:	4620      	mov	r0, r4
  setRange(LIS3MDL_RANGE_4_GAUSS);

  setOperationMode(LIS3MDL_CONTINUOUSMODE);

  return true;
}
    3798:	b00b      	add	sp, #44	; 0x2c
    379a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (chip_id.read() != 0x3D) {
    // No LIS3MDL detected ... return false
    return false;
  }

  reset();
    379c:	4630      	mov	r0, r6
    379e:	f7ff ffc3 	bl	3728 <Adafruit_LIS3MDL::reset()>

  // set high quality performance mode
  setPerformanceMode(LIS3MDL_ULTRAHIGHMODE);
    37a2:	4630      	mov	r0, r6
    37a4:	2103      	movs	r1, #3
    37a6:	f7ff fefb 	bl	35a0 <Adafruit_LIS3MDL::setPerformanceMode(lis3mdl_performancemode_t)>

  // 155Hz default rate
  setDataRate(LIS3MDL_DATARATE_155_HZ);
    37aa:	4629      	mov	r1, r5
    37ac:	4630      	mov	r0, r6
    37ae:	f7ff ff2d 	bl	360c <Adafruit_LIS3MDL::setDataRate(lis3mdl_dataRate_t)>

  // lowest range
  setRange(LIS3MDL_RANGE_4_GAUSS);
    37b2:	4621      	mov	r1, r4
    37b4:	4630      	mov	r0, r6
    37b6:	f7ff ff7d 	bl	36b4 <Adafruit_LIS3MDL::setRange(lis3mdl_range_t)>

  setOperationMode(LIS3MDL_CONTINUOUSMODE);
    37ba:	4630      	mov	r0, r6
    37bc:	4621      	mov	r1, r4
    37be:	f7ff ff5d 	bl	367c <Adafruit_LIS3MDL::setOperationMode(lis3mdl_operationmode_t)>
    37c2:	4628      	mov	r0, r5

  return true;
}
    37c4:	b00b      	add	sp, #44	; 0x2c
    37c6:	bdf0      	pop	{r4, r5, r6, r7, pc}

000037c8 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)>:
 *            The I2C address to be used.
 *    @param  wire
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
    37c8:	b530      	push	{r4, r5, lr}
    37ca:	4604      	mov	r4, r0
  if (!i2c_dev) {
    37cc:	69c0      	ldr	r0, [r0, #28]
 *            The I2C address to be used.
 *    @param  wire
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
    37ce:	b083      	sub	sp, #12
  if (!i2c_dev) {
    37d0:	b168      	cbz	r0, 37ee <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0x26>
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
  }
  spi_dev = NULL;
    37d2:	2300      	movs	r3, #0

  if (!i2c_dev->begin()) {
    37d4:	2101      	movs	r1, #1
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
  if (!i2c_dev) {
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
  }
  spi_dev = NULL;
    37d6:	6223      	str	r3, [r4, #32]

  if (!i2c_dev->begin()) {
    37d8:	f7ff fb64 	bl	2ea4 <Adafruit_I2CDevice::begin(bool)>
    37dc:	b908      	cbnz	r0, 37e2 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0x1a>
    return false;
  }
  return _init();
}
    37de:	b003      	add	sp, #12
    37e0:	bd30      	pop	{r4, r5, pc}
  spi_dev = NULL;

  if (!i2c_dev->begin()) {
    return false;
  }
  return _init();
    37e2:	4620      	mov	r0, r4
}
    37e4:	b003      	add	sp, #12
    37e6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  spi_dev = NULL;

  if (!i2c_dev->begin()) {
    return false;
  }
  return _init();
    37ea:	f7ff bfbf 	b.w	376c <Adafruit_LIS3MDL::_init()>
 *            The Wire object to be used for I2C connections.
 *    @return True if initialization was successful, otherwise false.
 */
bool Adafruit_LIS3MDL::begin_I2C(uint8_t i2c_address, TwoWire *wire) {
  if (!i2c_dev) {
    i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
    37ee:	2010      	movs	r0, #16
    37f0:	e88d 0006 	stmia.w	sp, {r1, r2}
    37f4:	f7ff f962 	bl	2abc <operator new(unsigned int)>
    37f8:	4605      	mov	r5, r0
    37fa:	e89d 0006 	ldmia.w	sp, {r1, r2}
    37fe:	f7ff fb2b 	bl	2e58 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    3802:	4628      	mov	r0, r5
    3804:	61e5      	str	r5, [r4, #28]
    3806:	e7e4      	b.n	37d2 <Adafruit_LIS3MDL::begin_I2C(unsigned char, TwoWire*)+0xa>

00003808 <Adafruit_LIS3MDL::configInterrupt(bool, bool, bool, bool, bool, bool)>:
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3808:	b5f0      	push	{r4, r5, r6, r7, lr}
    380a:	b08b      	sub	sp, #44	; 0x2c
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    380c:	f8d0 e020 	ldr.w	lr, [r0, #32]
    3810:	69c7      	ldr	r7, [r0, #28]
    3812:	2001      	movs	r0, #1
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    3814:	f89d 4044 	ldrb.w	r4, [sp, #68]	; 0x44
    3818:	f89d c040 	ldrb.w	ip, [sp, #64]	; 0x40
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    381c:	0065      	lsls	r5, r4, #1
    @param enableInt Interrupt enable on INT pin
*/
/**************************************************************************/
void Adafruit_LIS3MDL::configInterrupt(bool enableX, bool enableY, bool enableZ,
                                       bool polarity, bool latch,
                                       bool enableInt) {
    381e:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3822:	9003      	str	r0, [sp, #12]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3824:	f045 0508 	orr.w	r5, r5, #8
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3828:	9001      	str	r0, [sp, #4]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    382a:	ea45 048c 	orr.w	r4, r5, ip, lsl #2
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    382e:	2500      	movs	r5, #0
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3830:	ea44 1443 	orr.w	r4, r4, r3, lsl #5
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3834:	4603      	mov	r3, r0
    3836:	2030      	movs	r0, #48	; 0x30
    3838:	9502      	str	r5, [sp, #8]
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    383a:	ea44 1482 	orr.w	r4, r4, r2, lsl #6
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    383e:	4672      	mov	r2, lr
    3840:	9000      	str	r0, [sp, #0]
    3842:	a804      	add	r0, sp, #16
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3844:	ea44 14c1 	orr.w	r4, r4, r1, lsl #7
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
    3848:	4639      	mov	r1, r7
    384a:	f7ff f9c9 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  INT_CFG.write(value);
    384e:	462a      	mov	r2, r5
  uint8_t value = 0x08; // set default bits, see table 36
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
    3850:	b2e4      	uxtb	r4, r4
  value |= enableInt;

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
  INT_CFG.write(value);
    3852:	a804      	add	r0, sp, #16
  value |= enableX << 7;
  value |= enableY << 6;
  value |= enableZ << 5;
  value |= polarity << 2;
  value |= latch << 1;
  value |= enableInt;
    3854:	4334      	orrs	r4, r6

  Adafruit_BusIO_Register INT_CFG = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_INT_CFG, 1);
  INT_CFG.write(value);
    3856:	4621      	mov	r1, r4
    3858:	f7ff fa26 	bl	2ca8 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>
}
    385c:	b00b      	add	sp, #44	; 0x2c
    385e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003860 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3860:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3864:	f04f 0c00 	mov.w	ip, #0
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3868:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    386a:	f8d0 9020 	ldr.w	r9, [r0, #32]
    386e:	2401      	movs	r4, #1
    3870:	69c0      	ldr	r0, [r0, #28]
    3872:	f04f 0806 	mov.w	r8, #6
    3876:	f04f 0e28 	mov.w	lr, #40	; 0x28
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    387a:	460f      	mov	r7, r1
    387c:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    387e:	4601      	mov	r1, r0
    3880:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LIS3MDL::readMagneticField(float &x, float &y, float &z) {
    3882:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);
    3884:	a806      	add	r0, sp, #24
    3886:	9403      	str	r4, [sp, #12]
    3888:	4623      	mov	r3, r4
    388a:	f8cd c008 	str.w	ip, [sp, #8]
    388e:	f8cd 8004 	str.w	r8, [sp, #4]
    3892:	f8cd e000 	str.w	lr, [sp]
    3896:	f7ff f9a3 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    389a:	4642      	mov	r2, r8
    389c:	a806      	add	r0, sp, #24
    389e:	a904      	add	r1, sp, #16
    38a0:	f7ff fa22 	bl	2ce8 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    38a4:	b3c8      	cbz	r0, 391a <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xba>
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    38a6:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    38aa:	eeb1 6b00 	vmov.f64	d6, #16	; 0x40800000  4.0
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;

  return 1;
    38ae:	4620      	mov	r0, r4
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    38b0:	ee04 3a10 	vmov	s8, r3
  y = data[1] * 4.0 * 100.0 / 32768.0;
    38b4:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    38b8:	ee05 3a10 	vmov	s10, r3
  z = data[2] * 4.0 * 100.0 / 32768.0;
    38bc:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    38c0:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;
    38c4:	ee07 3a10 	vmov	s14, r3
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
  y = data[1] * 4.0 * 100.0 / 32768.0;
    38c8:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  z = data[2] * 4.0 * 100.0 / 32768.0;
    38cc:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    38d0:	ee24 4b06 	vmul.f64	d4, d4, d6
  y = data[1] * 4.0 * 100.0 / 32768.0;
    38d4:	ee25 5b06 	vmul.f64	d5, d5, d6
  z = data[2] * 4.0 * 100.0 / 32768.0;
    38d8:	ee27 6b06 	vmul.f64	d6, d7, d6
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    38dc:	ed9f 7b12 	vldr	d7, [pc, #72]	; 3928 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xc8>
    38e0:	ed9f 3b13 	vldr	d3, [pc, #76]	; 3930 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xd0>
  y = data[1] * 4.0 * 100.0 / 32768.0;
    38e4:	ee25 5b07 	vmul.f64	d5, d5, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    38e8:	ee24 4b07 	vmul.f64	d4, d4, d7
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;
    38ec:	ee26 7b07 	vmul.f64	d7, d6, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    38f0:	ee24 4b03 	vmul.f64	d4, d4, d3
  y = data[1] * 4.0 * 100.0 / 32768.0;
    38f4:	ee25 6b03 	vmul.f64	d6, d5, d3
  z = data[2] * 4.0 * 100.0 / 32768.0;
    38f8:	ee27 7b03 	vmul.f64	d7, d7, d3
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    38fc:	eeb7 4bc4 	vcvt.f32.f64	s8, d4
  y = data[1] * 4.0 * 100.0 / 32768.0;
    3900:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3904:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    return 0;
  }

  x = data[0] * 4.0 * 100.0 / 32768.0;
    3908:	ed87 4a00 	vstr	s8, [r7]
  y = data[1] * 4.0 * 100.0 / 32768.0;
    390c:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 4.0 * 100.0 / 32768.0;
    3910:	ed85 7a00 	vstr	s14, [r5]

  return 1;
    3914:	b00d      	add	sp, #52	; 0x34
    3916:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register XYZDataReg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, AD8_HIGH_TOREAD_AD7_HIGH_TOINC, LIS3MDL_REG_OUT_X_L, 6);

  if (!XYZDataReg.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    391a:	4b07      	ldr	r3, [pc, #28]	; (3938 <Adafruit_LIS3MDL::readMagneticField(float&, float&, float&)+0xd8>)
    391c:	602b      	str	r3, [r5, #0]
    391e:	6033      	str	r3, [r6, #0]
    3920:	603b      	str	r3, [r7, #0]
  x = data[0] * 4.0 * 100.0 / 32768.0;
  y = data[1] * 4.0 * 100.0 / 32768.0;
  z = data[2] * 4.0 * 100.0 / 32768.0;

  return 1;
    3922:	b00d      	add	sp, #52	; 0x34
    3924:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    3928:	00000000 	.word	0x00000000
    392c:	40590000 	.word	0x40590000
    3930:	00000000 	.word	0x00000000
    3934:	3f000000 	.word	0x3f000000
    3938:	7fc00000 	.word	0x7fc00000

0000393c <Adafruit_LSM6DS::~Adafruit_LSM6DS()>:
Adafruit_LSM6DS::Adafruit_LSM6DS(void) {}

/*!
 *    @brief  Cleans up the LSM6DS
 */
Adafruit_LSM6DS::~Adafruit_LSM6DS(void) { delete temp_sensor; }
    393c:	b510      	push	{r4, lr}
    393e:	4b05      	ldr	r3, [pc, #20]	; (3954 <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x18>)
    3940:	4604      	mov	r4, r0
    3942:	6c40      	ldr	r0, [r0, #68]	; 0x44
    3944:	6023      	str	r3, [r4, #0]
    3946:	b110      	cbz	r0, 394e <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x12>
    3948:	6803      	ldr	r3, [r0, #0]
    394a:	685b      	ldr	r3, [r3, #4]
    394c:	4798      	blx	r3
    394e:	4620      	mov	r0, r4
    3950:	bd10      	pop	{r4, pc}
    3952:	bf00      	nop
    3954:	20000450 	.word	0x20000450

00003958 <Adafruit_LSM6DS_Gyro::~Adafruit_LSM6DS_Gyro()>:
  int _sensorID = 0x6D1;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
    3958:	4770      	bx	lr
    395a:	bf00      	nop

0000395c <Adafruit_LSM6DS_Accelerometer::~Adafruit_LSM6DS_Accelerometer()>:
  int _sensorID = 0x6D0;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for accelerometer component of LSM6DS */
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
    395c:	4770      	bx	lr
    395e:	bf00      	nop

00003960 <Adafruit_LSM6DS_Temp::~Adafruit_LSM6DS_Temp()>:
} lsm6ds_hp_filter_t;

class Adafruit_LSM6DS;

/** Adafruit Unified Sensor interface for temperature component of LSM6DS */
class Adafruit_LSM6DS_Temp : public Adafruit_Sensor {
    3960:	4770      	bx	lr
    3962:	bf00      	nop

00003964 <Adafruit_LSM6DS::~Adafruit_LSM6DS()>:
    3964:	b510      	push	{r4, lr}
    3966:	4b07      	ldr	r3, [pc, #28]	; (3984 <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x20>)
    3968:	4604      	mov	r4, r0
    396a:	6c40      	ldr	r0, [r0, #68]	; 0x44
    396c:	6023      	str	r3, [r4, #0]
    396e:	b110      	cbz	r0, 3976 <Adafruit_LSM6DS::~Adafruit_LSM6DS()+0x12>
    3970:	6803      	ldr	r3, [r0, #0]
    3972:	685b      	ldr	r3, [r3, #4]
    3974:	4798      	blx	r3
    3976:	4620      	mov	r0, r4
    3978:	2154      	movs	r1, #84	; 0x54
    397a:	f7ff f8a3 	bl	2ac4 <operator delete(void*, unsigned int)>
    397e:	4620      	mov	r0, r4
    3980:	bd10      	pop	{r4, pc}
    3982:	bf00      	nop
    3984:	20000450 	.word	0x20000450

00003988 <Adafruit_LSM6DS_Temp::~Adafruit_LSM6DS_Temp()>:
    3988:	b510      	push	{r4, lr}
    398a:	4604      	mov	r4, r0
    398c:	2110      	movs	r1, #16
    398e:	f7ff f899 	bl	2ac4 <operator delete(void*, unsigned int)>
    3992:	4620      	mov	r0, r4
    3994:	bd10      	pop	{r4, pc}
    3996:	bf00      	nop

00003998 <Adafruit_LSM6DS_Accelerometer::~Adafruit_LSM6DS_Accelerometer()>:
  int _sensorID = 0x6D0;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for accelerometer component of LSM6DS */
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
    3998:	b510      	push	{r4, lr}
    399a:	4604      	mov	r4, r0
    399c:	2110      	movs	r1, #16
    399e:	f7ff f891 	bl	2ac4 <operator delete(void*, unsigned int)>
    39a2:	4620      	mov	r0, r4
    39a4:	bd10      	pop	{r4, pc}
    39a6:	bf00      	nop

000039a8 <Adafruit_LSM6DS_Gyro::~Adafruit_LSM6DS_Gyro()>:
  int _sensorID = 0x6D1;
  Adafruit_LSM6DS *_theLSM6DS = NULL;
};

/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
    39a8:	b510      	push	{r4, lr}
    39aa:	4604      	mov	r4, r0
    39ac:	2110      	movs	r1, #16
    39ae:	f7ff f889 	bl	2ac4 <operator delete(void*, unsigned int)>
    39b2:	4620      	mov	r0, r4
    39b4:	bd10      	pop	{r4, pc}
    39b6:	bf00      	nop

000039b8 <Adafruit_LSM6DS_Temp::getEvent(sensors_event_t*)>:
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
    39b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    39ba:	4606      	mov	r6, r0
  _theLSM6DS->_read();
    39bc:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the temperature as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
    39be:	460c      	mov	r4, r1
  fillTempEvent(temp, t);
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
    39c0:	2524      	movs	r5, #36	; 0x24
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
    39c2:	6803      	ldr	r3, [r0, #0]
    39c4:	689b      	ldr	r3, [r3, #8]
    39c6:	4798      	blx	r3
  _theLSM6DS->fillTempEvent(event, millis());
    39c8:	68f6      	ldr	r6, [r6, #12]
    39ca:	4b08      	ldr	r3, [pc, #32]	; (39ec <Adafruit_LSM6DS_Temp::getEvent(sensors_event_t*)+0x34>)
  fillTempEvent(temp, t);
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
    39cc:	462a      	mov	r2, r5
    39ce:	4620      	mov	r0, r4
    39d0:	2100      	movs	r1, #0
    39d2:	681f      	ldr	r7, [r3, #0]
    39d4:	f002 ff1e 	bl	6814 <memset>
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
    39d8:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    39da:	230d      	movs	r3, #13
  temp->timestamp = timestamp;
  temp->temperature = temperature;
    39dc:	6972      	ldr	r2, [r6, #20]
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillTempEvent(event, millis());

  return true;
}
    39de:	2001      	movs	r0, #1
  return true;
}

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
    39e0:	6025      	str	r5, [r4, #0]
  temp->sensor_id = _sensorid_temp;
    39e2:	6061      	str	r1, [r4, #4]
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  temp->timestamp = timestamp;
  temp->temperature = temperature;
    39e4:	6162      	str	r2, [r4, #20]
void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  temp->timestamp = timestamp;
    39e6:	6127      	str	r7, [r4, #16]

void Adafruit_LSM6DS::fillTempEvent(sensors_event_t *temp, uint32_t timestamp) {
  memset(temp, 0, sizeof(sensors_event_t));
  temp->version = sizeof(sensors_event_t);
  temp->sensor_id = _sensorid_temp;
  temp->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    39e8:	60a3      	str	r3, [r4, #8]
bool Adafruit_LSM6DS_Temp::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillTempEvent(event, millis());

  return true;
}
    39ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    39ec:	20002740 	.word	0x20002740

000039f0 <Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t*)>:
    @brief  Gets the gyroscope as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
    39f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    39f2:	4605      	mov	r5, r0
  _theLSM6DS->_read();
    39f4:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the gyroscope as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
    39f6:	460c      	mov	r4, r1
  _theLSM6DS->_read();
    39f8:	6803      	ldr	r3, [r0, #0]
    39fa:	689b      	ldr	r3, [r3, #8]
    39fc:	4798      	blx	r3
  _theLSM6DS->fillGyroEvent(event, millis());
    39fe:	68ed      	ldr	r5, [r5, #12]
    3a00:	4b0a      	ldr	r3, [pc, #40]	; (3a2c <Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t*)+0x3c>)
  temp->timestamp = timestamp;
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
    3a02:	4620      	mov	r0, r4
    3a04:	2224      	movs	r2, #36	; 0x24
    3a06:	2100      	movs	r1, #0
    3a08:	681e      	ldr	r6, [r3, #0]
    3a0a:	f002 ff03 	bl	6814 <memset>
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
    3a0e:	6a69      	ldr	r1, [r5, #36]	; 0x24
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
    3a10:	2301      	movs	r3, #1
  gyro->sensor_id = _sensorid_gyro;
    3a12:	8e6f      	ldrh	r7, [r5, #50]	; 0x32
  gyro->type = SENSOR_TYPE_GYROSCOPE;
    3a14:	2204      	movs	r2, #4
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
    3a16:	6161      	str	r1, [r4, #20]
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillGyroEvent(event, millis());

  return true;
}
    3a18:	4618      	mov	r0, r3
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
    3a1a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
    3a1c:	6067      	str	r7, [r4, #4]
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
    3a1e:	61a1      	str	r1, [r4, #24]
  gyro->gyro.z = gyroZ;
    3a20:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
  gyro->timestamp = timestamp;
    3a22:	6126      	str	r6, [r4, #16]
  gyro->gyro.x = gyroX;
  gyro->gyro.y = gyroY;
  gyro->gyro.z = gyroZ;
    3a24:	61e1      	str	r1, [r4, #28]

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
  gyro->sensor_id = _sensorid_gyro;
  gyro->type = SENSOR_TYPE_GYROSCOPE;
    3a26:	60a2      	str	r2, [r4, #8]
  temp->temperature = temperature;
}

void Adafruit_LSM6DS::fillGyroEvent(sensors_event_t *gyro, uint32_t timestamp) {
  memset(gyro, 0, sizeof(sensors_event_t));
  gyro->version = 1;
    3a28:	6023      	str	r3, [r4, #0]
bool Adafruit_LSM6DS_Gyro::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillGyroEvent(event, millis());

  return true;
}
    3a2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3a2c:	20002740 	.word	0x20002740

00003a30 <Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t*)>:
    @brief  Gets the accelerometer as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
    3a30:	b570      	push	{r4, r5, r6, lr}
    3a32:	4605      	mov	r5, r0
  _theLSM6DS->_read();
    3a34:	68c0      	ldr	r0, [r0, #12]
    @brief  Gets the accelerometer as a standard sensor event
    @param  event Sensor event object that will be populated
    @returns True
*/
/**************************************************************************/
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
    3a36:	460c      	mov	r4, r1
  _theLSM6DS->_read();
    3a38:	6803      	ldr	r3, [r0, #0]
    3a3a:	689b      	ldr	r3, [r3, #8]
    3a3c:	4798      	blx	r3
  _theLSM6DS->fillAccelEvent(event, millis());
    3a3e:	68ed      	ldr	r5, [r5, #12]
    3a40:	4b0a      	ldr	r3, [pc, #40]	; (3a6c <Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t*)+0x3c>)
  gyro->gyro.z = gyroZ;
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
    3a42:	4620      	mov	r0, r4
    3a44:	2224      	movs	r2, #36	; 0x24
    3a46:	2100      	movs	r1, #0
    3a48:	681e      	ldr	r6, [r3, #0]
    3a4a:	f002 fee3 	bl	6814 <memset>
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
    3a4e:	69aa      	ldr	r2, [r5, #24]
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
    3a50:	2301      	movs	r3, #1
  accel->sensor_id = _sensorid_accel;
    3a52:	8e29      	ldrh	r1, [r5, #48]	; 0x30
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
    3a54:	6162      	str	r2, [r4, #20]
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillAccelEvent(event, millis());

  return true;
}
    3a56:	4618      	mov	r0, r3
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
    3a58:	69ea      	ldr	r2, [r5, #28]

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
    3a5a:	6061      	str	r1, [r4, #4]
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
    3a5c:	61a2      	str	r2, [r4, #24]
  accel->acceleration.z = accZ;
    3a5e:	6a2a      	ldr	r2, [r5, #32]
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
  accel->timestamp = timestamp;
    3a60:	6126      	str	r6, [r4, #16]
  accel->acceleration.x = accX;
  accel->acceleration.y = accY;
  accel->acceleration.z = accZ;
    3a62:	61e2      	str	r2, [r4, #28]
}

void Adafruit_LSM6DS::fillAccelEvent(sensors_event_t *accel,
                                     uint32_t timestamp) {
  memset(accel, 0, sizeof(sensors_event_t));
  accel->version = 1;
    3a64:	6023      	str	r3, [r4, #0]
  accel->sensor_id = _sensorid_accel;
  accel->type = SENSOR_TYPE_ACCELEROMETER;
    3a66:	60a3      	str	r3, [r4, #8]
bool Adafruit_LSM6DS_Accelerometer::getEvent(sensors_event_t *event) {
  _theLSM6DS->_read();
  _theLSM6DS->fillAccelEvent(event, millis());

  return true;
}
    3a68:	bd70      	pop	{r4, r5, r6, pc}
    3a6a:	bf00      	nop
    3a6c:	20002740 	.word	0x20002740

00003a70 <Adafruit_LSM6DS::_read()>:
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    3a70:	b5f0      	push	{r4, r5, r6, r7, lr}
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    3a72:	2300      	movs	r3, #0
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    3a74:	b08f      	sub	sp, #60	; 0x3c
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    3a76:	2620      	movs	r6, #32
    3a78:	250e      	movs	r5, #14
    3a7a:	2701      	movs	r7, #1
/******************* Adafruit_Sensor functions *****************/
/*!
 *     @brief  Updates the measurement data for all sensors simultaneously
 */
/**************************************************************************/
void Adafruit_LSM6DS::_read(void) {
    3a7c:	4604      	mov	r4, r0
  // get raw readings
  Adafruit_BusIO_Register data_reg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);
    3a7e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    3a80:	6b81      	ldr	r1, [r0, #56]	; 0x38
    3a82:	eb0d 0006 	add.w	r0, sp, r6
    3a86:	9302      	str	r3, [sp, #8]
    3a88:	9703      	str	r7, [sp, #12]
    3a8a:	9501      	str	r5, [sp, #4]
    3a8c:	9600      	str	r6, [sp, #0]
    3a8e:	f7ff f8a7 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  uint8_t buffer[14];
  data_reg.read(buffer, 14);
    3a92:	462a      	mov	r2, r5
    3a94:	eb0d 0006 	add.w	r0, sp, r6
    3a98:	a904      	add	r1, sp, #16
    3a9a:	f7ff f925 	bl	2ce8 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>

  rawTemp = buffer[1] << 8 | buffer[0];
    3a9e:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3aa2:	f89d 7011 	ldrb.w	r7, [sp, #17]
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3aa6:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
    3aaa:	edd4 6a10 	vldr	s13, [r4, #64]	; 0x40
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    3aae:	ea43 2707 	orr.w	r7, r3, r7, lsl #8
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    3ab2:	f89d 6013 	ldrb.w	r6, [sp, #19]
    3ab6:	f89d 3012 	ldrb.w	r3, [sp, #18]
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    3aba:	b23f      	sxth	r7, r7
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3abc:	f89d 2014 	ldrb.w	r2, [sp, #20]
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    3ac0:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    3ac4:	f89d e019 	ldrb.w	lr, [sp, #25]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3ac8:	ee07 7a90 	vmov	s15, r7

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3acc:	f89d 3016 	ldrb.w	r3, [sp, #22]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3ad0:	f89d 5015 	ldrb.w	r5, [sp, #21]
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    3ad4:	b236      	sxth	r6, r6

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3ad6:	eeb8 6ae7 	vcvt.f32.s32	s12, s15

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3ada:	f89d 0017 	ldrb.w	r0, [sp, #23]

  rawAccX = buffer[9] << 8 | buffer[8];
    3ade:	f89d 1018 	ldrb.w	r1, [sp, #24]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3ae2:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3ae6:	ea43 2000 	orr.w	r0, r3, r0, lsl #8

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    3aea:	f89d c01b 	ldrb.w	ip, [sp, #27]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3aee:	eec6 7a26 	vdiv.f32	s15, s12, s13

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    3af2:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
  rawAccY = buffer[11] << 8 | buffer[10];
    3af6:	f89d 201a 	ldrb.w	r2, [sp, #26]

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3afa:	b22d      	sxth	r5, r5
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    3afc:	f89d e01d 	ldrb.w	lr, [sp, #29]
  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3b00:	b200      	sxth	r0, r0

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    3b02:	f89d 301c 	ldrb.w	r3, [sp, #28]
  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    3b06:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUT_TEMP_L, 14);

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
    3b0a:	8167      	strh	r7, [r4, #10]

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
    3b0c:	b209      	sxth	r1, r1
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    3b0e:	ea43 230e 	orr.w	r3, r3, lr, lsl #8

  float gyro_scale = 1; // range is in milli-dps per bit!
  switch (gyroRangeBuffered) {
    3b12:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
    3b16:	b212      	sxth	r2, r2
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
    3b18:	81a6      	strh	r6, [r4, #12]
  rawGyroY = buffer[5] << 8 | buffer[4];
  rawGyroZ = buffer[7] << 8 | buffer[6];

  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];
    3b1a:	b21b      	sxth	r3, r3
    3b1c:	2f0c      	cmp	r7, #12

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;

  rawGyroX = buffer[3] << 8 | buffer[2];
  rawGyroY = buffer[5] << 8 | buffer[4];
    3b1e:	81e5      	strh	r5, [r4, #14]
  rawGyroZ = buffer[7] << 8 | buffer[6];
    3b20:	8220      	strh	r0, [r4, #16]

  rawAccX = buffer[9] << 8 | buffer[8];
    3b22:	80a1      	strh	r1, [r4, #4]
  rawAccY = buffer[11] << 8 | buffer[10];
    3b24:	80e2      	strh	r2, [r4, #6]
  rawAccZ = buffer[13] << 8 | buffer[12];
    3b26:	8123      	strh	r3, [r4, #8]

  uint8_t buffer[14];
  data_reg.read(buffer, 14);

  rawTemp = buffer[1] << 8 | buffer[0];
  temperature = (rawTemp / temperature_sensitivity) + 25.0;
    3b28:	ee77 7a87 	vadd.f32	s15, s15, s14
    3b2c:	edc4 7a05 	vstr	s15, [r4, #20]
    3b30:	d860      	bhi.n	3bf4 <Adafruit_LSM6DS::_read()+0x184>
    3b32:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 3c10 <Adafruit_LSM6DS::_read()+0x1a0>
    3b36:	eb0e 0787 	add.w	r7, lr, r7, lsl #2
    3b3a:	edd7 7a00 	vldr	s15, [r7]
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b3e:	ee07 6a10 	vmov	s14, r6
    3b42:	ed9f 5a2f 	vldr	s10, [pc, #188]	; 3c00 <Adafruit_LSM6DS::_read()+0x190>
    3b46:	eddf 5a2f 	vldr	s11, [pc, #188]	; 3c04 <Adafruit_LSM6DS::_read()+0x194>
    3b4a:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b4e:	ee07 5a10 	vmov	s14, r5
    3b52:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b56:	ee07 0a10 	vmov	s14, r0
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b5a:	ee26 6a27 	vmul.f32	s12, s12, s15
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;

  float accel_scale = 1; // range is in milli-g per bit!
  switch (accelRangeBuffered) {
    3b5e:	f894 0050 	ldrb.w	r0, [r4, #80]	; 0x50
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b62:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b66:	ee66 6aa7 	vmul.f32	s13, s13, s15
    3b6a:	2803      	cmp	r0, #3
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b6c:	ee26 6a05 	vmul.f32	s12, s12, s10
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b70:	ee67 7a27 	vmul.f32	s15, s14, s15
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b74:	ee26 7a85 	vmul.f32	s14, s13, s10
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b78:	ee67 7a85 	vmul.f32	s15, s15, s10
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b7c:	eec7 6a25 	vdiv.f32	s13, s14, s11
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b80:	ee86 5a25 	vdiv.f32	s10, s12, s11
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b84:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b88:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
  case LSM6DS_GYRO_RANGE_125_DPS:
    gyro_scale = 4.375;
    break;
  }

  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b8c:	ed84 5a09 	vstr	s10, [r4, #36]	; 0x24
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
    3b90:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
    3b94:	d831      	bhi.n	3bfa <Adafruit_LSM6DS::_read()+0x18a>
    3b96:	4d1c      	ldr	r5, [pc, #112]	; (3c08 <Adafruit_LSM6DS::_read()+0x198>)
    3b98:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    3b9c:	edd0 7a00 	vldr	s15, [r0]
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3ba0:	ee07 1a10 	vmov	s14, r1
    3ba4:	ed9f 5a19 	vldr	s10, [pc, #100]	; 3c0c <Adafruit_LSM6DS::_read()+0x19c>
    3ba8:	eddf 5a16 	vldr	s11, [pc, #88]	; 3c04 <Adafruit_LSM6DS::_read()+0x194>
    3bac:	eeb8 6ac7 	vcvt.f32.s32	s12, s14
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bb0:	ee07 2a10 	vmov	s14, r2
    3bb4:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bb8:	ee07 3a10 	vmov	s14, r3
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bbc:	ee26 6a27 	vmul.f32	s12, s12, s15
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bc0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bc4:	ee66 6aa7 	vmul.f32	s13, s13, s15
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bc8:	ee26 6a05 	vmul.f32	s12, s12, s10
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bcc:	ee67 7a27 	vmul.f32	s15, s14, s15
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bd0:	ee26 7a85 	vmul.f32	s14, s13, s10
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bd4:	ee67 7a85 	vmul.f32	s15, s15, s10
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bd8:	eec7 6a25 	vdiv.f32	s13, s14, s11
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bdc:	ee86 5a25 	vdiv.f32	s10, s12, s11
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3be0:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3be4:	edc4 6a07 	vstr	s13, [r4, #28]
  case LSM6DS_ACCEL_RANGE_2_G:
    accel_scale = 0.061;
    break;
  }

  accX = rawAccX * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3be8:	ed84 5a06 	vstr	s10, [r4, #24]
  accY = rawAccY * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
  accZ = rawAccZ * accel_scale * SENSORS_GRAVITY_STANDARD / 1000;
    3bec:	ed84 7a08 	vstr	s14, [r4, #32]
}
    3bf0:	b00f      	add	sp, #60	; 0x3c
    3bf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  rawAccX = buffer[9] << 8 | buffer[8];
  rawAccY = buffer[11] << 8 | buffer[10];
  rawAccZ = buffer[13] << 8 | buffer[12];

  float gyro_scale = 1; // range is in milli-dps per bit!
  switch (gyroRangeBuffered) {
    3bf4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    3bf8:	e7a1      	b.n	3b3e <Adafruit_LSM6DS::_read()+0xce>
  gyroX = rawGyroX * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroY = rawGyroY * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;
  gyroZ = rawGyroZ * gyro_scale * SENSORS_DPS_TO_RADS / 1000.0;

  float accel_scale = 1; // range is in milli-g per bit!
  switch (accelRangeBuffered) {
    3bfa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    3bfe:	e7cf      	b.n	3ba0 <Adafruit_LSM6DS::_read()+0x130>
    3c00:	3c8efa35 	.word	0x3c8efa35
    3c04:	447a0000 	.word	0x447a0000
    3c08:	20000438 	.word	0x20000438
    3c0c:	411ce80a 	.word	0x411ce80a
    3c10:	200003f4 	.word	0x200003f4

00003c14 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's gyroscope sensor
*/
/**************************************************************************/
void Adafruit_LSM6DS_Gyro::getSensor(sensor_t *sensor) {
    3c14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3c16:	460c      	mov	r4, r1
    3c18:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3c1a:	2228      	movs	r2, #40	; 0x28
    3c1c:	2100      	movs	r1, #0
    3c1e:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3c20:	2701      	movs	r7, #1
    @brief  Gets the sensor_t data for the LSM6DS's gyroscope sensor
*/
/**************************************************************************/
void Adafruit_LSM6DS_Gyro::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3c22:	f002 fdf7 	bl	6814 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
    3c26:	220b      	movs	r2, #11
    3c28:	4909      	ldr	r1, [pc, #36]	; (3c50 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x3c>)
    3c2a:	4620      	mov	r0, r4
    3c2c:	f003 fa96 	bl	715c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3c30:	2300      	movs	r3, #0
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
    3c32:	2504      	movs	r5, #4
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
    3c34:	4807      	ldr	r0, [pc, #28]	; (3c54 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3c36:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
  sensor->max_value = +34.91;
    3c38:	4907      	ldr	r1, [pc, #28]	; (3c58 <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3c3a:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
  sensor->max_value = +34.91;
  sensor->resolution = 7.6358e-5; /* 4.375 mdps -> rad/s */
    3c3c:	4a07      	ldr	r2, [pc, #28]	; (3c5c <Adafruit_LSM6DS_Gyro::getSensor(sensor_t*)+0x48>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3c3e:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    3c40:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_GYROSCOPE;
  sensor->min_delay = 0;
    3c42:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_G", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_GYROSCOPE;
    3c44:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -34.91; /* -2000 dps -> rad/s (radians per second) */
    3c46:	61e0      	str	r0, [r4, #28]
  sensor->max_value = +34.91;
    3c48:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 7.6358e-5; /* 4.375 mdps -> rad/s */
    3c4a:	6222      	str	r2, [r4, #32]
    3c4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3c4e:	bf00      	nop
    3c50:	20000e00 	.word	0x20000e00
    3c54:	c20ba3d7 	.word	0xc20ba3d7
    3c58:	420ba3d7 	.word	0x420ba3d7
    3c5c:	38a02264 	.word	0x38a02264

00003c60 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's accelerometer
*/
/**************************************************************************/
void Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t *sensor) {
    3c60:	b570      	push	{r4, r5, r6, lr}
    3c62:	460c      	mov	r4, r1
    3c64:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3c66:	2228      	movs	r2, #40	; 0x28
    3c68:	2100      	movs	r1, #0
    3c6a:	4620      	mov	r0, r4
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
    3c6c:	4d0a      	ldr	r5, [pc, #40]	; (3c98 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x38>)
    @brief  Gets the sensor_t data for the LSM6DS's accelerometer
*/
/**************************************************************************/
void Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3c6e:	f002 fdd1 	bl	6814 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
    3c72:	220b      	movs	r2, #11
    3c74:	4909      	ldr	r1, [pc, #36]	; (3c9c <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x3c>)
    3c76:	4620      	mov	r0, r4
    3c78:	f003 fa70 	bl	715c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3c7c:	2200      	movs	r2, #0
  sensor->version = 1;
    3c7e:	2301      	movs	r3, #1
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
    3c80:	4807      	ldr	r0, [pc, #28]	; (3ca0 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x40>)
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3c82:	72e2      	strb	r2, [r4, #11]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
  sensor->resolution = 0.061;     /* 0.061 mg/LSB at +-2g */
    3c84:	4907      	ldr	r1, [pc, #28]	; (3ca4 <Adafruit_LSM6DS_Accelerometer::getSensor(sensor_t*)+0x44>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3c86:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
    3c88:	6262      	str	r2, [r4, #36]	; 0x24

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3c8a:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay = 0;
  sensor->min_value = -156.9064F; /*  -16g = 156.9064 m/s^2  */
    3c8c:	61e5      	str	r5, [r4, #28]
  sensor->max_value = 156.9064F;  /* 16g = 156.9064 m/s^2  */
    3c8e:	61a0      	str	r0, [r4, #24]
  sensor->resolution = 0.061;     /* 0.061 mg/LSB at +-2g */
    3c90:	6221      	str	r1, [r4, #32]
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_A", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3c92:	60e3      	str	r3, [r4, #12]
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_ACCELEROMETER;
    3c94:	6163      	str	r3, [r4, #20]
    3c96:	bd70      	pop	{r4, r5, r6, pc}
    3c98:	c31ce80a 	.word	0xc31ce80a
    3c9c:	20000e0c 	.word	0x20000e0c
    3ca0:	431ce80a 	.word	0x431ce80a
    3ca4:	3d79db23 	.word	0x3d79db23

00003ca8 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data for the LSM6DS's tenperature
*/
/**************************************************************************/
void Adafruit_LSM6DS_Temp::getSensor(sensor_t *sensor) {
    3ca8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3caa:	460c      	mov	r4, r1
    3cac:	4606      	mov	r6, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3cae:	2228      	movs	r2, #40	; 0x28
    3cb0:	2100      	movs	r1, #0
    3cb2:	4620      	mov	r0, r4

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3cb4:	2701      	movs	r7, #1
    @brief  Gets the sensor_t data for the LSM6DS's tenperature
*/
/**************************************************************************/
void Adafruit_LSM6DS_Temp::getSensor(sensor_t *sensor) {
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
    3cb6:	f002 fdad 	bl	6814 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
    3cba:	220b      	movs	r2, #11
    3cbc:	4909      	ldr	r1, [pc, #36]	; (3ce4 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x3c>)
    3cbe:	4620      	mov	r0, r4
    3cc0:	f003 fa4c 	bl	715c <strncpy>
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3cc4:	2300      	movs	r3, #0
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
  sensor->max_value = 85;
  sensor->resolution = 1; /* not a great sensor */
    3cc6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    3cca:	250d      	movs	r5, #13
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
    3ccc:	72e3      	strb	r3, [r4, #11]
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
    3cce:	4806      	ldr	r0, [pc, #24]	; (3ce8 <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x40>)

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
    3cd0:	68b6      	ldr	r6, [r6, #8]
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
  sensor->min_value = -40;
  sensor->max_value = 85;
    3cd2:	4906      	ldr	r1, [pc, #24]	; (3cec <Adafruit_LSM6DS_Temp::getSensor(sensor_t*)+0x44>)
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
    3cd4:	60e7      	str	r7, [r4, #12]
  sensor->sensor_id = _sensorID;
    3cd6:	6126      	str	r6, [r4, #16]
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
  sensor->min_delay = 0;
    3cd8:	6263      	str	r3, [r4, #36]	; 0x24
  /* Insert the sensor name in the fixed length char array */
  strncpy(sensor->name, "LSM6DS_T", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name) - 1] = 0;
  sensor->version = 1;
  sensor->sensor_id = _sensorID;
  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
    3cda:	6165      	str	r5, [r4, #20]
  sensor->min_delay = 0;
  sensor->min_value = -40;
    3cdc:	61e0      	str	r0, [r4, #28]
  sensor->max_value = 85;
    3cde:	61a1      	str	r1, [r4, #24]
  sensor->resolution = 1; /* not a great sensor */
    3ce0:	6222      	str	r2, [r4, #32]
    3ce2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3ce4:	20000e18 	.word	0x20000e18
    3ce8:	c2200000 	.word	0xc2200000
    3cec:	42aa0000 	.word	0x42aa0000

00003cf0 <Adafruit_LSM6DS::Adafruit_LSM6DS()>:
};

/*!
 *    @brief  Instantiates a new LSM6DS class
 */
Adafruit_LSM6DS::Adafruit_LSM6DS(void) {}
    3cf0:	2200      	movs	r2, #0
    3cf2:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
    3cf6:	b410      	push	{r4}
    3cf8:	4c07      	ldr	r4, [pc, #28]	; (3d18 <Adafruit_LSM6DS::Adafruit_LSM6DS()+0x28>)
    3cfa:	6401      	str	r1, [r0, #64]	; 0x40
    3cfc:	6004      	str	r4, [r0, #0]
    3cfe:	6382      	str	r2, [r0, #56]	; 0x38
    3d00:	63c2      	str	r2, [r0, #60]	; 0x3c
    3d02:	6442      	str	r2, [r0, #68]	; 0x44
    3d04:	6482      	str	r2, [r0, #72]	; 0x48
    3d06:	64c2      	str	r2, [r0, #76]	; 0x4c
    3d08:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
    3d0c:	f880 2051 	strb.w	r2, [r0, #81]	; 0x51
    3d10:	f85d 4b04 	ldr.w	r4, [sp], #4
    3d14:	4770      	bx	lr
    3d16:	bf00      	nop
    3d18:	20000450 	.word	0x20000450

00003d1c <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)>:
 *    @param  sensor_id
 *            The user-defined ID to differentiate different sensors
 *    @return True if initialization was successful, otherwise false.
 */
boolean Adafruit_LSM6DS::begin_I2C(uint8_t i2c_address, TwoWire *wire,
                                   int32_t sensor_id) {
    3d1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3d20:	4604      	mov	r4, r0
    3d22:	460e      	mov	r6, r1
  delete i2c_dev; // remove old interface
    3d24:	6b80      	ldr	r0, [r0, #56]	; 0x38
    3d26:	2110      	movs	r1, #16
 *    @param  sensor_id
 *            The user-defined ID to differentiate different sensors
 *    @return True if initialization was successful, otherwise false.
 */
boolean Adafruit_LSM6DS::begin_I2C(uint8_t i2c_address, TwoWire *wire,
                                   int32_t sensor_id) {
    3d28:	4617      	mov	r7, r2
    3d2a:	4698      	mov	r8, r3
  delete i2c_dev; // remove old interface
    3d2c:	f7fe feca 	bl	2ac4 <operator delete(void*, unsigned int)>

  i2c_dev = new Adafruit_I2CDevice(i2c_address, wire);
    3d30:	2010      	movs	r0, #16
    3d32:	f7fe fec3 	bl	2abc <operator new(unsigned int)>
    3d36:	4605      	mov	r5, r0
    3d38:	4631      	mov	r1, r6
    3d3a:	463a      	mov	r2, r7
    3d3c:	f7ff f88c 	bl	2e58 <Adafruit_I2CDevice::Adafruit_I2CDevice(unsigned char, TwoWire*)>
    3d40:	63a5      	str	r5, [r4, #56]	; 0x38

  if (!i2c_dev->begin()) {
    3d42:	4628      	mov	r0, r5
    3d44:	2101      	movs	r1, #1
    3d46:	f7ff f8ad 	bl	2ea4 <Adafruit_I2CDevice::begin(bool)>
    3d4a:	b908      	cbnz	r0, 3d50 <Adafruit_LSM6DS::begin_I2C(unsigned char, TwoWire*, long)+0x34>
    return false;
  }

  return _init(sensor_id);
}
    3d4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  if (!i2c_dev->begin()) {
    return false;
  }

  return _init(sensor_id);
    3d50:	6823      	ldr	r3, [r4, #0]
    3d52:	4641      	mov	r1, r8
    3d54:	4620      	mov	r0, r4
    3d56:	68db      	ldr	r3, [r3, #12]
}
    3d58:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  if (!i2c_dev->begin()) {
    return false;
  }

  return _init(sensor_id);
    3d5c:	4718      	bx	r3
    3d5e:	bf00      	nop

00003d60 <Adafruit_LSM6DS::reset()>:
/**************************************************************************/
/*!
    @brief Resets the sensor to its power-on state, clearing all registers and
   memory
*/
void Adafruit_LSM6DS::reset(void) {
    3d60:	b570      	push	{r4, r5, r6, lr}

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3d62:	2401      	movs	r4, #1
/**************************************************************************/
/*!
    @brief Resets the sensor to its power-on state, clearing all registers and
   memory
*/
void Adafruit_LSM6DS::reset(void) {
    3d64:	b08c      	sub	sp, #48	; 0x30

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3d66:	2500      	movs	r5, #0
    3d68:	2612      	movs	r6, #18
    3d6a:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    3d6c:	6b81      	ldr	r1, [r0, #56]	; 0x38
    3d6e:	462b      	mov	r3, r5
    3d70:	a806      	add	r0, sp, #24
    3d72:	9403      	str	r4, [sp, #12]
    3d74:	9401      	str	r4, [sp, #4]
    3d76:	9502      	str	r5, [sp, #8]
    3d78:	9600      	str	r6, [sp, #0]
    3d7a:	f7fe ff31 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits sw_reset =
      Adafruit_BusIO_RegisterBits(&ctrl3, 1, 0);
    3d7e:	a906      	add	r1, sp, #24
    3d80:	462b      	mov	r3, r5
    3d82:	4622      	mov	r2, r4
    3d84:	a804      	add	r0, sp, #16
    3d86:	f7ff f827 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  // Adafruit_BusIO_RegisterBits boot = Adafruit_BusIO_RegisterBits(&ctrl3, 1,
  // 7);

  sw_reset.write(true);
    3d8a:	4621      	mov	r1, r4
    3d8c:	a804      	add	r0, sp, #16
    3d8e:	f7ff f839 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
    3d92:	e002      	b.n	3d9a <Adafruit_LSM6DS::reset()+0x3a>

  while (sw_reset.read()) {
    delay(1);
    3d94:	2001      	movs	r0, #1
    3d96:	f7fd fa49 	bl	122c <delay>
  // Adafruit_BusIO_RegisterBits boot = Adafruit_BusIO_RegisterBits(&ctrl3, 1,
  // 7);

  sw_reset.write(true);

  while (sw_reset.read()) {
    3d9a:	a804      	add	r0, sp, #16
    3d9c:	f7ff f824 	bl	2de8 <Adafruit_BusIO_RegisterBits::read()>
    3da0:	2800      	cmp	r0, #0
    3da2:	d1f7      	bne.n	3d94 <Adafruit_LSM6DS::reset()+0x34>
    delay(1);
  }
}
    3da4:	b00c      	add	sp, #48	; 0x30
    3da6:	bd70      	pop	{r4, r5, r6, pc}

00003da8 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>:
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    3da8:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3daa:	2301      	movs	r3, #1
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    3dac:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3dae:	6b87      	ldr	r7, [r0, #56]	; 0x38
    3db0:	2610      	movs	r6, #16
    3db2:	2400      	movs	r4, #0
    3db4:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
    @brief Sets the accelerometer data rate.
    @param  data_rate
            The the accelerometer data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setAccelDataRate(lsm6ds_data_rate_t data_rate) {
    3db6:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3db8:	9303      	str	r3, [sp, #12]
    3dba:	4639      	mov	r1, r7
    3dbc:	9301      	str	r3, [sp, #4]
    3dbe:	a806      	add	r0, sp, #24
    3dc0:	4623      	mov	r3, r4
    3dc2:	9402      	str	r4, [sp, #8]
    3dc4:	9600      	str	r6, [sp, #0]
    3dc6:	f7fe ff0b 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits accel_data_rate =
      Adafruit_BusIO_RegisterBits(&ctrl1, 4, 4);
    3dca:	2304      	movs	r3, #4
    3dcc:	a906      	add	r1, sp, #24
    3dce:	eb0d 0006 	add.w	r0, sp, r6
    3dd2:	461a      	mov	r2, r3
    3dd4:	f7ff f800 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  accel_data_rate.write(data_rate);
    3dd8:	4629      	mov	r1, r5
    3dda:	eb0d 0006 	add.w	r0, sp, r6
    3dde:	f7ff f811 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3de2:	b00d      	add	sp, #52	; 0x34
    3de4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3de6:	bf00      	nop

00003de8 <Adafruit_LSM6DS::setAccelRange(accel_range)>:
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    3de8:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3dea:	2301      	movs	r3, #1
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    3dec:	b08d      	sub	sp, #52	; 0x34
    3dee:	4604      	mov	r4, r0

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3df0:	2710      	movs	r7, #16
    3df2:	2600      	movs	r6, #0
    3df4:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/**************************************************************************/
/*!
    @brief Sets the accelerometer measurement range.
    @param new_range The `lsm6ds_accel_range_t` range to set.
*/
void Adafruit_LSM6DS::setAccelRange(lsm6ds_accel_range_t new_range) {
    3df6:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl1 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL1_XL);
    3df8:	a806      	add	r0, sp, #24
    3dfa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    3dfc:	9303      	str	r3, [sp, #12]
    3dfe:	9301      	str	r3, [sp, #4]
    3e00:	4633      	mov	r3, r6
    3e02:	9602      	str	r6, [sp, #8]
    3e04:	9700      	str	r7, [sp, #0]
    3e06:	f7fe feeb 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits accel_range =
      Adafruit_BusIO_RegisterBits(&ctrl1, 2, 2);
    3e0a:	2302      	movs	r3, #2
    3e0c:	a906      	add	r1, sp, #24
    3e0e:	eb0d 0007 	add.w	r0, sp, r7
    3e12:	461a      	mov	r2, r3
    3e14:	f7fe ffe0 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  accel_range.write(new_range);
    3e18:	4629      	mov	r1, r5
    3e1a:	eb0d 0007 	add.w	r0, sp, r7
    3e1e:	f7fe fff1 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  accelRangeBuffered = new_range;
    3e22:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
}
    3e26:	b00d      	add	sp, #52	; 0x34
    3e28:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3e2a:	bf00      	nop

00003e2c <Adafruit_LSM6DS::setGyroDataRate(data_rate)>:
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    3e2c:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3e2e:	2301      	movs	r3, #1
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    3e30:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3e32:	6b87      	ldr	r7, [r0, #56]	; 0x38
    3e34:	2400      	movs	r4, #0
    3e36:	2611      	movs	r6, #17
    3e38:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
    @brief Sets the gyro data rate.
    @param  data_rate
            The the gyro data rate. Must be a `lsm6ds_data_rate_t`.
*/
void Adafruit_LSM6DS::setGyroDataRate(lsm6ds_data_rate_t data_rate) {
    3e3a:	460d      	mov	r5, r1

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3e3c:	9303      	str	r3, [sp, #12]
    3e3e:	4639      	mov	r1, r7
    3e40:	9301      	str	r3, [sp, #4]
    3e42:	a806      	add	r0, sp, #24
    3e44:	4623      	mov	r3, r4
    3e46:	9402      	str	r4, [sp, #8]
    3e48:	9600      	str	r6, [sp, #0]
    3e4a:	f7fe fec9 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits gyro_data_rate =
      Adafruit_BusIO_RegisterBits(&ctrl2, 4, 4);
    3e4e:	2304      	movs	r3, #4
    3e50:	a906      	add	r1, sp, #24
    3e52:	a804      	add	r0, sp, #16
    3e54:	461a      	mov	r2, r3
    3e56:	f7fe ffbf 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  gyro_data_rate.write(data_rate);
    3e5a:	4629      	mov	r1, r5
    3e5c:	a804      	add	r0, sp, #16
    3e5e:	f7fe ffd1 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3e62:	b00d      	add	sp, #52	; 0x34
    3e64:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3e66:	bf00      	nop

00003e68 <Adafruit_LSM6DS::setGyroRange(gyro_range)>:
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    3e68:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3e6a:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    3e6c:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3e6e:	2500      	movs	r5, #0
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    3e70:	4604      	mov	r4, r0

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3e72:	2301      	movs	r3, #1
    3e74:	6b80      	ldr	r0, [r0, #56]	; 0x38
    3e76:	2711      	movs	r7, #17
/**************************************************************************/
/*!
    @brief Sets the gyro range.
    @param new_range The `lsm6ds_gyro_range_t` to set.
*/
void Adafruit_LSM6DS::setGyroRange(lsm6ds_gyro_range_t new_range) {
    3e78:	460e      	mov	r6, r1

  Adafruit_BusIO_Register ctrl2 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL2_G);
    3e7a:	9303      	str	r3, [sp, #12]
    3e7c:	4601      	mov	r1, r0
    3e7e:	9301      	str	r3, [sp, #4]
    3e80:	a806      	add	r0, sp, #24
    3e82:	462b      	mov	r3, r5
    3e84:	9502      	str	r5, [sp, #8]
    3e86:	9700      	str	r7, [sp, #0]
    3e88:	f7fe feaa 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits gyro_range =
      Adafruit_BusIO_RegisterBits(&ctrl2, 4, 0);
    3e8c:	462b      	mov	r3, r5
    3e8e:	a906      	add	r1, sp, #24
    3e90:	2204      	movs	r2, #4
    3e92:	a804      	add	r0, sp, #16
    3e94:	f7fe ffa0 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  gyro_range.write(new_range);
    3e98:	4631      	mov	r1, r6
    3e9a:	a804      	add	r0, sp, #16
    3e9c:	f7fe ffb2 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  gyroRangeBuffered = new_range;
    3ea0:	f884 6051 	strb.w	r6, [r4, #81]	; 0x51
}
    3ea4:	b00d      	add	sp, #52	; 0x34
    3ea6:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003ea8 <Adafruit_LSM6DS::_init(long)>:

/*!  @brief  Unique subclass initializer post i2c/spi init
 *   @param sensor_id Optional unique ID for the sensor set
 *   @returns True if chip identified and initialized
 */
bool Adafruit_LSM6DS::_init(int32_t sensor_id) {
    3ea8:	b510      	push	{r4, lr}
    3eaa:	4604      	mov	r4, r0
  (void)sensor_id;

  // Enable accelerometer with 104 Hz data rate, 4G
  setAccelDataRate(LSM6DS_RATE_104_HZ);
    3eac:	2104      	movs	r1, #4
    3eae:	f7ff ff7b 	bl	3da8 <Adafruit_LSM6DS::setAccelDataRate(data_rate)>
  setAccelRange(LSM6DS_ACCEL_RANGE_4_G);
    3eb2:	2102      	movs	r1, #2
    3eb4:	4620      	mov	r0, r4
    3eb6:	f7ff ff97 	bl	3de8 <Adafruit_LSM6DS::setAccelRange(accel_range)>

  // Enable gyro with 104 Hz data rate, 2000 dps
  setGyroDataRate(LSM6DS_RATE_104_HZ);
    3eba:	4620      	mov	r0, r4
    3ebc:	2104      	movs	r1, #4
    3ebe:	f7ff ffb5 	bl	3e2c <Adafruit_LSM6DS::setGyroDataRate(data_rate)>
  setGyroRange(LSM6DS_GYRO_RANGE_2000_DPS);
    3ec2:	4620      	mov	r0, r4
    3ec4:	210c      	movs	r1, #12
    3ec6:	f7ff ffcf 	bl	3e68 <Adafruit_LSM6DS::setGyroRange(gyro_range)>

  delay(10);
    3eca:	200a      	movs	r0, #10
    3ecc:	f7fd f9ae 	bl	122c <delay>

  // delete objects if sensor is reinitialized
  delete temp_sensor;
    3ed0:	6c60      	ldr	r0, [r4, #68]	; 0x44
    3ed2:	b110      	cbz	r0, 3eda <Adafruit_LSM6DS::_init(long)+0x32>
    3ed4:	6803      	ldr	r3, [r0, #0]
    3ed6:	685b      	ldr	r3, [r3, #4]
    3ed8:	4798      	blx	r3
  delete accel_sensor;
    3eda:	6ca0      	ldr	r0, [r4, #72]	; 0x48
    3edc:	b110      	cbz	r0, 3ee4 <Adafruit_LSM6DS::_init(long)+0x3c>
    3ede:	6803      	ldr	r3, [r0, #0]
    3ee0:	685b      	ldr	r3, [r3, #4]
    3ee2:	4798      	blx	r3
  delete gyro_sensor;
    3ee4:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    3ee6:	b110      	cbz	r0, 3eee <Adafruit_LSM6DS::_init(long)+0x46>
    3ee8:	6803      	ldr	r3, [r0, #0]
    3eea:	685b      	ldr	r3, [r3, #4]
    3eec:	4798      	blx	r3

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
    3eee:	2010      	movs	r0, #16
    3ef0:	f7fe fde4 	bl	2abc <operator new(unsigned int)>
/** Adafruit Unified Sensor interface for temperature component of LSM6DS */
class Adafruit_LSM6DS_Temp : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the temp sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Temp(Adafruit_LSM6DS *parent) { _theLSM6DS = parent; }
    3ef4:	490f      	ldr	r1, [pc, #60]	; (3f34 <Adafruit_LSM6DS::_init(long)+0x8c>)
    3ef6:	4603      	mov	r3, r0
    3ef8:	f44f 62da 	mov.w	r2, #1744	; 0x6d0
    3efc:	6460      	str	r0, [r4, #68]	; 0x44
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
    3efe:	2010      	movs	r0, #16
    3f00:	60dc      	str	r4, [r3, #12]
    3f02:	6019      	str	r1, [r3, #0]
    3f04:	609a      	str	r2, [r3, #8]
    3f06:	f7fe fdd9 	bl	2abc <operator new(unsigned int)>
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the accelerometer
     sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Accelerometer(Adafruit_LSM6DS *parent) {
    3f0a:	490b      	ldr	r1, [pc, #44]	; (3f38 <Adafruit_LSM6DS::_init(long)+0x90>)
    3f0c:	4603      	mov	r3, r0
    3f0e:	f240 62d1 	movw	r2, #1745	; 0x6d1
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    3f12:	2010      	movs	r0, #16
  delete temp_sensor;
  delete accel_sensor;
  delete gyro_sensor;

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
    3f14:	64a3      	str	r3, [r4, #72]	; 0x48
    _theLSM6DS = parent;
    3f16:	60dc      	str	r4, [r3, #12]
class Adafruit_LSM6DS_Accelerometer : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the accelerometer
     sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Accelerometer(Adafruit_LSM6DS *parent) {
    3f18:	6019      	str	r1, [r3, #0]
    3f1a:	609a      	str	r2, [r3, #8]
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    3f1c:	f7fe fdce 	bl	2abc <operator new(unsigned int)>
/** Adafruit Unified Sensor interface for gyro component of LSM6DS */
class Adafruit_LSM6DS_Gyro : public Adafruit_Sensor {
public:
  /** @brief Create an Adafruit_Sensor compatible object for the gyro sensor
      @param parent A pointer to the LSM6DS class */
  Adafruit_LSM6DS_Gyro(Adafruit_LSM6DS *parent) { _theLSM6DS = parent; }
    3f20:	4906      	ldr	r1, [pc, #24]	; (3f3c <Adafruit_LSM6DS::_init(long)+0x94>)
    3f22:	4603      	mov	r3, r0
    3f24:	f240 62d2 	movw	r2, #1746	; 0x6d2

  return false;
};
    3f28:	2000      	movs	r0, #0
    3f2a:	60dc      	str	r4, [r3, #12]
  delete accel_sensor;
  delete gyro_sensor;

  temp_sensor = new Adafruit_LSM6DS_Temp(this);
  accel_sensor = new Adafruit_LSM6DS_Accelerometer(this);
  gyro_sensor = new Adafruit_LSM6DS_Gyro(this);
    3f2c:	64e3      	str	r3, [r4, #76]	; 0x4c
    3f2e:	6019      	str	r1, [r3, #0]
    3f30:	609a      	str	r2, [r3, #8]

  return false;
};
    3f32:	bd10      	pop	{r4, pc}
    3f34:	20000508 	.word	0x20000508
    3f38:	20000524 	.word	0x20000524
    3f3c:	200004ec 	.word	0x200004ec

00003f40 <Adafruit_LSM6DS::configIntOutputs(bool, bool)>:
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    3f40:	b5f0      	push	{r4, r5, r6, r7, lr}

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3f42:	f8d0 c03c 	ldr.w	ip, [r0, #60]	; 0x3c
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    3f46:	b08d      	sub	sp, #52	; 0x34

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3f48:	f8d0 e038 	ldr.w	lr, [r0, #56]	; 0x38
    3f4c:	2401      	movs	r4, #1
    3f4e:	2300      	movs	r3, #0
    3f50:	2712      	movs	r7, #18
    @param active_low true to set the pins  as active high, false to set the
   mode to active low
    @param open_drain true to set the pin mode as open-drain, false to set the
   mode to push-pull
*/
void Adafruit_LSM6DS::configIntOutputs(bool active_low, bool open_drain) {
    3f52:	460e      	mov	r6, r1
    3f54:	4615      	mov	r5, r2

  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_CTRL3_C);
    3f56:	4671      	mov	r1, lr
    3f58:	4662      	mov	r2, ip
    3f5a:	9302      	str	r3, [sp, #8]
    3f5c:	a806      	add	r0, sp, #24
    3f5e:	9403      	str	r4, [sp, #12]
    3f60:	9401      	str	r4, [sp, #4]
    3f62:	9700      	str	r7, [sp, #0]
    3f64:	f7fe fe3c 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits ppod_bits =
      Adafruit_BusIO_RegisterBits(&ctrl3, 2, 4);
    3f68:	a906      	add	r1, sp, #24
    3f6a:	2304      	movs	r3, #4
    3f6c:	2202      	movs	r2, #2
    3f6e:	a804      	add	r0, sp, #16
    3f70:	f7fe ff32 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  ppod_bits.write((active_low << 1) | open_drain);
    3f74:	a804      	add	r0, sp, #16
    3f76:	ea45 0146 	orr.w	r1, r5, r6, lsl #1
    3f7a:	f7fe ff43 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3f7e:	b00d      	add	sp, #52	; 0x34
    3f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3f82:	bf00      	nop

00003f84 <Adafruit_LSM6DS::configInt1(bool, bool, bool, bool, bool)>:
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    3f84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3f88:	4692      	mov	sl, r2
    3f8a:	461e      	mov	r6, r3
    3f8c:	b093      	sub	sp, #76	; 0x4c

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    3f8e:	2401      	movs	r4, #1
    3f90:	2500      	movs	r5, #0
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    3f92:	4680      	mov	r8, r0

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    3f94:	270d      	movs	r7, #13
    3f96:	6b80      	ldr	r0, [r0, #56]	; 0x38
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    3f98:	4689      	mov	r9, r1

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    3f9a:	ea46 064a 	orr.w	r6, r6, sl, lsl #1
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    3f9e:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
    3fa2:	462b      	mov	r3, r5
    3fa4:	4601      	mov	r1, r0
    3fa6:	9700      	str	r7, [sp, #0]
    3fa8:	a806      	add	r0, sp, #24
    3faa:	9403      	str	r4, [sp, #12]
    3fac:	9401      	str	r4, [sp, #4]
    3fae:	9502      	str	r5, [sp, #8]
    @param drdy_xl true to output the data ready accelerometer interrupt
    @param step_detect true to output the step detection interrupt (default off)
    @param wakeup true to output the wake up interrupt (default off)
*/
void Adafruit_LSM6DS::configInt1(bool drdy_temp, bool drdy_g, bool drdy_xl,
                                 bool step_detect, bool wakeup) {
    3fb0:	f89d b070 	ldrb.w	fp, [sp, #112]	; 0x70
    3fb4:	f89d 7074 	ldrb.w	r7, [sp, #116]	; 0x74

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);
    3fb8:	f7fe fe12 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    3fbc:	ea46 0189 	orr.w	r1, r6, r9, lsl #2

  Adafruit_BusIO_Register md1cfg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_MD1_CFG);
    3fc0:	265e      	movs	r6, #94	; 0x5e

  Adafruit_BusIO_Register int1_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT1_CTRL);

  int1_ctrl.write((step_detect << 7) | (drdy_temp << 2) | (drdy_g << 1) |
                  drdy_xl);
    3fc2:	462a      	mov	r2, r5
    3fc4:	a806      	add	r0, sp, #24
    3fc6:	ea41 11cb 	orr.w	r1, r1, fp, lsl #7
    3fca:	f7fe fe6d 	bl	2ca8 <Adafruit_BusIO_Register::write(unsigned long, unsigned char)>

  Adafruit_BusIO_Register md1cfg = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_MD1_CFG);
    3fce:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
    3fd2:	f8d8 1038 	ldr.w	r1, [r8, #56]	; 0x38
    3fd6:	462b      	mov	r3, r5
    3fd8:	9403      	str	r4, [sp, #12]
    3fda:	a80c      	add	r0, sp, #48	; 0x30
    3fdc:	9502      	str	r5, [sp, #8]
    3fde:	9401      	str	r4, [sp, #4]
    3fe0:	9600      	str	r6, [sp, #0]
    3fe2:	f7fe fdfd 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits wu = Adafruit_BusIO_RegisterBits(&md1cfg, 1, 5);
    3fe6:	4622      	mov	r2, r4
    3fe8:	a90c      	add	r1, sp, #48	; 0x30
    3fea:	2305      	movs	r3, #5
    3fec:	a804      	add	r0, sp, #16
    3fee:	f7fe fef3 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  wu.write(wakeup);
    3ff2:	4639      	mov	r1, r7
    3ff4:	a804      	add	r0, sp, #16
    3ff6:	f7fe ff05 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    3ffa:	b013      	add	sp, #76	; 0x4c
    3ffc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004000 <Adafruit_LSM6DS::configInt2(bool, bool, bool)>:
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    4000:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    4004:	f8d0 c03c 	ldr.w	ip, [r0, #60]	; 0x3c
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    4008:	b08c      	sub	sp, #48	; 0x30

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    400a:	6b80      	ldr	r0, [r0, #56]	; 0x38
    400c:	f04f 0e0e 	mov.w	lr, #14
    4010:	2500      	movs	r5, #0
    4012:	2601      	movs	r6, #1
    4014:	f8cd e000 	str.w	lr, [sp]
    @brief Enables and disables the data ready interrupt on INT 2.
    @param drdy_temp true to output the data ready temperature interrupt
    @param drdy_g true to output the data ready gyro interrupt
    @param drdy_xl true to output the data ready accelerometer interrupt
*/
void Adafruit_LSM6DS::configInt2(bool drdy_temp, bool drdy_g, bool drdy_xl) {
    4018:	460f      	mov	r7, r1
    401a:	4690      	mov	r8, r2
    401c:	461c      	mov	r4, r3

  Adafruit_BusIO_Register int2_ctrl = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_INT2_CTRL);
    401e:	4662      	mov	r2, ip
    4020:	4601      	mov	r1, r0
    4022:	462b      	mov	r3, r5
    4024:	a806      	add	r0, sp, #24
    4026:	9603      	str	r6, [sp, #12]
    4028:	9601      	str	r6, [sp, #4]
    402a:	9502      	str	r5, [sp, #8]
    402c:	f7fe fdd8 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  Adafruit_BusIO_RegisterBits int2_drdy_bits =
      Adafruit_BusIO_RegisterBits(&int2_ctrl, 3, 0);
    4030:	462b      	mov	r3, r5
    4032:	a906      	add	r1, sp, #24
    4034:	2203      	movs	r2, #3
    4036:	a804      	add	r0, sp, #16
    4038:	f7fe fece 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  int2_drdy_bits.write((drdy_temp << 2) | (drdy_g << 1) | drdy_xl);
    403c:	a804      	add	r0, sp, #16
    403e:	ea44 0148 	orr.w	r1, r4, r8, lsl #1
    4042:	ea41 0187 	orr.w	r1, r1, r7, lsl #2
    4046:	f7fe fedd 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>
}
    404a:	b00c      	add	sp, #48	; 0x30
    404c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004050 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    4050:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    4054:	f04f 0c28 	mov.w	ip, #40	; 0x28
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    4058:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    405a:	f8d0 903c 	ldr.w	r9, [r0, #60]	; 0x3c
    405e:	f04f 0e00 	mov.w	lr, #0
    4062:	6b80      	ldr	r0, [r0, #56]	; 0x38
    4064:	f04f 0806 	mov.w	r8, #6
    4068:	2401      	movs	r4, #1
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    406a:	460f      	mov	r7, r1
    406c:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    406e:	4601      	mov	r1, r0
    4070:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readAcceleration(float &x, float &y, float &z) {
    4072:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);
    4074:	a806      	add	r0, sp, #24
    4076:	9403      	str	r4, [sp, #12]
    4078:	4673      	mov	r3, lr
    407a:	f8cd e008 	str.w	lr, [sp, #8]
    407e:	f8cd 8004 	str.w	r8, [sp, #4]
    4082:	f8cd c000 	str.w	ip, [sp]
    4086:	f7fe fdab 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!accel_data.read((uint8_t *)data, sizeof(data))) {
    408a:	4642      	mov	r2, r8
    408c:	a806      	add	r0, sp, #24
    408e:	a904      	add	r1, sp, #16
    4090:	f7fe fe2a 	bl	2ce8 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    4094:	b388      	cbz	r0, 40fa <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xaa>
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    4096:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    409a:	eeb1 4b00 	vmov.f64	d4, #16	; 0x40800000  4.0
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;

  return 1;
    409e:	4620      	mov	r0, r4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    40a0:	ee05 3a10 	vmov	s10, r3
  y = data[1] * 4.0 / 32768.0;
    40a4:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    40a8:	ee06 3a10 	vmov	s12, r3
  z = data[2] * 4.0 / 32768.0;
    40ac:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    40b0:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;
    40b4:	ee07 3a10 	vmov	s14, r3
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
  y = data[1] * 4.0 / 32768.0;
    40b8:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
  z = data[2] * 4.0 / 32768.0;
    40bc:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    40c0:	ee25 5b04 	vmul.f64	d5, d5, d4
  y = data[1] * 4.0 / 32768.0;
    40c4:	ee26 6b04 	vmul.f64	d6, d6, d4
  z = data[2] * 4.0 / 32768.0;
    40c8:	ee27 7b04 	vmul.f64	d7, d7, d4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    40cc:	ed9f 4b0e 	vldr	d4, [pc, #56]	; 4108 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xb8>
    40d0:	ee25 5b04 	vmul.f64	d5, d5, d4
  y = data[1] * 4.0 / 32768.0;
    40d4:	ee26 6b04 	vmul.f64	d6, d6, d4
  z = data[2] * 4.0 / 32768.0;
    40d8:	ee27 7b04 	vmul.f64	d7, d7, d4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    40dc:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
  y = data[1] * 4.0 / 32768.0;
    40e0:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 4.0 / 32768.0;
    40e4:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -4 – 4
  x = data[0] * 4.0 / 32768.0;
    40e8:	ed87 5a00 	vstr	s10, [r7]
  y = data[1] * 4.0 / 32768.0;
    40ec:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 4.0 / 32768.0;
    40f0:	ed85 7a00 	vstr	s14, [r5]

  return 1;
}
    40f4:	b00d      	add	sp, #52	; 0x34
    40f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register accel_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_A, 6);

  if (!accel_data.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    40fa:	4b05      	ldr	r3, [pc, #20]	; (4110 <Adafruit_LSM6DS::readAcceleration(float&, float&, float&)+0xc0>)
    40fc:	602b      	str	r3, [r5, #0]
    40fe:	6033      	str	r3, [r6, #0]
    4100:	603b      	str	r3, [r7, #0]
  x = data[0] * 4.0 / 32768.0;
  y = data[1] * 4.0 / 32768.0;
  z = data[2] * 4.0 / 32768.0;

  return 1;
}
    4102:	b00d      	add	sp, #52	; 0x34
    4104:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4108:	00000000 	.word	0x00000000
    410c:	3f000000 	.word	0x3f000000
    4110:	7fc00000 	.word	0x7fc00000
    4114:	00000000 	.word	0x00000000

00004118 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)>:
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    4118:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    411c:	f04f 0c22 	mov.w	ip, #34	; 0x22
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    4120:	b08d      	sub	sp, #52	; 0x34
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    4122:	f8d0 903c 	ldr.w	r9, [r0, #60]	; 0x3c
    4126:	f04f 0e00 	mov.w	lr, #0
    412a:	6b80      	ldr	r0, [r0, #56]	; 0x38
    412c:	f04f 0806 	mov.w	r8, #6
    4130:	2401      	movs	r4, #1
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    4132:	460f      	mov	r7, r1
    4134:	4616      	mov	r6, r2
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    4136:	4601      	mov	r1, r0
    4138:	464a      	mov	r2, r9
    @param x reference to x axis
    @param y reference to y axis
    @param z reference to z axis
    @returns 1 if success, 0 if not
*/
int Adafruit_LSM6DS::readGyroscope(float &x, float &y, float &z) {
    413a:	461d      	mov	r5, r3
  int16_t data[3];

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);
    413c:	a806      	add	r0, sp, #24
    413e:	9403      	str	r4, [sp, #12]
    4140:	4673      	mov	r3, lr
    4142:	f8cd e008 	str.w	lr, [sp, #8]
    4146:	f8cd 8004 	str.w	r8, [sp, #4]
    414a:	f8cd c000 	str.w	ip, [sp]
    414e:	f7fe fd47 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  if (!gyro_data.read((uint8_t *)data, sizeof(data))) {
    4152:	4642      	mov	r2, r8
    4154:	a806      	add	r0, sp, #24
    4156:	a904      	add	r1, sp, #16
    4158:	f7fe fdc6 	bl	2ce8 <Adafruit_BusIO_Register::read(unsigned char*, unsigned char)>
    415c:	b388      	cbz	r0, 41c2 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xaa>
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    415e:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;

  return 1;
    4162:	4620      	mov	r0, r4
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    4164:	ee04 3a10 	vmov	s8, r3
  y = data[1] * 2000.0 / 32768.0;
    4168:	f9bd 3012 	ldrsh.w	r3, [sp, #18]
    416c:	ee05 3a10 	vmov	s10, r3
  z = data[2] * 2000.0 / 32768.0;
    4170:	f9bd 3014 	ldrsh.w	r3, [sp, #20]
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    4174:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;
    4178:	ee07 3a10 	vmov	s14, r3
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
  y = data[1] * 2000.0 / 32768.0;
    417c:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
  z = data[2] * 2000.0 / 32768.0;
    4180:	eeb8 6bc7 	vcvt.f64.s32	d6, s14
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    4184:	ed9f 7b12 	vldr	d7, [pc, #72]	; 41d0 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xb8>
    4188:	ed9f 3b13 	vldr	d3, [pc, #76]	; 41d8 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xc0>
  y = data[1] * 2000.0 / 32768.0;
    418c:	ee25 5b07 	vmul.f64	d5, d5, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    4190:	ee24 4b07 	vmul.f64	d4, d4, d7
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;
    4194:	ee26 7b07 	vmul.f64	d7, d6, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    4198:	ee24 4b03 	vmul.f64	d4, d4, d3
  y = data[1] * 2000.0 / 32768.0;
    419c:	ee25 6b03 	vmul.f64	d6, d5, d3
  z = data[2] * 2000.0 / 32768.0;
    41a0:	ee27 7b03 	vmul.f64	d7, d7, d3
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    41a4:	eeb7 4bc4 	vcvt.f32.f64	s8, d4
  y = data[1] * 2000.0 / 32768.0;
    41a8:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
  z = data[2] * 2000.0 / 32768.0;
    41ac:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    x = y = z = NAN;
    return 0;
  }

  // scale to range of -2000 – 2000
  x = data[0] * 2000.0 / 32768.0;
    41b0:	ed87 4a00 	vstr	s8, [r7]
  y = data[1] * 2000.0 / 32768.0;
    41b4:	ed86 6a00 	vstr	s12, [r6]
  z = data[2] * 2000.0 / 32768.0;
    41b8:	ed85 7a00 	vstr	s14, [r5]

  return 1;
}
    41bc:	b00d      	add	sp, #52	; 0x34
    41be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  Adafruit_BusIO_Register gyro_data = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_OUTX_L_G, 6);

  if (!gyro_data.read((uint8_t *)data, sizeof(data))) {
    x = y = z = NAN;
    41c2:	4b07      	ldr	r3, [pc, #28]	; (41e0 <Adafruit_LSM6DS::readGyroscope(float&, float&, float&)+0xc8>)
    41c4:	602b      	str	r3, [r5, #0]
    41c6:	6033      	str	r3, [r6, #0]
    41c8:	603b      	str	r3, [r7, #0]
  x = data[0] * 2000.0 / 32768.0;
  y = data[1] * 2000.0 / 32768.0;
  z = data[2] * 2000.0 / 32768.0;

  return 1;
}
    41ca:	b00d      	add	sp, #52	; 0x34
    41cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    41d0:	00000000 	.word	0x00000000
    41d4:	409f4000 	.word	0x409f4000
    41d8:	00000000 	.word	0x00000000
    41dc:	3f000000 	.word	0x3f000000
    41e0:	7fc00000 	.word	0x7fc00000

000041e4 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()>:

/*!
 *    @brief  Class that stores state and functions for interacting with
 *            the LSM6DSOX I2C Digital Potentiometer
 */
class Adafruit_LSM6DSOX : public Adafruit_LSM6DS {
    41e4:	4b03      	ldr	r3, [pc, #12]	; (41f4 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()+0x10>)
    41e6:	b510      	push	{r4, lr}
    41e8:	4604      	mov	r4, r0
    41ea:	6003      	str	r3, [r0, #0]
    41ec:	f7ff fba6 	bl	393c <Adafruit_LSM6DS::~Adafruit_LSM6DS()>
    41f0:	4620      	mov	r0, r4
    41f2:	bd10      	pop	{r4, pc}
    41f4:	200004a8 	.word	0x200004a8

000041f8 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()>:
    41f8:	4b05      	ldr	r3, [pc, #20]	; (4210 <Adafruit_LSM6DSOX::~Adafruit_LSM6DSOX()+0x18>)
    41fa:	b510      	push	{r4, lr}
    41fc:	4604      	mov	r4, r0
    41fe:	6003      	str	r3, [r0, #0]
    4200:	f7ff fb9c 	bl	393c <Adafruit_LSM6DS::~Adafruit_LSM6DS()>
    4204:	2154      	movs	r1, #84	; 0x54
    4206:	4620      	mov	r0, r4
    4208:	f7fe fc5c 	bl	2ac4 <operator delete(void*, unsigned int)>
    420c:	4620      	mov	r0, r4
    420e:	bd10      	pop	{r4, pc}
    4210:	200004a8 	.word	0x200004a8

00004214 <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()>:
#include "Adafruit_LSM6DSOX.h"

/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}
    4214:	b510      	push	{r4, lr}
    4216:	4604      	mov	r4, r0
    4218:	f7ff fd6a 	bl	3cf0 <Adafruit_LSM6DS::Adafruit_LSM6DS()>
    421c:	4b01      	ldr	r3, [pc, #4]	; (4224 <Adafruit_LSM6DSOX::Adafruit_LSM6DSOX()+0x10>)
    421e:	4620      	mov	r0, r4
    4220:	6023      	str	r3, [r4, #0]
    4222:	bd10      	pop	{r4, pc}
    4224:	200004a8 	.word	0x200004a8

00004228 <Adafruit_LSM6DSOX::_init(long)>:

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    4228:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    422c:	6b83      	ldr	r3, [r0, #56]	; 0x38
/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    422e:	b09a      	sub	sp, #104	; 0x68
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    4230:	2501      	movs	r5, #1
    4232:	2400      	movs	r4, #0
    4234:	270f      	movs	r7, #15
    4236:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
/*!
 *    @brief  Instantiates a new LSM6DSOX class
 */
Adafruit_LSM6DSOX::Adafruit_LSM6DSOX(void) {}

bool Adafruit_LSM6DSOX::_init(int32_t sensor_id) {
    4238:	4606      	mov	r6, r0
    423a:	4688      	mov	r8, r1
  Adafruit_BusIO_Register chip_id = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DS_WHOAMI);
    423c:	a808      	add	r0, sp, #32
    423e:	4619      	mov	r1, r3
    4240:	9503      	str	r5, [sp, #12]
    4242:	4623      	mov	r3, r4
    4244:	9501      	str	r5, [sp, #4]
    4246:	9402      	str	r4, [sp, #8]
    4248:	9700      	str	r7, [sp, #0]
    424a:	f7fe fcc9 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    424e:	a808      	add	r0, sp, #32
    4250:	f7fe fd98 	bl	2d84 <Adafruit_BusIO_Register::read()>
    4254:	286c      	cmp	r0, #108	; 0x6c
    4256:	d003      	beq.n	4260 <Adafruit_LSM6DSOX::_init(long)+0x38>
    return false;
    4258:	4620      	mov	r0, r4

  // call base class _init()
  Adafruit_LSM6DS::_init(sensor_id);

  return true;
}
    425a:	b01a      	add	sp, #104	; 0x68
    425c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
    4260:	fa1f f388 	uxth.w	r3, r8
  _sensorid_gyro = sensor_id + 1;
  _sensorid_temp = sensor_id + 2;

  reset();
    4264:	4630      	mov	r0, r6
  Adafruit_BusIO_RegisterBits bdu = Adafruit_BusIO_RegisterBits(&ctrl3, 1, 6);
  bdu.write(true);

  // Disable I3C
  Adafruit_BusIO_Register ctrl_9 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL9_XL);
    4266:	2718      	movs	r7, #24
  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
  _sensorid_gyro = sensor_id + 1;
    4268:	1959      	adds	r1, r3, r5
  _sensorid_temp = sensor_id + 2;
    426a:	1c9a      	adds	r2, r3, #2

  // make sure we're talking to the right chip
  if (chip_id.read() != LSM6DSOX_CHIP_ID) {
    return false;
  }
  _sensorid_accel = sensor_id;
    426c:	8633      	strh	r3, [r6, #48]	; 0x30
  _sensorid_gyro = sensor_id + 1;
    426e:	8671      	strh	r1, [r6, #50]	; 0x32
  _sensorid_temp = sensor_id + 2;
    4270:	86b2      	strh	r2, [r6, #52]	; 0x34

  reset();
    4272:	f7ff fd75 	bl	3d60 <Adafruit_LSM6DS::reset()>

  // Block Data Update
  Adafruit_BusIO_Register ctrl3 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL3_C);
    4276:	2312      	movs	r3, #18
    4278:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
    427a:	a80e      	add	r0, sp, #56	; 0x38
    427c:	6bb1      	ldr	r1, [r6, #56]	; 0x38
    427e:	9300      	str	r3, [sp, #0]
    4280:	4623      	mov	r3, r4
    4282:	9503      	str	r5, [sp, #12]
    4284:	9402      	str	r4, [sp, #8]
    4286:	9501      	str	r5, [sp, #4]
    4288:	f7fe fcaa 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits bdu = Adafruit_BusIO_RegisterBits(&ctrl3, 1, 6);
    428c:	462a      	mov	r2, r5
    428e:	a90e      	add	r1, sp, #56	; 0x38
    4290:	2306      	movs	r3, #6
    4292:	a804      	add	r0, sp, #16
    4294:	f7fe fda0 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>
  bdu.write(true);
    4298:	4629      	mov	r1, r5
    429a:	a804      	add	r0, sp, #16
    429c:	f7fe fdb2 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // Disable I3C
  Adafruit_BusIO_Register ctrl_9 = Adafruit_BusIO_Register(
      i2c_dev, spi_dev, ADDRBIT8_HIGH_TOREAD, LSM6DSOX_CTRL9_XL);
    42a0:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
    42a2:	6bb1      	ldr	r1, [r6, #56]	; 0x38
    42a4:	4623      	mov	r3, r4
    42a6:	9503      	str	r5, [sp, #12]
    42a8:	a814      	add	r0, sp, #80	; 0x50
    42aa:	9402      	str	r4, [sp, #8]
    42ac:	9501      	str	r5, [sp, #4]
    42ae:	9700      	str	r7, [sp, #0]
    42b0:	f7fe fc96 	bl	2be0 <Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice*, Adafruit_SPIDevice*, _Adafruit_BusIO_SPIRegType, unsigned short, unsigned char, unsigned char, unsigned char)>
  Adafruit_BusIO_RegisterBits i3c_disable_bit =
      Adafruit_BusIO_RegisterBits(&ctrl_9, 1, 1);
    42b4:	462b      	mov	r3, r5
    42b6:	462a      	mov	r2, r5
    42b8:	a914      	add	r1, sp, #80	; 0x50
    42ba:	eb0d 0007 	add.w	r0, sp, r7
    42be:	f7fe fd8b 	bl	2dd8 <Adafruit_BusIO_RegisterBits::Adafruit_BusIO_RegisterBits(Adafruit_BusIO_Register*, unsigned char, unsigned char)>

  i3c_disable_bit.write(true);
    42c2:	4629      	mov	r1, r5
    42c4:	eb0d 0007 	add.w	r0, sp, r7
    42c8:	f7fe fd9c 	bl	2e04 <Adafruit_BusIO_RegisterBits::write(unsigned long)>

  // call base class _init()
  Adafruit_LSM6DS::_init(sensor_id);
    42cc:	4641      	mov	r1, r8
    42ce:	4630      	mov	r0, r6
    42d0:	f7ff fdea 	bl	3ea8 <Adafruit_LSM6DS::_init(long)>
    42d4:	4628      	mov	r0, r5

  return true;
}
    42d6:	b01a      	add	sp, #104	; 0x68
    42d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000042dc <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>:
	if (interruptMask[n >> 5] == 0) {
		interruptMasksUsed &= ~(1 << (n >> 5));
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
    42dc:	b470      	push	{r4, r5, r6}
    uint8_t *p_read = (uint8_t*)retbuf;
    size_t count_read = count;

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 
    42de:	f240 2501 	movw	r5, #513	; 0x201
    42e2:	6804      	ldr	r4, [r0, #0]
    42e4:	6125      	str	r5, [r4, #16]

	while (count > 0) {
    42e6:	b31b      	cbz	r3, 4330 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
    42e8:	461e      	mov	r6, r3
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    42ea:	b1f1      	cbz	r1, 432a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4e>
    42ec:	780d      	ldrb	r5, [r1, #0]
    42ee:	3101      	adds	r1, #1
		count--; // how many bytes left to output.
    42f0:	3b01      	subs	r3, #1
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    42f2:	6665      	str	r5, [r4, #100]	; 0x64
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    42f4:	6f25      	ldr	r5, [r4, #112]	; 0x70
    42f6:	07ad      	lsls	r5, r5, #30
    42f8:	d406      	bmi.n	4308 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
				uint8_t b = port().RDR;  // Read any pending RX bytes in
    42fa:	6f65      	ldr	r5, [r4, #116]	; 0x74
				if (p_read) *p_read++ = b; 
				count_read--;
    42fc:	3e01      	subs	r6, #1
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
				uint8_t b = port().RDR;  // Read any pending RX bytes in
    42fe:	b2ed      	uxtb	r5, r5
				if (p_read) *p_read++ = b; 
    4300:	b112      	cbz	r2, 4308 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
    4302:	7015      	strb	r5, [r2, #0]
    4304:	3201      	adds	r2, #1
    4306:	6804      	ldr	r4, [r0, #0]
				count_read--;
			}
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;
    4308:	6965      	ldr	r5, [r4, #20]
	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
    430a:	07ed      	lsls	r5, r5, #31
    430c:	d5f2      	bpl.n	42f4 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x18>

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
    430e:	2b00      	cmp	r3, #0
    4310:	d1eb      	bne.n	42ea <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0xe>
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;

	}

	// now lets wait for all of the read bytes to be returned...
	while (count_read) {
    4312:	b16e      	cbz	r6, 4330 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    4314:	6801      	ldr	r1, [r0, #0]
		if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    4316:	6f0b      	ldr	r3, [r1, #112]	; 0x70
    4318:	079b      	lsls	r3, r3, #30
    431a:	d4fc      	bmi.n	4316 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x3a>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
    431c:	6f4b      	ldr	r3, [r1, #116]	; 0x74
    431e:	b2db      	uxtb	r3, r3
			if (p_read) *p_read++ = b; 
    4320:	b10a      	cbz	r2, 4326 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4a>
    4322:	7013      	strb	r3, [r2, #0]
    4324:	3201      	adds	r2, #1
			count_read--;
    4326:	3e01      	subs	r6, #1
    4328:	e7f3      	b.n	4312 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x36>
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
    432a:	f890 503c 	ldrb.w	r5, [r0, #60]	; 0x3c
    432e:	e7df      	b.n	42f0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x14>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
			if (p_read) *p_read++ = b; 
			count_read--;
		}
	}
}
    4330:	bc70      	pop	{r4, r5, r6}
    4332:	4770      	bx	lr

00004334 <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
    4334:	b10b      	cbz	r3, 433a <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
    4336:	f7ff bfd1 	b.w	42dc <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>
    433a:	4770      	bx	lr

0000433c <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    433c:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    4340:	f890 00a2 	ldrb.w	r0, [r0, #162]	; 0xa2
	}
    4344:	1a10      	subs	r0, r2, r0
    4346:	4770      	bx	lr

00004348 <TwoWire::peek()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    4348:	f890 30a2 	ldrb.w	r3, [r0, #162]	; 0xa2
    434c:	f890 20a3 	ldrb.w	r2, [r0, #163]	; 0xa3
    4350:	429a      	cmp	r2, r3
    4352:	d902      	bls.n	435a <TwoWire::peek()+0x12>
		return rxBuffer[rxBufferIndex];
    4354:	4403      	add	r3, r0
    4356:	7e98      	ldrb	r0, [r3, #26]
    4358:	4770      	bx	lr
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    435a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    435e:	4770      	bx	lr

00004360 <TwoWire::flush()>:
	virtual void flush(void) {
    4360:	4770      	bx	lr
    4362:	bf00      	nop

00004364 <TwoWire::write(unsigned char)>:
}


size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    4364:	f8b0 3130 	ldrh.w	r3, [r0, #304]	; 0x130
    4368:	b193      	cbz	r3, 4390 <TwoWire::write(unsigned char)+0x2c>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    436a:	f890 312f 	ldrb.w	r3, [r0, #303]	; 0x12f
    436e:	2b88      	cmp	r3, #136	; 0x88
    4370:	d80b      	bhi.n	438a <TwoWire::write(unsigned char)+0x26>
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4372:	18c2      	adds	r2, r0, r3
{
}


size_t TwoWire::write(uint8_t data)
{
    4374:	b410      	push	{r4}
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4376:	1c5c      	adds	r4, r3, #1
		return 1;
    4378:	2301      	movs	r3, #1
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    437a:	f880 412f 	strb.w	r4, [r0, #303]	; 0x12f
		return 1;
	}
	return 0;
}
    437e:	4618      	mov	r0, r3
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
		}
		txBuffer[txBufferLength++] = data;
    4380:	f882 10a5 	strb.w	r1, [r2, #165]	; 0xa5
		return 1;
	}
	return 0;
}
    4384:	f85d 4b04 	ldr.w	r4, [sp], #4
    4388:	4770      	bx	lr
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	// int printf(const char *format, ...) __attribute__ ((format (printf, 2, 3)));

  protected:
	void setWriteError(int err = 1) { write_error = err; }
    438a:	2201      	movs	r2, #1
size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
		if (txBufferLength >= BUFFER_LENGTH+1) {
			setWriteError();
			return 0;
    438c:	2300      	movs	r3, #0
    438e:	7102      	strb	r2, [r0, #4]
		}
		txBuffer[txBufferLength++] = data;
		return 1;
	}
	return 0;
}
    4390:	4618      	mov	r0, r3
    4392:	4770      	bx	lr

00004394 <TwoWire::write(unsigned char const*, unsigned int)>:

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    4394:	b538      	push	{r3, r4, r5, lr}
    4396:	4605      	mov	r5, r0
	if (transmitting || slave_mode) {
    4398:	f8b0 0130 	ldrh.w	r0, [r0, #304]	; 0x130
    439c:	b190      	cbz	r0, 43c4 <TwoWire::write(unsigned char const*, unsigned int)+0x30>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    439e:	f895 312f 	ldrb.w	r3, [r5, #303]	; 0x12f
    43a2:	4614      	mov	r4, r2
    43a4:	f1c3 0289 	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    43a8:	4294      	cmp	r4, r2
    43aa:	d80c      	bhi.n	43c6 <TwoWire::write(unsigned char const*, unsigned int)+0x32>
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    43ac:	f105 00a5 	add.w	r0, r5, #165	; 0xa5
    43b0:	4622      	mov	r2, r4
    43b2:	4418      	add	r0, r3
    43b4:	f002 f930 	bl	6618 <memcpy>
		txBufferLength += quantity;
    43b8:	f895 312f 	ldrb.w	r3, [r5, #303]	; 0x12f
    43bc:	4620      	mov	r0, r4
    43be:	441c      	add	r4, r3
    43c0:	f885 412f 	strb.w	r4, [r5, #303]	; 0x12f
		return quantity;
	}
	return 0;
}
    43c4:	bd38      	pop	{r3, r4, r5, pc}
    43c6:	4614      	mov	r4, r2
    43c8:	2201      	movs	r2, #1
    43ca:	712a      	strb	r2, [r5, #4]
    43cc:	e7ee      	b.n	43ac <TwoWire::write(unsigned char const*, unsigned int)+0x18>
    43ce:	bf00      	nop

000043d0 <TwoWire::force_clock()>:
	if (qty > BUFFER_LENGTH) qty = BUFFER_LENGTH;
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
    43d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    43d4:	4683      	mov	fp, r0
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    43d6:	4840      	ldr	r0, [pc, #256]	; (44d8 <TwoWire::force_clock()+0x108>)
	if (qty > BUFFER_LENGTH) qty = BUFFER_LENGTH;
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
    43d8:	b083      	sub	sp, #12
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    43da:	2515      	movs	r5, #21
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    43dc:	f8db a014 	ldr.w	sl, [fp, #20]
    43e0:	f89b 6018 	ldrb.w	r6, [fp, #24]
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    43e4:	f89b 3019 	ldrb.w	r3, [fp, #25]
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    43e8:	eb0a 1606 	add.w	r6, sl, r6, lsl #4
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    43ec:	493b      	ldr	r1, [pc, #236]	; (44dc <TwoWire::force_clock()+0x10c>)
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    43ee:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    43f2:	f8df e0ec 	ldr.w	lr, [pc, #236]	; 44e0 <TwoWire::force_clock()+0x110>
}

bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    43f6:	7a36      	ldrb	r6, [r6, #8]
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    43f8:	460c      	mov	r4, r1
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    43fa:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    43fe:	0136      	lsls	r6, r6, #4
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4400:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 44e4 <TwoWire::force_clock()+0x114>
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    4404:	011b      	lsls	r3, r3, #4
bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    4406:	1987      	adds	r7, r0, r6
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
    4408:	f850 8006 	ldr.w	r8, [r0, r6]
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    440c:	eb00 0c03 	add.w	ip, r0, r3
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
    4410:	58c6      	ldr	r6, [r0, r3]
bool TwoWire::force_clock()
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    4412:	68f8      	ldr	r0, [r7, #12]
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    4414:	687b      	ldr	r3, [r7, #4]
{
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    4416:	f8dc 700c 	ldr.w	r7, [ip, #12]
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    441a:	9300      	str	r3, [sp, #0]
    441c:	601d      	str	r5, [r3, #0]
	*portSetRegister(sda_pin) = sda_mask;
    441e:	f8c8 0084 	str.w	r0, [r8, #132]	; 0x84
	*portModeRegister(sda_pin) |= sda_mask;
    4422:	f8d8 3004 	ldr.w	r3, [r8, #4]
	*portConfigRegister(scl_pin) = 5 | 0x10;
    4426:	f8dc 2004 	ldr.w	r2, [ip, #4]
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
    442a:	4303      	orrs	r3, r0
	*portConfigRegister(scl_pin) = 5 | 0x10;
    442c:	9201      	str	r2, [sp, #4]
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
	*portSetRegister(sda_pin) = sda_mask;
	*portModeRegister(sda_pin) |= sda_mask;
    442e:	f8c8 3004 	str.w	r3, [r8, #4]
	*portConfigRegister(scl_pin) = 5 | 0x10;
    4432:	6015      	str	r5, [r2, #0]
	*portSetRegister(scl_pin) = scl_mask;
    4434:	f8c6 7084 	str.w	r7, [r6, #132]	; 0x84
	*portModeRegister(scl_pin) |= scl_mask;
    4438:	6873      	ldr	r3, [r6, #4]
    443a:	433b      	orrs	r3, r7
    443c:	6073      	str	r3, [r6, #4]
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    443e:	6809      	ldr	r1, [r1, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4440:	f8de 3000 	ldr.w	r3, [lr]
    4444:	fba9 3203 	umull	r3, r2, r9, r3
    4448:	0c92      	lsrs	r2, r2, #18
    444a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    444e:	0052      	lsls	r2, r2, #1
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4450:	6823      	ldr	r3, [r4, #0]
    4452:	1a5b      	subs	r3, r3, r1
    4454:	429a      	cmp	r2, r3
    4456:	d8fb      	bhi.n	4450 <TwoWire::force_clock()+0x80>
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4458:	4a20      	ldr	r2, [pc, #128]	; (44dc <TwoWire::force_clock()+0x10c>)
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    445a:	2509      	movs	r5, #9
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    445c:	f8df c084 	ldr.w	ip, [pc, #132]	; 44e4 <TwoWire::force_clock()+0x114>
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4460:	4691      	mov	r9, r2
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
    4462:	f8d8 3008 	ldr.w	r3, [r8, #8]
		  && (*portInputRegister(scl_pin) & scl_mask)) {
    4466:	4218      	tst	r0, r3
    4468:	d002      	beq.n	4470 <TwoWire::force_clock()+0xa0>
    446a:	68b3      	ldr	r3, [r6, #8]
    446c:	421f      	tst	r7, r3
    446e:	d131      	bne.n	44d4 <TwoWire::force_clock()+0x104>
			// success, both pins are high
			ret = true;
			break;
		}
		*portClearRegister(scl_pin) = scl_mask;
    4470:	f8c6 7088 	str.w	r7, [r6, #136]	; 0x88
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4474:	6814      	ldr	r4, [r2, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4476:	f8de 1000 	ldr.w	r1, [lr]
    447a:	fbac 3101 	umull	r3, r1, ip, r1
    447e:	0c89      	lsrs	r1, r1, #18
    4480:	eb01 0181 	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    4484:	6813      	ldr	r3, [r2, #0]
    4486:	1b1b      	subs	r3, r3, r4
    4488:	4299      	cmp	r1, r3
    448a:	d8fb      	bhi.n	4484 <TwoWire::force_clock()+0xb4>
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
    448c:	f8c6 7084 	str.w	r7, [r6, #132]	; 0x84
// Wait for a number of microseconds.  During this time, interrupts remain
// active, but the rest of your program becomes effectively stalled.  For shorter
// delay, use delayNanoseconds().
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    4490:	f8d9 4000 	ldr.w	r4, [r9]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    4494:	f8de 1000 	ldr.w	r1, [lr]
    4498:	fbac 3101 	umull	r3, r1, ip, r1
    449c:	0c89      	lsrs	r1, r1, #18
    449e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    44a2:	6813      	ldr	r3, [r2, #0]
    44a4:	1b1b      	subs	r3, r3, r4
    44a6:	4299      	cmp	r1, r3
    44a8:	d8fb      	bhi.n	44a2 <TwoWire::force_clock()+0xd2>
	*portModeRegister(sda_pin) |= sda_mask;
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
	*portModeRegister(scl_pin) |= scl_mask;
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
    44aa:	3d01      	subs	r5, #1
    44ac:	d1d9      	bne.n	4462 <TwoWire::force_clock()+0x92>
	return requestFrom(addr, qty, stop);
}

bool TwoWire::force_clock()
{
	bool ret = false;
    44ae:	4628      	mov	r0, r5
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
		delayMicroseconds(5);
	}
	// return control of pins to I2C
	*(portConfigRegister(sda_pin)) = hardware.sda_pins[sda_pin_index_].mux_val;
    44b0:	f89b 3018 	ldrb.w	r3, [fp, #24]
    44b4:	9a00      	ldr	r2, [sp, #0]
    44b6:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
    44ba:	68db      	ldr	r3, [r3, #12]
    44bc:	6013      	str	r3, [r2, #0]
	*(portConfigRegister(scl_pin)) = hardware.scl_pins[scl_pin_index_].mux_val;
    44be:	f89b 3019 	ldrb.w	r3, [fp, #25]
    44c2:	9a01      	ldr	r2, [sp, #4]
    44c4:	eb0a 1a03 	add.w	sl, sl, r3, lsl #4
    44c8:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
    44cc:	6013      	str	r3, [r2, #0]
	return ret;
}
    44ce:	b003      	add	sp, #12
    44d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
		  && (*portInputRegister(scl_pin) & scl_mask)) {
			// success, both pins are high
			ret = true;
    44d4:	2001      	movs	r0, #1
    44d6:	e7eb      	b.n	44b0 <TwoWire::force_clock()+0xe0>
    44d8:	200006dc 	.word	0x200006dc
    44dc:	e0001004 	.word	0xe0001004
    44e0:	20001478 	.word	0x20001478
    44e4:	431bde83 	.word	0x431bde83

000044e8 <TwoWire::wait_idle()>:
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
    44e8:	490d      	ldr	r1, [pc, #52]	; (4520 <TwoWire::wait_idle()+0x38>)
    44ea:	6902      	ldr	r2, [r0, #16]
//   01   EPF = End Packet Flag
//      2 RDF = Receive Data Flag
//      1 TDF = Transmit Data Flag

bool TwoWire::wait_idle()
{
    44ec:	b510      	push	{r4, lr}
    44ee:	680c      	ldr	r4, [r1, #0]
    44f0:	e005      	b.n	44fe <TwoWire::wait_idle()+0x16>
	elapsedMillis timeout = 0;
	while (1) {
		uint32_t status = port->MSR; // pg 2899 & 2892
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
		if (status & LPI2C_MSR_MBF) break; // we already have bus control
    44f2:	01db      	lsls	r3, r3, #7
    44f4:	d407      	bmi.n	4506 <TwoWire::wait_idle()+0x1e>
    44f6:	680b      	ldr	r3, [r1, #0]
		if (timeout > 16) {
    44f8:	1b1b      	subs	r3, r3, r4
    44fa:	2b10      	cmp	r3, #16
    44fc:	d808      	bhi.n	4510 <TwoWire::wait_idle()+0x28>

bool TwoWire::wait_idle()
{
	elapsedMillis timeout = 0;
	while (1) {
		uint32_t status = port->MSR; // pg 2899 & 2892
    44fe:	6953      	ldr	r3, [r2, #20]
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
    4500:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    4504:	d1f5      	bne.n	44f2 <TwoWire::wait_idle()+0xa>
			if (force_clock()) break;
			//Serial.printf("unable to get control of I2C bus\n");
			return false;
		}
	}
	port->MSR = 0x00007F00; // clear all prior flags
    4506:	f44f 43fe 	mov.w	r3, #32512	; 0x7f00
	return true;
    450a:	2001      	movs	r0, #1
			if (force_clock()) break;
			//Serial.printf("unable to get control of I2C bus\n");
			return false;
		}
	}
	port->MSR = 0x00007F00; // clear all prior flags
    450c:	6153      	str	r3, [r2, #20]
	return true;
}
    450e:	bd10      	pop	{r4, pc}
    4510:	4604      	mov	r4, r0
		uint32_t status = port->MSR; // pg 2899 & 2892
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
		if (status & LPI2C_MSR_MBF) break; // we already have bus control
		if (timeout > 16) {
			//Serial.printf("timeout waiting for idle, MSR = %x\n", status);
			if (force_clock()) break;
    4512:	f7ff ff5d 	bl	43d0 <TwoWire::force_clock()>
    4516:	2800      	cmp	r0, #0
    4518:	d0f9      	beq.n	450e <TwoWire::wait_idle()+0x26>
    451a:	6922      	ldr	r2, [r4, #16]
    451c:	e7f3      	b.n	4506 <TwoWire::wait_idle()+0x1e>
    451e:	bf00      	nop
    4520:	20002740 	.word	0x20002740

00004524 <TwoWire::endTransmission(unsigned char)>:
	return true;
}


uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    4524:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t tx_len = txBufferLength;
    4528:	f890 a12f 	ldrb.w	sl, [r0, #303]	; 0x12f
	if (!tx_len) return 4; // no address for transmit
    452c:	f1ba 0f00 	cmp.w	sl, #0
    4530:	d102      	bne.n	4538 <TwoWire::endTransmission(unsigned char)+0x14>
    4532:	2004      	movs	r0, #4
    4534:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4538:	4605      	mov	r5, r0
    453a:	460e      	mov	r6, r1
	if (!wait_idle()) return 4;
    453c:	f7ff ffd4 	bl	44e8 <TwoWire::wait_idle()>
    4540:	2800      	cmp	r0, #0
    4542:	d0f6      	beq.n	4532 <TwoWire::endTransmission(unsigned char)+0xe>
    4544:	4f2e      	ldr	r7, [pc, #184]	; (4600 <TwoWire::endTransmission(unsigned char)+0xdc>)
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
    4546:	2400      	movs	r4, #0
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4548:	f44f 7900 	mov.w	r9, #512	; 0x200
    454c:	f8d7 8000 	ldr.w	r8, [r7]
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
    4550:	4554      	cmp	r4, sl
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
    4552:	6929      	ldr	r1, [r5, #16]
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
    4554:	d81a      	bhi.n	458c <TwoWire::endTransmission(unsigned char)+0x68>
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
    4556:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
    4558:	f003 0307 	and.w	r3, r3, #7
			while (fifo_used < 4) {
    455c:	2b03      	cmp	r3, #3
    455e:	d909      	bls.n	4574 <TwoWire::endTransmission(unsigned char)+0x50>
    4560:	e014      	b.n	458c <TwoWire::endTransmission(unsigned char)+0x68>
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    4562:	f895 20a5 	ldrb.w	r2, [r5, #165]	; 0xa5
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
					tx_index++;
					break;
				}
				fifo_used++;
    4566:	3301      	adds	r3, #1
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
    4568:	2401      	movs	r4, #1
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    456a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    456e:	2b04      	cmp	r3, #4
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    4570:	660a      	str	r2, [r1, #96]	; 0x60
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4572:	d00b      	beq.n	458c <TwoWire::endTransmission(unsigned char)+0x68>
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    4574:	192a      	adds	r2, r5, r4
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
				if (tx_index == 0) {
    4576:	2c00      	cmp	r4, #0
    4578:	d0f3      	beq.n	4562 <TwoWire::endTransmission(unsigned char)+0x3e>
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
    457a:	45a2      	cmp	sl, r4
    457c:	d927      	bls.n	45ce <TwoWire::endTransmission(unsigned char)+0xaa>
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
					tx_index++;
					break;
				}
				fifo_used++;
    457e:	3301      	adds	r3, #1
			while (fifo_used < 4) {
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    4580:	f892 20a5 	ldrb.w	r2, [r2, #165]	; 0xa5
    4584:	3401      	adds	r4, #1
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    4586:	2b04      	cmp	r3, #4
				if (tx_index == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    4588:	660a      	str	r2, [r1, #96]	; 0x60
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    458a:	d1f3      	bne.n	4574 <TwoWire::endTransmission(unsigned char)+0x50>
				}
				fifo_used++;
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
    458c:	694b      	ldr	r3, [r1, #20]
		if (status & LPI2C_MSR_ALF) {
    458e:	0518      	lsls	r0, r3, #20
    4590:	d422      	bmi.n	45d8 <TwoWire::endTransmission(unsigned char)+0xb4>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			return 4; // we lost bus arbitration to another master
		}
		if (status & LPI2C_MSR_NDF) {
    4592:	055a      	lsls	r2, r3, #21
    4594:	d427      	bmi.n	45e6 <TwoWire::endTransmission(unsigned char)+0xc2>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP;
			return 2; // NACK (assume address, TODO: how to tell address from data)
		}
		if ((status & LPI2C_MSR_PLTF) || timeout > 50) {
    4596:	0498      	lsls	r0, r3, #18
    4598:	d404      	bmi.n	45a4 <TwoWire::endTransmission(unsigned char)+0x80>
    459a:	683a      	ldr	r2, [r7, #0]
    459c:	ebc8 0202 	rsb	r2, r8, r2
    45a0:	2a32      	cmp	r2, #50	; 0x32
    45a2:	d909      	bls.n	45b8 <TwoWire::endTransmission(unsigned char)+0x94>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    45a4:	690b      	ldr	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    45a6:	f44f 7200 	mov.w	r2, #512	; 0x200
			return 4; // clock stretched too long or generic timeout
    45aa:	2004      	movs	r0, #4
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP;
			return 2; // NACK (assume address, TODO: how to tell address from data)
		}
		if ((status & LPI2C_MSR_PLTF) || timeout > 50) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    45ac:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    45b0:	610b      	str	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    45b2:	660a      	str	r2, [r1, #96]	; 0x60
			return 4; // clock stretched too long or generic timeout
    45b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
    45b8:	4554      	cmp	r4, sl
    45ba:	d905      	bls.n	45c8 <TwoWire::endTransmission(unsigned char)+0xa4>
			uint32_t tx_fifo = port->MFSR & 0x07;
    45bc:	6dca      	ldr	r2, [r1, #92]	; 0x5c
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
    45be:	0752      	lsls	r2, r2, #29
    45c0:	d102      	bne.n	45c8 <TwoWire::endTransmission(unsigned char)+0xa4>
    45c2:	059b      	lsls	r3, r3, #22
    45c4:	d419      	bmi.n	45fa <TwoWire::endTransmission(unsigned char)+0xd6>
    45c6:	b1c6      	cbz	r6, 45fa <TwoWire::endTransmission(unsigned char)+0xd6>
				return 0;
			}
		}
		yield();
    45c8:	f7fe fa92 	bl	2af0 <yield>
	uint32_t tx_len = txBufferLength;
	if (!tx_len) return 4; // no address for transmit
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
    45cc:	e7c0      	b.n	4550 <TwoWire::endTransmission(unsigned char)+0x2c>
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
					tx_index = 1;
				} else if (tx_index < tx_len) {
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    45ce:	b10e      	cbz	r6, 45d4 <TwoWire::endTransmission(unsigned char)+0xb0>
    45d0:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
					tx_index++;
    45d4:	3401      	adds	r4, #1
					break;
    45d6:	e7d9      	b.n	458c <TwoWire::endTransmission(unsigned char)+0x68>
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    45d8:	690b      	ldr	r3, [r1, #16]
			return 4; // we lost bus arbitration to another master
    45da:	2004      	movs	r0, #4
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    45dc:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    45e0:	610b      	str	r3, [r1, #16]
			return 4; // we lost bus arbitration to another master
    45e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		if (status & LPI2C_MSR_NDF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    45e6:	690b      	ldr	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP;
    45e8:	f44f 7200 	mov.w	r2, #512	; 0x200
			return 2; // NACK (assume address, TODO: how to tell address from data)
    45ec:	2002      	movs	r0, #2
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			return 4; // we lost bus arbitration to another master
		}
		if (status & LPI2C_MSR_NDF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    45ee:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    45f2:	610b      	str	r3, [r1, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP;
    45f4:	660a      	str	r2, [r1, #96]	; 0x60
			return 2; // NACK (assume address, TODO: how to tell address from data)
    45f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
			uint32_t tx_fifo = port->MFSR & 0x07;
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
				return 0;
    45fa:	2000      	movs	r0, #0
    45fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4600:	20002740 	.word	0x20002740

00004604 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:
		yield();
	}
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    4604:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4608:	460c      	mov	r4, r1
    460a:	4615      	mov	r5, r2
    460c:	4698      	mov	r8, r3
    460e:	4681      	mov	r9, r0
	if (!wait_idle()) return 4;
    4610:	f7ff ff6a 	bl	44e8 <TwoWire::wait_idle()>
    4614:	b910      	cbnz	r0, 461c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x18>
    4616:	2004      	movs	r0, #4
    4618:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
    461c:	2200      	movs	r2, #0
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
    461e:	0063      	lsls	r3, r4, #1
	if (length < 1) length = 1;
    4620:	2d00      	cmp	r5, #0
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4622:	f240 4a01 	movw	sl, #1025	; 0x401
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
    4626:	4614      	mov	r4, r2
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4628:	b2db      	uxtb	r3, r3
    462a:	4e3d      	ldr	r6, [pc, #244]	; (4720 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x11c>)

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
    462c:	bf08      	it	eq
    462e:	2501      	moveq	r5, #1
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    4630:	2c02      	cmp	r4, #2
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    4632:	ea43 0a0a 	orr.w	sl, r3, sl
    4636:	f8d6 b000 	ldr.w	fp, [r6]
{
	if (!wait_idle()) return 4;
	address = (address & 0x7F) << 1;
	if (length < 1) length = 1;
	if (length > 255) length = 255;
	rxBufferIndex = 0;
    463a:	f889 20a2 	strb.w	r2, [r9, #162]	; 0xa2
	rxBufferLength = 0;
    463e:	f889 20a3 	strb.w	r2, [r9, #163]	; 0xa3
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    4642:	d948      	bls.n	46d6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xd2>
    4644:	f8d9 3010 	ldr.w	r3, [r9, #16]
				tx_state++;
				tx_fifo--;
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
    4648:	f899 20a3 	ldrb.w	r2, [r9, #163]	; 0xa3
    464c:	2a87      	cmp	r2, #135	; 0x87
    464e:	d812      	bhi.n	4676 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
    4650:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
    4652:	f3c1 4102 	ubfx	r1, r1, #16, #3
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    4656:	b911      	cbnz	r1, 465e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x5a>
    4658:	e00d      	b.n	4676 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
    465a:	2a88      	cmp	r2, #136	; 0x88
    465c:	d00b      	beq.n	4676 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x72>
				rxBuffer[rxBufferLength++] = port->MRDR;
    465e:	f102 0e01 	add.w	lr, r2, #1
    4662:	eb09 0002 	add.w	r0, r9, r2
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    4666:	3901      	subs	r1, #1
				rxBuffer[rxBufferLength++] = port->MRDR;
    4668:	fa5f f28e 	uxtb.w	r2, lr
    466c:	f889 20a3 	strb.w	r2, [r9, #163]	; 0xa3
    4670:	6f1f      	ldr	r7, [r3, #112]	; 0x70
    4672:	7687      	strb	r7, [r0, #26]
			}
		}
		// receive stuff
		if (rxBufferLength < sizeof(rxBuffer)) {
			uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
			while (rx_fifo > 0 && rxBufferLength < sizeof(rxBuffer)) {
    4674:	d1f1      	bne.n	465a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x56>
				rxBuffer[rxBufferLength++] = port->MRDR;
				rx_fifo--;
			}
		}
		// monitor status, check for error conditions
		uint32_t status = port->MSR; // pg 2884 & 2891
    4676:	695a      	ldr	r2, [r3, #20]
		if (status & LPI2C_MSR_ALF) {
    4678:	0510      	lsls	r0, r2, #20
    467a:	d44c      	bmi.n	4716 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x112>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			break;
		}
		if ((status & LPI2C_MSR_NDF) || (status & LPI2C_MSR_PLTF) || timeout > 50) {
    467c:	f412 5f10 	tst.w	r2, #9216	; 0x2400
    4680:	d104      	bne.n	468c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x88>
    4682:	6831      	ldr	r1, [r6, #0]
    4684:	ebcb 0101 	rsb	r1, fp, r1
    4688:	2932      	cmp	r1, #50	; 0x32
    468a:	d912      	bls.n	46b2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xae>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    468c:	691a      	ldr	r2, [r3, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    468e:	f44f 7100 	mov.w	r1, #512	; 0x200
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			break;
		}
		if ((status & LPI2C_MSR_NDF) || (status & LPI2C_MSR_PLTF) || timeout > 50) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4692:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    4696:	611a      	str	r2, [r3, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    4698:	6619      	str	r1, [r3, #96]	; 0x60
				break;
			}
		}
		yield();
	}
	uint32_t rx_fifo = (port->MFSR >> 16) & 0x07;
    469a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
	if (rx_fifo > 0) port->MCR |= LPI2C_MCR_RRF;
    469c:	f412 2fe0 	tst.w	r2, #458752	; 0x70000
    46a0:	d003      	beq.n	46aa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa6>
    46a2:	691a      	ldr	r2, [r3, #16]
    46a4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    46a8:	611a      	str	r2, [r3, #16]
	return rxBufferLength;
    46aa:	f899 00a3 	ldrb.w	r0, [r9, #163]	; 0xa3
    46ae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
			break;
		}
		// are we done yet?
		if (rxBufferLength >= length && tx_state >= 3) {
    46b2:	f899 10a3 	ldrb.w	r1, [r9, #163]	; 0xa3
    46b6:	42a9      	cmp	r1, r5
    46b8:	d309      	bcc.n	46ce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    46ba:	2c02      	cmp	r4, #2
    46bc:	d907      	bls.n	46ce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
			uint32_t tx_fifo = port->MFSR & 0x07;
    46be:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
    46c0:	0749      	lsls	r1, r1, #29
    46c2:	d104      	bne.n	46ce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xca>
    46c4:	0592      	lsls	r2, r2, #22
    46c6:	d4e8      	bmi.n	469a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    46c8:	f1b8 0f00 	cmp.w	r8, #0
    46cc:	d0e5      	beq.n	469a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
				break;
			}
		}
		yield();
    46ce:	f7fe fa0f 	bl	2af0 <yield>
	rxBufferLength = 0;
	uint32_t tx_state = 0; // 0=begin, 1=start, 2=data, 3=stop
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
    46d2:	2c02      	cmp	r4, #2
    46d4:	d8b6      	bhi.n	4644 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x40>
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
    46d6:	f8d9 2010 	ldr.w	r2, [r9, #16]
    46da:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    46dc:	f003 0307 	and.w	r3, r3, #7
			while (tx_fifo < 4 && tx_state < 3) {
    46e0:	2b03      	cmp	r3, #3
    46e2:	d80d      	bhi.n	4700 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    46e4:	1e69      	subs	r1, r5, #1
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    46e6:	f44f 7000 	mov.w	r0, #512	; 0x200
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    46ea:	f441 7180 	orr.w	r1, r1, #256	; 0x100
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
    46ee:	b94c      	cbnz	r4, 4704 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x100>
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
    46f0:	f8c2 a060 	str.w	sl, [r2, #96]	; 0x60
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
				}
				tx_state++;
				tx_fifo--;
    46f4:	3b01      	subs	r3, #1
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
				}
				tx_state++;
    46f6:	3401      	adds	r4, #1
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_state < 3) {
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
    46f8:	2b03      	cmp	r3, #3
    46fa:	d801      	bhi.n	4700 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xfc>
    46fc:	2c02      	cmp	r4, #2
    46fe:	d9f6      	bls.n	46ee <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
    4700:	4613      	mov	r3, r2
    4702:	e7a1      	b.n	4648 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x44>
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
    4704:	2c01      	cmp	r4, #1
    4706:	d004      	beq.n	4712 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10e>
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    4708:	f1b8 0f00 	cmp.w	r8, #0
    470c:	d0f2      	beq.n	46f4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
    470e:	6610      	str	r0, [r2, #96]	; 0x60
    4710:	e7f0      	b.n	46f4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
			uint32_t tx_fifo = port->MFSR & 0x07; // pg 2914
			while (tx_fifo < 4 && tx_state < 3) {
				if (tx_state == 0) {
					port->MTDR = LPI2C_MTDR_CMD_START | 1 | address;
				} else if (tx_state == 1) {
					port->MTDR = LPI2C_MTDR_CMD_RECEIVE | (length - 1);
    4712:	6611      	str	r1, [r2, #96]	; 0x60
    4714:	e7ee      	b.n	46f4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xf0>
			}
		}
		// monitor status, check for error conditions
		uint32_t status = port->MSR; // pg 2884 & 2891
		if (status & LPI2C_MSR_ALF) {
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    4716:	691a      	ldr	r2, [r3, #16]
    4718:	f442 7240 	orr.w	r2, r2, #768	; 0x300
    471c:	611a      	str	r2, [r3, #16]
    471e:	e7bc      	b.n	469a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x96>
    4720:	20002740 	.word	0x20002740

00004724 <TwoWire::isr()>:
}


void TwoWire::isr(void)
{
	uint32_t status = port->SSR;
    4724:	6903      	ldr	r3, [r0, #16]
	port->SCR = LPI2C_SCR_SEN;
}


void TwoWire::isr(void)
{
    4726:	b570      	push	{r4, r5, r6, lr}
	uint32_t status = port->SSR;
    4728:	f8d3 5114 	ldr.w	r5, [r3, #276]	; 0x114
	port->SCR = LPI2C_SCR_SEN;
}


void TwoWire::isr(void)
{
    472c:	4604      	mov	r4, r0
	uint32_t status = port->SSR;
	uint32_t w1c_bits = status & 0xF00;
	if (w1c_bits) port->SSR = w1c_bits;
    472e:	f415 6270 	ands.w	r2, r5, #3840	; 0xf00
    4732:	d001      	beq.n	4738 <TwoWire::isr()+0x14>
    4734:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

	//Serial.print("isr ");
	//Serial.println(status, HEX);

	if (status & LPI2C_SSR_RDF) { // Receive Data Flag
    4738:	07ae      	lsls	r6, r5, #30
    473a:	d50b      	bpl.n	4754 <TwoWire::isr()+0x30>
		int rx = port->SRDR;
    473c:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
		if (rx & 0x8000) {
    4740:	0408      	lsls	r0, r1, #16
    4742:	d542      	bpl.n	47ca <TwoWire::isr()+0xa6>
			rxBufferIndex = 0;
    4744:	2200      	movs	r2, #0
    4746:	2001      	movs	r0, #1
    4748:	f884 20a2 	strb.w	r2, [r4, #162]	; 0xa2
			rxBufferLength = 0;
		}
		if (rxBufferLength < BUFFER_LENGTH) {
			rxBuffer[rxBufferLength++] = rx & 255;
    474c:	4422      	add	r2, r4
    474e:	f884 00a3 	strb.w	r0, [r4, #163]	; 0xa3
    4752:	7691      	strb	r1, [r2, #26]
		}
		//Serial.print("rx = ");
		//Serial.println(rx, HEX);
	}
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
    4754:	07ea      	lsls	r2, r5, #31
    4756:	d510      	bpl.n	477a <TwoWire::isr()+0x56>
		if (!transmitting) {
    4758:	f894 6130 	ldrb.w	r6, [r4, #304]	; 0x130
    475c:	b316      	cbz	r6, 47a4 <TwoWire::isr()+0x80>
    475e:	f894 612e 	ldrb.w	r6, [r4, #302]	; 0x12e
				(*user_onRequest)();
			}
			txBufferIndex = 0;
			transmitting = 1;
		}
		if (txBufferIndex < txBufferLength) {
    4762:	f894 212f 	ldrb.w	r2, [r4, #303]	; 0x12f
    4766:	42b2      	cmp	r2, r6
    4768:	d92b      	bls.n	47c2 <TwoWire::isr()+0x9e>
			port->STDR = txBuffer[txBufferIndex++];
    476a:	1c72      	adds	r2, r6, #1
    476c:	4426      	add	r6, r4
    476e:	f884 212e 	strb.w	r2, [r4, #302]	; 0x12e
    4772:	f896 20a5 	ldrb.w	r2, [r6, #165]	; 0xa5
    4776:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
			port->STDR = 0;
		}
		//Serial.println("tx");
	}

	if (status & LPI2C_SSR_SDF) { // Stop
    477a:	05ab      	lsls	r3, r5, #22
    477c:	d511      	bpl.n	47a2 <TwoWire::isr()+0x7e>
		//Serial.println("Stop");
		if (rxBufferLength > 0 && user_onReceive != nullptr) {
    477e:	f894 00a3 	ldrb.w	r0, [r4, #163]	; 0xa3
    4782:	b118      	cbz	r0, 478c <TwoWire::isr()+0x68>
    4784:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
    4788:	b103      	cbz	r3, 478c <TwoWire::isr()+0x68>
			(*user_onReceive)(rxBufferLength);
    478a:	4798      	blx	r3
		}
		rxBufferIndex = 0;
    478c:	2300      	movs	r3, #0
    478e:	f884 30a2 	strb.w	r3, [r4, #162]	; 0xa2
		rxBufferLength = 0;
    4792:	f884 30a3 	strb.w	r3, [r4, #163]	; 0xa3
		txBufferIndex = 0;
    4796:	f884 312e 	strb.w	r3, [r4, #302]	; 0x12e
		txBufferLength = 0;
    479a:	f884 312f 	strb.w	r3, [r4, #303]	; 0x12f
		transmitting = 0;
    479e:	f884 3130 	strb.w	r3, [r4, #304]	; 0x130
    47a2:	bd70      	pop	{r4, r5, r6, pc}
		//Serial.print("rx = ");
		//Serial.println(rx, HEX);
	}
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
    47a4:	f8d4 2138 	ldr.w	r2, [r4, #312]	; 0x138
    47a8:	b10a      	cbz	r2, 47ae <TwoWire::isr()+0x8a>
				(*user_onRequest)();
    47aa:	4790      	blx	r2
    47ac:	6923      	ldr	r3, [r4, #16]
			}
			txBufferIndex = 0;
			transmitting = 1;
    47ae:	2201      	movs	r2, #1
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
				(*user_onRequest)();
			}
			txBufferIndex = 0;
    47b0:	2100      	movs	r1, #0
			transmitting = 1;
    47b2:	f884 2130 	strb.w	r2, [r4, #304]	; 0x130
		}
		if (txBufferIndex < txBufferLength) {
    47b6:	f894 212f 	ldrb.w	r2, [r4, #303]	; 0x12f
	if (status & LPI2C_SSR_TDF) { // Transmit Data Flag
		if (!transmitting) {
			if (user_onRequest != nullptr) {
				(*user_onRequest)();
			}
			txBufferIndex = 0;
    47ba:	f884 112e 	strb.w	r1, [r4, #302]	; 0x12e
			transmitting = 1;
		}
		if (txBufferIndex < txBufferLength) {
    47be:	42b2      	cmp	r2, r6
    47c0:	d8d3      	bhi.n	476a <TwoWire::isr()+0x46>
			port->STDR = txBuffer[txBufferIndex++];
		} else {
			port->STDR = 0;
    47c2:	2200      	movs	r2, #0
    47c4:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
    47c8:	e7d7      	b.n	477a <TwoWire::isr()+0x56>
		int rx = port->SRDR;
		if (rx & 0x8000) {
			rxBufferIndex = 0;
			rxBufferLength = 0;
		}
		if (rxBufferLength < BUFFER_LENGTH) {
    47ca:	f894 20a3 	ldrb.w	r2, [r4, #163]	; 0xa3
    47ce:	2a87      	cmp	r2, #135	; 0x87
    47d0:	d8c0      	bhi.n	4754 <TwoWire::isr()+0x30>
    47d2:	1c50      	adds	r0, r2, #1
    47d4:	b2c0      	uxtb	r0, r0
    47d6:	e7b9      	b.n	474c <TwoWire::isr()+0x28>

000047d8 <lpi2c1_isr()>:
void lpi2c1_isr(void) { Wire.isr(); }
void lpi2c3_isr(void) { Wire2.isr(); }
void lpi2c4_isr(void) { Wire1.isr(); }
void lpi2c2_isr(void) { Wire3.isr(); }
#else
void lpi2c1_isr(void) { Wire.isr(); }
    47d8:	4801      	ldr	r0, [pc, #4]	; (47e0 <lpi2c1_isr()+0x8>)
    47da:	f7ff bfa3 	b.w	4724 <TwoWire::isr()>
    47de:	bf00      	nop
    47e0:	2000148c 	.word	0x2000148c

000047e4 <lpi2c3_isr()>:
void lpi2c3_isr(void) { Wire1.isr(); }
    47e4:	4801      	ldr	r0, [pc, #4]	; (47ec <lpi2c3_isr()+0x8>)
    47e6:	f7ff bf9d 	b.w	4724 <TwoWire::isr()>
    47ea:	bf00      	nop
    47ec:	200015cc 	.word	0x200015cc

000047f0 <lpi2c4_isr()>:
void lpi2c4_isr(void) { Wire2.isr(); }
    47f0:	4801      	ldr	r0, [pc, #4]	; (47f8 <lpi2c4_isr()+0x8>)
    47f2:	f7ff bf97 	b.w	4724 <TwoWire::isr()>
    47f6:	bf00      	nop
    47f8:	2000170c 	.word	0x2000170c
    47fc:	00000000 	.word	0x00000000

00004800 <cos>:
    4800:	b500      	push	{lr}
    4802:	eeb0 7b40 	vmov.f64	d7, d0
    4806:	ee17 3a90 	vmov	r3, s15
    480a:	4a23      	ldr	r2, [pc, #140]	; (4898 <cos+0x98>)
    480c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    4810:	4293      	cmp	r3, r2
    4812:	b085      	sub	sp, #20
    4814:	dd19      	ble.n	484a <cos+0x4a>
    4816:	4a21      	ldr	r2, [pc, #132]	; (489c <cos+0x9c>)
    4818:	4293      	cmp	r3, r2
    481a:	dd04      	ble.n	4826 <cos+0x26>
    481c:	ee30 0b40 	vsub.f64	d0, d0, d0
    4820:	b005      	add	sp, #20
    4822:	f85d fb04 	ldr.w	pc, [sp], #4
    4826:	4668      	mov	r0, sp
    4828:	f000 f9d2 	bl	4bd0 <__ieee754_rem_pio2>
    482c:	f000 0003 	and.w	r0, r0, #3
    4830:	2801      	cmp	r0, #1
    4832:	d01a      	beq.n	486a <cos+0x6a>
    4834:	2802      	cmp	r0, #2
    4836:	d00f      	beq.n	4858 <cos+0x58>
    4838:	b300      	cbz	r0, 487c <cos+0x7c>
    483a:	2001      	movs	r0, #1
    483c:	ed9d 1b02 	vldr	d1, [sp, #8]
    4840:	ed9d 0b00 	vldr	d0, [sp]
    4844:	f000 ffa4 	bl	5790 <__kernel_sin>
    4848:	e7ea      	b.n	4820 <cos+0x20>
    484a:	ed9f 1b11 	vldr	d1, [pc, #68]	; 4890 <cos+0x90>
    484e:	f000 fbcf 	bl	4ff0 <__kernel_cos>
    4852:	b005      	add	sp, #20
    4854:	f85d fb04 	ldr.w	pc, [sp], #4
    4858:	ed9d 1b02 	vldr	d1, [sp, #8]
    485c:	ed9d 0b00 	vldr	d0, [sp]
    4860:	f000 fbc6 	bl	4ff0 <__kernel_cos>
    4864:	eeb1 0b40 	vneg.f64	d0, d0
    4868:	e7da      	b.n	4820 <cos+0x20>
    486a:	ed9d 1b02 	vldr	d1, [sp, #8]
    486e:	ed9d 0b00 	vldr	d0, [sp]
    4872:	f000 ff8d 	bl	5790 <__kernel_sin>
    4876:	eeb1 0b40 	vneg.f64	d0, d0
    487a:	e7d1      	b.n	4820 <cos+0x20>
    487c:	ed9d 1b02 	vldr	d1, [sp, #8]
    4880:	ed9d 0b00 	vldr	d0, [sp]
    4884:	f000 fbb4 	bl	4ff0 <__kernel_cos>
    4888:	e7ca      	b.n	4820 <cos+0x20>
    488a:	bf00      	nop
    488c:	f3af 8000 	nop.w
	...
    4898:	3fe921fb 	.word	0x3fe921fb
    489c:	7fefffff 	.word	0x7fefffff

000048a0 <sin>:
    48a0:	b500      	push	{lr}
    48a2:	eeb0 7b40 	vmov.f64	d7, d0
    48a6:	ee17 3a90 	vmov	r3, s15
    48aa:	4a23      	ldr	r2, [pc, #140]	; (4938 <sin+0x98>)
    48ac:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    48b0:	4293      	cmp	r3, r2
    48b2:	b085      	sub	sp, #20
    48b4:	dd1a      	ble.n	48ec <sin+0x4c>
    48b6:	4a21      	ldr	r2, [pc, #132]	; (493c <sin+0x9c>)
    48b8:	4293      	cmp	r3, r2
    48ba:	dd04      	ble.n	48c6 <sin+0x26>
    48bc:	ee30 0b40 	vsub.f64	d0, d0, d0
    48c0:	b005      	add	sp, #20
    48c2:	f85d fb04 	ldr.w	pc, [sp], #4
    48c6:	4668      	mov	r0, sp
    48c8:	f000 f982 	bl	4bd0 <__ieee754_rem_pio2>
    48cc:	f000 0003 	and.w	r0, r0, #3
    48d0:	2801      	cmp	r0, #1
    48d2:	d01d      	beq.n	4910 <sin+0x70>
    48d4:	2802      	cmp	r0, #2
    48d6:	d011      	beq.n	48fc <sin+0x5c>
    48d8:	b308      	cbz	r0, 491e <sin+0x7e>
    48da:	ed9d 1b02 	vldr	d1, [sp, #8]
    48de:	ed9d 0b00 	vldr	d0, [sp]
    48e2:	f000 fb85 	bl	4ff0 <__kernel_cos>
    48e6:	eeb1 0b40 	vneg.f64	d0, d0
    48ea:	e7e9      	b.n	48c0 <sin+0x20>
    48ec:	2000      	movs	r0, #0
    48ee:	ed9f 1b10 	vldr	d1, [pc, #64]	; 4930 <sin+0x90>
    48f2:	f000 ff4d 	bl	5790 <__kernel_sin>
    48f6:	b005      	add	sp, #20
    48f8:	f85d fb04 	ldr.w	pc, [sp], #4
    48fc:	2001      	movs	r0, #1
    48fe:	ed9d 1b02 	vldr	d1, [sp, #8]
    4902:	ed9d 0b00 	vldr	d0, [sp]
    4906:	f000 ff43 	bl	5790 <__kernel_sin>
    490a:	eeb1 0b40 	vneg.f64	d0, d0
    490e:	e7d7      	b.n	48c0 <sin+0x20>
    4910:	ed9d 1b02 	vldr	d1, [sp, #8]
    4914:	ed9d 0b00 	vldr	d0, [sp]
    4918:	f000 fb6a 	bl	4ff0 <__kernel_cos>
    491c:	e7d0      	b.n	48c0 <sin+0x20>
    491e:	2001      	movs	r0, #1
    4920:	ed9d 1b02 	vldr	d1, [sp, #8]
    4924:	ed9d 0b00 	vldr	d0, [sp]
    4928:	f000 ff32 	bl	5790 <__kernel_sin>
    492c:	e7c8      	b.n	48c0 <sin+0x20>
    492e:	bf00      	nop
	...
    4938:	3fe921fb 	.word	0x3fe921fb
    493c:	7fefffff 	.word	0x7fefffff

00004940 <atan2>:
    4940:	f000 b856 	b.w	49f0 <__ieee754_atan2>
    4944:	0000      	movs	r0, r0
	...

00004948 <sqrt>:
    4948:	b500      	push	{lr}
    494a:	ed2d 8b02 	vpush	{d8}
    494e:	eeb0 8b40 	vmov.f64	d8, d0
    4952:	b08b      	sub	sp, #44	; 0x2c
    4954:	f000 fa8a 	bl	4e6c <__ieee754_sqrt>
    4958:	4b23      	ldr	r3, [pc, #140]	; (49e8 <sqrt+0xa0>)
    495a:	f993 3000 	ldrsb.w	r3, [r3]
    495e:	1c5a      	adds	r2, r3, #1
    4960:	d00b      	beq.n	497a <sqrt+0x32>
    4962:	eeb4 8b48 	vcmp.f64	d8, d8
    4966:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    496a:	d606      	bvs.n	497a <sqrt+0x32>
    496c:	ed9f 7b1c 	vldr	d7, [pc, #112]	; 49e0 <sqrt+0x98>
    4970:	eeb4 8bc7 	vcmpe.f64	d8, d7
    4974:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4978:	d404      	bmi.n	4984 <sqrt+0x3c>
    497a:	b00b      	add	sp, #44	; 0x2c
    497c:	ecbd 8b02 	vpop	{d8}
    4980:	f85d fb04 	ldr.w	pc, [sp], #4
    4984:	2201      	movs	r2, #1
    4986:	4919      	ldr	r1, [pc, #100]	; (49ec <sqrt+0xa4>)
    4988:	9200      	str	r2, [sp, #0]
    498a:	2200      	movs	r2, #0
    498c:	ed8d 8b04 	vstr	d8, [sp, #16]
    4990:	ed8d 8b02 	vstr	d8, [sp, #8]
    4994:	9101      	str	r1, [sp, #4]
    4996:	9208      	str	r2, [sp, #32]
    4998:	b193      	cbz	r3, 49c0 <sqrt+0x78>
    499a:	ee87 6b07 	vdiv.f64	d6, d7, d7
    499e:	2b02      	cmp	r3, #2
    49a0:	ed8d 6b06 	vstr	d6, [sp, #24]
    49a4:	d10e      	bne.n	49c4 <sqrt+0x7c>
    49a6:	f001 fb1b 	bl	5fe0 <__errno>
    49aa:	2321      	movs	r3, #33	; 0x21
    49ac:	6003      	str	r3, [r0, #0]
    49ae:	9b08      	ldr	r3, [sp, #32]
    49b0:	b973      	cbnz	r3, 49d0 <sqrt+0x88>
    49b2:	ed9d 0b06 	vldr	d0, [sp, #24]
    49b6:	b00b      	add	sp, #44	; 0x2c
    49b8:	ecbd 8b02 	vpop	{d8}
    49bc:	f85d fb04 	ldr.w	pc, [sp], #4
    49c0:	ed8d 7b06 	vstr	d7, [sp, #24]
    49c4:	4668      	mov	r0, sp
    49c6:	f001 f8d3 	bl	5b70 <matherr>
    49ca:	2800      	cmp	r0, #0
    49cc:	d1ef      	bne.n	49ae <sqrt+0x66>
    49ce:	e7ea      	b.n	49a6 <sqrt+0x5e>
    49d0:	f001 fb06 	bl	5fe0 <__errno>
    49d4:	9b08      	ldr	r3, [sp, #32]
    49d6:	6003      	str	r3, [r0, #0]
    49d8:	e7eb      	b.n	49b2 <sqrt+0x6a>
    49da:	bf00      	nop
    49dc:	f3af 8000 	nop.w
	...
    49e8:	20001e46 	.word	0x20001e46
    49ec:	20000e24 	.word	0x20000e24

000049f0 <__ieee754_atan2>:
    49f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    49f2:	b085      	sub	sp, #20
    49f4:	ed8d 1b02 	vstr	d1, [sp, #8]
    49f8:	9a02      	ldr	r2, [sp, #8]
    49fa:	9803      	ldr	r0, [sp, #12]
    49fc:	4972      	ldr	r1, [pc, #456]	; (4bc8 <__ieee754_atan2+0x1d8>)
    49fe:	4253      	negs	r3, r2
    4a00:	ed8d 0b00 	vstr	d0, [sp]
    4a04:	4313      	orrs	r3, r2
    4a06:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
    4a0a:	ea45 73d3 	orr.w	r3, r5, r3, lsr #31
    4a0e:	428b      	cmp	r3, r1
    4a10:	e89d 0090 	ldmia.w	sp, {r4, r7}
    4a14:	d842      	bhi.n	4a9c <__ieee754_atan2+0xac>
    4a16:	4263      	negs	r3, r4
    4a18:	4323      	orrs	r3, r4
    4a1a:	f027 4e00 	bic.w	lr, r7, #2147483648	; 0x80000000
    4a1e:	ea4e 73d3 	orr.w	r3, lr, r3, lsr #31
    4a22:	428b      	cmp	r3, r1
    4a24:	d83a      	bhi.n	4a9c <__ieee754_atan2+0xac>
    4a26:	f100 4340 	add.w	r3, r0, #3221225472	; 0xc0000000
    4a2a:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
    4a2e:	4313      	orrs	r3, r2
    4a30:	d053      	beq.n	4ada <__ieee754_atan2+0xea>
    4a32:	1786      	asrs	r6, r0, #30
    4a34:	f006 0602 	and.w	r6, r6, #2
    4a38:	ea54 030e 	orrs.w	r3, r4, lr
    4a3c:	ea46 76d7 	orr.w	r6, r6, r7, lsr #31
    4a40:	d034      	beq.n	4aac <__ieee754_atan2+0xbc>
    4a42:	ea52 0305 	orrs.w	r3, r2, r5
    4a46:	d03e      	beq.n	4ac6 <__ieee754_atan2+0xd6>
    4a48:	428d      	cmp	r5, r1
    4a4a:	d052      	beq.n	4af2 <__ieee754_atan2+0x102>
    4a4c:	458e      	cmp	lr, r1
    4a4e:	d03a      	beq.n	4ac6 <__ieee754_atan2+0xd6>
    4a50:	ebc5 050e 	rsb	r5, r5, lr
    4a54:	152d      	asrs	r5, r5, #20
    4a56:	2d3c      	cmp	r5, #60	; 0x3c
    4a58:	dc44      	bgt.n	4ae4 <__ieee754_atan2+0xf4>
    4a5a:	2800      	cmp	r0, #0
    4a5c:	db6b      	blt.n	4b36 <__ieee754_atan2+0x146>
    4a5e:	e9dd 2300 	ldrd	r2, r3, [sp]
    4a62:	ed9d 0b02 	vldr	d0, [sp, #8]
    4a66:	ec43 2b17 	vmov	d7, r2, r3
    4a6a:	ee87 0b00 	vdiv.f64	d0, d7, d0
    4a6e:	f000 ffe9 	bl	5a44 <fabs>
    4a72:	f000 fee5 	bl	5840 <atan>
    4a76:	ec53 2b10 	vmov	r2, r3, d0
    4a7a:	2e01      	cmp	r6, #1
    4a7c:	d056      	beq.n	4b2c <__ieee754_atan2+0x13c>
    4a7e:	2e02      	cmp	r6, #2
    4a80:	d049      	beq.n	4b16 <__ieee754_atan2+0x126>
    4a82:	2e00      	cmp	r6, #0
    4a84:	d044      	beq.n	4b10 <__ieee754_atan2+0x120>
    4a86:	ed9f 7b3a 	vldr	d7, [pc, #232]	; 4b70 <__ieee754_atan2+0x180>
    4a8a:	ed9f 6b3b 	vldr	d6, [pc, #236]	; 4b78 <__ieee754_atan2+0x188>
    4a8e:	ec43 2b15 	vmov	d5, r2, r3
    4a92:	ee35 7b47 	vsub.f64	d7, d5, d7
    4a96:	ee37 0b46 	vsub.f64	d0, d7, d6
    4a9a:	e005      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4a9c:	ed9d 7b02 	vldr	d7, [sp, #8]
    4aa0:	ed9d 6b00 	vldr	d6, [sp]
    4aa4:	ee37 0b06 	vadd.f64	d0, d7, d6
    4aa8:	b005      	add	sp, #20
    4aaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4aac:	2e02      	cmp	r6, #2
    4aae:	d01d      	beq.n	4aec <__ieee754_atan2+0xfc>
    4ab0:	ed9f 0b33 	vldr	d0, [pc, #204]	; 4b80 <__ieee754_atan2+0x190>
    4ab4:	ed9d 7b00 	vldr	d7, [sp]
    4ab8:	2e03      	cmp	r6, #3
    4aba:	bf08      	it	eq
    4abc:	eeb0 7b40 	vmoveq.f64	d7, d0
    4ac0:	eeb0 0b47 	vmov.f64	d0, d7
    4ac4:	e7f0      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4ac6:	ed9f 7b30 	vldr	d7, [pc, #192]	; 4b88 <__ieee754_atan2+0x198>
    4aca:	ed9f 0b31 	vldr	d0, [pc, #196]	; 4b90 <__ieee754_atan2+0x1a0>
    4ace:	2f00      	cmp	r7, #0
    4ad0:	bfa8      	it	ge
    4ad2:	eeb0 0b47 	vmovge.f64	d0, d7
    4ad6:	b005      	add	sp, #20
    4ad8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4ada:	b005      	add	sp, #20
    4adc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    4ae0:	f000 beae 	b.w	5840 <atan>
    4ae4:	a328      	add	r3, pc, #160	; (adr r3, 4b88 <__ieee754_atan2+0x198>)
    4ae6:	e9d3 2300 	ldrd	r2, r3, [r3]
    4aea:	e7c6      	b.n	4a7a <__ieee754_atan2+0x8a>
    4aec:	ed9f 0b22 	vldr	d0, [pc, #136]	; 4b78 <__ieee754_atan2+0x188>
    4af0:	e7da      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4af2:	45ae      	cmp	lr, r5
    4af4:	d024      	beq.n	4b40 <__ieee754_atan2+0x150>
    4af6:	2e02      	cmp	r6, #2
    4af8:	d0f8      	beq.n	4aec <__ieee754_atan2+0xfc>
    4afa:	2e03      	cmp	r6, #3
    4afc:	d02d      	beq.n	4b5a <__ieee754_atan2+0x16a>
    4afe:	ed9f 7b26 	vldr	d7, [pc, #152]	; 4b98 <__ieee754_atan2+0x1a8>
    4b02:	ed9f 0b27 	vldr	d0, [pc, #156]	; 4ba0 <__ieee754_atan2+0x1b0>
    4b06:	2e01      	cmp	r6, #1
    4b08:	bf08      	it	eq
    4b0a:	eeb0 0b47 	vmoveq.f64	d0, d7
    4b0e:	e7cb      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4b10:	ec43 2b10 	vmov	d0, r2, r3
    4b14:	e7c8      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4b16:	ed9f 7b16 	vldr	d7, [pc, #88]	; 4b70 <__ieee754_atan2+0x180>
    4b1a:	ed9f 6b17 	vldr	d6, [pc, #92]	; 4b78 <__ieee754_atan2+0x188>
    4b1e:	ec43 2b15 	vmov	d5, r2, r3
    4b22:	ee35 7b47 	vsub.f64	d7, d5, d7
    4b26:	ee36 0b47 	vsub.f64	d0, d6, d7
    4b2a:	e7bd      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4b2c:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
    4b30:	ec43 2b10 	vmov	d0, r2, r3
    4b34:	e7b8      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4b36:	353c      	adds	r5, #60	; 0x3c
    4b38:	da91      	bge.n	4a5e <__ieee754_atan2+0x6e>
    4b3a:	2200      	movs	r2, #0
    4b3c:	2300      	movs	r3, #0
    4b3e:	e79c      	b.n	4a7a <__ieee754_atan2+0x8a>
    4b40:	2e02      	cmp	r6, #2
    4b42:	d010      	beq.n	4b66 <__ieee754_atan2+0x176>
    4b44:	2e03      	cmp	r6, #3
    4b46:	d00b      	beq.n	4b60 <__ieee754_atan2+0x170>
    4b48:	ed9f 7b17 	vldr	d7, [pc, #92]	; 4ba8 <__ieee754_atan2+0x1b8>
    4b4c:	ed9f 0b18 	vldr	d0, [pc, #96]	; 4bb0 <__ieee754_atan2+0x1c0>
    4b50:	2e01      	cmp	r6, #1
    4b52:	bf08      	it	eq
    4b54:	eeb0 0b47 	vmoveq.f64	d0, d7
    4b58:	e7a6      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4b5a:	ed9f 0b09 	vldr	d0, [pc, #36]	; 4b80 <__ieee754_atan2+0x190>
    4b5e:	e7a3      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4b60:	ed9f 0b15 	vldr	d0, [pc, #84]	; 4bb8 <__ieee754_atan2+0x1c8>
    4b64:	e7a0      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4b66:	ed9f 0b16 	vldr	d0, [pc, #88]	; 4bc0 <__ieee754_atan2+0x1d0>
    4b6a:	e79d      	b.n	4aa8 <__ieee754_atan2+0xb8>
    4b6c:	f3af 8000 	nop.w
    4b70:	33145c07 	.word	0x33145c07
    4b74:	3ca1a626 	.word	0x3ca1a626
    4b78:	54442d18 	.word	0x54442d18
    4b7c:	400921fb 	.word	0x400921fb
    4b80:	54442d18 	.word	0x54442d18
    4b84:	c00921fb 	.word	0xc00921fb
    4b88:	54442d18 	.word	0x54442d18
    4b8c:	3ff921fb 	.word	0x3ff921fb
    4b90:	54442d18 	.word	0x54442d18
    4b94:	bff921fb 	.word	0xbff921fb
    4b98:	00000000 	.word	0x00000000
    4b9c:	80000000 	.word	0x80000000
	...
    4ba8:	54442d18 	.word	0x54442d18
    4bac:	bfe921fb 	.word	0xbfe921fb
    4bb0:	54442d18 	.word	0x54442d18
    4bb4:	3fe921fb 	.word	0x3fe921fb
    4bb8:	7f3321d2 	.word	0x7f3321d2
    4bbc:	c002d97c 	.word	0xc002d97c
    4bc0:	7f3321d2 	.word	0x7f3321d2
    4bc4:	4002d97c 	.word	0x4002d97c
    4bc8:	7ff00000 	.word	0x7ff00000
    4bcc:	00000000 	.word	0x00000000

00004bd0 <__ieee754_rem_pio2>:
    4bd0:	b570      	push	{r4, r5, r6, lr}
    4bd2:	ec53 2b10 	vmov	r2, r3, d0
    4bd6:	499e      	ldr	r1, [pc, #632]	; (4e50 <__ieee754_rem_pio2+0x280>)
    4bd8:	f023 4600 	bic.w	r6, r3, #2147483648	; 0x80000000
    4bdc:	428e      	cmp	r6, r1
    4bde:	b088      	sub	sp, #32
    4be0:	dd62      	ble.n	4ca8 <__ieee754_rem_pio2+0xd8>
    4be2:	499c      	ldr	r1, [pc, #624]	; (4e54 <__ieee754_rem_pio2+0x284>)
    4be4:	428e      	cmp	r6, r1
    4be6:	461d      	mov	r5, r3
    4be8:	dc1c      	bgt.n	4c24 <__ieee754_rem_pio2+0x54>
    4bea:	2b00      	cmp	r3, #0
    4bec:	ed9f 7b88 	vldr	d7, [pc, #544]	; 4e10 <__ieee754_rem_pio2+0x240>
    4bf0:	f340 80df 	ble.w	4db2 <__ieee754_rem_pio2+0x1e2>
    4bf4:	ee30 7b47 	vsub.f64	d7, d0, d7
    4bf8:	f5a1 211b 	sub.w	r1, r1, #634880	; 0x9b000
    4bfc:	f5a1 61f0 	sub.w	r1, r1, #1920	; 0x780
    4c00:	428e      	cmp	r6, r1
    4c02:	d063      	beq.n	4ccc <__ieee754_rem_pio2+0xfc>
    4c04:	ed9f 6b84 	vldr	d6, [pc, #528]	; 4e18 <__ieee754_rem_pio2+0x248>
    4c08:	ee37 5b46 	vsub.f64	d5, d7, d6
    4c0c:	ee37 7b45 	vsub.f64	d7, d7, d5
    4c10:	2301      	movs	r3, #1
    4c12:	ed80 5b00 	vstr	d5, [r0]
    4c16:	ee37 7b46 	vsub.f64	d7, d7, d6
    4c1a:	ed80 7b02 	vstr	d7, [r0, #8]
    4c1e:	4618      	mov	r0, r3
    4c20:	b008      	add	sp, #32
    4c22:	bd70      	pop	{r4, r5, r6, pc}
    4c24:	498c      	ldr	r1, [pc, #560]	; (4e58 <__ieee754_rem_pio2+0x288>)
    4c26:	428e      	cmp	r6, r1
    4c28:	4604      	mov	r4, r0
    4c2a:	dd56      	ble.n	4cda <__ieee754_rem_pio2+0x10a>
    4c2c:	498b      	ldr	r1, [pc, #556]	; (4e5c <__ieee754_rem_pio2+0x28c>)
    4c2e:	428e      	cmp	r6, r1
    4c30:	dc44      	bgt.n	4cbc <__ieee754_rem_pio2+0xec>
    4c32:	4610      	mov	r0, r2
    4c34:	1532      	asrs	r2, r6, #20
    4c36:	f2a2 4216 	subw	r2, r2, #1046	; 0x416
    4c3a:	eba6 5102 	sub.w	r1, r6, r2, lsl #20
    4c3e:	ec41 0b16 	vmov	d6, r0, r1
    4c42:	ed9f 7b77 	vldr	d7, [pc, #476]	; 4e20 <__ieee754_rem_pio2+0x250>
    4c46:	eebd 4bc6 	vcvt.s32.f64	s8, d6
    4c4a:	2300      	movs	r3, #0
    4c4c:	eeb8 4bc4 	vcvt.f64.s32	d4, s8
    4c50:	ee36 6b44 	vsub.f64	d6, d6, d4
    4c54:	ee26 6b07 	vmul.f64	d6, d6, d7
    4c58:	eebd 5bc6 	vcvt.s32.f64	s10, d6
    4c5c:	ed8d 4b02 	vstr	d4, [sp, #8]
    4c60:	eeb8 5bc5 	vcvt.f64.s32	d5, s10
    4c64:	ee36 6b45 	vsub.f64	d6, d6, d5
    4c68:	ee26 7b07 	vmul.f64	d7, d6, d7
    4c6c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    4c70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4c74:	ed8d 5b04 	vstr	d5, [sp, #16]
    4c78:	ed8d 7b06 	vstr	d7, [sp, #24]
    4c7c:	f040 80bb 	bne.w	4df6 <__ieee754_rem_pio2+0x226>
    4c80:	eeb5 5b40 	vcmp.f64	d5, #0.0
    4c84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4c88:	bf0c      	ite	eq
    4c8a:	2301      	moveq	r3, #1
    4c8c:	2302      	movne	r3, #2
    4c8e:	4974      	ldr	r1, [pc, #464]	; (4e60 <__ieee754_rem_pio2+0x290>)
    4c90:	9101      	str	r1, [sp, #4]
    4c92:	2102      	movs	r1, #2
    4c94:	9100      	str	r1, [sp, #0]
    4c96:	a802      	add	r0, sp, #8
    4c98:	4621      	mov	r1, r4
    4c9a:	f000 fa39 	bl	5110 <__kernel_rem_pio2>
    4c9e:	2d00      	cmp	r5, #0
    4ca0:	f2c0 809b 	blt.w	4dda <__ieee754_rem_pio2+0x20a>
    4ca4:	4603      	mov	r3, r0
    4ca6:	e006      	b.n	4cb6 <__ieee754_rem_pio2+0xe6>
    4ca8:	2400      	movs	r4, #0
    4caa:	2500      	movs	r5, #0
    4cac:	ed80 0b00 	vstr	d0, [r0]
    4cb0:	e9c0 4502 	strd	r4, r5, [r0, #8]
    4cb4:	2300      	movs	r3, #0
    4cb6:	4618      	mov	r0, r3
    4cb8:	b008      	add	sp, #32
    4cba:	bd70      	pop	{r4, r5, r6, pc}
    4cbc:	ee30 7b40 	vsub.f64	d7, d0, d0
    4cc0:	2300      	movs	r3, #0
    4cc2:	ed80 7b02 	vstr	d7, [r0, #8]
    4cc6:	ed80 7b00 	vstr	d7, [r0]
    4cca:	e7f4      	b.n	4cb6 <__ieee754_rem_pio2+0xe6>
    4ccc:	ed9f 5b56 	vldr	d5, [pc, #344]	; 4e28 <__ieee754_rem_pio2+0x258>
    4cd0:	ed9f 6b57 	vldr	d6, [pc, #348]	; 4e30 <__ieee754_rem_pio2+0x260>
    4cd4:	ee37 7b45 	vsub.f64	d7, d7, d5
    4cd8:	e796      	b.n	4c08 <__ieee754_rem_pio2+0x38>
    4cda:	f000 feb3 	bl	5a44 <fabs>
    4cde:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    4ce2:	ed9f 6b55 	vldr	d6, [pc, #340]	; 4e38 <__ieee754_rem_pio2+0x268>
    4ce6:	eea0 7b06 	vfma.f64	d7, d0, d6
    4cea:	eefd 7bc7 	vcvt.s32.f64	s15, d7
    4cee:	ed9f 3b48 	vldr	d3, [pc, #288]	; 4e10 <__ieee754_rem_pio2+0x240>
    4cf2:	ee17 3a90 	vmov	r3, s15
    4cf6:	ed9f 6b48 	vldr	d6, [pc, #288]	; 4e18 <__ieee754_rem_pio2+0x248>
    4cfa:	2b1f      	cmp	r3, #31
    4cfc:	eeb8 5be7 	vcvt.f64.s32	d5, s15
    4d00:	eeb1 4b45 	vneg.f64	d4, d5
    4d04:	ee25 7b06 	vmul.f64	d7, d5, d6
    4d08:	eea4 0b03 	vfma.f64	d0, d4, d3
    4d0c:	dc1b      	bgt.n	4d46 <__ieee754_rem_pio2+0x176>
    4d0e:	4a55      	ldr	r2, [pc, #340]	; (4e64 <__ieee754_rem_pio2+0x294>)
    4d10:	1e59      	subs	r1, r3, #1
    4d12:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    4d16:	4296      	cmp	r6, r2
    4d18:	d015      	beq.n	4d46 <__ieee754_rem_pio2+0x176>
    4d1a:	ee30 6b47 	vsub.f64	d6, d0, d7
    4d1e:	ed84 6b00 	vstr	d6, [r4]
    4d22:	ee30 0b46 	vsub.f64	d0, d0, d6
    4d26:	ee30 0b47 	vsub.f64	d0, d0, d7
    4d2a:	2d00      	cmp	r5, #0
    4d2c:	ed84 0b02 	vstr	d0, [r4, #8]
    4d30:	dac1      	bge.n	4cb6 <__ieee754_rem_pio2+0xe6>
    4d32:	eeb1 6b46 	vneg.f64	d6, d6
    4d36:	eeb1 0b40 	vneg.f64	d0, d0
    4d3a:	ed84 6b00 	vstr	d6, [r4]
    4d3e:	ed84 0b02 	vstr	d0, [r4, #8]
    4d42:	425b      	negs	r3, r3
    4d44:	e7b7      	b.n	4cb6 <__ieee754_rem_pio2+0xe6>
    4d46:	ee30 6b47 	vsub.f64	d6, d0, d7
    4d4a:	ee16 2a90 	vmov	r2, s13
    4d4e:	1536      	asrs	r6, r6, #20
    4d50:	f3c2 520a 	ubfx	r2, r2, #20, #11
    4d54:	1ab2      	subs	r2, r6, r2
    4d56:	2a10      	cmp	r2, #16
    4d58:	ed84 6b00 	vstr	d6, [r4]
    4d5c:	dde1      	ble.n	4d22 <__ieee754_rem_pio2+0x152>
    4d5e:	eeb0 3b40 	vmov.f64	d3, d0
    4d62:	ed9f 7b31 	vldr	d7, [pc, #196]	; 4e28 <__ieee754_rem_pio2+0x258>
    4d66:	ed9f 6b32 	vldr	d6, [pc, #200]	; 4e30 <__ieee754_rem_pio2+0x260>
    4d6a:	eea4 3b07 	vfma.f64	d3, d4, d7
    4d6e:	ee30 0b43 	vsub.f64	d0, d0, d3
    4d72:	eea4 0b07 	vfma.f64	d0, d4, d7
    4d76:	eeb0 7b40 	vmov.f64	d7, d0
    4d7a:	ee95 7b06 	vfnms.f64	d7, d5, d6
    4d7e:	ee33 6b47 	vsub.f64	d6, d3, d7
    4d82:	ee16 2a90 	vmov	r2, s13
    4d86:	f3c2 520a 	ubfx	r2, r2, #20, #11
    4d8a:	1ab6      	subs	r6, r6, r2
    4d8c:	2e31      	cmp	r6, #49	; 0x31
    4d8e:	ed84 6b00 	vstr	d6, [r4]
    4d92:	dd39      	ble.n	4e08 <__ieee754_rem_pio2+0x238>
    4d94:	eeb0 0b43 	vmov.f64	d0, d3
    4d98:	ed9f 6b29 	vldr	d6, [pc, #164]	; 4e40 <__ieee754_rem_pio2+0x270>
    4d9c:	ed9f 2b2a 	vldr	d2, [pc, #168]	; 4e48 <__ieee754_rem_pio2+0x278>
    4da0:	eea4 0b06 	vfma.f64	d0, d4, d6
    4da4:	ee33 7b40 	vsub.f64	d7, d3, d0
    4da8:	eea4 7b06 	vfma.f64	d7, d4, d6
    4dac:	ee95 7b02 	vfnms.f64	d7, d5, d2
    4db0:	e7b3      	b.n	4d1a <__ieee754_rem_pio2+0x14a>
    4db2:	492d      	ldr	r1, [pc, #180]	; (4e68 <__ieee754_rem_pio2+0x298>)
    4db4:	ee30 7b07 	vadd.f64	d7, d0, d7
    4db8:	428e      	cmp	r6, r1
    4dba:	d01e      	beq.n	4dfa <__ieee754_rem_pio2+0x22a>
    4dbc:	ed9f 6b16 	vldr	d6, [pc, #88]	; 4e18 <__ieee754_rem_pio2+0x248>
    4dc0:	ee37 5b06 	vadd.f64	d5, d7, d6
    4dc4:	ee37 7b45 	vsub.f64	d7, d7, d5
    4dc8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4dcc:	ee37 7b06 	vadd.f64	d7, d7, d6
    4dd0:	ed80 5b00 	vstr	d5, [r0]
    4dd4:	ed80 7b02 	vstr	d7, [r0, #8]
    4dd8:	e76d      	b.n	4cb6 <__ieee754_rem_pio2+0xe6>
    4dda:	ed94 6b00 	vldr	d6, [r4]
    4dde:	ed94 7b02 	vldr	d7, [r4, #8]
    4de2:	eeb1 6b46 	vneg.f64	d6, d6
    4de6:	eeb1 7b47 	vneg.f64	d7, d7
    4dea:	4243      	negs	r3, r0
    4dec:	ed84 6b00 	vstr	d6, [r4]
    4df0:	ed84 7b02 	vstr	d7, [r4, #8]
    4df4:	e75f      	b.n	4cb6 <__ieee754_rem_pio2+0xe6>
    4df6:	2303      	movs	r3, #3
    4df8:	e749      	b.n	4c8e <__ieee754_rem_pio2+0xbe>
    4dfa:	ed9f 5b0b 	vldr	d5, [pc, #44]	; 4e28 <__ieee754_rem_pio2+0x258>
    4dfe:	ed9f 6b0c 	vldr	d6, [pc, #48]	; 4e30 <__ieee754_rem_pio2+0x260>
    4e02:	ee37 7b05 	vadd.f64	d7, d7, d5
    4e06:	e7db      	b.n	4dc0 <__ieee754_rem_pio2+0x1f0>
    4e08:	eeb0 0b43 	vmov.f64	d0, d3
    4e0c:	e789      	b.n	4d22 <__ieee754_rem_pio2+0x152>
    4e0e:	bf00      	nop
    4e10:	54400000 	.word	0x54400000
    4e14:	3ff921fb 	.word	0x3ff921fb
    4e18:	1a626331 	.word	0x1a626331
    4e1c:	3dd0b461 	.word	0x3dd0b461
    4e20:	00000000 	.word	0x00000000
    4e24:	41700000 	.word	0x41700000
    4e28:	1a600000 	.word	0x1a600000
    4e2c:	3dd0b461 	.word	0x3dd0b461
    4e30:	2e037073 	.word	0x2e037073
    4e34:	3ba3198a 	.word	0x3ba3198a
    4e38:	6dc9c883 	.word	0x6dc9c883
    4e3c:	3fe45f30 	.word	0x3fe45f30
    4e40:	2e000000 	.word	0x2e000000
    4e44:	3ba3198a 	.word	0x3ba3198a
    4e48:	252049c1 	.word	0x252049c1
    4e4c:	397b839a 	.word	0x397b839a
    4e50:	3fe921fb 	.word	0x3fe921fb
    4e54:	4002d97b 	.word	0x4002d97b
    4e58:	413921fb 	.word	0x413921fb
    4e5c:	7fefffff 	.word	0x7fefffff
    4e60:	20000e90 	.word	0x20000e90
    4e64:	20000a5c 	.word	0x20000a5c
    4e68:	3ff921fb 	.word	0x3ff921fb

00004e6c <__ieee754_sqrt>:
    4e6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4e70:	b082      	sub	sp, #8
    4e72:	ed8d 0b00 	vstr	d0, [sp]
    4e76:	495d      	ldr	r1, [pc, #372]	; (4fec <__ieee754_sqrt+0x180>)
    4e78:	9b01      	ldr	r3, [sp, #4]
    4e7a:	9800      	ldr	r0, [sp, #0]
    4e7c:	460c      	mov	r4, r1
    4e7e:	4019      	ands	r1, r3
    4e80:	42a1      	cmp	r1, r4
    4e82:	f000 8098 	beq.w	4fb6 <__ieee754_sqrt+0x14a>
    4e86:	2b00      	cmp	r3, #0
    4e88:	4602      	mov	r2, r0
    4e8a:	dd77      	ble.n	4f7c <__ieee754_sqrt+0x110>
    4e8c:	151f      	asrs	r7, r3, #20
    4e8e:	f000 8082 	beq.w	4f96 <__ieee754_sqrt+0x12a>
    4e92:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
    4e96:	f3c3 0313 	ubfx	r3, r3, #0, #20
    4e9a:	07f9      	lsls	r1, r7, #31
    4e9c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    4ea0:	d467      	bmi.n	4f72 <__ieee754_sqrt+0x106>
    4ea2:	eb03 71d2 	add.w	r1, r3, r2, lsr #31
    4ea6:	2600      	movs	r6, #0
    4ea8:	440b      	add	r3, r1
    4eaa:	107f      	asrs	r7, r7, #1
    4eac:	0052      	lsls	r2, r2, #1
    4eae:	46b6      	mov	lr, r6
    4eb0:	2016      	movs	r0, #22
    4eb2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    4eb6:	eb0e 0401 	add.w	r4, lr, r1
    4eba:	429c      	cmp	r4, r3
    4ebc:	ea4f 75d2 	mov.w	r5, r2, lsr #31
    4ec0:	ea4f 0242 	mov.w	r2, r2, lsl #1
    4ec4:	dc03      	bgt.n	4ece <__ieee754_sqrt+0x62>
    4ec6:	1b1b      	subs	r3, r3, r4
    4ec8:	eb04 0e01 	add.w	lr, r4, r1
    4ecc:	440e      	add	r6, r1
    4ece:	3801      	subs	r0, #1
    4ed0:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    4ed4:	ea4f 0151 	mov.w	r1, r1, lsr #1
    4ed8:	d1ed      	bne.n	4eb6 <__ieee754_sqrt+0x4a>
    4eda:	4684      	mov	ip, r0
    4edc:	2420      	movs	r4, #32
    4ede:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    4ee2:	e009      	b.n	4ef8 <__ieee754_sqrt+0x8c>
    4ee4:	d020      	beq.n	4f28 <__ieee754_sqrt+0xbc>
    4ee6:	eb03 75d2 	add.w	r5, r3, r2, lsr #31
    4eea:	3c01      	subs	r4, #1
    4eec:	ea4f 0151 	mov.w	r1, r1, lsr #1
    4ef0:	442b      	add	r3, r5
    4ef2:	ea4f 0242 	mov.w	r2, r2, lsl #1
    4ef6:	d020      	beq.n	4f3a <__ieee754_sqrt+0xce>
    4ef8:	459e      	cmp	lr, r3
    4efa:	eb01 050c 	add.w	r5, r1, ip
    4efe:	daf1      	bge.n	4ee4 <__ieee754_sqrt+0x78>
    4f00:	2d00      	cmp	r5, #0
    4f02:	eb05 0c01 	add.w	ip, r5, r1
    4f06:	db09      	blt.n	4f1c <__ieee754_sqrt+0xb0>
    4f08:	46f0      	mov	r8, lr
    4f0a:	4295      	cmp	r5, r2
    4f0c:	ebce 0303 	rsb	r3, lr, r3
    4f10:	d900      	bls.n	4f14 <__ieee754_sqrt+0xa8>
    4f12:	3b01      	subs	r3, #1
    4f14:	1b52      	subs	r2, r2, r5
    4f16:	4408      	add	r0, r1
    4f18:	46c6      	mov	lr, r8
    4f1a:	e7e4      	b.n	4ee6 <__ieee754_sqrt+0x7a>
    4f1c:	f1bc 0f00 	cmp.w	ip, #0
    4f20:	dbf2      	blt.n	4f08 <__ieee754_sqrt+0x9c>
    4f22:	f10e 0801 	add.w	r8, lr, #1
    4f26:	e7f0      	b.n	4f0a <__ieee754_sqrt+0x9e>
    4f28:	4295      	cmp	r5, r2
    4f2a:	d81a      	bhi.n	4f62 <__ieee754_sqrt+0xf6>
    4f2c:	2d00      	cmp	r5, #0
    4f2e:	eb05 0c01 	add.w	ip, r5, r1
    4f32:	db48      	blt.n	4fc6 <__ieee754_sqrt+0x15a>
    4f34:	4698      	mov	r8, r3
    4f36:	2300      	movs	r3, #0
    4f38:	e7ec      	b.n	4f14 <__ieee754_sqrt+0xa8>
    4f3a:	4313      	orrs	r3, r2
    4f3c:	d113      	bne.n	4f66 <__ieee754_sqrt+0xfa>
    4f3e:	0840      	lsrs	r0, r0, #1
    4f40:	1071      	asrs	r1, r6, #1
    4f42:	07f3      	lsls	r3, r6, #31
    4f44:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
    4f48:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
    4f4c:	bf48      	it	mi
    4f4e:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
    4f52:	eb01 5307 	add.w	r3, r1, r7, lsl #20
    4f56:	4602      	mov	r2, r0
    4f58:	ec43 2b10 	vmov	d0, r2, r3
    4f5c:	b002      	add	sp, #8
    4f5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4f62:	4673      	mov	r3, lr
    4f64:	e7bf      	b.n	4ee6 <__ieee754_sqrt+0x7a>
    4f66:	1c42      	adds	r2, r0, #1
    4f68:	d031      	beq.n	4fce <__ieee754_sqrt+0x162>
    4f6a:	f000 0301 	and.w	r3, r0, #1
    4f6e:	4418      	add	r0, r3
    4f70:	e7e5      	b.n	4f3e <__ieee754_sqrt+0xd2>
    4f72:	005b      	lsls	r3, r3, #1
    4f74:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
    4f78:	0052      	lsls	r2, r2, #1
    4f7a:	e792      	b.n	4ea2 <__ieee754_sqrt+0x36>
    4f7c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    4f80:	4301      	orrs	r1, r0
    4f82:	d01d      	beq.n	4fc0 <__ieee754_sqrt+0x154>
    4f84:	bb5b      	cbnz	r3, 4fde <__ieee754_sqrt+0x172>
    4f86:	461f      	mov	r7, r3
    4f88:	0ad3      	lsrs	r3, r2, #11
    4f8a:	3f15      	subs	r7, #21
    4f8c:	0552      	lsls	r2, r2, #21
    4f8e:	2b00      	cmp	r3, #0
    4f90:	d0fa      	beq.n	4f88 <__ieee754_sqrt+0x11c>
    4f92:	02dd      	lsls	r5, r3, #11
    4f94:	d41e      	bmi.n	4fd4 <__ieee754_sqrt+0x168>
    4f96:	2100      	movs	r1, #0
    4f98:	e000      	b.n	4f9c <__ieee754_sqrt+0x130>
    4f9a:	4601      	mov	r1, r0
    4f9c:	005b      	lsls	r3, r3, #1
    4f9e:	02dc      	lsls	r4, r3, #11
    4fa0:	f101 0001 	add.w	r0, r1, #1
    4fa4:	d5f9      	bpl.n	4f9a <__ieee754_sqrt+0x12e>
    4fa6:	f1c0 0420 	rsb	r4, r0, #32
    4faa:	fa22 f404 	lsr.w	r4, r2, r4
    4fae:	4323      	orrs	r3, r4
    4fb0:	1a7f      	subs	r7, r7, r1
    4fb2:	4082      	lsls	r2, r0
    4fb4:	e76d      	b.n	4e92 <__ieee754_sqrt+0x26>
    4fb6:	eea0 0b00 	vfma.f64	d0, d0, d0
    4fba:	b002      	add	sp, #8
    4fbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4fc0:	ed9d 0b00 	vldr	d0, [sp]
    4fc4:	e7ca      	b.n	4f5c <__ieee754_sqrt+0xf0>
    4fc6:	f1bc 0f00 	cmp.w	ip, #0
    4fca:	daaa      	bge.n	4f22 <__ieee754_sqrt+0xb6>
    4fcc:	e7b2      	b.n	4f34 <__ieee754_sqrt+0xc8>
    4fce:	3601      	adds	r6, #1
    4fd0:	4620      	mov	r0, r4
    4fd2:	e7b5      	b.n	4f40 <__ieee754_sqrt+0xd4>
    4fd4:	2420      	movs	r4, #32
    4fd6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    4fda:	2000      	movs	r0, #0
    4fdc:	e7e5      	b.n	4faa <__ieee754_sqrt+0x13e>
    4fde:	ed9d 7b00 	vldr	d7, [sp]
    4fe2:	ee37 7b47 	vsub.f64	d7, d7, d7
    4fe6:	ee87 0b07 	vdiv.f64	d0, d7, d7
    4fea:	e7b7      	b.n	4f5c <__ieee754_sqrt+0xf0>
    4fec:	7ff00000 	.word	0x7ff00000

00004ff0 <__kernel_cos>:
    4ff0:	ee10 3a90 	vmov	r3, s1
    4ff4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    4ff8:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
    4ffc:	da2c      	bge.n	5058 <__kernel_cos+0x68>
    4ffe:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    5002:	ee17 3a90 	vmov	r3, s15
    5006:	2b00      	cmp	r3, #0
    5008:	d061      	beq.n	50ce <__kernel_cos+0xde>
    500a:	ee20 7b00 	vmul.f64	d7, d0, d0
    500e:	ed9f 4b32 	vldr	d4, [pc, #200]	; 50d8 <__kernel_cos+0xe8>
    5012:	ed9f 5b33 	vldr	d5, [pc, #204]	; 50e0 <__kernel_cos+0xf0>
    5016:	ed9f 6b34 	vldr	d6, [pc, #208]	; 50e8 <__kernel_cos+0xf8>
    501a:	eea7 5b04 	vfma.f64	d5, d7, d4
    501e:	ed9f 4b34 	vldr	d4, [pc, #208]	; 50f0 <__kernel_cos+0x100>
    5022:	eea7 6b05 	vfma.f64	d6, d7, d5
    5026:	ed9f 5b34 	vldr	d5, [pc, #208]	; 50f8 <__kernel_cos+0x108>
    502a:	eea7 4b06 	vfma.f64	d4, d7, d6
    502e:	ed9f 6b34 	vldr	d6, [pc, #208]	; 5100 <__kernel_cos+0x110>
    5032:	eea7 5b04 	vfma.f64	d5, d7, d4
    5036:	eea7 6b05 	vfma.f64	d6, d7, d5
    503a:	ee26 6b07 	vmul.f64	d6, d6, d7
    503e:	ee21 0b40 	vnmul.f64	d0, d1, d0
    5042:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
    5046:	eea7 0b06 	vfma.f64	d0, d7, d6
    504a:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    504e:	ee97 0b05 	vfnms.f64	d0, d7, d5
    5052:	ee36 0b40 	vsub.f64	d0, d6, d0
    5056:	4770      	bx	lr
    5058:	ed9f 4b1f 	vldr	d4, [pc, #124]	; 50d8 <__kernel_cos+0xe8>
    505c:	ee20 7b00 	vmul.f64	d7, d0, d0
    5060:	ed9f 5b1f 	vldr	d5, [pc, #124]	; 50e0 <__kernel_cos+0xf0>
    5064:	ed9f 6b20 	vldr	d6, [pc, #128]	; 50e8 <__kernel_cos+0xf8>
    5068:	eea7 5b04 	vfma.f64	d5, d7, d4
    506c:	ed9f 4b20 	vldr	d4, [pc, #128]	; 50f0 <__kernel_cos+0x100>
    5070:	eea7 6b05 	vfma.f64	d6, d7, d5
    5074:	4a24      	ldr	r2, [pc, #144]	; (5108 <__kernel_cos+0x118>)
    5076:	eea7 4b06 	vfma.f64	d4, d7, d6
    507a:	ed9f 5b1f 	vldr	d5, [pc, #124]	; 50f8 <__kernel_cos+0x108>
    507e:	ed9f 6b20 	vldr	d6, [pc, #128]	; 5100 <__kernel_cos+0x110>
    5082:	eea7 5b04 	vfma.f64	d5, d7, d4
    5086:	4293      	cmp	r3, r2
    5088:	eea7 6b05 	vfma.f64	d6, d7, d5
    508c:	ee26 6b07 	vmul.f64	d6, d6, d7
    5090:	ddd5      	ble.n	503e <__kernel_cos+0x4e>
    5092:	4a1e      	ldr	r2, [pc, #120]	; (510c <__kernel_cos+0x11c>)
    5094:	4293      	cmp	r3, r2
    5096:	dc15      	bgt.n	50c4 <__kernel_cos+0xd4>
    5098:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
    509c:	2000      	movs	r0, #0
    509e:	f5a3 1100 	sub.w	r1, r3, #2097152	; 0x200000
    50a2:	ec41 0b15 	vmov	d5, r0, r1
    50a6:	ee34 4b45 	vsub.f64	d4, d4, d5
    50aa:	ee21 1b40 	vnmul.f64	d1, d1, d0
    50ae:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    50b2:	eea7 1b06 	vfma.f64	d1, d7, d6
    50b6:	ee97 5b03 	vfnms.f64	d5, d7, d3
    50ba:	ee35 5b41 	vsub.f64	d5, d5, d1
    50be:	ee34 0b45 	vsub.f64	d0, d4, d5
    50c2:	4770      	bx	lr
    50c4:	eeb6 4b07 	vmov.f64	d4, #103	; 0x3f380000  0.7187500
    50c8:	eeb5 5b02 	vmov.f64	d5, #82	; 0x3e900000  0.2812500
    50cc:	e7ed      	b.n	50aa <__kernel_cos+0xba>
    50ce:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    50d2:	4770      	bx	lr
    50d4:	f3af 8000 	nop.w
    50d8:	be8838d4 	.word	0xbe8838d4
    50dc:	bda8fae9 	.word	0xbda8fae9
    50e0:	bdb4b1c4 	.word	0xbdb4b1c4
    50e4:	3e21ee9e 	.word	0x3e21ee9e
    50e8:	809c52ad 	.word	0x809c52ad
    50ec:	be927e4f 	.word	0xbe927e4f
    50f0:	19cb1590 	.word	0x19cb1590
    50f4:	3efa01a0 	.word	0x3efa01a0
    50f8:	16c15177 	.word	0x16c15177
    50fc:	bf56c16c 	.word	0xbf56c16c
    5100:	5555554c 	.word	0x5555554c
    5104:	3fa55555 	.word	0x3fa55555
    5108:	3fd33332 	.word	0x3fd33332
    510c:	3fe90000 	.word	0x3fe90000

00005110 <__kernel_rem_pio2>:
    5110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5114:	ed2d 8b08 	vpush	{d8-d11}
    5118:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
    511c:	4cb0      	ldr	r4, [pc, #704]	; (53e0 <__kernel_rem_pio2+0x2d0>)
    511e:	9ea4      	ldr	r6, [sp, #656]	; 0x290
    5120:	4db0      	ldr	r5, [pc, #704]	; (53e4 <__kernel_rem_pio2+0x2d4>)
    5122:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
    5126:	9301      	str	r3, [sp, #4]
    5128:	1ed4      	subs	r4, r2, #3
    512a:	fb85 7504 	smull	r7, r5, r5, r4
    512e:	17e4      	asrs	r4, r4, #31
    5130:	ebc4 04a5 	rsb	r4, r4, r5, asr #2
    5134:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
    5138:	1e5f      	subs	r7, r3, #1
    513a:	f104 0a01 	add.w	sl, r4, #1
    513e:	ebaa 0a8a 	sub.w	sl, sl, sl, lsl #2
    5142:	468b      	mov	fp, r1
    5144:	19f1      	adds	r1, r6, r7
    5146:	9402      	str	r4, [sp, #8]
    5148:	4681      	mov	r9, r0
    514a:	eb02 0aca 	add.w	sl, r2, sl, lsl #3
    514e:	eba4 0307 	sub.w	r3, r4, r7
    5152:	d418      	bmi.n	5186 <__kernel_rem_pio2+0x76>
    5154:	4419      	add	r1, r3
    5156:	3101      	adds	r1, #1
    5158:	aa1a      	add	r2, sp, #104	; 0x68
    515a:	98a5      	ldr	r0, [sp, #660]	; 0x294
    515c:	e00a      	b.n	5174 <__kernel_rem_pio2+0x64>
    515e:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    5162:	ee07 4a90 	vmov	s15, r4
    5166:	3301      	adds	r3, #1
    5168:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    516c:	428b      	cmp	r3, r1
    516e:	eca2 7b02 	vstmia	r2!, {d7}
    5172:	d008      	beq.n	5186 <__kernel_rem_pio2+0x76>
    5174:	2b00      	cmp	r3, #0
    5176:	daf2      	bge.n	515e <__kernel_rem_pio2+0x4e>
    5178:	ed9f 7b93 	vldr	d7, [pc, #588]	; 53c8 <__kernel_rem_pio2+0x2b8>
    517c:	3301      	adds	r3, #1
    517e:	428b      	cmp	r3, r1
    5180:	eca2 7b02 	vstmia	r2!, {d7}
    5184:	d1f6      	bne.n	5174 <__kernel_rem_pio2+0x64>
    5186:	2e00      	cmp	r6, #0
    5188:	f2c0 82e2 	blt.w	5750 <__kernel_rem_pio2+0x640>
    518c:	9b01      	ldr	r3, [sp, #4]
    518e:	a86a      	add	r0, sp, #424	; 0x1a8
    5190:	f106 0e01 	add.w	lr, r6, #1
    5194:	00dc      	lsls	r4, r3, #3
    5196:	eb00 0ece 	add.w	lr, r0, lr, lsl #3
    519a:	eb09 0104 	add.w	r1, r9, r4
    519e:	463d      	mov	r5, r7
    51a0:	2f00      	cmp	r7, #0
    51a2:	f2c0 81c8 	blt.w	5536 <__kernel_rem_pio2+0x426>
    51a6:	ab1a      	add	r3, sp, #104	; 0x68
    51a8:	ed9f 7b87 	vldr	d7, [pc, #540]	; 53c8 <__kernel_rem_pio2+0x2b8>
    51ac:	eb03 02c5 	add.w	r2, r3, r5, lsl #3
    51b0:	3208      	adds	r2, #8
    51b2:	464b      	mov	r3, r9
    51b4:	ecb3 5b02 	vldmia	r3!, {d5}
    51b8:	ed32 6b02 	vldmdb	r2!, {d6}
    51bc:	428b      	cmp	r3, r1
    51be:	eea5 7b06 	vfma.f64	d7, d5, d6
    51c2:	d1f7      	bne.n	51b4 <__kernel_rem_pio2+0xa4>
    51c4:	eca0 7b02 	vstmia	r0!, {d7}
    51c8:	4570      	cmp	r0, lr
    51ca:	f105 0501 	add.w	r5, r5, #1
    51ce:	d1e7      	bne.n	51a0 <__kernel_rem_pio2+0x90>
    51d0:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
    51d4:	3b02      	subs	r3, #2
    51d6:	009b      	lsls	r3, r3, #2
    51d8:	aa06      	add	r2, sp, #24
    51da:	ed9f 9b7d 	vldr	d9, [pc, #500]	; 53d0 <__kernel_rem_pio2+0x2c0>
    51de:	ed9f 8b7e 	vldr	d8, [pc, #504]	; 53d8 <__kernel_rem_pio2+0x2c8>
    51e2:	f103 0804 	add.w	r8, r3, #4
    51e6:	4413      	add	r3, r2
    51e8:	444c      	add	r4, r9
    51ea:	4490      	add	r8, r2
    51ec:	9303      	str	r3, [sp, #12]
    51ee:	4635      	mov	r5, r6
    51f0:	f8cd b010 	str.w	fp, [sp, #16]
    51f4:	ab92      	add	r3, sp, #584	; 0x248
    51f6:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    51fa:	2d00      	cmp	r5, #0
    51fc:	ed13 0b28 	vldr	d0, [r3, #-160]	; 0xffffff60
    5200:	dd17      	ble.n	5232 <__kernel_rem_pio2+0x122>
    5202:	a96a      	add	r1, sp, #424	; 0x1a8
    5204:	eb01 03c5 	add.w	r3, r1, r5, lsl #3
    5208:	aa05      	add	r2, sp, #20
    520a:	ee20 7b09 	vmul.f64	d7, d0, d9
    520e:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    5212:	ed33 6b02 	vldmdb	r3!, {d6}
    5216:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    521a:	eea7 0b48 	vfms.f64	d0, d7, d8
    521e:	eefd 5bc0 	vcvt.s32.f64	s11, d0
    5222:	428b      	cmp	r3, r1
    5224:	ee15 0a90 	vmov	r0, s11
    5228:	ee37 0b06 	vadd.f64	d0, d7, d6
    522c:	f842 0f04 	str.w	r0, [r2, #4]!
    5230:	d1eb      	bne.n	520a <__kernel_rem_pio2+0xfa>
    5232:	4650      	mov	r0, sl
    5234:	f000 fca0 	bl	5b78 <scalbn>
    5238:	eeb0 ab40 	vmov.f64	d10, d0
    523c:	eeb4 0b00 	vmov.f64	d0, #64	; 0x3e000000  0.125
    5240:	ee2a 0b00 	vmul.f64	d0, d10, d0
    5244:	f000 fc08 	bl	5a58 <floor>
    5248:	eeb2 7b00 	vmov.f64	d7, #32	; 0x41000000  8.0
    524c:	eea0 ab47 	vfms.f64	d10, d0, d7
    5250:	eefd 7bca 	vcvt.s32.f64	s15, d10
    5254:	f1ba 0f00 	cmp.w	sl, #0
    5258:	ee17 ba90 	vmov	fp, s15
    525c:	eeb8 7be7 	vcvt.f64.s32	d7, s15
    5260:	ee3a ab47 	vsub.f64	d10, d10, d7
    5264:	f340 814c 	ble.w	5500 <__kernel_rem_pio2+0x3f0>
    5268:	f105 3eff 	add.w	lr, r5, #4294967295	; 0xffffffff
    526c:	ab06      	add	r3, sp, #24
    526e:	f1ca 0218 	rsb	r2, sl, #24
    5272:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
    5276:	fa43 f002 	asr.w	r0, r3, r2
    527a:	fa00 f202 	lsl.w	r2, r0, r2
    527e:	a906      	add	r1, sp, #24
    5280:	1a9b      	subs	r3, r3, r2
    5282:	f1ca 0217 	rsb	r2, sl, #23
    5286:	f841 302e 	str.w	r3, [r1, lr, lsl #2]
    528a:	4483      	add	fp, r0
    528c:	fa43 f102 	asr.w	r1, r3, r2
    5290:	2900      	cmp	r1, #0
    5292:	dd39      	ble.n	5308 <__kernel_rem_pio2+0x1f8>
    5294:	2d00      	cmp	r5, #0
    5296:	f10b 0b01 	add.w	fp, fp, #1
    529a:	f340 8224 	ble.w	56e6 <__kernel_rem_pio2+0x5d6>
    529e:	2200      	movs	r2, #0
    52a0:	4610      	mov	r0, r2
    52a2:	f10d 0e14 	add.w	lr, sp, #20
    52a6:	468c      	mov	ip, r1
    52a8:	e008      	b.n	52bc <__kernel_rem_pio2+0x1ac>
    52aa:	f1c3 7180 	rsb	r1, r3, #16777216	; 0x1000000
    52ae:	b113      	cbz	r3, 52b6 <__kernel_rem_pio2+0x1a6>
    52b0:	f8ce 1000 	str.w	r1, [lr]
    52b4:	2001      	movs	r0, #1
    52b6:	3201      	adds	r2, #1
    52b8:	4295      	cmp	r5, r2
    52ba:	dd0e      	ble.n	52da <__kernel_rem_pio2+0x1ca>
    52bc:	f85e 3f04 	ldr.w	r3, [lr, #4]!
    52c0:	2800      	cmp	r0, #0
    52c2:	d0f2      	beq.n	52aa <__kernel_rem_pio2+0x19a>
    52c4:	f1c3 13ff 	rsb	r3, r3, #16711935	; 0xff00ff
    52c8:	3201      	adds	r2, #1
    52ca:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    52ce:	4295      	cmp	r5, r2
    52d0:	f8ce 3000 	str.w	r3, [lr]
    52d4:	f04f 0001 	mov.w	r0, #1
    52d8:	dcf0      	bgt.n	52bc <__kernel_rem_pio2+0x1ac>
    52da:	4661      	mov	r1, ip
    52dc:	f1ba 0f00 	cmp.w	sl, #0
    52e0:	dd10      	ble.n	5304 <__kernel_rem_pio2+0x1f4>
    52e2:	f1ba 0f01 	cmp.w	sl, #1
    52e6:	f000 8112 	beq.w	550e <__kernel_rem_pio2+0x3fe>
    52ea:	f1ba 0f02 	cmp.w	sl, #2
    52ee:	d109      	bne.n	5304 <__kernel_rem_pio2+0x1f4>
    52f0:	1e6a      	subs	r2, r5, #1
    52f2:	ab06      	add	r3, sp, #24
    52f4:	f10d 0e18 	add.w	lr, sp, #24
    52f8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    52fc:	f3c3 0315 	ubfx	r3, r3, #0, #22
    5300:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    5304:	2902      	cmp	r1, #2
    5306:	d06f      	beq.n	53e8 <__kernel_rem_pio2+0x2d8>
    5308:	eeb5 ab40 	vcmp.f64	d10, #0.0
    530c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5310:	d17c      	bne.n	540c <__kernel_rem_pio2+0x2fc>
    5312:	f105 3eff 	add.w	lr, r5, #4294967295	; 0xffffffff
    5316:	4576      	cmp	r6, lr
    5318:	dc0f      	bgt.n	533a <__kernel_rem_pio2+0x22a>
    531a:	f105 4280 	add.w	r2, r5, #1073741824	; 0x40000000
    531e:	3a01      	subs	r2, #1
    5320:	ab06      	add	r3, sp, #24
    5322:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    5326:	2000      	movs	r0, #0
    5328:	f852 3904 	ldr.w	r3, [r2], #-4
    532c:	4542      	cmp	r2, r8
    532e:	ea40 0003 	orr.w	r0, r0, r3
    5332:	d1f9      	bne.n	5328 <__kernel_rem_pio2+0x218>
    5334:	2800      	cmp	r0, #0
    5336:	f040 8115 	bne.w	5564 <__kernel_rem_pio2+0x454>
    533a:	1e73      	subs	r3, r6, #1
    533c:	aa06      	add	r2, sp, #24
    533e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5342:	2b00      	cmp	r3, #0
    5344:	f040 81cc 	bne.w	56e0 <__kernel_rem_pio2+0x5d0>
    5348:	9b03      	ldr	r3, [sp, #12]
    534a:	f04f 0e01 	mov.w	lr, #1
    534e:	f853 2904 	ldr.w	r2, [r3], #-4
    5352:	f10e 0e01 	add.w	lr, lr, #1
    5356:	2a00      	cmp	r2, #0
    5358:	d0f9      	beq.n	534e <__kernel_rem_pio2+0x23e>
    535a:	44ae      	add	lr, r5
    535c:	1c6b      	adds	r3, r5, #1
    535e:	4573      	cmp	r3, lr
    5360:	dc2d      	bgt.n	53be <__kernel_rem_pio2+0x2ae>
    5362:	9a02      	ldr	r2, [sp, #8]
    5364:	1898      	adds	r0, r3, r2
    5366:	9a01      	ldr	r2, [sp, #4]
    5368:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    536c:	1951      	adds	r1, r2, r5
    536e:	eb0e 0c02 	add.w	ip, lr, r2
    5372:	9aa5      	ldr	r2, [sp, #660]	; 0x294
    5374:	3801      	subs	r0, #1
    5376:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    537a:	aa1a      	add	r2, sp, #104	; 0x68
    537c:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
    5380:	eb02 0ccc 	add.w	ip, r2, ip, lsl #3
    5384:	aa6a      	add	r2, sp, #424	; 0x1a8
    5386:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
    538a:	f850 3f04 	ldr.w	r3, [r0, #4]!
    538e:	ee07 3a10 	vmov	s14, r3
    5392:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    5396:	2f00      	cmp	r7, #0
    5398:	eca1 7b02 	vstmia	r1!, {d7}
    539c:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 53c8 <__kernel_rem_pio2+0x2b8>
    53a0:	db09      	blt.n	53b6 <__kernel_rem_pio2+0x2a6>
    53a2:	464b      	mov	r3, r9
    53a4:	460a      	mov	r2, r1
    53a6:	ecb3 5b02 	vldmia	r3!, {d5}
    53aa:	ed32 6b02 	vldmdb	r2!, {d6}
    53ae:	42a3      	cmp	r3, r4
    53b0:	eea5 7b06 	vfma.f64	d7, d5, d6
    53b4:	d1f7      	bne.n	53a6 <__kernel_rem_pio2+0x296>
    53b6:	4561      	cmp	r1, ip
    53b8:	eca5 7b02 	vstmia	r5!, {d7}
    53bc:	d1e5      	bne.n	538a <__kernel_rem_pio2+0x27a>
    53be:	4675      	mov	r5, lr
    53c0:	e718      	b.n	51f4 <__kernel_rem_pio2+0xe4>
    53c2:	bf00      	nop
    53c4:	f3af 8000 	nop.w
	...
    53d4:	3e700000 	.word	0x3e700000
    53d8:	00000000 	.word	0x00000000
    53dc:	41700000 	.word	0x41700000
    53e0:	20000a4c 	.word	0x20000a4c
    53e4:	2aaaaaab 	.word	0x2aaaaaab
    53e8:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    53ec:	ee30 ab4a 	vsub.f64	d10, d0, d10
    53f0:	2800      	cmp	r0, #0
    53f2:	d089      	beq.n	5308 <__kernel_rem_pio2+0x1f8>
    53f4:	4650      	mov	r0, sl
    53f6:	9105      	str	r1, [sp, #20]
    53f8:	f000 fbbe 	bl	5b78 <scalbn>
    53fc:	ee3a ab40 	vsub.f64	d10, d10, d0
    5400:	eeb5 ab40 	vcmp.f64	d10, #0.0
    5404:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5408:	9905      	ldr	r1, [sp, #20]
    540a:	d082      	beq.n	5312 <__kernel_rem_pio2+0x202>
    540c:	eeb0 0b4a 	vmov.f64	d0, d10
    5410:	f1ca 0000 	rsb	r0, sl, #0
    5414:	ee0b ba10 	vmov	s22, fp
    5418:	4689      	mov	r9, r1
    541a:	f8dd b010 	ldr.w	fp, [sp, #16]
    541e:	f000 fbab 	bl	5b78 <scalbn>
    5422:	ed9f 6bd1 	vldr	d6, [pc, #836]	; 5768 <__kernel_rem_pio2+0x658>
    5426:	eeb4 0bc6 	vcmpe.f64	d0, d6
    542a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    542e:	f2c0 8172 	blt.w	5716 <__kernel_rem_pio2+0x606>
    5432:	ed9f 7bcf 	vldr	d7, [pc, #828]	; 5770 <__kernel_rem_pio2+0x660>
    5436:	ee20 7b07 	vmul.f64	d7, d0, d7
    543a:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    543e:	a906      	add	r1, sp, #24
    5440:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
    5444:	eea5 0b46 	vfms.f64	d0, d5, d6
    5448:	eebd 0bc0 	vcvt.s32.f64	s0, d0
    544c:	1c6b      	adds	r3, r5, #1
    544e:	ee10 2a10 	vmov	r2, s0
    5452:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    5456:	ee17 2a10 	vmov	r2, s14
    545a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    545e:	f10a 0a18 	add.w	sl, sl, #24
    5462:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
    5466:	4650      	mov	r0, sl
    5468:	9301      	str	r3, [sp, #4]
    546a:	f000 fb85 	bl	5b78 <scalbn>
    546e:	9b01      	ldr	r3, [sp, #4]
    5470:	2b00      	cmp	r3, #0
    5472:	f2c0 815e 	blt.w	5732 <__kernel_rem_pio2+0x622>
    5476:	ac6a      	add	r4, sp, #424	; 0x1a8
    5478:	00df      	lsls	r7, r3, #3
    547a:	aa06      	add	r2, sp, #24
    547c:	ed9f 6bbc 	vldr	d6, [pc, #752]	; 5770 <__kernel_rem_pio2+0x660>
    5480:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    5484:	eb04 0c07 	add.w	ip, r4, r7
    5488:	3204      	adds	r2, #4
    548a:	f10c 0008 	add.w	r0, ip, #8
    548e:	ed32 7a01 	vldmdb	r2!, {s14}
    5492:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    5496:	ee27 7b00 	vmul.f64	d7, d7, d0
    549a:	ed20 7b02 	vstmdb	r0!, {d7}
    549e:	ee20 0b06 	vmul.f64	d0, d0, d6
    54a2:	42a0      	cmp	r0, r4
    54a4:	d1f3      	bne.n	548e <__kernel_rem_pio2+0x37e>
    54a6:	f50d 78d0 	add.w	r8, sp, #416	; 0x1a0
    54aa:	2500      	movs	r5, #0
    54ac:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    54b0:	2e00      	cmp	r6, #0
    54b2:	f2c0 8112 	blt.w	56da <__kernel_rem_pio2+0x5ca>
    54b6:	48b4      	ldr	r0, [pc, #720]	; (5788 <__kernel_rem_pio2+0x678>)
    54b8:	4661      	mov	r1, ip
    54ba:	ed9f 6baf 	vldr	d6, [pc, #700]	; 5778 <__kernel_rem_pio2+0x668>
    54be:	ed9f 7bb0 	vldr	d7, [pc, #704]	; 5780 <__kernel_rem_pio2+0x670>
    54c2:	2200      	movs	r2, #0
    54c4:	e003      	b.n	54ce <__kernel_rem_pio2+0x3be>
    54c6:	4295      	cmp	r5, r2
    54c8:	db08      	blt.n	54dc <__kernel_rem_pio2+0x3cc>
    54ca:	ecb0 6b02 	vldmia	r0!, {d6}
    54ce:	ecb1 5b02 	vldmia	r1!, {d5}
    54d2:	3201      	adds	r2, #1
    54d4:	4296      	cmp	r6, r2
    54d6:	eea5 7b06 	vfma.f64	d7, d5, d6
    54da:	daf4      	bge.n	54c6 <__kernel_rem_pio2+0x3b6>
    54dc:	f1ac 0c08 	sub.w	ip, ip, #8
    54e0:	eb0e 02c5 	add.w	r2, lr, r5, lsl #3
    54e4:	45c4      	cmp	ip, r8
    54e6:	ed82 7b00 	vstr	d7, [r2]
    54ea:	f105 0501 	add.w	r5, r5, #1
    54ee:	d1df      	bne.n	54b0 <__kernel_rem_pio2+0x3a0>
    54f0:	9aa4      	ldr	r2, [sp, #656]	; 0x290
    54f2:	2a03      	cmp	r2, #3
    54f4:	f200 80ad 	bhi.w	5652 <__kernel_rem_pio2+0x542>
    54f8:	e8df f002 	tbb	[pc, r2]
    54fc:	50b5b5dd 	.word	0x50b5b5dd
    5500:	d110      	bne.n	5524 <__kernel_rem_pio2+0x414>
    5502:	1e6b      	subs	r3, r5, #1
    5504:	aa06      	add	r2, sp, #24
    5506:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    550a:	15c9      	asrs	r1, r1, #23
    550c:	e6c0      	b.n	5290 <__kernel_rem_pio2+0x180>
    550e:	1e6a      	subs	r2, r5, #1
    5510:	ab06      	add	r3, sp, #24
    5512:	f10d 0e18 	add.w	lr, sp, #24
    5516:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    551a:	f3c3 0316 	ubfx	r3, r3, #0, #23
    551e:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    5522:	e6ef      	b.n	5304 <__kernel_rem_pio2+0x1f4>
    5524:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    5528:	eeb4 abc7 	vcmpe.f64	d10, d7
    552c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5530:	da0b      	bge.n	554a <__kernel_rem_pio2+0x43a>
    5532:	2100      	movs	r1, #0
    5534:	e6e8      	b.n	5308 <__kernel_rem_pio2+0x1f8>
    5536:	ed9f 7b92 	vldr	d7, [pc, #584]	; 5780 <__kernel_rem_pio2+0x670>
    553a:	eca0 7b02 	vstmia	r0!, {d7}
    553e:	4570      	cmp	r0, lr
    5540:	f105 0501 	add.w	r5, r5, #1
    5544:	f47f ae2c 	bne.w	51a0 <__kernel_rem_pio2+0x90>
    5548:	e642      	b.n	51d0 <__kernel_rem_pio2+0xc0>
    554a:	2d00      	cmp	r5, #0
    554c:	f10b 0b01 	add.w	fp, fp, #1
    5550:	bfc8      	it	gt
    5552:	2102      	movgt	r1, #2
    5554:	f73f aea3 	bgt.w	529e <__kernel_rem_pio2+0x18e>
    5558:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    555c:	2102      	movs	r1, #2
    555e:	ee37 ab4a 	vsub.f64	d10, d7, d10
    5562:	e6d1      	b.n	5308 <__kernel_rem_pio2+0x1f8>
    5564:	aa06      	add	r2, sp, #24
    5566:	ee0b ba10 	vmov	s22, fp
    556a:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
    556e:	f8dd b010 	ldr.w	fp, [sp, #16]
    5572:	4673      	mov	r3, lr
    5574:	4689      	mov	r9, r1
    5576:	f1aa 0a18 	sub.w	sl, sl, #24
    557a:	2a00      	cmp	r2, #0
    557c:	f47f af71 	bne.w	5462 <__kernel_rem_pio2+0x352>
    5580:	f10e 4280 	add.w	r2, lr, #1073741824	; 0x40000000
    5584:	3a01      	subs	r2, #1
    5586:	a906      	add	r1, sp, #24
    5588:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    558c:	f852 1904 	ldr.w	r1, [r2], #-4
    5590:	3b01      	subs	r3, #1
    5592:	f1aa 0a18 	sub.w	sl, sl, #24
    5596:	2900      	cmp	r1, #0
    5598:	d0f8      	beq.n	558c <__kernel_rem_pio2+0x47c>
    559a:	e762      	b.n	5462 <__kernel_rem_pio2+0x352>
    559c:	2b00      	cmp	r3, #0
    559e:	f340 80c5 	ble.w	572c <__kernel_rem_pio2+0x61c>
    55a2:	f103 5200 	add.w	r2, r3, #536870912	; 0x20000000
    55a6:	3a01      	subs	r2, #1
    55a8:	eb0e 0407 	add.w	r4, lr, r7
    55ac:	00d0      	lsls	r0, r2, #3
    55ae:	ed94 7b00 	vldr	d7, [r4]
    55b2:	f100 0408 	add.w	r4, r0, #8
    55b6:	3010      	adds	r0, #16
    55b8:	4474      	add	r4, lr
    55ba:	4470      	add	r0, lr
    55bc:	ad44      	add	r5, sp, #272	; 0x110
    55be:	ed34 6b02 	vldmdb	r4!, {d6}
    55c2:	ee36 5b07 	vadd.f64	d5, d6, d7
    55c6:	ee36 6b45 	vsub.f64	d6, d6, d5
    55ca:	ee36 7b07 	vadd.f64	d7, d6, d7
    55ce:	ed20 7b02 	vstmdb	r0!, {d7}
    55d2:	eeb0 7b45 	vmov.f64	d7, d5
    55d6:	42a8      	cmp	r0, r5
    55d8:	ed84 5b00 	vstr	d5, [r4]
    55dc:	d1ef      	bne.n	55be <__kernel_rem_pio2+0x4ae>
    55de:	2b01      	cmp	r3, #1
    55e0:	f340 80a4 	ble.w	572c <__kernel_rem_pio2+0x61c>
    55e4:	00d2      	lsls	r2, r2, #3
    55e6:	4477      	add	r7, lr
    55e8:	f102 0010 	add.w	r0, r2, #16
    55ec:	ed97 7b00 	vldr	d7, [r7]
    55f0:	3208      	adds	r2, #8
    55f2:	4470      	add	r0, lr
    55f4:	eb0e 0302 	add.w	r3, lr, r2
    55f8:	ac46      	add	r4, sp, #280	; 0x118
    55fa:	4602      	mov	r2, r0
    55fc:	ed33 6b02 	vldmdb	r3!, {d6}
    5600:	ee37 5b06 	vadd.f64	d5, d7, d6
    5604:	ee36 6b45 	vsub.f64	d6, d6, d5
    5608:	ee36 7b07 	vadd.f64	d7, d6, d7
    560c:	ed22 7b02 	vstmdb	r2!, {d7}
    5610:	eeb0 7b45 	vmov.f64	d7, d5
    5614:	4294      	cmp	r4, r2
    5616:	ed83 5b00 	vstr	d5, [r3]
    561a:	d1ef      	bne.n	55fc <__kernel_rem_pio2+0x4ec>
    561c:	ed9f 7b58 	vldr	d7, [pc, #352]	; 5780 <__kernel_rem_pio2+0x670>
    5620:	ed30 6b02 	vldmdb	r0!, {d6}
    5624:	4284      	cmp	r4, r0
    5626:	ee37 7b06 	vadd.f64	d7, d7, d6
    562a:	d1f9      	bne.n	5620 <__kernel_rem_pio2+0x510>
    562c:	464b      	mov	r3, r9
    562e:	2b00      	cmp	r3, #0
    5630:	d066      	beq.n	5700 <__kernel_rem_pio2+0x5f0>
    5632:	eeb1 7b47 	vneg.f64	d7, d7
    5636:	ed9e 5b00 	vldr	d5, [lr]
    563a:	ed9e 6b02 	vldr	d6, [lr, #8]
    563e:	eeb1 5b45 	vneg.f64	d5, d5
    5642:	ed8b 5b00 	vstr	d5, [fp]
    5646:	ed8b 7b04 	vstr	d7, [fp, #16]
    564a:	eeb1 7b46 	vneg.f64	d7, d6
    564e:	ed8b 7b02 	vstr	d7, [fp, #8]
    5652:	ee1b 3a10 	vmov	r3, s22
    5656:	f003 0007 	and.w	r0, r3, #7
    565a:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
    565e:	ecbd 8b08 	vpop	{d8-d11}
    5662:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5666:	ed9f 7b46 	vldr	d7, [pc, #280]	; 5780 <__kernel_rem_pio2+0x670>
    566a:	f107 0208 	add.w	r2, r7, #8
    566e:	4472      	add	r2, lr
    5670:	ed32 6b02 	vldmdb	r2!, {d6}
    5674:	4572      	cmp	r2, lr
    5676:	ee37 7b06 	vadd.f64	d7, d7, d6
    567a:	d1f9      	bne.n	5670 <__kernel_rem_pio2+0x560>
    567c:	464a      	mov	r2, r9
    567e:	b3a2      	cbz	r2, 56ea <__kernel_rem_pio2+0x5da>
    5680:	eeb1 5b47 	vneg.f64	d5, d7
    5684:	ed9e 6b00 	vldr	d6, [lr]
    5688:	2b00      	cmp	r3, #0
    568a:	ed8b 5b00 	vstr	d5, [fp]
    568e:	ee36 7b47 	vsub.f64	d7, d6, d7
    5692:	dd0b      	ble.n	56ac <__kernel_rem_pio2+0x59c>
    5694:	a844      	add	r0, sp, #272	; 0x110
    5696:	2201      	movs	r2, #1
    5698:	ecb0 6b02 	vldmia	r0!, {d6}
    569c:	3201      	adds	r2, #1
    569e:	4293      	cmp	r3, r2
    56a0:	ee37 7b06 	vadd.f64	d7, d7, d6
    56a4:	daf8      	bge.n	5698 <__kernel_rem_pio2+0x588>
    56a6:	464b      	mov	r3, r9
    56a8:	2b00      	cmp	r3, #0
    56aa:	d0d0      	beq.n	564e <__kernel_rem_pio2+0x53e>
    56ac:	eeb1 7b47 	vneg.f64	d7, d7
    56b0:	ed8b 7b02 	vstr	d7, [fp, #8]
    56b4:	e7cd      	b.n	5652 <__kernel_rem_pio2+0x542>
    56b6:	ed9f 7b32 	vldr	d7, [pc, #200]	; 5780 <__kernel_rem_pio2+0x670>
    56ba:	3708      	adds	r7, #8
    56bc:	44be      	add	lr, r7
    56be:	ed3e 6b02 	vldmdb	lr!, {d6}
    56c2:	3b01      	subs	r3, #1
    56c4:	1c5a      	adds	r2, r3, #1
    56c6:	ee37 7b06 	vadd.f64	d7, d7, d6
    56ca:	d1f8      	bne.n	56be <__kernel_rem_pio2+0x5ae>
    56cc:	464b      	mov	r3, r9
    56ce:	b10b      	cbz	r3, 56d4 <__kernel_rem_pio2+0x5c4>
    56d0:	eeb1 7b47 	vneg.f64	d7, d7
    56d4:	ed8b 7b00 	vstr	d7, [fp]
    56d8:	e7bb      	b.n	5652 <__kernel_rem_pio2+0x542>
    56da:	ed9f 7b29 	vldr	d7, [pc, #164]	; 5780 <__kernel_rem_pio2+0x670>
    56de:	e6fd      	b.n	54dc <__kernel_rem_pio2+0x3cc>
    56e0:	f04f 0e01 	mov.w	lr, #1
    56e4:	e639      	b.n	535a <__kernel_rem_pio2+0x24a>
    56e6:	2000      	movs	r0, #0
    56e8:	e5f8      	b.n	52dc <__kernel_rem_pio2+0x1cc>
    56ea:	ed9e 6b00 	vldr	d6, [lr]
    56ee:	2b00      	cmp	r3, #0
    56f0:	ed8b 7b00 	vstr	d7, [fp]
    56f4:	ee36 7b47 	vsub.f64	d7, d6, d7
    56f8:	dccc      	bgt.n	5694 <__kernel_rem_pio2+0x584>
    56fa:	ed8b 7b02 	vstr	d7, [fp, #8]
    56fe:	e7a8      	b.n	5652 <__kernel_rem_pio2+0x542>
    5700:	e9de 0100 	ldrd	r0, r1, [lr]
    5704:	e9de 2302 	ldrd	r2, r3, [lr, #8]
    5708:	ed8b 7b04 	vstr	d7, [fp, #16]
    570c:	e9cb 0100 	strd	r0, r1, [fp]
    5710:	e9cb 2302 	strd	r2, r3, [fp, #8]
    5714:	e79d      	b.n	5652 <__kernel_rem_pio2+0x542>
    5716:	eebd 0bc0 	vcvt.s32.f64	s0, d0
    571a:	a906      	add	r1, sp, #24
    571c:	ee10 2a10 	vmov	r2, s0
    5720:	462b      	mov	r3, r5
    5722:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    5726:	e69c      	b.n	5462 <__kernel_rem_pio2+0x352>
    5728:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    572c:	ed9f 7b14 	vldr	d7, [pc, #80]	; 5780 <__kernel_rem_pio2+0x670>
    5730:	e77c      	b.n	562c <__kernel_rem_pio2+0x51c>
    5732:	9aa4      	ldr	r2, [sp, #656]	; 0x290
    5734:	2a03      	cmp	r2, #3
    5736:	d88c      	bhi.n	5652 <__kernel_rem_pio2+0x542>
    5738:	a101      	add	r1, pc, #4	; (adr r1, 5740 <__kernel_rem_pio2+0x630>)
    573a:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    573e:	bf00      	nop
    5740:	00005761 	.word	0x00005761
    5744:	00005757 	.word	0x00005757
    5748:	00005757 	.word	0x00005757
    574c:	00005729 	.word	0x00005729
    5750:	9b01      	ldr	r3, [sp, #4]
    5752:	00dc      	lsls	r4, r3, #3
    5754:	e53c      	b.n	51d0 <__kernel_rem_pio2+0xc0>
    5756:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 5780 <__kernel_rem_pio2+0x670>
    575a:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
    575e:	e78d      	b.n	567c <__kernel_rem_pio2+0x56c>
    5760:	ed9f 7b07 	vldr	d7, [pc, #28]	; 5780 <__kernel_rem_pio2+0x670>
    5764:	e7b2      	b.n	56cc <__kernel_rem_pio2+0x5bc>
    5766:	bf00      	nop
    5768:	00000000 	.word	0x00000000
    576c:	41700000 	.word	0x41700000
    5770:	00000000 	.word	0x00000000
    5774:	3e700000 	.word	0x3e700000
    5778:	40000000 	.word	0x40000000
    577c:	3ff921fb 	.word	0x3ff921fb
	...
    5788:	20000288 	.word	0x20000288
    578c:	00000000 	.word	0x00000000

00005790 <__kernel_sin>:
    5790:	ee10 3a90 	vmov	r3, s1
    5794:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5798:	f1b3 5f79 	cmp.w	r3, #1044381696	; 0x3e400000
    579c:	da04      	bge.n	57a8 <__kernel_sin+0x18>
    579e:	eefd 7bc0 	vcvt.s32.f64	s15, d0
    57a2:	ee17 3a90 	vmov	r3, s15
    57a6:	b323      	cbz	r3, 57f2 <__kernel_sin+0x62>
    57a8:	ee20 7b00 	vmul.f64	d7, d0, d0
    57ac:	ee20 4b07 	vmul.f64	d4, d0, d7
    57b0:	ed9f 5b15 	vldr	d5, [pc, #84]	; 5808 <__kernel_sin+0x78>
    57b4:	ed9f 6b16 	vldr	d6, [pc, #88]	; 5810 <__kernel_sin+0x80>
    57b8:	ed9f 3b17 	vldr	d3, [pc, #92]	; 5818 <__kernel_sin+0x88>
    57bc:	eea7 6b05 	vfma.f64	d6, d7, d5
    57c0:	ed9f 5b17 	vldr	d5, [pc, #92]	; 5820 <__kernel_sin+0x90>
    57c4:	eea7 3b06 	vfma.f64	d3, d7, d6
    57c8:	ed9f 6b17 	vldr	d6, [pc, #92]	; 5828 <__kernel_sin+0x98>
    57cc:	eea7 5b03 	vfma.f64	d5, d7, d3
    57d0:	eea7 6b05 	vfma.f64	d6, d7, d5
    57d4:	b170      	cbz	r0, 57f4 <__kernel_sin+0x64>
    57d6:	ee26 6b44 	vnmul.f64	d6, d6, d4
    57da:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    57de:	ed9f 5b14 	vldr	d5, [pc, #80]	; 5830 <__kernel_sin+0xa0>
    57e2:	eea1 6b03 	vfma.f64	d6, d1, d3
    57e6:	ee97 1b06 	vfnms.f64	d1, d7, d6
    57ea:	eea4 1b05 	vfma.f64	d1, d4, d5
    57ee:	ee30 0b41 	vsub.f64	d0, d0, d1
    57f2:	4770      	bx	lr
    57f4:	ed9f 5b10 	vldr	d5, [pc, #64]	; 5838 <__kernel_sin+0xa8>
    57f8:	eea7 5b06 	vfma.f64	d5, d7, d6
    57fc:	eea4 0b05 	vfma.f64	d0, d4, d5
    5800:	4770      	bx	lr
    5802:	bf00      	nop
    5804:	f3af 8000 	nop.w
    5808:	5acfd57c 	.word	0x5acfd57c
    580c:	3de5d93a 	.word	0x3de5d93a
    5810:	8a2b9ceb 	.word	0x8a2b9ceb
    5814:	be5ae5e6 	.word	0xbe5ae5e6
    5818:	57b1fe7d 	.word	0x57b1fe7d
    581c:	3ec71de3 	.word	0x3ec71de3
    5820:	19c161d5 	.word	0x19c161d5
    5824:	bf2a01a0 	.word	0xbf2a01a0
    5828:	1110f8a6 	.word	0x1110f8a6
    582c:	3f811111 	.word	0x3f811111
    5830:	55555549 	.word	0x55555549
    5834:	3fc55555 	.word	0x3fc55555
    5838:	55555549 	.word	0x55555549
    583c:	bfc55555 	.word	0xbfc55555

00005840 <atan>:
    5840:	b538      	push	{r3, r4, r5, lr}
    5842:	eeb0 7b40 	vmov.f64	d7, d0
    5846:	ee17 5a90 	vmov	r5, s15
    584a:	4b77      	ldr	r3, [pc, #476]	; (5a28 <atan+0x1e8>)
    584c:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
    5850:	429c      	cmp	r4, r3
    5852:	dd0e      	ble.n	5872 <atan+0x32>
    5854:	4b75      	ldr	r3, [pc, #468]	; (5a2c <atan+0x1ec>)
    5856:	429c      	cmp	r4, r3
    5858:	ee10 2a10 	vmov	r2, s0
    585c:	dc5c      	bgt.n	5918 <atan+0xd8>
    585e:	d059      	beq.n	5914 <atan+0xd4>
    5860:	ed9f 7b55 	vldr	d7, [pc, #340]	; 59b8 <atan+0x178>
    5864:	ed9f 0b56 	vldr	d0, [pc, #344]	; 59c0 <atan+0x180>
    5868:	2d00      	cmp	r5, #0
    586a:	bfc8      	it	gt
    586c:	eeb0 0b47 	vmovgt.f64	d0, d7
    5870:	bd38      	pop	{r3, r4, r5, pc}
    5872:	4b6f      	ldr	r3, [pc, #444]	; (5a30 <atan+0x1f0>)
    5874:	429c      	cmp	r4, r3
    5876:	dc60      	bgt.n	593a <atan+0xfa>
    5878:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
    587c:	429c      	cmp	r4, r3
    587e:	dd4e      	ble.n	591e <atan+0xde>
    5880:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    5884:	ed9f 2b50 	vldr	d2, [pc, #320]	; 59c8 <atan+0x188>
    5888:	ee27 4b07 	vmul.f64	d4, d7, d7
    588c:	ee24 6b04 	vmul.f64	d6, d4, d4
    5890:	ed9f 3b4f 	vldr	d3, [pc, #316]	; 59d0 <atan+0x190>
    5894:	ed9f 5b50 	vldr	d5, [pc, #320]	; 59d8 <atan+0x198>
    5898:	eea6 3b02 	vfma.f64	d3, d6, d2
    589c:	ed9f 2b50 	vldr	d2, [pc, #320]	; 59e0 <atan+0x1a0>
    58a0:	eea6 5b03 	vfma.f64	d5, d6, d3
    58a4:	ed9f 3b50 	vldr	d3, [pc, #320]	; 59e8 <atan+0x1a8>
    58a8:	eea6 2b05 	vfma.f64	d2, d6, d5
    58ac:	ed9f 5b50 	vldr	d5, [pc, #320]	; 59f0 <atan+0x1b0>
    58b0:	eea6 3b02 	vfma.f64	d3, d6, d2
    58b4:	ed9f 1b50 	vldr	d1, [pc, #320]	; 59f8 <atan+0x1b8>
    58b8:	eea6 5b03 	vfma.f64	d5, d6, d3
    58bc:	ee25 5b04 	vmul.f64	d5, d5, d4
    58c0:	ed9f 2b4f 	vldr	d2, [pc, #316]	; 5a00 <atan+0x1c0>
    58c4:	ed9f 4b50 	vldr	d4, [pc, #320]	; 5a08 <atan+0x1c8>
    58c8:	ed9f 3b51 	vldr	d3, [pc, #324]	; 5a10 <atan+0x1d0>
    58cc:	eea6 4b01 	vfma.f64	d4, d6, d1
    58d0:	eea6 2b04 	vfma.f64	d2, d6, d4
    58d4:	ed9f 4b50 	vldr	d4, [pc, #320]	; 5a18 <atan+0x1d8>
    58d8:	eea6 3b02 	vfma.f64	d3, d6, d2
    58dc:	1c5a      	adds	r2, r3, #1
    58de:	eea6 4b03 	vfma.f64	d4, d6, d3
    58e2:	ee24 6b06 	vmul.f64	d6, d4, d6
    58e6:	d040      	beq.n	596a <atan+0x12a>
    58e8:	ee35 5b06 	vadd.f64	d5, d5, d6
    58ec:	4a51      	ldr	r2, [pc, #324]	; (5a34 <atan+0x1f4>)
    58ee:	4952      	ldr	r1, [pc, #328]	; (5a38 <atan+0x1f8>)
    58f0:	00db      	lsls	r3, r3, #3
    58f2:	441a      	add	r2, r3
    58f4:	440b      	add	r3, r1
    58f6:	ed92 6b00 	vldr	d6, [r2]
    58fa:	ed93 0b00 	vldr	d0, [r3]
    58fe:	ee97 6b05 	vfnms.f64	d6, d7, d5
    5902:	ee36 7b47 	vsub.f64	d7, d6, d7
    5906:	2d00      	cmp	r5, #0
    5908:	ee30 7b47 	vsub.f64	d7, d0, d7
    590c:	db2a      	blt.n	5964 <atan+0x124>
    590e:	eeb0 0b47 	vmov.f64	d0, d7
    5912:	bd38      	pop	{r3, r4, r5, pc}
    5914:	2a00      	cmp	r2, #0
    5916:	d0a3      	beq.n	5860 <atan+0x20>
    5918:	ee37 0b07 	vadd.f64	d0, d7, d7
    591c:	bd38      	pop	{r3, r4, r5, pc}
    591e:	ed9f 6b40 	vldr	d6, [pc, #256]	; 5a20 <atan+0x1e0>
    5922:	eeb7 5b00 	vmov.f64	d5, #112	; 0x3f800000  1.0
    5926:	ee30 6b06 	vadd.f64	d6, d0, d6
    592a:	eeb4 6bc5 	vcmpe.f64	d6, d5
    592e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5932:	dda5      	ble.n	5880 <atan+0x40>
    5934:	eeb0 0b47 	vmov.f64	d0, d7
    5938:	bd38      	pop	{r3, r4, r5, pc}
    593a:	f000 f883 	bl	5a44 <fabs>
    593e:	4b3f      	ldr	r3, [pc, #252]	; (5a3c <atan+0x1fc>)
    5940:	429c      	cmp	r4, r3
    5942:	dc19      	bgt.n	5978 <atan+0x138>
    5944:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
    5948:	429c      	cmp	r4, r3
    594a:	dc2a      	bgt.n	59a2 <atan+0x162>
    594c:	eeb0 7b00 	vmov.f64	d7, #0	; 0x40000000  2.0
    5950:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
    5954:	ee30 5b07 	vadd.f64	d5, d0, d7
    5958:	eea0 6b07 	vfma.f64	d6, d0, d7
    595c:	2300      	movs	r3, #0
    595e:	ee86 7b05 	vdiv.f64	d7, d6, d5
    5962:	e78f      	b.n	5884 <atan+0x44>
    5964:	eeb1 0b47 	vneg.f64	d0, d7
    5968:	bd38      	pop	{r3, r4, r5, pc}
    596a:	ee35 6b06 	vadd.f64	d6, d5, d6
    596e:	eea7 7b46 	vfms.f64	d7, d7, d6
    5972:	eeb0 0b47 	vmov.f64	d0, d7
    5976:	bd38      	pop	{r3, r4, r5, pc}
    5978:	4b31      	ldr	r3, [pc, #196]	; (5a40 <atan+0x200>)
    597a:	429c      	cmp	r4, r3
    597c:	dc0b      	bgt.n	5996 <atan+0x156>
    597e:	eeb7 7b08 	vmov.f64	d7, #120	; 0x3fc00000  1.5
    5982:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    5986:	ee30 5b47 	vsub.f64	d5, d0, d7
    598a:	eea0 6b07 	vfma.f64	d6, d0, d7
    598e:	2302      	movs	r3, #2
    5990:	ee85 7b06 	vdiv.f64	d7, d5, d6
    5994:	e776      	b.n	5884 <atan+0x44>
    5996:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
    599a:	2303      	movs	r3, #3
    599c:	ee86 7b00 	vdiv.f64	d7, d6, d0
    59a0:	e770      	b.n	5884 <atan+0x44>
    59a2:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    59a6:	2301      	movs	r3, #1
    59a8:	ee30 6b47 	vsub.f64	d6, d0, d7
    59ac:	ee30 0b07 	vadd.f64	d0, d0, d7
    59b0:	ee86 7b00 	vdiv.f64	d7, d6, d0
    59b4:	e766      	b.n	5884 <atan+0x44>
    59b6:	bf00      	nop
    59b8:	54442d18 	.word	0x54442d18
    59bc:	3ff921fb 	.word	0x3ff921fb
    59c0:	54442d18 	.word	0x54442d18
    59c4:	bff921fb 	.word	0xbff921fb
    59c8:	e322da11 	.word	0xe322da11
    59cc:	3f90ad3a 	.word	0x3f90ad3a
    59d0:	24760deb 	.word	0x24760deb
    59d4:	3fa97b4b 	.word	0x3fa97b4b
    59d8:	a0d03d51 	.word	0xa0d03d51
    59dc:	3fb10d66 	.word	0x3fb10d66
    59e0:	c54c206e 	.word	0xc54c206e
    59e4:	3fb745cd 	.word	0x3fb745cd
    59e8:	920083ff 	.word	0x920083ff
    59ec:	3fc24924 	.word	0x3fc24924
    59f0:	5555550d 	.word	0x5555550d
    59f4:	3fd55555 	.word	0x3fd55555
    59f8:	2c6a6c2f 	.word	0x2c6a6c2f
    59fc:	bfa2b444 	.word	0xbfa2b444
    5a00:	af749a6d 	.word	0xaf749a6d
    5a04:	bfb3b0f2 	.word	0xbfb3b0f2
    5a08:	52defd9a 	.word	0x52defd9a
    5a0c:	bfadde2d 	.word	0xbfadde2d
    5a10:	fe231671 	.word	0xfe231671
    5a14:	bfbc71c6 	.word	0xbfbc71c6
    5a18:	9998ebc4 	.word	0x9998ebc4
    5a1c:	bfc99999 	.word	0xbfc99999
    5a20:	8800759c 	.word	0x8800759c
    5a24:	7e37e43c 	.word	0x7e37e43c
    5a28:	440fffff 	.word	0x440fffff
    5a2c:	7ff00000 	.word	0x7ff00000
    5a30:	3fdbffff 	.word	0x3fdbffff
    5a34:	200003d0 	.word	0x200003d0
    5a38:	200003b0 	.word	0x200003b0
    5a3c:	3ff2ffff 	.word	0x3ff2ffff
    5a40:	40037fff 	.word	0x40037fff

00005a44 <fabs>:
    5a44:	ec53 2b10 	vmov	r2, r3, d0
    5a48:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5a4c:	ec43 2b10 	vmov	d0, r2, r3
    5a50:	4770      	bx	lr
    5a52:	bf00      	nop
    5a54:	0000      	movs	r0, r0
	...

00005a58 <floor>:
    5a58:	b470      	push	{r4, r5, r6}
    5a5a:	b083      	sub	sp, #12
    5a5c:	ed8d 0b00 	vstr	d0, [sp]
    5a60:	9901      	ldr	r1, [sp, #4]
    5a62:	9c00      	ldr	r4, [sp, #0]
    5a64:	f3c1 520a 	ubfx	r2, r1, #20, #11
    5a68:	f2a2 33ff 	subw	r3, r2, #1023	; 0x3ff
    5a6c:	2b13      	cmp	r3, #19
    5a6e:	460d      	mov	r5, r1
    5a70:	4620      	mov	r0, r4
    5a72:	dc1e      	bgt.n	5ab2 <floor+0x5a>
    5a74:	2b00      	cmp	r3, #0
    5a76:	db43      	blt.n	5b00 <floor+0xa8>
    5a78:	4a3b      	ldr	r2, [pc, #236]	; (5b68 <floor+0x110>)
    5a7a:	411a      	asrs	r2, r3
    5a7c:	ea01 0602 	and.w	r6, r1, r2
    5a80:	4334      	orrs	r4, r6
    5a82:	d01b      	beq.n	5abc <floor+0x64>
    5a84:	ed9f 7b36 	vldr	d7, [pc, #216]	; 5b60 <floor+0x108>
    5a88:	ed9d 6b00 	vldr	d6, [sp]
    5a8c:	ee36 7b07 	vadd.f64	d7, d6, d7
    5a90:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    5a94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5a98:	dd04      	ble.n	5aa4 <floor+0x4c>
    5a9a:	2900      	cmp	r1, #0
    5a9c:	db43      	blt.n	5b26 <floor+0xce>
    5a9e:	ea25 0102 	bic.w	r1, r5, r2
    5aa2:	2000      	movs	r0, #0
    5aa4:	460b      	mov	r3, r1
    5aa6:	4602      	mov	r2, r0
    5aa8:	ec43 2b10 	vmov	d0, r2, r3
    5aac:	b003      	add	sp, #12
    5aae:	bc70      	pop	{r4, r5, r6}
    5ab0:	4770      	bx	lr
    5ab2:	2b33      	cmp	r3, #51	; 0x33
    5ab4:	dd07      	ble.n	5ac6 <floor+0x6e>
    5ab6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    5aba:	d02f      	beq.n	5b1c <floor+0xc4>
    5abc:	ed9d 0b00 	vldr	d0, [sp]
    5ac0:	b003      	add	sp, #12
    5ac2:	bc70      	pop	{r4, r5, r6}
    5ac4:	4770      	bx	lr
    5ac6:	f2a2 4213 	subw	r2, r2, #1043	; 0x413
    5aca:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    5ace:	fa24 f202 	lsr.w	r2, r4, r2
    5ad2:	4210      	tst	r0, r2
    5ad4:	d0f2      	beq.n	5abc <floor+0x64>
    5ad6:	ed9f 7b22 	vldr	d7, [pc, #136]	; 5b60 <floor+0x108>
    5ada:	ed9d 6b00 	vldr	d6, [sp]
    5ade:	ee36 7b07 	vadd.f64	d7, d6, d7
    5ae2:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    5ae6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5aea:	dddb      	ble.n	5aa4 <floor+0x4c>
    5aec:	2900      	cmp	r1, #0
    5aee:	db20      	blt.n	5b32 <floor+0xda>
    5af0:	4629      	mov	r1, r5
    5af2:	ea20 0002 	bic.w	r0, r0, r2
    5af6:	460b      	mov	r3, r1
    5af8:	4602      	mov	r2, r0
    5afa:	ec43 2b10 	vmov	d0, r2, r3
    5afe:	e7d5      	b.n	5aac <floor+0x54>
    5b00:	ed9f 7b17 	vldr	d7, [pc, #92]	; 5b60 <floor+0x108>
    5b04:	ee30 7b07 	vadd.f64	d7, d0, d7
    5b08:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    5b0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5b10:	ddc8      	ble.n	5aa4 <floor+0x4c>
    5b12:	2900      	cmp	r1, #0
    5b14:	db18      	blt.n	5b48 <floor+0xf0>
    5b16:	2000      	movs	r0, #0
    5b18:	4601      	mov	r1, r0
    5b1a:	e7c3      	b.n	5aa4 <floor+0x4c>
    5b1c:	ed9d 7b00 	vldr	d7, [sp]
    5b20:	ee37 0b07 	vadd.f64	d0, d7, d7
    5b24:	e7cc      	b.n	5ac0 <floor+0x68>
    5b26:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    5b2a:	fa41 f303 	asr.w	r3, r1, r3
    5b2e:	441d      	add	r5, r3
    5b30:	e7b5      	b.n	5a9e <floor+0x46>
    5b32:	2b14      	cmp	r3, #20
    5b34:	d010      	beq.n	5b58 <floor+0x100>
    5b36:	2101      	movs	r1, #1
    5b38:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
    5b3c:	fa01 f303 	lsl.w	r3, r1, r3
    5b40:	1818      	adds	r0, r3, r0
    5b42:	bf28      	it	cs
    5b44:	186d      	addcs	r5, r5, r1
    5b46:	e7d3      	b.n	5af0 <floor+0x98>
    5b48:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
    5b4c:	4b07      	ldr	r3, [pc, #28]	; (5b6c <floor+0x114>)
    5b4e:	4322      	orrs	r2, r4
    5b50:	bf18      	it	ne
    5b52:	4619      	movne	r1, r3
    5b54:	2000      	movs	r0, #0
    5b56:	e7a5      	b.n	5aa4 <floor+0x4c>
    5b58:	3501      	adds	r5, #1
    5b5a:	e7c9      	b.n	5af0 <floor+0x98>
    5b5c:	f3af 8000 	nop.w
    5b60:	8800759c 	.word	0x8800759c
    5b64:	7e37e43c 	.word	0x7e37e43c
    5b68:	000fffff 	.word	0x000fffff
    5b6c:	bff00000 	.word	0xbff00000

00005b70 <matherr>:
    5b70:	2000      	movs	r0, #0
    5b72:	4770      	bx	lr
    5b74:	0000      	movs	r0, r0
	...

00005b78 <scalbn>:
    5b78:	b510      	push	{r4, lr}
    5b7a:	ed2d 8b02 	vpush	{d8}
    5b7e:	b082      	sub	sp, #8
    5b80:	ed8d 0b00 	vstr	d0, [sp]
    5b84:	9b01      	ldr	r3, [sp, #4]
    5b86:	9900      	ldr	r1, [sp, #0]
    5b88:	f3c3 520a 	ubfx	r2, r3, #20, #11
    5b8c:	bb2a      	cbnz	r2, 5bda <scalbn+0x62>
    5b8e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5b92:	430b      	orrs	r3, r1
    5b94:	d02d      	beq.n	5bf2 <scalbn+0x7a>
    5b96:	ed9f 7b36 	vldr	d7, [pc, #216]	; 5c70 <scalbn+0xf8>
    5b9a:	4a3d      	ldr	r2, [pc, #244]	; (5c90 <scalbn+0x118>)
    5b9c:	ee20 7b07 	vmul.f64	d7, d0, d7
    5ba0:	4290      	cmp	r0, r2
    5ba2:	ed8d 7b00 	vstr	d7, [sp]
    5ba6:	9b01      	ldr	r3, [sp, #4]
    5ba8:	db29      	blt.n	5bfe <scalbn+0x86>
    5baa:	f3c3 520a 	ubfx	r2, r3, #20, #11
    5bae:	3a36      	subs	r2, #54	; 0x36
    5bb0:	1884      	adds	r4, r0, r2
    5bb2:	f240 72fe 	movw	r2, #2046	; 0x7fe
    5bb6:	4294      	cmp	r4, r2
    5bb8:	dc30      	bgt.n	5c1c <scalbn+0xa4>
    5bba:	2c00      	cmp	r4, #0
    5bbc:	dd27      	ble.n	5c0e <scalbn+0x96>
    5bbe:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
    5bc2:	e9dd 2300 	ldrd	r2, r3, [sp]
    5bc6:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    5bca:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    5bce:	ec43 2b10 	vmov	d0, r2, r3
    5bd2:	b002      	add	sp, #8
    5bd4:	ecbd 8b02 	vpop	{d8}
    5bd8:	bd10      	pop	{r4, pc}
    5bda:	f240 71ff 	movw	r1, #2047	; 0x7ff
    5bde:	428a      	cmp	r2, r1
    5be0:	d1e6      	bne.n	5bb0 <scalbn+0x38>
    5be2:	ed9d 7b00 	vldr	d7, [sp]
    5be6:	ee37 0b07 	vadd.f64	d0, d7, d7
    5bea:	b002      	add	sp, #8
    5bec:	ecbd 8b02 	vpop	{d8}
    5bf0:	bd10      	pop	{r4, pc}
    5bf2:	ed9d 0b00 	vldr	d0, [sp]
    5bf6:	b002      	add	sp, #8
    5bf8:	ecbd 8b02 	vpop	{d8}
    5bfc:	bd10      	pop	{r4, pc}
    5bfe:	ed9f 0b1e 	vldr	d0, [pc, #120]	; 5c78 <scalbn+0x100>
    5c02:	ee27 0b00 	vmul.f64	d0, d7, d0
    5c06:	b002      	add	sp, #8
    5c08:	ecbd 8b02 	vpop	{d8}
    5c0c:	bd10      	pop	{r4, pc}
    5c0e:	f114 0f35 	cmn.w	r4, #53	; 0x35
    5c12:	da11      	bge.n	5c38 <scalbn+0xc0>
    5c14:	f24c 3350 	movw	r3, #50000	; 0xc350
    5c18:	4298      	cmp	r0, r3
    5c1a:	dd1d      	ble.n	5c58 <scalbn+0xe0>
    5c1c:	ed9f 8b18 	vldr	d8, [pc, #96]	; 5c80 <scalbn+0x108>
    5c20:	ed9d 1b00 	vldr	d1, [sp]
    5c24:	eeb0 0b48 	vmov.f64	d0, d8
    5c28:	f000 f834 	bl	5c94 <copysign>
    5c2c:	ee20 0b08 	vmul.f64	d0, d0, d8
    5c30:	b002      	add	sp, #8
    5c32:	ecbd 8b02 	vpop	{d8}
    5c36:	bd10      	pop	{r4, pc}
    5c38:	f023 41ff 	bic.w	r1, r3, #2139095040	; 0x7f800000
    5c3c:	e9dd 2300 	ldrd	r2, r3, [sp]
    5c40:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
    5c44:	3436      	adds	r4, #54	; 0x36
    5c46:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
    5c4a:	ed9f 0b0f 	vldr	d0, [pc, #60]	; 5c88 <scalbn+0x110>
    5c4e:	ec43 2b17 	vmov	d7, r2, r3
    5c52:	ee27 0b00 	vmul.f64	d0, d7, d0
    5c56:	e7bc      	b.n	5bd2 <scalbn+0x5a>
    5c58:	ed9f 8b07 	vldr	d8, [pc, #28]	; 5c78 <scalbn+0x100>
    5c5c:	ed9d 1b00 	vldr	d1, [sp]
    5c60:	eeb0 0b48 	vmov.f64	d0, d8
    5c64:	f000 f816 	bl	5c94 <copysign>
    5c68:	ee20 0b08 	vmul.f64	d0, d0, d8
    5c6c:	e7b1      	b.n	5bd2 <scalbn+0x5a>
    5c6e:	bf00      	nop
    5c70:	00000000 	.word	0x00000000
    5c74:	43500000 	.word	0x43500000
    5c78:	c2f8f359 	.word	0xc2f8f359
    5c7c:	01a56e1f 	.word	0x01a56e1f
    5c80:	8800759c 	.word	0x8800759c
    5c84:	7e37e43c 	.word	0x7e37e43c
    5c88:	00000000 	.word	0x00000000
    5c8c:	3c900000 	.word	0x3c900000
    5c90:	ffff3cb0 	.word	0xffff3cb0

00005c94 <copysign>:
    5c94:	ec53 2b10 	vmov	r2, r3, d0
    5c98:	ee11 0a90 	vmov	r0, s3
    5c9c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
    5ca0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
    5ca4:	ea41 0300 	orr.w	r3, r1, r0
    5ca8:	ec43 2b10 	vmov	d0, r2, r3
    5cac:	4770      	bx	lr
    5cae:	bf00      	nop

00005cb0 <__aeabi_atexit>:
    5cb0:	460b      	mov	r3, r1
    5cb2:	4601      	mov	r1, r0
    5cb4:	4618      	mov	r0, r3
    5cb6:	f000 b98d 	b.w	5fd4 <__cxa_atexit>
    5cba:	bf00      	nop

00005cbc <__aeabi_uldivmod>:
    5cbc:	b953      	cbnz	r3, 5cd4 <__aeabi_uldivmod+0x18>
    5cbe:	b94a      	cbnz	r2, 5cd4 <__aeabi_uldivmod+0x18>
    5cc0:	2900      	cmp	r1, #0
    5cc2:	bf08      	it	eq
    5cc4:	2800      	cmpeq	r0, #0
    5cc6:	bf1c      	itt	ne
    5cc8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    5ccc:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    5cd0:	f000 b97e 	b.w	5fd0 <__aeabi_idiv0>
    5cd4:	f1ad 0c08 	sub.w	ip, sp, #8
    5cd8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    5cdc:	f000 f806 	bl	5cec <__udivmoddi4>
    5ce0:	f8dd e004 	ldr.w	lr, [sp, #4]
    5ce4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    5ce8:	b004      	add	sp, #16
    5cea:	4770      	bx	lr

00005cec <__udivmoddi4>:
    5cec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5cf0:	468c      	mov	ip, r1
    5cf2:	460e      	mov	r6, r1
    5cf4:	4604      	mov	r4, r0
    5cf6:	9d08      	ldr	r5, [sp, #32]
    5cf8:	2b00      	cmp	r3, #0
    5cfa:	d150      	bne.n	5d9e <__udivmoddi4+0xb2>
    5cfc:	428a      	cmp	r2, r1
    5cfe:	4617      	mov	r7, r2
    5d00:	d96c      	bls.n	5ddc <__udivmoddi4+0xf0>
    5d02:	fab2 fe82 	clz	lr, r2
    5d06:	f1be 0f00 	cmp.w	lr, #0
    5d0a:	d00b      	beq.n	5d24 <__udivmoddi4+0x38>
    5d0c:	f1ce 0420 	rsb	r4, lr, #32
    5d10:	fa20 f404 	lsr.w	r4, r0, r4
    5d14:	fa01 f60e 	lsl.w	r6, r1, lr
    5d18:	ea44 0c06 	orr.w	ip, r4, r6
    5d1c:	fa02 f70e 	lsl.w	r7, r2, lr
    5d20:	fa00 f40e 	lsl.w	r4, r0, lr
    5d24:	ea4f 4917 	mov.w	r9, r7, lsr #16
    5d28:	0c22      	lsrs	r2, r4, #16
    5d2a:	fbbc f0f9 	udiv	r0, ip, r9
    5d2e:	fa1f f887 	uxth.w	r8, r7
    5d32:	fb09 c610 	mls	r6, r9, r0, ip
    5d36:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    5d3a:	fb00 f308 	mul.w	r3, r0, r8
    5d3e:	42b3      	cmp	r3, r6
    5d40:	d909      	bls.n	5d56 <__udivmoddi4+0x6a>
    5d42:	19f6      	adds	r6, r6, r7
    5d44:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    5d48:	f080 8122 	bcs.w	5f90 <__udivmoddi4+0x2a4>
    5d4c:	42b3      	cmp	r3, r6
    5d4e:	f240 811f 	bls.w	5f90 <__udivmoddi4+0x2a4>
    5d52:	3802      	subs	r0, #2
    5d54:	443e      	add	r6, r7
    5d56:	1af6      	subs	r6, r6, r3
    5d58:	b2a2      	uxth	r2, r4
    5d5a:	fbb6 f3f9 	udiv	r3, r6, r9
    5d5e:	fb09 6613 	mls	r6, r9, r3, r6
    5d62:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    5d66:	fb03 f808 	mul.w	r8, r3, r8
    5d6a:	45a0      	cmp	r8, r4
    5d6c:	d909      	bls.n	5d82 <__udivmoddi4+0x96>
    5d6e:	19e4      	adds	r4, r4, r7
    5d70:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    5d74:	f080 810a 	bcs.w	5f8c <__udivmoddi4+0x2a0>
    5d78:	45a0      	cmp	r8, r4
    5d7a:	f240 8107 	bls.w	5f8c <__udivmoddi4+0x2a0>
    5d7e:	3b02      	subs	r3, #2
    5d80:	443c      	add	r4, r7
    5d82:	ebc8 0404 	rsb	r4, r8, r4
    5d86:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    5d8a:	2100      	movs	r1, #0
    5d8c:	2d00      	cmp	r5, #0
    5d8e:	d062      	beq.n	5e56 <__udivmoddi4+0x16a>
    5d90:	fa24 f40e 	lsr.w	r4, r4, lr
    5d94:	2300      	movs	r3, #0
    5d96:	602c      	str	r4, [r5, #0]
    5d98:	606b      	str	r3, [r5, #4]
    5d9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5d9e:	428b      	cmp	r3, r1
    5da0:	d907      	bls.n	5db2 <__udivmoddi4+0xc6>
    5da2:	2d00      	cmp	r5, #0
    5da4:	d055      	beq.n	5e52 <__udivmoddi4+0x166>
    5da6:	2100      	movs	r1, #0
    5da8:	e885 0041 	stmia.w	r5, {r0, r6}
    5dac:	4608      	mov	r0, r1
    5dae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5db2:	fab3 f183 	clz	r1, r3
    5db6:	2900      	cmp	r1, #0
    5db8:	f040 8090 	bne.w	5edc <__udivmoddi4+0x1f0>
    5dbc:	42b3      	cmp	r3, r6
    5dbe:	d302      	bcc.n	5dc6 <__udivmoddi4+0xda>
    5dc0:	4282      	cmp	r2, r0
    5dc2:	f200 80f8 	bhi.w	5fb6 <__udivmoddi4+0x2ca>
    5dc6:	1a84      	subs	r4, r0, r2
    5dc8:	eb66 0603 	sbc.w	r6, r6, r3
    5dcc:	2001      	movs	r0, #1
    5dce:	46b4      	mov	ip, r6
    5dd0:	2d00      	cmp	r5, #0
    5dd2:	d040      	beq.n	5e56 <__udivmoddi4+0x16a>
    5dd4:	e885 1010 	stmia.w	r5, {r4, ip}
    5dd8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5ddc:	b912      	cbnz	r2, 5de4 <__udivmoddi4+0xf8>
    5dde:	2701      	movs	r7, #1
    5de0:	fbb7 f7f2 	udiv	r7, r7, r2
    5de4:	fab7 fe87 	clz	lr, r7
    5de8:	f1be 0f00 	cmp.w	lr, #0
    5dec:	d135      	bne.n	5e5a <__udivmoddi4+0x16e>
    5dee:	1bf3      	subs	r3, r6, r7
    5df0:	ea4f 4817 	mov.w	r8, r7, lsr #16
    5df4:	fa1f fc87 	uxth.w	ip, r7
    5df8:	2101      	movs	r1, #1
    5dfa:	fbb3 f0f8 	udiv	r0, r3, r8
    5dfe:	0c22      	lsrs	r2, r4, #16
    5e00:	fb08 3610 	mls	r6, r8, r0, r3
    5e04:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    5e08:	fb0c f300 	mul.w	r3, ip, r0
    5e0c:	42b3      	cmp	r3, r6
    5e0e:	d907      	bls.n	5e20 <__udivmoddi4+0x134>
    5e10:	19f6      	adds	r6, r6, r7
    5e12:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    5e16:	d202      	bcs.n	5e1e <__udivmoddi4+0x132>
    5e18:	42b3      	cmp	r3, r6
    5e1a:	f200 80ce 	bhi.w	5fba <__udivmoddi4+0x2ce>
    5e1e:	4610      	mov	r0, r2
    5e20:	1af6      	subs	r6, r6, r3
    5e22:	b2a2      	uxth	r2, r4
    5e24:	fbb6 f3f8 	udiv	r3, r6, r8
    5e28:	fb08 6613 	mls	r6, r8, r3, r6
    5e2c:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    5e30:	fb0c fc03 	mul.w	ip, ip, r3
    5e34:	45a4      	cmp	ip, r4
    5e36:	d907      	bls.n	5e48 <__udivmoddi4+0x15c>
    5e38:	19e4      	adds	r4, r4, r7
    5e3a:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    5e3e:	d202      	bcs.n	5e46 <__udivmoddi4+0x15a>
    5e40:	45a4      	cmp	ip, r4
    5e42:	f200 80b5 	bhi.w	5fb0 <__udivmoddi4+0x2c4>
    5e46:	4613      	mov	r3, r2
    5e48:	ebcc 0404 	rsb	r4, ip, r4
    5e4c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    5e50:	e79c      	b.n	5d8c <__udivmoddi4+0xa0>
    5e52:	4629      	mov	r1, r5
    5e54:	4628      	mov	r0, r5
    5e56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5e5a:	f1ce 0120 	rsb	r1, lr, #32
    5e5e:	fa06 f30e 	lsl.w	r3, r6, lr
    5e62:	fa07 f70e 	lsl.w	r7, r7, lr
    5e66:	fa20 f901 	lsr.w	r9, r0, r1
    5e6a:	ea4f 4817 	mov.w	r8, r7, lsr #16
    5e6e:	40ce      	lsrs	r6, r1
    5e70:	ea49 0903 	orr.w	r9, r9, r3
    5e74:	fbb6 faf8 	udiv	sl, r6, r8
    5e78:	ea4f 4419 	mov.w	r4, r9, lsr #16
    5e7c:	fb08 661a 	mls	r6, r8, sl, r6
    5e80:	fa1f fc87 	uxth.w	ip, r7
    5e84:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
    5e88:	fb0a f20c 	mul.w	r2, sl, ip
    5e8c:	429a      	cmp	r2, r3
    5e8e:	fa00 f40e 	lsl.w	r4, r0, lr
    5e92:	d90a      	bls.n	5eaa <__udivmoddi4+0x1be>
    5e94:	19db      	adds	r3, r3, r7
    5e96:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    5e9a:	f080 8087 	bcs.w	5fac <__udivmoddi4+0x2c0>
    5e9e:	429a      	cmp	r2, r3
    5ea0:	f240 8084 	bls.w	5fac <__udivmoddi4+0x2c0>
    5ea4:	f1aa 0a02 	sub.w	sl, sl, #2
    5ea8:	443b      	add	r3, r7
    5eaa:	1a9b      	subs	r3, r3, r2
    5eac:	fa1f f989 	uxth.w	r9, r9
    5eb0:	fbb3 f1f8 	udiv	r1, r3, r8
    5eb4:	fb08 3311 	mls	r3, r8, r1, r3
    5eb8:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
    5ebc:	fb01 f60c 	mul.w	r6, r1, ip
    5ec0:	429e      	cmp	r6, r3
    5ec2:	d907      	bls.n	5ed4 <__udivmoddi4+0x1e8>
    5ec4:	19db      	adds	r3, r3, r7
    5ec6:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    5eca:	d26b      	bcs.n	5fa4 <__udivmoddi4+0x2b8>
    5ecc:	429e      	cmp	r6, r3
    5ece:	d969      	bls.n	5fa4 <__udivmoddi4+0x2b8>
    5ed0:	3902      	subs	r1, #2
    5ed2:	443b      	add	r3, r7
    5ed4:	1b9b      	subs	r3, r3, r6
    5ed6:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
    5eda:	e78e      	b.n	5dfa <__udivmoddi4+0x10e>
    5edc:	f1c1 0e20 	rsb	lr, r1, #32
    5ee0:	fa22 f40e 	lsr.w	r4, r2, lr
    5ee4:	408b      	lsls	r3, r1
    5ee6:	4323      	orrs	r3, r4
    5ee8:	fa20 f70e 	lsr.w	r7, r0, lr
    5eec:	fa06 f401 	lsl.w	r4, r6, r1
    5ef0:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    5ef4:	fa26 f60e 	lsr.w	r6, r6, lr
    5ef8:	433c      	orrs	r4, r7
    5efa:	fbb6 f9fc 	udiv	r9, r6, ip
    5efe:	0c27      	lsrs	r7, r4, #16
    5f00:	fb0c 6619 	mls	r6, ip, r9, r6
    5f04:	fa1f f883 	uxth.w	r8, r3
    5f08:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
    5f0c:	fb09 f708 	mul.w	r7, r9, r8
    5f10:	42b7      	cmp	r7, r6
    5f12:	fa02 f201 	lsl.w	r2, r2, r1
    5f16:	fa00 fa01 	lsl.w	sl, r0, r1
    5f1a:	d908      	bls.n	5f2e <__udivmoddi4+0x242>
    5f1c:	18f6      	adds	r6, r6, r3
    5f1e:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    5f22:	d241      	bcs.n	5fa8 <__udivmoddi4+0x2bc>
    5f24:	42b7      	cmp	r7, r6
    5f26:	d93f      	bls.n	5fa8 <__udivmoddi4+0x2bc>
    5f28:	f1a9 0902 	sub.w	r9, r9, #2
    5f2c:	441e      	add	r6, r3
    5f2e:	1bf6      	subs	r6, r6, r7
    5f30:	b2a0      	uxth	r0, r4
    5f32:	fbb6 f4fc 	udiv	r4, r6, ip
    5f36:	fb0c 6614 	mls	r6, ip, r4, r6
    5f3a:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
    5f3e:	fb04 f808 	mul.w	r8, r4, r8
    5f42:	45b8      	cmp	r8, r7
    5f44:	d907      	bls.n	5f56 <__udivmoddi4+0x26a>
    5f46:	18ff      	adds	r7, r7, r3
    5f48:	f104 30ff 	add.w	r0, r4, #4294967295	; 0xffffffff
    5f4c:	d228      	bcs.n	5fa0 <__udivmoddi4+0x2b4>
    5f4e:	45b8      	cmp	r8, r7
    5f50:	d926      	bls.n	5fa0 <__udivmoddi4+0x2b4>
    5f52:	3c02      	subs	r4, #2
    5f54:	441f      	add	r7, r3
    5f56:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
    5f5a:	ebc8 0707 	rsb	r7, r8, r7
    5f5e:	fba0 8902 	umull	r8, r9, r0, r2
    5f62:	454f      	cmp	r7, r9
    5f64:	4644      	mov	r4, r8
    5f66:	464e      	mov	r6, r9
    5f68:	d314      	bcc.n	5f94 <__udivmoddi4+0x2a8>
    5f6a:	d029      	beq.n	5fc0 <__udivmoddi4+0x2d4>
    5f6c:	b365      	cbz	r5, 5fc8 <__udivmoddi4+0x2dc>
    5f6e:	ebba 0304 	subs.w	r3, sl, r4
    5f72:	eb67 0706 	sbc.w	r7, r7, r6
    5f76:	fa07 fe0e 	lsl.w	lr, r7, lr
    5f7a:	40cb      	lsrs	r3, r1
    5f7c:	40cf      	lsrs	r7, r1
    5f7e:	ea4e 0303 	orr.w	r3, lr, r3
    5f82:	e885 0088 	stmia.w	r5, {r3, r7}
    5f86:	2100      	movs	r1, #0
    5f88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5f8c:	4613      	mov	r3, r2
    5f8e:	e6f8      	b.n	5d82 <__udivmoddi4+0x96>
    5f90:	4610      	mov	r0, r2
    5f92:	e6e0      	b.n	5d56 <__udivmoddi4+0x6a>
    5f94:	ebb8 0402 	subs.w	r4, r8, r2
    5f98:	eb69 0603 	sbc.w	r6, r9, r3
    5f9c:	3801      	subs	r0, #1
    5f9e:	e7e5      	b.n	5f6c <__udivmoddi4+0x280>
    5fa0:	4604      	mov	r4, r0
    5fa2:	e7d8      	b.n	5f56 <__udivmoddi4+0x26a>
    5fa4:	4611      	mov	r1, r2
    5fa6:	e795      	b.n	5ed4 <__udivmoddi4+0x1e8>
    5fa8:	4681      	mov	r9, r0
    5faa:	e7c0      	b.n	5f2e <__udivmoddi4+0x242>
    5fac:	468a      	mov	sl, r1
    5fae:	e77c      	b.n	5eaa <__udivmoddi4+0x1be>
    5fb0:	3b02      	subs	r3, #2
    5fb2:	443c      	add	r4, r7
    5fb4:	e748      	b.n	5e48 <__udivmoddi4+0x15c>
    5fb6:	4608      	mov	r0, r1
    5fb8:	e70a      	b.n	5dd0 <__udivmoddi4+0xe4>
    5fba:	3802      	subs	r0, #2
    5fbc:	443e      	add	r6, r7
    5fbe:	e72f      	b.n	5e20 <__udivmoddi4+0x134>
    5fc0:	45c2      	cmp	sl, r8
    5fc2:	d3e7      	bcc.n	5f94 <__udivmoddi4+0x2a8>
    5fc4:	463e      	mov	r6, r7
    5fc6:	e7d1      	b.n	5f6c <__udivmoddi4+0x280>
    5fc8:	4629      	mov	r1, r5
    5fca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5fce:	bf00      	nop

00005fd0 <__aeabi_idiv0>:
    5fd0:	4770      	bx	lr
    5fd2:	bf00      	nop

00005fd4 <__cxa_atexit>:
    5fd4:	4613      	mov	r3, r2
    5fd6:	460a      	mov	r2, r1
    5fd8:	4601      	mov	r1, r0
    5fda:	2002      	movs	r0, #2
    5fdc:	f001 b948 	b.w	7270 <__register_exitproc>

00005fe0 <__errno>:
    5fe0:	4b01      	ldr	r3, [pc, #4]	; (5fe8 <__errno+0x8>)
    5fe2:	6818      	ldr	r0, [r3, #0]
    5fe4:	4770      	bx	lr
    5fe6:	bf00      	nop
    5fe8:	20001dd8 	.word	0x20001dd8

00005fec <exit>:
    5fec:	b508      	push	{r3, lr}
    5fee:	2100      	movs	r1, #0
    5ff0:	4604      	mov	r4, r0
    5ff2:	f001 f98f 	bl	7314 <__call_exitprocs>
    5ff6:	4b04      	ldr	r3, [pc, #16]	; (6008 <exit+0x1c>)
    5ff8:	6818      	ldr	r0, [r3, #0]
    5ffa:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    5ffc:	b103      	cbz	r3, 6000 <exit+0x14>
    5ffe:	4798      	blx	r3
    6000:	4620      	mov	r0, r4
    6002:	f7fb fca5 	bl	1950 <_exit>
    6006:	bf00      	nop
    6008:	200006c8 	.word	0x200006c8

0000600c <__libc_init_array>:
    600c:	b570      	push	{r4, r5, r6, lr}
    600e:	4e0f      	ldr	r6, [pc, #60]	; (604c <__libc_init_array+0x40>)
    6010:	4d0f      	ldr	r5, [pc, #60]	; (6050 <__libc_init_array+0x44>)
    6012:	1b76      	subs	r6, r6, r5
    6014:	10b6      	asrs	r6, r6, #2
    6016:	bf18      	it	ne
    6018:	2400      	movne	r4, #0
    601a:	d005      	beq.n	6028 <__libc_init_array+0x1c>
    601c:	3401      	adds	r4, #1
    601e:	f855 3b04 	ldr.w	r3, [r5], #4
    6022:	4798      	blx	r3
    6024:	42a6      	cmp	r6, r4
    6026:	d1f9      	bne.n	601c <__libc_init_array+0x10>
    6028:	4e0a      	ldr	r6, [pc, #40]	; (6054 <__libc_init_array+0x48>)
    602a:	4d0b      	ldr	r5, [pc, #44]	; (6058 <__libc_init_array+0x4c>)
    602c:	1b76      	subs	r6, r6, r5
    602e:	f004 f8ff 	bl	a230 <___init_veneer>
    6032:	10b6      	asrs	r6, r6, #2
    6034:	bf18      	it	ne
    6036:	2400      	movne	r4, #0
    6038:	d006      	beq.n	6048 <__libc_init_array+0x3c>
    603a:	3401      	adds	r4, #1
    603c:	f855 3b04 	ldr.w	r3, [r5], #4
    6040:	4798      	blx	r3
    6042:	42a6      	cmp	r6, r4
    6044:	d1f9      	bne.n	603a <__libc_init_array+0x2e>
    6046:	bd70      	pop	{r4, r5, r6, pc}
    6048:	bd70      	pop	{r4, r5, r6, pc}
    604a:	bf00      	nop
    604c:	60002098 	.word	0x60002098
    6050:	60002098 	.word	0x60002098
    6054:	600020a0 	.word	0x600020a0
    6058:	60002098 	.word	0x60002098

0000605c <malloc>:
    605c:	4b02      	ldr	r3, [pc, #8]	; (6068 <malloc+0xc>)
    605e:	4601      	mov	r1, r0
    6060:	6818      	ldr	r0, [r3, #0]
    6062:	f000 b80b 	b.w	607c <_malloc_r>
    6066:	bf00      	nop
    6068:	20001dd8 	.word	0x20001dd8

0000606c <free>:
    606c:	4b02      	ldr	r3, [pc, #8]	; (6078 <free+0xc>)
    606e:	4601      	mov	r1, r0
    6070:	6818      	ldr	r0, [r3, #0]
    6072:	f001 ba09 	b.w	7488 <_free_r>
    6076:	bf00      	nop
    6078:	20001dd8 	.word	0x20001dd8

0000607c <_malloc_r>:
    607c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6080:	f101 050b 	add.w	r5, r1, #11
    6084:	2d16      	cmp	r5, #22
    6086:	b083      	sub	sp, #12
    6088:	4606      	mov	r6, r0
    608a:	f240 809f 	bls.w	61cc <_malloc_r+0x150>
    608e:	f035 0507 	bics.w	r5, r5, #7
    6092:	f100 80bf 	bmi.w	6214 <_malloc_r+0x198>
    6096:	42a9      	cmp	r1, r5
    6098:	f200 80bc 	bhi.w	6214 <_malloc_r+0x198>
    609c:	f000 fc08 	bl	68b0 <__malloc_lock>
    60a0:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    60a4:	f0c0 829c 	bcc.w	65e0 <_malloc_r+0x564>
    60a8:	0a6b      	lsrs	r3, r5, #9
    60aa:	f000 80ba 	beq.w	6222 <_malloc_r+0x1a6>
    60ae:	2b04      	cmp	r3, #4
    60b0:	f200 8183 	bhi.w	63ba <_malloc_r+0x33e>
    60b4:	09a8      	lsrs	r0, r5, #6
    60b6:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    60ba:	ea4f 034e 	mov.w	r3, lr, lsl #1
    60be:	3038      	adds	r0, #56	; 0x38
    60c0:	4fc4      	ldr	r7, [pc, #784]	; (63d4 <_malloc_r+0x358>)
    60c2:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    60c6:	f1a3 0108 	sub.w	r1, r3, #8
    60ca:	685c      	ldr	r4, [r3, #4]
    60cc:	42a1      	cmp	r1, r4
    60ce:	d107      	bne.n	60e0 <_malloc_r+0x64>
    60d0:	e0ac      	b.n	622c <_malloc_r+0x1b0>
    60d2:	2a00      	cmp	r2, #0
    60d4:	f280 80ac 	bge.w	6230 <_malloc_r+0x1b4>
    60d8:	68e4      	ldr	r4, [r4, #12]
    60da:	42a1      	cmp	r1, r4
    60dc:	f000 80a6 	beq.w	622c <_malloc_r+0x1b0>
    60e0:	6863      	ldr	r3, [r4, #4]
    60e2:	f023 0303 	bic.w	r3, r3, #3
    60e6:	1b5a      	subs	r2, r3, r5
    60e8:	2a0f      	cmp	r2, #15
    60ea:	ddf2      	ble.n	60d2 <_malloc_r+0x56>
    60ec:	49b9      	ldr	r1, [pc, #740]	; (63d4 <_malloc_r+0x358>)
    60ee:	693c      	ldr	r4, [r7, #16]
    60f0:	f101 0e08 	add.w	lr, r1, #8
    60f4:	4574      	cmp	r4, lr
    60f6:	f000 81b3 	beq.w	6460 <_malloc_r+0x3e4>
    60fa:	6863      	ldr	r3, [r4, #4]
    60fc:	f023 0303 	bic.w	r3, r3, #3
    6100:	1b5a      	subs	r2, r3, r5
    6102:	2a0f      	cmp	r2, #15
    6104:	f300 8199 	bgt.w	643a <_malloc_r+0x3be>
    6108:	2a00      	cmp	r2, #0
    610a:	f8c1 e014 	str.w	lr, [r1, #20]
    610e:	f8c1 e010 	str.w	lr, [r1, #16]
    6112:	f280 809e 	bge.w	6252 <_malloc_r+0x1d6>
    6116:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    611a:	f080 8167 	bcs.w	63ec <_malloc_r+0x370>
    611e:	08db      	lsrs	r3, r3, #3
    6120:	f103 0c01 	add.w	ip, r3, #1
    6124:	2201      	movs	r2, #1
    6126:	109b      	asrs	r3, r3, #2
    6128:	fa02 f303 	lsl.w	r3, r2, r3
    612c:	684a      	ldr	r2, [r1, #4]
    612e:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    6132:	f8c4 8008 	str.w	r8, [r4, #8]
    6136:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    613a:	431a      	orrs	r2, r3
    613c:	f1a9 0308 	sub.w	r3, r9, #8
    6140:	60e3      	str	r3, [r4, #12]
    6142:	604a      	str	r2, [r1, #4]
    6144:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    6148:	f8c8 400c 	str.w	r4, [r8, #12]
    614c:	1083      	asrs	r3, r0, #2
    614e:	2401      	movs	r4, #1
    6150:	409c      	lsls	r4, r3
    6152:	4294      	cmp	r4, r2
    6154:	f200 808a 	bhi.w	626c <_malloc_r+0x1f0>
    6158:	4214      	tst	r4, r2
    615a:	d106      	bne.n	616a <_malloc_r+0xee>
    615c:	f020 0003 	bic.w	r0, r0, #3
    6160:	0064      	lsls	r4, r4, #1
    6162:	4214      	tst	r4, r2
    6164:	f100 0004 	add.w	r0, r0, #4
    6168:	d0fa      	beq.n	6160 <_malloc_r+0xe4>
    616a:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    616e:	46cc      	mov	ip, r9
    6170:	4680      	mov	r8, r0
    6172:	f8dc 100c 	ldr.w	r1, [ip, #12]
    6176:	458c      	cmp	ip, r1
    6178:	d107      	bne.n	618a <_malloc_r+0x10e>
    617a:	e173      	b.n	6464 <_malloc_r+0x3e8>
    617c:	2a00      	cmp	r2, #0
    617e:	f280 8181 	bge.w	6484 <_malloc_r+0x408>
    6182:	68c9      	ldr	r1, [r1, #12]
    6184:	458c      	cmp	ip, r1
    6186:	f000 816d 	beq.w	6464 <_malloc_r+0x3e8>
    618a:	684b      	ldr	r3, [r1, #4]
    618c:	f023 0303 	bic.w	r3, r3, #3
    6190:	1b5a      	subs	r2, r3, r5
    6192:	2a0f      	cmp	r2, #15
    6194:	ddf2      	ble.n	617c <_malloc_r+0x100>
    6196:	460c      	mov	r4, r1
    6198:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    619c:	f854 8f08 	ldr.w	r8, [r4, #8]!
    61a0:	194b      	adds	r3, r1, r5
    61a2:	f045 0501 	orr.w	r5, r5, #1
    61a6:	604d      	str	r5, [r1, #4]
    61a8:	f042 0101 	orr.w	r1, r2, #1
    61ac:	f8c8 c00c 	str.w	ip, [r8, #12]
    61b0:	4630      	mov	r0, r6
    61b2:	f8cc 8008 	str.w	r8, [ip, #8]
    61b6:	617b      	str	r3, [r7, #20]
    61b8:	613b      	str	r3, [r7, #16]
    61ba:	f8c3 e00c 	str.w	lr, [r3, #12]
    61be:	f8c3 e008 	str.w	lr, [r3, #8]
    61c2:	6059      	str	r1, [r3, #4]
    61c4:	509a      	str	r2, [r3, r2]
    61c6:	f000 fb75 	bl	68b4 <__malloc_unlock>
    61ca:	e01f      	b.n	620c <_malloc_r+0x190>
    61cc:	2910      	cmp	r1, #16
    61ce:	d821      	bhi.n	6214 <_malloc_r+0x198>
    61d0:	f000 fb6e 	bl	68b0 <__malloc_lock>
    61d4:	2510      	movs	r5, #16
    61d6:	2306      	movs	r3, #6
    61d8:	2002      	movs	r0, #2
    61da:	4f7e      	ldr	r7, [pc, #504]	; (63d4 <_malloc_r+0x358>)
    61dc:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    61e0:	f1a3 0208 	sub.w	r2, r3, #8
    61e4:	685c      	ldr	r4, [r3, #4]
    61e6:	4294      	cmp	r4, r2
    61e8:	f000 8145 	beq.w	6476 <_malloc_r+0x3fa>
    61ec:	6863      	ldr	r3, [r4, #4]
    61ee:	68e1      	ldr	r1, [r4, #12]
    61f0:	68a5      	ldr	r5, [r4, #8]
    61f2:	f023 0303 	bic.w	r3, r3, #3
    61f6:	4423      	add	r3, r4
    61f8:	4630      	mov	r0, r6
    61fa:	685a      	ldr	r2, [r3, #4]
    61fc:	60e9      	str	r1, [r5, #12]
    61fe:	f042 0201 	orr.w	r2, r2, #1
    6202:	608d      	str	r5, [r1, #8]
    6204:	605a      	str	r2, [r3, #4]
    6206:	f000 fb55 	bl	68b4 <__malloc_unlock>
    620a:	3408      	adds	r4, #8
    620c:	4620      	mov	r0, r4
    620e:	b003      	add	sp, #12
    6210:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6214:	2400      	movs	r4, #0
    6216:	230c      	movs	r3, #12
    6218:	4620      	mov	r0, r4
    621a:	6033      	str	r3, [r6, #0]
    621c:	b003      	add	sp, #12
    621e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6222:	2380      	movs	r3, #128	; 0x80
    6224:	f04f 0e40 	mov.w	lr, #64	; 0x40
    6228:	203f      	movs	r0, #63	; 0x3f
    622a:	e749      	b.n	60c0 <_malloc_r+0x44>
    622c:	4670      	mov	r0, lr
    622e:	e75d      	b.n	60ec <_malloc_r+0x70>
    6230:	4423      	add	r3, r4
    6232:	68e1      	ldr	r1, [r4, #12]
    6234:	685a      	ldr	r2, [r3, #4]
    6236:	68a5      	ldr	r5, [r4, #8]
    6238:	f042 0201 	orr.w	r2, r2, #1
    623c:	60e9      	str	r1, [r5, #12]
    623e:	4630      	mov	r0, r6
    6240:	608d      	str	r5, [r1, #8]
    6242:	605a      	str	r2, [r3, #4]
    6244:	f000 fb36 	bl	68b4 <__malloc_unlock>
    6248:	3408      	adds	r4, #8
    624a:	4620      	mov	r0, r4
    624c:	b003      	add	sp, #12
    624e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6252:	4423      	add	r3, r4
    6254:	4630      	mov	r0, r6
    6256:	685a      	ldr	r2, [r3, #4]
    6258:	f042 0201 	orr.w	r2, r2, #1
    625c:	605a      	str	r2, [r3, #4]
    625e:	f000 fb29 	bl	68b4 <__malloc_unlock>
    6262:	3408      	adds	r4, #8
    6264:	4620      	mov	r0, r4
    6266:	b003      	add	sp, #12
    6268:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    626c:	68bc      	ldr	r4, [r7, #8]
    626e:	6863      	ldr	r3, [r4, #4]
    6270:	f023 0803 	bic.w	r8, r3, #3
    6274:	45a8      	cmp	r8, r5
    6276:	d304      	bcc.n	6282 <_malloc_r+0x206>
    6278:	ebc5 0308 	rsb	r3, r5, r8
    627c:	2b0f      	cmp	r3, #15
    627e:	f300 808c 	bgt.w	639a <_malloc_r+0x31e>
    6282:	4b55      	ldr	r3, [pc, #340]	; (63d8 <_malloc_r+0x35c>)
    6284:	f8df 9160 	ldr.w	r9, [pc, #352]	; 63e8 <_malloc_r+0x36c>
    6288:	681a      	ldr	r2, [r3, #0]
    628a:	f8d9 3000 	ldr.w	r3, [r9]
    628e:	3301      	adds	r3, #1
    6290:	442a      	add	r2, r5
    6292:	eb04 0a08 	add.w	sl, r4, r8
    6296:	f000 8160 	beq.w	655a <_malloc_r+0x4de>
    629a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    629e:	320f      	adds	r2, #15
    62a0:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    62a4:	f022 020f 	bic.w	r2, r2, #15
    62a8:	4611      	mov	r1, r2
    62aa:	4630      	mov	r0, r6
    62ac:	9201      	str	r2, [sp, #4]
    62ae:	f000 fcfb 	bl	6ca8 <_sbrk_r>
    62b2:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    62b6:	4683      	mov	fp, r0
    62b8:	9a01      	ldr	r2, [sp, #4]
    62ba:	f000 8158 	beq.w	656e <_malloc_r+0x4f2>
    62be:	4582      	cmp	sl, r0
    62c0:	f200 80fc 	bhi.w	64bc <_malloc_r+0x440>
    62c4:	4b45      	ldr	r3, [pc, #276]	; (63dc <_malloc_r+0x360>)
    62c6:	6819      	ldr	r1, [r3, #0]
    62c8:	45da      	cmp	sl, fp
    62ca:	4411      	add	r1, r2
    62cc:	6019      	str	r1, [r3, #0]
    62ce:	f000 8153 	beq.w	6578 <_malloc_r+0x4fc>
    62d2:	f8d9 0000 	ldr.w	r0, [r9]
    62d6:	f8df e110 	ldr.w	lr, [pc, #272]	; 63e8 <_malloc_r+0x36c>
    62da:	3001      	adds	r0, #1
    62dc:	bf1b      	ittet	ne
    62de:	ebca 0a0b 	rsbne	sl, sl, fp
    62e2:	4451      	addne	r1, sl
    62e4:	f8ce b000 	streq.w	fp, [lr]
    62e8:	6019      	strne	r1, [r3, #0]
    62ea:	f01b 0107 	ands.w	r1, fp, #7
    62ee:	f000 8117 	beq.w	6520 <_malloc_r+0x4a4>
    62f2:	f1c1 0008 	rsb	r0, r1, #8
    62f6:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    62fa:	4483      	add	fp, r0
    62fc:	3108      	adds	r1, #8
    62fe:	445a      	add	r2, fp
    6300:	f3c2 020b 	ubfx	r2, r2, #0, #12
    6304:	ebc2 0901 	rsb	r9, r2, r1
    6308:	4649      	mov	r1, r9
    630a:	4630      	mov	r0, r6
    630c:	9301      	str	r3, [sp, #4]
    630e:	f000 fccb 	bl	6ca8 <_sbrk_r>
    6312:	1c43      	adds	r3, r0, #1
    6314:	9b01      	ldr	r3, [sp, #4]
    6316:	f000 813f 	beq.w	6598 <_malloc_r+0x51c>
    631a:	ebcb 0200 	rsb	r2, fp, r0
    631e:	444a      	add	r2, r9
    6320:	f042 0201 	orr.w	r2, r2, #1
    6324:	6819      	ldr	r1, [r3, #0]
    6326:	f8c7 b008 	str.w	fp, [r7, #8]
    632a:	4449      	add	r1, r9
    632c:	42bc      	cmp	r4, r7
    632e:	f8cb 2004 	str.w	r2, [fp, #4]
    6332:	6019      	str	r1, [r3, #0]
    6334:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 63dc <_malloc_r+0x360>
    6338:	d016      	beq.n	6368 <_malloc_r+0x2ec>
    633a:	f1b8 0f0f 	cmp.w	r8, #15
    633e:	f240 80fd 	bls.w	653c <_malloc_r+0x4c0>
    6342:	6862      	ldr	r2, [r4, #4]
    6344:	f1a8 030c 	sub.w	r3, r8, #12
    6348:	f023 0307 	bic.w	r3, r3, #7
    634c:	18e0      	adds	r0, r4, r3
    634e:	f002 0201 	and.w	r2, r2, #1
    6352:	f04f 0e05 	mov.w	lr, #5
    6356:	431a      	orrs	r2, r3
    6358:	2b0f      	cmp	r3, #15
    635a:	6062      	str	r2, [r4, #4]
    635c:	f8c0 e004 	str.w	lr, [r0, #4]
    6360:	f8c0 e008 	str.w	lr, [r0, #8]
    6364:	f200 811c 	bhi.w	65a0 <_malloc_r+0x524>
    6368:	4b1d      	ldr	r3, [pc, #116]	; (63e0 <_malloc_r+0x364>)
    636a:	68bc      	ldr	r4, [r7, #8]
    636c:	681a      	ldr	r2, [r3, #0]
    636e:	4291      	cmp	r1, r2
    6370:	bf88      	it	hi
    6372:	6019      	strhi	r1, [r3, #0]
    6374:	4b1b      	ldr	r3, [pc, #108]	; (63e4 <_malloc_r+0x368>)
    6376:	681a      	ldr	r2, [r3, #0]
    6378:	4291      	cmp	r1, r2
    637a:	6862      	ldr	r2, [r4, #4]
    637c:	bf88      	it	hi
    637e:	6019      	strhi	r1, [r3, #0]
    6380:	f022 0203 	bic.w	r2, r2, #3
    6384:	4295      	cmp	r5, r2
    6386:	eba2 0305 	sub.w	r3, r2, r5
    638a:	d801      	bhi.n	6390 <_malloc_r+0x314>
    638c:	2b0f      	cmp	r3, #15
    638e:	dc04      	bgt.n	639a <_malloc_r+0x31e>
    6390:	4630      	mov	r0, r6
    6392:	f000 fa8f 	bl	68b4 <__malloc_unlock>
    6396:	2400      	movs	r4, #0
    6398:	e738      	b.n	620c <_malloc_r+0x190>
    639a:	1962      	adds	r2, r4, r5
    639c:	f043 0301 	orr.w	r3, r3, #1
    63a0:	f045 0501 	orr.w	r5, r5, #1
    63a4:	6065      	str	r5, [r4, #4]
    63a6:	4630      	mov	r0, r6
    63a8:	60ba      	str	r2, [r7, #8]
    63aa:	6053      	str	r3, [r2, #4]
    63ac:	f000 fa82 	bl	68b4 <__malloc_unlock>
    63b0:	3408      	adds	r4, #8
    63b2:	4620      	mov	r0, r4
    63b4:	b003      	add	sp, #12
    63b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    63ba:	2b14      	cmp	r3, #20
    63bc:	d971      	bls.n	64a2 <_malloc_r+0x426>
    63be:	2b54      	cmp	r3, #84	; 0x54
    63c0:	f200 80a4 	bhi.w	650c <_malloc_r+0x490>
    63c4:	0b28      	lsrs	r0, r5, #12
    63c6:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    63ca:	ea4f 034e 	mov.w	r3, lr, lsl #1
    63ce:	306e      	adds	r0, #110	; 0x6e
    63d0:	e676      	b.n	60c0 <_malloc_r+0x44>
    63d2:	bf00      	nop
    63d4:	200019c8 	.word	0x200019c8
    63d8:	200026e4 	.word	0x200026e4
    63dc:	200026b4 	.word	0x200026b4
    63e0:	200026dc 	.word	0x200026dc
    63e4:	200026e0 	.word	0x200026e0
    63e8:	20001dd0 	.word	0x20001dd0
    63ec:	0a5a      	lsrs	r2, r3, #9
    63ee:	2a04      	cmp	r2, #4
    63f0:	d95e      	bls.n	64b0 <_malloc_r+0x434>
    63f2:	2a14      	cmp	r2, #20
    63f4:	f200 80b3 	bhi.w	655e <_malloc_r+0x4e2>
    63f8:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    63fc:	0049      	lsls	r1, r1, #1
    63fe:	325b      	adds	r2, #91	; 0x5b
    6400:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    6404:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    6408:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 65e8 <_malloc_r+0x56c>
    640c:	f1ac 0c08 	sub.w	ip, ip, #8
    6410:	458c      	cmp	ip, r1
    6412:	f000 8088 	beq.w	6526 <_malloc_r+0x4aa>
    6416:	684a      	ldr	r2, [r1, #4]
    6418:	f022 0203 	bic.w	r2, r2, #3
    641c:	4293      	cmp	r3, r2
    641e:	d202      	bcs.n	6426 <_malloc_r+0x3aa>
    6420:	6889      	ldr	r1, [r1, #8]
    6422:	458c      	cmp	ip, r1
    6424:	d1f7      	bne.n	6416 <_malloc_r+0x39a>
    6426:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    642a:	687a      	ldr	r2, [r7, #4]
    642c:	f8c4 c00c 	str.w	ip, [r4, #12]
    6430:	60a1      	str	r1, [r4, #8]
    6432:	f8cc 4008 	str.w	r4, [ip, #8]
    6436:	60cc      	str	r4, [r1, #12]
    6438:	e688      	b.n	614c <_malloc_r+0xd0>
    643a:	1963      	adds	r3, r4, r5
    643c:	f042 0701 	orr.w	r7, r2, #1
    6440:	f045 0501 	orr.w	r5, r5, #1
    6444:	6065      	str	r5, [r4, #4]
    6446:	4630      	mov	r0, r6
    6448:	614b      	str	r3, [r1, #20]
    644a:	610b      	str	r3, [r1, #16]
    644c:	f8c3 e00c 	str.w	lr, [r3, #12]
    6450:	f8c3 e008 	str.w	lr, [r3, #8]
    6454:	605f      	str	r7, [r3, #4]
    6456:	509a      	str	r2, [r3, r2]
    6458:	3408      	adds	r4, #8
    645a:	f000 fa2b 	bl	68b4 <__malloc_unlock>
    645e:	e6d5      	b.n	620c <_malloc_r+0x190>
    6460:	684a      	ldr	r2, [r1, #4]
    6462:	e673      	b.n	614c <_malloc_r+0xd0>
    6464:	f108 0801 	add.w	r8, r8, #1
    6468:	f018 0f03 	tst.w	r8, #3
    646c:	f10c 0c08 	add.w	ip, ip, #8
    6470:	f47f ae7f 	bne.w	6172 <_malloc_r+0xf6>
    6474:	e030      	b.n	64d8 <_malloc_r+0x45c>
    6476:	68dc      	ldr	r4, [r3, #12]
    6478:	42a3      	cmp	r3, r4
    647a:	bf08      	it	eq
    647c:	3002      	addeq	r0, #2
    647e:	f43f ae35 	beq.w	60ec <_malloc_r+0x70>
    6482:	e6b3      	b.n	61ec <_malloc_r+0x170>
    6484:	440b      	add	r3, r1
    6486:	460c      	mov	r4, r1
    6488:	685a      	ldr	r2, [r3, #4]
    648a:	68c9      	ldr	r1, [r1, #12]
    648c:	f854 5f08 	ldr.w	r5, [r4, #8]!
    6490:	f042 0201 	orr.w	r2, r2, #1
    6494:	605a      	str	r2, [r3, #4]
    6496:	4630      	mov	r0, r6
    6498:	60e9      	str	r1, [r5, #12]
    649a:	608d      	str	r5, [r1, #8]
    649c:	f000 fa0a 	bl	68b4 <__malloc_unlock>
    64a0:	e6b4      	b.n	620c <_malloc_r+0x190>
    64a2:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    64a6:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    64aa:	ea4f 034e 	mov.w	r3, lr, lsl #1
    64ae:	e607      	b.n	60c0 <_malloc_r+0x44>
    64b0:	099a      	lsrs	r2, r3, #6
    64b2:	f102 0139 	add.w	r1, r2, #57	; 0x39
    64b6:	0049      	lsls	r1, r1, #1
    64b8:	3238      	adds	r2, #56	; 0x38
    64ba:	e7a1      	b.n	6400 <_malloc_r+0x384>
    64bc:	42bc      	cmp	r4, r7
    64be:	4b4a      	ldr	r3, [pc, #296]	; (65e8 <_malloc_r+0x56c>)
    64c0:	f43f af00 	beq.w	62c4 <_malloc_r+0x248>
    64c4:	689c      	ldr	r4, [r3, #8]
    64c6:	6862      	ldr	r2, [r4, #4]
    64c8:	f022 0203 	bic.w	r2, r2, #3
    64cc:	e75a      	b.n	6384 <_malloc_r+0x308>
    64ce:	f859 3908 	ldr.w	r3, [r9], #-8
    64d2:	4599      	cmp	r9, r3
    64d4:	f040 8082 	bne.w	65dc <_malloc_r+0x560>
    64d8:	f010 0f03 	tst.w	r0, #3
    64dc:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    64e0:	d1f5      	bne.n	64ce <_malloc_r+0x452>
    64e2:	687b      	ldr	r3, [r7, #4]
    64e4:	ea23 0304 	bic.w	r3, r3, r4
    64e8:	607b      	str	r3, [r7, #4]
    64ea:	0064      	lsls	r4, r4, #1
    64ec:	429c      	cmp	r4, r3
    64ee:	f63f aebd 	bhi.w	626c <_malloc_r+0x1f0>
    64f2:	2c00      	cmp	r4, #0
    64f4:	f43f aeba 	beq.w	626c <_malloc_r+0x1f0>
    64f8:	421c      	tst	r4, r3
    64fa:	4640      	mov	r0, r8
    64fc:	f47f ae35 	bne.w	616a <_malloc_r+0xee>
    6500:	0064      	lsls	r4, r4, #1
    6502:	421c      	tst	r4, r3
    6504:	f100 0004 	add.w	r0, r0, #4
    6508:	d0fa      	beq.n	6500 <_malloc_r+0x484>
    650a:	e62e      	b.n	616a <_malloc_r+0xee>
    650c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    6510:	d818      	bhi.n	6544 <_malloc_r+0x4c8>
    6512:	0be8      	lsrs	r0, r5, #15
    6514:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    6518:	ea4f 034e 	mov.w	r3, lr, lsl #1
    651c:	3077      	adds	r0, #119	; 0x77
    651e:	e5cf      	b.n	60c0 <_malloc_r+0x44>
    6520:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    6524:	e6eb      	b.n	62fe <_malloc_r+0x282>
    6526:	2101      	movs	r1, #1
    6528:	f8d8 3004 	ldr.w	r3, [r8, #4]
    652c:	1092      	asrs	r2, r2, #2
    652e:	fa01 f202 	lsl.w	r2, r1, r2
    6532:	431a      	orrs	r2, r3
    6534:	f8c8 2004 	str.w	r2, [r8, #4]
    6538:	4661      	mov	r1, ip
    653a:	e777      	b.n	642c <_malloc_r+0x3b0>
    653c:	2301      	movs	r3, #1
    653e:	f8cb 3004 	str.w	r3, [fp, #4]
    6542:	e725      	b.n	6390 <_malloc_r+0x314>
    6544:	f240 5254 	movw	r2, #1364	; 0x554
    6548:	4293      	cmp	r3, r2
    654a:	d820      	bhi.n	658e <_malloc_r+0x512>
    654c:	0ca8      	lsrs	r0, r5, #18
    654e:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    6552:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6556:	307c      	adds	r0, #124	; 0x7c
    6558:	e5b2      	b.n	60c0 <_malloc_r+0x44>
    655a:	3210      	adds	r2, #16
    655c:	e6a4      	b.n	62a8 <_malloc_r+0x22c>
    655e:	2a54      	cmp	r2, #84	; 0x54
    6560:	d826      	bhi.n	65b0 <_malloc_r+0x534>
    6562:	0b1a      	lsrs	r2, r3, #12
    6564:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    6568:	0049      	lsls	r1, r1, #1
    656a:	326e      	adds	r2, #110	; 0x6e
    656c:	e748      	b.n	6400 <_malloc_r+0x384>
    656e:	68bc      	ldr	r4, [r7, #8]
    6570:	6862      	ldr	r2, [r4, #4]
    6572:	f022 0203 	bic.w	r2, r2, #3
    6576:	e705      	b.n	6384 <_malloc_r+0x308>
    6578:	f3ca 000b 	ubfx	r0, sl, #0, #12
    657c:	2800      	cmp	r0, #0
    657e:	f47f aea8 	bne.w	62d2 <_malloc_r+0x256>
    6582:	4442      	add	r2, r8
    6584:	68bb      	ldr	r3, [r7, #8]
    6586:	f042 0201 	orr.w	r2, r2, #1
    658a:	605a      	str	r2, [r3, #4]
    658c:	e6ec      	b.n	6368 <_malloc_r+0x2ec>
    658e:	23fe      	movs	r3, #254	; 0xfe
    6590:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    6594:	207e      	movs	r0, #126	; 0x7e
    6596:	e593      	b.n	60c0 <_malloc_r+0x44>
    6598:	2201      	movs	r2, #1
    659a:	f04f 0900 	mov.w	r9, #0
    659e:	e6c1      	b.n	6324 <_malloc_r+0x2a8>
    65a0:	f104 0108 	add.w	r1, r4, #8
    65a4:	4630      	mov	r0, r6
    65a6:	f000 ff6f 	bl	7488 <_free_r>
    65aa:	f8d9 1000 	ldr.w	r1, [r9]
    65ae:	e6db      	b.n	6368 <_malloc_r+0x2ec>
    65b0:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    65b4:	d805      	bhi.n	65c2 <_malloc_r+0x546>
    65b6:	0bda      	lsrs	r2, r3, #15
    65b8:	f102 0178 	add.w	r1, r2, #120	; 0x78
    65bc:	0049      	lsls	r1, r1, #1
    65be:	3277      	adds	r2, #119	; 0x77
    65c0:	e71e      	b.n	6400 <_malloc_r+0x384>
    65c2:	f240 5154 	movw	r1, #1364	; 0x554
    65c6:	428a      	cmp	r2, r1
    65c8:	d805      	bhi.n	65d6 <_malloc_r+0x55a>
    65ca:	0c9a      	lsrs	r2, r3, #18
    65cc:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    65d0:	0049      	lsls	r1, r1, #1
    65d2:	327c      	adds	r2, #124	; 0x7c
    65d4:	e714      	b.n	6400 <_malloc_r+0x384>
    65d6:	21fe      	movs	r1, #254	; 0xfe
    65d8:	227e      	movs	r2, #126	; 0x7e
    65da:	e711      	b.n	6400 <_malloc_r+0x384>
    65dc:	687b      	ldr	r3, [r7, #4]
    65de:	e784      	b.n	64ea <_malloc_r+0x46e>
    65e0:	08e8      	lsrs	r0, r5, #3
    65e2:	1c43      	adds	r3, r0, #1
    65e4:	005b      	lsls	r3, r3, #1
    65e6:	e5f8      	b.n	61da <_malloc_r+0x15e>
    65e8:	200019c8 	.word	0x200019c8

000065ec <__ascii_mbtowc>:
    65ec:	b082      	sub	sp, #8
    65ee:	b149      	cbz	r1, 6604 <__ascii_mbtowc+0x18>
    65f0:	b15a      	cbz	r2, 660a <__ascii_mbtowc+0x1e>
    65f2:	b16b      	cbz	r3, 6610 <__ascii_mbtowc+0x24>
    65f4:	7813      	ldrb	r3, [r2, #0]
    65f6:	600b      	str	r3, [r1, #0]
    65f8:	7812      	ldrb	r2, [r2, #0]
    65fa:	1c10      	adds	r0, r2, #0
    65fc:	bf18      	it	ne
    65fe:	2001      	movne	r0, #1
    6600:	b002      	add	sp, #8
    6602:	4770      	bx	lr
    6604:	a901      	add	r1, sp, #4
    6606:	2a00      	cmp	r2, #0
    6608:	d1f3      	bne.n	65f2 <__ascii_mbtowc+0x6>
    660a:	4610      	mov	r0, r2
    660c:	b002      	add	sp, #8
    660e:	4770      	bx	lr
    6610:	f06f 0001 	mvn.w	r0, #1
    6614:	e7f4      	b.n	6600 <__ascii_mbtowc+0x14>
    6616:	bf00      	nop

00006618 <memcpy>:
    6618:	4684      	mov	ip, r0
    661a:	ea41 0300 	orr.w	r3, r1, r0
    661e:	f013 0303 	ands.w	r3, r3, #3
    6622:	d16d      	bne.n	6700 <memcpy+0xe8>
    6624:	3a40      	subs	r2, #64	; 0x40
    6626:	d341      	bcc.n	66ac <memcpy+0x94>
    6628:	f851 3b04 	ldr.w	r3, [r1], #4
    662c:	f840 3b04 	str.w	r3, [r0], #4
    6630:	f851 3b04 	ldr.w	r3, [r1], #4
    6634:	f840 3b04 	str.w	r3, [r0], #4
    6638:	f851 3b04 	ldr.w	r3, [r1], #4
    663c:	f840 3b04 	str.w	r3, [r0], #4
    6640:	f851 3b04 	ldr.w	r3, [r1], #4
    6644:	f840 3b04 	str.w	r3, [r0], #4
    6648:	f851 3b04 	ldr.w	r3, [r1], #4
    664c:	f840 3b04 	str.w	r3, [r0], #4
    6650:	f851 3b04 	ldr.w	r3, [r1], #4
    6654:	f840 3b04 	str.w	r3, [r0], #4
    6658:	f851 3b04 	ldr.w	r3, [r1], #4
    665c:	f840 3b04 	str.w	r3, [r0], #4
    6660:	f851 3b04 	ldr.w	r3, [r1], #4
    6664:	f840 3b04 	str.w	r3, [r0], #4
    6668:	f851 3b04 	ldr.w	r3, [r1], #4
    666c:	f840 3b04 	str.w	r3, [r0], #4
    6670:	f851 3b04 	ldr.w	r3, [r1], #4
    6674:	f840 3b04 	str.w	r3, [r0], #4
    6678:	f851 3b04 	ldr.w	r3, [r1], #4
    667c:	f840 3b04 	str.w	r3, [r0], #4
    6680:	f851 3b04 	ldr.w	r3, [r1], #4
    6684:	f840 3b04 	str.w	r3, [r0], #4
    6688:	f851 3b04 	ldr.w	r3, [r1], #4
    668c:	f840 3b04 	str.w	r3, [r0], #4
    6690:	f851 3b04 	ldr.w	r3, [r1], #4
    6694:	f840 3b04 	str.w	r3, [r0], #4
    6698:	f851 3b04 	ldr.w	r3, [r1], #4
    669c:	f840 3b04 	str.w	r3, [r0], #4
    66a0:	f851 3b04 	ldr.w	r3, [r1], #4
    66a4:	f840 3b04 	str.w	r3, [r0], #4
    66a8:	3a40      	subs	r2, #64	; 0x40
    66aa:	d2bd      	bcs.n	6628 <memcpy+0x10>
    66ac:	3230      	adds	r2, #48	; 0x30
    66ae:	d311      	bcc.n	66d4 <memcpy+0xbc>
    66b0:	f851 3b04 	ldr.w	r3, [r1], #4
    66b4:	f840 3b04 	str.w	r3, [r0], #4
    66b8:	f851 3b04 	ldr.w	r3, [r1], #4
    66bc:	f840 3b04 	str.w	r3, [r0], #4
    66c0:	f851 3b04 	ldr.w	r3, [r1], #4
    66c4:	f840 3b04 	str.w	r3, [r0], #4
    66c8:	f851 3b04 	ldr.w	r3, [r1], #4
    66cc:	f840 3b04 	str.w	r3, [r0], #4
    66d0:	3a10      	subs	r2, #16
    66d2:	d2ed      	bcs.n	66b0 <memcpy+0x98>
    66d4:	320c      	adds	r2, #12
    66d6:	d305      	bcc.n	66e4 <memcpy+0xcc>
    66d8:	f851 3b04 	ldr.w	r3, [r1], #4
    66dc:	f840 3b04 	str.w	r3, [r0], #4
    66e0:	3a04      	subs	r2, #4
    66e2:	d2f9      	bcs.n	66d8 <memcpy+0xc0>
    66e4:	3204      	adds	r2, #4
    66e6:	d008      	beq.n	66fa <memcpy+0xe2>
    66e8:	07d2      	lsls	r2, r2, #31
    66ea:	bf1c      	itt	ne
    66ec:	f811 3b01 	ldrbne.w	r3, [r1], #1
    66f0:	f800 3b01 	strbne.w	r3, [r0], #1
    66f4:	d301      	bcc.n	66fa <memcpy+0xe2>
    66f6:	880b      	ldrh	r3, [r1, #0]
    66f8:	8003      	strh	r3, [r0, #0]
    66fa:	4660      	mov	r0, ip
    66fc:	4770      	bx	lr
    66fe:	bf00      	nop
    6700:	2a08      	cmp	r2, #8
    6702:	d313      	bcc.n	672c <memcpy+0x114>
    6704:	078b      	lsls	r3, r1, #30
    6706:	d08d      	beq.n	6624 <memcpy+0xc>
    6708:	f010 0303 	ands.w	r3, r0, #3
    670c:	d08a      	beq.n	6624 <memcpy+0xc>
    670e:	f1c3 0304 	rsb	r3, r3, #4
    6712:	1ad2      	subs	r2, r2, r3
    6714:	07db      	lsls	r3, r3, #31
    6716:	bf1c      	itt	ne
    6718:	f811 3b01 	ldrbne.w	r3, [r1], #1
    671c:	f800 3b01 	strbne.w	r3, [r0], #1
    6720:	d380      	bcc.n	6624 <memcpy+0xc>
    6722:	f831 3b02 	ldrh.w	r3, [r1], #2
    6726:	f820 3b02 	strh.w	r3, [r0], #2
    672a:	e77b      	b.n	6624 <memcpy+0xc>
    672c:	3a04      	subs	r2, #4
    672e:	d3d9      	bcc.n	66e4 <memcpy+0xcc>
    6730:	3a01      	subs	r2, #1
    6732:	f811 3b01 	ldrb.w	r3, [r1], #1
    6736:	f800 3b01 	strb.w	r3, [r0], #1
    673a:	d2f9      	bcs.n	6730 <memcpy+0x118>
    673c:	780b      	ldrb	r3, [r1, #0]
    673e:	7003      	strb	r3, [r0, #0]
    6740:	784b      	ldrb	r3, [r1, #1]
    6742:	7043      	strb	r3, [r0, #1]
    6744:	788b      	ldrb	r3, [r1, #2]
    6746:	7083      	strb	r3, [r0, #2]
    6748:	4660      	mov	r0, ip
    674a:	4770      	bx	lr

0000674c <memmove>:
    674c:	4288      	cmp	r0, r1
    674e:	b5f0      	push	{r4, r5, r6, r7, lr}
    6750:	d90d      	bls.n	676e <memmove+0x22>
    6752:	188b      	adds	r3, r1, r2
    6754:	4298      	cmp	r0, r3
    6756:	d20a      	bcs.n	676e <memmove+0x22>
    6758:	1881      	adds	r1, r0, r2
    675a:	2a00      	cmp	r2, #0
    675c:	d051      	beq.n	6802 <memmove+0xb6>
    675e:	1a9a      	subs	r2, r3, r2
    6760:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    6764:	f801 4d01 	strb.w	r4, [r1, #-1]!
    6768:	4293      	cmp	r3, r2
    676a:	d1f9      	bne.n	6760 <memmove+0x14>
    676c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    676e:	2a0f      	cmp	r2, #15
    6770:	d948      	bls.n	6804 <memmove+0xb8>
    6772:	ea41 0300 	orr.w	r3, r1, r0
    6776:	079b      	lsls	r3, r3, #30
    6778:	d146      	bne.n	6808 <memmove+0xbc>
    677a:	f100 0410 	add.w	r4, r0, #16
    677e:	f101 0310 	add.w	r3, r1, #16
    6782:	4615      	mov	r5, r2
    6784:	f853 6c10 	ldr.w	r6, [r3, #-16]
    6788:	f844 6c10 	str.w	r6, [r4, #-16]
    678c:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    6790:	f844 6c0c 	str.w	r6, [r4, #-12]
    6794:	f853 6c08 	ldr.w	r6, [r3, #-8]
    6798:	f844 6c08 	str.w	r6, [r4, #-8]
    679c:	3d10      	subs	r5, #16
    679e:	f853 6c04 	ldr.w	r6, [r3, #-4]
    67a2:	f844 6c04 	str.w	r6, [r4, #-4]
    67a6:	2d0f      	cmp	r5, #15
    67a8:	f103 0310 	add.w	r3, r3, #16
    67ac:	f104 0410 	add.w	r4, r4, #16
    67b0:	d8e8      	bhi.n	6784 <memmove+0x38>
    67b2:	f1a2 0310 	sub.w	r3, r2, #16
    67b6:	f023 030f 	bic.w	r3, r3, #15
    67ba:	f002 0e0f 	and.w	lr, r2, #15
    67be:	3310      	adds	r3, #16
    67c0:	f1be 0f03 	cmp.w	lr, #3
    67c4:	4419      	add	r1, r3
    67c6:	4403      	add	r3, r0
    67c8:	d921      	bls.n	680e <memmove+0xc2>
    67ca:	1f1e      	subs	r6, r3, #4
    67cc:	460d      	mov	r5, r1
    67ce:	4674      	mov	r4, lr
    67d0:	3c04      	subs	r4, #4
    67d2:	f855 7b04 	ldr.w	r7, [r5], #4
    67d6:	f846 7f04 	str.w	r7, [r6, #4]!
    67da:	2c03      	cmp	r4, #3
    67dc:	d8f8      	bhi.n	67d0 <memmove+0x84>
    67de:	f1ae 0404 	sub.w	r4, lr, #4
    67e2:	f024 0403 	bic.w	r4, r4, #3
    67e6:	3404      	adds	r4, #4
    67e8:	4423      	add	r3, r4
    67ea:	4421      	add	r1, r4
    67ec:	f002 0203 	and.w	r2, r2, #3
    67f0:	b162      	cbz	r2, 680c <memmove+0xc0>
    67f2:	3b01      	subs	r3, #1
    67f4:	440a      	add	r2, r1
    67f6:	f811 4b01 	ldrb.w	r4, [r1], #1
    67fa:	f803 4f01 	strb.w	r4, [r3, #1]!
    67fe:	428a      	cmp	r2, r1
    6800:	d1f9      	bne.n	67f6 <memmove+0xaa>
    6802:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6804:	4603      	mov	r3, r0
    6806:	e7f3      	b.n	67f0 <memmove+0xa4>
    6808:	4603      	mov	r3, r0
    680a:	e7f2      	b.n	67f2 <memmove+0xa6>
    680c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    680e:	4672      	mov	r2, lr
    6810:	e7ee      	b.n	67f0 <memmove+0xa4>
    6812:	bf00      	nop

00006814 <memset>:
    6814:	b470      	push	{r4, r5, r6}
    6816:	0784      	lsls	r4, r0, #30
    6818:	d046      	beq.n	68a8 <memset+0x94>
    681a:	1e54      	subs	r4, r2, #1
    681c:	2a00      	cmp	r2, #0
    681e:	d041      	beq.n	68a4 <memset+0x90>
    6820:	b2cd      	uxtb	r5, r1
    6822:	4603      	mov	r3, r0
    6824:	e002      	b.n	682c <memset+0x18>
    6826:	1e62      	subs	r2, r4, #1
    6828:	b3e4      	cbz	r4, 68a4 <memset+0x90>
    682a:	4614      	mov	r4, r2
    682c:	f803 5b01 	strb.w	r5, [r3], #1
    6830:	079a      	lsls	r2, r3, #30
    6832:	d1f8      	bne.n	6826 <memset+0x12>
    6834:	2c03      	cmp	r4, #3
    6836:	d92e      	bls.n	6896 <memset+0x82>
    6838:	b2cd      	uxtb	r5, r1
    683a:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    683e:	2c0f      	cmp	r4, #15
    6840:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    6844:	d919      	bls.n	687a <memset+0x66>
    6846:	f103 0210 	add.w	r2, r3, #16
    684a:	4626      	mov	r6, r4
    684c:	3e10      	subs	r6, #16
    684e:	2e0f      	cmp	r6, #15
    6850:	f842 5c10 	str.w	r5, [r2, #-16]
    6854:	f842 5c0c 	str.w	r5, [r2, #-12]
    6858:	f842 5c08 	str.w	r5, [r2, #-8]
    685c:	f842 5c04 	str.w	r5, [r2, #-4]
    6860:	f102 0210 	add.w	r2, r2, #16
    6864:	d8f2      	bhi.n	684c <memset+0x38>
    6866:	f1a4 0210 	sub.w	r2, r4, #16
    686a:	f022 020f 	bic.w	r2, r2, #15
    686e:	f004 040f 	and.w	r4, r4, #15
    6872:	3210      	adds	r2, #16
    6874:	2c03      	cmp	r4, #3
    6876:	4413      	add	r3, r2
    6878:	d90d      	bls.n	6896 <memset+0x82>
    687a:	461e      	mov	r6, r3
    687c:	4622      	mov	r2, r4
    687e:	3a04      	subs	r2, #4
    6880:	2a03      	cmp	r2, #3
    6882:	f846 5b04 	str.w	r5, [r6], #4
    6886:	d8fa      	bhi.n	687e <memset+0x6a>
    6888:	1f22      	subs	r2, r4, #4
    688a:	f022 0203 	bic.w	r2, r2, #3
    688e:	3204      	adds	r2, #4
    6890:	4413      	add	r3, r2
    6892:	f004 0403 	and.w	r4, r4, #3
    6896:	b12c      	cbz	r4, 68a4 <memset+0x90>
    6898:	b2c9      	uxtb	r1, r1
    689a:	441c      	add	r4, r3
    689c:	f803 1b01 	strb.w	r1, [r3], #1
    68a0:	42a3      	cmp	r3, r4
    68a2:	d1fb      	bne.n	689c <memset+0x88>
    68a4:	bc70      	pop	{r4, r5, r6}
    68a6:	4770      	bx	lr
    68a8:	4614      	mov	r4, r2
    68aa:	4603      	mov	r3, r0
    68ac:	e7c2      	b.n	6834 <memset+0x20>
    68ae:	bf00      	nop

000068b0 <__malloc_lock>:
    68b0:	4770      	bx	lr
    68b2:	bf00      	nop

000068b4 <__malloc_unlock>:
    68b4:	4770      	bx	lr
    68b6:	bf00      	nop

000068b8 <realloc>:
    68b8:	4b02      	ldr	r3, [pc, #8]	; (68c4 <realloc+0xc>)
    68ba:	460a      	mov	r2, r1
    68bc:	4601      	mov	r1, r0
    68be:	6818      	ldr	r0, [r3, #0]
    68c0:	f000 b802 	b.w	68c8 <_realloc_r>
    68c4:	20001dd8 	.word	0x20001dd8

000068c8 <_realloc_r>:
    68c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    68cc:	4617      	mov	r7, r2
    68ce:	b083      	sub	sp, #12
    68d0:	2900      	cmp	r1, #0
    68d2:	f000 80c1 	beq.w	6a58 <_realloc_r+0x190>
    68d6:	460e      	mov	r6, r1
    68d8:	4681      	mov	r9, r0
    68da:	f107 050b 	add.w	r5, r7, #11
    68de:	f7ff ffe7 	bl	68b0 <__malloc_lock>
    68e2:	f856 ec04 	ldr.w	lr, [r6, #-4]
    68e6:	2d16      	cmp	r5, #22
    68e8:	f02e 0403 	bic.w	r4, lr, #3
    68ec:	f1a6 0808 	sub.w	r8, r6, #8
    68f0:	d840      	bhi.n	6974 <_realloc_r+0xac>
    68f2:	2210      	movs	r2, #16
    68f4:	4615      	mov	r5, r2
    68f6:	42af      	cmp	r7, r5
    68f8:	d841      	bhi.n	697e <_realloc_r+0xb6>
    68fa:	4294      	cmp	r4, r2
    68fc:	da75      	bge.n	69ea <_realloc_r+0x122>
    68fe:	4bc9      	ldr	r3, [pc, #804]	; (6c24 <_realloc_r+0x35c>)
    6900:	6899      	ldr	r1, [r3, #8]
    6902:	eb08 0004 	add.w	r0, r8, r4
    6906:	4288      	cmp	r0, r1
    6908:	6841      	ldr	r1, [r0, #4]
    690a:	f000 80d9 	beq.w	6ac0 <_realloc_r+0x1f8>
    690e:	f021 0301 	bic.w	r3, r1, #1
    6912:	4403      	add	r3, r0
    6914:	685b      	ldr	r3, [r3, #4]
    6916:	07db      	lsls	r3, r3, #31
    6918:	d57d      	bpl.n	6a16 <_realloc_r+0x14e>
    691a:	f01e 0f01 	tst.w	lr, #1
    691e:	d035      	beq.n	698c <_realloc_r+0xc4>
    6920:	4639      	mov	r1, r7
    6922:	4648      	mov	r0, r9
    6924:	f7ff fbaa 	bl	607c <_malloc_r>
    6928:	4607      	mov	r7, r0
    692a:	b1e0      	cbz	r0, 6966 <_realloc_r+0x9e>
    692c:	f856 3c04 	ldr.w	r3, [r6, #-4]
    6930:	f023 0301 	bic.w	r3, r3, #1
    6934:	4443      	add	r3, r8
    6936:	f1a0 0208 	sub.w	r2, r0, #8
    693a:	429a      	cmp	r2, r3
    693c:	f000 8144 	beq.w	6bc8 <_realloc_r+0x300>
    6940:	1f22      	subs	r2, r4, #4
    6942:	2a24      	cmp	r2, #36	; 0x24
    6944:	f200 8131 	bhi.w	6baa <_realloc_r+0x2e2>
    6948:	2a13      	cmp	r2, #19
    694a:	f200 8104 	bhi.w	6b56 <_realloc_r+0x28e>
    694e:	4603      	mov	r3, r0
    6950:	4632      	mov	r2, r6
    6952:	6811      	ldr	r1, [r2, #0]
    6954:	6019      	str	r1, [r3, #0]
    6956:	6851      	ldr	r1, [r2, #4]
    6958:	6059      	str	r1, [r3, #4]
    695a:	6892      	ldr	r2, [r2, #8]
    695c:	609a      	str	r2, [r3, #8]
    695e:	4631      	mov	r1, r6
    6960:	4648      	mov	r0, r9
    6962:	f000 fd91 	bl	7488 <_free_r>
    6966:	4648      	mov	r0, r9
    6968:	f7ff ffa4 	bl	68b4 <__malloc_unlock>
    696c:	4638      	mov	r0, r7
    696e:	b003      	add	sp, #12
    6970:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6974:	f025 0507 	bic.w	r5, r5, #7
    6978:	2d00      	cmp	r5, #0
    697a:	462a      	mov	r2, r5
    697c:	dabb      	bge.n	68f6 <_realloc_r+0x2e>
    697e:	230c      	movs	r3, #12
    6980:	2000      	movs	r0, #0
    6982:	f8c9 3000 	str.w	r3, [r9]
    6986:	b003      	add	sp, #12
    6988:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    698c:	f856 3c08 	ldr.w	r3, [r6, #-8]
    6990:	ebc3 0a08 	rsb	sl, r3, r8
    6994:	f8da 3004 	ldr.w	r3, [sl, #4]
    6998:	f023 0c03 	bic.w	ip, r3, #3
    699c:	eb04 030c 	add.w	r3, r4, ip
    69a0:	4293      	cmp	r3, r2
    69a2:	dbbd      	blt.n	6920 <_realloc_r+0x58>
    69a4:	4657      	mov	r7, sl
    69a6:	f8da 100c 	ldr.w	r1, [sl, #12]
    69aa:	f857 0f08 	ldr.w	r0, [r7, #8]!
    69ae:	1f22      	subs	r2, r4, #4
    69b0:	2a24      	cmp	r2, #36	; 0x24
    69b2:	60c1      	str	r1, [r0, #12]
    69b4:	6088      	str	r0, [r1, #8]
    69b6:	f200 8117 	bhi.w	6be8 <_realloc_r+0x320>
    69ba:	2a13      	cmp	r2, #19
    69bc:	f240 8112 	bls.w	6be4 <_realloc_r+0x31c>
    69c0:	6831      	ldr	r1, [r6, #0]
    69c2:	f8ca 1008 	str.w	r1, [sl, #8]
    69c6:	6871      	ldr	r1, [r6, #4]
    69c8:	f8ca 100c 	str.w	r1, [sl, #12]
    69cc:	2a1b      	cmp	r2, #27
    69ce:	f200 812b 	bhi.w	6c28 <_realloc_r+0x360>
    69d2:	3608      	adds	r6, #8
    69d4:	f10a 0210 	add.w	r2, sl, #16
    69d8:	6831      	ldr	r1, [r6, #0]
    69da:	6011      	str	r1, [r2, #0]
    69dc:	6871      	ldr	r1, [r6, #4]
    69de:	6051      	str	r1, [r2, #4]
    69e0:	68b1      	ldr	r1, [r6, #8]
    69e2:	6091      	str	r1, [r2, #8]
    69e4:	463e      	mov	r6, r7
    69e6:	461c      	mov	r4, r3
    69e8:	46d0      	mov	r8, sl
    69ea:	1b63      	subs	r3, r4, r5
    69ec:	2b0f      	cmp	r3, #15
    69ee:	d81d      	bhi.n	6a2c <_realloc_r+0x164>
    69f0:	f8d8 3004 	ldr.w	r3, [r8, #4]
    69f4:	f003 0301 	and.w	r3, r3, #1
    69f8:	4323      	orrs	r3, r4
    69fa:	4444      	add	r4, r8
    69fc:	f8c8 3004 	str.w	r3, [r8, #4]
    6a00:	6863      	ldr	r3, [r4, #4]
    6a02:	f043 0301 	orr.w	r3, r3, #1
    6a06:	6063      	str	r3, [r4, #4]
    6a08:	4648      	mov	r0, r9
    6a0a:	f7ff ff53 	bl	68b4 <__malloc_unlock>
    6a0e:	4630      	mov	r0, r6
    6a10:	b003      	add	sp, #12
    6a12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6a16:	f021 0103 	bic.w	r1, r1, #3
    6a1a:	4421      	add	r1, r4
    6a1c:	4291      	cmp	r1, r2
    6a1e:	db21      	blt.n	6a64 <_realloc_r+0x19c>
    6a20:	68c3      	ldr	r3, [r0, #12]
    6a22:	6882      	ldr	r2, [r0, #8]
    6a24:	460c      	mov	r4, r1
    6a26:	60d3      	str	r3, [r2, #12]
    6a28:	609a      	str	r2, [r3, #8]
    6a2a:	e7de      	b.n	69ea <_realloc_r+0x122>
    6a2c:	f8d8 2004 	ldr.w	r2, [r8, #4]
    6a30:	eb08 0105 	add.w	r1, r8, r5
    6a34:	f002 0201 	and.w	r2, r2, #1
    6a38:	4315      	orrs	r5, r2
    6a3a:	f043 0201 	orr.w	r2, r3, #1
    6a3e:	440b      	add	r3, r1
    6a40:	f8c8 5004 	str.w	r5, [r8, #4]
    6a44:	604a      	str	r2, [r1, #4]
    6a46:	685a      	ldr	r2, [r3, #4]
    6a48:	f042 0201 	orr.w	r2, r2, #1
    6a4c:	3108      	adds	r1, #8
    6a4e:	605a      	str	r2, [r3, #4]
    6a50:	4648      	mov	r0, r9
    6a52:	f000 fd19 	bl	7488 <_free_r>
    6a56:	e7d7      	b.n	6a08 <_realloc_r+0x140>
    6a58:	4611      	mov	r1, r2
    6a5a:	b003      	add	sp, #12
    6a5c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6a60:	f7ff bb0c 	b.w	607c <_malloc_r>
    6a64:	f01e 0f01 	tst.w	lr, #1
    6a68:	f47f af5a 	bne.w	6920 <_realloc_r+0x58>
    6a6c:	f856 3c08 	ldr.w	r3, [r6, #-8]
    6a70:	ebc3 0a08 	rsb	sl, r3, r8
    6a74:	f8da 3004 	ldr.w	r3, [sl, #4]
    6a78:	f023 0c03 	bic.w	ip, r3, #3
    6a7c:	eb01 0e0c 	add.w	lr, r1, ip
    6a80:	4596      	cmp	lr, r2
    6a82:	db8b      	blt.n	699c <_realloc_r+0xd4>
    6a84:	68c3      	ldr	r3, [r0, #12]
    6a86:	6882      	ldr	r2, [r0, #8]
    6a88:	4657      	mov	r7, sl
    6a8a:	60d3      	str	r3, [r2, #12]
    6a8c:	609a      	str	r2, [r3, #8]
    6a8e:	f857 1f08 	ldr.w	r1, [r7, #8]!
    6a92:	f8da 300c 	ldr.w	r3, [sl, #12]
    6a96:	60cb      	str	r3, [r1, #12]
    6a98:	1f22      	subs	r2, r4, #4
    6a9a:	2a24      	cmp	r2, #36	; 0x24
    6a9c:	6099      	str	r1, [r3, #8]
    6a9e:	f200 8099 	bhi.w	6bd4 <_realloc_r+0x30c>
    6aa2:	2a13      	cmp	r2, #19
    6aa4:	d962      	bls.n	6b6c <_realloc_r+0x2a4>
    6aa6:	6833      	ldr	r3, [r6, #0]
    6aa8:	f8ca 3008 	str.w	r3, [sl, #8]
    6aac:	6873      	ldr	r3, [r6, #4]
    6aae:	f8ca 300c 	str.w	r3, [sl, #12]
    6ab2:	2a1b      	cmp	r2, #27
    6ab4:	f200 80a0 	bhi.w	6bf8 <_realloc_r+0x330>
    6ab8:	3608      	adds	r6, #8
    6aba:	f10a 0310 	add.w	r3, sl, #16
    6abe:	e056      	b.n	6b6e <_realloc_r+0x2a6>
    6ac0:	f021 0b03 	bic.w	fp, r1, #3
    6ac4:	44a3      	add	fp, r4
    6ac6:	f105 0010 	add.w	r0, r5, #16
    6aca:	4583      	cmp	fp, r0
    6acc:	da59      	bge.n	6b82 <_realloc_r+0x2ba>
    6ace:	f01e 0f01 	tst.w	lr, #1
    6ad2:	f47f af25 	bne.w	6920 <_realloc_r+0x58>
    6ad6:	f856 1c08 	ldr.w	r1, [r6, #-8]
    6ada:	ebc1 0a08 	rsb	sl, r1, r8
    6ade:	f8da 1004 	ldr.w	r1, [sl, #4]
    6ae2:	f021 0c03 	bic.w	ip, r1, #3
    6ae6:	44e3      	add	fp, ip
    6ae8:	4558      	cmp	r0, fp
    6aea:	f73f af57 	bgt.w	699c <_realloc_r+0xd4>
    6aee:	4657      	mov	r7, sl
    6af0:	f8da 100c 	ldr.w	r1, [sl, #12]
    6af4:	f857 0f08 	ldr.w	r0, [r7, #8]!
    6af8:	1f22      	subs	r2, r4, #4
    6afa:	2a24      	cmp	r2, #36	; 0x24
    6afc:	60c1      	str	r1, [r0, #12]
    6afe:	6088      	str	r0, [r1, #8]
    6b00:	f200 80b4 	bhi.w	6c6c <_realloc_r+0x3a4>
    6b04:	2a13      	cmp	r2, #19
    6b06:	f240 80a5 	bls.w	6c54 <_realloc_r+0x38c>
    6b0a:	6831      	ldr	r1, [r6, #0]
    6b0c:	f8ca 1008 	str.w	r1, [sl, #8]
    6b10:	6871      	ldr	r1, [r6, #4]
    6b12:	f8ca 100c 	str.w	r1, [sl, #12]
    6b16:	2a1b      	cmp	r2, #27
    6b18:	f200 80af 	bhi.w	6c7a <_realloc_r+0x3b2>
    6b1c:	3608      	adds	r6, #8
    6b1e:	f10a 0210 	add.w	r2, sl, #16
    6b22:	6831      	ldr	r1, [r6, #0]
    6b24:	6011      	str	r1, [r2, #0]
    6b26:	6871      	ldr	r1, [r6, #4]
    6b28:	6051      	str	r1, [r2, #4]
    6b2a:	68b1      	ldr	r1, [r6, #8]
    6b2c:	6091      	str	r1, [r2, #8]
    6b2e:	eb0a 0105 	add.w	r1, sl, r5
    6b32:	ebc5 020b 	rsb	r2, r5, fp
    6b36:	f042 0201 	orr.w	r2, r2, #1
    6b3a:	6099      	str	r1, [r3, #8]
    6b3c:	604a      	str	r2, [r1, #4]
    6b3e:	f8da 3004 	ldr.w	r3, [sl, #4]
    6b42:	f003 0301 	and.w	r3, r3, #1
    6b46:	431d      	orrs	r5, r3
    6b48:	4648      	mov	r0, r9
    6b4a:	f8ca 5004 	str.w	r5, [sl, #4]
    6b4e:	f7ff feb1 	bl	68b4 <__malloc_unlock>
    6b52:	4638      	mov	r0, r7
    6b54:	e75c      	b.n	6a10 <_realloc_r+0x148>
    6b56:	6833      	ldr	r3, [r6, #0]
    6b58:	6003      	str	r3, [r0, #0]
    6b5a:	6873      	ldr	r3, [r6, #4]
    6b5c:	6043      	str	r3, [r0, #4]
    6b5e:	2a1b      	cmp	r2, #27
    6b60:	d827      	bhi.n	6bb2 <_realloc_r+0x2ea>
    6b62:	f100 0308 	add.w	r3, r0, #8
    6b66:	f106 0208 	add.w	r2, r6, #8
    6b6a:	e6f2      	b.n	6952 <_realloc_r+0x8a>
    6b6c:	463b      	mov	r3, r7
    6b6e:	6832      	ldr	r2, [r6, #0]
    6b70:	601a      	str	r2, [r3, #0]
    6b72:	6872      	ldr	r2, [r6, #4]
    6b74:	605a      	str	r2, [r3, #4]
    6b76:	68b2      	ldr	r2, [r6, #8]
    6b78:	609a      	str	r2, [r3, #8]
    6b7a:	463e      	mov	r6, r7
    6b7c:	4674      	mov	r4, lr
    6b7e:	46d0      	mov	r8, sl
    6b80:	e733      	b.n	69ea <_realloc_r+0x122>
    6b82:	eb08 0105 	add.w	r1, r8, r5
    6b86:	ebc5 0b0b 	rsb	fp, r5, fp
    6b8a:	f04b 0201 	orr.w	r2, fp, #1
    6b8e:	6099      	str	r1, [r3, #8]
    6b90:	604a      	str	r2, [r1, #4]
    6b92:	f856 3c04 	ldr.w	r3, [r6, #-4]
    6b96:	f003 0301 	and.w	r3, r3, #1
    6b9a:	431d      	orrs	r5, r3
    6b9c:	4648      	mov	r0, r9
    6b9e:	f846 5c04 	str.w	r5, [r6, #-4]
    6ba2:	f7ff fe87 	bl	68b4 <__malloc_unlock>
    6ba6:	4630      	mov	r0, r6
    6ba8:	e732      	b.n	6a10 <_realloc_r+0x148>
    6baa:	4631      	mov	r1, r6
    6bac:	f7ff fdce 	bl	674c <memmove>
    6bb0:	e6d5      	b.n	695e <_realloc_r+0x96>
    6bb2:	68b3      	ldr	r3, [r6, #8]
    6bb4:	6083      	str	r3, [r0, #8]
    6bb6:	68f3      	ldr	r3, [r6, #12]
    6bb8:	60c3      	str	r3, [r0, #12]
    6bba:	2a24      	cmp	r2, #36	; 0x24
    6bbc:	d028      	beq.n	6c10 <_realloc_r+0x348>
    6bbe:	f100 0310 	add.w	r3, r0, #16
    6bc2:	f106 0210 	add.w	r2, r6, #16
    6bc6:	e6c4      	b.n	6952 <_realloc_r+0x8a>
    6bc8:	f850 3c04 	ldr.w	r3, [r0, #-4]
    6bcc:	f023 0303 	bic.w	r3, r3, #3
    6bd0:	441c      	add	r4, r3
    6bd2:	e70a      	b.n	69ea <_realloc_r+0x122>
    6bd4:	4631      	mov	r1, r6
    6bd6:	4638      	mov	r0, r7
    6bd8:	4674      	mov	r4, lr
    6bda:	46d0      	mov	r8, sl
    6bdc:	f7ff fdb6 	bl	674c <memmove>
    6be0:	463e      	mov	r6, r7
    6be2:	e702      	b.n	69ea <_realloc_r+0x122>
    6be4:	463a      	mov	r2, r7
    6be6:	e6f7      	b.n	69d8 <_realloc_r+0x110>
    6be8:	4631      	mov	r1, r6
    6bea:	4638      	mov	r0, r7
    6bec:	461c      	mov	r4, r3
    6bee:	46d0      	mov	r8, sl
    6bf0:	f7ff fdac 	bl	674c <memmove>
    6bf4:	463e      	mov	r6, r7
    6bf6:	e6f8      	b.n	69ea <_realloc_r+0x122>
    6bf8:	68b3      	ldr	r3, [r6, #8]
    6bfa:	f8ca 3010 	str.w	r3, [sl, #16]
    6bfe:	68f3      	ldr	r3, [r6, #12]
    6c00:	f8ca 3014 	str.w	r3, [sl, #20]
    6c04:	2a24      	cmp	r2, #36	; 0x24
    6c06:	d01b      	beq.n	6c40 <_realloc_r+0x378>
    6c08:	3610      	adds	r6, #16
    6c0a:	f10a 0318 	add.w	r3, sl, #24
    6c0e:	e7ae      	b.n	6b6e <_realloc_r+0x2a6>
    6c10:	6933      	ldr	r3, [r6, #16]
    6c12:	6103      	str	r3, [r0, #16]
    6c14:	6973      	ldr	r3, [r6, #20]
    6c16:	6143      	str	r3, [r0, #20]
    6c18:	f106 0218 	add.w	r2, r6, #24
    6c1c:	f100 0318 	add.w	r3, r0, #24
    6c20:	e697      	b.n	6952 <_realloc_r+0x8a>
    6c22:	bf00      	nop
    6c24:	200019c8 	.word	0x200019c8
    6c28:	68b1      	ldr	r1, [r6, #8]
    6c2a:	f8ca 1010 	str.w	r1, [sl, #16]
    6c2e:	68f1      	ldr	r1, [r6, #12]
    6c30:	f8ca 1014 	str.w	r1, [sl, #20]
    6c34:	2a24      	cmp	r2, #36	; 0x24
    6c36:	d00f      	beq.n	6c58 <_realloc_r+0x390>
    6c38:	3610      	adds	r6, #16
    6c3a:	f10a 0218 	add.w	r2, sl, #24
    6c3e:	e6cb      	b.n	69d8 <_realloc_r+0x110>
    6c40:	6933      	ldr	r3, [r6, #16]
    6c42:	f8ca 3018 	str.w	r3, [sl, #24]
    6c46:	6973      	ldr	r3, [r6, #20]
    6c48:	f8ca 301c 	str.w	r3, [sl, #28]
    6c4c:	3618      	adds	r6, #24
    6c4e:	f10a 0320 	add.w	r3, sl, #32
    6c52:	e78c      	b.n	6b6e <_realloc_r+0x2a6>
    6c54:	463a      	mov	r2, r7
    6c56:	e764      	b.n	6b22 <_realloc_r+0x25a>
    6c58:	6932      	ldr	r2, [r6, #16]
    6c5a:	f8ca 2018 	str.w	r2, [sl, #24]
    6c5e:	6972      	ldr	r2, [r6, #20]
    6c60:	f8ca 201c 	str.w	r2, [sl, #28]
    6c64:	3618      	adds	r6, #24
    6c66:	f10a 0220 	add.w	r2, sl, #32
    6c6a:	e6b5      	b.n	69d8 <_realloc_r+0x110>
    6c6c:	4631      	mov	r1, r6
    6c6e:	4638      	mov	r0, r7
    6c70:	9301      	str	r3, [sp, #4]
    6c72:	f7ff fd6b 	bl	674c <memmove>
    6c76:	9b01      	ldr	r3, [sp, #4]
    6c78:	e759      	b.n	6b2e <_realloc_r+0x266>
    6c7a:	68b1      	ldr	r1, [r6, #8]
    6c7c:	f8ca 1010 	str.w	r1, [sl, #16]
    6c80:	68f1      	ldr	r1, [r6, #12]
    6c82:	f8ca 1014 	str.w	r1, [sl, #20]
    6c86:	2a24      	cmp	r2, #36	; 0x24
    6c88:	d003      	beq.n	6c92 <_realloc_r+0x3ca>
    6c8a:	3610      	adds	r6, #16
    6c8c:	f10a 0218 	add.w	r2, sl, #24
    6c90:	e747      	b.n	6b22 <_realloc_r+0x25a>
    6c92:	6932      	ldr	r2, [r6, #16]
    6c94:	f8ca 2018 	str.w	r2, [sl, #24]
    6c98:	6972      	ldr	r2, [r6, #20]
    6c9a:	f8ca 201c 	str.w	r2, [sl, #28]
    6c9e:	3618      	adds	r6, #24
    6ca0:	f10a 0220 	add.w	r2, sl, #32
    6ca4:	e73d      	b.n	6b22 <_realloc_r+0x25a>
    6ca6:	bf00      	nop

00006ca8 <_sbrk_r>:
    6ca8:	b538      	push	{r3, r4, r5, lr}
    6caa:	4c07      	ldr	r4, [pc, #28]	; (6cc8 <_sbrk_r+0x20>)
    6cac:	2300      	movs	r3, #0
    6cae:	4605      	mov	r5, r0
    6cb0:	4608      	mov	r0, r1
    6cb2:	6023      	str	r3, [r4, #0]
    6cb4:	f7fa fe34 	bl	1920 <_sbrk>
    6cb8:	1c43      	adds	r3, r0, #1
    6cba:	d000      	beq.n	6cbe <_sbrk_r+0x16>
    6cbc:	bd38      	pop	{r3, r4, r5, pc}
    6cbe:	6823      	ldr	r3, [r4, #0]
    6cc0:	2b00      	cmp	r3, #0
    6cc2:	d0fb      	beq.n	6cbc <_sbrk_r+0x14>
    6cc4:	602b      	str	r3, [r5, #0]
    6cc6:	bd38      	pop	{r3, r4, r5, pc}
    6cc8:	200027b4 	.word	0x200027b4
	...
    6ce0:	eba2 0003 	sub.w	r0, r2, r3
    6ce4:	4770      	bx	lr
    6ce6:	bf00      	nop

00006ce8 <strcmp>:
    6ce8:	7802      	ldrb	r2, [r0, #0]
    6cea:	780b      	ldrb	r3, [r1, #0]
    6cec:	2a01      	cmp	r2, #1
    6cee:	bf28      	it	cs
    6cf0:	429a      	cmpcs	r2, r3
    6cf2:	d1f5      	bne.n	6ce0 <_sbrk_r+0x38>
    6cf4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
    6cf8:	ea40 0401 	orr.w	r4, r0, r1
    6cfc:	e9cd 6702 	strd	r6, r7, [sp, #8]
    6d00:	f06f 0c00 	mvn.w	ip, #0
    6d04:	ea4f 7244 	mov.w	r2, r4, lsl #29
    6d08:	b312      	cbz	r2, 6d50 <strcmp+0x68>
    6d0a:	ea80 0401 	eor.w	r4, r0, r1
    6d0e:	f014 0f07 	tst.w	r4, #7
    6d12:	d16a      	bne.n	6dea <strcmp+0x102>
    6d14:	f000 0407 	and.w	r4, r0, #7
    6d18:	f020 0007 	bic.w	r0, r0, #7
    6d1c:	f004 0503 	and.w	r5, r4, #3
    6d20:	f021 0107 	bic.w	r1, r1, #7
    6d24:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    6d28:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    6d2c:	f014 0f04 	tst.w	r4, #4
    6d30:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    6d34:	fa0c f405 	lsl.w	r4, ip, r5
    6d38:	ea62 0204 	orn	r2, r2, r4
    6d3c:	ea66 0604 	orn	r6, r6, r4
    6d40:	d00a      	beq.n	6d58 <strcmp+0x70>
    6d42:	ea63 0304 	orn	r3, r3, r4
    6d46:	4662      	mov	r2, ip
    6d48:	ea67 0704 	orn	r7, r7, r4
    6d4c:	4666      	mov	r6, ip
    6d4e:	e003      	b.n	6d58 <strcmp+0x70>
    6d50:	e8f0 2304 	ldrd	r2, r3, [r0], #16
    6d54:	e8f1 6704 	ldrd	r6, r7, [r1], #16
    6d58:	fa82 f54c 	uadd8	r5, r2, ip
    6d5c:	ea82 0406 	eor.w	r4, r2, r6
    6d60:	faa4 f48c 	sel	r4, r4, ip
    6d64:	bb6c      	cbnz	r4, 6dc2 <strcmp+0xda>
    6d66:	fa83 f54c 	uadd8	r5, r3, ip
    6d6a:	ea83 0507 	eor.w	r5, r3, r7
    6d6e:	faa5 f58c 	sel	r5, r5, ip
    6d72:	b995      	cbnz	r5, 6d9a <strcmp+0xb2>
    6d74:	e950 2302 	ldrd	r2, r3, [r0, #-8]
    6d78:	e951 6702 	ldrd	r6, r7, [r1, #-8]
    6d7c:	fa82 f54c 	uadd8	r5, r2, ip
    6d80:	ea82 0406 	eor.w	r4, r2, r6
    6d84:	faa4 f48c 	sel	r4, r4, ip
    6d88:	fa83 f54c 	uadd8	r5, r3, ip
    6d8c:	ea83 0507 	eor.w	r5, r3, r7
    6d90:	faa5 f58c 	sel	r5, r5, ip
    6d94:	4325      	orrs	r5, r4
    6d96:	d0db      	beq.n	6d50 <strcmp+0x68>
    6d98:	b99c      	cbnz	r4, 6dc2 <strcmp+0xda>
    6d9a:	ba2d      	rev	r5, r5
    6d9c:	fab5 f485 	clz	r4, r5
    6da0:	f024 0407 	bic.w	r4, r4, #7
    6da4:	fa27 f104 	lsr.w	r1, r7, r4
    6da8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    6dac:	fa23 f304 	lsr.w	r3, r3, r4
    6db0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    6db4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6db8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6dbc:	eba0 0001 	sub.w	r0, r0, r1
    6dc0:	4770      	bx	lr
    6dc2:	ba24      	rev	r4, r4
    6dc4:	fab4 f484 	clz	r4, r4
    6dc8:	f024 0407 	bic.w	r4, r4, #7
    6dcc:	fa26 f104 	lsr.w	r1, r6, r4
    6dd0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    6dd4:	fa22 f204 	lsr.w	r2, r2, r4
    6dd8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    6ddc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6de0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6de4:	eba0 0001 	sub.w	r0, r0, r1
    6de8:	4770      	bx	lr
    6dea:	f014 0f03 	tst.w	r4, #3
    6dee:	d13c      	bne.n	6e6a <strcmp+0x182>
    6df0:	f010 0403 	ands.w	r4, r0, #3
    6df4:	d128      	bne.n	6e48 <strcmp+0x160>
    6df6:	f850 2b08 	ldr.w	r2, [r0], #8
    6dfa:	f851 3b08 	ldr.w	r3, [r1], #8
    6dfe:	fa82 f54c 	uadd8	r5, r2, ip
    6e02:	ea82 0503 	eor.w	r5, r2, r3
    6e06:	faa5 f58c 	sel	r5, r5, ip
    6e0a:	b95d      	cbnz	r5, 6e24 <strcmp+0x13c>
    6e0c:	f850 2c04 	ldr.w	r2, [r0, #-4]
    6e10:	f851 3c04 	ldr.w	r3, [r1, #-4]
    6e14:	fa82 f54c 	uadd8	r5, r2, ip
    6e18:	ea82 0503 	eor.w	r5, r2, r3
    6e1c:	faa5 f58c 	sel	r5, r5, ip
    6e20:	2d00      	cmp	r5, #0
    6e22:	d0e8      	beq.n	6df6 <strcmp+0x10e>
    6e24:	ba2d      	rev	r5, r5
    6e26:	fab5 f485 	clz	r4, r5
    6e2a:	f024 0407 	bic.w	r4, r4, #7
    6e2e:	fa23 f104 	lsr.w	r1, r3, r4
    6e32:	fa22 f204 	lsr.w	r2, r2, r4
    6e36:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    6e3a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    6e3e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6e42:	eba0 0001 	sub.w	r0, r0, r1
    6e46:	4770      	bx	lr
    6e48:	ea4f 04c4 	mov.w	r4, r4, lsl #3
    6e4c:	f020 0003 	bic.w	r0, r0, #3
    6e50:	f850 2b08 	ldr.w	r2, [r0], #8
    6e54:	f021 0103 	bic.w	r1, r1, #3
    6e58:	f851 3b08 	ldr.w	r3, [r1], #8
    6e5c:	fa0c f404 	lsl.w	r4, ip, r4
    6e60:	ea62 0204 	orn	r2, r2, r4
    6e64:	ea63 0304 	orn	r3, r3, r4
    6e68:	e7c9      	b.n	6dfe <strcmp+0x116>
    6e6a:	f010 0403 	ands.w	r4, r0, #3
    6e6e:	d01a      	beq.n	6ea6 <strcmp+0x1be>
    6e70:	eba1 0104 	sub.w	r1, r1, r4
    6e74:	f020 0003 	bic.w	r0, r0, #3
    6e78:	07e4      	lsls	r4, r4, #31
    6e7a:	f850 2b04 	ldr.w	r2, [r0], #4
    6e7e:	d006      	beq.n	6e8e <strcmp+0x1a6>
    6e80:	d20f      	bcs.n	6ea2 <strcmp+0x1ba>
    6e82:	788b      	ldrb	r3, [r1, #2]
    6e84:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
    6e88:	1ae4      	subs	r4, r4, r3
    6e8a:	d106      	bne.n	6e9a <strcmp+0x1b2>
    6e8c:	b12b      	cbz	r3, 6e9a <strcmp+0x1b2>
    6e8e:	78cb      	ldrb	r3, [r1, #3]
    6e90:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
    6e94:	1ae4      	subs	r4, r4, r3
    6e96:	d100      	bne.n	6e9a <strcmp+0x1b2>
    6e98:	b91b      	cbnz	r3, 6ea2 <strcmp+0x1ba>
    6e9a:	4620      	mov	r0, r4
    6e9c:	f85d 4b10 	ldr.w	r4, [sp], #16
    6ea0:	4770      	bx	lr
    6ea2:	f101 0104 	add.w	r1, r1, #4
    6ea6:	f850 2b04 	ldr.w	r2, [r0], #4
    6eaa:	07cc      	lsls	r4, r1, #31
    6eac:	f021 0103 	bic.w	r1, r1, #3
    6eb0:	f851 3b04 	ldr.w	r3, [r1], #4
    6eb4:	d848      	bhi.n	6f48 <strcmp+0x260>
    6eb6:	d224      	bcs.n	6f02 <strcmp+0x21a>
    6eb8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
    6ebc:	fa82 f54c 	uadd8	r5, r2, ip
    6ec0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
    6ec4:	faa5 f58c 	sel	r5, r5, ip
    6ec8:	d10a      	bne.n	6ee0 <strcmp+0x1f8>
    6eca:	b965      	cbnz	r5, 6ee6 <strcmp+0x1fe>
    6ecc:	f851 3b04 	ldr.w	r3, [r1], #4
    6ed0:	ea84 0402 	eor.w	r4, r4, r2
    6ed4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
    6ed8:	d10e      	bne.n	6ef8 <strcmp+0x210>
    6eda:	f850 2b04 	ldr.w	r2, [r0], #4
    6ede:	e7eb      	b.n	6eb8 <strcmp+0x1d0>
    6ee0:	ea4f 2313 	mov.w	r3, r3, lsr #8
    6ee4:	e055      	b.n	6f92 <strcmp+0x2aa>
    6ee6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
    6eea:	d14d      	bne.n	6f88 <strcmp+0x2a0>
    6eec:	7808      	ldrb	r0, [r1, #0]
    6eee:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6ef2:	f1c0 0000 	rsb	r0, r0, #0
    6ef6:	4770      	bx	lr
    6ef8:	ea4f 6212 	mov.w	r2, r2, lsr #24
    6efc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    6f00:	e047      	b.n	6f92 <strcmp+0x2aa>
    6f02:	ea02 441c 	and.w	r4, r2, ip, lsr #16
    6f06:	fa82 f54c 	uadd8	r5, r2, ip
    6f0a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
    6f0e:	faa5 f58c 	sel	r5, r5, ip
    6f12:	d10a      	bne.n	6f2a <strcmp+0x242>
    6f14:	b965      	cbnz	r5, 6f30 <strcmp+0x248>
    6f16:	f851 3b04 	ldr.w	r3, [r1], #4
    6f1a:	ea84 0402 	eor.w	r4, r4, r2
    6f1e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
    6f22:	d10c      	bne.n	6f3e <strcmp+0x256>
    6f24:	f850 2b04 	ldr.w	r2, [r0], #4
    6f28:	e7eb      	b.n	6f02 <strcmp+0x21a>
    6f2a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    6f2e:	e030      	b.n	6f92 <strcmp+0x2aa>
    6f30:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
    6f34:	d128      	bne.n	6f88 <strcmp+0x2a0>
    6f36:	880b      	ldrh	r3, [r1, #0]
    6f38:	ea4f 4212 	mov.w	r2, r2, lsr #16
    6f3c:	e029      	b.n	6f92 <strcmp+0x2aa>
    6f3e:	ea4f 4212 	mov.w	r2, r2, lsr #16
    6f42:	ea03 431c 	and.w	r3, r3, ip, lsr #16
    6f46:	e024      	b.n	6f92 <strcmp+0x2aa>
    6f48:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    6f4c:	fa82 f54c 	uadd8	r5, r2, ip
    6f50:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
    6f54:	faa5 f58c 	sel	r5, r5, ip
    6f58:	d10a      	bne.n	6f70 <strcmp+0x288>
    6f5a:	b965      	cbnz	r5, 6f76 <strcmp+0x28e>
    6f5c:	f851 3b04 	ldr.w	r3, [r1], #4
    6f60:	ea84 0402 	eor.w	r4, r4, r2
    6f64:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
    6f68:	d109      	bne.n	6f7e <strcmp+0x296>
    6f6a:	f850 2b04 	ldr.w	r2, [r0], #4
    6f6e:	e7eb      	b.n	6f48 <strcmp+0x260>
    6f70:	ea4f 6313 	mov.w	r3, r3, lsr #24
    6f74:	e00d      	b.n	6f92 <strcmp+0x2aa>
    6f76:	f015 0fff 	tst.w	r5, #255	; 0xff
    6f7a:	d105      	bne.n	6f88 <strcmp+0x2a0>
    6f7c:	680b      	ldr	r3, [r1, #0]
    6f7e:	ea4f 2212 	mov.w	r2, r2, lsr #8
    6f82:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    6f86:	e004      	b.n	6f92 <strcmp+0x2aa>
    6f88:	f04f 0000 	mov.w	r0, #0
    6f8c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6f90:	4770      	bx	lr
    6f92:	ba12      	rev	r2, r2
    6f94:	ba1b      	rev	r3, r3
    6f96:	fa82 f44c 	uadd8	r4, r2, ip
    6f9a:	ea82 0403 	eor.w	r4, r2, r3
    6f9e:	faa4 f58c 	sel	r5, r4, ip
    6fa2:	fab5 f485 	clz	r4, r5
    6fa6:	fa02 f204 	lsl.w	r2, r2, r4
    6faa:	fa03 f304 	lsl.w	r3, r3, r4
    6fae:	ea4f 6012 	mov.w	r0, r2, lsr #24
    6fb2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
    6fb6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
    6fba:	4770      	bx	lr

00006fbc <strcpy>:
    6fbc:	ea80 0201 	eor.w	r2, r0, r1
    6fc0:	4684      	mov	ip, r0
    6fc2:	f012 0f03 	tst.w	r2, #3
    6fc6:	d14f      	bne.n	7068 <strcpy+0xac>
    6fc8:	f011 0f03 	tst.w	r1, #3
    6fcc:	d132      	bne.n	7034 <strcpy+0x78>
    6fce:	f84d 4d04 	str.w	r4, [sp, #-4]!
    6fd2:	f011 0f04 	tst.w	r1, #4
    6fd6:	f851 3b04 	ldr.w	r3, [r1], #4
    6fda:	d00b      	beq.n	6ff4 <strcpy+0x38>
    6fdc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    6fe0:	439a      	bics	r2, r3
    6fe2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    6fe6:	bf04      	itt	eq
    6fe8:	f84c 3b04 	streq.w	r3, [ip], #4
    6fec:	f851 3b04 	ldreq.w	r3, [r1], #4
    6ff0:	d116      	bne.n	7020 <strcpy+0x64>
    6ff2:	bf00      	nop
    6ff4:	f851 4b04 	ldr.w	r4, [r1], #4
    6ff8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    6ffc:	439a      	bics	r2, r3
    6ffe:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    7002:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    7006:	d10b      	bne.n	7020 <strcpy+0x64>
    7008:	f84c 3b04 	str.w	r3, [ip], #4
    700c:	43a2      	bics	r2, r4
    700e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    7012:	bf04      	itt	eq
    7014:	f851 3b04 	ldreq.w	r3, [r1], #4
    7018:	f84c 4b04 	streq.w	r4, [ip], #4
    701c:	d0ea      	beq.n	6ff4 <strcpy+0x38>
    701e:	4623      	mov	r3, r4
    7020:	f80c 3b01 	strb.w	r3, [ip], #1
    7024:	f013 0fff 	tst.w	r3, #255	; 0xff
    7028:	ea4f 2333 	mov.w	r3, r3, ror #8
    702c:	d1f8      	bne.n	7020 <strcpy+0x64>
    702e:	f85d 4b04 	ldr.w	r4, [sp], #4
    7032:	4770      	bx	lr
    7034:	f011 0f01 	tst.w	r1, #1
    7038:	d006      	beq.n	7048 <strcpy+0x8c>
    703a:	f811 2b01 	ldrb.w	r2, [r1], #1
    703e:	f80c 2b01 	strb.w	r2, [ip], #1
    7042:	2a00      	cmp	r2, #0
    7044:	bf08      	it	eq
    7046:	4770      	bxeq	lr
    7048:	f011 0f02 	tst.w	r1, #2
    704c:	d0bf      	beq.n	6fce <strcpy+0x12>
    704e:	f831 2b02 	ldrh.w	r2, [r1], #2
    7052:	f012 0fff 	tst.w	r2, #255	; 0xff
    7056:	bf16      	itet	ne
    7058:	f82c 2b02 	strhne.w	r2, [ip], #2
    705c:	f88c 2000 	strbeq.w	r2, [ip]
    7060:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    7064:	d1b3      	bne.n	6fce <strcpy+0x12>
    7066:	4770      	bx	lr
    7068:	f811 2b01 	ldrb.w	r2, [r1], #1
    706c:	f80c 2b01 	strb.w	r2, [ip], #1
    7070:	2a00      	cmp	r2, #0
    7072:	d1f9      	bne.n	7068 <strcpy+0xac>
    7074:	4770      	bx	lr
    7076:	bf00      	nop
	...

00007080 <strlen>:
    7080:	f890 f000 	pld	[r0]
    7084:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    7088:	f020 0107 	bic.w	r1, r0, #7
    708c:	f06f 0c00 	mvn.w	ip, #0
    7090:	f010 0407 	ands.w	r4, r0, #7
    7094:	f891 f020 	pld	[r1, #32]
    7098:	f040 8049 	bne.w	712e <strlen+0xae>
    709c:	f04f 0400 	mov.w	r4, #0
    70a0:	f06f 0007 	mvn.w	r0, #7
    70a4:	e9d1 2300 	ldrd	r2, r3, [r1]
    70a8:	f891 f040 	pld	[r1, #64]	; 0x40
    70ac:	f100 0008 	add.w	r0, r0, #8
    70b0:	fa82 f24c 	uadd8	r2, r2, ip
    70b4:	faa4 f28c 	sel	r2, r4, ip
    70b8:	fa83 f34c 	uadd8	r3, r3, ip
    70bc:	faa2 f38c 	sel	r3, r2, ip
    70c0:	bb4b      	cbnz	r3, 7116 <strlen+0x96>
    70c2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    70c6:	fa82 f24c 	uadd8	r2, r2, ip
    70ca:	f100 0008 	add.w	r0, r0, #8
    70ce:	faa4 f28c 	sel	r2, r4, ip
    70d2:	fa83 f34c 	uadd8	r3, r3, ip
    70d6:	faa2 f38c 	sel	r3, r2, ip
    70da:	b9e3      	cbnz	r3, 7116 <strlen+0x96>
    70dc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    70e0:	fa82 f24c 	uadd8	r2, r2, ip
    70e4:	f100 0008 	add.w	r0, r0, #8
    70e8:	faa4 f28c 	sel	r2, r4, ip
    70ec:	fa83 f34c 	uadd8	r3, r3, ip
    70f0:	faa2 f38c 	sel	r3, r2, ip
    70f4:	b97b      	cbnz	r3, 7116 <strlen+0x96>
    70f6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    70fa:	f101 0120 	add.w	r1, r1, #32
    70fe:	fa82 f24c 	uadd8	r2, r2, ip
    7102:	f100 0008 	add.w	r0, r0, #8
    7106:	faa4 f28c 	sel	r2, r4, ip
    710a:	fa83 f34c 	uadd8	r3, r3, ip
    710e:	faa2 f38c 	sel	r3, r2, ip
    7112:	2b00      	cmp	r3, #0
    7114:	d0c6      	beq.n	70a4 <strlen+0x24>
    7116:	2a00      	cmp	r2, #0
    7118:	bf04      	itt	eq
    711a:	3004      	addeq	r0, #4
    711c:	461a      	moveq	r2, r3
    711e:	ba12      	rev	r2, r2
    7120:	fab2 f282 	clz	r2, r2
    7124:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    7128:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    712c:	4770      	bx	lr
    712e:	e9d1 2300 	ldrd	r2, r3, [r1]
    7132:	f004 0503 	and.w	r5, r4, #3
    7136:	f1c4 0000 	rsb	r0, r4, #0
    713a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    713e:	f014 0f04 	tst.w	r4, #4
    7142:	f891 f040 	pld	[r1, #64]	; 0x40
    7146:	fa0c f505 	lsl.w	r5, ip, r5
    714a:	ea62 0205 	orn	r2, r2, r5
    714e:	bf1c      	itt	ne
    7150:	ea63 0305 	ornne	r3, r3, r5
    7154:	4662      	movne	r2, ip
    7156:	f04f 0400 	mov.w	r4, #0
    715a:	e7a9      	b.n	70b0 <strlen+0x30>

0000715c <strncpy>:
    715c:	ea40 0301 	orr.w	r3, r0, r1
    7160:	079b      	lsls	r3, r3, #30
    7162:	b470      	push	{r4, r5, r6}
    7164:	d12b      	bne.n	71be <strncpy+0x62>
    7166:	2a03      	cmp	r2, #3
    7168:	d929      	bls.n	71be <strncpy+0x62>
    716a:	460c      	mov	r4, r1
    716c:	4603      	mov	r3, r0
    716e:	4621      	mov	r1, r4
    7170:	f854 6b04 	ldr.w	r6, [r4], #4
    7174:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
    7178:	ea25 0506 	bic.w	r5, r5, r6
    717c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
    7180:	d106      	bne.n	7190 <strncpy+0x34>
    7182:	3a04      	subs	r2, #4
    7184:	2a03      	cmp	r2, #3
    7186:	f843 6b04 	str.w	r6, [r3], #4
    718a:	4621      	mov	r1, r4
    718c:	d8ef      	bhi.n	716e <strncpy+0x12>
    718e:	b1a2      	cbz	r2, 71ba <strncpy+0x5e>
    7190:	780c      	ldrb	r4, [r1, #0]
    7192:	701c      	strb	r4, [r3, #0]
    7194:	3a01      	subs	r2, #1
    7196:	3301      	adds	r3, #1
    7198:	3101      	adds	r1, #1
    719a:	b13c      	cbz	r4, 71ac <strncpy+0x50>
    719c:	b16a      	cbz	r2, 71ba <strncpy+0x5e>
    719e:	f811 4b01 	ldrb.w	r4, [r1], #1
    71a2:	f803 4b01 	strb.w	r4, [r3], #1
    71a6:	3a01      	subs	r2, #1
    71a8:	2c00      	cmp	r4, #0
    71aa:	d1f7      	bne.n	719c <strncpy+0x40>
    71ac:	b12a      	cbz	r2, 71ba <strncpy+0x5e>
    71ae:	441a      	add	r2, r3
    71b0:	2100      	movs	r1, #0
    71b2:	f803 1b01 	strb.w	r1, [r3], #1
    71b6:	429a      	cmp	r2, r3
    71b8:	d1fb      	bne.n	71b2 <strncpy+0x56>
    71ba:	bc70      	pop	{r4, r5, r6}
    71bc:	4770      	bx	lr
    71be:	4603      	mov	r3, r0
    71c0:	e7e5      	b.n	718e <strncpy+0x32>
    71c2:	bf00      	nop

000071c4 <_vdprintf_r>:
    71c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    71c6:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
    71ca:	ad04      	add	r5, sp, #16
    71cc:	9300      	str	r3, [sp, #0]
    71ce:	460f      	mov	r7, r1
    71d0:	4613      	mov	r3, r2
    71d2:	f44f 7400 	mov.w	r4, #512	; 0x200
    71d6:	aa03      	add	r2, sp, #12
    71d8:	4629      	mov	r1, r5
    71da:	9403      	str	r4, [sp, #12]
    71dc:	4606      	mov	r6, r0
    71de:	f000 fdb1 	bl	7d44 <_vasnprintf_r>
    71e2:	b188      	cbz	r0, 7208 <_vdprintf_r+0x44>
    71e4:	4604      	mov	r4, r0
    71e6:	4602      	mov	r2, r0
    71e8:	4639      	mov	r1, r7
    71ea:	9b03      	ldr	r3, [sp, #12]
    71ec:	4630      	mov	r0, r6
    71ee:	f000 f829 	bl	7244 <_write_r>
    71f2:	42ac      	cmp	r4, r5
    71f4:	9003      	str	r0, [sp, #12]
    71f6:	d004      	beq.n	7202 <_vdprintf_r+0x3e>
    71f8:	4630      	mov	r0, r6
    71fa:	4621      	mov	r1, r4
    71fc:	f000 f944 	bl	7488 <_free_r>
    7200:	9803      	ldr	r0, [sp, #12]
    7202:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
    7206:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7208:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    720c:	e7f9      	b.n	7202 <_vdprintf_r+0x3e>
    720e:	bf00      	nop

00007210 <vdprintf>:
    7210:	b410      	push	{r4}
    7212:	4c04      	ldr	r4, [pc, #16]	; (7224 <vdprintf+0x14>)
    7214:	4613      	mov	r3, r2
    7216:	460a      	mov	r2, r1
    7218:	4601      	mov	r1, r0
    721a:	6820      	ldr	r0, [r4, #0]
    721c:	f85d 4b04 	ldr.w	r4, [sp], #4
    7220:	f7ff bfd0 	b.w	71c4 <_vdprintf_r>
    7224:	20001dd8 	.word	0x20001dd8

00007228 <__ascii_wctomb>:
    7228:	b121      	cbz	r1, 7234 <__ascii_wctomb+0xc>
    722a:	2aff      	cmp	r2, #255	; 0xff
    722c:	d804      	bhi.n	7238 <__ascii_wctomb+0x10>
    722e:	700a      	strb	r2, [r1, #0]
    7230:	2001      	movs	r0, #1
    7232:	4770      	bx	lr
    7234:	4608      	mov	r0, r1
    7236:	4770      	bx	lr
    7238:	238a      	movs	r3, #138	; 0x8a
    723a:	6003      	str	r3, [r0, #0]
    723c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7240:	4770      	bx	lr
    7242:	bf00      	nop

00007244 <_write_r>:
    7244:	b570      	push	{r4, r5, r6, lr}
    7246:	460d      	mov	r5, r1
    7248:	4c08      	ldr	r4, [pc, #32]	; (726c <_write_r+0x28>)
    724a:	4611      	mov	r1, r2
    724c:	4606      	mov	r6, r0
    724e:	461a      	mov	r2, r3
    7250:	4628      	mov	r0, r5
    7252:	2300      	movs	r3, #0
    7254:	6023      	str	r3, [r4, #0]
    7256:	f7fb fb9d 	bl	2994 <_write>
    725a:	1c43      	adds	r3, r0, #1
    725c:	d000      	beq.n	7260 <_write_r+0x1c>
    725e:	bd70      	pop	{r4, r5, r6, pc}
    7260:	6823      	ldr	r3, [r4, #0]
    7262:	2b00      	cmp	r3, #0
    7264:	d0fb      	beq.n	725e <_write_r+0x1a>
    7266:	6033      	str	r3, [r6, #0]
    7268:	bd70      	pop	{r4, r5, r6, pc}
    726a:	bf00      	nop
    726c:	200027b4 	.word	0x200027b4

00007270 <__register_exitproc>:
    7270:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7274:	4c25      	ldr	r4, [pc, #148]	; (730c <__register_exitproc+0x9c>)
    7276:	6825      	ldr	r5, [r4, #0]
    7278:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    727c:	4606      	mov	r6, r0
    727e:	4688      	mov	r8, r1
    7280:	4692      	mov	sl, r2
    7282:	4699      	mov	r9, r3
    7284:	b3c4      	cbz	r4, 72f8 <__register_exitproc+0x88>
    7286:	6860      	ldr	r0, [r4, #4]
    7288:	281f      	cmp	r0, #31
    728a:	dc17      	bgt.n	72bc <__register_exitproc+0x4c>
    728c:	1c43      	adds	r3, r0, #1
    728e:	b176      	cbz	r6, 72ae <__register_exitproc+0x3e>
    7290:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    7294:	2201      	movs	r2, #1
    7296:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    729a:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    729e:	4082      	lsls	r2, r0
    72a0:	4311      	orrs	r1, r2
    72a2:	2e02      	cmp	r6, #2
    72a4:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    72a8:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    72ac:	d01e      	beq.n	72ec <__register_exitproc+0x7c>
    72ae:	3002      	adds	r0, #2
    72b0:	6063      	str	r3, [r4, #4]
    72b2:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    72b6:	2000      	movs	r0, #0
    72b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    72bc:	4b14      	ldr	r3, [pc, #80]	; (7310 <__register_exitproc+0xa0>)
    72be:	b303      	cbz	r3, 7302 <__register_exitproc+0x92>
    72c0:	f44f 70c8 	mov.w	r0, #400	; 0x190
    72c4:	f7fe feca 	bl	605c <malloc>
    72c8:	4604      	mov	r4, r0
    72ca:	b1d0      	cbz	r0, 7302 <__register_exitproc+0x92>
    72cc:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    72d0:	2700      	movs	r7, #0
    72d2:	e880 0088 	stmia.w	r0, {r3, r7}
    72d6:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    72da:	4638      	mov	r0, r7
    72dc:	2301      	movs	r3, #1
    72de:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    72e2:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    72e6:	2e00      	cmp	r6, #0
    72e8:	d0e1      	beq.n	72ae <__register_exitproc+0x3e>
    72ea:	e7d1      	b.n	7290 <__register_exitproc+0x20>
    72ec:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    72f0:	430a      	orrs	r2, r1
    72f2:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    72f6:	e7da      	b.n	72ae <__register_exitproc+0x3e>
    72f8:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    72fc:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    7300:	e7c1      	b.n	7286 <__register_exitproc+0x16>
    7302:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7306:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    730a:	bf00      	nop
    730c:	200006c8 	.word	0x200006c8
    7310:	0000605d 	.word	0x0000605d

00007314 <__call_exitprocs>:
    7314:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7318:	4b32      	ldr	r3, [pc, #200]	; (73e4 <__call_exitprocs+0xd0>)
    731a:	b085      	sub	sp, #20
    731c:	681b      	ldr	r3, [r3, #0]
    731e:	9302      	str	r3, [sp, #8]
    7320:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    7324:	9001      	str	r0, [sp, #4]
    7326:	460e      	mov	r6, r1
    7328:	9303      	str	r3, [sp, #12]
    732a:	9b02      	ldr	r3, [sp, #8]
    732c:	f8d3 7148 	ldr.w	r7, [r3, #328]	; 0x148
    7330:	b33f      	cbz	r7, 7382 <__call_exitprocs+0x6e>
    7332:	f8dd a00c 	ldr.w	sl, [sp, #12]
    7336:	f04f 0901 	mov.w	r9, #1
    733a:	46d3      	mov	fp, sl
    733c:	687c      	ldr	r4, [r7, #4]
    733e:	1e65      	subs	r5, r4, #1
    7340:	d40e      	bmi.n	7360 <__call_exitprocs+0x4c>
    7342:	3401      	adds	r4, #1
    7344:	eb07 0484 	add.w	r4, r7, r4, lsl #2
    7348:	f04f 0800 	mov.w	r8, #0
    734c:	b1e6      	cbz	r6, 7388 <__call_exitprocs+0x74>
    734e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    7352:	429e      	cmp	r6, r3
    7354:	d018      	beq.n	7388 <__call_exitprocs+0x74>
    7356:	3d01      	subs	r5, #1
    7358:	1c6b      	adds	r3, r5, #1
    735a:	f1a4 0404 	sub.w	r4, r4, #4
    735e:	d1f5      	bne.n	734c <__call_exitprocs+0x38>
    7360:	4b21      	ldr	r3, [pc, #132]	; (73e8 <__call_exitprocs+0xd4>)
    7362:	b173      	cbz	r3, 7382 <__call_exitprocs+0x6e>
    7364:	687b      	ldr	r3, [r7, #4]
    7366:	2b00      	cmp	r3, #0
    7368:	d136      	bne.n	73d8 <__call_exitprocs+0xc4>
    736a:	683b      	ldr	r3, [r7, #0]
    736c:	2b00      	cmp	r3, #0
    736e:	d034      	beq.n	73da <__call_exitprocs+0xc6>
    7370:	4638      	mov	r0, r7
    7372:	f8cb 3000 	str.w	r3, [fp]
    7376:	f7fe fe79 	bl	606c <free>
    737a:	f8db 7000 	ldr.w	r7, [fp]
    737e:	2f00      	cmp	r7, #0
    7380:	d1dc      	bne.n	733c <__call_exitprocs+0x28>
    7382:	b005      	add	sp, #20
    7384:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7388:	687b      	ldr	r3, [r7, #4]
    738a:	6822      	ldr	r2, [r4, #0]
    738c:	3b01      	subs	r3, #1
    738e:	42ab      	cmp	r3, r5
    7390:	bf0c      	ite	eq
    7392:	607d      	streq	r5, [r7, #4]
    7394:	f8c4 8000 	strne.w	r8, [r4]
    7398:	2a00      	cmp	r2, #0
    739a:	d0dc      	beq.n	7356 <__call_exitprocs+0x42>
    739c:	f8d7 1188 	ldr.w	r1, [r7, #392]	; 0x188
    73a0:	f8d7 a004 	ldr.w	sl, [r7, #4]
    73a4:	fa09 f305 	lsl.w	r3, r9, r5
    73a8:	420b      	tst	r3, r1
    73aa:	d00f      	beq.n	73cc <__call_exitprocs+0xb8>
    73ac:	f8d7 118c 	ldr.w	r1, [r7, #396]	; 0x18c
    73b0:	420b      	tst	r3, r1
    73b2:	d10d      	bne.n	73d0 <__call_exitprocs+0xbc>
    73b4:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
    73b8:	9801      	ldr	r0, [sp, #4]
    73ba:	4790      	blx	r2
    73bc:	687b      	ldr	r3, [r7, #4]
    73be:	4553      	cmp	r3, sl
    73c0:	d1b3      	bne.n	732a <__call_exitprocs+0x16>
    73c2:	f8db 3000 	ldr.w	r3, [fp]
    73c6:	42bb      	cmp	r3, r7
    73c8:	d0c5      	beq.n	7356 <__call_exitprocs+0x42>
    73ca:	e7ae      	b.n	732a <__call_exitprocs+0x16>
    73cc:	4790      	blx	r2
    73ce:	e7f5      	b.n	73bc <__call_exitprocs+0xa8>
    73d0:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
    73d4:	4790      	blx	r2
    73d6:	e7f1      	b.n	73bc <__call_exitprocs+0xa8>
    73d8:	683b      	ldr	r3, [r7, #0]
    73da:	46bb      	mov	fp, r7
    73dc:	461f      	mov	r7, r3
    73de:	2f00      	cmp	r7, #0
    73e0:	d1ac      	bne.n	733c <__call_exitprocs+0x28>
    73e2:	e7ce      	b.n	7382 <__call_exitprocs+0x6e>
    73e4:	200006c8 	.word	0x200006c8
    73e8:	0000606d 	.word	0x0000606d

000073ec <_malloc_trim_r>:
    73ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    73ee:	4f23      	ldr	r7, [pc, #140]	; (747c <_malloc_trim_r+0x90>)
    73f0:	460c      	mov	r4, r1
    73f2:	4606      	mov	r6, r0
    73f4:	f7ff fa5c 	bl	68b0 <__malloc_lock>
    73f8:	68bb      	ldr	r3, [r7, #8]
    73fa:	685d      	ldr	r5, [r3, #4]
    73fc:	f025 0503 	bic.w	r5, r5, #3
    7400:	1b29      	subs	r1, r5, r4
    7402:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    7406:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    740a:	f021 010f 	bic.w	r1, r1, #15
    740e:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    7412:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    7416:	db07      	blt.n	7428 <_malloc_trim_r+0x3c>
    7418:	2100      	movs	r1, #0
    741a:	4630      	mov	r0, r6
    741c:	f7ff fc44 	bl	6ca8 <_sbrk_r>
    7420:	68bb      	ldr	r3, [r7, #8]
    7422:	442b      	add	r3, r5
    7424:	4298      	cmp	r0, r3
    7426:	d004      	beq.n	7432 <_malloc_trim_r+0x46>
    7428:	4630      	mov	r0, r6
    742a:	f7ff fa43 	bl	68b4 <__malloc_unlock>
    742e:	2000      	movs	r0, #0
    7430:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7432:	4261      	negs	r1, r4
    7434:	4630      	mov	r0, r6
    7436:	f7ff fc37 	bl	6ca8 <_sbrk_r>
    743a:	3001      	adds	r0, #1
    743c:	d00d      	beq.n	745a <_malloc_trim_r+0x6e>
    743e:	4b10      	ldr	r3, [pc, #64]	; (7480 <_malloc_trim_r+0x94>)
    7440:	68ba      	ldr	r2, [r7, #8]
    7442:	6819      	ldr	r1, [r3, #0]
    7444:	1b2d      	subs	r5, r5, r4
    7446:	f045 0501 	orr.w	r5, r5, #1
    744a:	4630      	mov	r0, r6
    744c:	1b09      	subs	r1, r1, r4
    744e:	6055      	str	r5, [r2, #4]
    7450:	6019      	str	r1, [r3, #0]
    7452:	f7ff fa2f 	bl	68b4 <__malloc_unlock>
    7456:	2001      	movs	r0, #1
    7458:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    745a:	2100      	movs	r1, #0
    745c:	4630      	mov	r0, r6
    745e:	f7ff fc23 	bl	6ca8 <_sbrk_r>
    7462:	68ba      	ldr	r2, [r7, #8]
    7464:	1a83      	subs	r3, r0, r2
    7466:	2b0f      	cmp	r3, #15
    7468:	ddde      	ble.n	7428 <_malloc_trim_r+0x3c>
    746a:	4c06      	ldr	r4, [pc, #24]	; (7484 <_malloc_trim_r+0x98>)
    746c:	4904      	ldr	r1, [pc, #16]	; (7480 <_malloc_trim_r+0x94>)
    746e:	6824      	ldr	r4, [r4, #0]
    7470:	f043 0301 	orr.w	r3, r3, #1
    7474:	1b00      	subs	r0, r0, r4
    7476:	6053      	str	r3, [r2, #4]
    7478:	6008      	str	r0, [r1, #0]
    747a:	e7d5      	b.n	7428 <_malloc_trim_r+0x3c>
    747c:	200019c8 	.word	0x200019c8
    7480:	200026b4 	.word	0x200026b4
    7484:	20001dd0 	.word	0x20001dd0

00007488 <_free_r>:
    7488:	2900      	cmp	r1, #0
    748a:	d045      	beq.n	7518 <_free_r+0x90>
    748c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7490:	460d      	mov	r5, r1
    7492:	4680      	mov	r8, r0
    7494:	f7ff fa0c 	bl	68b0 <__malloc_lock>
    7498:	f855 7c04 	ldr.w	r7, [r5, #-4]
    749c:	496a      	ldr	r1, [pc, #424]	; (7648 <_free_r+0x1c0>)
    749e:	f027 0301 	bic.w	r3, r7, #1
    74a2:	f1a5 0408 	sub.w	r4, r5, #8
    74a6:	18e2      	adds	r2, r4, r3
    74a8:	688e      	ldr	r6, [r1, #8]
    74aa:	6850      	ldr	r0, [r2, #4]
    74ac:	42b2      	cmp	r2, r6
    74ae:	f020 0003 	bic.w	r0, r0, #3
    74b2:	d062      	beq.n	757a <_free_r+0xf2>
    74b4:	07fe      	lsls	r6, r7, #31
    74b6:	6050      	str	r0, [r2, #4]
    74b8:	d40b      	bmi.n	74d2 <_free_r+0x4a>
    74ba:	f855 7c08 	ldr.w	r7, [r5, #-8]
    74be:	1be4      	subs	r4, r4, r7
    74c0:	f101 0e08 	add.w	lr, r1, #8
    74c4:	68a5      	ldr	r5, [r4, #8]
    74c6:	4575      	cmp	r5, lr
    74c8:	443b      	add	r3, r7
    74ca:	d06f      	beq.n	75ac <_free_r+0x124>
    74cc:	68e7      	ldr	r7, [r4, #12]
    74ce:	60ef      	str	r7, [r5, #12]
    74d0:	60bd      	str	r5, [r7, #8]
    74d2:	1815      	adds	r5, r2, r0
    74d4:	686d      	ldr	r5, [r5, #4]
    74d6:	07ed      	lsls	r5, r5, #31
    74d8:	d542      	bpl.n	7560 <_free_r+0xd8>
    74da:	f043 0201 	orr.w	r2, r3, #1
    74de:	6062      	str	r2, [r4, #4]
    74e0:	50e3      	str	r3, [r4, r3]
    74e2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    74e6:	d218      	bcs.n	751a <_free_r+0x92>
    74e8:	08db      	lsrs	r3, r3, #3
    74ea:	1c5a      	adds	r2, r3, #1
    74ec:	684d      	ldr	r5, [r1, #4]
    74ee:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    74f2:	60a7      	str	r7, [r4, #8]
    74f4:	2001      	movs	r0, #1
    74f6:	109b      	asrs	r3, r3, #2
    74f8:	fa00 f303 	lsl.w	r3, r0, r3
    74fc:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    7500:	431d      	orrs	r5, r3
    7502:	3808      	subs	r0, #8
    7504:	60e0      	str	r0, [r4, #12]
    7506:	604d      	str	r5, [r1, #4]
    7508:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    750c:	60fc      	str	r4, [r7, #12]
    750e:	4640      	mov	r0, r8
    7510:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    7514:	f7ff b9ce 	b.w	68b4 <__malloc_unlock>
    7518:	4770      	bx	lr
    751a:	0a5a      	lsrs	r2, r3, #9
    751c:	2a04      	cmp	r2, #4
    751e:	d853      	bhi.n	75c8 <_free_r+0x140>
    7520:	099a      	lsrs	r2, r3, #6
    7522:	f102 0739 	add.w	r7, r2, #57	; 0x39
    7526:	007f      	lsls	r7, r7, #1
    7528:	f102 0538 	add.w	r5, r2, #56	; 0x38
    752c:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    7530:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    7534:	4944      	ldr	r1, [pc, #272]	; (7648 <_free_r+0x1c0>)
    7536:	3808      	subs	r0, #8
    7538:	4290      	cmp	r0, r2
    753a:	d04d      	beq.n	75d8 <_free_r+0x150>
    753c:	6851      	ldr	r1, [r2, #4]
    753e:	f021 0103 	bic.w	r1, r1, #3
    7542:	428b      	cmp	r3, r1
    7544:	d202      	bcs.n	754c <_free_r+0xc4>
    7546:	6892      	ldr	r2, [r2, #8]
    7548:	4290      	cmp	r0, r2
    754a:	d1f7      	bne.n	753c <_free_r+0xb4>
    754c:	68d0      	ldr	r0, [r2, #12]
    754e:	60e0      	str	r0, [r4, #12]
    7550:	60a2      	str	r2, [r4, #8]
    7552:	6084      	str	r4, [r0, #8]
    7554:	60d4      	str	r4, [r2, #12]
    7556:	4640      	mov	r0, r8
    7558:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    755c:	f7ff b9aa 	b.w	68b4 <__malloc_unlock>
    7560:	6895      	ldr	r5, [r2, #8]
    7562:	4f3a      	ldr	r7, [pc, #232]	; (764c <_free_r+0x1c4>)
    7564:	42bd      	cmp	r5, r7
    7566:	4403      	add	r3, r0
    7568:	d03f      	beq.n	75ea <_free_r+0x162>
    756a:	68d0      	ldr	r0, [r2, #12]
    756c:	60e8      	str	r0, [r5, #12]
    756e:	f043 0201 	orr.w	r2, r3, #1
    7572:	6085      	str	r5, [r0, #8]
    7574:	6062      	str	r2, [r4, #4]
    7576:	50e3      	str	r3, [r4, r3]
    7578:	e7b3      	b.n	74e2 <_free_r+0x5a>
    757a:	07ff      	lsls	r7, r7, #31
    757c:	4403      	add	r3, r0
    757e:	d407      	bmi.n	7590 <_free_r+0x108>
    7580:	f855 2c08 	ldr.w	r2, [r5, #-8]
    7584:	1aa4      	subs	r4, r4, r2
    7586:	4413      	add	r3, r2
    7588:	68a0      	ldr	r0, [r4, #8]
    758a:	68e2      	ldr	r2, [r4, #12]
    758c:	60c2      	str	r2, [r0, #12]
    758e:	6090      	str	r0, [r2, #8]
    7590:	4a2f      	ldr	r2, [pc, #188]	; (7650 <_free_r+0x1c8>)
    7592:	6812      	ldr	r2, [r2, #0]
    7594:	f043 0001 	orr.w	r0, r3, #1
    7598:	4293      	cmp	r3, r2
    759a:	6060      	str	r0, [r4, #4]
    759c:	608c      	str	r4, [r1, #8]
    759e:	d3b6      	bcc.n	750e <_free_r+0x86>
    75a0:	4b2c      	ldr	r3, [pc, #176]	; (7654 <_free_r+0x1cc>)
    75a2:	4640      	mov	r0, r8
    75a4:	6819      	ldr	r1, [r3, #0]
    75a6:	f7ff ff21 	bl	73ec <_malloc_trim_r>
    75aa:	e7b0      	b.n	750e <_free_r+0x86>
    75ac:	1811      	adds	r1, r2, r0
    75ae:	6849      	ldr	r1, [r1, #4]
    75b0:	07c9      	lsls	r1, r1, #31
    75b2:	d444      	bmi.n	763e <_free_r+0x1b6>
    75b4:	6891      	ldr	r1, [r2, #8]
    75b6:	68d2      	ldr	r2, [r2, #12]
    75b8:	60ca      	str	r2, [r1, #12]
    75ba:	4403      	add	r3, r0
    75bc:	f043 0001 	orr.w	r0, r3, #1
    75c0:	6091      	str	r1, [r2, #8]
    75c2:	6060      	str	r0, [r4, #4]
    75c4:	50e3      	str	r3, [r4, r3]
    75c6:	e7a2      	b.n	750e <_free_r+0x86>
    75c8:	2a14      	cmp	r2, #20
    75ca:	d817      	bhi.n	75fc <_free_r+0x174>
    75cc:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    75d0:	007f      	lsls	r7, r7, #1
    75d2:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    75d6:	e7a9      	b.n	752c <_free_r+0xa4>
    75d8:	10aa      	asrs	r2, r5, #2
    75da:	684b      	ldr	r3, [r1, #4]
    75dc:	2501      	movs	r5, #1
    75de:	fa05 f202 	lsl.w	r2, r5, r2
    75e2:	4313      	orrs	r3, r2
    75e4:	604b      	str	r3, [r1, #4]
    75e6:	4602      	mov	r2, r0
    75e8:	e7b1      	b.n	754e <_free_r+0xc6>
    75ea:	f043 0201 	orr.w	r2, r3, #1
    75ee:	614c      	str	r4, [r1, #20]
    75f0:	610c      	str	r4, [r1, #16]
    75f2:	60e5      	str	r5, [r4, #12]
    75f4:	60a5      	str	r5, [r4, #8]
    75f6:	6062      	str	r2, [r4, #4]
    75f8:	50e3      	str	r3, [r4, r3]
    75fa:	e788      	b.n	750e <_free_r+0x86>
    75fc:	2a54      	cmp	r2, #84	; 0x54
    75fe:	d806      	bhi.n	760e <_free_r+0x186>
    7600:	0b1a      	lsrs	r2, r3, #12
    7602:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    7606:	007f      	lsls	r7, r7, #1
    7608:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    760c:	e78e      	b.n	752c <_free_r+0xa4>
    760e:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    7612:	d806      	bhi.n	7622 <_free_r+0x19a>
    7614:	0bda      	lsrs	r2, r3, #15
    7616:	f102 0778 	add.w	r7, r2, #120	; 0x78
    761a:	007f      	lsls	r7, r7, #1
    761c:	f102 0577 	add.w	r5, r2, #119	; 0x77
    7620:	e784      	b.n	752c <_free_r+0xa4>
    7622:	f240 5054 	movw	r0, #1364	; 0x554
    7626:	4282      	cmp	r2, r0
    7628:	d806      	bhi.n	7638 <_free_r+0x1b0>
    762a:	0c9a      	lsrs	r2, r3, #18
    762c:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    7630:	007f      	lsls	r7, r7, #1
    7632:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    7636:	e779      	b.n	752c <_free_r+0xa4>
    7638:	27fe      	movs	r7, #254	; 0xfe
    763a:	257e      	movs	r5, #126	; 0x7e
    763c:	e776      	b.n	752c <_free_r+0xa4>
    763e:	f043 0201 	orr.w	r2, r3, #1
    7642:	6062      	str	r2, [r4, #4]
    7644:	50e3      	str	r3, [r4, r3]
    7646:	e762      	b.n	750e <_free_r+0x86>
    7648:	200019c8 	.word	0x200019c8
    764c:	200019d0 	.word	0x200019d0
    7650:	20001dd4 	.word	0x20001dd4
    7654:	200026e4 	.word	0x200026e4

00007658 <_localeconv_r>:
    7658:	4a04      	ldr	r2, [pc, #16]	; (766c <_localeconv_r+0x14>)
    765a:	4b05      	ldr	r3, [pc, #20]	; (7670 <_localeconv_r+0x18>)
    765c:	6812      	ldr	r2, [r2, #0]
    765e:	6b50      	ldr	r0, [r2, #52]	; 0x34
    7660:	2800      	cmp	r0, #0
    7662:	bf08      	it	eq
    7664:	4618      	moveq	r0, r3
    7666:	30f0      	adds	r0, #240	; 0xf0
    7668:	4770      	bx	lr
    766a:	bf00      	nop
    766c:	20001dd8 	.word	0x20001dd8
    7670:	2000185c 	.word	0x2000185c
	...

00007680 <memchr>:
    7680:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    7684:	2a10      	cmp	r2, #16
    7686:	db2b      	blt.n	76e0 <memchr+0x60>
    7688:	f010 0f07 	tst.w	r0, #7
    768c:	d008      	beq.n	76a0 <memchr+0x20>
    768e:	f810 3b01 	ldrb.w	r3, [r0], #1
    7692:	3a01      	subs	r2, #1
    7694:	428b      	cmp	r3, r1
    7696:	d02d      	beq.n	76f4 <memchr+0x74>
    7698:	f010 0f07 	tst.w	r0, #7
    769c:	b342      	cbz	r2, 76f0 <memchr+0x70>
    769e:	d1f6      	bne.n	768e <memchr+0xe>
    76a0:	b4f0      	push	{r4, r5, r6, r7}
    76a2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    76a6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    76aa:	f022 0407 	bic.w	r4, r2, #7
    76ae:	f07f 0700 	mvns.w	r7, #0
    76b2:	2300      	movs	r3, #0
    76b4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    76b8:	3c08      	subs	r4, #8
    76ba:	ea85 0501 	eor.w	r5, r5, r1
    76be:	ea86 0601 	eor.w	r6, r6, r1
    76c2:	fa85 f547 	uadd8	r5, r5, r7
    76c6:	faa3 f587 	sel	r5, r3, r7
    76ca:	fa86 f647 	uadd8	r6, r6, r7
    76ce:	faa5 f687 	sel	r6, r5, r7
    76d2:	b98e      	cbnz	r6, 76f8 <memchr+0x78>
    76d4:	d1ee      	bne.n	76b4 <memchr+0x34>
    76d6:	bcf0      	pop	{r4, r5, r6, r7}
    76d8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    76dc:	f002 0207 	and.w	r2, r2, #7
    76e0:	b132      	cbz	r2, 76f0 <memchr+0x70>
    76e2:	f810 3b01 	ldrb.w	r3, [r0], #1
    76e6:	3a01      	subs	r2, #1
    76e8:	ea83 0301 	eor.w	r3, r3, r1
    76ec:	b113      	cbz	r3, 76f4 <memchr+0x74>
    76ee:	d1f8      	bne.n	76e2 <memchr+0x62>
    76f0:	2000      	movs	r0, #0
    76f2:	4770      	bx	lr
    76f4:	3801      	subs	r0, #1
    76f6:	4770      	bx	lr
    76f8:	2d00      	cmp	r5, #0
    76fa:	bf06      	itte	eq
    76fc:	4635      	moveq	r5, r6
    76fe:	3803      	subeq	r0, #3
    7700:	3807      	subne	r0, #7
    7702:	f015 0f01 	tst.w	r5, #1
    7706:	d107      	bne.n	7718 <memchr+0x98>
    7708:	3001      	adds	r0, #1
    770a:	f415 7f80 	tst.w	r5, #256	; 0x100
    770e:	bf02      	ittt	eq
    7710:	3001      	addeq	r0, #1
    7712:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    7716:	3001      	addeq	r0, #1
    7718:	bcf0      	pop	{r4, r5, r6, r7}
    771a:	3801      	subs	r0, #1
    771c:	4770      	bx	lr
    771e:	bf00      	nop

00007720 <_Balloc>:
    7720:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    7722:	b570      	push	{r4, r5, r6, lr}
    7724:	4605      	mov	r5, r0
    7726:	460c      	mov	r4, r1
    7728:	b14b      	cbz	r3, 773e <_Balloc+0x1e>
    772a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    772e:	b180      	cbz	r0, 7752 <_Balloc+0x32>
    7730:	6802      	ldr	r2, [r0, #0]
    7732:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    7736:	2300      	movs	r3, #0
    7738:	6103      	str	r3, [r0, #16]
    773a:	60c3      	str	r3, [r0, #12]
    773c:	bd70      	pop	{r4, r5, r6, pc}
    773e:	2221      	movs	r2, #33	; 0x21
    7740:	2104      	movs	r1, #4
    7742:	f000 fb2f 	bl	7da4 <_calloc_r>
    7746:	64e8      	str	r0, [r5, #76]	; 0x4c
    7748:	4603      	mov	r3, r0
    774a:	2800      	cmp	r0, #0
    774c:	d1ed      	bne.n	772a <_Balloc+0xa>
    774e:	2000      	movs	r0, #0
    7750:	bd70      	pop	{r4, r5, r6, pc}
    7752:	2101      	movs	r1, #1
    7754:	fa01 f604 	lsl.w	r6, r1, r4
    7758:	1d72      	adds	r2, r6, #5
    775a:	4628      	mov	r0, r5
    775c:	0092      	lsls	r2, r2, #2
    775e:	f000 fb21 	bl	7da4 <_calloc_r>
    7762:	2800      	cmp	r0, #0
    7764:	d0f3      	beq.n	774e <_Balloc+0x2e>
    7766:	6044      	str	r4, [r0, #4]
    7768:	6086      	str	r6, [r0, #8]
    776a:	e7e4      	b.n	7736 <_Balloc+0x16>

0000776c <_Bfree>:
    776c:	b131      	cbz	r1, 777c <_Bfree+0x10>
    776e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    7770:	684a      	ldr	r2, [r1, #4]
    7772:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    7776:	6008      	str	r0, [r1, #0]
    7778:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    777c:	4770      	bx	lr
    777e:	bf00      	nop

00007780 <__multadd>:
    7780:	b5f0      	push	{r4, r5, r6, r7, lr}
    7782:	690c      	ldr	r4, [r1, #16]
    7784:	b083      	sub	sp, #12
    7786:	460d      	mov	r5, r1
    7788:	4606      	mov	r6, r0
    778a:	f101 0e14 	add.w	lr, r1, #20
    778e:	2700      	movs	r7, #0
    7790:	f8de 0000 	ldr.w	r0, [lr]
    7794:	b281      	uxth	r1, r0
    7796:	fb02 3101 	mla	r1, r2, r1, r3
    779a:	0c0b      	lsrs	r3, r1, #16
    779c:	0c00      	lsrs	r0, r0, #16
    779e:	fb02 3300 	mla	r3, r2, r0, r3
    77a2:	b289      	uxth	r1, r1
    77a4:	3701      	adds	r7, #1
    77a6:	eb01 4103 	add.w	r1, r1, r3, lsl #16
    77aa:	42bc      	cmp	r4, r7
    77ac:	f84e 1b04 	str.w	r1, [lr], #4
    77b0:	ea4f 4313 	mov.w	r3, r3, lsr #16
    77b4:	dcec      	bgt.n	7790 <__multadd+0x10>
    77b6:	b13b      	cbz	r3, 77c8 <__multadd+0x48>
    77b8:	68aa      	ldr	r2, [r5, #8]
    77ba:	4294      	cmp	r4, r2
    77bc:	da07      	bge.n	77ce <__multadd+0x4e>
    77be:	eb05 0284 	add.w	r2, r5, r4, lsl #2
    77c2:	3401      	adds	r4, #1
    77c4:	6153      	str	r3, [r2, #20]
    77c6:	612c      	str	r4, [r5, #16]
    77c8:	4628      	mov	r0, r5
    77ca:	b003      	add	sp, #12
    77cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    77ce:	6869      	ldr	r1, [r5, #4]
    77d0:	9301      	str	r3, [sp, #4]
    77d2:	3101      	adds	r1, #1
    77d4:	4630      	mov	r0, r6
    77d6:	f7ff ffa3 	bl	7720 <_Balloc>
    77da:	692a      	ldr	r2, [r5, #16]
    77dc:	3202      	adds	r2, #2
    77de:	f105 010c 	add.w	r1, r5, #12
    77e2:	4607      	mov	r7, r0
    77e4:	0092      	lsls	r2, r2, #2
    77e6:	300c      	adds	r0, #12
    77e8:	f7fe ff16 	bl	6618 <memcpy>
    77ec:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
    77ee:	6869      	ldr	r1, [r5, #4]
    77f0:	9b01      	ldr	r3, [sp, #4]
    77f2:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
    77f6:	6028      	str	r0, [r5, #0]
    77f8:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
    77fc:	463d      	mov	r5, r7
    77fe:	e7de      	b.n	77be <__multadd+0x3e>

00007800 <__hi0bits>:
    7800:	0c03      	lsrs	r3, r0, #16
    7802:	041b      	lsls	r3, r3, #16
    7804:	b9b3      	cbnz	r3, 7834 <__hi0bits+0x34>
    7806:	0400      	lsls	r0, r0, #16
    7808:	2310      	movs	r3, #16
    780a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
    780e:	bf04      	itt	eq
    7810:	0200      	lsleq	r0, r0, #8
    7812:	3308      	addeq	r3, #8
    7814:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
    7818:	bf04      	itt	eq
    781a:	0100      	lsleq	r0, r0, #4
    781c:	3304      	addeq	r3, #4
    781e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
    7822:	bf04      	itt	eq
    7824:	0080      	lsleq	r0, r0, #2
    7826:	3302      	addeq	r3, #2
    7828:	2800      	cmp	r0, #0
    782a:	db07      	blt.n	783c <__hi0bits+0x3c>
    782c:	0042      	lsls	r2, r0, #1
    782e:	d403      	bmi.n	7838 <__hi0bits+0x38>
    7830:	2020      	movs	r0, #32
    7832:	4770      	bx	lr
    7834:	2300      	movs	r3, #0
    7836:	e7e8      	b.n	780a <__hi0bits+0xa>
    7838:	1c58      	adds	r0, r3, #1
    783a:	4770      	bx	lr
    783c:	4618      	mov	r0, r3
    783e:	4770      	bx	lr

00007840 <__lo0bits>:
    7840:	6803      	ldr	r3, [r0, #0]
    7842:	f013 0207 	ands.w	r2, r3, #7
    7846:	d007      	beq.n	7858 <__lo0bits+0x18>
    7848:	07d9      	lsls	r1, r3, #31
    784a:	d420      	bmi.n	788e <__lo0bits+0x4e>
    784c:	079a      	lsls	r2, r3, #30
    784e:	d420      	bmi.n	7892 <__lo0bits+0x52>
    7850:	089b      	lsrs	r3, r3, #2
    7852:	6003      	str	r3, [r0, #0]
    7854:	2002      	movs	r0, #2
    7856:	4770      	bx	lr
    7858:	b299      	uxth	r1, r3
    785a:	b909      	cbnz	r1, 7860 <__lo0bits+0x20>
    785c:	0c1b      	lsrs	r3, r3, #16
    785e:	2210      	movs	r2, #16
    7860:	f013 0fff 	tst.w	r3, #255	; 0xff
    7864:	bf04      	itt	eq
    7866:	0a1b      	lsreq	r3, r3, #8
    7868:	3208      	addeq	r2, #8
    786a:	0719      	lsls	r1, r3, #28
    786c:	bf04      	itt	eq
    786e:	091b      	lsreq	r3, r3, #4
    7870:	3204      	addeq	r2, #4
    7872:	0799      	lsls	r1, r3, #30
    7874:	bf04      	itt	eq
    7876:	089b      	lsreq	r3, r3, #2
    7878:	3202      	addeq	r2, #2
    787a:	07d9      	lsls	r1, r3, #31
    787c:	d404      	bmi.n	7888 <__lo0bits+0x48>
    787e:	085b      	lsrs	r3, r3, #1
    7880:	d101      	bne.n	7886 <__lo0bits+0x46>
    7882:	2020      	movs	r0, #32
    7884:	4770      	bx	lr
    7886:	3201      	adds	r2, #1
    7888:	6003      	str	r3, [r0, #0]
    788a:	4610      	mov	r0, r2
    788c:	4770      	bx	lr
    788e:	2000      	movs	r0, #0
    7890:	4770      	bx	lr
    7892:	085b      	lsrs	r3, r3, #1
    7894:	6003      	str	r3, [r0, #0]
    7896:	2001      	movs	r0, #1
    7898:	4770      	bx	lr
    789a:	bf00      	nop

0000789c <__i2b>:
    789c:	b510      	push	{r4, lr}
    789e:	460c      	mov	r4, r1
    78a0:	2101      	movs	r1, #1
    78a2:	f7ff ff3d 	bl	7720 <_Balloc>
    78a6:	2201      	movs	r2, #1
    78a8:	6144      	str	r4, [r0, #20]
    78aa:	6102      	str	r2, [r0, #16]
    78ac:	bd10      	pop	{r4, pc}
    78ae:	bf00      	nop

000078b0 <__multiply>:
    78b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    78b4:	690d      	ldr	r5, [r1, #16]
    78b6:	6917      	ldr	r7, [r2, #16]
    78b8:	42bd      	cmp	r5, r7
    78ba:	b083      	sub	sp, #12
    78bc:	460c      	mov	r4, r1
    78be:	4616      	mov	r6, r2
    78c0:	da04      	bge.n	78cc <__multiply+0x1c>
    78c2:	462a      	mov	r2, r5
    78c4:	4634      	mov	r4, r6
    78c6:	463d      	mov	r5, r7
    78c8:	460e      	mov	r6, r1
    78ca:	4617      	mov	r7, r2
    78cc:	68a3      	ldr	r3, [r4, #8]
    78ce:	6861      	ldr	r1, [r4, #4]
    78d0:	eb05 0807 	add.w	r8, r5, r7
    78d4:	4598      	cmp	r8, r3
    78d6:	bfc8      	it	gt
    78d8:	3101      	addgt	r1, #1
    78da:	f7ff ff21 	bl	7720 <_Balloc>
    78de:	f100 0c14 	add.w	ip, r0, #20
    78e2:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
    78e6:	45cc      	cmp	ip, r9
    78e8:	9000      	str	r0, [sp, #0]
    78ea:	d205      	bcs.n	78f8 <__multiply+0x48>
    78ec:	4663      	mov	r3, ip
    78ee:	2100      	movs	r1, #0
    78f0:	f843 1b04 	str.w	r1, [r3], #4
    78f4:	4599      	cmp	r9, r3
    78f6:	d8fb      	bhi.n	78f0 <__multiply+0x40>
    78f8:	f106 0214 	add.w	r2, r6, #20
    78fc:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
    7900:	f104 0314 	add.w	r3, r4, #20
    7904:	4552      	cmp	r2, sl
    7906:	eb03 0e85 	add.w	lr, r3, r5, lsl #2
    790a:	d254      	bcs.n	79b6 <__multiply+0x106>
    790c:	f8cd 9004 	str.w	r9, [sp, #4]
    7910:	4699      	mov	r9, r3
    7912:	f852 3b04 	ldr.w	r3, [r2], #4
    7916:	fa1f fb83 	uxth.w	fp, r3
    791a:	f1bb 0f00 	cmp.w	fp, #0
    791e:	d020      	beq.n	7962 <__multiply+0xb2>
    7920:	2000      	movs	r0, #0
    7922:	464f      	mov	r7, r9
    7924:	4666      	mov	r6, ip
    7926:	4605      	mov	r5, r0
    7928:	e000      	b.n	792c <__multiply+0x7c>
    792a:	461e      	mov	r6, r3
    792c:	f857 4b04 	ldr.w	r4, [r7], #4
    7930:	6830      	ldr	r0, [r6, #0]
    7932:	b2a1      	uxth	r1, r4
    7934:	b283      	uxth	r3, r0
    7936:	fb0b 3101 	mla	r1, fp, r1, r3
    793a:	0c24      	lsrs	r4, r4, #16
    793c:	0c00      	lsrs	r0, r0, #16
    793e:	194b      	adds	r3, r1, r5
    7940:	fb0b 0004 	mla	r0, fp, r4, r0
    7944:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    7948:	b299      	uxth	r1, r3
    794a:	4633      	mov	r3, r6
    794c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    7950:	45be      	cmp	lr, r7
    7952:	ea4f 4510 	mov.w	r5, r0, lsr #16
    7956:	f843 1b04 	str.w	r1, [r3], #4
    795a:	d8e6      	bhi.n	792a <__multiply+0x7a>
    795c:	6075      	str	r5, [r6, #4]
    795e:	f852 3c04 	ldr.w	r3, [r2, #-4]
    7962:	ea5f 4b13 	movs.w	fp, r3, lsr #16
    7966:	d020      	beq.n	79aa <__multiply+0xfa>
    7968:	f8dc 3000 	ldr.w	r3, [ip]
    796c:	4667      	mov	r7, ip
    796e:	4618      	mov	r0, r3
    7970:	464d      	mov	r5, r9
    7972:	2100      	movs	r1, #0
    7974:	e000      	b.n	7978 <__multiply+0xc8>
    7976:	4637      	mov	r7, r6
    7978:	882c      	ldrh	r4, [r5, #0]
    797a:	0c00      	lsrs	r0, r0, #16
    797c:	fb0b 0004 	mla	r0, fp, r4, r0
    7980:	4401      	add	r1, r0
    7982:	b29c      	uxth	r4, r3
    7984:	463e      	mov	r6, r7
    7986:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
    798a:	f846 3b04 	str.w	r3, [r6], #4
    798e:	6878      	ldr	r0, [r7, #4]
    7990:	f855 4b04 	ldr.w	r4, [r5], #4
    7994:	b283      	uxth	r3, r0
    7996:	0c24      	lsrs	r4, r4, #16
    7998:	fb0b 3404 	mla	r4, fp, r4, r3
    799c:	eb04 4311 	add.w	r3, r4, r1, lsr #16
    79a0:	45ae      	cmp	lr, r5
    79a2:	ea4f 4113 	mov.w	r1, r3, lsr #16
    79a6:	d8e6      	bhi.n	7976 <__multiply+0xc6>
    79a8:	607b      	str	r3, [r7, #4]
    79aa:	4592      	cmp	sl, r2
    79ac:	f10c 0c04 	add.w	ip, ip, #4
    79b0:	d8af      	bhi.n	7912 <__multiply+0x62>
    79b2:	f8dd 9004 	ldr.w	r9, [sp, #4]
    79b6:	f1b8 0f00 	cmp.w	r8, #0
    79ba:	dd0b      	ble.n	79d4 <__multiply+0x124>
    79bc:	f859 3c04 	ldr.w	r3, [r9, #-4]
    79c0:	f1a9 0904 	sub.w	r9, r9, #4
    79c4:	b11b      	cbz	r3, 79ce <__multiply+0x11e>
    79c6:	e005      	b.n	79d4 <__multiply+0x124>
    79c8:	f859 3d04 	ldr.w	r3, [r9, #-4]!
    79cc:	b913      	cbnz	r3, 79d4 <__multiply+0x124>
    79ce:	f1b8 0801 	subs.w	r8, r8, #1
    79d2:	d1f9      	bne.n	79c8 <__multiply+0x118>
    79d4:	9800      	ldr	r0, [sp, #0]
    79d6:	f8c0 8010 	str.w	r8, [r0, #16]
    79da:	b003      	add	sp, #12
    79dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000079e0 <__pow5mult>:
    79e0:	f012 0303 	ands.w	r3, r2, #3
    79e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    79e8:	4614      	mov	r4, r2
    79ea:	4607      	mov	r7, r0
    79ec:	d12e      	bne.n	7a4c <__pow5mult+0x6c>
    79ee:	460e      	mov	r6, r1
    79f0:	10a4      	asrs	r4, r4, #2
    79f2:	d01c      	beq.n	7a2e <__pow5mult+0x4e>
    79f4:	6cbd      	ldr	r5, [r7, #72]	; 0x48
    79f6:	b395      	cbz	r5, 7a5e <__pow5mult+0x7e>
    79f8:	07e3      	lsls	r3, r4, #31
    79fa:	f04f 0800 	mov.w	r8, #0
    79fe:	d406      	bmi.n	7a0e <__pow5mult+0x2e>
    7a00:	1064      	asrs	r4, r4, #1
    7a02:	d014      	beq.n	7a2e <__pow5mult+0x4e>
    7a04:	6828      	ldr	r0, [r5, #0]
    7a06:	b1a8      	cbz	r0, 7a34 <__pow5mult+0x54>
    7a08:	4605      	mov	r5, r0
    7a0a:	07e3      	lsls	r3, r4, #31
    7a0c:	d5f8      	bpl.n	7a00 <__pow5mult+0x20>
    7a0e:	462a      	mov	r2, r5
    7a10:	4631      	mov	r1, r6
    7a12:	4638      	mov	r0, r7
    7a14:	f7ff ff4c 	bl	78b0 <__multiply>
    7a18:	b1b6      	cbz	r6, 7a48 <__pow5mult+0x68>
    7a1a:	6872      	ldr	r2, [r6, #4]
    7a1c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    7a1e:	1064      	asrs	r4, r4, #1
    7a20:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    7a24:	6031      	str	r1, [r6, #0]
    7a26:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    7a2a:	4606      	mov	r6, r0
    7a2c:	d1ea      	bne.n	7a04 <__pow5mult+0x24>
    7a2e:	4630      	mov	r0, r6
    7a30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7a34:	462a      	mov	r2, r5
    7a36:	4629      	mov	r1, r5
    7a38:	4638      	mov	r0, r7
    7a3a:	f7ff ff39 	bl	78b0 <__multiply>
    7a3e:	6028      	str	r0, [r5, #0]
    7a40:	f8c0 8000 	str.w	r8, [r0]
    7a44:	4605      	mov	r5, r0
    7a46:	e7e0      	b.n	7a0a <__pow5mult+0x2a>
    7a48:	4606      	mov	r6, r0
    7a4a:	e7d9      	b.n	7a00 <__pow5mult+0x20>
    7a4c:	1e5a      	subs	r2, r3, #1
    7a4e:	4d0b      	ldr	r5, [pc, #44]	; (7a7c <__pow5mult+0x9c>)
    7a50:	2300      	movs	r3, #0
    7a52:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
    7a56:	f7ff fe93 	bl	7780 <__multadd>
    7a5a:	4606      	mov	r6, r0
    7a5c:	e7c8      	b.n	79f0 <__pow5mult+0x10>
    7a5e:	2101      	movs	r1, #1
    7a60:	4638      	mov	r0, r7
    7a62:	f7ff fe5d 	bl	7720 <_Balloc>
    7a66:	f240 2171 	movw	r1, #625	; 0x271
    7a6a:	2201      	movs	r2, #1
    7a6c:	2300      	movs	r3, #0
    7a6e:	6141      	str	r1, [r0, #20]
    7a70:	6102      	str	r2, [r0, #16]
    7a72:	4605      	mov	r5, r0
    7a74:	64b8      	str	r0, [r7, #72]	; 0x48
    7a76:	6003      	str	r3, [r0, #0]
    7a78:	e7be      	b.n	79f8 <__pow5mult+0x18>
    7a7a:	bf00      	nop
    7a7c:	20000adc 	.word	0x20000adc

00007a80 <__lshift>:
    7a80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7a84:	4691      	mov	r9, r2
    7a86:	690a      	ldr	r2, [r1, #16]
    7a88:	688b      	ldr	r3, [r1, #8]
    7a8a:	ea4f 1469 	mov.w	r4, r9, asr #5
    7a8e:	eb04 0802 	add.w	r8, r4, r2
    7a92:	f108 0501 	add.w	r5, r8, #1
    7a96:	429d      	cmp	r5, r3
    7a98:	460e      	mov	r6, r1
    7a9a:	4682      	mov	sl, r0
    7a9c:	6849      	ldr	r1, [r1, #4]
    7a9e:	dd04      	ble.n	7aaa <__lshift+0x2a>
    7aa0:	005b      	lsls	r3, r3, #1
    7aa2:	429d      	cmp	r5, r3
    7aa4:	f101 0101 	add.w	r1, r1, #1
    7aa8:	dcfa      	bgt.n	7aa0 <__lshift+0x20>
    7aaa:	4650      	mov	r0, sl
    7aac:	f7ff fe38 	bl	7720 <_Balloc>
    7ab0:	2c00      	cmp	r4, #0
    7ab2:	f100 0214 	add.w	r2, r0, #20
    7ab6:	dd38      	ble.n	7b2a <__lshift+0xaa>
    7ab8:	eb02 0384 	add.w	r3, r2, r4, lsl #2
    7abc:	2100      	movs	r1, #0
    7abe:	f842 1b04 	str.w	r1, [r2], #4
    7ac2:	4293      	cmp	r3, r2
    7ac4:	d1fb      	bne.n	7abe <__lshift+0x3e>
    7ac6:	6934      	ldr	r4, [r6, #16]
    7ac8:	f106 0114 	add.w	r1, r6, #20
    7acc:	f019 091f 	ands.w	r9, r9, #31
    7ad0:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
    7ad4:	d021      	beq.n	7b1a <__lshift+0x9a>
    7ad6:	f1c9 0220 	rsb	r2, r9, #32
    7ada:	2400      	movs	r4, #0
    7adc:	680f      	ldr	r7, [r1, #0]
    7ade:	fa07 fc09 	lsl.w	ip, r7, r9
    7ae2:	ea4c 0404 	orr.w	r4, ip, r4
    7ae6:	469c      	mov	ip, r3
    7ae8:	f843 4b04 	str.w	r4, [r3], #4
    7aec:	f851 4b04 	ldr.w	r4, [r1], #4
    7af0:	458e      	cmp	lr, r1
    7af2:	fa24 f402 	lsr.w	r4, r4, r2
    7af6:	d8f1      	bhi.n	7adc <__lshift+0x5c>
    7af8:	f8cc 4004 	str.w	r4, [ip, #4]
    7afc:	b10c      	cbz	r4, 7b02 <__lshift+0x82>
    7afe:	f108 0502 	add.w	r5, r8, #2
    7b02:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    7b06:	6872      	ldr	r2, [r6, #4]
    7b08:	3d01      	subs	r5, #1
    7b0a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    7b0e:	6105      	str	r5, [r0, #16]
    7b10:	6031      	str	r1, [r6, #0]
    7b12:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    7b16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7b1a:	3b04      	subs	r3, #4
    7b1c:	f851 2b04 	ldr.w	r2, [r1], #4
    7b20:	f843 2f04 	str.w	r2, [r3, #4]!
    7b24:	458e      	cmp	lr, r1
    7b26:	d8f9      	bhi.n	7b1c <__lshift+0x9c>
    7b28:	e7eb      	b.n	7b02 <__lshift+0x82>
    7b2a:	4613      	mov	r3, r2
    7b2c:	e7cb      	b.n	7ac6 <__lshift+0x46>
    7b2e:	bf00      	nop

00007b30 <__mcmp>:
    7b30:	6902      	ldr	r2, [r0, #16]
    7b32:	690b      	ldr	r3, [r1, #16]
    7b34:	1ad2      	subs	r2, r2, r3
    7b36:	d113      	bne.n	7b60 <__mcmp+0x30>
    7b38:	009b      	lsls	r3, r3, #2
    7b3a:	3014      	adds	r0, #20
    7b3c:	3114      	adds	r1, #20
    7b3e:	4419      	add	r1, r3
    7b40:	b410      	push	{r4}
    7b42:	4403      	add	r3, r0
    7b44:	e001      	b.n	7b4a <__mcmp+0x1a>
    7b46:	4298      	cmp	r0, r3
    7b48:	d20c      	bcs.n	7b64 <__mcmp+0x34>
    7b4a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
    7b4e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
    7b52:	4294      	cmp	r4, r2
    7b54:	d0f7      	beq.n	7b46 <__mcmp+0x16>
    7b56:	d309      	bcc.n	7b6c <__mcmp+0x3c>
    7b58:	2001      	movs	r0, #1
    7b5a:	f85d 4b04 	ldr.w	r4, [sp], #4
    7b5e:	4770      	bx	lr
    7b60:	4610      	mov	r0, r2
    7b62:	4770      	bx	lr
    7b64:	2000      	movs	r0, #0
    7b66:	f85d 4b04 	ldr.w	r4, [sp], #4
    7b6a:	4770      	bx	lr
    7b6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7b70:	e7f3      	b.n	7b5a <__mcmp+0x2a>
    7b72:	bf00      	nop

00007b74 <__mdiff>:
    7b74:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    7b78:	690b      	ldr	r3, [r1, #16]
    7b7a:	460f      	mov	r7, r1
    7b7c:	6911      	ldr	r1, [r2, #16]
    7b7e:	1a5b      	subs	r3, r3, r1
    7b80:	2b00      	cmp	r3, #0
    7b82:	4690      	mov	r8, r2
    7b84:	d117      	bne.n	7bb6 <__mdiff+0x42>
    7b86:	0089      	lsls	r1, r1, #2
    7b88:	f107 0214 	add.w	r2, r7, #20
    7b8c:	f108 0514 	add.w	r5, r8, #20
    7b90:	1853      	adds	r3, r2, r1
    7b92:	4429      	add	r1, r5
    7b94:	e001      	b.n	7b9a <__mdiff+0x26>
    7b96:	429a      	cmp	r2, r3
    7b98:	d25e      	bcs.n	7c58 <__mdiff+0xe4>
    7b9a:	f853 6d04 	ldr.w	r6, [r3, #-4]!
    7b9e:	f851 4d04 	ldr.w	r4, [r1, #-4]!
    7ba2:	42a6      	cmp	r6, r4
    7ba4:	d0f7      	beq.n	7b96 <__mdiff+0x22>
    7ba6:	d260      	bcs.n	7c6a <__mdiff+0xf6>
    7ba8:	463b      	mov	r3, r7
    7baa:	4614      	mov	r4, r2
    7bac:	4647      	mov	r7, r8
    7bae:	f04f 0901 	mov.w	r9, #1
    7bb2:	4698      	mov	r8, r3
    7bb4:	e006      	b.n	7bc4 <__mdiff+0x50>
    7bb6:	db5d      	blt.n	7c74 <__mdiff+0x100>
    7bb8:	f107 0514 	add.w	r5, r7, #20
    7bbc:	f102 0414 	add.w	r4, r2, #20
    7bc0:	f04f 0900 	mov.w	r9, #0
    7bc4:	6879      	ldr	r1, [r7, #4]
    7bc6:	f7ff fdab 	bl	7720 <_Balloc>
    7bca:	f8d8 3010 	ldr.w	r3, [r8, #16]
    7bce:	693e      	ldr	r6, [r7, #16]
    7bd0:	f8c0 900c 	str.w	r9, [r0, #12]
    7bd4:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
    7bd8:	46a6      	mov	lr, r4
    7bda:	eb05 0786 	add.w	r7, r5, r6, lsl #2
    7bde:	f100 0414 	add.w	r4, r0, #20
    7be2:	2300      	movs	r3, #0
    7be4:	f85e 1b04 	ldr.w	r1, [lr], #4
    7be8:	f855 8b04 	ldr.w	r8, [r5], #4
    7bec:	b28a      	uxth	r2, r1
    7bee:	fa13 f388 	uxtah	r3, r3, r8
    7bf2:	0c09      	lsrs	r1, r1, #16
    7bf4:	1a9a      	subs	r2, r3, r2
    7bf6:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
    7bfa:	eb03 4322 	add.w	r3, r3, r2, asr #16
    7bfe:	b292      	uxth	r2, r2
    7c00:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    7c04:	45f4      	cmp	ip, lr
    7c06:	f844 2b04 	str.w	r2, [r4], #4
    7c0a:	ea4f 4323 	mov.w	r3, r3, asr #16
    7c0e:	d8e9      	bhi.n	7be4 <__mdiff+0x70>
    7c10:	42af      	cmp	r7, r5
    7c12:	d917      	bls.n	7c44 <__mdiff+0xd0>
    7c14:	46a4      	mov	ip, r4
    7c16:	4629      	mov	r1, r5
    7c18:	f851 eb04 	ldr.w	lr, [r1], #4
    7c1c:	fa13 f28e 	uxtah	r2, r3, lr
    7c20:	1413      	asrs	r3, r2, #16
    7c22:	eb03 431e 	add.w	r3, r3, lr, lsr #16
    7c26:	b292      	uxth	r2, r2
    7c28:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    7c2c:	428f      	cmp	r7, r1
    7c2e:	f84c 2b04 	str.w	r2, [ip], #4
    7c32:	ea4f 4323 	mov.w	r3, r3, asr #16
    7c36:	d8ef      	bhi.n	7c18 <__mdiff+0xa4>
    7c38:	43ed      	mvns	r5, r5
    7c3a:	443d      	add	r5, r7
    7c3c:	f025 0503 	bic.w	r5, r5, #3
    7c40:	3504      	adds	r5, #4
    7c42:	442c      	add	r4, r5
    7c44:	3c04      	subs	r4, #4
    7c46:	b922      	cbnz	r2, 7c52 <__mdiff+0xde>
    7c48:	f854 3d04 	ldr.w	r3, [r4, #-4]!
    7c4c:	3e01      	subs	r6, #1
    7c4e:	2b00      	cmp	r3, #0
    7c50:	d0fa      	beq.n	7c48 <__mdiff+0xd4>
    7c52:	6106      	str	r6, [r0, #16]
    7c54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7c58:	2100      	movs	r1, #0
    7c5a:	f7ff fd61 	bl	7720 <_Balloc>
    7c5e:	2201      	movs	r2, #1
    7c60:	2300      	movs	r3, #0
    7c62:	6102      	str	r2, [r0, #16]
    7c64:	6143      	str	r3, [r0, #20]
    7c66:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7c6a:	462c      	mov	r4, r5
    7c6c:	f04f 0900 	mov.w	r9, #0
    7c70:	4615      	mov	r5, r2
    7c72:	e7a7      	b.n	7bc4 <__mdiff+0x50>
    7c74:	463b      	mov	r3, r7
    7c76:	f107 0414 	add.w	r4, r7, #20
    7c7a:	f108 0514 	add.w	r5, r8, #20
    7c7e:	4647      	mov	r7, r8
    7c80:	f04f 0901 	mov.w	r9, #1
    7c84:	4698      	mov	r8, r3
    7c86:	e79d      	b.n	7bc4 <__mdiff+0x50>

00007c88 <__d2b>:
    7c88:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7c8c:	ec57 6b10 	vmov	r6, r7, d0
    7c90:	b083      	sub	sp, #12
    7c92:	4688      	mov	r8, r1
    7c94:	2101      	movs	r1, #1
    7c96:	463c      	mov	r4, r7
    7c98:	f3c7 550a 	ubfx	r5, r7, #20, #11
    7c9c:	4617      	mov	r7, r2
    7c9e:	f7ff fd3f 	bl	7720 <_Balloc>
    7ca2:	f3c4 0413 	ubfx	r4, r4, #0, #20
    7ca6:	4681      	mov	r9, r0
    7ca8:	b10d      	cbz	r5, 7cae <__d2b+0x26>
    7caa:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
    7cae:	9401      	str	r4, [sp, #4]
    7cb0:	b31e      	cbz	r6, 7cfa <__d2b+0x72>
    7cb2:	a802      	add	r0, sp, #8
    7cb4:	f840 6d08 	str.w	r6, [r0, #-8]!
    7cb8:	f7ff fdc2 	bl	7840 <__lo0bits>
    7cbc:	2800      	cmp	r0, #0
    7cbe:	d134      	bne.n	7d2a <__d2b+0xa2>
    7cc0:	e89d 000c 	ldmia.w	sp, {r2, r3}
    7cc4:	f8c9 2014 	str.w	r2, [r9, #20]
    7cc8:	2b00      	cmp	r3, #0
    7cca:	bf0c      	ite	eq
    7ccc:	2101      	moveq	r1, #1
    7cce:	2102      	movne	r1, #2
    7cd0:	f8c9 3018 	str.w	r3, [r9, #24]
    7cd4:	f8c9 1010 	str.w	r1, [r9, #16]
    7cd8:	b9dd      	cbnz	r5, 7d12 <__d2b+0x8a>
    7cda:	eb09 0381 	add.w	r3, r9, r1, lsl #2
    7cde:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
    7ce2:	f8c8 0000 	str.w	r0, [r8]
    7ce6:	6918      	ldr	r0, [r3, #16]
    7ce8:	f7ff fd8a 	bl	7800 <__hi0bits>
    7cec:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
    7cf0:	6038      	str	r0, [r7, #0]
    7cf2:	4648      	mov	r0, r9
    7cf4:	b003      	add	sp, #12
    7cf6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    7cfa:	a801      	add	r0, sp, #4
    7cfc:	f7ff fda0 	bl	7840 <__lo0bits>
    7d00:	9b01      	ldr	r3, [sp, #4]
    7d02:	f8c9 3014 	str.w	r3, [r9, #20]
    7d06:	2101      	movs	r1, #1
    7d08:	3020      	adds	r0, #32
    7d0a:	f8c9 1010 	str.w	r1, [r9, #16]
    7d0e:	2d00      	cmp	r5, #0
    7d10:	d0e3      	beq.n	7cda <__d2b+0x52>
    7d12:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
    7d16:	4405      	add	r5, r0
    7d18:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
    7d1c:	f8c8 5000 	str.w	r5, [r8]
    7d20:	6038      	str	r0, [r7, #0]
    7d22:	4648      	mov	r0, r9
    7d24:	b003      	add	sp, #12
    7d26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    7d2a:	e89d 000c 	ldmia.w	sp, {r2, r3}
    7d2e:	f1c0 0120 	rsb	r1, r0, #32
    7d32:	fa03 f101 	lsl.w	r1, r3, r1
    7d36:	430a      	orrs	r2, r1
    7d38:	40c3      	lsrs	r3, r0
    7d3a:	9301      	str	r3, [sp, #4]
    7d3c:	f8c9 2014 	str.w	r2, [r9, #20]
    7d40:	e7c2      	b.n	7cc8 <__d2b+0x40>
    7d42:	bf00      	nop

00007d44 <_vasnprintf_r>:
    7d44:	b570      	push	{r4, r5, r6, lr}
    7d46:	4615      	mov	r5, r2
    7d48:	b09a      	sub	sp, #104	; 0x68
    7d4a:	6814      	ldr	r4, [r2, #0]
    7d4c:	b109      	cbz	r1, 7d52 <_vasnprintf_r+0xe>
    7d4e:	2c00      	cmp	r4, #0
    7d50:	d11a      	bne.n	7d88 <_vasnprintf_r+0x44>
    7d52:	2400      	movs	r4, #0
    7d54:	f44f 7222 	mov.w	r2, #648	; 0x288
    7d58:	f8ad 200c 	strh.w	r2, [sp, #12]
    7d5c:	9400      	str	r4, [sp, #0]
    7d5e:	9404      	str	r4, [sp, #16]
    7d60:	461a      	mov	r2, r3
    7d62:	f64f 76ff 	movw	r6, #65535	; 0xffff
    7d66:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    7d68:	9402      	str	r4, [sp, #8]
    7d6a:	4669      	mov	r1, sp
    7d6c:	9405      	str	r4, [sp, #20]
    7d6e:	f8ad 600e 	strh.w	r6, [sp, #14]
    7d72:	f000 ff21 	bl	8bb8 <_svfprintf_r>
    7d76:	2800      	cmp	r0, #0
    7d78:	db11      	blt.n	7d9e <_vasnprintf_r+0x5a>
    7d7a:	9b00      	ldr	r3, [sp, #0]
    7d7c:	6028      	str	r0, [r5, #0]
    7d7e:	2200      	movs	r2, #0
    7d80:	701a      	strb	r2, [r3, #0]
    7d82:	9804      	ldr	r0, [sp, #16]
    7d84:	b01a      	add	sp, #104	; 0x68
    7d86:	bd70      	pop	{r4, r5, r6, pc}
    7d88:	f44f 62c1 	mov.w	r2, #1544	; 0x608
    7d8c:	9100      	str	r1, [sp, #0]
    7d8e:	9104      	str	r1, [sp, #16]
    7d90:	f8ad 200c 	strh.w	r2, [sp, #12]
    7d94:	dae4      	bge.n	7d60 <_vasnprintf_r+0x1c>
    7d96:	238b      	movs	r3, #139	; 0x8b
    7d98:	6003      	str	r3, [r0, #0]
    7d9a:	2000      	movs	r0, #0
    7d9c:	e7f2      	b.n	7d84 <_vasnprintf_r+0x40>
    7d9e:	2000      	movs	r0, #0
    7da0:	e7f0      	b.n	7d84 <_vasnprintf_r+0x40>
    7da2:	bf00      	nop

00007da4 <_calloc_r>:
    7da4:	b510      	push	{r4, lr}
    7da6:	fb02 f101 	mul.w	r1, r2, r1
    7daa:	f7fe f967 	bl	607c <_malloc_r>
    7dae:	4604      	mov	r4, r0
    7db0:	b1d8      	cbz	r0, 7dea <_calloc_r+0x46>
    7db2:	f850 2c04 	ldr.w	r2, [r0, #-4]
    7db6:	f022 0203 	bic.w	r2, r2, #3
    7dba:	3a04      	subs	r2, #4
    7dbc:	2a24      	cmp	r2, #36	; 0x24
    7dbe:	d818      	bhi.n	7df2 <_calloc_r+0x4e>
    7dc0:	2a13      	cmp	r2, #19
    7dc2:	d914      	bls.n	7dee <_calloc_r+0x4a>
    7dc4:	2300      	movs	r3, #0
    7dc6:	2a1b      	cmp	r2, #27
    7dc8:	6003      	str	r3, [r0, #0]
    7dca:	6043      	str	r3, [r0, #4]
    7dcc:	d916      	bls.n	7dfc <_calloc_r+0x58>
    7dce:	2a24      	cmp	r2, #36	; 0x24
    7dd0:	6083      	str	r3, [r0, #8]
    7dd2:	60c3      	str	r3, [r0, #12]
    7dd4:	bf11      	iteee	ne
    7dd6:	f100 0210 	addne.w	r2, r0, #16
    7dda:	6103      	streq	r3, [r0, #16]
    7ddc:	6143      	streq	r3, [r0, #20]
    7dde:	f100 0218 	addeq.w	r2, r0, #24
    7de2:	2300      	movs	r3, #0
    7de4:	6013      	str	r3, [r2, #0]
    7de6:	6053      	str	r3, [r2, #4]
    7de8:	6093      	str	r3, [r2, #8]
    7dea:	4620      	mov	r0, r4
    7dec:	bd10      	pop	{r4, pc}
    7dee:	4602      	mov	r2, r0
    7df0:	e7f7      	b.n	7de2 <_calloc_r+0x3e>
    7df2:	2100      	movs	r1, #0
    7df4:	f7fe fd0e 	bl	6814 <memset>
    7df8:	4620      	mov	r0, r4
    7dfa:	bd10      	pop	{r4, pc}
    7dfc:	f100 0208 	add.w	r2, r0, #8
    7e00:	e7ef      	b.n	7de2 <_calloc_r+0x3e>
    7e02:	bf00      	nop

00007e04 <quorem>:
    7e04:	6902      	ldr	r2, [r0, #16]
    7e06:	690b      	ldr	r3, [r1, #16]
    7e08:	4293      	cmp	r3, r2
    7e0a:	f300 808d 	bgt.w	7f28 <quorem+0x124>
    7e0e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7e12:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    7e16:	f101 0714 	add.w	r7, r1, #20
    7e1a:	f100 0b14 	add.w	fp, r0, #20
    7e1e:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
    7e22:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    7e26:	ea4f 0488 	mov.w	r4, r8, lsl #2
    7e2a:	b083      	sub	sp, #12
    7e2c:	3201      	adds	r2, #1
    7e2e:	fbb3 f9f2 	udiv	r9, r3, r2
    7e32:	eb0b 0304 	add.w	r3, fp, r4
    7e36:	9400      	str	r4, [sp, #0]
    7e38:	eb07 0a04 	add.w	sl, r7, r4
    7e3c:	9301      	str	r3, [sp, #4]
    7e3e:	f1b9 0f00 	cmp.w	r9, #0
    7e42:	d039      	beq.n	7eb8 <quorem+0xb4>
    7e44:	2500      	movs	r5, #0
    7e46:	46bc      	mov	ip, r7
    7e48:	46de      	mov	lr, fp
    7e4a:	462b      	mov	r3, r5
    7e4c:	f85c 6b04 	ldr.w	r6, [ip], #4
    7e50:	f8de 2000 	ldr.w	r2, [lr]
    7e54:	b2b4      	uxth	r4, r6
    7e56:	fb09 5504 	mla	r5, r9, r4, r5
    7e5a:	0c36      	lsrs	r6, r6, #16
    7e5c:	0c2c      	lsrs	r4, r5, #16
    7e5e:	fb09 4406 	mla	r4, r9, r6, r4
    7e62:	b2ad      	uxth	r5, r5
    7e64:	1b5b      	subs	r3, r3, r5
    7e66:	b2a6      	uxth	r6, r4
    7e68:	fa13 f382 	uxtah	r3, r3, r2
    7e6c:	ebc6 4612 	rsb	r6, r6, r2, lsr #16
    7e70:	eb06 4623 	add.w	r6, r6, r3, asr #16
    7e74:	b29b      	uxth	r3, r3
    7e76:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    7e7a:	45e2      	cmp	sl, ip
    7e7c:	f84e 3b04 	str.w	r3, [lr], #4
    7e80:	ea4f 4514 	mov.w	r5, r4, lsr #16
    7e84:	ea4f 4326 	mov.w	r3, r6, asr #16
    7e88:	d2e0      	bcs.n	7e4c <quorem+0x48>
    7e8a:	9b00      	ldr	r3, [sp, #0]
    7e8c:	f85b 3003 	ldr.w	r3, [fp, r3]
    7e90:	b993      	cbnz	r3, 7eb8 <quorem+0xb4>
    7e92:	9c01      	ldr	r4, [sp, #4]
    7e94:	1f23      	subs	r3, r4, #4
    7e96:	459b      	cmp	fp, r3
    7e98:	d20c      	bcs.n	7eb4 <quorem+0xb0>
    7e9a:	f854 3c04 	ldr.w	r3, [r4, #-4]
    7e9e:	b94b      	cbnz	r3, 7eb4 <quorem+0xb0>
    7ea0:	f1a4 0308 	sub.w	r3, r4, #8
    7ea4:	e002      	b.n	7eac <quorem+0xa8>
    7ea6:	681a      	ldr	r2, [r3, #0]
    7ea8:	3b04      	subs	r3, #4
    7eaa:	b91a      	cbnz	r2, 7eb4 <quorem+0xb0>
    7eac:	459b      	cmp	fp, r3
    7eae:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    7eb2:	d3f8      	bcc.n	7ea6 <quorem+0xa2>
    7eb4:	f8c0 8010 	str.w	r8, [r0, #16]
    7eb8:	4604      	mov	r4, r0
    7eba:	f7ff fe39 	bl	7b30 <__mcmp>
    7ebe:	2800      	cmp	r0, #0
    7ec0:	db2e      	blt.n	7f20 <quorem+0x11c>
    7ec2:	f109 0901 	add.w	r9, r9, #1
    7ec6:	465d      	mov	r5, fp
    7ec8:	2300      	movs	r3, #0
    7eca:	f857 1b04 	ldr.w	r1, [r7], #4
    7ece:	6828      	ldr	r0, [r5, #0]
    7ed0:	b28a      	uxth	r2, r1
    7ed2:	1a9a      	subs	r2, r3, r2
    7ed4:	0c09      	lsrs	r1, r1, #16
    7ed6:	fa12 f280 	uxtah	r2, r2, r0
    7eda:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
    7ede:	eb03 4322 	add.w	r3, r3, r2, asr #16
    7ee2:	b291      	uxth	r1, r2
    7ee4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    7ee8:	45ba      	cmp	sl, r7
    7eea:	f845 1b04 	str.w	r1, [r5], #4
    7eee:	ea4f 4323 	mov.w	r3, r3, asr #16
    7ef2:	d2ea      	bcs.n	7eca <quorem+0xc6>
    7ef4:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
    7ef8:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
    7efc:	b982      	cbnz	r2, 7f20 <quorem+0x11c>
    7efe:	1f1a      	subs	r2, r3, #4
    7f00:	4593      	cmp	fp, r2
    7f02:	d20b      	bcs.n	7f1c <quorem+0x118>
    7f04:	f853 2c04 	ldr.w	r2, [r3, #-4]
    7f08:	b942      	cbnz	r2, 7f1c <quorem+0x118>
    7f0a:	3b08      	subs	r3, #8
    7f0c:	e002      	b.n	7f14 <quorem+0x110>
    7f0e:	681a      	ldr	r2, [r3, #0]
    7f10:	3b04      	subs	r3, #4
    7f12:	b91a      	cbnz	r2, 7f1c <quorem+0x118>
    7f14:	459b      	cmp	fp, r3
    7f16:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    7f1a:	d3f8      	bcc.n	7f0e <quorem+0x10a>
    7f1c:	f8c4 8010 	str.w	r8, [r4, #16]
    7f20:	4648      	mov	r0, r9
    7f22:	b003      	add	sp, #12
    7f24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7f28:	2000      	movs	r0, #0
    7f2a:	4770      	bx	lr
    7f2c:	0000      	movs	r0, r0
	...

00007f30 <_dtoa_r>:
    7f30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7f34:	ec57 6b10 	vmov	r6, r7, d0
    7f38:	b093      	sub	sp, #76	; 0x4c
    7f3a:	6c05      	ldr	r5, [r0, #64]	; 0x40
    7f3c:	9101      	str	r1, [sp, #4]
    7f3e:	4604      	mov	r4, r0
    7f40:	4690      	mov	r8, r2
    7f42:	9304      	str	r3, [sp, #16]
    7f44:	ee10 aa10 	vmov	sl, s0
    7f48:	46bb      	mov	fp, r7
    7f4a:	b14d      	cbz	r5, 7f60 <_dtoa_r+0x30>
    7f4c:	6c42      	ldr	r2, [r0, #68]	; 0x44
    7f4e:	606a      	str	r2, [r5, #4]
    7f50:	2301      	movs	r3, #1
    7f52:	4093      	lsls	r3, r2
    7f54:	60ab      	str	r3, [r5, #8]
    7f56:	4629      	mov	r1, r5
    7f58:	f7ff fc08 	bl	776c <_Bfree>
    7f5c:	2300      	movs	r3, #0
    7f5e:	6423      	str	r3, [r4, #64]	; 0x40
    7f60:	f1bb 0f00 	cmp.w	fp, #0
    7f64:	465e      	mov	r6, fp
    7f66:	db34      	blt.n	7fd2 <_dtoa_r+0xa2>
    7f68:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    7f6a:	2300      	movs	r3, #0
    7f6c:	6013      	str	r3, [r2, #0]
    7f6e:	4bc4      	ldr	r3, [pc, #784]	; (8280 <_dtoa_r+0x350>)
    7f70:	461a      	mov	r2, r3
    7f72:	4033      	ands	r3, r6
    7f74:	4293      	cmp	r3, r2
    7f76:	d015      	beq.n	7fa4 <_dtoa_r+0x74>
    7f78:	ec4b ab17 	vmov	d7, sl, fp
    7f7c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    7f80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    7f84:	e9cd ab02 	strd	sl, fp, [sp, #8]
    7f88:	d12a      	bne.n	7fe0 <_dtoa_r+0xb0>
    7f8a:	9a04      	ldr	r2, [sp, #16]
    7f8c:	2301      	movs	r3, #1
    7f8e:	6013      	str	r3, [r2, #0]
    7f90:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    7f92:	2b00      	cmp	r3, #0
    7f94:	f000 80b7 	beq.w	8106 <_dtoa_r+0x1d6>
    7f98:	48ba      	ldr	r0, [pc, #744]	; (8284 <_dtoa_r+0x354>)
    7f9a:	6018      	str	r0, [r3, #0]
    7f9c:	3801      	subs	r0, #1
    7f9e:	b013      	add	sp, #76	; 0x4c
    7fa0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7fa4:	9a04      	ldr	r2, [sp, #16]
    7fa6:	f242 730f 	movw	r3, #9999	; 0x270f
    7faa:	6013      	str	r3, [r2, #0]
    7fac:	f1ba 0f00 	cmp.w	sl, #0
    7fb0:	f000 8092 	beq.w	80d8 <_dtoa_r+0x1a8>
    7fb4:	48b4      	ldr	r0, [pc, #720]	; (8288 <_dtoa_r+0x358>)
    7fb6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    7fb8:	2b00      	cmp	r3, #0
    7fba:	d0f0      	beq.n	7f9e <_dtoa_r+0x6e>
    7fbc:	78c3      	ldrb	r3, [r0, #3]
    7fbe:	2b00      	cmp	r3, #0
    7fc0:	f000 80a3 	beq.w	810a <_dtoa_r+0x1da>
    7fc4:	f100 0308 	add.w	r3, r0, #8
    7fc8:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    7fca:	6013      	str	r3, [r2, #0]
    7fcc:	b013      	add	sp, #76	; 0x4c
    7fce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7fd2:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    7fd4:	2301      	movs	r3, #1
    7fd6:	f02b 4600 	bic.w	r6, fp, #2147483648	; 0x80000000
    7fda:	6013      	str	r3, [r2, #0]
    7fdc:	46b3      	mov	fp, r6
    7fde:	e7c6      	b.n	7f6e <_dtoa_r+0x3e>
    7fe0:	a911      	add	r1, sp, #68	; 0x44
    7fe2:	aa10      	add	r2, sp, #64	; 0x40
    7fe4:	ed9d 0b02 	vldr	d0, [sp, #8]
    7fe8:	4620      	mov	r0, r4
    7fea:	f7ff fe4d 	bl	7c88 <__d2b>
    7fee:	0d31      	lsrs	r1, r6, #20
    7ff0:	9007      	str	r0, [sp, #28]
    7ff2:	d17a      	bne.n	80ea <_dtoa_r+0x1ba>
    7ff4:	9810      	ldr	r0, [sp, #64]	; 0x40
    7ff6:	9911      	ldr	r1, [sp, #68]	; 0x44
    7ff8:	4401      	add	r1, r0
    7ffa:	f201 4332 	addw	r3, r1, #1074	; 0x432
    7ffe:	2b20      	cmp	r3, #32
    8000:	f340 8241 	ble.w	8486 <_dtoa_r+0x556>
    8004:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    8008:	f201 4212 	addw	r2, r1, #1042	; 0x412
    800c:	409e      	lsls	r6, r3
    800e:	fa2a f302 	lsr.w	r3, sl, r2
    8012:	4333      	orrs	r3, r6
    8014:	ee07 3a90 	vmov	s15, r3
    8018:	eeb8 7b67 	vcvt.f64.u32	d7, s15
    801c:	2501      	movs	r5, #1
    801e:	ec53 2b17 	vmov	r2, r3, d7
    8022:	3901      	subs	r1, #1
    8024:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
    8028:	950a      	str	r5, [sp, #40]	; 0x28
    802a:	ec43 2b17 	vmov	d7, r2, r3
    802e:	eeb7 6b08 	vmov.f64	d6, #120	; 0x3fc00000  1.5
    8032:	ed9f 4b8d 	vldr	d4, [pc, #564]	; 8268 <_dtoa_r+0x338>
    8036:	ee37 6b46 	vsub.f64	d6, d7, d6
    803a:	ed9f 7b8d 	vldr	d7, [pc, #564]	; 8270 <_dtoa_r+0x340>
    803e:	ed9f 5b8e 	vldr	d5, [pc, #568]	; 8278 <_dtoa_r+0x348>
    8042:	eea6 7b04 	vfma.f64	d7, d6, d4
    8046:	ee06 1a90 	vmov	s13, r1
    804a:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    804e:	eea6 7b05 	vfma.f64	d7, d6, d5
    8052:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    8056:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    805a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    805e:	edcd 6a02 	vstr	s13, [sp, #8]
    8062:	f100 811c 	bmi.w	829e <_dtoa_r+0x36e>
    8066:	9d02      	ldr	r5, [sp, #8]
    8068:	2d16      	cmp	r5, #22
    806a:	f200 8115 	bhi.w	8298 <_dtoa_r+0x368>
    806e:	4b87      	ldr	r3, [pc, #540]	; (828c <_dtoa_r+0x35c>)
    8070:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    8074:	ed93 7b00 	vldr	d7, [r3]
    8078:	ec4b ab16 	vmov	d6, sl, fp
    807c:	eeb4 7bc6 	vcmpe.f64	d7, d6
    8080:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8084:	f340 8206 	ble.w	8494 <_dtoa_r+0x564>
    8088:	1e6b      	subs	r3, r5, #1
    808a:	9302      	str	r3, [sp, #8]
    808c:	2300      	movs	r3, #0
    808e:	930c      	str	r3, [sp, #48]	; 0x30
    8090:	1a41      	subs	r1, r0, r1
    8092:	f1b1 0901 	subs.w	r9, r1, #1
    8096:	f100 8117 	bmi.w	82c8 <_dtoa_r+0x398>
    809a:	2300      	movs	r3, #0
    809c:	9306      	str	r3, [sp, #24]
    809e:	9b02      	ldr	r3, [sp, #8]
    80a0:	2b00      	cmp	r3, #0
    80a2:	f2c0 8108 	blt.w	82b6 <_dtoa_r+0x386>
    80a6:	4499      	add	r9, r3
    80a8:	930b      	str	r3, [sp, #44]	; 0x2c
    80aa:	2300      	movs	r3, #0
    80ac:	9305      	str	r3, [sp, #20]
    80ae:	9b01      	ldr	r3, [sp, #4]
    80b0:	2b09      	cmp	r3, #9
    80b2:	d82c      	bhi.n	810e <_dtoa_r+0x1de>
    80b4:	2b05      	cmp	r3, #5
    80b6:	f340 855f 	ble.w	8b78 <_dtoa_r+0xc48>
    80ba:	3b04      	subs	r3, #4
    80bc:	9301      	str	r3, [sp, #4]
    80be:	2300      	movs	r3, #0
    80c0:	930e      	str	r3, [sp, #56]	; 0x38
    80c2:	9b01      	ldr	r3, [sp, #4]
    80c4:	3b02      	subs	r3, #2
    80c6:	2b03      	cmp	r3, #3
    80c8:	f200 855f 	bhi.w	8b8a <_dtoa_r+0xc5a>
    80cc:	e8df f013 	tbh	[pc, r3, lsl #1]
    80d0:	01e502a9 	.word	0x01e502a9
    80d4:	03c802b5 	.word	0x03c802b5
    80d8:	4b6b      	ldr	r3, [pc, #428]	; (8288 <_dtoa_r+0x358>)
    80da:	4a6d      	ldr	r2, [pc, #436]	; (8290 <_dtoa_r+0x360>)
    80dc:	f3c6 0013 	ubfx	r0, r6, #0, #20
    80e0:	2800      	cmp	r0, #0
    80e2:	bf14      	ite	ne
    80e4:	4618      	movne	r0, r3
    80e6:	4610      	moveq	r0, r2
    80e8:	e765      	b.n	7fb6 <_dtoa_r+0x86>
    80ea:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    80ee:	f3c3 0013 	ubfx	r0, r3, #0, #20
    80f2:	f040 537f 	orr.w	r3, r0, #1069547520	; 0x3fc00000
    80f6:	2500      	movs	r5, #0
    80f8:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
    80fc:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    8100:	9810      	ldr	r0, [sp, #64]	; 0x40
    8102:	950a      	str	r5, [sp, #40]	; 0x28
    8104:	e791      	b.n	802a <_dtoa_r+0xfa>
    8106:	4863      	ldr	r0, [pc, #396]	; (8294 <_dtoa_r+0x364>)
    8108:	e749      	b.n	7f9e <_dtoa_r+0x6e>
    810a:	1cc3      	adds	r3, r0, #3
    810c:	e75c      	b.n	7fc8 <_dtoa_r+0x98>
    810e:	2100      	movs	r1, #0
    8110:	6461      	str	r1, [r4, #68]	; 0x44
    8112:	4620      	mov	r0, r4
    8114:	4688      	mov	r8, r1
    8116:	9101      	str	r1, [sp, #4]
    8118:	f7ff fb02 	bl	7720 <_Balloc>
    811c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    8120:	2301      	movs	r3, #1
    8122:	9008      	str	r0, [sp, #32]
    8124:	6420      	str	r0, [r4, #64]	; 0x40
    8126:	970d      	str	r7, [sp, #52]	; 0x34
    8128:	9309      	str	r3, [sp, #36]	; 0x24
    812a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    812c:	2b00      	cmp	r3, #0
    812e:	db7a      	blt.n	8226 <_dtoa_r+0x2f6>
    8130:	9a02      	ldr	r2, [sp, #8]
    8132:	2a0e      	cmp	r2, #14
    8134:	dc77      	bgt.n	8226 <_dtoa_r+0x2f6>
    8136:	4b55      	ldr	r3, [pc, #340]	; (828c <_dtoa_r+0x35c>)
    8138:	f1b8 0f00 	cmp.w	r8, #0
    813c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    8140:	ed93 4b00 	vldr	d4, [r3]
    8144:	f2c0 8284 	blt.w	8650 <_dtoa_r+0x720>
    8148:	eeb1 2b44 	vneg.f64	d2, d4
    814c:	ec4b ab17 	vmov	d7, sl, fp
    8150:	ee87 6b04 	vdiv.f64	d6, d7, d4
    8154:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    8158:	9a08      	ldr	r2, [sp, #32]
    815a:	ee16 3a10 	vmov	r3, s12
    815e:	2f01      	cmp	r7, #1
    8160:	f103 0330 	add.w	r3, r3, #48	; 0x30
    8164:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    8168:	f102 0b01 	add.w	fp, r2, #1
    816c:	7013      	strb	r3, [r2, #0]
    816e:	eea2 7b05 	vfma.f64	d7, d2, d5
    8172:	d022      	beq.n	81ba <_dtoa_r+0x28a>
    8174:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
    8178:	ee27 7b03 	vmul.f64	d7, d7, d3
    817c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    8180:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8184:	d03a      	beq.n	81fc <_dtoa_r+0x2cc>
    8186:	9a08      	ldr	r2, [sp, #32]
    8188:	e006      	b.n	8198 <_dtoa_r+0x268>
    818a:	ee27 7b03 	vmul.f64	d7, d7, d3
    818e:	eeb5 7b40 	vcmp.f64	d7, #0.0
    8192:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8196:	d031      	beq.n	81fc <_dtoa_r+0x2cc>
    8198:	ee87 6b04 	vdiv.f64	d6, d7, d4
    819c:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    81a0:	ee16 3a10 	vmov	r3, s12
    81a4:	3330      	adds	r3, #48	; 0x30
    81a6:	f80b 3b01 	strb.w	r3, [fp], #1
    81aa:	ebc2 030b 	rsb	r3, r2, fp
    81ae:	42bb      	cmp	r3, r7
    81b0:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    81b4:	eea2 7b05 	vfma.f64	d7, d2, d5
    81b8:	d1e7      	bne.n	818a <_dtoa_r+0x25a>
    81ba:	ee37 7b07 	vadd.f64	d7, d7, d7
    81be:	eeb4 4bc7 	vcmpe.f64	d4, d7
    81c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    81c6:	d408      	bmi.n	81da <_dtoa_r+0x2aa>
    81c8:	eeb4 4b47 	vcmp.f64	d4, d7
    81cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    81d0:	d114      	bne.n	81fc <_dtoa_r+0x2cc>
    81d2:	ee16 3a10 	vmov	r3, s12
    81d6:	07db      	lsls	r3, r3, #31
    81d8:	d510      	bpl.n	81fc <_dtoa_r+0x2cc>
    81da:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    81de:	9a08      	ldr	r2, [sp, #32]
    81e0:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    81e4:	e004      	b.n	81f0 <_dtoa_r+0x2c0>
    81e6:	429a      	cmp	r2, r3
    81e8:	f000 83e5 	beq.w	89b6 <_dtoa_r+0xa86>
    81ec:	f813 0d01 	ldrb.w	r0, [r3, #-1]!
    81f0:	2839      	cmp	r0, #57	; 0x39
    81f2:	f103 0b01 	add.w	fp, r3, #1
    81f6:	d0f6      	beq.n	81e6 <_dtoa_r+0x2b6>
    81f8:	3001      	adds	r0, #1
    81fa:	7018      	strb	r0, [r3, #0]
    81fc:	9907      	ldr	r1, [sp, #28]
    81fe:	4620      	mov	r0, r4
    8200:	f7ff fab4 	bl	776c <_Bfree>
    8204:	2200      	movs	r2, #0
    8206:	9b02      	ldr	r3, [sp, #8]
    8208:	f88b 2000 	strb.w	r2, [fp]
    820c:	9a04      	ldr	r2, [sp, #16]
    820e:	3301      	adds	r3, #1
    8210:	6013      	str	r3, [r2, #0]
    8212:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    8214:	2b00      	cmp	r3, #0
    8216:	f000 8366 	beq.w	88e6 <_dtoa_r+0x9b6>
    821a:	9808      	ldr	r0, [sp, #32]
    821c:	f8c3 b000 	str.w	fp, [r3]
    8220:	b013      	add	sp, #76	; 0x4c
    8222:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8226:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8228:	2a00      	cmp	r2, #0
    822a:	d053      	beq.n	82d4 <_dtoa_r+0x3a4>
    822c:	9a01      	ldr	r2, [sp, #4]
    822e:	2a01      	cmp	r2, #1
    8230:	f340 822e 	ble.w	8690 <_dtoa_r+0x760>
    8234:	9905      	ldr	r1, [sp, #20]
    8236:	1e7a      	subs	r2, r7, #1
    8238:	4291      	cmp	r1, r2
    823a:	f2c0 8357 	blt.w	88ec <_dtoa_r+0x9bc>
    823e:	1a8b      	subs	r3, r1, r2
    8240:	930e      	str	r3, [sp, #56]	; 0x38
    8242:	2f00      	cmp	r7, #0
    8244:	9b06      	ldr	r3, [sp, #24]
    8246:	f2c0 8424 	blt.w	8a92 <_dtoa_r+0xb62>
    824a:	930a      	str	r3, [sp, #40]	; 0x28
    824c:	463b      	mov	r3, r7
    824e:	9a06      	ldr	r2, [sp, #24]
    8250:	2101      	movs	r1, #1
    8252:	441a      	add	r2, r3
    8254:	4620      	mov	r0, r4
    8256:	9206      	str	r2, [sp, #24]
    8258:	4499      	add	r9, r3
    825a:	f7ff fb1f 	bl	789c <__i2b>
    825e:	4606      	mov	r6, r0
    8260:	e03d      	b.n	82de <_dtoa_r+0x3ae>
    8262:	bf00      	nop
    8264:	f3af 8000 	nop.w
    8268:	636f4361 	.word	0x636f4361
    826c:	3fd287a7 	.word	0x3fd287a7
    8270:	8b60c8b3 	.word	0x8b60c8b3
    8274:	3fc68a28 	.word	0x3fc68a28
    8278:	509f79fb 	.word	0x509f79fb
    827c:	3fd34413 	.word	0x3fd34413
    8280:	7ff00000 	.word	0x7ff00000
    8284:	20000e4d 	.word	0x20000e4d
    8288:	20000e48 	.word	0x20000e48
    828c:	200002e8 	.word	0x200002e8
    8290:	20000e3c 	.word	0x20000e3c
    8294:	20000e4c 	.word	0x20000e4c
    8298:	2301      	movs	r3, #1
    829a:	930c      	str	r3, [sp, #48]	; 0x30
    829c:	e6f8      	b.n	8090 <_dtoa_r+0x160>
    829e:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    82a2:	eeb4 7b46 	vcmp.f64	d7, d6
    82a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    82aa:	f43f aedc 	beq.w	8066 <_dtoa_r+0x136>
    82ae:	9b02      	ldr	r3, [sp, #8]
    82b0:	3b01      	subs	r3, #1
    82b2:	9302      	str	r3, [sp, #8]
    82b4:	e6d7      	b.n	8066 <_dtoa_r+0x136>
    82b6:	9a06      	ldr	r2, [sp, #24]
    82b8:	9b02      	ldr	r3, [sp, #8]
    82ba:	1ad2      	subs	r2, r2, r3
    82bc:	425b      	negs	r3, r3
    82be:	9305      	str	r3, [sp, #20]
    82c0:	2300      	movs	r3, #0
    82c2:	9206      	str	r2, [sp, #24]
    82c4:	930b      	str	r3, [sp, #44]	; 0x2c
    82c6:	e6f2      	b.n	80ae <_dtoa_r+0x17e>
    82c8:	f1c9 0300 	rsb	r3, r9, #0
    82cc:	9306      	str	r3, [sp, #24]
    82ce:	f04f 0900 	mov.w	r9, #0
    82d2:	e6e4      	b.n	809e <_dtoa_r+0x16e>
    82d4:	9b05      	ldr	r3, [sp, #20]
    82d6:	930e      	str	r3, [sp, #56]	; 0x38
    82d8:	9e09      	ldr	r6, [sp, #36]	; 0x24
    82da:	9b06      	ldr	r3, [sp, #24]
    82dc:	930a      	str	r3, [sp, #40]	; 0x28
    82de:	990a      	ldr	r1, [sp, #40]	; 0x28
    82e0:	460b      	mov	r3, r1
    82e2:	b161      	cbz	r1, 82fe <_dtoa_r+0x3ce>
    82e4:	f1b9 0f00 	cmp.w	r9, #0
    82e8:	dd09      	ble.n	82fe <_dtoa_r+0x3ce>
    82ea:	4549      	cmp	r1, r9
    82ec:	9a06      	ldr	r2, [sp, #24]
    82ee:	bfa8      	it	ge
    82f0:	464b      	movge	r3, r9
    82f2:	1ad2      	subs	r2, r2, r3
    82f4:	9206      	str	r2, [sp, #24]
    82f6:	1aca      	subs	r2, r1, r3
    82f8:	920a      	str	r2, [sp, #40]	; 0x28
    82fa:	ebc3 0909 	rsb	r9, r3, r9
    82fe:	9b05      	ldr	r3, [sp, #20]
    8300:	2b00      	cmp	r3, #0
    8302:	f340 8280 	ble.w	8806 <_dtoa_r+0x8d6>
    8306:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8308:	2a00      	cmp	r2, #0
    830a:	f000 819a 	beq.w	8642 <_dtoa_r+0x712>
    830e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    8310:	2a00      	cmp	r2, #0
    8312:	f000 8196 	beq.w	8642 <_dtoa_r+0x712>
    8316:	4631      	mov	r1, r6
    8318:	4620      	mov	r0, r4
    831a:	f7ff fb61 	bl	79e0 <__pow5mult>
    831e:	9a07      	ldr	r2, [sp, #28]
    8320:	4601      	mov	r1, r0
    8322:	4606      	mov	r6, r0
    8324:	4620      	mov	r0, r4
    8326:	f7ff fac3 	bl	78b0 <__multiply>
    832a:	9907      	ldr	r1, [sp, #28]
    832c:	4605      	mov	r5, r0
    832e:	4620      	mov	r0, r4
    8330:	f7ff fa1c 	bl	776c <_Bfree>
    8334:	9b05      	ldr	r3, [sp, #20]
    8336:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    8338:	1a9b      	subs	r3, r3, r2
    833a:	9305      	str	r3, [sp, #20]
    833c:	f040 8180 	bne.w	8640 <_dtoa_r+0x710>
    8340:	2101      	movs	r1, #1
    8342:	4620      	mov	r0, r4
    8344:	f7ff faaa 	bl	789c <__i2b>
    8348:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    834a:	9005      	str	r0, [sp, #20]
    834c:	2b00      	cmp	r3, #0
    834e:	f000 81ac 	beq.w	86aa <_dtoa_r+0x77a>
    8352:	4601      	mov	r1, r0
    8354:	461a      	mov	r2, r3
    8356:	4620      	mov	r0, r4
    8358:	f7ff fb42 	bl	79e0 <__pow5mult>
    835c:	9b01      	ldr	r3, [sp, #4]
    835e:	9005      	str	r0, [sp, #20]
    8360:	2b01      	cmp	r3, #1
    8362:	f340 8280 	ble.w	8866 <_dtoa_r+0x936>
    8366:	2300      	movs	r3, #0
    8368:	9307      	str	r3, [sp, #28]
    836a:	9a05      	ldr	r2, [sp, #20]
    836c:	6913      	ldr	r3, [r2, #16]
    836e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    8372:	6918      	ldr	r0, [r3, #16]
    8374:	f7ff fa44 	bl	7800 <__hi0bits>
    8378:	f1c0 0020 	rsb	r0, r0, #32
    837c:	4448      	add	r0, r9
    837e:	f010 001f 	ands.w	r0, r0, #31
    8382:	f000 8190 	beq.w	86a6 <_dtoa_r+0x776>
    8386:	f1c0 0320 	rsb	r3, r0, #32
    838a:	2b04      	cmp	r3, #4
    838c:	f340 83f8 	ble.w	8b80 <_dtoa_r+0xc50>
    8390:	f1c0 001c 	rsb	r0, r0, #28
    8394:	9b06      	ldr	r3, [sp, #24]
    8396:	4403      	add	r3, r0
    8398:	9306      	str	r3, [sp, #24]
    839a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    839c:	4403      	add	r3, r0
    839e:	930a      	str	r3, [sp, #40]	; 0x28
    83a0:	4481      	add	r9, r0
    83a2:	9b06      	ldr	r3, [sp, #24]
    83a4:	2b00      	cmp	r3, #0
    83a6:	dd05      	ble.n	83b4 <_dtoa_r+0x484>
    83a8:	4629      	mov	r1, r5
    83aa:	461a      	mov	r2, r3
    83ac:	4620      	mov	r0, r4
    83ae:	f7ff fb67 	bl	7a80 <__lshift>
    83b2:	4605      	mov	r5, r0
    83b4:	f1b9 0f00 	cmp.w	r9, #0
    83b8:	dd05      	ble.n	83c6 <_dtoa_r+0x496>
    83ba:	464a      	mov	r2, r9
    83bc:	9905      	ldr	r1, [sp, #20]
    83be:	4620      	mov	r0, r4
    83c0:	f7ff fb5e 	bl	7a80 <__lshift>
    83c4:	9005      	str	r0, [sp, #20]
    83c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    83c8:	2b00      	cmp	r3, #0
    83ca:	f040 8201 	bne.w	87d0 <_dtoa_r+0x8a0>
    83ce:	2f00      	cmp	r7, #0
    83d0:	f340 8220 	ble.w	8814 <_dtoa_r+0x8e4>
    83d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    83d6:	2b00      	cmp	r3, #0
    83d8:	f040 817b 	bne.w	86d2 <_dtoa_r+0x7a2>
    83dc:	f8dd b020 	ldr.w	fp, [sp, #32]
    83e0:	f8dd a014 	ldr.w	sl, [sp, #20]
    83e4:	46d8      	mov	r8, fp
    83e6:	e002      	b.n	83ee <_dtoa_r+0x4be>
    83e8:	f7ff f9ca 	bl	7780 <__multadd>
    83ec:	4605      	mov	r5, r0
    83ee:	4651      	mov	r1, sl
    83f0:	4628      	mov	r0, r5
    83f2:	f7ff fd07 	bl	7e04 <quorem>
    83f6:	f100 0930 	add.w	r9, r0, #48	; 0x30
    83fa:	f808 9b01 	strb.w	r9, [r8], #1
    83fe:	ebcb 0308 	rsb	r3, fp, r8
    8402:	42bb      	cmp	r3, r7
    8404:	f04f 020a 	mov.w	r2, #10
    8408:	f04f 0300 	mov.w	r3, #0
    840c:	4629      	mov	r1, r5
    840e:	4620      	mov	r0, r4
    8410:	dbea      	blt.n	83e8 <_dtoa_r+0x4b8>
    8412:	9b08      	ldr	r3, [sp, #32]
    8414:	2f01      	cmp	r7, #1
    8416:	bfac      	ite	ge
    8418:	19db      	addge	r3, r3, r7
    841a:	3301      	addlt	r3, #1
    841c:	469b      	mov	fp, r3
    841e:	f04f 0a00 	mov.w	sl, #0
    8422:	4629      	mov	r1, r5
    8424:	2201      	movs	r2, #1
    8426:	4620      	mov	r0, r4
    8428:	f7ff fb2a 	bl	7a80 <__lshift>
    842c:	9905      	ldr	r1, [sp, #20]
    842e:	9007      	str	r0, [sp, #28]
    8430:	f7ff fb7e 	bl	7b30 <__mcmp>
    8434:	2800      	cmp	r0, #0
    8436:	f340 828c 	ble.w	8952 <_dtoa_r+0xa22>
    843a:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
    843e:	9908      	ldr	r1, [sp, #32]
    8440:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    8444:	e004      	b.n	8450 <_dtoa_r+0x520>
    8446:	428b      	cmp	r3, r1
    8448:	f000 8203 	beq.w	8852 <_dtoa_r+0x922>
    844c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    8450:	2a39      	cmp	r2, #57	; 0x39
    8452:	f103 0b01 	add.w	fp, r3, #1
    8456:	d0f6      	beq.n	8446 <_dtoa_r+0x516>
    8458:	3201      	adds	r2, #1
    845a:	701a      	strb	r2, [r3, #0]
    845c:	9905      	ldr	r1, [sp, #20]
    845e:	4620      	mov	r0, r4
    8460:	f7ff f984 	bl	776c <_Bfree>
    8464:	2e00      	cmp	r6, #0
    8466:	f43f aec9 	beq.w	81fc <_dtoa_r+0x2cc>
    846a:	f1ba 0f00 	cmp.w	sl, #0
    846e:	d005      	beq.n	847c <_dtoa_r+0x54c>
    8470:	45b2      	cmp	sl, r6
    8472:	d003      	beq.n	847c <_dtoa_r+0x54c>
    8474:	4651      	mov	r1, sl
    8476:	4620      	mov	r0, r4
    8478:	f7ff f978 	bl	776c <_Bfree>
    847c:	4631      	mov	r1, r6
    847e:	4620      	mov	r0, r4
    8480:	f7ff f974 	bl	776c <_Bfree>
    8484:	e6ba      	b.n	81fc <_dtoa_r+0x2cc>
    8486:	f1c3 0320 	rsb	r3, r3, #32
    848a:	fa0a f303 	lsl.w	r3, sl, r3
    848e:	ee07 3a90 	vmov	s15, r3
    8492:	e5c1      	b.n	8018 <_dtoa_r+0xe8>
    8494:	2300      	movs	r3, #0
    8496:	930c      	str	r3, [sp, #48]	; 0x30
    8498:	e5fa      	b.n	8090 <_dtoa_r+0x160>
    849a:	2300      	movs	r3, #0
    849c:	9309      	str	r3, [sp, #36]	; 0x24
    849e:	9b02      	ldr	r3, [sp, #8]
    84a0:	4443      	add	r3, r8
    84a2:	1c5f      	adds	r7, r3, #1
    84a4:	2f00      	cmp	r7, #0
    84a6:	930d      	str	r3, [sp, #52]	; 0x34
    84a8:	f340 822d 	ble.w	8906 <_dtoa_r+0x9d6>
    84ac:	463e      	mov	r6, r7
    84ae:	463d      	mov	r5, r7
    84b0:	2100      	movs	r1, #0
    84b2:	2e17      	cmp	r6, #23
    84b4:	6461      	str	r1, [r4, #68]	; 0x44
    84b6:	d90a      	bls.n	84ce <_dtoa_r+0x59e>
    84b8:	2201      	movs	r2, #1
    84ba:	2304      	movs	r3, #4
    84bc:	005b      	lsls	r3, r3, #1
    84be:	f103 0014 	add.w	r0, r3, #20
    84c2:	42b0      	cmp	r0, r6
    84c4:	4611      	mov	r1, r2
    84c6:	f102 0201 	add.w	r2, r2, #1
    84ca:	d9f7      	bls.n	84bc <_dtoa_r+0x58c>
    84cc:	6461      	str	r1, [r4, #68]	; 0x44
    84ce:	4620      	mov	r0, r4
    84d0:	f7ff f926 	bl	7720 <_Balloc>
    84d4:	2d0e      	cmp	r5, #14
    84d6:	9008      	str	r0, [sp, #32]
    84d8:	6420      	str	r0, [r4, #64]	; 0x40
    84da:	f63f ae26 	bhi.w	812a <_dtoa_r+0x1fa>
    84de:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    84e0:	2b00      	cmp	r3, #0
    84e2:	f43f ae22 	beq.w	812a <_dtoa_r+0x1fa>
    84e6:	9902      	ldr	r1, [sp, #8]
    84e8:	2900      	cmp	r1, #0
    84ea:	e9cd ab0e 	strd	sl, fp, [sp, #56]	; 0x38
    84ee:	f340 8241 	ble.w	8974 <_dtoa_r+0xa44>
    84f2:	4bc6      	ldr	r3, [pc, #792]	; (880c <_dtoa_r+0x8dc>)
    84f4:	f001 020f 	and.w	r2, r1, #15
    84f8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    84fc:	110b      	asrs	r3, r1, #4
    84fe:	06de      	lsls	r6, r3, #27
    8500:	ed92 6b00 	vldr	d6, [r2]
    8504:	f140 81fb 	bpl.w	88fe <_dtoa_r+0x9ce>
    8508:	4ac1      	ldr	r2, [pc, #772]	; (8810 <_dtoa_r+0x8e0>)
    850a:	ed92 7b08 	vldr	d7, [r2, #32]
    850e:	ec4b ab14 	vmov	d4, sl, fp
    8512:	f003 030f 	and.w	r3, r3, #15
    8516:	2103      	movs	r1, #3
    8518:	ee84 5b07 	vdiv.f64	d5, d4, d7
    851c:	b15b      	cbz	r3, 8536 <_dtoa_r+0x606>
    851e:	4abc      	ldr	r2, [pc, #752]	; (8810 <_dtoa_r+0x8e0>)
    8520:	07dd      	lsls	r5, r3, #31
    8522:	d504      	bpl.n	852e <_dtoa_r+0x5fe>
    8524:	ed92 7b00 	vldr	d7, [r2]
    8528:	3101      	adds	r1, #1
    852a:	ee26 6b07 	vmul.f64	d6, d6, d7
    852e:	105b      	asrs	r3, r3, #1
    8530:	f102 0208 	add.w	r2, r2, #8
    8534:	d1f4      	bne.n	8520 <_dtoa_r+0x5f0>
    8536:	ee85 4b06 	vdiv.f64	d4, d5, d6
    853a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    853c:	b13b      	cbz	r3, 854e <_dtoa_r+0x61e>
    853e:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    8542:	eeb4 4bc7 	vcmpe.f64	d4, d7
    8546:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    854a:	f100 82b7 	bmi.w	8abc <_dtoa_r+0xb8c>
    854e:	ee07 1a90 	vmov	s15, r1
    8552:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    8556:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    855a:	eea6 7b04 	vfma.f64	d7, d6, d4
    855e:	ec53 2b17 	vmov	r2, r3, d7
    8562:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    8566:	2f00      	cmp	r7, #0
    8568:	f000 81a6 	beq.w	88b8 <_dtoa_r+0x988>
    856c:	9e02      	ldr	r6, [sp, #8]
    856e:	4639      	mov	r1, r7
    8570:	9809      	ldr	r0, [sp, #36]	; 0x24
    8572:	2800      	cmp	r0, #0
    8574:	f000 824d 	beq.w	8a12 <_dtoa_r+0xae2>
    8578:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    857c:	48a3      	ldr	r0, [pc, #652]	; (880c <_dtoa_r+0x8dc>)
    857e:	9d08      	ldr	r5, [sp, #32]
    8580:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
    8584:	ed10 6b02 	vldr	d6, [r0, #-8]
    8588:	eebd 7bc4 	vcvt.s32.f64	s14, d4
    858c:	ee83 5b06 	vdiv.f64	d5, d3, d6
    8590:	ee17 0a10 	vmov	r0, s14
    8594:	ec43 2b16 	vmov	d6, r2, r3
    8598:	3030      	adds	r0, #48	; 0x30
    859a:	b2c0      	uxtb	r0, r0
    859c:	ee35 5b46 	vsub.f64	d5, d5, d6
    85a0:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    85a4:	ee34 7b47 	vsub.f64	d7, d4, d7
    85a8:	eeb4 5bc7 	vcmpe.f64	d5, d7
    85ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    85b0:	7028      	strb	r0, [r5, #0]
    85b2:	f105 0b01 	add.w	fp, r5, #1
    85b6:	dc32      	bgt.n	861e <_dtoa_r+0x6ee>
    85b8:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
    85bc:	ee33 6b47 	vsub.f64	d6, d3, d7
    85c0:	eeb4 5bc6 	vcmpe.f64	d5, d6
    85c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    85c8:	f300 82ae 	bgt.w	8b28 <_dtoa_r+0xbf8>
    85cc:	2901      	cmp	r1, #1
    85ce:	f340 81cd 	ble.w	896c <_dtoa_r+0xa3c>
    85d2:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    85d6:	9b08      	ldr	r3, [sp, #32]
    85d8:	4419      	add	r1, r3
    85da:	e00a      	b.n	85f2 <_dtoa_r+0x6c2>
    85dc:	ee33 6b47 	vsub.f64	d6, d3, d7
    85e0:	eeb4 6bc5 	vcmpe.f64	d6, d5
    85e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    85e8:	f100 829e 	bmi.w	8b28 <_dtoa_r+0xbf8>
    85ec:	458b      	cmp	fp, r1
    85ee:	f000 81bd 	beq.w	896c <_dtoa_r+0xa3c>
    85f2:	ee27 7b04 	vmul.f64	d7, d7, d4
    85f6:	ee25 5b04 	vmul.f64	d5, d5, d4
    85fa:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    85fe:	ee16 3a10 	vmov	r3, s12
    8602:	f103 0030 	add.w	r0, r3, #48	; 0x30
    8606:	b2c0      	uxtb	r0, r0
    8608:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    860c:	ee37 7b46 	vsub.f64	d7, d7, d6
    8610:	eeb4 7bc5 	vcmpe.f64	d7, d5
    8614:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8618:	f80b 0b01 	strb.w	r0, [fp], #1
    861c:	d5de      	bpl.n	85dc <_dtoa_r+0x6ac>
    861e:	9602      	str	r6, [sp, #8]
    8620:	e5ec      	b.n	81fc <_dtoa_r+0x2cc>
    8622:	2300      	movs	r3, #0
    8624:	9309      	str	r3, [sp, #36]	; 0x24
    8626:	f1b8 0f00 	cmp.w	r8, #0
    862a:	f340 8170 	ble.w	890e <_dtoa_r+0x9de>
    862e:	4646      	mov	r6, r8
    8630:	4645      	mov	r5, r8
    8632:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    8636:	4647      	mov	r7, r8
    8638:	e73a      	b.n	84b0 <_dtoa_r+0x580>
    863a:	2301      	movs	r3, #1
    863c:	9309      	str	r3, [sp, #36]	; 0x24
    863e:	e7f2      	b.n	8626 <_dtoa_r+0x6f6>
    8640:	9507      	str	r5, [sp, #28]
    8642:	9a05      	ldr	r2, [sp, #20]
    8644:	9907      	ldr	r1, [sp, #28]
    8646:	4620      	mov	r0, r4
    8648:	f7ff f9ca 	bl	79e0 <__pow5mult>
    864c:	4605      	mov	r5, r0
    864e:	e677      	b.n	8340 <_dtoa_r+0x410>
    8650:	2f00      	cmp	r7, #0
    8652:	f73f ad79 	bgt.w	8148 <_dtoa_r+0x218>
    8656:	f040 8142 	bne.w	88de <_dtoa_r+0x9ae>
    865a:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    865e:	ee24 4b07 	vmul.f64	d4, d4, d7
    8662:	ec4b ab17 	vmov	d7, sl, fp
    8666:	eeb4 4bc7 	vcmpe.f64	d4, d7
    866a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    866e:	463e      	mov	r6, r7
    8670:	9705      	str	r7, [sp, #20]
    8672:	f2c0 80e5 	blt.w	8840 <_dtoa_r+0x910>
    8676:	ea6f 0308 	mvn.w	r3, r8
    867a:	f8dd b020 	ldr.w	fp, [sp, #32]
    867e:	9302      	str	r3, [sp, #8]
    8680:	9905      	ldr	r1, [sp, #20]
    8682:	4620      	mov	r0, r4
    8684:	f7ff f872 	bl	776c <_Bfree>
    8688:	2e00      	cmp	r6, #0
    868a:	f43f adb7 	beq.w	81fc <_dtoa_r+0x2cc>
    868e:	e6f5      	b.n	847c <_dtoa_r+0x54c>
    8690:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    8692:	2a00      	cmp	r2, #0
    8694:	f000 8202 	beq.w	8a9c <_dtoa_r+0xb6c>
    8698:	9a05      	ldr	r2, [sp, #20]
    869a:	920e      	str	r2, [sp, #56]	; 0x38
    869c:	9a06      	ldr	r2, [sp, #24]
    869e:	920a      	str	r2, [sp, #40]	; 0x28
    86a0:	f203 4333 	addw	r3, r3, #1075	; 0x433
    86a4:	e5d3      	b.n	824e <_dtoa_r+0x31e>
    86a6:	201c      	movs	r0, #28
    86a8:	e674      	b.n	8394 <_dtoa_r+0x464>
    86aa:	9b01      	ldr	r3, [sp, #4]
    86ac:	2b01      	cmp	r3, #1
    86ae:	f340 8240 	ble.w	8b32 <_dtoa_r+0xc02>
    86b2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    86b4:	9307      	str	r3, [sp, #28]
    86b6:	2001      	movs	r0, #1
    86b8:	e660      	b.n	837c <_dtoa_r+0x44c>
    86ba:	4631      	mov	r1, r6
    86bc:	2300      	movs	r3, #0
    86be:	220a      	movs	r2, #10
    86c0:	4620      	mov	r0, r4
    86c2:	f7ff f85d 	bl	7780 <__multadd>
    86c6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    86c8:	2b00      	cmp	r3, #0
    86ca:	4606      	mov	r6, r0
    86cc:	f340 824d 	ble.w	8b6a <_dtoa_r+0xc3a>
    86d0:	461f      	mov	r7, r3
    86d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    86d4:	2b00      	cmp	r3, #0
    86d6:	dd05      	ble.n	86e4 <_dtoa_r+0x7b4>
    86d8:	4631      	mov	r1, r6
    86da:	461a      	mov	r2, r3
    86dc:	4620      	mov	r0, r4
    86de:	f7ff f9cf 	bl	7a80 <__lshift>
    86e2:	4606      	mov	r6, r0
    86e4:	9b07      	ldr	r3, [sp, #28]
    86e6:	2b00      	cmp	r3, #0
    86e8:	f040 816e 	bne.w	89c8 <_dtoa_r+0xa98>
    86ec:	46b0      	mov	r8, r6
    86ee:	9b08      	ldr	r3, [sp, #32]
    86f0:	3f01      	subs	r7, #1
    86f2:	19da      	adds	r2, r3, r7
    86f4:	9209      	str	r2, [sp, #36]	; 0x24
    86f6:	f00a 0201 	and.w	r2, sl, #1
    86fa:	920a      	str	r2, [sp, #40]	; 0x28
    86fc:	461f      	mov	r7, r3
    86fe:	f8dd b014 	ldr.w	fp, [sp, #20]
    8702:	4628      	mov	r0, r5
    8704:	4659      	mov	r1, fp
    8706:	f7ff fb7d 	bl	7e04 <quorem>
    870a:	4631      	mov	r1, r6
    870c:	4682      	mov	sl, r0
    870e:	4628      	mov	r0, r5
    8710:	f7ff fa0e 	bl	7b30 <__mcmp>
    8714:	4642      	mov	r2, r8
    8716:	4659      	mov	r1, fp
    8718:	4681      	mov	r9, r0
    871a:	4620      	mov	r0, r4
    871c:	f7ff fa2a 	bl	7b74 <__mdiff>
    8720:	68c3      	ldr	r3, [r0, #12]
    8722:	4683      	mov	fp, r0
    8724:	f10a 0230 	add.w	r2, sl, #48	; 0x30
    8728:	2b00      	cmp	r3, #0
    872a:	d149      	bne.n	87c0 <_dtoa_r+0x890>
    872c:	4601      	mov	r1, r0
    872e:	4628      	mov	r0, r5
    8730:	9207      	str	r2, [sp, #28]
    8732:	f7ff f9fd 	bl	7b30 <__mcmp>
    8736:	4659      	mov	r1, fp
    8738:	9006      	str	r0, [sp, #24]
    873a:	4620      	mov	r0, r4
    873c:	f7ff f816 	bl	776c <_Bfree>
    8740:	9b06      	ldr	r3, [sp, #24]
    8742:	9a07      	ldr	r2, [sp, #28]
    8744:	b92b      	cbnz	r3, 8752 <_dtoa_r+0x822>
    8746:	9901      	ldr	r1, [sp, #4]
    8748:	b919      	cbnz	r1, 8752 <_dtoa_r+0x822>
    874a:	990a      	ldr	r1, [sp, #40]	; 0x28
    874c:	2900      	cmp	r1, #0
    874e:	f000 81f5 	beq.w	8b3c <_dtoa_r+0xc0c>
    8752:	f1b9 0f00 	cmp.w	r9, #0
    8756:	f2c0 80df 	blt.w	8918 <_dtoa_r+0x9e8>
    875a:	d105      	bne.n	8768 <_dtoa_r+0x838>
    875c:	9901      	ldr	r1, [sp, #4]
    875e:	b919      	cbnz	r1, 8768 <_dtoa_r+0x838>
    8760:	990a      	ldr	r1, [sp, #40]	; 0x28
    8762:	2900      	cmp	r1, #0
    8764:	f000 80d8 	beq.w	8918 <_dtoa_r+0x9e8>
    8768:	2b00      	cmp	r3, #0
    876a:	f300 8141 	bgt.w	89f0 <_dtoa_r+0xac0>
    876e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    8770:	703a      	strb	r2, [r7, #0]
    8772:	f107 0901 	add.w	r9, r7, #1
    8776:	429f      	cmp	r7, r3
    8778:	46cb      	mov	fp, r9
    877a:	f000 8146 	beq.w	8a0a <_dtoa_r+0xada>
    877e:	4629      	mov	r1, r5
    8780:	2300      	movs	r3, #0
    8782:	220a      	movs	r2, #10
    8784:	4620      	mov	r0, r4
    8786:	f7fe fffb 	bl	7780 <__multadd>
    878a:	4546      	cmp	r6, r8
    878c:	4605      	mov	r5, r0
    878e:	4631      	mov	r1, r6
    8790:	f04f 0300 	mov.w	r3, #0
    8794:	f04f 020a 	mov.w	r2, #10
    8798:	4620      	mov	r0, r4
    879a:	d00b      	beq.n	87b4 <_dtoa_r+0x884>
    879c:	f7fe fff0 	bl	7780 <__multadd>
    87a0:	4641      	mov	r1, r8
    87a2:	4606      	mov	r6, r0
    87a4:	2300      	movs	r3, #0
    87a6:	220a      	movs	r2, #10
    87a8:	4620      	mov	r0, r4
    87aa:	f7fe ffe9 	bl	7780 <__multadd>
    87ae:	464f      	mov	r7, r9
    87b0:	4680      	mov	r8, r0
    87b2:	e7a4      	b.n	86fe <_dtoa_r+0x7ce>
    87b4:	f7fe ffe4 	bl	7780 <__multadd>
    87b8:	464f      	mov	r7, r9
    87ba:	4606      	mov	r6, r0
    87bc:	4680      	mov	r8, r0
    87be:	e79e      	b.n	86fe <_dtoa_r+0x7ce>
    87c0:	4601      	mov	r1, r0
    87c2:	4620      	mov	r0, r4
    87c4:	9206      	str	r2, [sp, #24]
    87c6:	f7fe ffd1 	bl	776c <_Bfree>
    87ca:	2301      	movs	r3, #1
    87cc:	9a06      	ldr	r2, [sp, #24]
    87ce:	e7c0      	b.n	8752 <_dtoa_r+0x822>
    87d0:	9905      	ldr	r1, [sp, #20]
    87d2:	4628      	mov	r0, r5
    87d4:	f7ff f9ac 	bl	7b30 <__mcmp>
    87d8:	2800      	cmp	r0, #0
    87da:	f6bf adf8 	bge.w	83ce <_dtoa_r+0x49e>
    87de:	4629      	mov	r1, r5
    87e0:	9d02      	ldr	r5, [sp, #8]
    87e2:	2300      	movs	r3, #0
    87e4:	3d01      	subs	r5, #1
    87e6:	220a      	movs	r2, #10
    87e8:	4620      	mov	r0, r4
    87ea:	9502      	str	r5, [sp, #8]
    87ec:	f7fe ffc8 	bl	7780 <__multadd>
    87f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    87f2:	4605      	mov	r5, r0
    87f4:	2b00      	cmp	r3, #0
    87f6:	f47f af60 	bne.w	86ba <_dtoa_r+0x78a>
    87fa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    87fc:	2b00      	cmp	r3, #0
    87fe:	f340 81ad 	ble.w	8b5c <_dtoa_r+0xc2c>
    8802:	461f      	mov	r7, r3
    8804:	e5ea      	b.n	83dc <_dtoa_r+0x4ac>
    8806:	9d07      	ldr	r5, [sp, #28]
    8808:	e59a      	b.n	8340 <_dtoa_r+0x410>
    880a:	bf00      	nop
    880c:	200002e8 	.word	0x200002e8
    8810:	200002c0 	.word	0x200002c0
    8814:	9b01      	ldr	r3, [sp, #4]
    8816:	2b02      	cmp	r3, #2
    8818:	f77f addc 	ble.w	83d4 <_dtoa_r+0x4a4>
    881c:	2f00      	cmp	r7, #0
    881e:	f040 8169 	bne.w	8af4 <_dtoa_r+0xbc4>
    8822:	463b      	mov	r3, r7
    8824:	9905      	ldr	r1, [sp, #20]
    8826:	2205      	movs	r2, #5
    8828:	4620      	mov	r0, r4
    882a:	f7fe ffa9 	bl	7780 <__multadd>
    882e:	4601      	mov	r1, r0
    8830:	9005      	str	r0, [sp, #20]
    8832:	4628      	mov	r0, r5
    8834:	f7ff f97c 	bl	7b30 <__mcmp>
    8838:	2800      	cmp	r0, #0
    883a:	9507      	str	r5, [sp, #28]
    883c:	f77f af1b 	ble.w	8676 <_dtoa_r+0x746>
    8840:	9a02      	ldr	r2, [sp, #8]
    8842:	9908      	ldr	r1, [sp, #32]
    8844:	2331      	movs	r3, #49	; 0x31
    8846:	3201      	adds	r2, #1
    8848:	9202      	str	r2, [sp, #8]
    884a:	700b      	strb	r3, [r1, #0]
    884c:	f101 0b01 	add.w	fp, r1, #1
    8850:	e716      	b.n	8680 <_dtoa_r+0x750>
    8852:	9a02      	ldr	r2, [sp, #8]
    8854:	3201      	adds	r2, #1
    8856:	9202      	str	r2, [sp, #8]
    8858:	9a08      	ldr	r2, [sp, #32]
    885a:	2331      	movs	r3, #49	; 0x31
    885c:	7013      	strb	r3, [r2, #0]
    885e:	e5fd      	b.n	845c <_dtoa_r+0x52c>
    8860:	2301      	movs	r3, #1
    8862:	9309      	str	r3, [sp, #36]	; 0x24
    8864:	e61b      	b.n	849e <_dtoa_r+0x56e>
    8866:	f1ba 0f00 	cmp.w	sl, #0
    886a:	f47f ad7c 	bne.w	8366 <_dtoa_r+0x436>
    886e:	f3cb 0313 	ubfx	r3, fp, #0, #20
    8872:	2b00      	cmp	r3, #0
    8874:	f040 811b 	bne.w	8aae <_dtoa_r+0xb7e>
    8878:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
    887c:	0d1b      	lsrs	r3, r3, #20
    887e:	051b      	lsls	r3, r3, #20
    8880:	2b00      	cmp	r3, #0
    8882:	f000 8154 	beq.w	8b2e <_dtoa_r+0xbfe>
    8886:	9b06      	ldr	r3, [sp, #24]
    8888:	3301      	adds	r3, #1
    888a:	9306      	str	r3, [sp, #24]
    888c:	2301      	movs	r3, #1
    888e:	f109 0901 	add.w	r9, r9, #1
    8892:	9307      	str	r3, [sp, #28]
    8894:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8896:	2001      	movs	r0, #1
    8898:	2b00      	cmp	r3, #0
    889a:	f43f ad6f 	beq.w	837c <_dtoa_r+0x44c>
    889e:	e564      	b.n	836a <_dtoa_r+0x43a>
    88a0:	ee07 1a90 	vmov	s15, r1
    88a4:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    88a8:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    88ac:	eea4 7b06 	vfma.f64	d7, d4, d6
    88b0:	ec53 2b17 	vmov	r2, r3, d7
    88b4:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    88b8:	ec43 2b16 	vmov	d6, r2, r3
    88bc:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    88c0:	ee34 7b47 	vsub.f64	d7, d4, d7
    88c4:	eeb4 7bc6 	vcmpe.f64	d7, d6
    88c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    88cc:	f300 80dd 	bgt.w	8a8a <_dtoa_r+0xb5a>
    88d0:	eeb1 6b46 	vneg.f64	d6, d6
    88d4:	eeb4 7bc6 	vcmpe.f64	d7, d6
    88d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    88dc:	d546      	bpl.n	896c <_dtoa_r+0xa3c>
    88de:	2300      	movs	r3, #0
    88e0:	9305      	str	r3, [sp, #20]
    88e2:	461e      	mov	r6, r3
    88e4:	e6c7      	b.n	8676 <_dtoa_r+0x746>
    88e6:	9808      	ldr	r0, [sp, #32]
    88e8:	f7ff bb59 	b.w	7f9e <_dtoa_r+0x6e>
    88ec:	9b05      	ldr	r3, [sp, #20]
    88ee:	990b      	ldr	r1, [sp, #44]	; 0x2c
    88f0:	9205      	str	r2, [sp, #20]
    88f2:	1ad3      	subs	r3, r2, r3
    88f4:	4419      	add	r1, r3
    88f6:	2300      	movs	r3, #0
    88f8:	910b      	str	r1, [sp, #44]	; 0x2c
    88fa:	930e      	str	r3, [sp, #56]	; 0x38
    88fc:	e4a1      	b.n	8242 <_dtoa_r+0x312>
    88fe:	ed9d 5b0e 	vldr	d5, [sp, #56]	; 0x38
    8902:	2102      	movs	r1, #2
    8904:	e60a      	b.n	851c <_dtoa_r+0x5ec>
    8906:	463d      	mov	r5, r7
    8908:	2100      	movs	r1, #0
    890a:	6461      	str	r1, [r4, #68]	; 0x44
    890c:	e5df      	b.n	84ce <_dtoa_r+0x59e>
    890e:	2501      	movs	r5, #1
    8910:	950d      	str	r5, [sp, #52]	; 0x34
    8912:	462f      	mov	r7, r5
    8914:	46a8      	mov	r8, r5
    8916:	e7f7      	b.n	8908 <_dtoa_r+0x9d8>
    8918:	2b00      	cmp	r3, #0
    891a:	4691      	mov	r9, r2
    891c:	dd11      	ble.n	8942 <_dtoa_r+0xa12>
    891e:	4629      	mov	r1, r5
    8920:	2201      	movs	r2, #1
    8922:	4620      	mov	r0, r4
    8924:	f7ff f8ac 	bl	7a80 <__lshift>
    8928:	9905      	ldr	r1, [sp, #20]
    892a:	4605      	mov	r5, r0
    892c:	f7ff f900 	bl	7b30 <__mcmp>
    8930:	2800      	cmp	r0, #0
    8932:	f340 810c 	ble.w	8b4e <_dtoa_r+0xc1e>
    8936:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
    893a:	f000 80dd 	beq.w	8af8 <_dtoa_r+0xbc8>
    893e:	f10a 0931 	add.w	r9, sl, #49	; 0x31
    8942:	46b2      	mov	sl, r6
    8944:	f887 9000 	strb.w	r9, [r7]
    8948:	f107 0b01 	add.w	fp, r7, #1
    894c:	4646      	mov	r6, r8
    894e:	9507      	str	r5, [sp, #28]
    8950:	e584      	b.n	845c <_dtoa_r+0x52c>
    8952:	d104      	bne.n	895e <_dtoa_r+0xa2e>
    8954:	f019 0f01 	tst.w	r9, #1
    8958:	d001      	beq.n	895e <_dtoa_r+0xa2e>
    895a:	e56e      	b.n	843a <_dtoa_r+0x50a>
    895c:	4693      	mov	fp, r2
    895e:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    8962:	2b30      	cmp	r3, #48	; 0x30
    8964:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    8968:	d0f8      	beq.n	895c <_dtoa_r+0xa2c>
    896a:	e577      	b.n	845c <_dtoa_r+0x52c>
    896c:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
    8970:	f7ff bbdb 	b.w	812a <_dtoa_r+0x1fa>
    8974:	9b02      	ldr	r3, [sp, #8]
    8976:	425b      	negs	r3, r3
    8978:	2b00      	cmp	r3, #0
    897a:	f000 809b 	beq.w	8ab4 <_dtoa_r+0xb84>
    897e:	4a8b      	ldr	r2, [pc, #556]	; (8bac <_dtoa_r+0xc7c>)
    8980:	f003 010f 	and.w	r1, r3, #15
    8984:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
    8988:	ed92 7b00 	vldr	d7, [r2]
    898c:	ed9d 6b0e 	vldr	d6, [sp, #56]	; 0x38
    8990:	111b      	asrs	r3, r3, #4
    8992:	ee26 4b07 	vmul.f64	d4, d6, d7
    8996:	f000 80e6 	beq.w	8b66 <_dtoa_r+0xc36>
    899a:	4a85      	ldr	r2, [pc, #532]	; (8bb0 <_dtoa_r+0xc80>)
    899c:	2102      	movs	r1, #2
    899e:	07d8      	lsls	r0, r3, #31
    89a0:	d504      	bpl.n	89ac <_dtoa_r+0xa7c>
    89a2:	ed92 7b00 	vldr	d7, [r2]
    89a6:	3101      	adds	r1, #1
    89a8:	ee24 4b07 	vmul.f64	d4, d4, d7
    89ac:	105b      	asrs	r3, r3, #1
    89ae:	f102 0208 	add.w	r2, r2, #8
    89b2:	d1f4      	bne.n	899e <_dtoa_r+0xa6e>
    89b4:	e5c1      	b.n	853a <_dtoa_r+0x60a>
    89b6:	9908      	ldr	r1, [sp, #32]
    89b8:	2230      	movs	r2, #48	; 0x30
    89ba:	700a      	strb	r2, [r1, #0]
    89bc:	9a02      	ldr	r2, [sp, #8]
    89be:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    89c2:	3201      	adds	r2, #1
    89c4:	9202      	str	r2, [sp, #8]
    89c6:	e417      	b.n	81f8 <_dtoa_r+0x2c8>
    89c8:	6871      	ldr	r1, [r6, #4]
    89ca:	4620      	mov	r0, r4
    89cc:	f7fe fea8 	bl	7720 <_Balloc>
    89d0:	6933      	ldr	r3, [r6, #16]
    89d2:	1c9a      	adds	r2, r3, #2
    89d4:	4680      	mov	r8, r0
    89d6:	0092      	lsls	r2, r2, #2
    89d8:	f106 010c 	add.w	r1, r6, #12
    89dc:	300c      	adds	r0, #12
    89de:	f7fd fe1b 	bl	6618 <memcpy>
    89e2:	4641      	mov	r1, r8
    89e4:	2201      	movs	r2, #1
    89e6:	4620      	mov	r0, r4
    89e8:	f7ff f84a 	bl	7a80 <__lshift>
    89ec:	4680      	mov	r8, r0
    89ee:	e67e      	b.n	86ee <_dtoa_r+0x7be>
    89f0:	2a39      	cmp	r2, #57	; 0x39
    89f2:	f000 8081 	beq.w	8af8 <_dtoa_r+0xbc8>
    89f6:	f102 0901 	add.w	r9, r2, #1
    89fa:	46b2      	mov	sl, r6
    89fc:	f887 9000 	strb.w	r9, [r7]
    8a00:	f107 0b01 	add.w	fp, r7, #1
    8a04:	4646      	mov	r6, r8
    8a06:	9507      	str	r5, [sp, #28]
    8a08:	e528      	b.n	845c <_dtoa_r+0x52c>
    8a0a:	46b2      	mov	sl, r6
    8a0c:	4691      	mov	r9, r2
    8a0e:	4646      	mov	r6, r8
    8a10:	e507      	b.n	8422 <_dtoa_r+0x4f2>
    8a12:	4866      	ldr	r0, [pc, #408]	; (8bac <_dtoa_r+0xc7c>)
    8a14:	eebd 6bc4 	vcvt.s32.f64	s12, d4
    8a18:	1e4d      	subs	r5, r1, #1
    8a1a:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
    8a1e:	ec43 2b17 	vmov	d7, r2, r3
    8a22:	ed90 3b00 	vldr	d3, [r0]
    8a26:	ee16 3a10 	vmov	r3, s12
    8a2a:	ee23 3b07 	vmul.f64	d3, d3, d7
    8a2e:	9808      	ldr	r0, [sp, #32]
    8a30:	3330      	adds	r3, #48	; 0x30
    8a32:	2901      	cmp	r1, #1
    8a34:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    8a38:	7003      	strb	r3, [r0, #0]
    8a3a:	f100 0b01 	add.w	fp, r0, #1
    8a3e:	ee34 7b46 	vsub.f64	d7, d4, d6
    8a42:	d014      	beq.n	8a6e <_dtoa_r+0xb3e>
    8a44:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    8a48:	9b08      	ldr	r3, [sp, #32]
    8a4a:	4419      	add	r1, r3
    8a4c:	465b      	mov	r3, fp
    8a4e:	ee27 7b05 	vmul.f64	d7, d7, d5
    8a52:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    8a56:	ee16 2a10 	vmov	r2, s12
    8a5a:	3230      	adds	r2, #48	; 0x30
    8a5c:	f803 2b01 	strb.w	r2, [r3], #1
    8a60:	4299      	cmp	r1, r3
    8a62:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    8a66:	ee37 7b46 	vsub.f64	d7, d7, d6
    8a6a:	d1f0      	bne.n	8a4e <_dtoa_r+0xb1e>
    8a6c:	44ab      	add	fp, r5
    8a6e:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
    8a72:	ee33 5b06 	vadd.f64	d5, d3, d6
    8a76:	eeb4 5bc7 	vcmpe.f64	d5, d7
    8a7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8a7e:	d543      	bpl.n	8b08 <_dtoa_r+0xbd8>
    8a80:	9602      	str	r6, [sp, #8]
    8a82:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    8a86:	f7ff bbaa 	b.w	81de <_dtoa_r+0x2ae>
    8a8a:	2300      	movs	r3, #0
    8a8c:	9305      	str	r3, [sp, #20]
    8a8e:	461e      	mov	r6, r3
    8a90:	e6d6      	b.n	8840 <_dtoa_r+0x910>
    8a92:	1bdb      	subs	r3, r3, r7
    8a94:	930a      	str	r3, [sp, #40]	; 0x28
    8a96:	2300      	movs	r3, #0
    8a98:	f7ff bbd9 	b.w	824e <_dtoa_r+0x31e>
    8a9c:	9a05      	ldr	r2, [sp, #20]
    8a9e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8aa0:	920e      	str	r2, [sp, #56]	; 0x38
    8aa2:	9a06      	ldr	r2, [sp, #24]
    8aa4:	920a      	str	r2, [sp, #40]	; 0x28
    8aa6:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    8aaa:	f7ff bbd0 	b.w	824e <_dtoa_r+0x31e>
    8aae:	2300      	movs	r3, #0
    8ab0:	9307      	str	r3, [sp, #28]
    8ab2:	e6ef      	b.n	8894 <_dtoa_r+0x964>
    8ab4:	ed9d 4b0e 	vldr	d4, [sp, #56]	; 0x38
    8ab8:	2102      	movs	r1, #2
    8aba:	e53e      	b.n	853a <_dtoa_r+0x60a>
    8abc:	2f00      	cmp	r7, #0
    8abe:	f43f aeef 	beq.w	88a0 <_dtoa_r+0x970>
    8ac2:	980d      	ldr	r0, [sp, #52]	; 0x34
    8ac4:	2800      	cmp	r0, #0
    8ac6:	f77f af51 	ble.w	896c <_dtoa_r+0xa3c>
    8aca:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    8ace:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    8ad2:	3101      	adds	r1, #1
    8ad4:	ee06 1a90 	vmov	s13, r1
    8ad8:	ee24 4b05 	vmul.f64	d4, d4, d5
    8adc:	9b02      	ldr	r3, [sp, #8]
    8ade:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    8ae2:	1e5e      	subs	r6, r3, #1
    8ae4:	eea4 7b06 	vfma.f64	d7, d4, d6
    8ae8:	ec53 2b17 	vmov	r2, r3, d7
    8aec:	4601      	mov	r1, r0
    8aee:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    8af2:	e53d      	b.n	8570 <_dtoa_r+0x640>
    8af4:	9507      	str	r5, [sp, #28]
    8af6:	e5be      	b.n	8676 <_dtoa_r+0x746>
    8af8:	2239      	movs	r2, #57	; 0x39
    8afa:	46b2      	mov	sl, r6
    8afc:	9507      	str	r5, [sp, #28]
    8afe:	4646      	mov	r6, r8
    8b00:	703a      	strb	r2, [r7, #0]
    8b02:	f107 0b01 	add.w	fp, r7, #1
    8b06:	e49a      	b.n	843e <_dtoa_r+0x50e>
    8b08:	ee36 6b43 	vsub.f64	d6, d6, d3
    8b0c:	eeb4 6bc7 	vcmpe.f64	d6, d7
    8b10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8b14:	dc01      	bgt.n	8b1a <_dtoa_r+0xbea>
    8b16:	e729      	b.n	896c <_dtoa_r+0xa3c>
    8b18:	4693      	mov	fp, r2
    8b1a:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    8b1e:	2b30      	cmp	r3, #48	; 0x30
    8b20:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    8b24:	d0f8      	beq.n	8b18 <_dtoa_r+0xbe8>
    8b26:	e57a      	b.n	861e <_dtoa_r+0x6ee>
    8b28:	9602      	str	r6, [sp, #8]
    8b2a:	f7ff bb58 	b.w	81de <_dtoa_r+0x2ae>
    8b2e:	9307      	str	r3, [sp, #28]
    8b30:	e6b0      	b.n	8894 <_dtoa_r+0x964>
    8b32:	f1ba 0f00 	cmp.w	sl, #0
    8b36:	f47f adbc 	bne.w	86b2 <_dtoa_r+0x782>
    8b3a:	e698      	b.n	886e <_dtoa_r+0x93e>
    8b3c:	2a39      	cmp	r2, #57	; 0x39
    8b3e:	46cb      	mov	fp, r9
    8b40:	4691      	mov	r9, r2
    8b42:	d0d9      	beq.n	8af8 <_dtoa_r+0xbc8>
    8b44:	f1bb 0f00 	cmp.w	fp, #0
    8b48:	f73f aef9 	bgt.w	893e <_dtoa_r+0xa0e>
    8b4c:	e6f9      	b.n	8942 <_dtoa_r+0xa12>
    8b4e:	f47f aef8 	bne.w	8942 <_dtoa_r+0xa12>
    8b52:	f019 0f01 	tst.w	r9, #1
    8b56:	f43f aef4 	beq.w	8942 <_dtoa_r+0xa12>
    8b5a:	e6ec      	b.n	8936 <_dtoa_r+0xa06>
    8b5c:	9b01      	ldr	r3, [sp, #4]
    8b5e:	2b02      	cmp	r3, #2
    8b60:	dc08      	bgt.n	8b74 <_dtoa_r+0xc44>
    8b62:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    8b64:	e43a      	b.n	83dc <_dtoa_r+0x4ac>
    8b66:	2102      	movs	r1, #2
    8b68:	e4e7      	b.n	853a <_dtoa_r+0x60a>
    8b6a:	9b01      	ldr	r3, [sp, #4]
    8b6c:	2b02      	cmp	r3, #2
    8b6e:	dc01      	bgt.n	8b74 <_dtoa_r+0xc44>
    8b70:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    8b72:	e5ae      	b.n	86d2 <_dtoa_r+0x7a2>
    8b74:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    8b76:	e651      	b.n	881c <_dtoa_r+0x8ec>
    8b78:	2301      	movs	r3, #1
    8b7a:	930e      	str	r3, [sp, #56]	; 0x38
    8b7c:	f7ff baa1 	b.w	80c2 <_dtoa_r+0x192>
    8b80:	f43f ac0f 	beq.w	83a2 <_dtoa_r+0x472>
    8b84:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
    8b88:	e404      	b.n	8394 <_dtoa_r+0x464>
    8b8a:	2500      	movs	r5, #0
    8b8c:	6465      	str	r5, [r4, #68]	; 0x44
    8b8e:	4629      	mov	r1, r5
    8b90:	4620      	mov	r0, r4
    8b92:	f7fe fdc5 	bl	7720 <_Balloc>
    8b96:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    8b9a:	2301      	movs	r3, #1
    8b9c:	9008      	str	r0, [sp, #32]
    8b9e:	46a8      	mov	r8, r5
    8ba0:	6420      	str	r0, [r4, #64]	; 0x40
    8ba2:	970d      	str	r7, [sp, #52]	; 0x34
    8ba4:	9309      	str	r3, [sp, #36]	; 0x24
    8ba6:	f7ff bac0 	b.w	812a <_dtoa_r+0x1fa>
    8baa:	bf00      	nop
    8bac:	200002e8 	.word	0x200002e8
    8bb0:	200002c0 	.word	0x200002c0
    8bb4:	00000000 	.word	0x00000000

00008bb8 <_svfprintf_r>:
    8bb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8bbc:	ed2d 8b06 	vpush	{d8-d10}
    8bc0:	b0b9      	sub	sp, #228	; 0xe4
    8bc2:	460c      	mov	r4, r1
    8bc4:	9103      	str	r1, [sp, #12]
    8bc6:	4692      	mov	sl, r2
    8bc8:	9309      	str	r3, [sp, #36]	; 0x24
    8bca:	9005      	str	r0, [sp, #20]
    8bcc:	f7fe fd44 	bl	7658 <_localeconv_r>
    8bd0:	6803      	ldr	r3, [r0, #0]
    8bd2:	9310      	str	r3, [sp, #64]	; 0x40
    8bd4:	4618      	mov	r0, r3
    8bd6:	f7fe fa53 	bl	7080 <strlen>
    8bda:	89a3      	ldrh	r3, [r4, #12]
    8bdc:	900f      	str	r0, [sp, #60]	; 0x3c
    8bde:	0619      	lsls	r1, r3, #24
    8be0:	d503      	bpl.n	8bea <_svfprintf_r+0x32>
    8be2:	6923      	ldr	r3, [r4, #16]
    8be4:	2b00      	cmp	r3, #0
    8be6:	f001 807d 	beq.w	9ce4 <_svfprintf_r+0x112c>
    8bea:	2300      	movs	r3, #0
    8bec:	ed9f 8ba4 	vldr	d8, [pc, #656]	; 8e80 <_svfprintf_r+0x2c8>
    8bf0:	ed9f 9ba5 	vldr	d9, [pc, #660]	; 8e88 <_svfprintf_r+0x2d0>
    8bf4:	930d      	str	r3, [sp, #52]	; 0x34
    8bf6:	931d      	str	r3, [sp, #116]	; 0x74
    8bf8:	931c      	str	r3, [sp, #112]	; 0x70
    8bfa:	9311      	str	r3, [sp, #68]	; 0x44
    8bfc:	9306      	str	r3, [sp, #24]
    8bfe:	ab28      	add	r3, sp, #160	; 0xa0
    8c00:	931b      	str	r3, [sp, #108]	; 0x6c
    8c02:	4699      	mov	r9, r3
    8c04:	f89a 3000 	ldrb.w	r3, [sl]
    8c08:	4654      	mov	r4, sl
    8c0a:	b1eb      	cbz	r3, 8c48 <_svfprintf_r+0x90>
    8c0c:	2b25      	cmp	r3, #37	; 0x25
    8c0e:	d102      	bne.n	8c16 <_svfprintf_r+0x5e>
    8c10:	e01a      	b.n	8c48 <_svfprintf_r+0x90>
    8c12:	2b25      	cmp	r3, #37	; 0x25
    8c14:	d003      	beq.n	8c1e <_svfprintf_r+0x66>
    8c16:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    8c1a:	2b00      	cmp	r3, #0
    8c1c:	d1f9      	bne.n	8c12 <_svfprintf_r+0x5a>
    8c1e:	ebca 0504 	rsb	r5, sl, r4
    8c22:	b18d      	cbz	r5, 8c48 <_svfprintf_r+0x90>
    8c24:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    8c26:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    8c28:	f8c9 a000 	str.w	sl, [r9]
    8c2c:	3301      	adds	r3, #1
    8c2e:	442a      	add	r2, r5
    8c30:	2b07      	cmp	r3, #7
    8c32:	f8c9 5004 	str.w	r5, [r9, #4]
    8c36:	921d      	str	r2, [sp, #116]	; 0x74
    8c38:	931c      	str	r3, [sp, #112]	; 0x70
    8c3a:	f300 80a3 	bgt.w	8d84 <_svfprintf_r+0x1cc>
    8c3e:	f109 0908 	add.w	r9, r9, #8
    8c42:	9b06      	ldr	r3, [sp, #24]
    8c44:	442b      	add	r3, r5
    8c46:	9306      	str	r3, [sp, #24]
    8c48:	7823      	ldrb	r3, [r4, #0]
    8c4a:	2b00      	cmp	r3, #0
    8c4c:	f000 80a3 	beq.w	8d96 <_svfprintf_r+0x1de>
    8c50:	2300      	movs	r3, #0
    8c52:	461a      	mov	r2, r3
    8c54:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    8c58:	4619      	mov	r1, r3
    8c5a:	9307      	str	r3, [sp, #28]
    8c5c:	469b      	mov	fp, r3
    8c5e:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    8c62:	7863      	ldrb	r3, [r4, #1]
    8c64:	f104 0a01 	add.w	sl, r4, #1
    8c68:	4645      	mov	r5, r8
    8c6a:	f10a 0a01 	add.w	sl, sl, #1
    8c6e:	f1a3 0020 	sub.w	r0, r3, #32
    8c72:	2858      	cmp	r0, #88	; 0x58
    8c74:	f200 83f8 	bhi.w	9468 <_svfprintf_r+0x8b0>
    8c78:	e8df f010 	tbh	[pc, r0, lsl #1]
    8c7c:	03f60363 	.word	0x03f60363
    8c80:	036b03f6 	.word	0x036b03f6
    8c84:	03f603f6 	.word	0x03f603f6
    8c88:	03f603f6 	.word	0x03f603f6
    8c8c:	03f603f6 	.word	0x03f603f6
    8c90:	037e0370 	.word	0x037e0370
    8c94:	005d03f6 	.word	0x005d03f6
    8c98:	03f600df 	.word	0x03f600df
    8c9c:	010c00fb 	.word	0x010c00fb
    8ca0:	010c010c 	.word	0x010c010c
    8ca4:	010c010c 	.word	0x010c010c
    8ca8:	010c010c 	.word	0x010c010c
    8cac:	010c010c 	.word	0x010c010c
    8cb0:	03f603f6 	.word	0x03f603f6
    8cb4:	03f603f6 	.word	0x03f603f6
    8cb8:	03f603f6 	.word	0x03f603f6
    8cbc:	03f603f6 	.word	0x03f603f6
    8cc0:	03f603f6 	.word	0x03f603f6
    8cc4:	015e011c 	.word	0x015e011c
    8cc8:	015e03f6 	.word	0x015e03f6
    8ccc:	03f603f6 	.word	0x03f603f6
    8cd0:	03f603f6 	.word	0x03f603f6
    8cd4:	03f602a1 	.word	0x03f602a1
    8cd8:	02a603f6 	.word	0x02a603f6
    8cdc:	03f603f6 	.word	0x03f603f6
    8ce0:	03f603f6 	.word	0x03f603f6
    8ce4:	02d803f6 	.word	0x02d803f6
    8ce8:	03f603f6 	.word	0x03f603f6
    8cec:	03f60305 	.word	0x03f60305
    8cf0:	03f603f6 	.word	0x03f603f6
    8cf4:	03f603f6 	.word	0x03f603f6
    8cf8:	03f603f6 	.word	0x03f603f6
    8cfc:	03f603f6 	.word	0x03f603f6
    8d00:	034303f6 	.word	0x034303f6
    8d04:	015e0356 	.word	0x015e0356
    8d08:	015e015e 	.word	0x015e015e
    8d0c:	0356035e 	.word	0x0356035e
    8d10:	03f603f6 	.word	0x03f603f6
    8d14:	03f603a4 	.word	0x03f603a4
    8d18:	00a203b1 	.word	0x00a203b1
    8d1c:	03c30062 	.word	0x03c30062
    8d20:	03c803f6 	.word	0x03c803f6
    8d24:	038303f6 	.word	0x038303f6
    8d28:	03f603f6 	.word	0x03f603f6
    8d2c:	038b      	.short	0x038b
    8d2e:	9807      	ldr	r0, [sp, #28]
    8d30:	9309      	str	r3, [sp, #36]	; 0x24
    8d32:	4240      	negs	r0, r0
    8d34:	9007      	str	r0, [sp, #28]
    8d36:	f04b 0b04 	orr.w	fp, fp, #4
    8d3a:	f89a 3000 	ldrb.w	r3, [sl]
    8d3e:	e794      	b.n	8c6a <_svfprintf_r+0xb2>
    8d40:	46a8      	mov	r8, r5
    8d42:	9809      	ldr	r0, [sp, #36]	; 0x24
    8d44:	2100      	movs	r1, #0
    8d46:	2330      	movs	r3, #48	; 0x30
    8d48:	2278      	movs	r2, #120	; 0x78
    8d4a:	4588      	cmp	r8, r1
    8d4c:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    8d50:	6804      	ldr	r4, [r0, #0]
    8d52:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    8d56:	f100 0704 	add.w	r7, r0, #4
    8d5a:	f04f 0500 	mov.w	r5, #0
    8d5e:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    8d62:	f04b 0302 	orr.w	r3, fp, #2
    8d66:	f2c0 839c 	blt.w	94a2 <_svfprintf_r+0x8ea>
    8d6a:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    8d6e:	f043 0b02 	orr.w	fp, r3, #2
    8d72:	ea54 0305 	orrs.w	r3, r4, r5
    8d76:	9709      	str	r7, [sp, #36]	; 0x24
    8d78:	f000 8369 	beq.w	944e <_svfprintf_r+0x896>
    8d7c:	460f      	mov	r7, r1
    8d7e:	920c      	str	r2, [sp, #48]	; 0x30
    8d80:	4843      	ldr	r0, [pc, #268]	; (8e90 <_svfprintf_r+0x2d8>)
    8d82:	e2ae      	b.n	92e2 <_svfprintf_r+0x72a>
    8d84:	aa1b      	add	r2, sp, #108	; 0x6c
    8d86:	9903      	ldr	r1, [sp, #12]
    8d88:	9805      	ldr	r0, [sp, #20]
    8d8a:	f001 f9cd 	bl	a128 <__ssprint_r>
    8d8e:	b948      	cbnz	r0, 8da4 <_svfprintf_r+0x1ec>
    8d90:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    8d94:	e755      	b.n	8c42 <_svfprintf_r+0x8a>
    8d96:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    8d98:	b123      	cbz	r3, 8da4 <_svfprintf_r+0x1ec>
    8d9a:	9805      	ldr	r0, [sp, #20]
    8d9c:	9903      	ldr	r1, [sp, #12]
    8d9e:	aa1b      	add	r2, sp, #108	; 0x6c
    8da0:	f001 f9c2 	bl	a128 <__ssprint_r>
    8da4:	9b03      	ldr	r3, [sp, #12]
    8da6:	899b      	ldrh	r3, [r3, #12]
    8da8:	f013 0f40 	tst.w	r3, #64	; 0x40
    8dac:	9b06      	ldr	r3, [sp, #24]
    8dae:	bf18      	it	ne
    8db0:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    8db4:	4618      	mov	r0, r3
    8db6:	b039      	add	sp, #228	; 0xe4
    8db8:	ecbd 8b06 	vpop	{d8-d10}
    8dbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8dc0:	930c      	str	r3, [sp, #48]	; 0x30
    8dc2:	46a8      	mov	r8, r5
    8dc4:	2a00      	cmp	r2, #0
    8dc6:	f041 819a 	bne.w	a0fe <_svfprintf_r+0x1546>
    8dca:	f01b 0320 	ands.w	r3, fp, #32
    8dce:	f000 8206 	beq.w	91de <_svfprintf_r+0x626>
    8dd2:	9f09      	ldr	r7, [sp, #36]	; 0x24
    8dd4:	3707      	adds	r7, #7
    8dd6:	f027 0307 	bic.w	r3, r7, #7
    8dda:	2700      	movs	r7, #0
    8ddc:	f103 0208 	add.w	r2, r3, #8
    8de0:	45b8      	cmp	r8, r7
    8de2:	9209      	str	r2, [sp, #36]	; 0x24
    8de4:	e9d3 4500 	ldrd	r4, r5, [r3]
    8de8:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    8dec:	f2c0 865e 	blt.w	9aac <_svfprintf_r+0xef4>
    8df0:	ea54 0305 	orrs.w	r3, r4, r5
    8df4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    8df8:	f000 834b 	beq.w	9492 <_svfprintf_r+0x8da>
    8dfc:	ae28      	add	r6, sp, #160	; 0xa0
    8dfe:	08e2      	lsrs	r2, r4, #3
    8e00:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
    8e04:	08e9      	lsrs	r1, r5, #3
    8e06:	f004 0307 	and.w	r3, r4, #7
    8e0a:	460d      	mov	r5, r1
    8e0c:	4614      	mov	r4, r2
    8e0e:	3330      	adds	r3, #48	; 0x30
    8e10:	ea54 0205 	orrs.w	r2, r4, r5
    8e14:	f806 3d01 	strb.w	r3, [r6, #-1]!
    8e18:	d1f1      	bne.n	8dfe <_svfprintf_r+0x246>
    8e1a:	f01b 0f01 	tst.w	fp, #1
    8e1e:	f000 8227 	beq.w	9270 <_svfprintf_r+0x6b8>
    8e22:	2b30      	cmp	r3, #48	; 0x30
    8e24:	f000 8224 	beq.w	9270 <_svfprintf_r+0x6b8>
    8e28:	2230      	movs	r2, #48	; 0x30
    8e2a:	1e73      	subs	r3, r6, #1
    8e2c:	f806 2c01 	strb.w	r2, [r6, #-1]
    8e30:	aa28      	add	r2, sp, #160	; 0xa0
    8e32:	1ad2      	subs	r2, r2, r3
    8e34:	9208      	str	r2, [sp, #32]
    8e36:	461e      	mov	r6, r3
    8e38:	e21d      	b.n	9276 <_svfprintf_r+0x6be>
    8e3a:	f89a 3000 	ldrb.w	r3, [sl]
    8e3e:	2b2a      	cmp	r3, #42	; 0x2a
    8e40:	f10a 0401 	add.w	r4, sl, #1
    8e44:	f001 812f 	beq.w	a0a6 <_svfprintf_r+0x14ee>
    8e48:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    8e4c:	2809      	cmp	r0, #9
    8e4e:	bf98      	it	ls
    8e50:	2500      	movls	r5, #0
    8e52:	f201 80d5 	bhi.w	a000 <_svfprintf_r+0x1448>
    8e56:	f814 3b01 	ldrb.w	r3, [r4], #1
    8e5a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    8e5e:	eb00 0545 	add.w	r5, r0, r5, lsl #1
    8e62:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    8e66:	2809      	cmp	r0, #9
    8e68:	d9f5      	bls.n	8e56 <_svfprintf_r+0x29e>
    8e6a:	ea45 75e5 	orr.w	r5, r5, r5, asr #31
    8e6e:	46a2      	mov	sl, r4
    8e70:	e6fd      	b.n	8c6e <_svfprintf_r+0xb6>
    8e72:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
    8e76:	f89a 3000 	ldrb.w	r3, [sl]
    8e7a:	e6f6      	b.n	8c6a <_svfprintf_r+0xb2>
    8e7c:	f3af 8000 	nop.w
	...
    8e88:	ffffffff 	.word	0xffffffff
    8e8c:	7fefffff 	.word	0x7fefffff
    8e90:	20000e74 	.word	0x20000e74
    8e94:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    8e98:	2300      	movs	r3, #0
    8e9a:	461c      	mov	r4, r3
    8e9c:	f81a 3b01 	ldrb.w	r3, [sl], #1
    8ea0:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    8ea4:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    8ea8:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    8eac:	2809      	cmp	r0, #9
    8eae:	d9f5      	bls.n	8e9c <_svfprintf_r+0x2e4>
    8eb0:	9407      	str	r4, [sp, #28]
    8eb2:	e6dc      	b.n	8c6e <_svfprintf_r+0xb6>
    8eb4:	930c      	str	r3, [sp, #48]	; 0x30
    8eb6:	46a8      	mov	r8, r5
    8eb8:	2a00      	cmp	r2, #0
    8eba:	f041 812c 	bne.w	a116 <_svfprintf_r+0x155e>
    8ebe:	f04b 0b10 	orr.w	fp, fp, #16
    8ec2:	f01b 0f20 	tst.w	fp, #32
    8ec6:	f000 8503 	beq.w	98d0 <_svfprintf_r+0xd18>
    8eca:	9f09      	ldr	r7, [sp, #36]	; 0x24
    8ecc:	3707      	adds	r7, #7
    8ece:	f027 0707 	bic.w	r7, r7, #7
    8ed2:	e9d7 2300 	ldrd	r2, r3, [r7]
    8ed6:	f107 0108 	add.w	r1, r7, #8
    8eda:	9109      	str	r1, [sp, #36]	; 0x24
    8edc:	4614      	mov	r4, r2
    8ede:	461d      	mov	r5, r3
    8ee0:	2a00      	cmp	r2, #0
    8ee2:	f173 0300 	sbcs.w	r3, r3, #0
    8ee6:	f2c0 8537 	blt.w	9958 <_svfprintf_r+0xda0>
    8eea:	f1b8 0f00 	cmp.w	r8, #0
    8eee:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    8ef2:	f2c0 81b5 	blt.w	9260 <_svfprintf_r+0x6a8>
    8ef6:	ea54 0305 	orrs.w	r3, r4, r5
    8efa:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    8efe:	f000 83f6 	beq.w	96ee <_svfprintf_r+0xb36>
    8f02:	2d00      	cmp	r5, #0
    8f04:	bf08      	it	eq
    8f06:	2c0a      	cmpeq	r4, #10
    8f08:	f0c0 81ae 	bcc.w	9268 <_svfprintf_r+0x6b0>
    8f0c:	ae28      	add	r6, sp, #160	; 0xa0
    8f0e:	4620      	mov	r0, r4
    8f10:	4629      	mov	r1, r5
    8f12:	220a      	movs	r2, #10
    8f14:	2300      	movs	r3, #0
    8f16:	f7fc fed1 	bl	5cbc <__aeabi_uldivmod>
    8f1a:	3230      	adds	r2, #48	; 0x30
    8f1c:	f806 2d01 	strb.w	r2, [r6, #-1]!
    8f20:	4620      	mov	r0, r4
    8f22:	4629      	mov	r1, r5
    8f24:	2300      	movs	r3, #0
    8f26:	220a      	movs	r2, #10
    8f28:	f7fc fec8 	bl	5cbc <__aeabi_uldivmod>
    8f2c:	4604      	mov	r4, r0
    8f2e:	460d      	mov	r5, r1
    8f30:	ea54 0305 	orrs.w	r3, r4, r5
    8f34:	d1eb      	bne.n	8f0e <_svfprintf_r+0x356>
    8f36:	e19b      	b.n	9270 <_svfprintf_r+0x6b8>
    8f38:	930c      	str	r3, [sp, #48]	; 0x30
    8f3a:	46a8      	mov	r8, r5
    8f3c:	2a00      	cmp	r2, #0
    8f3e:	f041 80e6 	bne.w	a10e <_svfprintf_r+0x1556>
    8f42:	9f09      	ldr	r7, [sp, #36]	; 0x24
    8f44:	f01b 0f08 	tst.w	fp, #8
    8f48:	f107 0707 	add.w	r7, r7, #7
    8f4c:	f000 8640 	beq.w	9bd0 <_svfprintf_r+0x1018>
    8f50:	f027 0307 	bic.w	r3, r7, #7
    8f54:	ed93 8b00 	vldr	d8, [r3]
    8f58:	f103 0208 	add.w	r2, r3, #8
    8f5c:	9209      	str	r2, [sp, #36]	; 0x24
    8f5e:	eeb0 7bc8 	vabs.f64	d7, d8
    8f62:	eeb4 7b49 	vcmp.f64	d7, d9
    8f66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8f6a:	f340 85bc 	ble.w	9ae6 <_svfprintf_r+0xf2e>
    8f6e:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
    8f72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    8f76:	f100 87ca 	bmi.w	9f0e <_svfprintf_r+0x1356>
    8f7a:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    8f7e:	4ea7      	ldr	r6, [pc, #668]	; (921c <_svfprintf_r+0x664>)
    8f80:	4ba7      	ldr	r3, [pc, #668]	; (9220 <_svfprintf_r+0x668>)
    8f82:	990c      	ldr	r1, [sp, #48]	; 0x30
    8f84:	2203      	movs	r2, #3
    8f86:	f04f 0800 	mov.w	r8, #0
    8f8a:	9204      	str	r2, [sp, #16]
    8f8c:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    8f90:	2947      	cmp	r1, #71	; 0x47
    8f92:	bfd8      	it	le
    8f94:	461e      	movle	r6, r3
    8f96:	9208      	str	r2, [sp, #32]
    8f98:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    8f9c:	b117      	cbz	r7, 8fa4 <_svfprintf_r+0x3ec>
    8f9e:	9b04      	ldr	r3, [sp, #16]
    8fa0:	3301      	adds	r3, #1
    8fa2:	9304      	str	r3, [sp, #16]
    8fa4:	f01b 0302 	ands.w	r3, fp, #2
    8fa8:	930a      	str	r3, [sp, #40]	; 0x28
    8faa:	d002      	beq.n	8fb2 <_svfprintf_r+0x3fa>
    8fac:	9b04      	ldr	r3, [sp, #16]
    8fae:	3302      	adds	r3, #2
    8fb0:	9304      	str	r3, [sp, #16]
    8fb2:	f01b 0384 	ands.w	r3, fp, #132	; 0x84
    8fb6:	930b      	str	r3, [sp, #44]	; 0x2c
    8fb8:	f040 8280 	bne.w	94bc <_svfprintf_r+0x904>
    8fbc:	9b07      	ldr	r3, [sp, #28]
    8fbe:	9a04      	ldr	r2, [sp, #16]
    8fc0:	1a9c      	subs	r4, r3, r2
    8fc2:	2c00      	cmp	r4, #0
    8fc4:	f340 827a 	ble.w	94bc <_svfprintf_r+0x904>
    8fc8:	2c10      	cmp	r4, #16
    8fca:	991d      	ldr	r1, [sp, #116]	; 0x74
    8fcc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    8fce:	4f95      	ldr	r7, [pc, #596]	; (9224 <_svfprintf_r+0x66c>)
    8fd0:	dd23      	ble.n	901a <_svfprintf_r+0x462>
    8fd2:	4648      	mov	r0, r9
    8fd4:	2510      	movs	r5, #16
    8fd6:	46c1      	mov	r9, r8
    8fd8:	46b0      	mov	r8, r6
    8fda:	9e05      	ldr	r6, [sp, #20]
    8fdc:	e004      	b.n	8fe8 <_svfprintf_r+0x430>
    8fde:	3c10      	subs	r4, #16
    8fe0:	2c10      	cmp	r4, #16
    8fe2:	f100 0008 	add.w	r0, r0, #8
    8fe6:	dd15      	ble.n	9014 <_svfprintf_r+0x45c>
    8fe8:	3201      	adds	r2, #1
    8fea:	3110      	adds	r1, #16
    8fec:	2a07      	cmp	r2, #7
    8fee:	911d      	str	r1, [sp, #116]	; 0x74
    8ff0:	921c      	str	r2, [sp, #112]	; 0x70
    8ff2:	6007      	str	r7, [r0, #0]
    8ff4:	6045      	str	r5, [r0, #4]
    8ff6:	ddf2      	ble.n	8fde <_svfprintf_r+0x426>
    8ff8:	aa1b      	add	r2, sp, #108	; 0x6c
    8ffa:	9903      	ldr	r1, [sp, #12]
    8ffc:	4630      	mov	r0, r6
    8ffe:	f001 f893 	bl	a128 <__ssprint_r>
    9002:	2800      	cmp	r0, #0
    9004:	f47f aece 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9008:	3c10      	subs	r4, #16
    900a:	2c10      	cmp	r4, #16
    900c:	991d      	ldr	r1, [sp, #116]	; 0x74
    900e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9010:	a828      	add	r0, sp, #160	; 0xa0
    9012:	dce9      	bgt.n	8fe8 <_svfprintf_r+0x430>
    9014:	4646      	mov	r6, r8
    9016:	46c8      	mov	r8, r9
    9018:	4681      	mov	r9, r0
    901a:	3201      	adds	r2, #1
    901c:	1863      	adds	r3, r4, r1
    901e:	2a07      	cmp	r2, #7
    9020:	931d      	str	r3, [sp, #116]	; 0x74
    9022:	921c      	str	r2, [sp, #112]	; 0x70
    9024:	f8c9 7000 	str.w	r7, [r9]
    9028:	f8c9 4004 	str.w	r4, [r9, #4]
    902c:	f300 83e2 	bgt.w	97f4 <_svfprintf_r+0xc3c>
    9030:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9034:	f109 0908 	add.w	r9, r9, #8
    9038:	b177      	cbz	r7, 9058 <_svfprintf_r+0x4a0>
    903a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    903c:	3201      	adds	r2, #1
    903e:	3301      	adds	r3, #1
    9040:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
    9044:	2101      	movs	r1, #1
    9046:	2a07      	cmp	r2, #7
    9048:	931d      	str	r3, [sp, #116]	; 0x74
    904a:	921c      	str	r2, [sp, #112]	; 0x70
    904c:	e889 0003 	stmia.w	r9, {r0, r1}
    9050:	f300 835f 	bgt.w	9712 <_svfprintf_r+0xb5a>
    9054:	f109 0908 	add.w	r9, r9, #8
    9058:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    905a:	b16a      	cbz	r2, 9078 <_svfprintf_r+0x4c0>
    905c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    905e:	3201      	adds	r2, #1
    9060:	3302      	adds	r3, #2
    9062:	a814      	add	r0, sp, #80	; 0x50
    9064:	2102      	movs	r1, #2
    9066:	2a07      	cmp	r2, #7
    9068:	931d      	str	r3, [sp, #116]	; 0x74
    906a:	921c      	str	r2, [sp, #112]	; 0x70
    906c:	e889 0003 	stmia.w	r9, {r0, r1}
    9070:	f300 835b 	bgt.w	972a <_svfprintf_r+0xb72>
    9074:	f109 0908 	add.w	r9, r9, #8
    9078:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    907a:	2a80      	cmp	r2, #128	; 0x80
    907c:	f000 827e 	beq.w	957c <_svfprintf_r+0x9c4>
    9080:	9a08      	ldr	r2, [sp, #32]
    9082:	ebc2 0408 	rsb	r4, r2, r8
    9086:	2c00      	cmp	r4, #0
    9088:	dd34      	ble.n	90f4 <_svfprintf_r+0x53c>
    908a:	2c10      	cmp	r4, #16
    908c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    908e:	4f66      	ldr	r7, [pc, #408]	; (9228 <_svfprintf_r+0x670>)
    9090:	dd23      	ble.n	90da <_svfprintf_r+0x522>
    9092:	4649      	mov	r1, r9
    9094:	f04f 0810 	mov.w	r8, #16
    9098:	46b1      	mov	r9, r6
    909a:	9d05      	ldr	r5, [sp, #20]
    909c:	9e03      	ldr	r6, [sp, #12]
    909e:	e004      	b.n	90aa <_svfprintf_r+0x4f2>
    90a0:	3c10      	subs	r4, #16
    90a2:	2c10      	cmp	r4, #16
    90a4:	f101 0108 	add.w	r1, r1, #8
    90a8:	dd15      	ble.n	90d6 <_svfprintf_r+0x51e>
    90aa:	3201      	adds	r2, #1
    90ac:	3310      	adds	r3, #16
    90ae:	2a07      	cmp	r2, #7
    90b0:	931d      	str	r3, [sp, #116]	; 0x74
    90b2:	921c      	str	r2, [sp, #112]	; 0x70
    90b4:	e881 0180 	stmia.w	r1, {r7, r8}
    90b8:	ddf2      	ble.n	90a0 <_svfprintf_r+0x4e8>
    90ba:	aa1b      	add	r2, sp, #108	; 0x6c
    90bc:	4631      	mov	r1, r6
    90be:	4628      	mov	r0, r5
    90c0:	f001 f832 	bl	a128 <__ssprint_r>
    90c4:	2800      	cmp	r0, #0
    90c6:	f47f ae6d 	bne.w	8da4 <_svfprintf_r+0x1ec>
    90ca:	3c10      	subs	r4, #16
    90cc:	2c10      	cmp	r4, #16
    90ce:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    90d0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    90d2:	a928      	add	r1, sp, #160	; 0xa0
    90d4:	dce9      	bgt.n	90aa <_svfprintf_r+0x4f2>
    90d6:	464e      	mov	r6, r9
    90d8:	4689      	mov	r9, r1
    90da:	3201      	adds	r2, #1
    90dc:	4423      	add	r3, r4
    90de:	2a07      	cmp	r2, #7
    90e0:	931d      	str	r3, [sp, #116]	; 0x74
    90e2:	921c      	str	r2, [sp, #112]	; 0x70
    90e4:	f8c9 7000 	str.w	r7, [r9]
    90e8:	f8c9 4004 	str.w	r4, [r9, #4]
    90ec:	f300 8305 	bgt.w	96fa <_svfprintf_r+0xb42>
    90f0:	f109 0908 	add.w	r9, r9, #8
    90f4:	f41b 7f80 	tst.w	fp, #256	; 0x100
    90f8:	f040 81e2 	bne.w	94c0 <_svfprintf_r+0x908>
    90fc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    90fe:	9808      	ldr	r0, [sp, #32]
    9100:	f8c9 6000 	str.w	r6, [r9]
    9104:	3201      	adds	r2, #1
    9106:	4403      	add	r3, r0
    9108:	2a07      	cmp	r2, #7
    910a:	931d      	str	r3, [sp, #116]	; 0x74
    910c:	f8c9 0004 	str.w	r0, [r9, #4]
    9110:	921c      	str	r2, [sp, #112]	; 0x70
    9112:	f300 82c2 	bgt.w	969a <_svfprintf_r+0xae2>
    9116:	f109 0908 	add.w	r9, r9, #8
    911a:	f01b 0f04 	tst.w	fp, #4
    911e:	d03e      	beq.n	919e <_svfprintf_r+0x5e6>
    9120:	9a07      	ldr	r2, [sp, #28]
    9122:	9904      	ldr	r1, [sp, #16]
    9124:	1a54      	subs	r4, r2, r1
    9126:	2c00      	cmp	r4, #0
    9128:	dd39      	ble.n	919e <_svfprintf_r+0x5e6>
    912a:	2c10      	cmp	r4, #16
    912c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    912e:	4f3d      	ldr	r7, [pc, #244]	; (9224 <_svfprintf_r+0x66c>)
    9130:	dd22      	ble.n	9178 <_svfprintf_r+0x5c0>
    9132:	2510      	movs	r5, #16
    9134:	9e05      	ldr	r6, [sp, #20]
    9136:	f8dd 800c 	ldr.w	r8, [sp, #12]
    913a:	e004      	b.n	9146 <_svfprintf_r+0x58e>
    913c:	3c10      	subs	r4, #16
    913e:	2c10      	cmp	r4, #16
    9140:	f109 0908 	add.w	r9, r9, #8
    9144:	dd18      	ble.n	9178 <_svfprintf_r+0x5c0>
    9146:	3201      	adds	r2, #1
    9148:	3310      	adds	r3, #16
    914a:	2a07      	cmp	r2, #7
    914c:	931d      	str	r3, [sp, #116]	; 0x74
    914e:	921c      	str	r2, [sp, #112]	; 0x70
    9150:	f8c9 7000 	str.w	r7, [r9]
    9154:	f8c9 5004 	str.w	r5, [r9, #4]
    9158:	ddf0      	ble.n	913c <_svfprintf_r+0x584>
    915a:	aa1b      	add	r2, sp, #108	; 0x6c
    915c:	4641      	mov	r1, r8
    915e:	4630      	mov	r0, r6
    9160:	f000 ffe2 	bl	a128 <__ssprint_r>
    9164:	2800      	cmp	r0, #0
    9166:	f47f ae1d 	bne.w	8da4 <_svfprintf_r+0x1ec>
    916a:	3c10      	subs	r4, #16
    916c:	2c10      	cmp	r4, #16
    916e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9170:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9172:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9176:	dce6      	bgt.n	9146 <_svfprintf_r+0x58e>
    9178:	3201      	adds	r2, #1
    917a:	4423      	add	r3, r4
    917c:	2a07      	cmp	r2, #7
    917e:	931d      	str	r3, [sp, #116]	; 0x74
    9180:	921c      	str	r2, [sp, #112]	; 0x70
    9182:	f8c9 7000 	str.w	r7, [r9]
    9186:	f8c9 4004 	str.w	r4, [r9, #4]
    918a:	dd08      	ble.n	919e <_svfprintf_r+0x5e6>
    918c:	aa1b      	add	r2, sp, #108	; 0x6c
    918e:	9903      	ldr	r1, [sp, #12]
    9190:	9805      	ldr	r0, [sp, #20]
    9192:	f000 ffc9 	bl	a128 <__ssprint_r>
    9196:	2800      	cmp	r0, #0
    9198:	f47f ae04 	bne.w	8da4 <_svfprintf_r+0x1ec>
    919c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    919e:	9a06      	ldr	r2, [sp, #24]
    91a0:	9907      	ldr	r1, [sp, #28]
    91a2:	9804      	ldr	r0, [sp, #16]
    91a4:	4281      	cmp	r1, r0
    91a6:	bfac      	ite	ge
    91a8:	1852      	addge	r2, r2, r1
    91aa:	1812      	addlt	r2, r2, r0
    91ac:	9206      	str	r2, [sp, #24]
    91ae:	2b00      	cmp	r3, #0
    91b0:	f040 827f 	bne.w	96b2 <_svfprintf_r+0xafa>
    91b4:	2300      	movs	r3, #0
    91b6:	931c      	str	r3, [sp, #112]	; 0x70
    91b8:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    91bc:	e522      	b.n	8c04 <_svfprintf_r+0x4c>
    91be:	f04b 0b08 	orr.w	fp, fp, #8
    91c2:	f89a 3000 	ldrb.w	r3, [sl]
    91c6:	e550      	b.n	8c6a <_svfprintf_r+0xb2>
    91c8:	930c      	str	r3, [sp, #48]	; 0x30
    91ca:	46a8      	mov	r8, r5
    91cc:	2a00      	cmp	r2, #0
    91ce:	f040 879a 	bne.w	a106 <_svfprintf_r+0x154e>
    91d2:	f04b 0b10 	orr.w	fp, fp, #16
    91d6:	f01b 0320 	ands.w	r3, fp, #32
    91da:	f47f adfa 	bne.w	8dd2 <_svfprintf_r+0x21a>
    91de:	f01b 0210 	ands.w	r2, fp, #16
    91e2:	f040 8391 	bne.w	9908 <_svfprintf_r+0xd50>
    91e6:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    91ea:	f000 838d 	beq.w	9908 <_svfprintf_r+0xd50>
    91ee:	9909      	ldr	r1, [sp, #36]	; 0x24
    91f0:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    91f4:	460b      	mov	r3, r1
    91f6:	f1b8 0f00 	cmp.w	r8, #0
    91fa:	f103 0304 	add.w	r3, r3, #4
    91fe:	880c      	ldrh	r4, [r1, #0]
    9200:	f04f 0500 	mov.w	r5, #0
    9204:	f2c0 85ab 	blt.w	9d5e <_svfprintf_r+0x11a6>
    9208:	ea54 0105 	orrs.w	r1, r4, r5
    920c:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9210:	9309      	str	r3, [sp, #36]	; 0x24
    9212:	f000 813e 	beq.w	9492 <_svfprintf_r+0x8da>
    9216:	4617      	mov	r7, r2
    9218:	e5f0      	b.n	8dfc <_svfprintf_r+0x244>
    921a:	bf00      	nop
    921c:	20000e54 	.word	0x20000e54
    9220:	20000e50 	.word	0x20000e50
    9224:	200006cc 	.word	0x200006cc
    9228:	20001034 	.word	0x20001034
    922c:	930c      	str	r3, [sp, #48]	; 0x30
    922e:	46a8      	mov	r8, r5
    9230:	2a00      	cmp	r2, #0
    9232:	f040 8759 	bne.w	a0e8 <_svfprintf_r+0x1530>
    9236:	f04b 0b10 	orr.w	fp, fp, #16
    923a:	f01b 0320 	ands.w	r3, fp, #32
    923e:	f000 82e7 	beq.w	9810 <_svfprintf_r+0xc58>
    9242:	9f09      	ldr	r7, [sp, #36]	; 0x24
    9244:	3707      	adds	r7, #7
    9246:	f027 0307 	bic.w	r3, r7, #7
    924a:	2700      	movs	r7, #0
    924c:	f103 0208 	add.w	r2, r3, #8
    9250:	45b8      	cmp	r8, r7
    9252:	9209      	str	r2, [sp, #36]	; 0x24
    9254:	e9d3 4500 	ldrd	r4, r5, [r3]
    9258:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    925c:	f6bf ae4b 	bge.w	8ef6 <_svfprintf_r+0x33e>
    9260:	ea54 0305 	orrs.w	r3, r4, r5
    9264:	f47f ae4d 	bne.w	8f02 <_svfprintf_r+0x34a>
    9268:	ae38      	add	r6, sp, #224	; 0xe0
    926a:	3430      	adds	r4, #48	; 0x30
    926c:	f806 4d41 	strb.w	r4, [r6, #-65]!
    9270:	ab28      	add	r3, sp, #160	; 0xa0
    9272:	1b9b      	subs	r3, r3, r6
    9274:	9308      	str	r3, [sp, #32]
    9276:	9b08      	ldr	r3, [sp, #32]
    9278:	4543      	cmp	r3, r8
    927a:	bfb8      	it	lt
    927c:	4643      	movlt	r3, r8
    927e:	9304      	str	r3, [sp, #16]
    9280:	2300      	movs	r3, #0
    9282:	930e      	str	r3, [sp, #56]	; 0x38
    9284:	e68a      	b.n	8f9c <_svfprintf_r+0x3e4>
    9286:	930c      	str	r3, [sp, #48]	; 0x30
    9288:	46a8      	mov	r8, r5
    928a:	2a00      	cmp	r2, #0
    928c:	f040 8728 	bne.w	a0e0 <_svfprintf_r+0x1528>
    9290:	f01b 0f20 	tst.w	fp, #32
    9294:	48c2      	ldr	r0, [pc, #776]	; (95a0 <_svfprintf_r+0x9e8>)
    9296:	f000 8086 	beq.w	93a6 <_svfprintf_r+0x7ee>
    929a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    929c:	3707      	adds	r7, #7
    929e:	f027 0307 	bic.w	r3, r7, #7
    92a2:	e9d3 4500 	ldrd	r4, r5, [r3]
    92a6:	f103 0208 	add.w	r2, r3, #8
    92aa:	9209      	str	r2, [sp, #36]	; 0x24
    92ac:	f01b 0701 	ands.w	r7, fp, #1
    92b0:	f000 8247 	beq.w	9742 <_svfprintf_r+0xb8a>
    92b4:	ea54 0305 	orrs.w	r3, r4, r5
    92b8:	f000 84a3 	beq.w	9c02 <_svfprintf_r+0x104a>
    92bc:	2700      	movs	r7, #0
    92be:	2330      	movs	r3, #48	; 0x30
    92c0:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    92c4:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    92c8:	45b8      	cmp	r8, r7
    92ca:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    92ce:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    92d2:	f04b 0302 	orr.w	r3, fp, #2
    92d6:	f2c0 8617 	blt.w	9f08 <_svfprintf_r+0x1350>
    92da:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    92de:	f043 0b02 	orr.w	fp, r3, #2
    92e2:	ae28      	add	r6, sp, #160	; 0xa0
    92e4:	0923      	lsrs	r3, r4, #4
    92e6:	f004 010f 	and.w	r1, r4, #15
    92ea:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
    92ee:	092a      	lsrs	r2, r5, #4
    92f0:	461c      	mov	r4, r3
    92f2:	4615      	mov	r5, r2
    92f4:	5c43      	ldrb	r3, [r0, r1]
    92f6:	f806 3d01 	strb.w	r3, [r6, #-1]!
    92fa:	ea54 0305 	orrs.w	r3, r4, r5
    92fe:	d1f1      	bne.n	92e4 <_svfprintf_r+0x72c>
    9300:	e7b6      	b.n	9270 <_svfprintf_r+0x6b8>
    9302:	9909      	ldr	r1, [sp, #36]	; 0x24
    9304:	930c      	str	r3, [sp, #48]	; 0x30
    9306:	680a      	ldr	r2, [r1, #0]
    9308:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    930c:	2300      	movs	r3, #0
    930e:	460a      	mov	r2, r1
    9310:	461f      	mov	r7, r3
    9312:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9316:	3204      	adds	r2, #4
    9318:	2301      	movs	r3, #1
    931a:	9304      	str	r3, [sp, #16]
    931c:	46b8      	mov	r8, r7
    931e:	970e      	str	r7, [sp, #56]	; 0x38
    9320:	9209      	str	r2, [sp, #36]	; 0x24
    9322:	9308      	str	r3, [sp, #32]
    9324:	ae1e      	add	r6, sp, #120	; 0x78
    9326:	e63d      	b.n	8fa4 <_svfprintf_r+0x3ec>
    9328:	930c      	str	r3, [sp, #48]	; 0x30
    932a:	46a8      	mov	r8, r5
    932c:	2a00      	cmp	r2, #0
    932e:	f43f adc8 	beq.w	8ec2 <_svfprintf_r+0x30a>
    9332:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    9336:	e5c4      	b.n	8ec2 <_svfprintf_r+0x30a>
    9338:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
    933c:	f89a 3000 	ldrb.w	r3, [sl]
    9340:	e493      	b.n	8c6a <_svfprintf_r+0xb2>
    9342:	f89a 3000 	ldrb.w	r3, [sl]
    9346:	2900      	cmp	r1, #0
    9348:	f47f ac8f 	bne.w	8c6a <_svfprintf_r+0xb2>
    934c:	2201      	movs	r2, #1
    934e:	2120      	movs	r1, #32
    9350:	e48b      	b.n	8c6a <_svfprintf_r+0xb2>
    9352:	f04b 0b01 	orr.w	fp, fp, #1
    9356:	f89a 3000 	ldrb.w	r3, [sl]
    935a:	e486      	b.n	8c6a <_svfprintf_r+0xb2>
    935c:	9c09      	ldr	r4, [sp, #36]	; 0x24
    935e:	6823      	ldr	r3, [r4, #0]
    9360:	9307      	str	r3, [sp, #28]
    9362:	4618      	mov	r0, r3
    9364:	2800      	cmp	r0, #0
    9366:	4623      	mov	r3, r4
    9368:	f103 0304 	add.w	r3, r3, #4
    936c:	f6ff acdf 	blt.w	8d2e <_svfprintf_r+0x176>
    9370:	9309      	str	r3, [sp, #36]	; 0x24
    9372:	f89a 3000 	ldrb.w	r3, [sl]
    9376:	e478      	b.n	8c6a <_svfprintf_r+0xb2>
    9378:	f89a 3000 	ldrb.w	r3, [sl]
    937c:	2201      	movs	r2, #1
    937e:	212b      	movs	r1, #43	; 0x2b
    9380:	e473      	b.n	8c6a <_svfprintf_r+0xb2>
    9382:	930c      	str	r3, [sp, #48]	; 0x30
    9384:	46a8      	mov	r8, r5
    9386:	2a00      	cmp	r2, #0
    9388:	f43f af57 	beq.w	923a <_svfprintf_r+0x682>
    938c:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    9390:	e753      	b.n	923a <_svfprintf_r+0x682>
    9392:	930c      	str	r3, [sp, #48]	; 0x30
    9394:	46a8      	mov	r8, r5
    9396:	2a00      	cmp	r2, #0
    9398:	f040 86aa 	bne.w	a0f0 <_svfprintf_r+0x1538>
    939c:	f01b 0f20 	tst.w	fp, #32
    93a0:	4880      	ldr	r0, [pc, #512]	; (95a4 <_svfprintf_r+0x9ec>)
    93a2:	f47f af7a 	bne.w	929a <_svfprintf_r+0x6e2>
    93a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    93a8:	f01b 0f10 	tst.w	fp, #16
    93ac:	4613      	mov	r3, r2
    93ae:	f040 82c1 	bne.w	9934 <_svfprintf_r+0xd7c>
    93b2:	f01b 0f40 	tst.w	fp, #64	; 0x40
    93b6:	f000 82bd 	beq.w	9934 <_svfprintf_r+0xd7c>
    93ba:	3304      	adds	r3, #4
    93bc:	8814      	ldrh	r4, [r2, #0]
    93be:	9309      	str	r3, [sp, #36]	; 0x24
    93c0:	2500      	movs	r5, #0
    93c2:	e773      	b.n	92ac <_svfprintf_r+0x6f4>
    93c4:	f89a 3000 	ldrb.w	r3, [sl]
    93c8:	2b6c      	cmp	r3, #108	; 0x6c
    93ca:	bf03      	ittte	eq
    93cc:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
    93d0:	f04b 0b20 	orreq.w	fp, fp, #32
    93d4:	f10a 0a01 	addeq.w	sl, sl, #1
    93d8:	f04b 0b10 	orrne.w	fp, fp, #16
    93dc:	e445      	b.n	8c6a <_svfprintf_r+0xb2>
    93de:	2a00      	cmp	r2, #0
    93e0:	f040 866f 	bne.w	a0c2 <_svfprintf_r+0x150a>
    93e4:	f01b 0f20 	tst.w	fp, #32
    93e8:	f000 8366 	beq.w	9ab8 <_svfprintf_r+0xf00>
    93ec:	9a09      	ldr	r2, [sp, #36]	; 0x24
    93ee:	9906      	ldr	r1, [sp, #24]
    93f0:	6813      	ldr	r3, [r2, #0]
    93f2:	17cd      	asrs	r5, r1, #31
    93f4:	4608      	mov	r0, r1
    93f6:	3204      	adds	r2, #4
    93f8:	4629      	mov	r1, r5
    93fa:	9209      	str	r2, [sp, #36]	; 0x24
    93fc:	e9c3 0100 	strd	r0, r1, [r3]
    9400:	e400      	b.n	8c04 <_svfprintf_r+0x4c>
    9402:	f04b 0b20 	orr.w	fp, fp, #32
    9406:	f89a 3000 	ldrb.w	r3, [sl]
    940a:	e42e      	b.n	8c6a <_svfprintf_r+0xb2>
    940c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    940e:	930c      	str	r3, [sp, #48]	; 0x30
    9410:	6816      	ldr	r6, [r2, #0]
    9412:	2400      	movs	r4, #0
    9414:	f88d 404f 	strb.w	r4, [sp, #79]	; 0x4f
    9418:	1d17      	adds	r7, r2, #4
    941a:	2e00      	cmp	r6, #0
    941c:	f000 8565 	beq.w	9eea <_svfprintf_r+0x1332>
    9420:	2d00      	cmp	r5, #0
    9422:	f2c0 84a2 	blt.w	9d6a <_svfprintf_r+0x11b2>
    9426:	462a      	mov	r2, r5
    9428:	4621      	mov	r1, r4
    942a:	4630      	mov	r0, r6
    942c:	f7fe f928 	bl	7680 <memchr>
    9430:	2800      	cmp	r0, #0
    9432:	f000 85cc 	beq.w	9fce <_svfprintf_r+0x1416>
    9436:	1b83      	subs	r3, r0, r6
    9438:	9308      	str	r3, [sp, #32]
    943a:	46a0      	mov	r8, r4
    943c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9440:	9709      	str	r7, [sp, #36]	; 0x24
    9442:	9304      	str	r3, [sp, #16]
    9444:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    9448:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    944c:	e5a6      	b.n	8f9c <_svfprintf_r+0x3e4>
    944e:	4855      	ldr	r0, [pc, #340]	; (95a4 <_svfprintf_r+0x9ec>)
    9450:	920c      	str	r2, [sp, #48]	; 0x30
    9452:	f1b8 0f00 	cmp.w	r8, #0
    9456:	f040 8184 	bne.w	9762 <_svfprintf_r+0xbaa>
    945a:	4647      	mov	r7, r8
    945c:	f04f 0800 	mov.w	r8, #0
    9460:	f8cd 8020 	str.w	r8, [sp, #32]
    9464:	ae28      	add	r6, sp, #160	; 0xa0
    9466:	e706      	b.n	9276 <_svfprintf_r+0x6be>
    9468:	930c      	str	r3, [sp, #48]	; 0x30
    946a:	2a00      	cmp	r2, #0
    946c:	f040 862d 	bne.w	a0ca <_svfprintf_r+0x1512>
    9470:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9472:	2a00      	cmp	r2, #0
    9474:	f43f ac8f 	beq.w	8d96 <_svfprintf_r+0x1de>
    9478:	2300      	movs	r3, #0
    947a:	2101      	movs	r1, #1
    947c:	461f      	mov	r7, r3
    947e:	9104      	str	r1, [sp, #16]
    9480:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    9484:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9488:	4698      	mov	r8, r3
    948a:	930e      	str	r3, [sp, #56]	; 0x38
    948c:	9108      	str	r1, [sp, #32]
    948e:	ae1e      	add	r6, sp, #120	; 0x78
    9490:	e588      	b.n	8fa4 <_svfprintf_r+0x3ec>
    9492:	f1b8 0f00 	cmp.w	r8, #0
    9496:	f000 858b 	beq.w	9fb0 <_svfprintf_r+0x13f8>
    949a:	2700      	movs	r7, #0
    949c:	2400      	movs	r4, #0
    949e:	2500      	movs	r5, #0
    94a0:	e4ac      	b.n	8dfc <_svfprintf_r+0x244>
    94a2:	4840      	ldr	r0, [pc, #256]	; (95a4 <_svfprintf_r+0x9ec>)
    94a4:	920c      	str	r2, [sp, #48]	; 0x30
    94a6:	469b      	mov	fp, r3
    94a8:	ea54 0305 	orrs.w	r3, r4, r5
    94ac:	9709      	str	r7, [sp, #36]	; 0x24
    94ae:	f04f 0700 	mov.w	r7, #0
    94b2:	f47f af16 	bne.w	92e2 <_svfprintf_r+0x72a>
    94b6:	2400      	movs	r4, #0
    94b8:	2500      	movs	r5, #0
    94ba:	e712      	b.n	92e2 <_svfprintf_r+0x72a>
    94bc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    94be:	e5bb      	b.n	9038 <_svfprintf_r+0x480>
    94c0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    94c2:	2a65      	cmp	r2, #101	; 0x65
    94c4:	f340 80a1 	ble.w	960a <_svfprintf_r+0xa52>
    94c8:	eeb5 8b40 	vcmp.f64	d8, #0.0
    94cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    94d0:	f040 8149 	bne.w	9766 <_svfprintf_r+0xbae>
    94d4:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    94d6:	4934      	ldr	r1, [pc, #208]	; (95a8 <_svfprintf_r+0x9f0>)
    94d8:	f8c9 1000 	str.w	r1, [r9]
    94dc:	3201      	adds	r2, #1
    94de:	3301      	adds	r3, #1
    94e0:	2101      	movs	r1, #1
    94e2:	2a07      	cmp	r2, #7
    94e4:	931d      	str	r3, [sp, #116]	; 0x74
    94e6:	921c      	str	r2, [sp, #112]	; 0x70
    94e8:	f8c9 1004 	str.w	r1, [r9, #4]
    94ec:	f300 8392 	bgt.w	9c14 <_svfprintf_r+0x105c>
    94f0:	f109 0908 	add.w	r9, r9, #8
    94f4:	9a15      	ldr	r2, [sp, #84]	; 0x54
    94f6:	990d      	ldr	r1, [sp, #52]	; 0x34
    94f8:	428a      	cmp	r2, r1
    94fa:	db03      	blt.n	9504 <_svfprintf_r+0x94c>
    94fc:	f01b 0f01 	tst.w	fp, #1
    9500:	f43f ae0b 	beq.w	911a <_svfprintf_r+0x562>
    9504:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9506:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9508:	9910      	ldr	r1, [sp, #64]	; 0x40
    950a:	f8c9 1000 	str.w	r1, [r9]
    950e:	3201      	adds	r2, #1
    9510:	4403      	add	r3, r0
    9512:	2a07      	cmp	r2, #7
    9514:	931d      	str	r3, [sp, #116]	; 0x74
    9516:	f8c9 0004 	str.w	r0, [r9, #4]
    951a:	921c      	str	r2, [sp, #112]	; 0x70
    951c:	f300 83d6 	bgt.w	9ccc <_svfprintf_r+0x1114>
    9520:	f109 0908 	add.w	r9, r9, #8
    9524:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9526:	1e54      	subs	r4, r2, #1
    9528:	2c00      	cmp	r4, #0
    952a:	f77f adf6 	ble.w	911a <_svfprintf_r+0x562>
    952e:	2c10      	cmp	r4, #16
    9530:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9532:	4f1e      	ldr	r7, [pc, #120]	; (95ac <_svfprintf_r+0x9f4>)
    9534:	f340 81dc 	ble.w	98f0 <_svfprintf_r+0xd38>
    9538:	2510      	movs	r5, #16
    953a:	9e05      	ldr	r6, [sp, #20]
    953c:	f8dd 800c 	ldr.w	r8, [sp, #12]
    9540:	e005      	b.n	954e <_svfprintf_r+0x996>
    9542:	f109 0908 	add.w	r9, r9, #8
    9546:	3c10      	subs	r4, #16
    9548:	2c10      	cmp	r4, #16
    954a:	f340 81d1 	ble.w	98f0 <_svfprintf_r+0xd38>
    954e:	3201      	adds	r2, #1
    9550:	3310      	adds	r3, #16
    9552:	2a07      	cmp	r2, #7
    9554:	931d      	str	r3, [sp, #116]	; 0x74
    9556:	921c      	str	r2, [sp, #112]	; 0x70
    9558:	f8c9 7000 	str.w	r7, [r9]
    955c:	f8c9 5004 	str.w	r5, [r9, #4]
    9560:	ddef      	ble.n	9542 <_svfprintf_r+0x98a>
    9562:	aa1b      	add	r2, sp, #108	; 0x6c
    9564:	4641      	mov	r1, r8
    9566:	4630      	mov	r0, r6
    9568:	f000 fdde 	bl	a128 <__ssprint_r>
    956c:	2800      	cmp	r0, #0
    956e:	f47f ac19 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9572:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9574:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9576:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    957a:	e7e4      	b.n	9546 <_svfprintf_r+0x98e>
    957c:	9a07      	ldr	r2, [sp, #28]
    957e:	9904      	ldr	r1, [sp, #16]
    9580:	1a54      	subs	r4, r2, r1
    9582:	2c00      	cmp	r4, #0
    9584:	f77f ad7c 	ble.w	9080 <_svfprintf_r+0x4c8>
    9588:	2c10      	cmp	r4, #16
    958a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    958c:	4f07      	ldr	r7, [pc, #28]	; (95ac <_svfprintf_r+0x9f4>)
    958e:	dd2e      	ble.n	95ee <_svfprintf_r+0xa36>
    9590:	4649      	mov	r1, r9
    9592:	2510      	movs	r5, #16
    9594:	46c1      	mov	r9, r8
    9596:	4618      	mov	r0, r3
    9598:	46b0      	mov	r8, r6
    959a:	9e05      	ldr	r6, [sp, #20]
    959c:	e00d      	b.n	95ba <_svfprintf_r+0xa02>
    959e:	bf00      	nop
    95a0:	20000e60 	.word	0x20000e60
    95a4:	20000e74 	.word	0x20000e74
    95a8:	20000e4c 	.word	0x20000e4c
    95ac:	20001034 	.word	0x20001034
    95b0:	3c10      	subs	r4, #16
    95b2:	2c10      	cmp	r4, #16
    95b4:	f101 0108 	add.w	r1, r1, #8
    95b8:	dd15      	ble.n	95e6 <_svfprintf_r+0xa2e>
    95ba:	3201      	adds	r2, #1
    95bc:	3010      	adds	r0, #16
    95be:	2a07      	cmp	r2, #7
    95c0:	901d      	str	r0, [sp, #116]	; 0x74
    95c2:	921c      	str	r2, [sp, #112]	; 0x70
    95c4:	600f      	str	r7, [r1, #0]
    95c6:	604d      	str	r5, [r1, #4]
    95c8:	ddf2      	ble.n	95b0 <_svfprintf_r+0x9f8>
    95ca:	aa1b      	add	r2, sp, #108	; 0x6c
    95cc:	9903      	ldr	r1, [sp, #12]
    95ce:	4630      	mov	r0, r6
    95d0:	f000 fdaa 	bl	a128 <__ssprint_r>
    95d4:	2800      	cmp	r0, #0
    95d6:	f47f abe5 	bne.w	8da4 <_svfprintf_r+0x1ec>
    95da:	3c10      	subs	r4, #16
    95dc:	2c10      	cmp	r4, #16
    95de:	981d      	ldr	r0, [sp, #116]	; 0x74
    95e0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    95e2:	a928      	add	r1, sp, #160	; 0xa0
    95e4:	dce9      	bgt.n	95ba <_svfprintf_r+0xa02>
    95e6:	4646      	mov	r6, r8
    95e8:	4603      	mov	r3, r0
    95ea:	46c8      	mov	r8, r9
    95ec:	4689      	mov	r9, r1
    95ee:	3201      	adds	r2, #1
    95f0:	4423      	add	r3, r4
    95f2:	2a07      	cmp	r2, #7
    95f4:	931d      	str	r3, [sp, #116]	; 0x74
    95f6:	921c      	str	r2, [sp, #112]	; 0x70
    95f8:	f8c9 7000 	str.w	r7, [r9]
    95fc:	f8c9 4004 	str.w	r4, [r9, #4]
    9600:	f300 8246 	bgt.w	9a90 <_svfprintf_r+0xed8>
    9604:	f109 0908 	add.w	r9, r9, #8
    9608:	e53a      	b.n	9080 <_svfprintf_r+0x4c8>
    960a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    960c:	f8c9 6000 	str.w	r6, [r9]
    9610:	2a01      	cmp	r2, #1
    9612:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9614:	f103 0301 	add.w	r3, r3, #1
    9618:	f102 0201 	add.w	r2, r2, #1
    961c:	f04f 0101 	mov.w	r1, #1
    9620:	931d      	str	r3, [sp, #116]	; 0x74
    9622:	921c      	str	r2, [sp, #112]	; 0x70
    9624:	f8c9 1004 	str.w	r1, [r9, #4]
    9628:	f340 8210 	ble.w	9a4c <_svfprintf_r+0xe94>
    962c:	2a07      	cmp	r2, #7
    962e:	f300 8215 	bgt.w	9a5c <_svfprintf_r+0xea4>
    9632:	f109 0908 	add.w	r9, r9, #8
    9636:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9638:	9910      	ldr	r1, [sp, #64]	; 0x40
    963a:	f8c9 1000 	str.w	r1, [r9]
    963e:	3201      	adds	r2, #1
    9640:	4403      	add	r3, r0
    9642:	2a07      	cmp	r2, #7
    9644:	931d      	str	r3, [sp, #116]	; 0x74
    9646:	921c      	str	r2, [sp, #112]	; 0x70
    9648:	f8c9 0004 	str.w	r0, [r9, #4]
    964c:	f300 8213 	bgt.w	9a76 <_svfprintf_r+0xebe>
    9650:	f109 0908 	add.w	r9, r9, #8
    9654:	eeb5 8b40 	vcmp.f64	d8, #0.0
    9658:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    965c:	990d      	ldr	r1, [sp, #52]	; 0x34
    965e:	f000 80f5 	beq.w	984c <_svfprintf_r+0xc94>
    9662:	3901      	subs	r1, #1
    9664:	3201      	adds	r2, #1
    9666:	3601      	adds	r6, #1
    9668:	440b      	add	r3, r1
    966a:	2a07      	cmp	r2, #7
    966c:	f8c9 6000 	str.w	r6, [r9]
    9670:	921c      	str	r2, [sp, #112]	; 0x70
    9672:	931d      	str	r3, [sp, #116]	; 0x74
    9674:	f8c9 1004 	str.w	r1, [r9, #4]
    9678:	f300 811d 	bgt.w	98b6 <_svfprintf_r+0xcfe>
    967c:	f109 0908 	add.w	r9, r9, #8
    9680:	9811      	ldr	r0, [sp, #68]	; 0x44
    9682:	f8c9 0004 	str.w	r0, [r9, #4]
    9686:	3201      	adds	r2, #1
    9688:	4403      	add	r3, r0
    968a:	a917      	add	r1, sp, #92	; 0x5c
    968c:	2a07      	cmp	r2, #7
    968e:	931d      	str	r3, [sp, #116]	; 0x74
    9690:	921c      	str	r2, [sp, #112]	; 0x70
    9692:	f8c9 1000 	str.w	r1, [r9]
    9696:	f77f ad3e 	ble.w	9116 <_svfprintf_r+0x55e>
    969a:	aa1b      	add	r2, sp, #108	; 0x6c
    969c:	9903      	ldr	r1, [sp, #12]
    969e:	9805      	ldr	r0, [sp, #20]
    96a0:	f000 fd42 	bl	a128 <__ssprint_r>
    96a4:	2800      	cmp	r0, #0
    96a6:	f47f ab7d 	bne.w	8da4 <_svfprintf_r+0x1ec>
    96aa:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    96ac:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    96b0:	e533      	b.n	911a <_svfprintf_r+0x562>
    96b2:	aa1b      	add	r2, sp, #108	; 0x6c
    96b4:	9903      	ldr	r1, [sp, #12]
    96b6:	9805      	ldr	r0, [sp, #20]
    96b8:	f000 fd36 	bl	a128 <__ssprint_r>
    96bc:	2800      	cmp	r0, #0
    96be:	f43f ad79 	beq.w	91b4 <_svfprintf_r+0x5fc>
    96c2:	f7ff bb6f 	b.w	8da4 <_svfprintf_r+0x1ec>
    96c6:	9909      	ldr	r1, [sp, #36]	; 0x24
    96c8:	f1b8 0f00 	cmp.w	r8, #0
    96cc:	680c      	ldr	r4, [r1, #0]
    96ce:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    96d2:	f101 0704 	add.w	r7, r1, #4
    96d6:	f04f 0500 	mov.w	r5, #0
    96da:	f2c0 8371 	blt.w	9dc0 <_svfprintf_r+0x1208>
    96de:	ea54 0205 	orrs.w	r2, r4, r5
    96e2:	9709      	str	r7, [sp, #36]	; 0x24
    96e4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    96e8:	461f      	mov	r7, r3
    96ea:	f47f ac0a 	bne.w	8f02 <_svfprintf_r+0x34a>
    96ee:	f1b8 0f00 	cmp.w	r8, #0
    96f2:	f43f aeb3 	beq.w	945c <_svfprintf_r+0x8a4>
    96f6:	2400      	movs	r4, #0
    96f8:	e5b6      	b.n	9268 <_svfprintf_r+0x6b0>
    96fa:	aa1b      	add	r2, sp, #108	; 0x6c
    96fc:	9903      	ldr	r1, [sp, #12]
    96fe:	9805      	ldr	r0, [sp, #20]
    9700:	f000 fd12 	bl	a128 <__ssprint_r>
    9704:	2800      	cmp	r0, #0
    9706:	f47f ab4d 	bne.w	8da4 <_svfprintf_r+0x1ec>
    970a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    970c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9710:	e4f0      	b.n	90f4 <_svfprintf_r+0x53c>
    9712:	aa1b      	add	r2, sp, #108	; 0x6c
    9714:	9903      	ldr	r1, [sp, #12]
    9716:	9805      	ldr	r0, [sp, #20]
    9718:	f000 fd06 	bl	a128 <__ssprint_r>
    971c:	2800      	cmp	r0, #0
    971e:	f47f ab41 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9722:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9724:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9728:	e496      	b.n	9058 <_svfprintf_r+0x4a0>
    972a:	aa1b      	add	r2, sp, #108	; 0x6c
    972c:	9903      	ldr	r1, [sp, #12]
    972e:	9805      	ldr	r0, [sp, #20]
    9730:	f000 fcfa 	bl	a128 <__ssprint_r>
    9734:	2800      	cmp	r0, #0
    9736:	f47f ab35 	bne.w	8da4 <_svfprintf_r+0x1ec>
    973a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    973c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9740:	e49a      	b.n	9078 <_svfprintf_r+0x4c0>
    9742:	f1b8 0f00 	cmp.w	r8, #0
    9746:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    974a:	f2c0 826f 	blt.w	9c2c <_svfprintf_r+0x1074>
    974e:	ea54 0305 	orrs.w	r3, r4, r5
    9752:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9756:	f47f adc4 	bne.w	92e2 <_svfprintf_r+0x72a>
    975a:	f1b8 0f00 	cmp.w	r8, #0
    975e:	f43f ae7c 	beq.w	945a <_svfprintf_r+0x8a2>
    9762:	2700      	movs	r7, #0
    9764:	e6a7      	b.n	94b6 <_svfprintf_r+0x8fe>
    9766:	9c15      	ldr	r4, [sp, #84]	; 0x54
    9768:	2c00      	cmp	r4, #0
    976a:	f340 8261 	ble.w	9c30 <_svfprintf_r+0x1078>
    976e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    9770:	990d      	ldr	r1, [sp, #52]	; 0x34
    9772:	428a      	cmp	r2, r1
    9774:	bfa8      	it	ge
    9776:	460a      	movge	r2, r1
    9778:	2a00      	cmp	r2, #0
    977a:	4614      	mov	r4, r2
    977c:	dd0d      	ble.n	979a <_svfprintf_r+0xbe2>
    977e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9780:	f8c9 6000 	str.w	r6, [r9]
    9784:	3201      	adds	r2, #1
    9786:	4423      	add	r3, r4
    9788:	2a07      	cmp	r2, #7
    978a:	931d      	str	r3, [sp, #116]	; 0x74
    978c:	f8c9 4004 	str.w	r4, [r9, #4]
    9790:	921c      	str	r2, [sp, #112]	; 0x70
    9792:	f300 8372 	bgt.w	9e7a <_svfprintf_r+0x12c2>
    9796:	f109 0908 	add.w	r9, r9, #8
    979a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    979c:	2c00      	cmp	r4, #0
    979e:	bfa8      	it	ge
    97a0:	1b12      	subge	r2, r2, r4
    97a2:	2a00      	cmp	r2, #0
    97a4:	4614      	mov	r4, r2
    97a6:	f340 80f1 	ble.w	998c <_svfprintf_r+0xdd4>
    97aa:	2c10      	cmp	r4, #16
    97ac:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    97ae:	4fc1      	ldr	r7, [pc, #772]	; (9ab4 <_svfprintf_r+0xefc>)
    97b0:	f340 8219 	ble.w	9be6 <_svfprintf_r+0x102e>
    97b4:	4649      	mov	r1, r9
    97b6:	2510      	movs	r5, #16
    97b8:	46b1      	mov	r9, r6
    97ba:	f8dd 8014 	ldr.w	r8, [sp, #20]
    97be:	9e03      	ldr	r6, [sp, #12]
    97c0:	e004      	b.n	97cc <_svfprintf_r+0xc14>
    97c2:	3108      	adds	r1, #8
    97c4:	3c10      	subs	r4, #16
    97c6:	2c10      	cmp	r4, #16
    97c8:	f340 820b 	ble.w	9be2 <_svfprintf_r+0x102a>
    97cc:	3201      	adds	r2, #1
    97ce:	3310      	adds	r3, #16
    97d0:	2a07      	cmp	r2, #7
    97d2:	931d      	str	r3, [sp, #116]	; 0x74
    97d4:	921c      	str	r2, [sp, #112]	; 0x70
    97d6:	600f      	str	r7, [r1, #0]
    97d8:	604d      	str	r5, [r1, #4]
    97da:	ddf2      	ble.n	97c2 <_svfprintf_r+0xc0a>
    97dc:	aa1b      	add	r2, sp, #108	; 0x6c
    97de:	4631      	mov	r1, r6
    97e0:	4640      	mov	r0, r8
    97e2:	f000 fca1 	bl	a128 <__ssprint_r>
    97e6:	2800      	cmp	r0, #0
    97e8:	f47f aadc 	bne.w	8da4 <_svfprintf_r+0x1ec>
    97ec:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    97ee:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    97f0:	a928      	add	r1, sp, #160	; 0xa0
    97f2:	e7e7      	b.n	97c4 <_svfprintf_r+0xc0c>
    97f4:	aa1b      	add	r2, sp, #108	; 0x6c
    97f6:	9903      	ldr	r1, [sp, #12]
    97f8:	9805      	ldr	r0, [sp, #20]
    97fa:	f000 fc95 	bl	a128 <__ssprint_r>
    97fe:	2800      	cmp	r0, #0
    9800:	f47f aad0 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9804:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9808:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    980a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    980e:	e413      	b.n	9038 <_svfprintf_r+0x480>
    9810:	f01b 0210 	ands.w	r2, fp, #16
    9814:	f47f af57 	bne.w	96c6 <_svfprintf_r+0xb0e>
    9818:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    981c:	f43f af53 	beq.w	96c6 <_svfprintf_r+0xb0e>
    9820:	9909      	ldr	r1, [sp, #36]	; 0x24
    9822:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    9826:	460b      	mov	r3, r1
    9828:	f1b8 0f00 	cmp.w	r8, #0
    982c:	f103 0304 	add.w	r3, r3, #4
    9830:	880c      	ldrh	r4, [r1, #0]
    9832:	f04f 0500 	mov.w	r5, #0
    9836:	f2c0 8294 	blt.w	9d62 <_svfprintf_r+0x11aa>
    983a:	ea54 0105 	orrs.w	r1, r4, r5
    983e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9842:	9309      	str	r3, [sp, #36]	; 0x24
    9844:	4617      	mov	r7, r2
    9846:	f47f ab5c 	bne.w	8f02 <_svfprintf_r+0x34a>
    984a:	e750      	b.n	96ee <_svfprintf_r+0xb36>
    984c:	1e4c      	subs	r4, r1, #1
    984e:	2c00      	cmp	r4, #0
    9850:	f77f af16 	ble.w	9680 <_svfprintf_r+0xac8>
    9854:	2c10      	cmp	r4, #16
    9856:	4f97      	ldr	r7, [pc, #604]	; (9ab4 <_svfprintf_r+0xefc>)
    9858:	dd22      	ble.n	98a0 <_svfprintf_r+0xce8>
    985a:	2510      	movs	r5, #16
    985c:	9e05      	ldr	r6, [sp, #20]
    985e:	f8dd 800c 	ldr.w	r8, [sp, #12]
    9862:	e004      	b.n	986e <_svfprintf_r+0xcb6>
    9864:	3c10      	subs	r4, #16
    9866:	2c10      	cmp	r4, #16
    9868:	f109 0908 	add.w	r9, r9, #8
    986c:	dd18      	ble.n	98a0 <_svfprintf_r+0xce8>
    986e:	3201      	adds	r2, #1
    9870:	3310      	adds	r3, #16
    9872:	2a07      	cmp	r2, #7
    9874:	931d      	str	r3, [sp, #116]	; 0x74
    9876:	921c      	str	r2, [sp, #112]	; 0x70
    9878:	f8c9 7000 	str.w	r7, [r9]
    987c:	f8c9 5004 	str.w	r5, [r9, #4]
    9880:	ddf0      	ble.n	9864 <_svfprintf_r+0xcac>
    9882:	aa1b      	add	r2, sp, #108	; 0x6c
    9884:	4641      	mov	r1, r8
    9886:	4630      	mov	r0, r6
    9888:	f000 fc4e 	bl	a128 <__ssprint_r>
    988c:	2800      	cmp	r0, #0
    988e:	f47f aa89 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9892:	3c10      	subs	r4, #16
    9894:	2c10      	cmp	r4, #16
    9896:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9898:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    989a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    989e:	dce6      	bgt.n	986e <_svfprintf_r+0xcb6>
    98a0:	3201      	adds	r2, #1
    98a2:	4423      	add	r3, r4
    98a4:	2a07      	cmp	r2, #7
    98a6:	931d      	str	r3, [sp, #116]	; 0x74
    98a8:	921c      	str	r2, [sp, #112]	; 0x70
    98aa:	f8c9 7000 	str.w	r7, [r9]
    98ae:	f8c9 4004 	str.w	r4, [r9, #4]
    98b2:	f77f aee3 	ble.w	967c <_svfprintf_r+0xac4>
    98b6:	aa1b      	add	r2, sp, #108	; 0x6c
    98b8:	9903      	ldr	r1, [sp, #12]
    98ba:	9805      	ldr	r0, [sp, #20]
    98bc:	f000 fc34 	bl	a128 <__ssprint_r>
    98c0:	2800      	cmp	r0, #0
    98c2:	f47f aa6f 	bne.w	8da4 <_svfprintf_r+0x1ec>
    98c6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    98c8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    98ca:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    98ce:	e6d7      	b.n	9680 <_svfprintf_r+0xac8>
    98d0:	f01b 0f10 	tst.w	fp, #16
    98d4:	d133      	bne.n	993e <_svfprintf_r+0xd86>
    98d6:	f01b 0f40 	tst.w	fp, #64	; 0x40
    98da:	d030      	beq.n	993e <_svfprintf_r+0xd86>
    98dc:	9909      	ldr	r1, [sp, #36]	; 0x24
    98de:	f9b1 4000 	ldrsh.w	r4, [r1]
    98e2:	3104      	adds	r1, #4
    98e4:	17e5      	asrs	r5, r4, #31
    98e6:	4622      	mov	r2, r4
    98e8:	462b      	mov	r3, r5
    98ea:	9109      	str	r1, [sp, #36]	; 0x24
    98ec:	f7ff baf8 	b.w	8ee0 <_svfprintf_r+0x328>
    98f0:	3201      	adds	r2, #1
    98f2:	4423      	add	r3, r4
    98f4:	2a07      	cmp	r2, #7
    98f6:	931d      	str	r3, [sp, #116]	; 0x74
    98f8:	921c      	str	r2, [sp, #112]	; 0x70
    98fa:	f8c9 7000 	str.w	r7, [r9]
    98fe:	f8c9 4004 	str.w	r4, [r9, #4]
    9902:	f77f ac08 	ble.w	9116 <_svfprintf_r+0x55e>
    9906:	e6c8      	b.n	969a <_svfprintf_r+0xae2>
    9908:	9909      	ldr	r1, [sp, #36]	; 0x24
    990a:	f1b8 0f00 	cmp.w	r8, #0
    990e:	680c      	ldr	r4, [r1, #0]
    9910:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    9914:	f101 0704 	add.w	r7, r1, #4
    9918:	f04f 0500 	mov.w	r5, #0
    991c:	f2c0 80c5 	blt.w	9aaa <_svfprintf_r+0xef2>
    9920:	ea54 0205 	orrs.w	r2, r4, r5
    9924:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9928:	9709      	str	r7, [sp, #36]	; 0x24
    992a:	f43f adb2 	beq.w	9492 <_svfprintf_r+0x8da>
    992e:	461f      	mov	r7, r3
    9930:	f7ff ba64 	b.w	8dfc <_svfprintf_r+0x244>
    9934:	681c      	ldr	r4, [r3, #0]
    9936:	3304      	adds	r3, #4
    9938:	9309      	str	r3, [sp, #36]	; 0x24
    993a:	2500      	movs	r5, #0
    993c:	e4b6      	b.n	92ac <_svfprintf_r+0x6f4>
    993e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9940:	6814      	ldr	r4, [r2, #0]
    9942:	4613      	mov	r3, r2
    9944:	3304      	adds	r3, #4
    9946:	17e5      	asrs	r5, r4, #31
    9948:	4622      	mov	r2, r4
    994a:	9309      	str	r3, [sp, #36]	; 0x24
    994c:	2a00      	cmp	r2, #0
    994e:	462b      	mov	r3, r5
    9950:	f173 0300 	sbcs.w	r3, r3, #0
    9954:	f6bf aac9 	bge.w	8eea <_svfprintf_r+0x332>
    9958:	4264      	negs	r4, r4
    995a:	f04f 072d 	mov.w	r7, #45	; 0x2d
    995e:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
    9962:	f1b8 0f00 	cmp.w	r8, #0
    9966:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    996a:	f6ff aaca 	blt.w	8f02 <_svfprintf_r+0x34a>
    996e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9972:	f7ff bac6 	b.w	8f02 <_svfprintf_r+0x34a>
    9976:	aa1b      	add	r2, sp, #108	; 0x6c
    9978:	9903      	ldr	r1, [sp, #12]
    997a:	9805      	ldr	r0, [sp, #20]
    997c:	f000 fbd4 	bl	a128 <__ssprint_r>
    9980:	2800      	cmp	r0, #0
    9982:	f47f aa0f 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9986:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9988:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    998c:	990e      	ldr	r1, [sp, #56]	; 0x38
    998e:	9a15      	ldr	r2, [sp, #84]	; 0x54
    9990:	4431      	add	r1, r6
    9992:	460d      	mov	r5, r1
    9994:	990d      	ldr	r1, [sp, #52]	; 0x34
    9996:	428a      	cmp	r2, r1
    9998:	db47      	blt.n	9a2a <_svfprintf_r+0xe72>
    999a:	f01b 0f01 	tst.w	fp, #1
    999e:	d144      	bne.n	9a2a <_svfprintf_r+0xe72>
    99a0:	980d      	ldr	r0, [sp, #52]	; 0x34
    99a2:	4406      	add	r6, r0
    99a4:	1b74      	subs	r4, r6, r5
    99a6:	1a82      	subs	r2, r0, r2
    99a8:	4294      	cmp	r4, r2
    99aa:	bfa8      	it	ge
    99ac:	4614      	movge	r4, r2
    99ae:	2c00      	cmp	r4, #0
    99b0:	4626      	mov	r6, r4
    99b2:	dd0d      	ble.n	99d0 <_svfprintf_r+0xe18>
    99b4:	991c      	ldr	r1, [sp, #112]	; 0x70
    99b6:	f8c9 5000 	str.w	r5, [r9]
    99ba:	3101      	adds	r1, #1
    99bc:	4423      	add	r3, r4
    99be:	2907      	cmp	r1, #7
    99c0:	931d      	str	r3, [sp, #116]	; 0x74
    99c2:	f8c9 4004 	str.w	r4, [r9, #4]
    99c6:	911c      	str	r1, [sp, #112]	; 0x70
    99c8:	f300 8280 	bgt.w	9ecc <_svfprintf_r+0x1314>
    99cc:	f109 0908 	add.w	r9, r9, #8
    99d0:	2e00      	cmp	r6, #0
    99d2:	bfac      	ite	ge
    99d4:	1b94      	subge	r4, r2, r6
    99d6:	4614      	movlt	r4, r2
    99d8:	2c00      	cmp	r4, #0
    99da:	f77f ab9e 	ble.w	911a <_svfprintf_r+0x562>
    99de:	2c10      	cmp	r4, #16
    99e0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    99e2:	4f34      	ldr	r7, [pc, #208]	; (9ab4 <_svfprintf_r+0xefc>)
    99e4:	dd84      	ble.n	98f0 <_svfprintf_r+0xd38>
    99e6:	2510      	movs	r5, #16
    99e8:	9e05      	ldr	r6, [sp, #20]
    99ea:	f8dd 800c 	ldr.w	r8, [sp, #12]
    99ee:	e005      	b.n	99fc <_svfprintf_r+0xe44>
    99f0:	f109 0908 	add.w	r9, r9, #8
    99f4:	3c10      	subs	r4, #16
    99f6:	2c10      	cmp	r4, #16
    99f8:	f77f af7a 	ble.w	98f0 <_svfprintf_r+0xd38>
    99fc:	3201      	adds	r2, #1
    99fe:	3310      	adds	r3, #16
    9a00:	2a07      	cmp	r2, #7
    9a02:	931d      	str	r3, [sp, #116]	; 0x74
    9a04:	921c      	str	r2, [sp, #112]	; 0x70
    9a06:	f8c9 7000 	str.w	r7, [r9]
    9a0a:	f8c9 5004 	str.w	r5, [r9, #4]
    9a0e:	ddef      	ble.n	99f0 <_svfprintf_r+0xe38>
    9a10:	aa1b      	add	r2, sp, #108	; 0x6c
    9a12:	4641      	mov	r1, r8
    9a14:	4630      	mov	r0, r6
    9a16:	f000 fb87 	bl	a128 <__ssprint_r>
    9a1a:	2800      	cmp	r0, #0
    9a1c:	f47f a9c2 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9a20:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9a22:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9a24:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9a28:	e7e4      	b.n	99f4 <_svfprintf_r+0xe3c>
    9a2a:	991c      	ldr	r1, [sp, #112]	; 0x70
    9a2c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    9a2e:	9810      	ldr	r0, [sp, #64]	; 0x40
    9a30:	f8c9 0000 	str.w	r0, [r9]
    9a34:	3101      	adds	r1, #1
    9a36:	4423      	add	r3, r4
    9a38:	2907      	cmp	r1, #7
    9a3a:	931d      	str	r3, [sp, #116]	; 0x74
    9a3c:	f8c9 4004 	str.w	r4, [r9, #4]
    9a40:	911c      	str	r1, [sp, #112]	; 0x70
    9a42:	f300 8226 	bgt.w	9e92 <_svfprintf_r+0x12da>
    9a46:	f109 0908 	add.w	r9, r9, #8
    9a4a:	e7a9      	b.n	99a0 <_svfprintf_r+0xde8>
    9a4c:	f01b 0f01 	tst.w	fp, #1
    9a50:	f47f adec 	bne.w	962c <_svfprintf_r+0xa74>
    9a54:	2a07      	cmp	r2, #7
    9a56:	f77f ae11 	ble.w	967c <_svfprintf_r+0xac4>
    9a5a:	e72c      	b.n	98b6 <_svfprintf_r+0xcfe>
    9a5c:	aa1b      	add	r2, sp, #108	; 0x6c
    9a5e:	9903      	ldr	r1, [sp, #12]
    9a60:	9805      	ldr	r0, [sp, #20]
    9a62:	f000 fb61 	bl	a128 <__ssprint_r>
    9a66:	2800      	cmp	r0, #0
    9a68:	f47f a99c 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9a6c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9a6e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9a70:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9a74:	e5df      	b.n	9636 <_svfprintf_r+0xa7e>
    9a76:	aa1b      	add	r2, sp, #108	; 0x6c
    9a78:	9903      	ldr	r1, [sp, #12]
    9a7a:	9805      	ldr	r0, [sp, #20]
    9a7c:	f000 fb54 	bl	a128 <__ssprint_r>
    9a80:	2800      	cmp	r0, #0
    9a82:	f47f a98f 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9a86:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9a88:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9a8a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9a8e:	e5e1      	b.n	9654 <_svfprintf_r+0xa9c>
    9a90:	aa1b      	add	r2, sp, #108	; 0x6c
    9a92:	9903      	ldr	r1, [sp, #12]
    9a94:	9805      	ldr	r0, [sp, #20]
    9a96:	f000 fb47 	bl	a128 <__ssprint_r>
    9a9a:	2800      	cmp	r0, #0
    9a9c:	f47f a982 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9aa0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9aa2:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9aa6:	f7ff baeb 	b.w	9080 <_svfprintf_r+0x4c8>
    9aaa:	9709      	str	r7, [sp, #36]	; 0x24
    9aac:	2700      	movs	r7, #0
    9aae:	f7ff b9a5 	b.w	8dfc <_svfprintf_r+0x244>
    9ab2:	bf00      	nop
    9ab4:	20001034 	.word	0x20001034
    9ab8:	f01b 0f10 	tst.w	fp, #16
    9abc:	d10b      	bne.n	9ad6 <_svfprintf_r+0xf1e>
    9abe:	f01b 0f40 	tst.w	fp, #64	; 0x40
    9ac2:	d008      	beq.n	9ad6 <_svfprintf_r+0xf1e>
    9ac4:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9ac6:	6813      	ldr	r3, [r2, #0]
    9ac8:	3204      	adds	r2, #4
    9aca:	9209      	str	r2, [sp, #36]	; 0x24
    9acc:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    9ad0:	801a      	strh	r2, [r3, #0]
    9ad2:	f7ff b897 	b.w	8c04 <_svfprintf_r+0x4c>
    9ad6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9ad8:	6813      	ldr	r3, [r2, #0]
    9ada:	3204      	adds	r2, #4
    9adc:	9209      	str	r2, [sp, #36]	; 0x24
    9ade:	9a06      	ldr	r2, [sp, #24]
    9ae0:	601a      	str	r2, [r3, #0]
    9ae2:	f7ff b88f 	b.w	8c04 <_svfprintf_r+0x4c>
    9ae6:	eeb4 8b48 	vcmp.f64	d8, d8
    9aea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9aee:	f180 829e 	bvs.w	a02e <_svfprintf_r+0x1476>
    9af2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9af4:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    9af8:	f023 0520 	bic.w	r5, r3, #32
    9afc:	f000 8225 	beq.w	9f4a <_svfprintf_r+0x1392>
    9b00:	2d47      	cmp	r5, #71	; 0x47
    9b02:	f000 8126 	beq.w	9d52 <_svfprintf_r+0x119a>
    9b06:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
    9b0a:	930a      	str	r3, [sp, #40]	; 0x28
    9b0c:	ee18 3a90 	vmov	r3, s17
    9b10:	2b00      	cmp	r3, #0
    9b12:	f2c0 821d 	blt.w	9f50 <_svfprintf_r+0x1398>
    9b16:	eeb0 ab48 	vmov.f64	d10, d8
    9b1a:	2700      	movs	r7, #0
    9b1c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9b1e:	2b66      	cmp	r3, #102	; 0x66
    9b20:	f000 8202 	beq.w	9f28 <_svfprintf_r+0x1370>
    9b24:	2b46      	cmp	r3, #70	; 0x46
    9b26:	f000 80ec 	beq.w	9d02 <_svfprintf_r+0x114a>
    9b2a:	eeb0 0b4a 	vmov.f64	d0, d10
    9b2e:	2d45      	cmp	r5, #69	; 0x45
    9b30:	bf0c      	ite	eq
    9b32:	f108 0401 	addeq.w	r4, r8, #1
    9b36:	4644      	movne	r4, r8
    9b38:	aa19      	add	r2, sp, #100	; 0x64
    9b3a:	ab16      	add	r3, sp, #88	; 0x58
    9b3c:	9201      	str	r2, [sp, #4]
    9b3e:	9300      	str	r3, [sp, #0]
    9b40:	4622      	mov	r2, r4
    9b42:	ab15      	add	r3, sp, #84	; 0x54
    9b44:	2102      	movs	r1, #2
    9b46:	9805      	ldr	r0, [sp, #20]
    9b48:	f7fe f9f2 	bl	7f30 <_dtoa_r>
    9b4c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9b4e:	2b67      	cmp	r3, #103	; 0x67
    9b50:	4606      	mov	r6, r0
    9b52:	f040 820e 	bne.w	9f72 <_svfprintf_r+0x13ba>
    9b56:	f01b 0f01 	tst.w	fp, #1
    9b5a:	f000 8266 	beq.w	a02a <_svfprintf_r+0x1472>
    9b5e:	1931      	adds	r1, r6, r4
    9b60:	eeb5 ab40 	vcmp.f64	d10, #0.0
    9b64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    9b68:	f000 8185 	beq.w	9e76 <_svfprintf_r+0x12be>
    9b6c:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9b6e:	4299      	cmp	r1, r3
    9b70:	d906      	bls.n	9b80 <_svfprintf_r+0xfc8>
    9b72:	2030      	movs	r0, #48	; 0x30
    9b74:	1c5a      	adds	r2, r3, #1
    9b76:	9219      	str	r2, [sp, #100]	; 0x64
    9b78:	7018      	strb	r0, [r3, #0]
    9b7a:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9b7c:	4299      	cmp	r1, r3
    9b7e:	d8f9      	bhi.n	9b74 <_svfprintf_r+0xfbc>
    9b80:	1b9b      	subs	r3, r3, r6
    9b82:	2d47      	cmp	r5, #71	; 0x47
    9b84:	930d      	str	r3, [sp, #52]	; 0x34
    9b86:	f000 811f 	beq.w	9dc8 <_svfprintf_r+0x1210>
    9b8a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9b8c:	2b65      	cmp	r3, #101	; 0x65
    9b8e:	f340 81ff 	ble.w	9f90 <_svfprintf_r+0x13d8>
    9b92:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9b94:	2b66      	cmp	r3, #102	; 0x66
    9b96:	9b15      	ldr	r3, [sp, #84]	; 0x54
    9b98:	f000 81fc 	beq.w	9f94 <_svfprintf_r+0x13dc>
    9b9c:	930e      	str	r3, [sp, #56]	; 0x38
    9b9e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    9ba0:	990d      	ldr	r1, [sp, #52]	; 0x34
    9ba2:	428a      	cmp	r2, r1
    9ba4:	f2c0 81d8 	blt.w	9f58 <_svfprintf_r+0x13a0>
    9ba8:	f01b 0f01 	tst.w	fp, #1
    9bac:	f040 8234 	bne.w	a018 <_svfprintf_r+0x1460>
    9bb0:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    9bb4:	9208      	str	r2, [sp, #32]
    9bb6:	2267      	movs	r2, #103	; 0x67
    9bb8:	920c      	str	r2, [sp, #48]	; 0x30
    9bba:	2f00      	cmp	r7, #0
    9bbc:	f040 80f6 	bne.w	9dac <_svfprintf_r+0x11f4>
    9bc0:	46b8      	mov	r8, r7
    9bc2:	9304      	str	r3, [sp, #16]
    9bc4:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    9bc8:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9bcc:	f7ff b9e6 	b.w	8f9c <_svfprintf_r+0x3e4>
    9bd0:	f027 0707 	bic.w	r7, r7, #7
    9bd4:	f107 0308 	add.w	r3, r7, #8
    9bd8:	ed97 8b00 	vldr	d8, [r7]
    9bdc:	9309      	str	r3, [sp, #36]	; 0x24
    9bde:	f7ff b9be 	b.w	8f5e <_svfprintf_r+0x3a6>
    9be2:	464e      	mov	r6, r9
    9be4:	4689      	mov	r9, r1
    9be6:	3201      	adds	r2, #1
    9be8:	4423      	add	r3, r4
    9bea:	2a07      	cmp	r2, #7
    9bec:	931d      	str	r3, [sp, #116]	; 0x74
    9bee:	921c      	str	r2, [sp, #112]	; 0x70
    9bf0:	f8c9 7000 	str.w	r7, [r9]
    9bf4:	f8c9 4004 	str.w	r4, [r9, #4]
    9bf8:	f73f aebd 	bgt.w	9976 <_svfprintf_r+0xdbe>
    9bfc:	f109 0908 	add.w	r9, r9, #8
    9c00:	e6c4      	b.n	998c <_svfprintf_r+0xdd4>
    9c02:	2700      	movs	r7, #0
    9c04:	45b8      	cmp	r8, r7
    9c06:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9c0a:	f6ff ac54 	blt.w	94b6 <_svfprintf_r+0x8fe>
    9c0e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    9c12:	e41e      	b.n	9452 <_svfprintf_r+0x89a>
    9c14:	aa1b      	add	r2, sp, #108	; 0x6c
    9c16:	9903      	ldr	r1, [sp, #12]
    9c18:	9805      	ldr	r0, [sp, #20]
    9c1a:	f000 fa85 	bl	a128 <__ssprint_r>
    9c1e:	2800      	cmp	r0, #0
    9c20:	f47f a8c0 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9c24:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9c26:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9c2a:	e463      	b.n	94f4 <_svfprintf_r+0x93c>
    9c2c:	9f09      	ldr	r7, [sp, #36]	; 0x24
    9c2e:	e43b      	b.n	94a8 <_svfprintf_r+0x8f0>
    9c30:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9c32:	49b9      	ldr	r1, [pc, #740]	; (9f18 <_svfprintf_r+0x1360>)
    9c34:	f8c9 1000 	str.w	r1, [r9]
    9c38:	3201      	adds	r2, #1
    9c3a:	3301      	adds	r3, #1
    9c3c:	2101      	movs	r1, #1
    9c3e:	2a07      	cmp	r2, #7
    9c40:	931d      	str	r3, [sp, #116]	; 0x74
    9c42:	921c      	str	r2, [sp, #112]	; 0x70
    9c44:	f8c9 1004 	str.w	r1, [r9, #4]
    9c48:	dc76      	bgt.n	9d38 <_svfprintf_r+0x1180>
    9c4a:	f109 0908 	add.w	r9, r9, #8
    9c4e:	b92c      	cbnz	r4, 9c5c <_svfprintf_r+0x10a4>
    9c50:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9c52:	b91a      	cbnz	r2, 9c5c <_svfprintf_r+0x10a4>
    9c54:	f01b 0f01 	tst.w	fp, #1
    9c58:	f43f aa5f 	beq.w	911a <_svfprintf_r+0x562>
    9c5c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9c5e:	980f      	ldr	r0, [sp, #60]	; 0x3c
    9c60:	9910      	ldr	r1, [sp, #64]	; 0x40
    9c62:	f8c9 1000 	str.w	r1, [r9]
    9c66:	3201      	adds	r2, #1
    9c68:	4403      	add	r3, r0
    9c6a:	2a07      	cmp	r2, #7
    9c6c:	931d      	str	r3, [sp, #116]	; 0x74
    9c6e:	f8c9 0004 	str.w	r0, [r9, #4]
    9c72:	921c      	str	r2, [sp, #112]	; 0x70
    9c74:	f300 81b6 	bgt.w	9fe4 <_svfprintf_r+0x142c>
    9c78:	f109 0908 	add.w	r9, r9, #8
    9c7c:	4264      	negs	r4, r4
    9c7e:	2c00      	cmp	r4, #0
    9c80:	f340 8087 	ble.w	9d92 <_svfprintf_r+0x11da>
    9c84:	2c10      	cmp	r4, #16
    9c86:	4fa5      	ldr	r7, [pc, #660]	; (9f1c <_svfprintf_r+0x1364>)
    9c88:	f340 8112 	ble.w	9eb0 <_svfprintf_r+0x12f8>
    9c8c:	4649      	mov	r1, r9
    9c8e:	2510      	movs	r5, #16
    9c90:	46b1      	mov	r9, r6
    9c92:	f8dd 8014 	ldr.w	r8, [sp, #20]
    9c96:	9e03      	ldr	r6, [sp, #12]
    9c98:	e004      	b.n	9ca4 <_svfprintf_r+0x10ec>
    9c9a:	3108      	adds	r1, #8
    9c9c:	3c10      	subs	r4, #16
    9c9e:	2c10      	cmp	r4, #16
    9ca0:	f340 8104 	ble.w	9eac <_svfprintf_r+0x12f4>
    9ca4:	3201      	adds	r2, #1
    9ca6:	3310      	adds	r3, #16
    9ca8:	2a07      	cmp	r2, #7
    9caa:	931d      	str	r3, [sp, #116]	; 0x74
    9cac:	921c      	str	r2, [sp, #112]	; 0x70
    9cae:	600f      	str	r7, [r1, #0]
    9cb0:	604d      	str	r5, [r1, #4]
    9cb2:	ddf2      	ble.n	9c9a <_svfprintf_r+0x10e2>
    9cb4:	aa1b      	add	r2, sp, #108	; 0x6c
    9cb6:	4631      	mov	r1, r6
    9cb8:	4640      	mov	r0, r8
    9cba:	f000 fa35 	bl	a128 <__ssprint_r>
    9cbe:	2800      	cmp	r0, #0
    9cc0:	f47f a870 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9cc4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9cc6:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9cc8:	a928      	add	r1, sp, #160	; 0xa0
    9cca:	e7e7      	b.n	9c9c <_svfprintf_r+0x10e4>
    9ccc:	aa1b      	add	r2, sp, #108	; 0x6c
    9cce:	9903      	ldr	r1, [sp, #12]
    9cd0:	9805      	ldr	r0, [sp, #20]
    9cd2:	f000 fa29 	bl	a128 <__ssprint_r>
    9cd6:	2800      	cmp	r0, #0
    9cd8:	f47f a864 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9cdc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9cde:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9ce2:	e41f      	b.n	9524 <_svfprintf_r+0x96c>
    9ce4:	2140      	movs	r1, #64	; 0x40
    9ce6:	9805      	ldr	r0, [sp, #20]
    9ce8:	f7fc f9c8 	bl	607c <_malloc_r>
    9cec:	9a03      	ldr	r2, [sp, #12]
    9cee:	6010      	str	r0, [r2, #0]
    9cf0:	6110      	str	r0, [r2, #16]
    9cf2:	2800      	cmp	r0, #0
    9cf4:	f000 81ed 	beq.w	a0d2 <_svfprintf_r+0x151a>
    9cf8:	9a03      	ldr	r2, [sp, #12]
    9cfa:	2340      	movs	r3, #64	; 0x40
    9cfc:	6153      	str	r3, [r2, #20]
    9cfe:	f7fe bf74 	b.w	8bea <_svfprintf_r+0x32>
    9d02:	aa19      	add	r2, sp, #100	; 0x64
    9d04:	ab16      	add	r3, sp, #88	; 0x58
    9d06:	9201      	str	r2, [sp, #4]
    9d08:	9300      	str	r3, [sp, #0]
    9d0a:	4642      	mov	r2, r8
    9d0c:	ab15      	add	r3, sp, #84	; 0x54
    9d0e:	2103      	movs	r1, #3
    9d10:	eeb0 0b4a 	vmov.f64	d0, d10
    9d14:	9805      	ldr	r0, [sp, #20]
    9d16:	f7fe f90b 	bl	7f30 <_dtoa_r>
    9d1a:	4644      	mov	r4, r8
    9d1c:	4606      	mov	r6, r0
    9d1e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9d20:	2b46      	cmp	r3, #70	; 0x46
    9d22:	eb06 0104 	add.w	r1, r6, r4
    9d26:	f47f af1b 	bne.w	9b60 <_svfprintf_r+0xfa8>
    9d2a:	7833      	ldrb	r3, [r6, #0]
    9d2c:	2b30      	cmp	r3, #48	; 0x30
    9d2e:	f000 818d 	beq.w	a04c <_svfprintf_r+0x1494>
    9d32:	9c15      	ldr	r4, [sp, #84]	; 0x54
    9d34:	4421      	add	r1, r4
    9d36:	e713      	b.n	9b60 <_svfprintf_r+0xfa8>
    9d38:	aa1b      	add	r2, sp, #108	; 0x6c
    9d3a:	9903      	ldr	r1, [sp, #12]
    9d3c:	9805      	ldr	r0, [sp, #20]
    9d3e:	f000 f9f3 	bl	a128 <__ssprint_r>
    9d42:	2800      	cmp	r0, #0
    9d44:	f47f a82e 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9d48:	9c15      	ldr	r4, [sp, #84]	; 0x54
    9d4a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9d4c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9d50:	e77d      	b.n	9c4e <_svfprintf_r+0x1096>
    9d52:	f1b8 0f00 	cmp.w	r8, #0
    9d56:	bf08      	it	eq
    9d58:	f04f 0801 	moveq.w	r8, #1
    9d5c:	e6d3      	b.n	9b06 <_svfprintf_r+0xf4e>
    9d5e:	9309      	str	r3, [sp, #36]	; 0x24
    9d60:	e6a4      	b.n	9aac <_svfprintf_r+0xef4>
    9d62:	9309      	str	r3, [sp, #36]	; 0x24
    9d64:	4617      	mov	r7, r2
    9d66:	f7ff ba7b 	b.w	9260 <_svfprintf_r+0x6a8>
    9d6a:	4630      	mov	r0, r6
    9d6c:	f7fd f988 	bl	7080 <strlen>
    9d70:	46a0      	mov	r8, r4
    9d72:	4603      	mov	r3, r0
    9d74:	9008      	str	r0, [sp, #32]
    9d76:	f7ff bb61 	b.w	943c <_svfprintf_r+0x884>
    9d7a:	aa1b      	add	r2, sp, #108	; 0x6c
    9d7c:	9903      	ldr	r1, [sp, #12]
    9d7e:	9805      	ldr	r0, [sp, #20]
    9d80:	f000 f9d2 	bl	a128 <__ssprint_r>
    9d84:	2800      	cmp	r0, #0
    9d86:	f47f a80d 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9d8a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9d8c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9d8e:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9d92:	980d      	ldr	r0, [sp, #52]	; 0x34
    9d94:	f8c9 6000 	str.w	r6, [r9]
    9d98:	3201      	adds	r2, #1
    9d9a:	4403      	add	r3, r0
    9d9c:	2a07      	cmp	r2, #7
    9d9e:	931d      	str	r3, [sp, #116]	; 0x74
    9da0:	921c      	str	r2, [sp, #112]	; 0x70
    9da2:	f8c9 0004 	str.w	r0, [r9, #4]
    9da6:	f77f a9b6 	ble.w	9116 <_svfprintf_r+0x55e>
    9daa:	e476      	b.n	969a <_svfprintf_r+0xae2>
    9dac:	272d      	movs	r7, #45	; 0x2d
    9dae:	9304      	str	r3, [sp, #16]
    9db0:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    9db4:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9db8:	f04f 0800 	mov.w	r8, #0
    9dbc:	f7ff b8ef 	b.w	8f9e <_svfprintf_r+0x3e6>
    9dc0:	9709      	str	r7, [sp, #36]	; 0x24
    9dc2:	461f      	mov	r7, r3
    9dc4:	f7ff ba4c 	b.w	9260 <_svfprintf_r+0x6a8>
    9dc8:	9b15      	ldr	r3, [sp, #84]	; 0x54
    9dca:	1cda      	adds	r2, r3, #3
    9dcc:	db02      	blt.n	9dd4 <_svfprintf_r+0x121c>
    9dce:	4598      	cmp	r8, r3
    9dd0:	f6bf aee4 	bge.w	9b9c <_svfprintf_r+0xfe4>
    9dd4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    9dd6:	3a02      	subs	r2, #2
    9dd8:	920c      	str	r2, [sp, #48]	; 0x30
    9dda:	3b01      	subs	r3, #1
    9ddc:	2b00      	cmp	r3, #0
    9dde:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    9de2:	9315      	str	r3, [sp, #84]	; 0x54
    9de4:	bfb8      	it	lt
    9de6:	425b      	neglt	r3, r3
    9de8:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
    9dec:	bfb4      	ite	lt
    9dee:	222d      	movlt	r2, #45	; 0x2d
    9df0:	222b      	movge	r2, #43	; 0x2b
    9df2:	2b09      	cmp	r3, #9
    9df4:	f88d 205d 	strb.w	r2, [sp, #93]	; 0x5d
    9df8:	f340 8106 	ble.w	a008 <_svfprintf_r+0x1450>
    9dfc:	f10d 006b 	add.w	r0, sp, #107	; 0x6b
    9e00:	4604      	mov	r4, r0
    9e02:	4a47      	ldr	r2, [pc, #284]	; (9f20 <_svfprintf_r+0x1368>)
    9e04:	fb82 2103 	smull	r2, r1, r2, r3
    9e08:	17da      	asrs	r2, r3, #31
    9e0a:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
    9e0e:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    9e12:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
    9e16:	f103 0130 	add.w	r1, r3, #48	; 0x30
    9e1a:	2a09      	cmp	r2, #9
    9e1c:	4613      	mov	r3, r2
    9e1e:	f804 1d01 	strb.w	r1, [r4, #-1]!
    9e22:	dcee      	bgt.n	9e02 <_svfprintf_r+0x124a>
    9e24:	4621      	mov	r1, r4
    9e26:	3330      	adds	r3, #48	; 0x30
    9e28:	b2da      	uxtb	r2, r3
    9e2a:	f801 2d01 	strb.w	r2, [r1, #-1]!
    9e2e:	4288      	cmp	r0, r1
    9e30:	f240 8162 	bls.w	a0f8 <_svfprintf_r+0x1540>
    9e34:	f10d 015e 	add.w	r1, sp, #94	; 0x5e
    9e38:	4623      	mov	r3, r4
    9e3a:	e001      	b.n	9e40 <_svfprintf_r+0x1288>
    9e3c:	f813 2b01 	ldrb.w	r2, [r3], #1
    9e40:	f801 2b01 	strb.w	r2, [r1], #1
    9e44:	4298      	cmp	r0, r3
    9e46:	d1f9      	bne.n	9e3c <_svfprintf_r+0x1284>
    9e48:	1c43      	adds	r3, r0, #1
    9e4a:	1b1b      	subs	r3, r3, r4
    9e4c:	f10d 025e 	add.w	r2, sp, #94	; 0x5e
    9e50:	4413      	add	r3, r2
    9e52:	aa17      	add	r2, sp, #92	; 0x5c
    9e54:	1a9b      	subs	r3, r3, r2
    9e56:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    9e58:	9311      	str	r3, [sp, #68]	; 0x44
    9e5a:	2a01      	cmp	r2, #1
    9e5c:	4413      	add	r3, r2
    9e5e:	9308      	str	r3, [sp, #32]
    9e60:	f340 80ff 	ble.w	a062 <_svfprintf_r+0x14aa>
    9e64:	9b08      	ldr	r3, [sp, #32]
    9e66:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9e68:	4413      	add	r3, r2
    9e6a:	2200      	movs	r2, #0
    9e6c:	9308      	str	r3, [sp, #32]
    9e6e:	920e      	str	r2, [sp, #56]	; 0x38
    9e70:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9e74:	e6a1      	b.n	9bba <_svfprintf_r+0x1002>
    9e76:	460b      	mov	r3, r1
    9e78:	e682      	b.n	9b80 <_svfprintf_r+0xfc8>
    9e7a:	aa1b      	add	r2, sp, #108	; 0x6c
    9e7c:	9903      	ldr	r1, [sp, #12]
    9e7e:	9805      	ldr	r0, [sp, #20]
    9e80:	f000 f952 	bl	a128 <__ssprint_r>
    9e84:	2800      	cmp	r0, #0
    9e86:	f47e af8d 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9e8a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9e8c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9e90:	e483      	b.n	979a <_svfprintf_r+0xbe2>
    9e92:	aa1b      	add	r2, sp, #108	; 0x6c
    9e94:	9903      	ldr	r1, [sp, #12]
    9e96:	9805      	ldr	r0, [sp, #20]
    9e98:	f000 f946 	bl	a128 <__ssprint_r>
    9e9c:	2800      	cmp	r0, #0
    9e9e:	f47e af81 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9ea2:	9a15      	ldr	r2, [sp, #84]	; 0x54
    9ea4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9ea6:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9eaa:	e579      	b.n	99a0 <_svfprintf_r+0xde8>
    9eac:	464e      	mov	r6, r9
    9eae:	4689      	mov	r9, r1
    9eb0:	3201      	adds	r2, #1
    9eb2:	4423      	add	r3, r4
    9eb4:	2a07      	cmp	r2, #7
    9eb6:	931d      	str	r3, [sp, #116]	; 0x74
    9eb8:	921c      	str	r2, [sp, #112]	; 0x70
    9eba:	f8c9 7000 	str.w	r7, [r9]
    9ebe:	f8c9 4004 	str.w	r4, [r9, #4]
    9ec2:	f73f af5a 	bgt.w	9d7a <_svfprintf_r+0x11c2>
    9ec6:	f109 0908 	add.w	r9, r9, #8
    9eca:	e762      	b.n	9d92 <_svfprintf_r+0x11da>
    9ecc:	aa1b      	add	r2, sp, #108	; 0x6c
    9ece:	9903      	ldr	r1, [sp, #12]
    9ed0:	9805      	ldr	r0, [sp, #20]
    9ed2:	f000 f929 	bl	a128 <__ssprint_r>
    9ed6:	2800      	cmp	r0, #0
    9ed8:	f47e af64 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9edc:	9a15      	ldr	r2, [sp, #84]	; 0x54
    9ede:	990d      	ldr	r1, [sp, #52]	; 0x34
    9ee0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9ee2:	1a8a      	subs	r2, r1, r2
    9ee4:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9ee8:	e572      	b.n	99d0 <_svfprintf_r+0xe18>
    9eea:	2d06      	cmp	r5, #6
    9eec:	462b      	mov	r3, r5
    9eee:	bf28      	it	cs
    9ef0:	2306      	movcs	r3, #6
    9ef2:	9308      	str	r3, [sp, #32]
    9ef4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9ef8:	46b0      	mov	r8, r6
    9efa:	9709      	str	r7, [sp, #36]	; 0x24
    9efc:	960e      	str	r6, [sp, #56]	; 0x38
    9efe:	4637      	mov	r7, r6
    9f00:	9304      	str	r3, [sp, #16]
    9f02:	4e08      	ldr	r6, [pc, #32]	; (9f24 <_svfprintf_r+0x136c>)
    9f04:	f7ff b84a 	b.w	8f9c <_svfprintf_r+0x3e4>
    9f08:	469b      	mov	fp, r3
    9f0a:	f7ff b9ea 	b.w	92e2 <_svfprintf_r+0x72a>
    9f0e:	272d      	movs	r7, #45	; 0x2d
    9f10:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    9f14:	f7ff b833 	b.w	8f7e <_svfprintf_r+0x3c6>
    9f18:	20000e4c 	.word	0x20000e4c
    9f1c:	20001034 	.word	0x20001034
    9f20:	66666667 	.word	0x66666667
    9f24:	20000e88 	.word	0x20000e88
    9f28:	aa19      	add	r2, sp, #100	; 0x64
    9f2a:	ab16      	add	r3, sp, #88	; 0x58
    9f2c:	9201      	str	r2, [sp, #4]
    9f2e:	9300      	str	r3, [sp, #0]
    9f30:	2103      	movs	r1, #3
    9f32:	ab15      	add	r3, sp, #84	; 0x54
    9f34:	4642      	mov	r2, r8
    9f36:	eeb0 0b4a 	vmov.f64	d0, d10
    9f3a:	9805      	ldr	r0, [sp, #20]
    9f3c:	f7fd fff8 	bl	7f30 <_dtoa_r>
    9f40:	4644      	mov	r4, r8
    9f42:	4606      	mov	r6, r0
    9f44:	eb00 0108 	add.w	r1, r0, r8
    9f48:	e6ef      	b.n	9d2a <_svfprintf_r+0x1172>
    9f4a:	f04f 0806 	mov.w	r8, #6
    9f4e:	e5da      	b.n	9b06 <_svfprintf_r+0xf4e>
    9f50:	eeb1 ab48 	vneg.f64	d10, d8
    9f54:	272d      	movs	r7, #45	; 0x2d
    9f56:	e5e1      	b.n	9b1c <_svfprintf_r+0xf64>
    9f58:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9f5a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    9f5c:	4413      	add	r3, r2
    9f5e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    9f60:	9308      	str	r3, [sp, #32]
    9f62:	2a00      	cmp	r2, #0
    9f64:	f340 8086 	ble.w	a074 <_svfprintf_r+0x14bc>
    9f68:	2267      	movs	r2, #103	; 0x67
    9f6a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9f6e:	920c      	str	r2, [sp, #48]	; 0x30
    9f70:	e623      	b.n	9bba <_svfprintf_r+0x1002>
    9f72:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9f74:	2b47      	cmp	r3, #71	; 0x47
    9f76:	f47f adf2 	bne.w	9b5e <_svfprintf_r+0xfa6>
    9f7a:	f01b 0f01 	tst.w	fp, #1
    9f7e:	f47f aece 	bne.w	9d1e <_svfprintf_r+0x1166>
    9f82:	9b19      	ldr	r3, [sp, #100]	; 0x64
    9f84:	2d47      	cmp	r5, #71	; 0x47
    9f86:	eba3 0306 	sub.w	r3, r3, r6
    9f8a:	930d      	str	r3, [sp, #52]	; 0x34
    9f8c:	f43f af1c 	beq.w	9dc8 <_svfprintf_r+0x1210>
    9f90:	9b15      	ldr	r3, [sp, #84]	; 0x54
    9f92:	e722      	b.n	9dda <_svfprintf_r+0x1222>
    9f94:	2b00      	cmp	r3, #0
    9f96:	461a      	mov	r2, r3
    9f98:	930e      	str	r3, [sp, #56]	; 0x38
    9f9a:	dd73      	ble.n	a084 <_svfprintf_r+0x14cc>
    9f9c:	f1b8 0f00 	cmp.w	r8, #0
    9fa0:	d14b      	bne.n	a03a <_svfprintf_r+0x1482>
    9fa2:	f01b 0f01 	tst.w	fp, #1
    9fa6:	d148      	bne.n	a03a <_svfprintf_r+0x1482>
    9fa8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    9fac:	9208      	str	r2, [sp, #32]
    9fae:	e604      	b.n	9bba <_svfprintf_r+0x1002>
    9fb0:	f01b 0f01 	tst.w	fp, #1
    9fb4:	4647      	mov	r7, r8
    9fb6:	d005      	beq.n	9fc4 <_svfprintf_r+0x140c>
    9fb8:	ae38      	add	r6, sp, #224	; 0xe0
    9fba:	2330      	movs	r3, #48	; 0x30
    9fbc:	f806 3d41 	strb.w	r3, [r6, #-65]!
    9fc0:	f7ff b956 	b.w	9270 <_svfprintf_r+0x6b8>
    9fc4:	f8cd 8020 	str.w	r8, [sp, #32]
    9fc8:	ae28      	add	r6, sp, #160	; 0xa0
    9fca:	f7ff b954 	b.w	9276 <_svfprintf_r+0x6be>
    9fce:	ea25 73e5 	bic.w	r3, r5, r5, asr #31
    9fd2:	9709      	str	r7, [sp, #36]	; 0x24
    9fd4:	9304      	str	r3, [sp, #16]
    9fd6:	9508      	str	r5, [sp, #32]
    9fd8:	4680      	mov	r8, r0
    9fda:	900e      	str	r0, [sp, #56]	; 0x38
    9fdc:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    9fe0:	f7fe bfdc 	b.w	8f9c <_svfprintf_r+0x3e4>
    9fe4:	aa1b      	add	r2, sp, #108	; 0x6c
    9fe6:	9903      	ldr	r1, [sp, #12]
    9fe8:	9805      	ldr	r0, [sp, #20]
    9fea:	f000 f89d 	bl	a128 <__ssprint_r>
    9fee:	2800      	cmp	r0, #0
    9ff0:	f47e aed8 	bne.w	8da4 <_svfprintf_r+0x1ec>
    9ff4:	9c15      	ldr	r4, [sp, #84]	; 0x54
    9ff6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    9ff8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    9ffa:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    9ffe:	e63d      	b.n	9c7c <_svfprintf_r+0x10c4>
    a000:	46a2      	mov	sl, r4
    a002:	2500      	movs	r5, #0
    a004:	f7fe be33 	b.w	8c6e <_svfprintf_r+0xb6>
    a008:	3330      	adds	r3, #48	; 0x30
    a00a:	2230      	movs	r2, #48	; 0x30
    a00c:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    a010:	f88d 205e 	strb.w	r2, [sp, #94]	; 0x5e
    a014:	ab18      	add	r3, sp, #96	; 0x60
    a016:	e71c      	b.n	9e52 <_svfprintf_r+0x129a>
    a018:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a01a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a01c:	4413      	add	r3, r2
    a01e:	2267      	movs	r2, #103	; 0x67
    a020:	9308      	str	r3, [sp, #32]
    a022:	920c      	str	r2, [sp, #48]	; 0x30
    a024:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a028:	e5c7      	b.n	9bba <_svfprintf_r+0x1002>
    a02a:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a02c:	e5a8      	b.n	9b80 <_svfprintf_r+0xfc8>
    a02e:	4e3c      	ldr	r6, [pc, #240]	; (a120 <_svfprintf_r+0x1568>)
    a030:	4b3c      	ldr	r3, [pc, #240]	; (a124 <_svfprintf_r+0x156c>)
    a032:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    a036:	f7fe bfa4 	b.w	8f82 <_svfprintf_r+0x3ca>
    a03a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a03c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a03e:	189d      	adds	r5, r3, r2
    a040:	eb05 0308 	add.w	r3, r5, r8
    a044:	9308      	str	r3, [sp, #32]
    a046:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a04a:	e5b6      	b.n	9bba <_svfprintf_r+0x1002>
    a04c:	eeb5 ab40 	vcmp.f64	d10, #0.0
    a050:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    a054:	f43f ae6d 	beq.w	9d32 <_svfprintf_r+0x117a>
    a058:	f1c4 0401 	rsb	r4, r4, #1
    a05c:	9415      	str	r4, [sp, #84]	; 0x54
    a05e:	4421      	add	r1, r4
    a060:	e57e      	b.n	9b60 <_svfprintf_r+0xfa8>
    a062:	f01b 0301 	ands.w	r3, fp, #1
    a066:	f47f aefd 	bne.w	9e64 <_svfprintf_r+0x12ac>
    a06a:	930e      	str	r3, [sp, #56]	; 0x38
    a06c:	9b08      	ldr	r3, [sp, #32]
    a06e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a072:	e5a2      	b.n	9bba <_svfprintf_r+0x1002>
    a074:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    a076:	9a08      	ldr	r2, [sp, #32]
    a078:	f1c3 0301 	rsb	r3, r3, #1
    a07c:	441a      	add	r2, r3
    a07e:	4613      	mov	r3, r2
    a080:	9208      	str	r2, [sp, #32]
    a082:	e771      	b.n	9f68 <_svfprintf_r+0x13b0>
    a084:	f1b8 0f00 	cmp.w	r8, #0
    a088:	d102      	bne.n	a090 <_svfprintf_r+0x14d8>
    a08a:	f01b 0f01 	tst.w	fp, #1
    a08e:	d007      	beq.n	a0a0 <_svfprintf_r+0x14e8>
    a090:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    a092:	1c5d      	adds	r5, r3, #1
    a094:	eb05 0308 	add.w	r3, r5, r8
    a098:	9308      	str	r3, [sp, #32]
    a09a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    a09e:	e58c      	b.n	9bba <_svfprintf_r+0x1002>
    a0a0:	2301      	movs	r3, #1
    a0a2:	9308      	str	r3, [sp, #32]
    a0a4:	e589      	b.n	9bba <_svfprintf_r+0x1002>
    a0a6:	9809      	ldr	r0, [sp, #36]	; 0x24
    a0a8:	f89a 3001 	ldrb.w	r3, [sl, #1]
    a0ac:	6805      	ldr	r5, [r0, #0]
    a0ae:	3004      	adds	r0, #4
    a0b0:	2d00      	cmp	r5, #0
    a0b2:	9009      	str	r0, [sp, #36]	; 0x24
    a0b4:	46a2      	mov	sl, r4
    a0b6:	f6be add8 	bge.w	8c6a <_svfprintf_r+0xb2>
    a0ba:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    a0be:	f7fe bdd4 	b.w	8c6a <_svfprintf_r+0xb2>
    a0c2:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a0c6:	f7ff b98d 	b.w	93e4 <_svfprintf_r+0x82c>
    a0ca:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a0ce:	f7ff b9cf 	b.w	9470 <_svfprintf_r+0x8b8>
    a0d2:	9a05      	ldr	r2, [sp, #20]
    a0d4:	230c      	movs	r3, #12
    a0d6:	6013      	str	r3, [r2, #0]
    a0d8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a0dc:	f7fe be6b 	b.w	8db6 <_svfprintf_r+0x1fe>
    a0e0:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a0e4:	f7ff b8d4 	b.w	9290 <_svfprintf_r+0x6d8>
    a0e8:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a0ec:	f7ff b8a3 	b.w	9236 <_svfprintf_r+0x67e>
    a0f0:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a0f4:	f7ff b952 	b.w	939c <_svfprintf_r+0x7e4>
    a0f8:	f10d 035e 	add.w	r3, sp, #94	; 0x5e
    a0fc:	e6a9      	b.n	9e52 <_svfprintf_r+0x129a>
    a0fe:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a102:	f7fe be62 	b.w	8dca <_svfprintf_r+0x212>
    a106:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a10a:	f7ff b862 	b.w	91d2 <_svfprintf_r+0x61a>
    a10e:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a112:	f7fe bf16 	b.w	8f42 <_svfprintf_r+0x38a>
    a116:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    a11a:	f7fe bed0 	b.w	8ebe <_svfprintf_r+0x306>
    a11e:	bf00      	nop
    a120:	20000e5c 	.word	0x20000e5c
    a124:	20000e58 	.word	0x20000e58

0000a128 <__ssprint_r>:
    a128:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a12c:	6893      	ldr	r3, [r2, #8]
    a12e:	b083      	sub	sp, #12
    a130:	4690      	mov	r8, r2
    a132:	2b00      	cmp	r3, #0
    a134:	d072      	beq.n	a21c <__ssprint_r+0xf4>
    a136:	4683      	mov	fp, r0
    a138:	f04f 0900 	mov.w	r9, #0
    a13c:	6816      	ldr	r6, [r2, #0]
    a13e:	6808      	ldr	r0, [r1, #0]
    a140:	688b      	ldr	r3, [r1, #8]
    a142:	460d      	mov	r5, r1
    a144:	464c      	mov	r4, r9
    a146:	2c00      	cmp	r4, #0
    a148:	d045      	beq.n	a1d6 <__ssprint_r+0xae>
    a14a:	429c      	cmp	r4, r3
    a14c:	461f      	mov	r7, r3
    a14e:	469a      	mov	sl, r3
    a150:	d346      	bcc.n	a1e0 <__ssprint_r+0xb8>
    a152:	89ab      	ldrh	r3, [r5, #12]
    a154:	f413 6f90 	tst.w	r3, #1152	; 0x480
    a158:	d02d      	beq.n	a1b6 <__ssprint_r+0x8e>
    a15a:	696f      	ldr	r7, [r5, #20]
    a15c:	6929      	ldr	r1, [r5, #16]
    a15e:	eb07 0747 	add.w	r7, r7, r7, lsl #1
    a162:	ebc1 0a00 	rsb	sl, r1, r0
    a166:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
    a16a:	1c60      	adds	r0, r4, #1
    a16c:	107f      	asrs	r7, r7, #1
    a16e:	4450      	add	r0, sl
    a170:	42b8      	cmp	r0, r7
    a172:	463a      	mov	r2, r7
    a174:	bf84      	itt	hi
    a176:	4607      	movhi	r7, r0
    a178:	463a      	movhi	r2, r7
    a17a:	055b      	lsls	r3, r3, #21
    a17c:	d533      	bpl.n	a1e6 <__ssprint_r+0xbe>
    a17e:	4611      	mov	r1, r2
    a180:	4658      	mov	r0, fp
    a182:	f7fb ff7b 	bl	607c <_malloc_r>
    a186:	2800      	cmp	r0, #0
    a188:	d037      	beq.n	a1fa <__ssprint_r+0xd2>
    a18a:	4652      	mov	r2, sl
    a18c:	6929      	ldr	r1, [r5, #16]
    a18e:	9001      	str	r0, [sp, #4]
    a190:	f7fc fa42 	bl	6618 <memcpy>
    a194:	89aa      	ldrh	r2, [r5, #12]
    a196:	9b01      	ldr	r3, [sp, #4]
    a198:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    a19c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    a1a0:	81aa      	strh	r2, [r5, #12]
    a1a2:	ebca 0207 	rsb	r2, sl, r7
    a1a6:	eb03 000a 	add.w	r0, r3, sl
    a1aa:	616f      	str	r7, [r5, #20]
    a1ac:	612b      	str	r3, [r5, #16]
    a1ae:	6028      	str	r0, [r5, #0]
    a1b0:	60aa      	str	r2, [r5, #8]
    a1b2:	4627      	mov	r7, r4
    a1b4:	46a2      	mov	sl, r4
    a1b6:	4652      	mov	r2, sl
    a1b8:	4649      	mov	r1, r9
    a1ba:	f7fc fac7 	bl	674c <memmove>
    a1be:	f8d8 2008 	ldr.w	r2, [r8, #8]
    a1c2:	68ab      	ldr	r3, [r5, #8]
    a1c4:	6828      	ldr	r0, [r5, #0]
    a1c6:	1bdb      	subs	r3, r3, r7
    a1c8:	4450      	add	r0, sl
    a1ca:	1b14      	subs	r4, r2, r4
    a1cc:	60ab      	str	r3, [r5, #8]
    a1ce:	6028      	str	r0, [r5, #0]
    a1d0:	f8c8 4008 	str.w	r4, [r8, #8]
    a1d4:	b314      	cbz	r4, a21c <__ssprint_r+0xf4>
    a1d6:	f8d6 9000 	ldr.w	r9, [r6]
    a1da:	6874      	ldr	r4, [r6, #4]
    a1dc:	3608      	adds	r6, #8
    a1de:	e7b2      	b.n	a146 <__ssprint_r+0x1e>
    a1e0:	4627      	mov	r7, r4
    a1e2:	46a2      	mov	sl, r4
    a1e4:	e7e7      	b.n	a1b6 <__ssprint_r+0x8e>
    a1e6:	4658      	mov	r0, fp
    a1e8:	f7fc fb6e 	bl	68c8 <_realloc_r>
    a1ec:	4603      	mov	r3, r0
    a1ee:	2800      	cmp	r0, #0
    a1f0:	d1d7      	bne.n	a1a2 <__ssprint_r+0x7a>
    a1f2:	6929      	ldr	r1, [r5, #16]
    a1f4:	4658      	mov	r0, fp
    a1f6:	f7fd f947 	bl	7488 <_free_r>
    a1fa:	230c      	movs	r3, #12
    a1fc:	f8cb 3000 	str.w	r3, [fp]
    a200:	89ab      	ldrh	r3, [r5, #12]
    a202:	2200      	movs	r2, #0
    a204:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a208:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    a20c:	81ab      	strh	r3, [r5, #12]
    a20e:	f8c8 2008 	str.w	r2, [r8, #8]
    a212:	f8c8 2004 	str.w	r2, [r8, #4]
    a216:	b003      	add	sp, #12
    a218:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a21c:	2000      	movs	r0, #0
    a21e:	f8c8 0004 	str.w	r0, [r8, #4]
    a222:	b003      	add	sp, #12
    a224:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000a228 <___ZN7TwoWire5beginEv_veneer>:
    a228:	f85f f000 	ldr.w	pc, [pc]	; a22c <___ZN7TwoWire5beginEv_veneer+0x4>
    a22c:	60001e19 	.word	0x60001e19

0000a230 <___init_veneer>:
    a230:	f85f f000 	ldr.w	pc, [pc]	; a234 <___init_veneer+0x4>
    a234:	6000204d 	.word	0x6000204d

0000a238 <___reboot_Teensyduino__veneer>:
    a238:	f85f f000 	ldr.w	pc, [pc]	; a23c <___reboot_Teensyduino__veneer+0x4>
    a23c:	60001dc5 	.word	0x60001dc5

Disassembly of section .fini:

0000a240 <_fini>:
    a240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a242:	bf00      	nop

Disassembly of section .text.csf:

6000e784 <_heap_end+0x3fd8e784>:
6000e784:	ffffffff 	.word	0xffffffff
6000e788:	ffffffff 	.word	0xffffffff
6000e78c:	ffffffff 	.word	0xffffffff
6000e790:	ffffffff 	.word	0xffffffff
6000e794:	ffffffff 	.word	0xffffffff
6000e798:	ffffffff 	.word	0xffffffff
6000e79c:	ffffffff 	.word	0xffffffff
6000e7a0:	ffffffff 	.word	0xffffffff
6000e7a4:	ffffffff 	.word	0xffffffff
6000e7a8:	ffffffff 	.word	0xffffffff
6000e7ac:	ffffffff 	.word	0xffffffff
6000e7b0:	ffffffff 	.word	0xffffffff
6000e7b4:	ffffffff 	.word	0xffffffff
6000e7b8:	ffffffff 	.word	0xffffffff
6000e7bc:	ffffffff 	.word	0xffffffff
6000e7c0:	ffffffff 	.word	0xffffffff
6000e7c4:	ffffffff 	.word	0xffffffff
6000e7c8:	ffffffff 	.word	0xffffffff
6000e7cc:	ffffffff 	.word	0xffffffff
6000e7d0:	ffffffff 	.word	0xffffffff
6000e7d4:	ffffffff 	.word	0xffffffff
6000e7d8:	ffffffff 	.word	0xffffffff
6000e7dc:	ffffffff 	.word	0xffffffff
6000e7e0:	ffffffff 	.word	0xffffffff
6000e7e4:	ffffffff 	.word	0xffffffff
6000e7e8:	ffffffff 	.word	0xffffffff
6000e7ec:	ffffffff 	.word	0xffffffff
6000e7f0:	ffffffff 	.word	0xffffffff
6000e7f4:	ffffffff 	.word	0xffffffff
6000e7f8:	ffffffff 	.word	0xffffffff
6000e7fc:	ffffffff 	.word	0xffffffff

6000e800 <hab_csf>:
	...
