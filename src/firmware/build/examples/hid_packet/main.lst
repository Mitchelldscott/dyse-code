
/Users/mitchellscott/Desktop/rufous/src/firmware/build/examples/hid_packet/main.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001400:	4288      	cmp	r0, r1
60001402:	d007      	beq.n	60001414 <memory_copy+0x14>
	while (dest < dest_end) {
60001404:	4290      	cmp	r0, r2
60001406:	d205      	bcs.n	60001414 <memory_copy+0x14>
		*dest++ = *src++;
60001408:	f851 3b04 	ldr.w	r3, [r1], #4
6000140c:	f840 3b04 	str.w	r3, [r0], #4

__attribute__((section(".startup"), optimize("O1")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001410:	4282      	cmp	r2, r0
60001412:	d8f9      	bhi.n	60001408 <memory_copy+0x8>
60001414:	4770      	bx	lr
60001416:	bf00      	nop

60001418 <memory_clear>:
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001418:	4288      	cmp	r0, r1
6000141a:	d204      	bcs.n	60001426 <memory_clear+0xe>
		*dest++ = 0;
6000141c:	2300      	movs	r3, #0
6000141e:	f840 3b04 	str.w	r3, [r0], #4
}

__attribute__((section(".startup"), optimize("O1")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001422:	4281      	cmp	r1, r0
60001424:	d8fb      	bhi.n	6000141e <memory_clear+0x6>
60001426:	4770      	bx	lr

60001428 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001428:	4b66      	ldr	r3, [pc, #408]	; (600015c4 <ResetHandler+0x19c>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000142a:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000142e:	4a66      	ldr	r2, [pc, #408]	; (600015c8 <ResetHandler+0x1a0>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001430:	4866      	ldr	r0, [pc, #408]	; (600015cc <ResetHandler+0x1a4>)
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
void startup_late_hook(void)	__attribute__ ((weak, alias("startup_default_late_hook")));
__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
void ResetHandler(void)
{
60001432:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001436:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001438:	6418      	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143a:	4a65      	ldr	r2, [pc, #404]	; (600015d0 <ResetHandler+0x1a8>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000143c:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000143e:	4695      	mov	sp, r2
	__asm__ volatile("dsb":::"memory");
60001440:	f3bf 8f4f 	dsb	sy
	__asm__ volatile("isb":::"memory");
60001444:	f3bf 8f6f 	isb	sy
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
60001448:	f000 f930 	bl	600016ac <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000144c:	4b61      	ldr	r3, [pc, #388]	; (600015d4 <ResetHandler+0x1ac>)
6000144e:	2008      	movs	r0, #8
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001450:	4a61      	ldr	r2, [pc, #388]	; (600015d8 <ResetHandler+0x1b0>)
60001452:	4962      	ldr	r1, [pc, #392]	; (600015dc <ResetHandler+0x1b4>)
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
	__asm__ volatile("dsb":::"memory");
	__asm__ volatile("isb":::"memory");
#endif
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001454:	f8c3 0154 	str.w	r0, [r3, #340]	; 0x154
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001458:	4861      	ldr	r0, [pc, #388]	; (600015e0 <ResetHandler+0x1b8>)
6000145a:	f7ff ffd1 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
6000145e:	4a61      	ldr	r2, [pc, #388]	; (600015e4 <ResetHandler+0x1bc>)
60001460:	4961      	ldr	r1, [pc, #388]	; (600015e8 <ResetHandler+0x1c0>)
60001462:	4862      	ldr	r0, [pc, #392]	; (600015ec <ResetHandler+0x1c4>)
60001464:	f7ff ffcc 	bl	60001400 <memory_copy>
	memory_clear(&_sbss, &_ebss);
60001468:	4961      	ldr	r1, [pc, #388]	; (600015f0 <ResetHandler+0x1c8>)
6000146a:	4862      	ldr	r0, [pc, #392]	; (600015f4 <ResetHandler+0x1cc>)
6000146c:	f7ff ffd4 	bl	60001418 <memory_clear>
60001470:	4c61      	ldr	r4, [pc, #388]	; (600015f8 <ResetHandler+0x1d0>)

	// enable FPU
	SCB_CPACR = 0x00F00000;
60001472:	4962      	ldr	r1, [pc, #392]	; (600015fc <ResetHandler+0x1d4>)
60001474:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001478:	2300      	movs	r3, #0
6000147a:	4a61      	ldr	r2, [pc, #388]	; (60001600 <ResetHandler+0x1d8>)
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
6000147c:	6008      	str	r0, [r1, #0]

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000147e:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
60001482:	3301      	adds	r3, #1
60001484:	2bb0      	cmp	r3, #176	; 0xb0
60001486:	d1fa      	bne.n	6000147e <ResetHandler+0x56>
60001488:	4b5e      	ldr	r3, [pc, #376]	; (60001604 <ResetHandler+0x1dc>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
6000148a:	2180      	movs	r1, #128	; 0x80
6000148c:	4a5e      	ldr	r2, [pc, #376]	; (60001608 <ResetHandler+0x1e0>)
6000148e:	f803 1b01 	strb.w	r1, [r3], #1
60001492:	4293      	cmp	r3, r2
60001494:	d1fb      	bne.n	6000148e <ResetHandler+0x66>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001496:	4d4f      	ldr	r5, [pc, #316]	; (600015d4 <ResetHandler+0x1ac>)
60001498:	f04f 3880 	mov.w	r8, #2155905152	; 0x80808080
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
6000149c:	495b      	ldr	r1, [pc, #364]	; (6000160c <ResetHandler+0x1e4>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
6000149e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014a2:	4b5b      	ldr	r3, [pc, #364]	; (60001610 <ResetHandler+0x1e8>)
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600014a4:	2600      	movs	r6, #0

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014a6:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 6000164c <ResetHandler+0x224>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014aa:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 60001650 <ResetHandler+0x228>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014ae:	601c      	str	r4, [r3, #0]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014b0:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014b4:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014b8:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014bc:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c0:	680b      	ldr	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014c2:	4f54      	ldr	r7, [pc, #336]	; (60001614 <ResetHandler+0x1ec>)
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c4:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
600014c8:	600b      	str	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ca:	69fb      	ldr	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014cc:	493d      	ldr	r1, [pc, #244]	; (600015c4 <ResetHandler+0x19c>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014ce:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014d2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014d6:	61fb      	str	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
600014da:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014e2:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014e4:	668a      	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
600014e6:	66ca      	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
600014e8:	670a      	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
600014ea:	674a      	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
600014ec:	f000 f8e4 	bl	600016b8 <configure_cache>
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f0:	4a49      	ldr	r2, [pc, #292]	; (60001618 <ResetHandler+0x1f0>)
	_VectorsRam[15] = systick_isr;
600014f2:	4b4a      	ldr	r3, [pc, #296]	; (6000161c <ResetHandler+0x1f4>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014f4:	2063      	movs	r0, #99	; 0x63
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
600014f6:	63a2      	str	r2, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
600014f8:	2103      	movs	r1, #3

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
600014fa:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
600014fc:	4a48      	ldr	r2, [pc, #288]	; (60001620 <ResetHandler+0x1f8>)
	SYST_CVR = 0;
600014fe:	4b49      	ldr	r3, [pc, #292]	; (60001624 <ResetHandler+0x1fc>)
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001500:	6010      	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001502:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
60001506:	601e      	str	r6, [r3, #0]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001508:	f842 1c04 	str.w	r1, [r2, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000150c:	f600 70a1 	addw	r0, r0, #4001	; 0xfa1
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001510:	4945      	ldr	r1, [pc, #276]	; (60001628 <ResetHandler+0x200>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001512:	4a46      	ldr	r2, [pc, #280]	; (6000162c <ResetHandler+0x204>)
60001514:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001518:	680b      	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000151a:	4a45      	ldr	r2, [pc, #276]	; (60001630 <ResetHandler+0x208>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000151c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
60001520:	600b      	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001522:	6813      	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001524:	4943      	ldr	r1, [pc, #268]	; (60001634 <ResetHandler+0x20c>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001526:	f043 0301 	orr.w	r3, r3, #1
6000152a:	6013      	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000152c:	6803      	ldr	r3, [r0, #0]
6000152e:	600b      	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
60001530:	f000 fb12 	bl	60001b58 <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001534:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001538:	483f      	ldr	r0, [pc, #252]	; (60001638 <ResetHandler+0x210>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000153a:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000153e:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001542:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001546:	f000 fc77 	bl	60001e38 <__set_arm_clock_veneer>
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154a:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
6000154c:	4a3b      	ldr	r2, [pc, #236]	; (6000163c <ResetHandler+0x214>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000154e:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001552:	4b3b      	ldr	r3, [pc, #236]	; (60001640 <ResetHandler+0x218>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001554:	66f9      	str	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
60001556:	6016      	str	r6, [r2, #0]
	PIT_TCTRL0 = 0;
60001558:	f8c2 6108 	str.w	r6, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000155c:	f8c2 6118 	str.w	r6, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001560:	f8c2 6128 	str.w	r6, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001564:	f8c2 6138 	str.w	r6, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001568:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000156a:	07d2      	lsls	r2, r2, #31
6000156c:	d408      	bmi.n	60001580 <ResetHandler+0x158>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000156e:	f642 6215 	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
60001572:	4934      	ldr	r1, [pc, #208]	; (60001644 <ResetHandler+0x21c>)
60001574:	6559      	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001576:	651a      	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001578:	6b9a      	ldr	r2, [r3, #56]	; 0x38
6000157a:	f042 0201 	orr.w	r2, r2, #1
6000157e:	639a      	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
60001580:	4a2f      	ldr	r2, [pc, #188]	; (60001640 <ResetHandler+0x218>)
60001582:	4c31      	ldr	r4, [pc, #196]	; (60001648 <ResetHandler+0x220>)
60001584:	6893      	ldr	r3, [r2, #8]
60001586:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
6000158a:	6093      	str	r3, [r2, #8]

#ifdef ARDUINO_TEENSY41
	configure_external_ram();
6000158c:	f000 f906 	bl	6000179c <configure_external_ram>
#endif
	analog_init();
60001590:	f000 f860 	bl	60001654 <analog_init>
	pwm_init();
60001594:	f000 fc64 	bl	60001e60 <__pwm_init_veneer>
	tempmon_init();
60001598:	f000 fb10 	bl	60001bbc <tempmon_init>
	startup_middle_hook();
6000159c:	f000 f888 	bl	600016b0 <startup_default_middle_hook>
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
600015a0:	6823      	ldr	r3, [r4, #0]
#endif
	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290?p=87273&viewfull=1#post87273

	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015a2:	2b13      	cmp	r3, #19
600015a4:	d9fc      	bls.n	600015a0 <ResetHandler+0x178>
	usb_init();
600015a6:	f000 fb97 	bl	60001cd8 <usb_init>
600015aa:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015ac:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
600015b0:	d3fb      	bcc.n	600015aa <ResetHandler+0x182>
	//printf("before C++ constructors\n");
	startup_late_hook();
600015b2:	f000 f87f 	bl	600016b4 <startup_default_late_hook>
	__libc_init_array();
600015b6:	f000 fc47 	bl	60001e48 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
600015ba:	f000 fc35 	bl	60001e28 <__main_veneer>
	
	while (1) asm("WFI");
600015be:	bf30      	wfi
600015c0:	e7fd      	b.n	600015be <ResetHandler+0x196>
600015c2:	bf00      	nop
600015c4:	400ac000 	.word	0x400ac000
600015c8:	aaaaaaab 	.word	0xaaaaaaab
600015cc:	00200007 	.word	0x00200007
600015d0:	20078000 	.word	0x20078000
600015d4:	400d8000 	.word	0x400d8000
600015d8:	00006708 	.word	0x00006708
600015dc:	60001f5c 	.word	0x60001f5c
600015e0:	00000000 	.word	0x00000000
600015e4:	200016c0 	.word	0x200016c0
600015e8:	60008668 	.word	0x60008668
600015ec:	20000000 	.word	0x20000000
600015f0:	20001ca0 	.word	0x20001ca0
600015f4:	200016c0 	.word	0x200016c0
600015f8:	20001400 	.word	0x20001400
600015fc:	e000ed88 	.word	0xe000ed88
60001600:	00001005 	.word	0x00001005
60001604:	e000e400 	.word	0xe000e400
60001608:	e000e4a0 	.word	0xe000e4a0
6000160c:	e000ed24 	.word	0xe000ed24
60001610:	e000ed08 	.word	0xe000ed08
60001614:	400fc000 	.word	0x400fc000
60001618:	00002161 	.word	0x00002161
6000161c:	00002165 	.word	0x00002165
60001620:	e000e014 	.word	0xe000e014
60001624:	e000e018 	.word	0xe000e018
60001628:	e000edfc 	.word	0xe000edfc
6000162c:	20200000 	.word	0x20200000
60001630:	e0001000 	.word	0xe0001000
60001634:	20001bbc 	.word	0x20001bbc
60001638:	23c34600 	.word	0x23c34600
6000163c:	40084000 	.word	0x40084000
60001640:	400d4000 	.word	0x400d4000
60001644:	56c00000 	.word	0x56c00000
60001648:	20001bc0 	.word	0x20001bc0
6000164c:	2018101b 	.word	0x2018101b
60001650:	13110d0c 	.word	0x13110d0c

60001654 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001654:	4b11      	ldr	r3, [pc, #68]	; (6000169c <analog_init+0x48>)
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001656:	4912      	ldr	r1, [pc, #72]	; (600016a0 <analog_init+0x4c>)
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001658:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
6000165a:	460a      	mov	r2, r1
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
6000165c:	f440 3040 	orr.w	r0, r0, #196608	; 0x30000
}

#define MAX_ADC_CLOCK 20000000

FLASHMEM void analog_init(void)
{
60001660:	b430      	push	{r4, r5}
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001662:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001664:	f240 6537 	movw	r5, #1591	; 0x637
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001668:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
6000166a:	24a0      	movs	r4, #160	; 0xa0
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
6000166c:	f440 7040 	orr.w	r0, r0, #768	; 0x300
60001670:	66d8      	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
60001672:	644d      	str	r5, [r1, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001674:	648c      	str	r4, [r1, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) {
60001676:	6c93      	ldr	r3, [r2, #72]	; 0x48
60001678:	061b      	lsls	r3, r3, #24
6000167a:	d4fc      	bmi.n	60001676 <analog_init+0x22>
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
6000167c:	4b09      	ldr	r3, [pc, #36]	; (600016a4 <analog_init+0x50>)
6000167e:	f240 6037 	movw	r0, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001682:	21a0      	movs	r1, #160	; 0xa0
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
60001684:	461a      	mov	r2, r3
	while (ADC1_GC & ADC_GC_CAL) {
		//yield();
	}
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001686:	6458      	str	r0, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001688:	6499      	str	r1, [r3, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) {
6000168a:	6c93      	ldr	r3, [r2, #72]	; 0x48
6000168c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
60001690:	d1fb      	bne.n	6000168a <analog_init+0x36>
		//yield();
	}
	calibrating = 0;
60001692:	4a05      	ldr	r2, [pc, #20]	; (600016a8 <analog_init+0x54>)
60001694:	7013      	strb	r3, [r2, #0]
}
60001696:	bc30      	pop	{r4, r5}
60001698:	4770      	bx	lr
6000169a:	bf00      	nop
6000169c:	400fc000 	.word	0x400fc000
600016a0:	400c4000 	.word	0x400c4000
600016a4:	400c8000 	.word	0x400c8000
600016a8:	20001bf9 	.word	0x20001bf9

600016ac <startup_default_early_hook>:
600016ac:	4770      	bx	lr
600016ae:	bf00      	nop

600016b0 <startup_default_middle_hook>:
600016b0:	4770      	bx	lr
600016b2:	bf00      	nop

600016b4 <startup_default_late_hook>:
extern int main (void);
FLASHMEM void startup_default_early_hook(void) {}
void startup_early_hook(void)	__attribute__ ((weak, alias("startup_default_early_hook")));
FLASHMEM void startup_default_middle_hook(void) {}
void startup_middle_hook(void)	__attribute__ ((weak, alias("startup_default_middle_hook")));
FLASHMEM void startup_default_late_hook(void) {}
600016b4:	4770      	bx	lr
600016b6:	bf00      	nop

600016b8 <configure_cache>:
#define SIZE_2G		(SCB_MPU_RASR_SIZE(30) | SCB_MPU_RASR_ENABLE)
#define SIZE_4G		(SCB_MPU_RASR_SIZE(31) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
600016b8:	b5f0      	push	{r4, r5, r6, r7, lr}
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016ba:	4a24      	ldr	r2, [pc, #144]	; (6000174c <configure_cache+0x94>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016bc:	2000      	movs	r0, #0

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016be:	4b24      	ldr	r3, [pc, #144]	; (60001750 <configure_cache+0x98>)
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016c0:	f04f 0c10 	mov.w	ip, #16
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016c4:	4c23      	ldr	r4, [pc, #140]	; (60001754 <configure_cache+0x9c>)

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016c6:	2611      	movs	r6, #17

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016c8:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 60001794 <configure_cache+0xdc>
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016cc:	2712      	movs	r7, #18
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
600016ce:	6020      	str	r0, [r4, #0]
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600016d0:	2501      	movs	r5, #1
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600016d2:	f8c2 c000 	str.w	ip, [r2]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600016d6:	f8c3 e000 	str.w	lr, [r3]
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600016da:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016dc:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 60001798 <configure_cache+0xe0>

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016e0:	4e1d      	ldr	r6, [pc, #116]	; (60001758 <configure_cache+0xa0>)
	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600016e2:	f8c3 e000 	str.w	lr, [r3]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016e6:	491d      	ldr	r1, [pc, #116]	; (6000175c <configure_cache+0xa4>)
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600016e8:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600016ea:	601e      	str	r6, [r3, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600016ec:	f041 0115 	orr.w	r1, r1, #21
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f0:	4f1b      	ldr	r7, [pc, #108]	; (60001760 <configure_cache+0xa8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f2:	4e1c      	ldr	r6, [pc, #112]	; (60001764 <configure_cache+0xac>)
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600016f4:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600016f6:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016f8:	4f1b      	ldr	r7, [pc, #108]	; (60001768 <configure_cache+0xb0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fa:	4e1c      	ldr	r6, [pc, #112]	; (6000176c <configure_cache+0xb4>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600016fc:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600016fe:	601e      	str	r6, [r3, #0]
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001700:	4f1b      	ldr	r7, [pc, #108]	; (60001770 <configure_cache+0xb8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
60001702:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
60001704:	4e1b      	ldr	r6, [pc, #108]	; (60001774 <configure_cache+0xbc>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
60001706:	491c      	ldr	r1, [pc, #112]	; (60001778 <configure_cache+0xc0>)

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001708:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
6000170a:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
6000170c:	4f1b      	ldr	r7, [pc, #108]	; (6000177c <configure_cache+0xc4>)
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
6000170e:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001710:	4e1b      	ldr	r6, [pc, #108]	; (60001780 <configure_cache+0xc8>)

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
60001712:	491c      	ldr	r1, [pc, #112]	; (60001784 <configure_cache+0xcc>)
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
60001714:	6017      	str	r7, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
60001716:	601e      	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001718:	4f1b      	ldr	r7, [pc, #108]	; (60001788 <configure_cache+0xd0>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
6000171a:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
6000171c:	4e1b      	ldr	r6, [pc, #108]	; (6000178c <configure_cache+0xd4>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
6000171e:	491c      	ldr	r1, [pc, #112]	; (60001790 <configure_cache+0xd8>)

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
60001720:	601f      	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
60001722:	6016      	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
60001724:	6019      	str	r1, [r3, #0]

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
60001726:	6025      	str	r5, [r4, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
60001728:	f3bf 8f4f 	dsb	sy
	asm("isb");
6000172c:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
60001730:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0

	asm("dsb");
60001734:	f3bf 8f4f 	dsb	sy
	asm("isb");
60001738:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000173c:	f852 3c88 	ldr.w	r3, [r2, #-136]
60001740:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
60001744:	f842 3c88 	str.w	r3, [r2, #-136]
60001748:	bdf0      	pop	{r4, r5, r6, r7, pc}
6000174a:	bf00      	nop
6000174c:	e000ed9c 	.word	0xe000ed9c
60001750:	e000eda0 	.word	0xe000eda0
60001754:	e000ed94 	.word	0xe000ed94
60001758:	00100009 	.word	0x00100009
6000175c:	20001ca0 	.word	0x20001ca0
60001760:	00200013 	.word	0x00200013
60001764:	07020021 	.word	0x07020021
60001768:	20000014 	.word	0x20000014
6000176c:	13080025 	.word	0x13080025
60001770:	10000009 	.word	0x10000009
60001774:	20200016 	.word	0x20200016
60001778:	130b0027 	.word	0x130b0027
6000177c:	40000017 	.word	0x40000017
60001780:	13100033 	.word	0x13100033
60001784:	60000018 	.word	0x60000018
60001788:	070b002f 	.word	0x070b002f
6000178c:	70000019 	.word	0x70000019
60001790:	130b002f 	.word	0x130b002f
60001794:	1000003f 	.word	0x1000003f
60001798:	03080025 	.word	0x03080025

6000179c <configure_external_ram>:
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
6000179c:	b5f0      	push	{r4, r5, r6, r7, lr}
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
6000179e:	4b8d      	ldr	r3, [pc, #564]	; (600019d4 <configure_external_ram+0x238>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017a0:	2218      	movs	r2, #24
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017a2:	4e8d      	ldr	r6, [pc, #564]	; (600019d8 <configure_external_ram+0x23c>)
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017a4:	2001      	movs	r0, #1
}

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017a6:	498d      	ldr	r1, [pc, #564]	; (600019dc <configure_external_ram+0x240>)
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
600017a8:	f248 7e0c 	movw	lr, #34572	; 0x870c

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ac:	4d8c      	ldr	r5, [pc, #560]	; (600019e0 <configure_external_ram+0x244>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
600017ae:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017b2:	4c8c      	ldr	r4, [pc, #560]	; (600019e4 <configure_external_ram+0x248>)
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
600017b4:	b083      	sub	sp, #12
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017b6:	f8c3 125c 	str.w	r1, [r3, #604]	; 0x25c
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
600017ba:	f8c3 5260 	str.w	r5, [r3, #608]	; 0x260
	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
600017be:	2500      	movs	r5, #0
FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600017c0:	f8c3 1264 	str.w	r1, [r3, #612]	; 0x264
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600017c4:	f8c3 4268 	str.w	r4, [r3, #616]	; 0x268
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600017c8:	f44f 5400 	mov.w	r4, #8192	; 0x2000
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017cc:	f8c3 626c 	str.w	r6, [r3, #620]	; 0x26c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017d0:	4985      	ldr	r1, [pc, #532]	; (600019e8 <configure_external_ram+0x24c>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d2:	f8c3 6270 	str.w	r6, [r3, #624]	; 0x270
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017d6:	f8c3 6274 	str.w	r6, [r3, #628]	; 0x274
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600017da:	f8c3 6278 	str.w	r6, [r3, #632]	; 0x278
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
600017de:	4e83      	ldr	r6, [pc, #524]	; (600019ec <configure_external_ram+0x250>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600017e0:	66da      	str	r2, [r3, #108]	; 0x6c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DQS
600017e2:	671a      	str	r2, [r3, #112]	; 0x70
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS0_B (RAM)
600017e4:	675a      	str	r2, [r3, #116]	; 0x74
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SCLK
600017e6:	679a      	str	r2, [r3, #120]	; 0x78
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
600017e8:	67da      	str	r2, [r3, #124]	; 0x7c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
600017ea:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
600017ee:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3
600017f2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600017f6:	f240 6205 	movw	r2, #1541	; 0x605
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600017fa:	f8c1 032c 	str.w	r0, [r1, #812]	; 0x32c
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT = 1; // GPIO_EMC_26 for Mode: ALT8
600017fe:	f8c1 0330 	str.w	r0, [r1, #816]	; 0x330
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT = 1; // GPIO_EMC_27 for Mode: ALT8
60001802:	f8c1 0334 	str.w	r0, [r1, #820]	; 0x334
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
60001806:	f8c1 0338 	str.w	r0, [r1, #824]	; 0x338
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
6000180a:	f8c1 033c 	str.w	r0, [r1, #828]	; 0x33c
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8
6000180e:	f8c1 0350 	str.w	r0, [r1, #848]	; 0x350
	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
60001812:	4629      	mov	r1, r5
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001814:	69b3      	ldr	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
60001816:	4876      	ldr	r0, [pc, #472]	; (600019f0 <configure_external_ram+0x254>)
60001818:	4018      	ands	r0, r3
6000181a:	4b76      	ldr	r3, [pc, #472]	; (600019f4 <configure_external_ram+0x258>)
6000181c:	4303      	orrs	r3, r0
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
6000181e:	4876      	ldr	r0, [pc, #472]	; (600019f8 <configure_external_ram+0x25c>)
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001820:	61b3      	str	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);
60001822:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
60001826:	f043 030c 	orr.w	r3, r3, #12
6000182a:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
6000182e:	2602      	movs	r6, #2
	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
60001830:	6803      	ldr	r3, [r0, #0]
60001832:	4333      	orrs	r3, r6
60001834:	6003      	str	r3, [r0, #0]
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001836:	6803      	ldr	r3, [r0, #0]
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
60001838:	ea03 0e0e 	and.w	lr, r3, lr
6000183c:	4b6f      	ldr	r3, [pc, #444]	; (600019fc <configure_external_ram+0x260>)
6000183e:	ea4e 0303 	orr.w	r3, lr, r3
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001842:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 60001a34 <configure_external_ram+0x298>
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
60001846:	6003      	str	r3, [r0, #0]
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001848:	4b6d      	ldr	r3, [pc, #436]	; (60001a00 <configure_external_ram+0x264>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
6000184a:	6047      	str	r7, [r0, #4]
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
6000184c:	f8de 7008 	ldr.w	r7, [lr, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001850:	403b      	ands	r3, r7
	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001852:	4f6c      	ldr	r7, [pc, #432]	; (60001a04 <configure_external_ram+0x268>)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001854:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001858:	6083      	str	r3, [r0, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
6000185a:	68c3      	ldr	r3, [r0, #12]
6000185c:	f023 0378 	bic.w	r3, r3, #120	; 0x78
60001860:	60c3      	str	r3, [r0, #12]
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001862:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001864:	401f      	ands	r7, r3
60001866:	4b68      	ldr	r3, [pc, #416]	; (60001a08 <configure_external_ram+0x26c>)
60001868:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
6000186a:	4f66      	ldr	r7, [pc, #408]	; (60001a04 <configure_external_ram+0x268>)

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186c:	6203      	str	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000186e:	6a03      	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001870:	401f      	ands	r7, r3
60001872:	4b65      	ldr	r3, [pc, #404]	; (60001a08 <configure_external_ram+0x26c>)
60001874:	433b      	orrs	r3, r7
	FLEXSPI2_AHBRXBUF2CR0 = mask;
60001876:	4f65      	ldr	r7, [pc, #404]	; (60001a0c <configure_external_ram+0x270>)
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001878:	6243      	str	r3, [r0, #36]	; 0x24
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
6000187a:	6287      	str	r7, [r0, #40]	; 0x28
	FLEXSPI2_AHBRXBUF3CR0 = mask;
6000187c:	62c7      	str	r7, [r0, #44]	; 0x2c

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
6000187e:	f8de 30b8 	ldr.w	r3, [lr, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
60001882:	4f63      	ldr	r7, [pc, #396]	; (60001a10 <configure_external_ram+0x274>)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
60001884:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
60001888:	f043 0301 	orr.w	r3, r3, #1
6000188c:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001890:	f8de 30bc 	ldr.w	r3, [lr, #188]	; 0xbc
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
60001894:	f8df e184 	ldr.w	lr, [pc, #388]	; 60001a1c <configure_external_ram+0x280>
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001898:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
6000189c:	f043 0301 	orr.w	r3, r3, #1
600018a0:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc

	FLEXSPI2_INTEN = 0;
600018a4:	6105      	str	r5, [r0, #16]
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600018a6:	6604      	str	r4, [r0, #96]	; 0x60
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018a8:	6707      	str	r7, [r0, #112]	; 0x70
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018aa:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_FLSHA2CR0 = 0x2000; // 8 MByte
600018ae:	6644      	str	r4, [r0, #100]	; 0x64
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
600018b0:	6747      	str	r7, [r0, #116]	; 0x74
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600018b2:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018b6:	6804      	ldr	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018b8:	4b56      	ldr	r3, [pc, #344]	; (60001a14 <configure_external_ram+0x278>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018ba:	f024 0402 	bic.w	r4, r4, #2

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018be:	4a56      	ldr	r2, [pc, #344]	; (60001a18 <configure_external_ram+0x27c>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600018c0:	6004      	str	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018c2:	f8c0 e018 	str.w	lr, [r0, #24]
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018c6:	61c6      	str	r6, [r0, #28]
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600018c8:	f843 1b04 	str.w	r1, [r3], #4
600018cc:	4293      	cmp	r3, r2
600018ce:	d1fb      	bne.n	600018c8 <configure_external_ram+0x12c>
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d0:	4b49      	ldr	r3, [pc, #292]	; (600019f8 <configure_external_ram+0x25c>)
600018d2:	681a      	ldr	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018d4:	4619      	mov	r1, r3

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600018d6:	f042 0201 	orr.w	r2, r2, #1
600018da:	601a      	str	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600018dc:	680b      	ldr	r3, [r1, #0]
600018de:	4a46      	ldr	r2, [pc, #280]	; (600019f8 <configure_external_ram+0x25c>)
600018e0:	f013 0301 	ands.w	r3, r3, #1
600018e4:	d1fa      	bne.n	600018dc <configure_external_ram+0x140>

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018e6:	4e4d      	ldr	r6, [pc, #308]	; (60001a1c <configure_external_ram+0x280>)
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018e8:	2502      	movs	r5, #2

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
600018ea:	f240 64f5 	movw	r4, #1781	; 0x6f5
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
600018ee:	f240 4066 	movw	r0, #1126	; 0x466
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
600018f2:	f240 4199 	movw	r1, #1177	; 0x499
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
600018f6:	4f4a      	ldr	r7, [pc, #296]	; (60001a20 <configure_external_ram+0x284>)
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600018f8:	6196      	str	r6, [r2, #24]
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
600018fa:	f242 4601 	movw	r6, #9217	; 0x2401
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600018fe:	61d5      	str	r5, [r2, #28]
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001900:	f240 4535 	movw	r5, #1077	; 0x435

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
60001904:	f8c2 4200 	str.w	r4, [r2, #512]	; 0x200
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
60001908:	f242 2401 	movw	r4, #8705	; 0x2201
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
6000190c:	f8c2 0210 	str.w	r0, [r2, #528]	; 0x210

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001910:	2001      	movs	r0, #1
	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
60001912:	f8c2 1220 	str.w	r1, [r2, #544]	; 0x220
FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001916:	4611      	mov	r1, r2
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
60001918:	f8c2 7230 	str.w	r7, [r2, #560]	; 0x230
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
6000191c:	f107 475a 	add.w	r7, r7, #3657433088	; 0xda000000
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
60001920:	f8c2 6234 	str.w	r6, [r2, #564]	; 0x234
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001924:	f507 7713 	add.w	r7, r7, #588	; 0x24c
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
60001928:	f8c2 5240 	str.w	r5, [r2, #576]	; 0x240
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
6000192c:	4e3d      	ldr	r6, [pc, #244]	; (60001a24 <configure_external_ram+0x288>)
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
6000192e:	4d3e      	ldr	r5, [pc, #248]	; (60001a28 <configure_external_ram+0x28c>)
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001930:	f8c2 7250 	str.w	r7, [r2, #592]	; 0x250
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
60001934:	f8c2 6254 	str.w	r6, [r2, #596]	; 0x254
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
60001938:	f8c2 5260 	str.w	r5, [r2, #608]	; 0x260
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
6000193c:	f8c2 4264 	str.w	r4, [r2, #612]	; 0x264
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001940:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001944:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001948:	f8c2 00b0 	str.w	r0, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000194c:	694b      	ldr	r3, [r1, #20]
6000194e:	4a2a      	ldr	r2, [pc, #168]	; (600019f8 <configure_external_ram+0x25c>)
60001950:	07dd      	lsls	r5, r3, #31
60001952:	d5fb      	bpl.n	6000194c <configure_external_ram+0x1b0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001954:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001956:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001958:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000195c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000195e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001960:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001964:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001968:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000196c:	694b      	ldr	r3, [r1, #20]
6000196e:	4a22      	ldr	r2, [pc, #136]	; (600019f8 <configure_external_ram+0x25c>)
60001970:	07dc      	lsls	r4, r3, #31
60001972:	d5fb      	bpl.n	6000196c <configure_external_ram+0x1d0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001974:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001976:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001978:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000197c:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000197e:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001980:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001984:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001988:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000198c:	694b      	ldr	r3, [r1, #20]
6000198e:	4a1a      	ldr	r2, [pc, #104]	; (600019f8 <configure_external_ram+0x25c>)
60001990:	07d8      	lsls	r0, r3, #31
60001992:	d5fb      	bpl.n	6000198c <configure_external_ram+0x1f0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001994:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001996:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001998:	4824      	ldr	r0, [pc, #144]	; (60001a2c <configure_external_ram+0x290>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000199a:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000199c:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000199e:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
600019a2:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
600019a6:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
600019aa:	694b      	ldr	r3, [r1, #20]
600019ac:	4a12      	ldr	r2, [pc, #72]	; (600019f8 <configure_external_ram+0x25c>)
600019ae:	07db      	lsls	r3, r3, #31
600019b0:	d5fb      	bpl.n	600019aa <configure_external_ram+0x20e>
	uint32_t id = FLEXSPI2_RFDR0;
600019b2:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019b6:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019ba:	2021      	movs	r0, #33	; 0x21

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019bc:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600019be:	6150      	str	r0, [r2, #20]

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600019c0:	428b      	cmp	r3, r1
600019c2:	d039      	beq.n	60001a38 <configure_external_ram+0x29c>
			external_psram_size * 0x100000 -
			((uint32_t)&_extram_end - (uint32_t)&_extram_start),
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
600019c4:	4b1a      	ldr	r3, [pc, #104]	; (60001a30 <configure_external_ram+0x294>)
600019c6:	2200      	movs	r2, #0
600019c8:	601a      	str	r2, [r3, #0]
600019ca:	605a      	str	r2, [r3, #4]
600019cc:	609a      	str	r2, [r3, #8]
600019ce:	60da      	str	r2, [r3, #12]
	}
}
600019d0:	b003      	add	sp, #12
600019d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
600019d4:	401f8000 	.word	0x401f8000
600019d8:	000170f9 	.word	0x000170f9
600019dc:	0001b0f9 	.word	0x0001b0f9
600019e0:	000110f9 	.word	0x000110f9
600019e4:	000100f9 	.word	0x000100f9
600019e8:	401f8400 	.word	0x401f8400
600019ec:	400fc000 	.word	0x400fc000
600019f0:	1ffffcff 	.word	0x1ffffcff
600019f4:	a0000300 	.word	0xa0000300
600019f8:	402a4000 	.word	0x402a4000
600019fc:	ffff0012 	.word	0xffff0012
60001a00:	00f737ff 	.word	0x00f737ff
60001a04:	7cf0ff00 	.word	0x7cf0ff00
60001a08:	80000040 	.word	0x80000040
60001a0c:	830f00ff 	.word	0x830f00ff
60001a10:	00020063 	.word	0x00020063
60001a14:	402a4200 	.word	0x402a4200
60001a18:	402a4300 	.word	0x402a4300
60001a1c:	5af05af0 	.word	0x5af05af0
60001a20:	3018049f 	.word	0x3018049f
60001a24:	26013206 	.word	0x26013206
60001a28:	0a180638 	.word	0x0a180638
60001a2c:	00030004 	.word	0x00030004
60001a30:	20001c64 	.word	0x20001c64
60001a34:	402a8000 	.word	0x402a8000
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a38:	2400      	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a3a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a3e:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a40:	4611      	mov	r1, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a42:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a46:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a4a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a4e:	694b      	ldr	r3, [r1, #20]
60001a50:	4a3b      	ldr	r2, [pc, #236]	; (60001b40 <configure_external_ram+0x3a4>)
60001a52:	07df      	lsls	r7, r3, #31
60001a54:	d5fb      	bpl.n	60001a4e <configure_external_ram+0x2b2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a56:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a58:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a5c:	2000      	movs	r0, #0
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a5e:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a60:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a62:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a66:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a6a:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a6e:	694b      	ldr	r3, [r1, #20]
60001a70:	4a33      	ldr	r2, [pc, #204]	; (60001b40 <configure_external_ram+0x3a4>)
60001a72:	07de      	lsls	r6, r3, #31
60001a74:	d5fb      	bpl.n	60001a6e <configure_external_ram+0x2d2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a76:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a78:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a7c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a80:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a82:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a84:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a88:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001a8c:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001a90:	694b      	ldr	r3, [r1, #20]
60001a92:	4a2b      	ldr	r2, [pc, #172]	; (60001b40 <configure_external_ram+0x3a4>)
60001a94:	07dd      	lsls	r5, r3, #31
60001a96:	d5fb      	bpl.n	60001a90 <configure_external_ram+0x2f4>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001a98:	2301      	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001a9a:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001a9e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001aa2:	4611      	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aa4:	6153      	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001aa6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001aaa:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001aae:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ab2:	694b      	ldr	r3, [r1, #20]
60001ab4:	4a22      	ldr	r2, [pc, #136]	; (60001b40 <configure_external_ram+0x3a4>)
60001ab6:	07dc      	lsls	r4, r3, #31
60001ab8:	d5fb      	bpl.n	60001ab2 <configure_external_ram+0x316>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001aba:	2301      	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001abc:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001ac0:	4820      	ldr	r0, [pc, #128]	; (60001b44 <configure_external_ram+0x3a8>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ac2:	4611      	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001ac4:	6153      	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001ac6:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001aca:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001ace:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001ad2:	694b      	ldr	r3, [r1, #20]
60001ad4:	4a1a      	ldr	r2, [pc, #104]	; (60001b40 <configure_external_ram+0x3a4>)
60001ad6:	07d8      	lsls	r0, r3, #31
60001ad8:	d5fb      	bpl.n	60001ad2 <configure_external_ram+0x336>
	uint32_t id = FLEXSPI2_RFDR0;
60001ada:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ade:	f645 510d 	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae2:	2021      	movs	r0, #33	; 0x21
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae4:	b29b      	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
60001ae6:	6150      	str	r0, [r2, #20]
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
60001ae8:	428b      	cmp	r3, r1
60001aea:	d010      	beq.n	60001b0e <configure_external_ram+0x372>
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
		} else {
			// One PSRAM chip is present, 8 MByte
			external_psram_size = 8;
60001aec:	4b16      	ldr	r3, [pc, #88]	; (60001b48 <configure_external_ram+0x3ac>)
60001aee:	2208      	movs	r2, #8
60001af0:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
60001af4:	701a      	strb	r2, [r3, #0]
		}
		// TODO: zero uninitialized EXTMEM variables
		// TODO: copy from flash to initialize EXTMEM variables
		sm_set_pool(&extmem_smalloc_pool, &_extram_end,
60001af6:	4915      	ldr	r1, [pc, #84]	; (60001b4c <configure_external_ram+0x3b0>)
60001af8:	2000      	movs	r0, #0
60001afa:	4a15      	ldr	r2, [pc, #84]	; (60001b50 <configure_external_ram+0x3b4>)
60001afc:	2301      	movs	r3, #1
60001afe:	9000      	str	r0, [sp, #0]
60001b00:	1a52      	subs	r2, r2, r1
60001b02:	4814      	ldr	r0, [pc, #80]	; (60001b54 <configure_external_ram+0x3b8>)
60001b04:	4422      	add	r2, r4
60001b06:	f000 f993 	bl	60001e30 <__sm_set_pool_veneer>
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
	}
}
60001b0a:	b003      	add	sp, #12
60001b0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b0e:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b12:	f44f 2180 	mov.w	r1, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b16:	2301      	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b18:	4610      	mov	r0, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001b1a:	f8c2 40a0 	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001b1e:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001b22:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001b26:	6943      	ldr	r3, [r0, #20]
60001b28:	4905      	ldr	r1, [pc, #20]	; (60001b40 <configure_external_ram+0x3a4>)
60001b2a:	07db      	lsls	r3, r3, #31
60001b2c:	d5fb      	bpl.n	60001b26 <configure_external_ram+0x38a>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b2e:	2001      	movs	r0, #1
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b30:	4b05      	ldr	r3, [pc, #20]	; (60001b48 <configure_external_ram+0x3ac>)
60001b32:	2210      	movs	r2, #16
60001b34:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001b38:	6148      	str	r0, [r1, #20]
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001b3a:	701a      	strb	r2, [r3, #0]
60001b3c:	e7db      	b.n	60001af6 <configure_external_ram+0x35a>
60001b3e:	bf00      	nop
60001b40:	402a4000 	.word	0x402a4000
60001b44:	00030004 	.word	0x00030004
60001b48:	20001bfa 	.word	0x20001bfa
60001b4c:	70000000 	.word	0x70000000
60001b50:	70000000 	.word	0x70000000
60001b54:	20001c64 	.word	0x20001c64

60001b58 <usb_pll_start>:

#endif // ARDUINO_TEENSY41


FLASHMEM void usb_pll_start()
{
60001b58:	b4f0      	push	{r4, r5, r6, r7}
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b5a:	4a17      	ldr	r2, [pc, #92]	; (60001bb8 <usb_pll_start+0x60>)
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001b5c:	2740      	movs	r7, #64	; 0x40
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001b5e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b62:	f44f 5680 	mov.w	r6, #4096	; 0x1000
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b66:	f44f 5500 	mov.w	r5, #8192	; 0x2000
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b6a:	f44f 4440 	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b6e:	f243 0042 	movw	r0, #12354	; 0x3042


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b72:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b74:	f013 0f02 	tst.w	r3, #2
60001b78:	d006      	beq.n	60001b88 <usb_pll_start+0x30>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
60001b7a:	6194      	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001b7c:	6151      	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001b7e:	6190      	str	r0, [r2, #24]


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001b80:	6913      	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001b82:	f013 0f02 	tst.w	r3, #2
60001b86:	d1f8      	bne.n	60001b7a <usb_pll_start+0x22>
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
60001b88:	f413 5f00 	tst.w	r3, #8192	; 0x2000
60001b8c:	d101      	bne.n	60001b92 <usb_pll_start+0x3a>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001b8e:	6155      	str	r5, [r2, #20]
			continue;
60001b90:	e7ef      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001b92:	f413 5f80 	tst.w	r3, #4096	; 0x1000
60001b96:	d101      	bne.n	60001b9c <usb_pll_start+0x44>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001b98:	6156      	str	r6, [r2, #20]
			continue;
60001b9a:	e7ea      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
60001b9c:	2b00      	cmp	r3, #0
60001b9e:	dae8      	bge.n	60001b72 <usb_pll_start+0x1a>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
60001ba0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
60001ba4:	d001      	beq.n	60001baa <usb_pll_start+0x52>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001ba6:	6191      	str	r1, [r2, #24]
			continue;
60001ba8:	e7e3      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
60001baa:	065b      	lsls	r3, r3, #25
60001bac:	d401      	bmi.n	60001bb2 <usb_pll_start+0x5a>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001bae:	6157      	str	r7, [r2, #20]
			continue;
60001bb0:	e7df      	b.n	60001b72 <usb_pll_start+0x1a>
		}
		return; // everything is as it should be  :-)
	}
}
60001bb2:	bcf0      	pop	{r4, r5, r6, r7}
60001bb4:	4770      	bx	lr
60001bb6:	bf00      	nop
60001bb8:	400d8000 	.word	0x400d8000

60001bbc <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bbc:	4a39      	ldr	r2, [pc, #228]	; (60001ca4 <tempmon_init+0xe8>)

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bbe:	2003      	movs	r0, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bc0:	4939      	ldr	r1, [pc, #228]	; (60001ca8 <tempmon_init+0xec>)
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bc2:	eef3 5a09 	vmov.f32	s11, #57	; 0x41c80000  25.0
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bc6:	6813      	ldr	r3, [r2, #0]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001bc8:	ed9f 6a38 	vldr	s12, [pc, #224]	; 60001cac <tempmon_init+0xf0>
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bcc:	f023 0301 	bic.w	r3, r3, #1
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001bd0:	eddf 6a37 	vldr	s13, [pc, #220]	; 60001cb0 <tempmon_init+0xf4>
  //asm volatile ("dsb":::"memory");
  //while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
60001bd4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
60001bd6:	6013      	str	r3, [r2, #0]
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001bd8:	2400      	movs	r4, #0
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
60001bda:	6110      	str	r0, [r2, #16]
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
60001bdc:	f8d1 30e0 	ldr.w	r3, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be0:	4f34      	ldr	r7, [pc, #208]	; (60001cb4 <tempmon_init+0xf8>)
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001be2:	b2d8      	uxtb	r0, r3
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001be4:	f3c3 210b 	ubfx	r1, r3, #8, #12
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001be8:	0d1b      	lsrs	r3, r3, #20
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001bea:	4e33      	ldr	r6, [pc, #204]	; (60001cb8 <tempmon_init+0xfc>)
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bec:	ee07 0a10 	vmov	s14, r0
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bf0:	ee05 1a10 	vmov	s10, r1
60001bf4:	ee07 3a90 	vmov	s15, r3
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001bf8:	4b30      	ldr	r3, [pc, #192]	; (60001cbc <tempmon_init+0x100>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001bfa:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001bfe:	4d30      	ldr	r5, [pc, #192]	; (60001cc0 <tempmon_init+0x104>)
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c00:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
60001c04:	6030      	str	r0, [r6, #0]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001c0a:	6029      	str	r1, [r5, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c0c:	492d      	ldr	r1, [pc, #180]	; (60001cc4 <tempmon_init+0x108>)
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c0e:	ee37 6a46 	vsub.f32	s12, s14, s12
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c12:	4e2d      	ldr	r6, [pc, #180]	; (60001cc8 <tempmon_init+0x10c>)
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c14:	ee77 7ac5 	vsub.f32	s15, s15, s10
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* volatile _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
60001c18:	482c      	ldr	r0, [pc, #176]	; (60001ccc <tempmon_init+0x110>)
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c1a:	ee77 6a66 	vsub.f32	s13, s14, s13
60001c1e:	4d2c      	ldr	r5, [pc, #176]	; (60001cd0 <tempmon_init+0x114>)
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c20:	ee37 7a65 	vsub.f32	s14, s14, s11
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c24:	ee26 6a27 	vmul.f32	s12, s12, s15
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;
60001c28:	edc7 7a00 	vstr	s15, [r7]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c2c:	ee66 6aa7 	vmul.f32	s13, s13, s15
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c30:	6817      	ldr	r7, [r2, #0]
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c32:	ee67 7a27 	vmul.f32	s15, s14, s15
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = (float) (s_hotTemp) - 25.0f;
60001c36:	ed83 7a00 	vstr	s14, [r3]
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c3a:	eec6 5a07 	vdiv.f32	s11, s12, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c3e:	ee86 6a87 	vdiv.f32	s12, s13, s14
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c42:	eec7 6a87 	vdiv.f32	s13, s15, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c46:	ee35 7a85 	vadd.f32	s14, s11, s10
60001c4a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c4e:	ee36 7a05 	vadd.f32	s14, s12, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c52:	ee17 3a90 	vmov	r3, s15
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c56:	eebc 7ac7 	vcvt.u32.f32	s14, s14
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c5a:	ea47 5303 	orr.w	r3, r7, r3, lsl #20
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c5e:	ee76 7a85 	vadd.f32	s15, s13, s10
    s_roomC_hotC = (float) roomCount - (float) s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001c62:	6013      	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c64:	ee17 3a10 	vmov	r3, s14
60001c68:	f8d2 7110 	ldr.w	r7, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c6c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c70:	ea01 4103 	and.w	r1, r1, r3, lsl #16
60001c74:	4339      	orrs	r1, r7
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c76:	ee17 3a90 	vmov	r3, s15
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001c7a:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = ((float)s_hotCount + ((float)s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001c7e:	f3c3 030b 	ubfx	r3, r3, #0, #12
60001c82:	f8d2 1110 	ldr.w	r1, [r2, #272]	; 0x110
60001c86:	430b      	orrs	r3, r1
60001c88:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
60001c8c:	6813      	ldr	r3, [r2, #0]
60001c8e:	f043 0302 	orr.w	r3, r3, #2
60001c92:	6013      	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001c94:	7034      	strb	r4, [r6, #0]
60001c96:	f8c0 5140 	str.w	r5, [r0, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001c9a:	4b0e      	ldr	r3, [pc, #56]	; (60001cd4 <tempmon_init+0x118>)
60001c9c:	2201      	movs	r2, #1
}
60001c9e:	bcf0      	pop	{r4, r5, r6, r7}
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001ca0:	601a      	str	r2, [r3, #0]
}
60001ca2:	4770      	bx	lr
60001ca4:	400d8180 	.word	0x400d8180
60001ca8:	401f4400 	.word	0x401f4400
60001cac:	42aa0000 	.word	0x42aa0000
60001cb0:	42b40000 	.word	0x42b40000
60001cb4:	20001bb4 	.word	0x20001bb4
60001cb8:	20001bac 	.word	0x20001bac
60001cbc:	20001bb0 	.word	0x20001bb0
60001cc0:	20001ba8 	.word	0x20001ba8
60001cc4:	0fff0000 	.word	0x0fff0000
60001cc8:	e000e440 	.word	0xe000e440
60001ccc:	20001400 	.word	0x20001400
60001cd0:	000011c5 	.word	0x000011c5
60001cd4:	e000e108 	.word	0xe000e108

60001cd8 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001cd8:	4b30      	ldr	r3, [pc, #192]	; (60001d9c <usb_init+0xc4>)
60001cda:	f640 7261 	movw	r2, #3937	; 0xf61

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
60001cde:	b570      	push	{r4, r5, r6, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001ce0:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001ce4:	f240 4504 	movw	r5, #1028	; 0x404
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
60001ce8:	f000 f8b2 	bl	60001e50 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cec:	492c      	ldr	r1, [pc, #176]	; (60001da0 <usb_init+0xc8>)
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001cee:	482d      	ldr	r0, [pc, #180]	; (60001da4 <usb_init+0xcc>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf0:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cf4:	4c2c      	ldr	r4, [pc, #176]	; (60001da8 <usb_init+0xd0>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cf6:	f042 0203 	orr.w	r2, r2, #3
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001cfa:	4b2c      	ldr	r3, [pc, #176]	; (60001dac <usb_init+0xd4>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001cfc:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001d00:	f8c0 5160 	str.w	r5, [r0, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001d04:	6822      	ldr	r2, [r4, #0]
60001d06:	4013      	ands	r3, r2
60001d08:	b91b      	cbnz	r3, 60001d12 <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
60001d0a:	f8d0 31a8 	ldr.w	r3, [r0, #424]	; 0x1a8
60001d0e:	079a      	lsls	r2, r3, #30
60001d10:	d01a      	beq.n	60001d48 <usb_init+0x70>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d12:	4b24      	ldr	r3, [pc, #144]	; (60001da4 <usb_init+0xcc>)
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001d14:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
60001d18:	4a23      	ldr	r2, [pc, #140]	; (60001da8 <usb_init+0xd0>)
60001d1a:	6351      	str	r1, [r2, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d1c:	461a      	mov	r2, r3
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001d1e:	f8d3 1140 	ldr.w	r1, [r3, #320]	; 0x140
60001d22:	f041 0102 	orr.w	r1, r1, #2
60001d26:	f8c3 1140 	str.w	r1, [r3, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001d2a:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001d2e:	079b      	lsls	r3, r3, #30
60001d30:	d4fb      	bmi.n	60001d2a <usb_init+0x52>
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d32:	f44f 3000 	mov.w	r0, #131072	; 0x20000
60001d36:	491e      	ldr	r1, [pc, #120]	; (60001db0 <usb_init+0xd8>)
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d38:	4b1b      	ldr	r3, [pc, #108]	; (60001da8 <usb_init+0xd0>)
60001d3a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001d3e:	6008      	str	r0, [r1, #0]
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d40:	2019      	movs	r0, #25
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001d42:	639a      	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001d44:	f000 f87c 	bl	60001e40 <__delay_veneer>
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d48:	4d1a      	ldr	r5, [pc, #104]	; (60001db4 <usb_init+0xdc>)
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d4a:	2200      	movs	r2, #0
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d4c:	4b16      	ldr	r3, [pc, #88]	; (60001da8 <usb_init+0xd0>)
60001d4e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d52:	4c14      	ldr	r4, [pc, #80]	; (60001da4 <usb_init+0xcc>)
60001d54:	260a      	movs	r6, #10
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001d56:	6399      	str	r1, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d58:	4628      	mov	r0, r5
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001d5a:	601a      	str	r2, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d5c:	4611      	mov	r1, r2
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001d5e:	f8c4 61a8 	str.w	r6, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001d62:	f44f 7220 	mov.w	r2, #640	; 0x280
60001d66:	f000 f877 	bl	60001e58 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d6a:	f44f 0681 	mov.w	r6, #4227072	; 0x408000
	endpoint_queue_head[1].config = (64 << 16);
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d6e:	f240 1143 	movw	r1, #323	; 0x143
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
	endpoint_queue_head[1].config = (64 << 16);
60001d72:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
60001d76:	4b10      	ldr	r3, [pc, #64]	; (60001db8 <usb_init+0xe0>)
60001d78:	4a10      	ldr	r2, [pc, #64]	; (60001dbc <usb_init+0xe4>)
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001d7a:	602e      	str	r6, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
60001d7c:	6428      	str	r0, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001d7e:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001d82:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
60001d86:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d8a:	4a0d      	ldr	r2, [pc, #52]	; (60001dc0 <usb_init+0xe8>)
60001d8c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d90:	2301      	movs	r3, #1
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &usb_isr;
	attachInterruptVector(IRQ_USB1, &usb_isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001d92:	6011      	str	r1, [r2, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001d94:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
60001d98:	bd70      	pop	{r4, r5, r6, pc}
60001d9a:	bf00      	nop
60001d9c:	400d8000 	.word	0x400d8000
60001da0:	400fc000 	.word	0x400fc000
60001da4:	402e0000 	.word	0x402e0000
60001da8:	400d9000 	.word	0x400d9000
60001dac:	001e1c00 	.word	0x001e1c00
60001db0:	e000e28c 	.word	0xe000e28c
60001db4:	20000000 	.word	0x20000000
60001db8:	20001400 	.word	0x20001400
60001dbc:	00001391 	.word	0x00001391
60001dc0:	e000e10c 	.word	0xe000e10c

60001dc4 <_reboot_Teensyduino_>:
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


FLASHMEM void _reboot_Teensyduino_(void)
{
60001dc4:	b508      	push	{r3, lr}
	if (!(HW_OCOTP_CFG5 & 0x02)) {
60001dc6:	4b0e      	ldr	r3, [pc, #56]	; (60001e00 <_reboot_Teensyduino_+0x3c>)
60001dc8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
60001dca:	079b      	lsls	r3, r3, #30
60001dcc:	d400      	bmi.n	60001dd0 <_reboot_Teensyduino_+0xc>
		asm("bkpt #251"); // run bootloader
60001dce:	befb      	bkpt	0x00fb
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
60001dd0:	b672      	cpsid	i
		USB1_USBCMD = 0;
60001dd2:	4b0c      	ldr	r3, [pc, #48]	; (60001e04 <_reboot_Teensyduino_+0x40>)
60001dd4:	2000      	movs	r0, #0
		IOMUXC_GPR_GPR16 = 0x00200003;
60001dd6:	4a0c      	ldr	r2, [pc, #48]	; (60001e08 <_reboot_Teensyduino_+0x44>)
{
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
60001dd8:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001ddc:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de0:	490a      	ldr	r1, [pc, #40]	; (60001e0c <_reboot_Teensyduino_+0x48>)
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de2:	f5a3 235f 	sub.w	r3, r3, #913408	; 0xdf000
	if (!(HW_OCOTP_CFG5 & 0x02)) {
		asm("bkpt #251"); // run bootloader
	} else {
		__disable_irq(); // secure mode NXP ROM reboot
		USB1_USBCMD = 0;
		IOMUXC_GPR_GPR16 = 0x00200003;
60001de6:	6411      	str	r1, [r2, #64]	; 0x40
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
60001de8:	469d      	mov	sp, r3
		__asm__ volatile("dsb":::"memory");
60001dea:	f3bf 8f4f 	dsb	sy
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dee:	4a08      	ldr	r2, [pc, #32]	; (60001e10 <_reboot_Teensyduino_+0x4c>)
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001df0:	f503 43e0 	add.w	r3, r3, #28672	; 0x7000
60001df4:	4907      	ldr	r1, [pc, #28]	; (60001e14 <_reboot_Teensyduino_+0x50>)
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001df6:	6812      	ldr	r2, [r2, #0]
60001df8:	4618      	mov	r0, r3
		IOMUXC_GPR_GPR16 = 0x00200003;
		// TODO: wipe all RAM for security
		__asm__ volatile("mov sp, %0" : : "r" (0x20201000) : );
		__asm__ volatile("dsb":::"memory");
		volatile uint32_t * const p = (uint32_t *)0x20208000;
		*p = 0xEB120000;
60001dfa:	6019      	str	r1, [r3, #0]
		((void (*)(volatile void *))(*(uint32_t *)(*(uint32_t *)0x0020001C + 8)))(p);
60001dfc:	6893      	ldr	r3, [r2, #8]
60001dfe:	4798      	blx	r3
60001e00:	401f4400 	.word	0x401f4400
60001e04:	402e0000 	.word	0x402e0000
60001e08:	400ac000 	.word	0x400ac000
60001e0c:	00200003 	.word	0x00200003
60001e10:	0020001c 	.word	0x0020001c
60001e14:	eb120000 	.word	0xeb120000

60001e18 <_init>:
60001e18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
60001e1a:	bf00      	nop
60001e1c:	bcf8      	pop	{r3, r4, r5, r6, r7}
60001e1e:	bc08      	pop	{r3}
60001e20:	469e      	mov	lr, r3
60001e22:	4770      	bx	lr
60001e24:	0000      	movs	r0, r0
	...

60001e28 <__main_veneer>:
60001e28:	f85f f000 	ldr.w	pc, [pc]	; 60001e2c <__main_veneer+0x4>
60001e2c:	00000601 	.word	0x00000601

60001e30 <__sm_set_pool_veneer>:
60001e30:	f85f f000 	ldr.w	pc, [pc]	; 60001e34 <__sm_set_pool_veneer+0x4>
60001e34:	00000f75 	.word	0x00000f75

60001e38 <__set_arm_clock_veneer>:
60001e38:	f85f f000 	ldr.w	pc, [pc]	; 60001e3c <__set_arm_clock_veneer+0x4>
60001e3c:	0000085d 	.word	0x0000085d

60001e40 <__delay_veneer>:
60001e40:	f85f f000 	ldr.w	pc, [pc]	; 60001e44 <__delay_veneer+0x4>
60001e44:	00000b21 	.word	0x00000b21

60001e48 <____libc_init_array_veneer>:
60001e48:	f85f f000 	ldr.w	pc, [pc]	; 60001e4c <____libc_init_array_veneer+0x4>
60001e4c:	00002851 	.word	0x00002851

60001e50 <__usb_init_serialnumber_veneer>:
60001e50:	f85f f000 	ldr.w	pc, [pc]	; 60001e54 <__usb_init_serialnumber_veneer+0x4>
60001e54:	00001af5 	.word	0x00001af5

60001e58 <__memset_veneer>:
60001e58:	f85f f000 	ldr.w	pc, [pc]	; 60001e5c <__memset_veneer+0x4>
60001e5c:	0000308d 	.word	0x0000308d

60001e60 <__pwm_init_veneer>:
60001e60:	f85f f000 	ldr.w	pc, [pc]	; 60001e64 <__pwm_init_veneer+0x4>
60001e64:	00000c3d 	.word	0x00000c3d

60001e68 <__init_array_start>:
60001e68:	00000045 	.word	0x00000045
60001e6c:	00000655 	.word	0x00000655
60001e70:	0000223d 	.word	0x0000223d

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      20:	4c05b510 	.word	0x4c05b510
      24:	7823      	ldrb	r3, [r4, #0]
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      26:	b933      	.short	0xb933
      28:	4b04      	ldr	r3, [pc, #16]	; (3c <_teensy_model_identifier+0x17>)
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      2a:	b113      	cbz	r3, 32 <_teensy_model_identifier+0xd>
      2c:	f3af4804 	.word	0xf3af4804
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
      30:	8000      	strh	r0, [r0, #0]
      32:	2301      	.short	0x2301
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      34:	7023      	strb	r3, [r4, #0]
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
      36:	bd10      	.short	0xbd10
      38:	1a68      	subs	r0, r5, r1
      3a:	2000      	.short	0x2000
      3c:	0000      	movs	r0, r0
      3e:	0000      	.short	0x0000
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
      40:	6704      	str	r4, [r0, #112]	; 0x70
	...

00000044 <frame_dummy>:

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
      44:	b5104b08 	.word	0xb5104b08
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      48:	b11b      	cbz	r3, 52 <frame_dummy+0xe>
      4a:	4908      	.short	0x4908
      4c:	4808      	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	f3af      	.short	0xf3af
      50:	8000      	strh	r0, [r0, #0]
      52:	4808      	.short	0x4808
      54:	6803      	ldr	r3, [r0, #0]
      56:	b903      	.short	0xb903
      58:	bd10      	pop	{r4, pc}
      5a:	4b07      	.short	0x4b07
      5c:	2b00      	cmp	r3, #0
      5e:	d0fb      	beq.n	58 <frame_dummy+0x14>
      60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      64:	4718      	bx	r3
      66:	bf00      	nop
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      68:	0000      	movs	r0, r0
      6a:	0000      	movs	r0, r0
			yield(); // TODO: what happens if yield-called code uses analogRead()
      6c:	1a6c      	subs	r4, r5, r1
      6e:	2000      	.short	0x2000
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) {
      70:	6704      	str	r4, [r0, #112]	; 0x70
      72:	0000      	movs	r0, r0
      74:	16c0      	asrs	r0, r0, #27
			yield(); // TODO: what happens if yield-called code uses analogRead()
		}
		return ADC2_R0;
      76:	2000      	movs	r0, #0
      78:	0000      	movs	r0, r0
	...

0000007c <int assert_eq<int>(int, int, String) [clone .part.1] [clone .constprop.6]>:
// int assert_not_nan(float, String);
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
      7c:	b570      	push	{r4, r5, r6, lr}
      7e:	4606      	mov	r6, r0
      80:	b082      	sub	sp, #8
      82:	460d      	mov	r5, r1
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
      84:	210c4808 	.word	0x210c4808
      88:	4614      	mov	r4, r2
      8a:	f002      	.short	0xf002
      8c:	f81b 4907 	ldrb.w	r4, [fp], #-7
	if (a != b) {
		TEST_INFO(message, "!=", a, b);
      90:	95014633 	.word	0x95014633
      94:	9100      	str	r1, [sp, #0]
      96:	4622      	.short	0x4622
      98:	4905      	ldr	r1, [pc, #20]	; (b0 <int assert_eq<int>(int, int, String) [clone .part.1] [clone .constprop.6]+0x34>)
      9a:	4806      	.short	0x4806
      9c:	f002 f8b8 	bl	2210 <Print::printf(char const*, ...)>
		return 1;
	}
	return 0;
}
      a0:	2001      	movs	r0, #1
      a2:	b002      	.short	0xb002
      a4:	bd70      	pop	{r4, r5, r6, pc}
      a6:	bf00      	nop
      a8:	200004bc 	.word	0x200004bc
      ac:	04dc      	lsls	r4, r3, #19
      ae:	2000      	movs	r0, #0
      b0:	04cc      	lsls	r4, r1, #19
      b2:	2000      	.short	0x2000
      b4:	0c2c      	lsrs	r4, r5, #16
      b6:	2000      	movs	r0, #0

000000b8 <Print::println(char const*)>:
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
      b8:	4604b538 	.word	0x4604b538
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
      bc:	4608      	mov	r0, r1
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
      be:	460d      	.short	0x460d
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
      c0:	f003 fa9e 	bl	3600 <strlen>
      c4:	6823      	ldr	r3, [r4, #0]
      c6:	4602      	mov	r2, r0
      c8:	4629      	mov	r1, r5
      ca:	4620      	mov	r0, r4
      cc:	685b      	ldr	r3, [r3, #4]
      ce:	4798      	blx	r3
      d0:	46204605 	.word	0x46204605
	// Print a string and newline
	size_t println(const String &s)			{ return print(s) + println(); }
	// Print a single character and newline
	size_t println(char c)				{ return print(c) + println(); }
	// Print a string and newline
	size_t println(const char s[])			{ return print(s) + println(); }
      d4:	f002 f884 	bl	21e0 <Print::println()>
      d8:	bd384428 	.word	0xbd384428

000000dc <packet_put_test()>:
HidReport incoming_report;

FTYK timer;


int packet_put_test() {
      dc:	b570      	push	{r4, r5, r6, lr}
	int errors = 0;
	Serial.printf("\nPUT test:...\n");

	// execute the function in question
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
      de:	2400      	.short	0x2400
FTYK timer;


int packet_put_test() {
	int errors = 0;
	Serial.printf("\nPUT test:...\n");
      e0:	491a      	ldr	r1, [pc, #104]	; (14c <packet_put_test()+0x70>)
HidReport incoming_report;

FTYK timer;


int packet_put_test() {
      e2:	b084      	.short	0xb084
	int errors = 0;
	Serial.printf("\nPUT test:...\n");
      e4:	481a      	ldr	r0, [pc, #104]	; (150 <packet_put_test()+0x74>)
      e6:	f002 f893 	bl	2210 <Print::printf(char const*, ...)>

	// execute the function in question
	timer.set(0);
      ea:	4621      	mov	r1, r4
      ec:	f0004819 	.word	0xf0004819
      f0:	fb89 4621 			; <UNDEFINED> instruction: 0xfb894621
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
      f4:	22ff3401 	.word	0x22ff3401
		outgoing_report.put(i, 0xFF);
      f8:	4817      	ldr	r0, [pc, #92]	; (158 <packet_put_test()+0x7c>)
      fa:	f000 fb13 	bl	724 <HidReport::put(int, unsigned char)>
	int errors = 0;
	Serial.printf("\nPUT test:...\n");

	// execute the function in question
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
      fe:	2c40      	cmp	r4, #64	; 0x40
     100:	d1f7      	bne.n	f2 <packet_put_test()+0x16>
		outgoing_report.put(i, 0xFF);
	}	
	timer.mark(0);

	// check the test
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     102:	2400      	movs	r4, #0
	// execute the function in question
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
		outgoing_report.put(i, 0xFF);
	}	
	timer.mark(0);
     104:	4813      	ldr	r0, [pc, #76]	; (154 <packet_put_test()+0x78>)
     106:	4621      	.short	0x4621

FTYK timer;


int packet_put_test() {
	int errors = 0;
     108:	4626      	mov	r6, r4
	// execute the function in question
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
		outgoing_report.put(i, 0xFF);
	}	
	timer.mark(0);
     10a:	f000 fb85 	bl	818 <FTYK::mark(int)>

	// check the test
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
		errors += assert_eq<int>(0xFF, outgoing_report.get(i), "failed packet insert");
     10e:	4621      	mov	r1, r4
     110:	4811      	ldr	r0, [pc, #68]	; (158 <packet_put_test()+0x7c>)
     112:	f000 fb05 	bl	720 <HidReport::get(int)>
     116:	4605      	mov	r5, r0
     118:	4910      	ldr	r1, [pc, #64]	; (15c <packet_put_test()+0x80>)
     11a:	4668      	mov	r0, sp
     11c:	f002 f8da 	bl	22d4 <String::String(char const*)>
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
	if (a != b) {
     120:	2dff      	cmp	r5, #255	; 0xff
		TEST_INFO(message, "!=", a, b);
		return 1;
	}
	return 0;
     122:	f04f 0300 	mov.w	r3, #0
     126:	466a      	mov	r2, sp
     128:	4629      	mov	r1, r5
     12a:	f04f 00ff 	mov.w	r0, #255	; 0xff
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
	if (a != b) {
     12e:	d002      	beq.n	136 <packet_put_test()+0x5a>
     130:	f7ff ffa4 	bl	7c <int assert_eq<int>(int, int, String) [clone .part.1] [clone .constprop.6]>
     134:	4603      	mov	r3, r0
		outgoing_report.put(i, 0xFF);
	}	
	timer.mark(0);

	// check the test
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     136:	3401      	adds	r4, #1
		errors += assert_eq<int>(0xFF, outgoing_report.get(i), "failed packet insert");
     138:	4668      	mov	r0, sp
     13a:	441e      	.short	0x441e
     13c:	f002 f88a 	bl	2254 <String::~String()>
		outgoing_report.put(i, 0xFF);
	}	
	timer.mark(0);

	// check the test
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     140:	2c40      	cmp	r4, #64	; 0x40
     142:	d1e4      	bne.n	10e <packet_put_test()+0x32>
	}
	// byte* data[HID_REPORT_SIZE_BYTES];
	// outgoing_report.get(0, HID_REPORT_SIZE_BYTES, data);
	// return assert_eq()
	return errors;
}
     144:	4630      	mov	r0, r6
     146:	b004      	.short	0xb004
     148:	bd70      	pop	{r4, r5, r6, pc}
     14a:	bf00      	.short	0xbf00
     14c:	050c      	lsls	r4, r1, #20
     14e:	2000      	.short	0x2000
     150:	0c2c      	lsrs	r4, r5, #16
     152:	2000      	movs	r0, #0
     154:	20001bc4 	.word	0x20001bc4
     158:	1b38      	subs	r0, r7, r4
     15a:	2000      	.short	0x2000
     15c:	051c      	lsls	r4, r3, #20
     15e:	2000      	movs	r0, #0

00000160 <packet_get_test()>:

int packet_get_test() {
     160:	491fb5f0 	.word	0x491fb5f0
     164:	b095      	sub	sp, #84	; 0x54
	int errors = 0;
	Serial.printf("\nGET test:...\n");
     166:	481f      	.short	0x481f
	// insert semi-random values 
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     168:	2400      	movs	r4, #0
	return errors;
}

int packet_get_test() {
	int errors = 0;
	Serial.printf("\nGET test:...\n");
     16a:	f002      	.short	0xf002
     16c:	f851 f1c4 	ldr.w	pc, [r1, <undefined>]
	// insert semi-random values 
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
		outgoing_report.put(i, HID_REPORT_SIZE_BYTES - i);
     170:	46210240 	.word	0x46210240

int packet_get_test() {
	int errors = 0;
	Serial.printf("\nGET test:...\n");
	// insert semi-random values 
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     174:	3401      	adds	r4, #1
		outgoing_report.put(i, HID_REPORT_SIZE_BYTES - i);
     176:	481c      	.short	0x481c
     178:	b2d2      	uxtb	r2, r2
     17a:	f000      	.short	0xf000
     17c:	fad3 2c40 			; <UNDEFINED> instruction: 0xfad32c40

int packet_get_test() {
	int errors = 0;
	Serial.printf("\nGET test:...\n");
	// insert semi-random values 
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     180:	2400d1f5 	.word	0x2400d1f5
	}

	// execute the function
	int8_t tmp[64];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     184:	f10d 070f 	add.w	r7, sp, #15
		outgoing_report.put(i, HID_REPORT_SIZE_BYTES - i);
	}

	// execute the function
	int8_t tmp[64];
	timer.set(0);
     188:	46214818 	.word	0x46214818
     18c:	463d      	mov	r5, r7
     18e:	f000      	.short	0xf000
     190:	fb39 4621 			; <UNDEFINED> instruction: 0xfb394621
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     194:	48143401 	.word	0x48143401
		tmp[i] = outgoing_report.get(i);
     198:	f000 fac2 	bl	720 <HidReport::get(int)>
	}

	// execute the function
	int8_t tmp[64];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     19c:	f8052c40 	.word	0xf8052c40
		tmp[i] = outgoing_report.get(i);
     1a0:	0f01      	lsrs	r1, r0, #28
	}

	// execute the function
	int8_t tmp[64];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     1a2:	d1f6      	.short	0xd1f6
	// return assert_eq()
	return errors;
}

int packet_get_test() {
	int errors = 0;
     1a4:	2600      	movs	r6, #0
	int8_t tmp[64];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
		tmp[i] = outgoing_report.get(i);
	}
	timer.mark(0);
     1a6:	4811      	.short	0x4811
     1a8:	4631      	mov	r1, r6
     1aa:	f000      	.short	0xf000
     1ac:	fb35 f917 	smulwt	r9, r5, r7

	// check the output
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
		// Sum error of inserted values
		errors += assert_eq<int>(tmp[i], (HID_REPORT_SIZE_BYTES - i), "failed packet read");
     1b0:	46685f01 	.word	0x46685f01
     1b4:	490e      	ldr	r1, [pc, #56]	; (1f0 <packet_get_test()+0x90>)
     1b6:	f002      	.short	0xf002
     1b8:	f88d 42a5 	strb.w	r4, [sp, #677]	; 0x2a5
		TEST_INFO(message, "!=", a, b);
		return 1;
	}
	return 0;
     1bc:	f04f 0300 	mov.w	r3, #0
     1c0:	4621466a 	.word	0x4621466a
     1c4:	4628      	mov	r0, r5
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
	if (a != b) {
     1c6:	d002      	.short	0xd002
     1c8:	f7ff ff58 	bl	7c <int assert_eq<int>(int, int, String) [clone .part.1] [clone .constprop.6]>
     1cc:	4603      	mov	r3, r0
     1ce:	4668      	.short	0x4668
     1d0:	441e      	add	r6, r3
     1d2:	f002      	.short	0xf002
     1d4:	f83f 3c01 	ldrh.w	r3, [pc, #-3073]	; fffff5d7 <_flexram_bank_config+0x55554b2c>
		tmp[i] = outgoing_report.get(i);
	}
	timer.mark(0);

	// check the output
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     1d8:	4630d1e9 	.word	0x4630d1e9
		// Sum error of inserted values
		errors += assert_eq<int>(tmp[i], (HID_REPORT_SIZE_BYTES - i), "failed packet read");
	}

	return errors;
}
     1dc:	b015      	add	sp, #84	; 0x54
     1de:	bdf0      	.short	0xbdf0
     1e0:	0534      	lsls	r4, r6, #20
     1e2:	2000      	.short	0x2000
     1e4:	0c2c      	lsrs	r4, r5, #16
     1e6:	2000      	movs	r0, #0
     1e8:	20001b38 	.word	0x20001b38
     1ec:	1bc4      	subs	r4, r0, r7
     1ee:	2000      	.short	0x2000
     1f0:	0544      	lsls	r4, r0, #21
     1f2:	2000      	movs	r0, #0

000001f4 <packet_int32_test()>:

	// check the output
	return assert_eq<byte>(tmp1, tmp2, "Failed Puts-Gets", HID_REPORT_SIZE_BYTES);
}

int packet_int32_test() {
     1f4:	41f0e92d 	.word	0x41f0e92d
	Serial.printf("\nInt32 test:...\n");
	int32_t test_value = 913;
	// insert semi-random values 
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i += 4) {
     1f8:	2400      	movs	r4, #0
	// check the output
	return assert_eq<byte>(tmp1, tmp2, "Failed Puts-Gets", HID_REPORT_SIZE_BYTES);
}

int packet_int32_test() {
	Serial.printf("\nInt32 test:...\n");
     1fa:	4934      	.short	0x4934

	// check the output
	return assert_eq<byte>(tmp1, tmp2, "Failed Puts-Gets", HID_REPORT_SIZE_BYTES);
}

int packet_int32_test() {
     1fc:	b0a0      	sub	sp, #128	; 0x80
	Serial.printf("\nInt32 test:...\n");
     1fe:	4834      	.short	0x4834
     200:	f002 f806 	bl	2210 <Print::printf(char const*, ...)>
	int32_t test_value = 913;
	// insert semi-random values 
	timer.set(0);
     204:	48334621 	.word	0x48334621
     208:	f000 fafc 	bl	804 <FTYK::set(int)>
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i += 4) {
		outgoing_report.put_int32(i, test_value);
     20c:	34044621 	.word	0x34044621
     210:	f240 3291 	movw	r2, #913	; 0x391
     214:	f0004830 	.word	0xf0004830
     218:	fa97 2c40 			; <UNDEFINED> instruction: 0xfa972c40
int packet_int32_test() {
	Serial.printf("\nInt32 test:...\n");
	int32_t test_value = 913;
	// insert semi-random values 
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i += 4) {
     21c:	d1f6      	bne.n	20c <packet_int32_test()+0x18>
		outgoing_report.put_int32(i, test_value);
	}
	timer.mark(0);
     21e:	2100      	.short	0x2100
     220:	482c      	ldr	r0, [pc, #176]	; (2d4 <packet_int32_test()+0xe0>)
     222:	ad10      	.short	0xad10
     224:	f000 faf8 	bl	818 <FTYK::mark(int)>

	// check the values output from the function in question
	int tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
     228:	482a2100 	.word	0x482a2100
     22c:	ae20      	add	r6, sp, #128	; 0x80
     22e:	462c      	.short	0x462c
     230:	f000 fae8 	bl	804 <FTYK::set(int)>
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
		tmp[i] = outgoing_report.get_int32(4 * i);
     234:	48281b61 	.word	0x48281b61
     238:	f000 fa76 	bl	728 <HidReport::get_int32(int)>
     23c:	f844 0b04 	str.w	r0, [r4], #4
	timer.mark(0);

	// check the values output from the function in question
	int tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
     240:	42a6      	cmp	r6, r4
     242:	d1f7      	bne.n	234 <packet_int32_test()+0x40>
	}
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
     244:	2600      	movs	r6, #0
		tmp[i] = outgoing_report.get_int32(4 * i);
	}
	timer.mark(0);
     246:	4823      	ldr	r0, [pc, #140]	; (2d4 <packet_int32_test()+0xe0>)
     248:	af0f      	add	r7, sp, #60	; 0x3c
     24a:	4631      	mov	r1, r6
	for (int i = 0; i < n; i++) {
     24c:	4634      	mov	r4, r6
     24e:	f000 fae3 	bl	818 <FTYK::mark(int)>

	// check the output
	return assert_eq<int>(tmp, int(test_value), "Failed int32_t test", HID_REPORT_SIZE_BYTES / 4);
     252:	4668      	.short	0x4668
     254:	4921      	ldr	r1, [pc, #132]	; (2dc <packet_int32_test()+0xe8>)
     256:	f002      	.short	0xf002
     258:	f83d 4669 	ldrh.w	r4, [sp, <undefined>]
};

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
     25c:	f857a808 	.word	0xf857a808
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
     260:	5f04      	ldrsh	r4, [r0, r4]
     262:	f002 f84b 	bl	22fc <String::String(String const&)>
     266:	491e      	.short	0x491e
     268:	a808      	add	r0, sp, #32
     26a:	f002      	.short	0xf002
     26c:	f8b9 4680 	ldrh.w	r4, [r9, #1664]	; 0x680
     270:	4621220a 	.word	0x4621220a
     274:	a804      	add	r0, sp, #16
     276:	f002      	.short	0xf002
     278:	f85f a904 	ldr.w	sl, [pc, #-2308]	; fffff978 <_flexram_bank_config+0x55554ecd>
     27c:	f0024640 	.word	0xf0024640
     280:	f8a7 4918 	strh.w	r4, [r7, #2328]	; 0x918
     284:	f002 f8ac 	bl	23e0 <operator+(StringSumHelper const&, char const*)>
     288:	4601      	mov	r1, r0
     28a:	a80c      	add	r0, sp, #48	; 0x30
     28c:	f002 f836 	bl	22fc <String::String(String const&)>
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
	if (a != b) {
     290:	f240 3191 	movw	r1, #913	; 0x391
		TEST_INFO(message, "!=", a, b);
		return 1;
	}
	return 0;
     294:	2300      	movs	r3, #0
     296:	aa0c      	add	r2, sp, #48	; 0x30
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
	if (a != b) {
     298:	428d      	cmp	r5, r1
     29a:	4628      	mov	r0, r5
     29c:	d002      	beq.n	2a4 <packet_int32_test()+0xb0>
     29e:	f7ff feed 	bl	7c <int assert_eq<int>(int, int, String) [clone .part.1] [clone .constprop.6]>
     2a2:	4603      	mov	r3, r0
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
     2a4:	a80c      	add	r0, sp, #48	; 0x30
     2a6:	441e      	add	r6, r3
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     2a8:	3401      	adds	r4, #1
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
     2aa:	f001 ffd3 	bl	2254 <String::~String()>
     2ae:	a804      	add	r0, sp, #16
     2b0:	f001 ffd0 	bl	2254 <String::~String()>
	static const char zerotermination;
public:
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
};

class StringSumHelper : public String
     2b4:	a808      	add	r0, sp, #32
     2b6:	f001 ffcd 	bl	2254 <String::~String()>
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     2ba:	2c10      	cmp	r4, #16
     2bc:	d1cd      	bne.n	25a <packet_int32_test()+0x66>
     2be:	4668      	mov	r0, sp
     2c0:	f001 ffc8 	bl	2254 <String::~String()>
}
     2c4:	4630      	mov	r0, r6
     2c6:	b020      	add	sp, #128	; 0x80
     2c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     2cc:	20000558 	.word	0x20000558
     2d0:	20000c2c 	.word	0x20000c2c
     2d4:	20001bc4 	.word	0x20001bc4
     2d8:	20001b38 	.word	0x20001b38
     2dc:	2000056c 	.word	0x2000056c
     2e0:	20000580 	.word	0x20000580
     2e4:	20000584 	.word	0x20000584

000002e8 <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)>:
	return errors;
}

template <typename T> int assert_eq(T* a, T* b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     2e8:	2b00      	cmp	r3, #0
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
	}
	return errors;
}

template <typename T> int assert_eq(T* a, T* b, String message, int n) {
     2ea:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     2ee:	b091      	sub	sp, #68	; 0x44
	int errors = 0;
	for (int i = 0; i < n; i++) {
     2f0:	dd47      	ble.n	382 <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0x9a>
     2f2:	2400      	movs	r4, #0
     2f4:	469b      	mov	fp, r3
     2f6:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
     2fa:	1e4f      	subs	r7, r1, #1
     2fc:	46a1      	mov	r9, r4
     2fe:	9203      	str	r2, [sp, #12]
{
public:
	StringSumHelper(const String &s) : String(s) {}
     300:	9903      	ldr	r1, [sp, #12]
     302:	a804      	add	r0, sp, #16
		errors += assert_eq(a[i], b[i], message + " [" + String(i) + "]");
     304:	f818 5f01 	ldrb.w	r5, [r8, #1]!
     308:	f817 6f01 	ldrb.w	r6, [r7, #1]!
     30c:	f001 fff6 	bl	22fc <String::String(String const&)>
     310:	491d      	ldr	r1, [pc, #116]	; (388 <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0xa0>)
     312:	a804      	add	r0, sp, #16
     314:	f002 f864 	bl	23e0 <operator+(StringSumHelper const&, char const*)>
     318:	4682      	mov	sl, r0
     31a:	220a      	movs	r2, #10
     31c:	4621      	mov	r1, r4
     31e:	a808      	add	r0, sp, #32
     320:	f002 f80a 	bl	2338 <String::String(int, unsigned char)>
     324:	a908      	add	r1, sp, #32
     326:	4650      	mov	r0, sl
     328:	f002 f852 	bl	23d0 <operator+(StringSumHelper const&, String const&)>
     32c:	4917      	ldr	r1, [pc, #92]	; (38c <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0xa4>)
     32e:	f002 f857 	bl	23e0 <operator+(StringSumHelper const&, char const*)>
     332:	4601      	mov	r1, r0
     334:	a80c      	add	r0, sp, #48	; 0x30
     336:	f001 ffe1 	bl	22fc <String::String(String const&)>
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
	if (a != b) {
     33a:	42b5      	cmp	r5, r6
     33c:	f04f 010c 	mov.w	r1, #12
     340:	4813      	ldr	r0, [pc, #76]	; (390 <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0xa8>)
		TEST_INFO(message, "!=", a, b);
		return 1;
	}
	return 0;
     342:	f04f 0300 	mov.w	r3, #0
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
	if (a != b) {
     346:	d00b      	beq.n	360 <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0x78>
     348:	f001 febc 	bl	20c4 <usb_seremu_write>
		TEST_INFO(message, "!=", a, b);
     34c:	4a11      	ldr	r2, [pc, #68]	; (394 <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0xac>)
     34e:	462b      	mov	r3, r5
     350:	9601      	str	r6, [sp, #4]
     352:	9200      	str	r2, [sp, #0]
     354:	aa0c      	add	r2, sp, #48	; 0x30
     356:	4910      	ldr	r1, [pc, #64]	; (398 <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0xb0>)
     358:	4810      	ldr	r0, [pc, #64]	; (39c <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0xb4>)
     35a:	f001 ff59 	bl	2210 <Print::printf(char const*, ...)>
     35e:	2301      	movs	r3, #1
}

template <typename T> int assert_eq(T* a, T* b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
		errors += assert_eq(a[i], b[i], message + " [" + String(i) + "]");
     360:	a80c      	add	r0, sp, #48	; 0x30
     362:	4499      	add	r9, r3
	return errors;
}

template <typename T> int assert_eq(T* a, T* b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     364:	3401      	adds	r4, #1
		errors += assert_eq(a[i], b[i], message + " [" + String(i) + "]");
     366:	f001 ff75 	bl	2254 <String::~String()>
     36a:	a808      	add	r0, sp, #32
     36c:	f001 ff72 	bl	2254 <String::~String()>
	static const char zerotermination;
public:
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
};

class StringSumHelper : public String
     370:	a804      	add	r0, sp, #16
     372:	f001 ff6f 	bl	2254 <String::~String()>
	return errors;
}

template <typename T> int assert_eq(T* a, T* b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     376:	45a3      	cmp	fp, r4
     378:	d1c2      	bne.n	300 <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0x18>
		errors += assert_eq(a[i], b[i], message + " [" + String(i) + "]");
	}
	return errors;
}
     37a:	4648      	mov	r0, r9
     37c:	b011      	add	sp, #68	; 0x44
     37e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	return errors;
}

template <typename T> int assert_eq(T* a, T* b, String message, int n) {
	int errors = 0;
     382:	f04f 0900 	mov.w	r9, #0
     386:	e7f8      	b.n	37a <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)+0x92>
     388:	20000580 	.word	0x20000580
     38c:	20000584 	.word	0x20000584
     390:	200004bc 	.word	0x200004bc
     394:	200004dc 	.word	0x200004dc
     398:	200004cc 	.word	0x200004cc
     39c:	20000c2c 	.word	0x20000c2c

000003a0 <packet_puts_gets_test()>:
	}

	return errors;
}

int packet_puts_gets_test() {
     3a0:	b510      	push	{r4, lr}
     3a2:	b0a4      	sub	sp, #144	; 0x90
	Serial.printf("\nPUTS/GETS test:...\n");
     3a4:	491b      	ldr	r1, [pc, #108]	; (414 <packet_puts_gets_test()+0x74>)
     3a6:	481c      	ldr	r0, [pc, #112]	; (418 <packet_puts_gets_test()+0x78>)
     3a8:	2440      	movs	r4, #64	; 0x40
     3aa:	f001 ff31 	bl	2210 <Print::printf(char const*, ...)>
     3ae:	ab04      	add	r3, sp, #16
	// insert semi-random values 
	byte tmp1[HID_REPORT_SIZE_BYTES];
	for (size_t i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
		tmp1[i] = HID_REPORT_SIZE_BYTES - i;
     3b0:	f803 4b01 	strb.w	r4, [r3], #1

int packet_puts_gets_test() {
	Serial.printf("\nPUTS/GETS test:...\n");
	// insert semi-random values 
	byte tmp1[HID_REPORT_SIZE_BYTES];
	for (size_t i = 0; i < HID_REPORT_SIZE_BYTES; i++) {
     3b4:	3c01      	subs	r4, #1
     3b6:	d1fb      	bne.n	3b0 <packet_puts_gets_test()+0x10>
		tmp1[i] = HID_REPORT_SIZE_BYTES - i;
	}

	timer.set(0);
     3b8:	4621      	mov	r1, r4
     3ba:	4818      	ldr	r0, [pc, #96]	; (41c <packet_puts_gets_test()+0x7c>)
     3bc:	f000 fa22 	bl	804 <FTYK::set(int)>
	outgoing_report.rputs(tmp1, 0, HID_REPORT_SIZE_BYTES);
     3c0:	4622      	mov	r2, r4
     3c2:	2340      	movs	r3, #64	; 0x40
     3c4:	a904      	add	r1, sp, #16
     3c6:	4816      	ldr	r0, [pc, #88]	; (420 <packet_puts_gets_test()+0x80>)
     3c8:	f000 f9fc 	bl	7c4 <HidReport::rputs(unsigned char*, int, int)>
	timer.mark(0);
     3cc:	4621      	mov	r1, r4
     3ce:	4813      	ldr	r0, [pc, #76]	; (41c <packet_puts_gets_test()+0x7c>)
     3d0:	f000 fa22 	bl	818 <FTYK::mark(int)>

	// execute the function
	byte tmp2[HID_REPORT_SIZE_BYTES];
	timer.set(0);
     3d4:	4621      	mov	r1, r4
     3d6:	4811      	ldr	r0, [pc, #68]	; (41c <packet_puts_gets_test()+0x7c>)
     3d8:	f000 fa14 	bl	804 <FTYK::set(int)>
	outgoing_report.rgets(tmp2, 0, HID_REPORT_SIZE_BYTES);
     3dc:	4622      	mov	r2, r4
     3de:	2340      	movs	r3, #64	; 0x40
     3e0:	a914      	add	r1, sp, #80	; 0x50
     3e2:	480f      	ldr	r0, [pc, #60]	; (420 <packet_puts_gets_test()+0x80>)
     3e4:	f000 f9de 	bl	7a4 <HidReport::rgets(unsigned char*, int, int)>
	timer.mark(0);
     3e8:	4621      	mov	r1, r4
     3ea:	480c      	ldr	r0, [pc, #48]	; (41c <packet_puts_gets_test()+0x7c>)
     3ec:	f000 fa14 	bl	818 <FTYK::mark(int)>

	// check the output
	return assert_eq<byte>(tmp1, tmp2, "Failed Puts-Gets", HID_REPORT_SIZE_BYTES);
     3f0:	4668      	mov	r0, sp
     3f2:	490c      	ldr	r1, [pc, #48]	; (424 <packet_puts_gets_test()+0x84>)
     3f4:	f001 ff6e 	bl	22d4 <String::String(char const*)>
     3f8:	a914      	add	r1, sp, #80	; 0x50
     3fa:	466a      	mov	r2, sp
     3fc:	2340      	movs	r3, #64	; 0x40
     3fe:	a804      	add	r0, sp, #16
     400:	f7ff ff72 	bl	2e8 <int assert_eq<unsigned char>(unsigned char*, unsigned char*, String, int)>
     404:	4604      	mov	r4, r0
     406:	4668      	mov	r0, sp
     408:	f001 ff24 	bl	2254 <String::~String()>
}
     40c:	4620      	mov	r0, r4
     40e:	b024      	add	sp, #144	; 0x90
     410:	bd10      	pop	{r4, pc}
     412:	bf00      	nop
     414:	20000588 	.word	0x20000588
     418:	20000c2c 	.word	0x20000c2c
     41c:	20001bc4 	.word	0x20001bc4
     420:	20001b38 	.word	0x20001b38
     424:	200005a0 	.word	0x200005a0

00000428 <int assert_eq<float>(float*, float, String, int)>:
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     428:	2a00      	cmp	r2, #0
		return 1;
	}
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
     42a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     42e:	ed2d 8b02 	vpush	{d8}
     432:	b093      	sub	sp, #76	; 0x4c
	int errors = 0;
	for (int i = 0; i < n; i++) {
     434:	dd4a      	ble.n	4cc <int assert_eq<float>(float*, float, String, int)+0xa4>
     436:	2400      	movs	r4, #0
     438:	4690      	mov	r8, r2
     43a:	460f      	mov	r7, r1
     43c:	eef0 8a40 	vmov.f32	s17, s0
     440:	4605      	mov	r5, r0
     442:	4626      	mov	r6, r4
     444:	e00c      	b.n	460 <int assert_eq<float>(float*, float, String, int)+0x38>
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
     446:	a80e      	add	r0, sp, #56	; 0x38
     448:	441e      	add	r6, r3
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     44a:	3401      	adds	r4, #1
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
     44c:	f001 ff02 	bl	2254 <String::~String()>
     450:	a80a      	add	r0, sp, #40	; 0x28
     452:	f001 feff 	bl	2254 <String::~String()>
     456:	a806      	add	r0, sp, #24
     458:	f001 fefc 	bl	2254 <String::~String()>
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
	for (int i = 0; i < n; i++) {
     45c:	45a0      	cmp	r8, r4
     45e:	d036      	beq.n	4ce <int assert_eq<float>(float*, float, String, int)+0xa6>
{
public:
	StringSumHelper(const String &s) : String(s) {}
     460:	4639      	mov	r1, r7
     462:	a806      	add	r0, sp, #24
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
     464:	ecb5 8a01 	vldmia	r5!, {s16}
     468:	f001 ff48 	bl	22fc <String::String(String const&)>
     46c:	491b      	ldr	r1, [pc, #108]	; (4dc <int assert_eq<float>(float*, float, String, int)+0xb4>)
     46e:	a806      	add	r0, sp, #24
     470:	f001 ffb6 	bl	23e0 <operator+(StringSumHelper const&, char const*)>
     474:	4681      	mov	r9, r0
     476:	220a      	movs	r2, #10
     478:	4621      	mov	r1, r4
     47a:	a80a      	add	r0, sp, #40	; 0x28
     47c:	f001 ff5c 	bl	2338 <String::String(int, unsigned char)>
     480:	a90a      	add	r1, sp, #40	; 0x28
     482:	4648      	mov	r0, r9
     484:	f001 ffa4 	bl	23d0 <operator+(StringSumHelper const&, String const&)>
     488:	4915      	ldr	r1, [pc, #84]	; (4e0 <int assert_eq<float>(float*, float, String, int)+0xb8>)
     48a:	f001 ffa9 	bl	23e0 <operator+(StringSumHelper const&, char const*)>
     48e:	4601      	mov	r1, r0
     490:	a80e      	add	r0, sp, #56	; 0x38
     492:	f001 ff33 	bl	22fc <String::String(String const&)>
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
	if (a != b) {
     496:	eeb4 8a68 	vcmp.f32	s16, s17
		TEST_INFO(message, "!=", a, b);
		return 1;
	}
	return 0;
     49a:	2300      	movs	r3, #0
// int assert_not_nan(float*, String);

// void timer_print(uint32_t, String);

template <typename T> int assert_eq(T a, T b, String message) {
	if (a != b) {
     49c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     4a0:	d0d1      	beq.n	446 <int assert_eq<float>(float*, float, String, int)+0x1e>
     4a2:	210c      	movs	r1, #12
     4a4:	480f      	ldr	r0, [pc, #60]	; (4e4 <int assert_eq<float>(float*, float, String, int)+0xbc>)
     4a6:	f001 fe0d 	bl	20c4 <usb_seremu_write>
		TEST_INFO(message, "!=", a, b);
     4aa:	eeb7 6ae8 	vcvt.f64.f32	d6, s17
     4ae:	eeb7 7ac8 	vcvt.f64.f32	d7, s16
     4b2:	4b0d      	ldr	r3, [pc, #52]	; (4e8 <int assert_eq<float>(float*, float, String, int)+0xc0>)
     4b4:	aa0e      	add	r2, sp, #56	; 0x38
     4b6:	490d      	ldr	r1, [pc, #52]	; (4ec <int assert_eq<float>(float*, float, String, int)+0xc4>)
     4b8:	9302      	str	r3, [sp, #8]
     4ba:	480d      	ldr	r0, [pc, #52]	; (4f0 <int assert_eq<float>(float*, float, String, int)+0xc8>)
     4bc:	ed8d 6b04 	vstr	d6, [sp, #16]
     4c0:	ed8d 7b00 	vstr	d7, [sp]
     4c4:	f001 fea4 	bl	2210 <Print::printf(char const*, ...)>
     4c8:	2301      	movs	r3, #1
     4ca:	e7bc      	b.n	446 <int assert_eq<float>(float*, float, String, int)+0x1e>
	}
	return 0;
}

template <typename T> int assert_eq(T* a, T b, String message, int n) {
	int errors = 0;
     4cc:	2600      	movs	r6, #0
	for (int i = 0; i < n; i++) {
		errors += assert_eq(a[i], b, message + " [" + String(i) + "]");
	}
	return errors;
}
     4ce:	4630      	mov	r0, r6
     4d0:	b013      	add	sp, #76	; 0x4c
     4d2:	ecbd 8b02 	vpop	{d8}
     4d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     4da:	bf00      	nop
     4dc:	20000580 	.word	0x20000580
     4e0:	20000584 	.word	0x20000584
     4e4:	200004bc 	.word	0x200004bc
     4e8:	200004dc 	.word	0x200004dc
     4ec:	200004cc 	.word	0x200004cc
     4f0:	20000c2c 	.word	0x20000c2c

000004f4 <packet_float_test()>:
	// check the output
	return assert_eq<int>(tmp, int(test_value), "Failed int32_t test", HID_REPORT_SIZE_BYTES / 4);
}


int packet_float_test() {
     4f4:	b570      	push	{r4, r5, r6, lr}
	Serial.printf("\nFloat test:...\n");
	float test_value = 3.14159;

	// insert semi-random values 
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i += 4) {
     4f6:	2400      	movs	r4, #0
}


int packet_float_test() {
	// int errors = 0;
	Serial.printf("\nFloat test:...\n");
     4f8:	4930      	ldr	r1, [pc, #192]	; (5bc <packet_float_test()+0xc8>)
	// check the output
	return assert_eq<int>(tmp, int(test_value), "Failed int32_t test", HID_REPORT_SIZE_BYTES / 4);
}


int packet_float_test() {
     4fa:	b094      	sub	sp, #80	; 0x50
	// int errors = 0;
	Serial.printf("\nFloat test:...\n");
     4fc:	4830      	ldr	r0, [pc, #192]	; (5c0 <packet_float_test()+0xcc>)
     4fe:	f001 fe87 	bl	2210 <Print::printf(char const*, ...)>
	float test_value = 3.14159;

	// insert semi-random values 
	timer.set(0);
     502:	4621      	mov	r1, r4
     504:	482f      	ldr	r0, [pc, #188]	; (5c4 <packet_float_test()+0xd0>)
     506:	f000 f97d 	bl	804 <FTYK::set(int)>
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i += 4) {
		outgoing_report.put_float(i, test_value);
     50a:	4621      	mov	r1, r4
	Serial.printf("\nFloat test:...\n");
	float test_value = 3.14159;

	// insert semi-random values 
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i += 4) {
     50c:	3404      	adds	r4, #4
		outgoing_report.put_float(i, test_value);
     50e:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 5c8 <packet_float_test()+0xd4>
     512:	482e      	ldr	r0, [pc, #184]	; (5cc <packet_float_test()+0xd8>)
     514:	f000 f936 	bl	784 <HidReport::put_float(int, float)>
	Serial.printf("\nFloat test:...\n");
	float test_value = 3.14159;

	// insert semi-random values 
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES; i += 4) {
     518:	2c40      	cmp	r4, #64	; 0x40
     51a:	d1f6      	bne.n	50a <packet_float_test()+0x16>
		outgoing_report.put_float(i, test_value);
	}
	timer.mark(0);
     51c:	2100      	movs	r1, #0
     51e:	4829      	ldr	r0, [pc, #164]	; (5c4 <packet_float_test()+0xd0>)
     520:	f000 f97a 	bl	818 <FTYK::mark(int)>
	outgoing_report.print();
     524:	4829      	ldr	r0, [pc, #164]	; (5cc <packet_float_test()+0xd8>)
     526:	f000 f8a7 	bl	678 <HidReport::print()>

	// check the values output from the function in question
	float tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
     52a:	2100      	movs	r1, #0
     52c:	4825      	ldr	r0, [pc, #148]	; (5c4 <packet_float_test()+0xd0>)
     52e:	ad05      	add	r5, sp, #20
     530:	f000 f968 	bl	804 <FTYK::set(int)>
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
		tmp[i] = outgoing_report.get_float(4 * i);
     534:	2100      	movs	r1, #0
     536:	4825      	ldr	r0, [pc, #148]	; (5cc <packet_float_test()+0xd8>)
		Serial.printf("%f\t", tmp[i]);
		if ((i + 1) % 6 == 0 && i > 0) {
     538:	2401      	movs	r4, #1

	// check the values output from the function in question
	float tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
		tmp[i] = outgoing_report.get_float(4 * i);
     53a:	f000 f911 	bl	760 <HidReport::get_float(int)>
		Serial.printf("%f\t", tmp[i]);
     53e:	eeb7 7ac0 	vcvt.f64.f32	d7, s0
		if ((i + 1) % 6 == 0 && i > 0) {
     542:	4e23      	ldr	r6, [pc, #140]	; (5d0 <packet_float_test()+0xdc>)
	// check the values output from the function in question
	float tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
		tmp[i] = outgoing_report.get_float(4 * i);
		Serial.printf("%f\t", tmp[i]);
     544:	4923      	ldr	r1, [pc, #140]	; (5d4 <packet_float_test()+0xe0>)
     546:	481e      	ldr	r0, [pc, #120]	; (5c0 <packet_float_test()+0xcc>)

	// check the values output from the function in question
	float tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
		tmp[i] = outgoing_report.get_float(4 * i);
     548:	ed8d 0a04 	vstr	s0, [sp, #16]
		Serial.printf("%f\t", tmp[i]);
     54c:	ec53 2b17 	vmov	r2, r3, d7
     550:	f001 fe5e 	bl	2210 <Print::printf(char const*, ...)>

	// check the values output from the function in question
	float tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
		tmp[i] = outgoing_report.get_float(4 * i);
     554:	00a1      	lsls	r1, r4, #2
     556:	481d      	ldr	r0, [pc, #116]	; (5cc <packet_float_test()+0xd8>)
     558:	f000 f902 	bl	760 <HidReport::get_float(int)>
		Serial.printf("%f\t", tmp[i]);
     55c:	eeb7 7ac0 	vcvt.f64.f32	d7, s0
		if ((i + 1) % 6 == 0 && i > 0) {
     560:	3401      	adds	r4, #1
	// check the values output from the function in question
	float tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
		tmp[i] = outgoing_report.get_float(4 * i);
		Serial.printf("%f\t", tmp[i]);
     562:	491c      	ldr	r1, [pc, #112]	; (5d4 <packet_float_test()+0xe0>)
     564:	4816      	ldr	r0, [pc, #88]	; (5c0 <packet_float_test()+0xcc>)

	// check the values output from the function in question
	float tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
		tmp[i] = outgoing_report.get_float(4 * i);
     566:	eca5 0a01 	vstmia	r5!, {s0}
		Serial.printf("%f\t", tmp[i]);
     56a:	ec53 2b17 	vmov	r2, r3, d7
     56e:	f001 fe4f 	bl	2210 <Print::printf(char const*, ...)>
		if ((i + 1) % 6 == 0 && i > 0) {
     572:	fb86 2304 	smull	r2, r3, r6, r4
			Serial.println();
     576:	4812      	ldr	r0, [pc, #72]	; (5c0 <packet_float_test()+0xcc>)
	float tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
		tmp[i] = outgoing_report.get_float(4 * i);
		Serial.printf("%f\t", tmp[i]);
		if ((i + 1) % 6 == 0 && i > 0) {
     578:	eba3 73e4 	sub.w	r3, r3, r4, asr #31
     57c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
     580:	ebb4 0f43 	cmp.w	r4, r3, lsl #1
     584:	d101      	bne.n	58a <packet_float_test()+0x96>
			Serial.println();
     586:	f001 fe2b 	bl	21e0 <Print::println()>
	outgoing_report.print();

	// check the values output from the function in question
	float tmp[HID_REPORT_SIZE_BYTES / 4];
	timer.set(0);
	for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
     58a:	2c10      	cmp	r4, #16
     58c:	d1e2      	bne.n	554 <packet_float_test()+0x60>
		Serial.printf("%f\t", tmp[i]);
		if ((i + 1) % 6 == 0 && i > 0) {
			Serial.println();
		} 
	}
	timer.mark(0);
     58e:	2100      	movs	r1, #0
     590:	480c      	ldr	r0, [pc, #48]	; (5c4 <packet_float_test()+0xd0>)
     592:	f000 f941 	bl	818 <FTYK::mark(int)>
	// for (int i = 0; i < HID_REPORT_SIZE_BYTES / 4; i++) {
	// 	// Sum error of inserted values
	// 	errors += assert_eq<float>(tmp[i], test_value, "Failed float test");
	// }

	return assert_eq<float>(tmp, test_value, "Failed float test", HID_REPORT_SIZE_BYTES / 4);
     596:	4668      	mov	r0, sp
     598:	490f      	ldr	r1, [pc, #60]	; (5d8 <packet_float_test()+0xe4>)
     59a:	f001 fe9b 	bl	22d4 <String::String(char const*)>
     59e:	4622      	mov	r2, r4
     5a0:	4669      	mov	r1, sp
     5a2:	ed9f 0a09 	vldr	s0, [pc, #36]	; 5c8 <packet_float_test()+0xd4>
     5a6:	a804      	add	r0, sp, #16
     5a8:	f7ff ff3e 	bl	428 <int assert_eq<float>(float*, float, String, int)>
     5ac:	4604      	mov	r4, r0
     5ae:	4668      	mov	r0, sp
     5b0:	f001 fe50 	bl	2254 <String::~String()>
}
     5b4:	4620      	mov	r0, r4
     5b6:	b014      	add	sp, #80	; 0x50
     5b8:	bd70      	pop	{r4, r5, r6, pc}
     5ba:	bf00      	nop
     5bc:	200005b4 	.word	0x200005b4
     5c0:	20000c2c 	.word	0x20000c2c
     5c4:	20001bc4 	.word	0x20001bc4
     5c8:	40490fd0 	.word	0x40490fd0
     5cc:	20001b38 	.word	0x20001b38
     5d0:	2aaaaaab 	.word	0x2aaaaaab
     5d4:	200005c8 	.word	0x200005c8
     5d8:	200005cc 	.word	0x200005cc

000005dc <run_hid_report_tests()>:

int run_hid_report_tests(void) {
     5dc:	b510      	push	{r4, lr}

	int errors = 0;
	errors += packet_put_test();
     5de:	f7ff fd7d 	bl	dc <packet_put_test()>
     5e2:	4604      	mov	r4, r0
	errors += packet_get_test();
     5e4:	f7ff fdbc 	bl	160 <packet_get_test()>
     5e8:	4404      	add	r4, r0
	errors += packet_puts_gets_test();
     5ea:	f7ff fed9 	bl	3a0 <packet_puts_gets_test()>
     5ee:	4404      	add	r4, r0
	errors += packet_int32_test();
     5f0:	f7ff fe00 	bl	1f4 <packet_int32_test()>
     5f4:	4404      	add	r4, r0
	errors += packet_float_test();
     5f6:	f7ff ff7d 	bl	4f4 <packet_float_test()>

	return errors;
}
     5fa:	4420      	add	r0, r4
     5fc:	bd10      	pop	{r4, pc}
     5fe:	bf00      	nop

00000600 <main>:


// Runs once
int main() {
     600:	b538      	push	{r3, r4, r5, lr}
     602:	4c0e      	ldr	r4, [pc, #56]	; (63c <main+0x3c>)
     604:	4d0e      	ldr	r5, [pc, #56]	; (640 <main+0x40>)
        uint8_t stopbits(void) { return 1; }
        uint8_t paritytype(void) { return 0; }
        uint8_t numbits(void) { return 8; }
        uint8_t dtr(void) { return 1; }
        uint8_t rts(void) { return 1; }
        operator bool() { yield(); return usb_configuration && usb_seremu_online; }
     606:	f001 ff0d 	bl	2424 <yield>
     60a:	7823      	ldrb	r3, [r4, #0]
     60c:	2b00      	cmp	r3, #0
     60e:	d0fa      	beq.n	606 <main+0x6>
     610:	782b      	ldrb	r3, [r5, #0]
     612:	2b00      	cmp	r3, #0
     614:	d0f7      	beq.n	606 <main+0x6>

	// if (Serial)
	// Serial.println("-- TEENSY SERIAL START --");

	while (!Serial) {};
	Serial.println("Start comms tests");
     616:	490b      	ldr	r1, [pc, #44]	; (644 <main+0x44>)
     618:	480b      	ldr	r0, [pc, #44]	; (648 <main+0x48>)
     61a:	f7ff fd4d 	bl	b8 <Print::println(char const*)>

	int errors = run_hid_report_tests();
     61e:	f7ff ffdd 	bl	5dc <run_hid_report_tests()>
     622:	4604      	mov	r4, r0

	Serial.println("Finished tests");
     624:	4909      	ldr	r1, [pc, #36]	; (64c <main+0x4c>)
     626:	4808      	ldr	r0, [pc, #32]	; (648 <main+0x48>)
     628:	f7ff fd46 	bl	b8 <Print::println(char const*)>
	Serial.printf("%i failed\n", errors);
     62c:	4622      	mov	r2, r4
     62e:	4908      	ldr	r1, [pc, #32]	; (650 <main+0x50>)
     630:	4805      	ldr	r0, [pc, #20]	; (648 <main+0x48>)
     632:	f001 fded 	bl	2210 <Print::printf(char const*, ...)>

	return 0;
}
     636:	2000      	movs	r0, #0
     638:	bd38      	pop	{r3, r4, r5, pc}
     63a:	bf00      	nop
     63c:	20001c04 	.word	0x20001c04
     640:	20001c07 	.word	0x20001c07
     644:	200005e0 	.word	0x200005e0
     648:	20000c2c 	.word	0x20000c2c
     64c:	200005f4 	.word	0x200005f4
     650:	20000604 	.word	0x20000604

00000654 <_GLOBAL__sub_I__Z14assert_not_nanf>:
     654:	b508      	push	{r3, lr}
#include "utilities/timing.h"
#include "utilities/assertions.h"
#include "robot_comms/hid_report.h"


HidReport outgoing_report;
     656:	4805      	ldr	r0, [pc, #20]	; (66c <_GLOBAL__sub_I__Z14assert_not_nanf+0x18>)
     658:	f000 f858 	bl	70c <HidReport::HidReport()>
HidReport incoming_report;
     65c:	4804      	ldr	r0, [pc, #16]	; (670 <_GLOBAL__sub_I__Z14assert_not_nanf+0x1c>)
     65e:	f000 f855 	bl	70c <HidReport::HidReport()>

FTYK timer;
     662:	4804      	ldr	r0, [pc, #16]	; (674 <_GLOBAL__sub_I__Z14assert_not_nanf+0x20>)

	Serial.println("Finished tests");
	Serial.printf("%i failed\n", errors);

	return 0;
}
     664:	e8bd 4008 	ldmia.w	sp!, {r3, lr}


HidReport outgoing_report;
HidReport incoming_report;

FTYK timer;
     668:	f000 b8bc 	b.w	7e4 <FTYK::FTYK()>
     66c:	20001b38 	.word	0x20001b38
     670:	20001af8 	.word	0x20001af8
     674:	20001bc4 	.word	0x20001bc4

00000678 <HidReport::print()>:
#include "hid_report.h"

void HidReport::print(){
     678:	b5f0      	push	{r4, r5, r6, r7, lr}
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
     67a:	2107      	movs	r1, #7
     67c:	4607      	mov	r7, r0
     67e:	b091      	sub	sp, #68	; 0x44
     680:	481f      	ldr	r0, [pc, #124]	; (700 <HidReport::print()+0x88>)
     682:	f001 fd1f 	bl	20c4 <usb_seremu_write>
     686:	481f      	ldr	r0, [pc, #124]	; (704 <HidReport::print()+0x8c>)
	/*
		  Display function for HID packets
	*/
	Serial.println("\n\t=====");
	for (int i = 0; i < HID_REPORT_SIZE_BYTES - 15; i += 16){
     688:	2500      	movs	r5, #0
     68a:	463c      	mov	r4, r7
     68c:	f001 fda8 	bl	21e0 <Print::println()>
		Serial.printf("\t[%d]\t\t%X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X\n", 
						i,
						data[i], data[i+1], data[i+2], data[i+3],
						data[i+4], data[i+5], data[i+6], data[i+7], 
						data[i+8], data[i+9], data[i+10], data[i+11],
						data[i+12], data[i+13], data[i+14], data[i+15]);
     690:	7be1      	ldrb	r1, [r4, #15]
     692:	462a      	mov	r2, r5
     694:	5d7b      	ldrb	r3, [r7, r5]
void HidReport::print(){
	/*
		  Display function for HID packets
	*/
	Serial.println("\n\t=====");
	for (int i = 0; i < HID_REPORT_SIZE_BYTES - 15; i += 16){
     696:	3510      	adds	r5, #16
		Serial.printf("\t[%d]\t\t%X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X, %X\n", 
						i,
						data[i], data[i+1], data[i+2], data[i+3],
						data[i+4], data[i+5], data[i+6], data[i+7], 
						data[i+8], data[i+9], data[i+10], data[i+11],
						data[i+12], data[i+13], data[i+14], data[i+15]);
     698:	910e      	str	r1, [sp, #56]	; 0x38
     69a:	3410      	adds	r4, #16
     69c:	f814 0c02 	ldrb.w	r0, [r4, #-2]
     6a0:	4919      	ldr	r1, [pc, #100]	; (708 <HidReport::print()+0x90>)
     6a2:	900d      	str	r0, [sp, #52]	; 0x34
     6a4:	f814 6c03 	ldrb.w	r6, [r4, #-3]
     6a8:	4816      	ldr	r0, [pc, #88]	; (704 <HidReport::print()+0x8c>)
     6aa:	960c      	str	r6, [sp, #48]	; 0x30
     6ac:	f814 6c04 	ldrb.w	r6, [r4, #-4]
     6b0:	960b      	str	r6, [sp, #44]	; 0x2c
     6b2:	f814 6c05 	ldrb.w	r6, [r4, #-5]
     6b6:	960a      	str	r6, [sp, #40]	; 0x28
     6b8:	f814 6c06 	ldrb.w	r6, [r4, #-6]
     6bc:	9609      	str	r6, [sp, #36]	; 0x24
     6be:	f814 6c07 	ldrb.w	r6, [r4, #-7]
     6c2:	9608      	str	r6, [sp, #32]
     6c4:	f814 6c08 	ldrb.w	r6, [r4, #-8]
     6c8:	9607      	str	r6, [sp, #28]
     6ca:	f814 6c09 	ldrb.w	r6, [r4, #-9]
     6ce:	9606      	str	r6, [sp, #24]
     6d0:	f814 6c0a 	ldrb.w	r6, [r4, #-10]
     6d4:	9605      	str	r6, [sp, #20]
     6d6:	f814 6c0b 	ldrb.w	r6, [r4, #-11]
     6da:	9604      	str	r6, [sp, #16]
     6dc:	f814 6c0c 	ldrb.w	r6, [r4, #-12]
     6e0:	9603      	str	r6, [sp, #12]
     6e2:	f814 6c0d 	ldrb.w	r6, [r4, #-13]
     6e6:	9602      	str	r6, [sp, #8]
     6e8:	f814 6c0e 	ldrb.w	r6, [r4, #-14]
     6ec:	9601      	str	r6, [sp, #4]
     6ee:	f814 6c0f 	ldrb.w	r6, [r4, #-15]
     6f2:	9600      	str	r6, [sp, #0]
     6f4:	f001 fd8c 	bl	2210 <Print::printf(char const*, ...)>
void HidReport::print(){
	/*
		  Display function for HID packets
	*/
	Serial.println("\n\t=====");
	for (int i = 0; i < HID_REPORT_SIZE_BYTES - 15; i += 16){
     6f8:	2d40      	cmp	r5, #64	; 0x40
     6fa:	d1c9      	bne.n	690 <HidReport::print()+0x18>
						data[i], data[i+1], data[i+2], data[i+3],
						data[i+4], data[i+5], data[i+6], data[i+7], 
						data[i+8], data[i+9], data[i+10], data[i+11],
						data[i+12], data[i+13], data[i+14], data[i+15]);
	}
}
     6fc:	b011      	add	sp, #68	; 0x44
     6fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
     700:	20000610 	.word	0x20000610
     704:	20000c2c 	.word	0x20000c2c
     708:	20000618 	.word	0x20000618

0000070c <HidReport::HidReport()>:

HidReport::HidReport() {
     70c:	b510      	push	{r4, lr}

void HidReport::clear(){
	/*
		  Clear the HID packet (set all indices = 0)
	*/
	memset(data, 0, HID_REPORT_SIZE_BYTES);
     70e:	2240      	movs	r2, #64	; 0x40
     710:	2100      	movs	r1, #0
						data[i+8], data[i+9], data[i+10], data[i+11],
						data[i+12], data[i+13], data[i+14], data[i+15]);
	}
}

HidReport::HidReport() {
     712:	4604      	mov	r4, r0

void HidReport::clear(){
	/*
		  Clear the HID packet (set all indices = 0)
	*/
	memset(data, 0, HID_REPORT_SIZE_BYTES);
     714:	f002 fcba 	bl	308c <memset>
		  Set the byte at packet[idx]
		@param:
			idx: index of the byte to set
			value: the byte to write
	*/
	data[idx] = value;
     718:	23ff      	movs	r3, #255	; 0xff
}

HidReport::HidReport() {
	clear();
	put(0, 255);
}
     71a:	4620      	mov	r0, r4
		  Set the byte at packet[idx]
		@param:
			idx: index of the byte to set
			value: the byte to write
	*/
	data[idx] = value;
     71c:	7023      	strb	r3, [r4, #0]
}

HidReport::HidReport() {
	clear();
	put(0, 255);
}
     71e:	bd10      	pop	{r4, pc}

00000720 <HidReport::get(int)>:
			idx: index of byte to read
		@return:
			byte: requested byte
	*/
	return data[idx];
}
     720:	5c40      	ldrb	r0, [r0, r1]
     722:	4770      	bx	lr

00000724 <HidReport::put(int, unsigned char)>:
		  Set the byte at packet[idx]
		@param:
			idx: index of the byte to set
			value: the byte to write
	*/
	data[idx] = value;
     724:	5442      	strb	r2, [r0, r1]
     726:	4770      	bx	lr

00000728 <HidReport::get_int32(int)>:
	for (int i = 0; i < n; i++) {
		data[i + idx] = arr[i];
	}
}

int32_t HidReport::get_int32(int idx){
     728:	b410      	push	{r4}
			int32_t: requested data
	*/
	return  (int32_t(data[idx]) << 24) | 
				(int32_t(data[idx+1]) << 16) | 
				(int32_t(data[idx+2]) << 8) | 
				 int32_t(data[idx+3]);
     72a:	1844      	adds	r4, r0, r1
     72c:	5c43      	ldrb	r3, [r0, r1]
     72e:	78e2      	ldrb	r2, [r4, #3]
     730:	7861      	ldrb	r1, [r4, #1]
     732:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
     736:	78a0      	ldrb	r0, [r4, #2]
}
     738:	f85d 4b04 	ldr.w	r4, [sp], #4
			int32_t: requested data
	*/
	return  (int32_t(data[idx]) << 24) | 
				(int32_t(data[idx+1]) << 16) | 
				(int32_t(data[idx+2]) << 8) | 
				 int32_t(data[idx+3]);
     73c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
}
     740:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
     744:	4770      	bx	lr
     746:	bf00      	nop

00000748 <HidReport::put_int32(int, long)>:

void HidReport::put_int32(int idx, int32_t value){
     748:	b470      	push	{r4, r5, r6}
		@param:
			idx: index of the data to write to
			value: the value to write
	*/
	data[idx]   = byte(value >> 24);
	data[idx+1] = byte(value >> 16);
     74a:	1843      	adds	r3, r0, r1
		  Set the int32_t at packet[idx]
		@param:
			idx: index of the data to write to
			value: the value to write
	*/
	data[idx]   = byte(value >> 24);
     74c:	1616      	asrs	r6, r2, #24
	data[idx+1] = byte(value >> 16);
     74e:	1415      	asrs	r5, r2, #16
	data[idx+2] = byte(value >> 8);
     750:	1214      	asrs	r4, r2, #8
		  Set the int32_t at packet[idx]
		@param:
			idx: index of the data to write to
			value: the value to write
	*/
	data[idx]   = byte(value >> 24);
     752:	5446      	strb	r6, [r0, r1]
	data[idx+1] = byte(value >> 16);
	data[idx+2] = byte(value >> 8);
	data[idx+3] = byte(value);
     754:	70da      	strb	r2, [r3, #3]
		@param:
			idx: index of the data to write to
			value: the value to write
	*/
	data[idx]   = byte(value >> 24);
	data[idx+1] = byte(value >> 16);
     756:	705d      	strb	r5, [r3, #1]
	data[idx+2] = byte(value >> 8);
     758:	709c      	strb	r4, [r3, #2]
	data[idx+3] = byte(value);
}
     75a:	bc70      	pop	{r4, r5, r6}
     75c:	4770      	bx	lr
     75e:	bf00      	nop

00000760 <HidReport::get_float(int)>:
			idx: the index to start reading the float from
		@return:
			float: requested data
	*/
	FLOATBYTE_t fb_union;
	fb_union.bytes[3] = data[idx];
     760:	5c42      	ldrb	r2, [r0, r1]
     762:	2300      	movs	r3, #0
	fb_union.bytes[2] = data[idx+1];
     764:	4401      	add	r1, r0
			idx: the index to start reading the float from
		@return:
			float: requested data
	*/
	FLOATBYTE_t fb_union;
	fb_union.bytes[3] = data[idx];
     766:	f362 631f 	bfi	r3, r2, #24, #8
	fb_union.bytes[2] = data[idx+1];
     76a:	784a      	ldrb	r2, [r1, #1]
	fb_union.bytes[1] = data[idx+2];
     76c:	7888      	ldrb	r0, [r1, #2]
		@return:
			float: requested data
	*/
	FLOATBYTE_t fb_union;
	fb_union.bytes[3] = data[idx];
	fb_union.bytes[2] = data[idx+1];
     76e:	f362 4317 	bfi	r3, r2, #16, #8
	fb_union.bytes[1] = data[idx+2];
	fb_union.bytes[0] = data[idx+3];
     772:	78ca      	ldrb	r2, [r1, #3]
			float: requested data
	*/
	FLOATBYTE_t fb_union;
	fb_union.bytes[3] = data[idx];
	fb_union.bytes[2] = data[idx+1];
	fb_union.bytes[1] = data[idx+2];
     774:	f360 230f 	bfi	r3, r0, #8, #8
	fb_union.bytes[0] = data[idx+3];
     778:	f362 0307 	bfi	r3, r2, #0, #8

	return fb_union.number;
     77c:	ee00 3a10 	vmov	s0, r3
}
     780:	4770      	bx	lr
     782:	bf00      	nop

00000784 <HidReport::put_float(int, float)>:
		@param:
			idx: index to insert at
			value: the float value to insert
	*/
	FLOATBYTE_t fb_union;
	fb_union.number = value;
     784:	ee10 3a10 	vmov	r3, s0
	data[idx]   = fb_union.bytes[3];
	data[idx+1] = fb_union.bytes[2];
     788:	1842      	adds	r2, r0, r1
	fb_union.bytes[0] = data[idx+3];

	return fb_union.number;
}

void HidReport::put_float(int idx, float value){
     78a:	b470      	push	{r4, r5, r6}
			idx: index to insert at
			value: the float value to insert
	*/
	FLOATBYTE_t fb_union;
	fb_union.number = value;
	data[idx]   = fb_union.bytes[3];
     78c:	f3c3 6607 	ubfx	r6, r3, #24, #8
	data[idx+1] = fb_union.bytes[2];
     790:	f3c3 4507 	ubfx	r5, r3, #16, #8
	data[idx+2] = fb_union.bytes[1];
     794:	f3c3 2407 	ubfx	r4, r3, #8, #8
			idx: index to insert at
			value: the float value to insert
	*/
	FLOATBYTE_t fb_union;
	fb_union.number = value;
	data[idx]   = fb_union.bytes[3];
     798:	5446      	strb	r6, [r0, r1]
	data[idx+1] = fb_union.bytes[2];
	data[idx+2] = fb_union.bytes[1];
	data[idx+3] = fb_union.bytes[0];
     79a:	70d3      	strb	r3, [r2, #3]
			value: the float value to insert
	*/
	FLOATBYTE_t fb_union;
	fb_union.number = value;
	data[idx]   = fb_union.bytes[3];
	data[idx+1] = fb_union.bytes[2];
     79c:	7055      	strb	r5, [r2, #1]
	data[idx+2] = fb_union.bytes[1];
     79e:	7094      	strb	r4, [r2, #2]
	data[idx+3] = fb_union.bytes[0];
}
     7a0:	bc70      	pop	{r4, r5, r6}
     7a2:	4770      	bx	lr

000007a4 <HidReport::rgets(unsigned char*, int, int)>:
	for (size_t i = 0; i < strlen(value); i++) {
		data[idx + i] = value[i];
	}
}

void HidReport::rgets(byte* out_data, int offset, int bytes){
     7a4:	b430      	push	{r4, r5}
     7a6:	18d4      	adds	r4, r2, r3
     7a8:	4419      	add	r1, r3
     7aa:	4404      	add	r4, r0
     7ac:	1aa3      	subs	r3, r4, r2
		@param:
			out_data: a byte buffer to fill with data
			offset: the index to begin reading from
			bytes: the number of bytes to get
	*/
	out_data[bytes - 1] = data[offset + (bytes - 1)];
     7ae:	f814 5c01 	ldrb.w	r5, [r4, #-1]
     7b2:	3c01      	subs	r4, #1
     7b4:	1a1b      	subs	r3, r3, r0
     7b6:	f801 5d01 	strb.w	r5, [r1, #-1]!

	if (bytes > 1) {
     7ba:	2b01      	cmp	r3, #1
     7bc:	dcf6      	bgt.n	7ac <HidReport::rgets(unsigned char*, int, int)+0x8>
		rgets(out_data, offset, bytes - 1);
	}
}
     7be:	bc30      	pop	{r4, r5}
     7c0:	4770      	bx	lr
     7c2:	bf00      	nop

000007c4 <HidReport::rputs(unsigned char*, int, int)>:

void HidReport::rputs(byte* in_data, int offset, int bytes){
     7c4:	441a      	add	r2, r3
     7c6:	440b      	add	r3, r1
     7c8:	4410      	add	r0, r2
     7ca:	b410      	push	{r4}
     7cc:	1a5a      	subs	r2, r3, r1
		@param:
			in_data: a byte buffer to copy data from
			offset: the index to begin writing at
			bytes: the number of bytes to write
	*/
	data[offset + (bytes - 1)] = in_data[bytes - 1];
     7ce:	f813 4c01 	ldrb.w	r4, [r3, #-1]

	if (bytes > 1) {
     7d2:	3b01      	subs	r3, #1
     7d4:	2a01      	cmp	r2, #1
		@param:
			in_data: a byte buffer to copy data from
			offset: the index to begin writing at
			bytes: the number of bytes to write
	*/
	data[offset + (bytes - 1)] = in_data[bytes - 1];
     7d6:	f800 4d01 	strb.w	r4, [r0, #-1]!

	if (bytes > 1) {
     7da:	dcf7      	bgt.n	7cc <HidReport::rputs(unsigned char*, int, int)+0x8>
		rputs(in_data, offset, bytes - 1);
	}
}
     7dc:	f85d 4b04 	ldr.w	r4, [sp], #4
     7e0:	4770      	bx	lr
     7e2:	bf00      	nop

000007e4 <FTYK::FTYK()>:
	uint32_t delta_ns = CYCLES_2_NS(delta_cycles); 
	Serial.printf( "\t%1lu cycles, %1lu ns\n", delta_cycles, delta_ns);
	return delta_ns;
}

FTYK::FTYK() {
     7e4:	b410      	push	{r4}
     7e6:	1f03      	subs	r3, r0, #4
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
		timers[i] = ARM_DWT_CYCCNT;
     7e8:	4c05      	ldr	r4, [pc, #20]	; (800 <FTYK::FTYK()+0x1c>)
     7ea:	f100 0124 	add.w	r1, r0, #36	; 0x24
     7ee:	6822      	ldr	r2, [r4, #0]
     7f0:	f843 2f04 	str.w	r2, [r3, #4]!
			- add rollover support: ARM_DWT_CYCCNT is a cycle count that resets every 8
			seconds or so, use a member variable to track the number of roll overs.
			This will be dependant on the timer being able to check those rollovers, so
			it will need to be called often (maybe sysgraph needs a timer case check).
	*/
	for (size_t i = 0; i < MAX_NUM_TIMERS; i++) {
     7f4:	428b      	cmp	r3, r1
     7f6:	d1fa      	bne.n	7ee <FTYK::FTYK()+0xa>
		timers[i] = ARM_DWT_CYCCNT;
	}
}
     7f8:	f85d 4b04 	ldr.w	r4, [sp], #4
     7fc:	4770      	bx	lr
     7fe:	bf00      	nop
     800:	e0001004 	.word	0xe0001004

00000804 <FTYK::set(int)>:
	/*
		  Set the timer at idx to the current cycle count.
		@param:
			idx: (int) index of the timer to set.
	*/
	timers[idx] = ARM_DWT_CYCCNT;
     804:	4b02      	ldr	r3, [pc, #8]	; (810 <FTYK::set(int)+0xc>)
     806:	681b      	ldr	r3, [r3, #0]
     808:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
     80c:	4770      	bx	lr
     80e:	bf00      	nop
     810:	e0001004 	.word	0xe0001004
     814:	00000000 	.word	0x00000000

00000818 <FTYK::mark(int)>:
	/*
		  Print info about the timer at idx.
		@param:
			idx: (int) index of the timer to print info about.
	*/
	duration_info(timers[idx], ARM_DWT_CYCCNT);
     818:	4b0d      	ldr	r3, [pc, #52]	; (850 <FTYK::mark(int)+0x38>)
			start: (uint32_t) value of ARM_DWT_CYCCNT at the beginning of a duration
			stop: (uint32_t) value of ARM_DWT_CYCNT at the end of a duration
		@return
			delta_ns: (uint32_t) duration in nanoseconds
	*/
	uint32_t delta_cycles = stop - start;
     81a:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
	/*
		  Print info about the timer at idx.
		@param:
			idx: (int) index of the timer to print info about.
	*/
	duration_info(timers[idx], ARM_DWT_CYCCNT);
     81e:	681b      	ldr	r3, [r3, #0]
		@return
			delta_ns: (uint32_t) duration in nanoseconds
	*/
	uint32_t delta_cycles = stop - start;
	uint32_t delta_ns = CYCLES_2_NS(delta_cycles); 
	Serial.printf( "\t%1lu cycles, %1lu ns\n", delta_cycles, delta_ns);
     820:	490c      	ldr	r1, [pc, #48]	; (854 <FTYK::mark(int)+0x3c>)
			start: (uint32_t) value of ARM_DWT_CYCCNT at the beginning of a duration
			stop: (uint32_t) value of ARM_DWT_CYCNT at the end of a duration
		@return
			delta_ns: (uint32_t) duration in nanoseconds
	*/
	uint32_t delta_cycles = stop - start;
     822:	1a9a      	subs	r2, r3, r2
	uint32_t delta_ns = CYCLES_2_NS(delta_cycles); 
	Serial.printf( "\t%1lu cycles, %1lu ns\n", delta_cycles, delta_ns);
     824:	480c      	ldr	r0, [pc, #48]	; (858 <FTYK::mark(int)+0x40>)
     826:	ee07 2a90 	vmov	s15, r2
     82a:	ed9f 6b07 	vldr	d6, [pc, #28]	; 848 <FTYK::mark(int)+0x30>
     82e:	eeb8 7b67 	vcvt.f64.u32	d7, s15
     832:	ee27 7b06 	vmul.f64	d7, d7, d6
     836:	eefc 7bc7 	vcvt.u32.f64	s15, d7
     83a:	ee17 3a90 	vmov	r3, s15
     83e:	f001 bce7 	b.w	2210 <Print::printf(char const*, ...)>
     842:	bf00      	nop
     844:	f3af 8000 	nop.w
     848:	aaaaaaab 	.word	0xaaaaaaab
     84c:	3ffaaaaa 	.word	0x3ffaaaaa
     850:	e0001004 	.word	0xe0001004
     854:	20000660 	.word	0x20000660
     858:	20000c2c 	.word	0x20000c2c

0000085c <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
     85c:	4a96      	ldr	r2, [pc, #600]	; (ab8 <set_arm_clock+0x25c>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
     85e:	4b97      	ldr	r3, [pc, #604]	; (abc <set_arm_clock+0x260>)
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
     860:	4290      	cmp	r0, r2
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
     862:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;
     866:	4c96      	ldr	r4, [pc, #600]	; (ac0 <set_arm_clock+0x264>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
     868:	f8d3 e014 	ldr.w	lr, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
     86c:	6999      	ldr	r1, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
     86e:	68e6      	ldr	r6, [r4, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
     870:	d91c      	bls.n	8ac <set_arm_clock+0x50>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
     872:	4b94      	ldr	r3, [pc, #592]	; (ac4 <set_arm_clock+0x268>)
     874:	4298      	cmp	r0, r3
     876:	f240 8115 	bls.w	aa4 <set_arm_clock+0x248>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
     87a:	4b93      	ldr	r3, [pc, #588]	; (ac8 <set_arm_clock+0x26c>)
     87c:	f240 6527 	movw	r5, #1575	; 0x627
     880:	4f92      	ldr	r7, [pc, #584]	; (acc <set_arm_clock+0x270>)
     882:	4403      	add	r3, r0
     884:	4c92      	ldr	r4, [pc, #584]	; (ad0 <set_arm_clock+0x274>)
     886:	0a1a      	lsrs	r2, r3, #8
     888:	fba7 3202 	umull	r3, r2, r7, r2
     88c:	09d3      	lsrs	r3, r2, #7
     88e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
     892:	eb03 0283 	add.w	r2, r3, r3, lsl #2
     896:	f202 43e2 	addw	r3, r2, #1250	; 0x4e2
     89a:	42ab      	cmp	r3, r5
     89c:	bf28      	it	cs
     89e:	462b      	movcs	r3, r5
     8a0:	f5a3 7348 	sub.w	r3, r3, #800	; 0x320
     8a4:	fba4 3503 	umull	r3, r5, r4, r3
     8a8:	08ed      	lsrs	r5, r5, #3
     8aa:	e004      	b.n	8b6 <set_arm_clock+0x5a>
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
		}
#endif
	} else if (frequency <= 24000000) {
     8ac:	4d89      	ldr	r5, [pc, #548]	; (ad4 <set_arm_clock+0x278>)
     8ae:	42a8      	cmp	r0, r5
     8b0:	bf94      	ite	ls
     8b2:	2506      	movls	r5, #6
     8b4:	250e      	movhi	r5, #14
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
     8b6:	4a81      	ldr	r2, [pc, #516]	; (abc <set_arm_clock+0x260>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
     8b8:	f006 071f 	and.w	r7, r6, #31
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
     8bc:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
     8c0:	42af      	cmp	r7, r5
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
     8c2:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
     8c6:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
     8ca:	d20a      	bcs.n	8e2 <set_arm_clock+0x86>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
     8cc:	4b7c      	ldr	r3, [pc, #496]	; (ac0 <set_arm_clock+0x264>)

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
     8ce:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
     8d2:	461a      	mov	r2, r3
	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
     8d4:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
     8d6:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
     8d8:	6813      	ldr	r3, [r2, #0]
     8da:	2b00      	cmp	r3, #0
     8dc:	dafc      	bge.n	8d8 <set_arm_clock+0x7c>
     8de:	f006 071f 	and.w	r7, r6, #31
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
     8e2:	f01e 7300 	ands.w	r3, lr, #33554432	; 0x2000000
     8e6:	d131      	bne.n	94c <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
     8e8:	4c7b      	ldr	r4, [pc, #492]	; (ad8 <set_arm_clock+0x27c>)
     8ea:	4a7c      	ldr	r2, [pc, #496]	; (adc <set_arm_clock+0x280>)
     8ec:	f8d4 c010 	ldr.w	ip, [r4, #16]
     8f0:	4614      	mov	r4, r2
     8f2:	ea0c 0202 	and.w	r2, ip, r2
     8f6:	42a2      	cmp	r2, r4
     8f8:	bf0a      	itet	eq
     8fa:	f04f 53c0 	moveq.w	r3, #402653184	; 0x18000000
     8fe:	f44f 5280 	movne.w	r2, #4096	; 0x1000
     902:	2200      	moveq	r2, #0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
     904:	ea8e 0403 	eor.w	r4, lr, r3
     908:	f014 5f60 	tst.w	r4, #939524096	; 0x38000000
     90c:	d008      	beq.n	920 <set_arm_clock+0xc4>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
     90e:	f02e 5e60 	bic.w	lr, lr, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
     912:	f003 5360 	and.w	r3, r3, #939524096	; 0x38000000
			CCM_CBCDR = cbcdr;
     916:	4c69      	ldr	r4, [pc, #420]	; (abc <set_arm_clock+0x260>)
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
     918:	ea43 0e0e 	orr.w	lr, r3, lr
			CCM_CBCDR = cbcdr;
     91c:	f8c4 e014 	str.w	lr, [r4, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
     920:	ea81 0302 	eor.w	r3, r1, r2
     924:	f413 5f40 	tst.w	r3, #12288	; 0x3000
     928:	d008      	beq.n	93c <set_arm_clock+0xe0>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
     92a:	4b64      	ldr	r3, [pc, #400]	; (abc <set_arm_clock+0x260>)
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
			CCM_CBCDR = cbcdr;
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
     92c:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
     930:	4311      	orrs	r1, r2
			CCM_CBCMR = cbcmr;
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
     932:	461a      	mov	r2, r3
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
     934:	6199      	str	r1, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
     936:	6c93      	ldr	r3, [r2, #72]	; 0x48
     938:	071c      	lsls	r4, r3, #28
     93a:	d4fc      	bmi.n	936 <set_arm_clock+0xda>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
     93c:	f04e 7e00 	orr.w	lr, lr, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
     940:	4a5e      	ldr	r2, [pc, #376]	; (abc <set_arm_clock+0x260>)
     942:	f8c2 e014 	str.w	lr, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
     946:	6c93      	ldr	r3, [r2, #72]	; 0x48
     948:	0699      	lsls	r1, r3, #26
     94a:	d4fc      	bmi.n	946 <set_arm_clock+0xea>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
     94c:	2101      	movs	r1, #1
	while (frequency * div_arm * div_ahb < 648000000) {
     94e:	4c64      	ldr	r4, [pc, #400]	; (ae0 <set_arm_clock+0x284>)
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
     950:	460a      	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
     952:	fb01 f302 	mul.w	r3, r1, r2
     956:	fb00 f303 	mul.w	r3, r0, r3
     95a:	42a3      	cmp	r3, r4
     95c:	d809      	bhi.n	972 <set_arm_clock+0x116>
		if (div_arm < 8) {
     95e:	2a07      	cmp	r2, #7
     960:	f200 8095 	bhi.w	a8e <set_arm_clock+0x232>
			div_arm = div_arm + 1;
     964:	3201      	adds	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
     966:	fb01 f302 	mul.w	r3, r1, r2
     96a:	fb00 f303 	mul.w	r3, r0, r3
     96e:	42a3      	cmp	r3, r4
     970:	d9f5      	bls.n	95e <set_arm_clock+0x102>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
     972:	485c      	ldr	r0, [pc, #368]	; (ae4 <set_arm_clock+0x288>)
     974:	4c5c      	ldr	r4, [pc, #368]	; (ae8 <set_arm_clock+0x28c>)
     976:	4418      	add	r0, r3
     978:	fba4 0300 	umull	r0, r3, r4, r0
     97c:	0d1b      	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
     97e:	2b6c      	cmp	r3, #108	; 0x6c
     980:	f200 808b 	bhi.w	a9a <set_arm_clock+0x23e>
	if (mult < 54) mult = 54;
     984:	2b35      	cmp	r3, #53	; 0x35
     986:	f200 808f 	bhi.w	aa8 <set_arm_clock+0x24c>
     98a:	f8df 8188 	ldr.w	r8, [pc, #392]	; b14 <set_arm_clock+0x2b8>
     98e:	2336      	movs	r3, #54	; 0x36
     990:	4856      	ldr	r0, [pc, #344]	; (aec <set_arm_clock+0x290>)

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
     992:	f8df c144 	ldr.w	ip, [pc, #324]	; ad8 <set_arm_clock+0x27c>
     996:	4c56      	ldr	r4, [pc, #344]	; (af0 <set_arm_clock+0x294>)
     998:	f8dc 9000 	ldr.w	r9, [ip]
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
     99c:	fbb0 f0f2 	udiv	r0, r0, r2

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
     9a0:	ea09 0404 	and.w	r4, r9, r4
     9a4:	4544      	cmp	r4, r8
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
     9a6:	fbb0 f0f1 	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
     9aa:	d00b      	beq.n	9c4 <set_arm_clock+0x168>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
     9ac:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
     9b0:	f44f 5880 	mov.w	r8, #4096	; 0x1000
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
     9b4:	4664      	mov	r4, ip
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
     9b6:	f8cc 8000 	str.w	r8, [ip]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
     9ba:	f8cc 3000 	str.w	r3, [ip]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
     9be:	6823      	ldr	r3, [r4, #0]
     9c0:	2b00      	cmp	r3, #0
     9c2:	dafc      	bge.n	9be <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
     9c4:	f8df c0f4 	ldr.w	ip, [pc, #244]	; abc <set_arm_clock+0x260>
     9c8:	3a01      	subs	r2, #1
     9ca:	f8dc 3010 	ldr.w	r3, [ip, #16]
     9ce:	f003 0307 	and.w	r3, r3, #7
     9d2:	4293      	cmp	r3, r2
     9d4:	d007      	beq.n	9e6 <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
     9d6:	f002 0207 	and.w	r2, r2, #7
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
     9da:	4664      	mov	r4, ip
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
     9dc:	f8cc 2010 	str.w	r2, [ip, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
     9e0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     9e2:	03db      	lsls	r3, r3, #15
     9e4:	d4fc      	bmi.n	9e0 <set_arm_clock+0x184>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
     9e6:	3901      	subs	r1, #1
     9e8:	0289      	lsls	r1, r1, #10
     9ea:	ea8e 0301 	eor.w	r3, lr, r1
     9ee:	f413 5fe0 	tst.w	r3, #7168	; 0x1c00
     9f2:	d00c      	beq.n	a0e <set_arm_clock+0x1b2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
		CCM_CBCDR = cbcdr;
     9f4:	4b31      	ldr	r3, [pc, #196]	; (abc <set_arm_clock+0x260>)
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
     9f6:	f42e 5ee0 	bic.w	lr, lr, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
     9fa:	f401 51e0 	and.w	r1, r1, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
     9fe:	461a      	mov	r2, r3
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
     a00:	ea41 0e0e 	orr.w	lr, r1, lr
		CCM_CBCDR = cbcdr;
     a04:	f8c3 e014 	str.w	lr, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
     a08:	6c93      	ldr	r3, [r2, #72]	; 0x48
     a0a:	0799      	lsls	r1, r3, #30
     a0c:	d4fc      	bmi.n	a08 <set_arm_clock+0x1ac>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
     a0e:	4b39      	ldr	r3, [pc, #228]	; (af4 <set_arm_clock+0x298>)
     a10:	4939      	ldr	r1, [pc, #228]	; (af8 <set_arm_clock+0x29c>)
     a12:	4403      	add	r3, r0
     a14:	09db      	lsrs	r3, r3, #7
     a16:	fba1 3103 	umull	r3, r1, r1, r3
     a1a:	0b09      	lsrs	r1, r1, #12
     a1c:	2904      	cmp	r1, #4
     a1e:	bf28      	it	cs
     a20:	2104      	movcs	r1, #4
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
     a22:	1e4b      	subs	r3, r1, #1
     a24:	021b      	lsls	r3, r3, #8
     a26:	ea8e 0203 	eor.w	r2, lr, r3
     a2a:	f412 7f40 	tst.w	r2, #768	; 0x300
     a2e:	d007      	beq.n	a40 <set_arm_clock+0x1e4>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
     a30:	f42e 7e40 	bic.w	lr, lr, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
     a34:	f403 7340 	and.w	r3, r3, #768	; 0x300
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
     a38:	4a20      	ldr	r2, [pc, #128]	; (abc <set_arm_clock+0x260>)

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
     a3a:	ea43 030e 	orr.w	r3, r3, lr
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
     a3e:	6153      	str	r3, [r2, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
     a40:	4b1e      	ldr	r3, [pc, #120]	; (abc <set_arm_clock+0x260>)
     a42:	695c      	ldr	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
     a44:	461a      	mov	r2, r3
		CCM_CBCDR = cbcdr;
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
     a46:	f024 7400 	bic.w	r4, r4, #33554432	; 0x2000000
     a4a:	615c      	str	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
     a4c:	6c93      	ldr	r3, [r2, #72]	; 0x48
     a4e:	069b      	lsls	r3, r3, #26
     a50:	d4fc      	bmi.n	a4c <set_arm_clock+0x1f0>

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
     a52:	4b2a      	ldr	r3, [pc, #168]	; (afc <set_arm_clock+0x2a0>)
     a54:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
     a58:	4c29      	ldr	r4, [pc, #164]	; (b00 <set_arm_clock+0x2a4>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
     a5a:	42bd      	cmp	r5, r7
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
     a5c:	fba3 e300 	umull	lr, r3, r3, r0
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
     a60:	6020      	str	r0, [r4, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
     a62:	ea4f 4393 	mov.w	r3, r3, lsr #18
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
     a66:	4c27      	ldr	r4, [pc, #156]	; (b04 <set_arm_clock+0x2a8>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
     a68:	fbb2 f3f3 	udiv	r3, r2, r3
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
     a6c:	fbb0 f1f1 	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
     a70:	4a25      	ldr	r2, [pc, #148]	; (b08 <set_arm_clock+0x2ac>)
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
     a72:	6021      	str	r1, [r4, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
     a74:	6013      	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
     a76:	d208      	bcs.n	a8a <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
     a78:	4b11      	ldr	r3, [pc, #68]	; (ac0 <set_arm_clock+0x264>)
	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
     a7a:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
     a7e:	461a      	mov	r2, r3

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
     a80:	432e      	orrs	r6, r5
		DCDC_REG3 = dcdc;
     a82:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
     a84:	6813      	ldr	r3, [r2, #0]
     a86:	2b00      	cmp	r3, #0
     a88:	dafc      	bge.n	a84 <set_arm_clock+0x228>
	}

	return frequency;
}
     a8a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
		if (div_arm < 8) {
			div_arm = div_arm + 1;
		} else {
			if (div_ahb < 5) {
     a8e:	2904      	cmp	r1, #4
     a90:	f63f af6f 	bhi.w	972 <set_arm_clock+0x116>
				div_ahb = div_ahb + 1;
     a94:	3101      	adds	r1, #1
				div_arm = 1;
     a96:	2201      	movs	r2, #1
     a98:	e75b      	b.n	952 <set_arm_clock+0xf6>
     a9a:	f8df 807c 	ldr.w	r8, [pc, #124]	; b18 <set_arm_clock+0x2bc>
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
     a9e:	236c      	movs	r3, #108	; 0x6c
     aa0:	481a      	ldr	r0, [pc, #104]	; (b0c <set_arm_clock+0x2b0>)
     aa2:	e776      	b.n	992 <set_arm_clock+0x136>
     aa4:	2512      	movs	r5, #18
     aa6:	e706      	b.n	8b6 <set_arm_clock+0x5a>
     aa8:	4819      	ldr	r0, [pc, #100]	; (b10 <set_arm_clock+0x2b4>)
     aaa:	f8df 8070 	ldr.w	r8, [pc, #112]	; b1c <set_arm_clock+0x2c0>
     aae:	fb00 f003 	mul.w	r0, r0, r3
     ab2:	ea43 0808 	orr.w	r8, r3, r8
     ab6:	e76c      	b.n	992 <set_arm_clock+0x136>
     ab8:	1f78a400 	.word	0x1f78a400
     abc:	400fc000 	.word	0x400fc000
     ac0:	40080000 	.word	0x40080000
     ac4:	23c34600 	.word	0x23c34600
     ac8:	dc3cba00 	.word	0xdc3cba00
     acc:	004cb223 	.word	0x004cb223
     ad0:	51eb851f 	.word	0x51eb851f
     ad4:	016e3600 	.word	0x016e3600
     ad8:	400d8000 	.word	0x400d8000
     adc:	80003040 	.word	0x80003040
     ae0:	269fb1ff 	.word	0x269fb1ff
     ae4:	005b8d80 	.word	0x005b8d80
     ae8:	165e9f81 	.word	0x165e9f81
     aec:	269fb200 	.word	0x269fb200
     af0:	8001307f 	.word	0x8001307f
     af4:	08f0d17f 	.word	0x08f0d17f
     af8:	00e5109f 	.word	0x00e5109f
     afc:	431bde83 	.word	0x431bde83
     b00:	20000c28 	.word	0x20000c28
     b04:	20000c24 	.word	0x20000c24
     b08:	20001bb8 	.word	0x20001bb8
     b0c:	4d3f6400 	.word	0x4d3f6400
     b10:	00b71b00 	.word	0x00b71b00
     b14:	80002036 	.word	0x80002036
     b18:	8000206c 	.word	0x8000206c
     b1c:	80002000 	.word	0x80002000

00000b20 <delay>:
// or delayNanoseconds().
void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
     b20:	2800      	cmp	r0, #0
     b22:	d057      	beq.n	bd4 <delay+0xb4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
     b24:	2201      	movs	r2, #1
// active, but the rest of your program becomes effectively stalled.  Usually
// delay() is used in very simple programs.  To achieve delay without waiting
// use millis() or elapsedMillis.  For shorter delay, use delayMicroseconds()
// or delayNanoseconds().
void delay(uint32_t msec)
{
     b26:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     b2a:	b085      	sub	sp, #20
     b2c:	4683      	mov	fp, r0
     b2e:	4c2a      	ldr	r4, [pc, #168]	; (bd8 <delay+0xb8>)
     b30:	4d2a      	ldr	r5, [pc, #168]	; (bdc <delay+0xbc>)
     b32:	4e2b      	ldr	r6, [pc, #172]	; (be0 <delay+0xc0>)
     b34:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
     b38:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
     b3c:	6828      	ldr	r0, [r5, #0]
		scc = systick_cycle_count;
     b3e:	6833      	ldr	r3, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
     b40:	e844 2100 	strex	r1, r2, [r4]
	} while ( __STREXW(1, &systick_safe_read));
     b44:	2900      	cmp	r1, #0
     b46:	d1f7      	bne.n	b38 <delay+0x18>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
     b48:	4f26      	ldr	r7, [pc, #152]	; (be4 <delay+0xc4>)
     b4a:	e9cd 8902 	strd	r8, r9, [sp, #8]
     b4e:	683a      	ldr	r2, [r7, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
     b50:	1ad3      	subs	r3, r2, r3
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
     b52:	4a25      	ldr	r2, [pc, #148]	; (be8 <delay+0xc8>)
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
     b54:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
     b58:	9701      	str	r7, [sp, #4]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
     b5a:	6812      	ldr	r2, [r2, #0]
     b5c:	2701      	movs	r7, #1
     b5e:	fba3 2302 	umull	r2, r3, r3, r2
	if (frac > 1000) frac = 1000;
     b62:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
     b66:	4698      	mov	r8, r3
	if (frac > 1000) frac = 1000;
     b68:	2300      	movs	r3, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
     b6a:	428b      	cmp	r3, r1
     b6c:	bf08      	it	eq
     b6e:	4542      	cmpeq	r2, r8
     b70:	bf2c      	ite	cs
     b72:	46c2      	movcs	sl, r8
     b74:	46f2      	movcc	sl, lr
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
     b76:	fb0e aa00 	mla	sl, lr, r0, sl
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
     b7a:	e854 3f00 	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
     b7e:	682a      	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
     b80:	6831      	ldr	r1, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
     b82:	e844 7300 	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
     b86:	2b00      	cmp	r3, #0
     b88:	d1f7      	bne.n	b7a <delay+0x5a>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
     b8a:	9801      	ldr	r0, [sp, #4]
     b8c:	6800      	ldr	r0, [r0, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
     b8e:	1a41      	subs	r1, r0, r1
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
     b90:	4815      	ldr	r0, [pc, #84]	; (be8 <delay+0xc8>)
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
     b92:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
     b96:	6800      	ldr	r0, [r0, #0]
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
     b98:	fb0e f202 	mul.w	r2, lr, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
     b9c:	fba1 0100 	umull	r0, r1, r1, r0
	if (frac > 1000) frac = 1000;
     ba0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
     ba4:	ebca 0202 	rsb	r2, sl, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
     ba8:	4688      	mov	r8, r1
	if (frac > 1000) frac = 1000;
     baa:	2100      	movs	r1, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
     bac:	4299      	cmp	r1, r3
     bae:	bf08      	it	eq
     bb0:	4540      	cmpeq	r0, r8
     bb2:	bf2c      	ite	cs
     bb4:	4643      	movcs	r3, r8
     bb6:	4673      	movcc	r3, lr
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
     bb8:	441a      	add	r2, r3
     bba:	4572      	cmp	r2, lr
     bbc:	d307      	bcc.n	bce <delay+0xae>
			if (--msec == 0) return;
     bbe:	f1bb 0b01 	subs.w	fp, fp, #1
			start += 1000;
     bc2:	f50a 7a7a 	add.w	sl, sl, #1000	; 0x3e8

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
     bc6:	d1d8      	bne.n	b7a <delay+0x5a>
			start += 1000;
		}
		yield();
	}
	// TODO...
}
     bc8:	b005      	add	sp, #20
     bca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
     bce:	f001 fc29 	bl	2424 <yield>
	}
     bd2:	e7d2      	b.n	b7a <delay+0x5a>
     bd4:	4770      	bx	lr
     bd6:	bf00      	nop
     bd8:	20001c60 	.word	0x20001c60
     bdc:	20001bc0 	.word	0x20001bc0
     be0:	20001bbc 	.word	0x20001bbc
     be4:	e0001004 	.word	0xe0001004
     be8:	20001bb8 	.word	0x20001bb8

00000bec <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
     bec:	b4f0      	push	{r4, r5, r6, r7}
     bee:	1e4e      	subs	r6, r1, #1
	unsigned digit;
	int i=0, j;
     bf0:	2500      	movs	r5, #0
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
     bf2:	4637      	mov	r7, r6
     bf4:	e000      	b.n	bf8 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
     bf6:	3501      	adds	r5, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
     bf8:	fbb0 f3f2 	udiv	r3, r0, r2
     bfc:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
     c00:	f100 0437 	add.w	r4, r0, #55	; 0x37
     c04:	2809      	cmp	r0, #9
     c06:	f100 0030 	add.w	r0, r0, #48	; 0x30
     c0a:	b2e4      	uxtb	r4, r4
     c0c:	bf98      	it	ls
     c0e:	b2c4      	uxtbls	r4, r0
		val /= radix;
		if (val == 0) break;
     c10:	4618      	mov	r0, r3
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
     c12:	f807 4f01 	strb.w	r4, [r7, #1]!
		val /= radix;
		if (val == 0) break;
     c16:	2b00      	cmp	r3, #0
     c18:	d1ed      	bne.n	bf6 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
     c1a:	194a      	adds	r2, r1, r5
     c1c:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
     c1e:	b14d      	cbz	r5, c34 <ultoa+0x48>
     c20:	3301      	adds	r3, #1
		t = buf[j];
     c22:	f816 4f01 	ldrb.w	r4, [r6, #1]!
		buf[j] = buf[i];
     c26:	7817      	ldrb	r7, [r2, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
     c28:	1ae8      	subs	r0, r5, r3
		t = buf[j];
		buf[j] = buf[i];
     c2a:	7037      	strb	r7, [r6, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
     c2c:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
     c2e:	f802 4901 	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
     c32:	dbf5      	blt.n	c20 <ultoa+0x34>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
     c34:	4608      	mov	r0, r1
     c36:	bcf0      	pop	{r4, r5, r6, r7}
     c38:	4770      	bx	lr
     c3a:	bf00      	nop

00000c3c <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
     c3c:	48a4      	ldr	r0, [pc, #656]	; (ed0 <pwm_init+0x294>)
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
     c3e:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
     c42:	4ba4      	ldr	r3, [pc, #656]	; (ed4 <pwm_init+0x298>)
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
     c44:	6f82      	ldr	r2, [r0, #120]	; 0x78
     c46:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}

void pwm_init(void)
{
     c4a:	b5f0      	push	{r4, r5, r6, r7, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
     c4c:	6782      	str	r2, [r0, #120]	; 0x78
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
     c4e:	2500      	movs	r5, #0
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
     c50:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
     c54:	f44f 4670 	mov.w	r6, #61440	; 0xf000
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
     c58:	4c9f      	ldr	r4, [pc, #636]	; (ed8 <pwm_init+0x29c>)
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
     c5a:	f44f 4e60 	mov.w	lr, #57344	; 0xe000

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     c5e:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
     c60:	f44f 6780 	mov.w	r7, #1024	; 0x400
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
     c64:	4314      	orrs	r4, r2
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
     c66:	462a      	mov	r2, r5
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
     c68:	f8c0 4080 	str.w	r4, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
     c6c:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
     c70:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
     c74:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
     c78:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
     c7c:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
     c80:	b280      	uxth	r0, r0
     c82:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
     c86:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
     c8a:	eb01 0041 	add.w	r0, r1, r1, lsl #1
     c8e:	4b91      	ldr	r3, [pc, #580]	; (ed4 <pwm_init+0x298>)
	for (i=0; i < 4; i++) {
     c90:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
     c92:	2500      	movs	r5, #0
     c94:	0140      	lsls	r0, r0, #5
     c96:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     c98:	2904      	cmp	r1, #4
     c9a:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
     c9c:	f8a3 e004 	strh.w	lr, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
     ca0:	80df      	strh	r7, [r3, #6]
		p->SM[i].OCTRL = 0;
     ca2:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
     ca4:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
     ca6:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
     ca8:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
     caa:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
     cac:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
     cae:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
     cb0:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
     cb2:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     cb4:	d1e9      	bne.n	c8a <pwm_init+0x4e>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     cb6:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
     cba:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
     cbe:	4b87      	ldr	r3, [pc, #540]	; (edc <pwm_init+0x2a0>)
     cc0:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     cc4:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     cc6:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
     cc8:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
     ccc:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     cce:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
     cd2:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     cd6:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
     cda:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
     cde:	b280      	uxth	r0, r0
     ce0:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
     ce4:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
     ce8:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
     cec:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
     cf0:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
     cf4:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
     cf8:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
     cfc:	b280      	uxth	r0, r0
     cfe:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
     d02:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
     d06:	eb01 0041 	add.w	r0, r1, r1, lsl #1
     d0a:	4b74      	ldr	r3, [pc, #464]	; (edc <pwm_init+0x2a0>)
	for (i=0; i < 4; i++) {
     d0c:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
     d0e:	2500      	movs	r5, #0
     d10:	0140      	lsls	r0, r0, #5
     d12:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     d14:	2904      	cmp	r1, #4
     d16:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
     d18:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
     d1a:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
     d1e:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
     d20:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
     d22:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
     d24:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
     d26:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
     d28:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
     d2a:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
     d2c:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
     d2e:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     d30:	d1e9      	bne.n	d06 <pwm_init+0xca>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     d32:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
     d36:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
     d3a:	4b69      	ldr	r3, [pc, #420]	; (ee0 <pwm_init+0x2a4>)
     d3c:	f44f 4670 	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     d40:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     d42:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
     d44:	f44f 4760 	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
     d48:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     d4a:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
     d4e:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     d52:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
     d56:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
     d5a:	b280      	uxth	r0, r0
     d5c:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
     d60:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
     d64:	f8a3 618c 	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
     d68:	f248 26b8 	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
     d6c:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
     d70:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
     d74:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
     d78:	b280      	uxth	r0, r0
     d7a:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
     d7e:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
     d82:	eb01 0041 	add.w	r0, r1, r1, lsl #1
     d86:	4b56      	ldr	r3, [pc, #344]	; (ee0 <pwm_init+0x2a4>)
	for (i=0; i < 4; i++) {
     d88:	3101      	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
     d8a:	2500      	movs	r5, #0
     d8c:	0140      	lsls	r0, r0, #5
     d8e:	461c      	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     d90:	2904      	cmp	r1, #4
     d92:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
     d94:	809f      	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
     d96:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
     d9a:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
     d9c:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
     d9e:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
     da0:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
     da2:	81de      	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
     da4:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
     da6:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
     da8:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
     daa:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     dac:	d1e9      	bne.n	d82 <pwm_init+0x146>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     dae:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
     db2:	f04f 0c0f 	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
     db6:	4b4b      	ldr	r3, [pc, #300]	; (ee4 <pwm_init+0x2a8>)
     db8:	f44f 4770 	mov.w	r7, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     dbc:	b280      	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     dbe:	4629      	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
     dc0:	f44f 4660 	mov.w	r6, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
     dc4:	462a      	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     dc6:	ea40 000c 	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
     dca:	f44f 6e80 	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     dce:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
     dd2:	f8b4 0188 	ldrh.w	r0, [r4, #392]	; 0x188
     dd6:	b280      	uxth	r0, r0
     dd8:	f440 6070 	orr.w	r0, r0, #3840	; 0xf00
     ddc:	f8a4 0188 	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
     de0:	f8a3 718c 	strh.w	r7, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
     de4:	f248 27b8 	movw	r7, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
     de8:	f8a3 c18e 	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
     dec:	f8a3 5190 	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
     df0:	f8b3 0188 	ldrh.w	r0, [r3, #392]	; 0x188
     df4:	b280      	uxth	r0, r0
     df6:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
     dfa:	f8a3 0188 	strh.w	r0, [r3, #392]	; 0x188
     dfe:	eb01 0041 	add.w	r0, r1, r1, lsl #1
     e02:	4b38      	ldr	r3, [pc, #224]	; (ee4 <pwm_init+0x2a8>)
	for (i=0; i < 4; i++) {
     e04:	3101      	adds	r1, #1
     e06:	0140      	lsls	r0, r0, #5
     e08:	461c      	mov	r4, r3
     e0a:	2904      	cmp	r1, #4
     e0c:	4403      	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
     e0e:	809e      	strh	r6, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
     e10:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
     e14:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
     e16:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
     e18:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
     e1a:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
     e1c:	81df      	strh	r7, [r3, #14]
		p->SM[i].VAL2 = 0;
     e1e:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
     e20:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
     e22:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
     e24:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
     e26:	d1ea      	bne.n	dfe <pwm_init+0x1c2>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     e28:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
     e2c:	270f      	movs	r7, #15

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     e2e:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
     e30:	f241 0601 	movw	r6, #4097	; 0x1001
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     e34:	b29b      	uxth	r3, r3
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
     e36:	f645 5ec0 	movw	lr, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
     e3a:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
     e3c:	f243 0526 	movw	r5, #12326	; 0x3026
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
     e40:	433b      	orrs	r3, r7
     e42:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
     e46:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
     e4a:	b29b      	uxth	r3, r3
     e4c:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
     e50:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
     e54:	0150      	lsls	r0, r2, #5
     e56:	4b24      	ldr	r3, [pc, #144]	; (ee8 <pwm_init+0x2ac>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     e58:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
     e5a:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     e5c:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
     e5e:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
     e60:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
     e62:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
     e64:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
     e66:	f8a3 e006 	strh.w	lr, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
     e6a:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
     e6c:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
     e6e:	819d      	strh	r5, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     e70:	d1f0      	bne.n	e54 <pwm_init+0x218>
     e72:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
     e74:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
     e76:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
     e7a:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
     e7e:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
     e80:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
     e84:	0150      	lsls	r0, r2, #5
     e86:	4b19      	ldr	r3, [pc, #100]	; (eec <pwm_init+0x2b0>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     e88:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
     e8a:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     e8c:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
     e8e:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
     e90:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
     e92:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
     e94:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
     e96:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
     e98:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
     e9a:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
     e9c:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     e9e:	d1f1      	bne.n	e84 <pwm_init+0x248>
     ea0:	2200      	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
     ea2:	270f      	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
     ea4:	f241 0601 	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
     ea8:	f645 55c0 	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
     eac:	4611      	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
     eae:	f243 0426 	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
     eb2:	0150      	lsls	r0, r2, #5
     eb4:	4b0e      	ldr	r3, [pc, #56]	; (ef0 <pwm_init+0x2b4>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     eb6:	3201      	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
     eb8:	4403      	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     eba:	2a04      	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
     ebc:	8199      	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
     ebe:	8159      	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
     ec0:	81df      	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
     ec2:	829e      	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
     ec4:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
     ec6:	8019      	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
     ec8:	8219      	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
     eca:	819c      	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
     ecc:	d1f1      	bne.n	eb2 <pwm_init+0x276>
	flexpwm_init(&IMXRT_FLEXPWM3);
	flexpwm_init(&IMXRT_FLEXPWM4);
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
     ece:	bdf0      	pop	{r4, r5, r6, r7, pc}
     ed0:	400fc000 	.word	0x400fc000
     ed4:	403dc000 	.word	0x403dc000
     ed8:	fc030000 	.word	0xfc030000
     edc:	403e0000 	.word	0x403e0000
     ee0:	403e4000 	.word	0x403e4000
     ee4:	403e8000 	.word	0x403e8000
     ee8:	401dc000 	.word	0x401dc000
     eec:	401e0000 	.word	0x401e0000
     ef0:	401e4000 	.word	0x401e4000

00000ef4 <rtc_get>:
#include "debug/printf.h"


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
     ef4:	4b0a      	ldr	r3, [pc, #40]	; (f20 <rtc_get+0x2c>)
#include "imxrt.h"
#include "debug/printf.h"


unsigned long rtc_get(void)
{
     ef6:	b430      	push	{r4, r5}
	uint32_t hi1 = SNVS_HPRTCMR;
     ef8:	6a58      	ldr	r0, [r3, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
     efa:	461c      	mov	r4, r3


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
     efc:	6a99      	ldr	r1, [r3, #40]	; 0x28
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
     efe:	6a62      	ldr	r2, [r4, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
     f00:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
     f02:	4299      	cmp	r1, r3
     f04:	bf08      	it	eq
     f06:	4290      	cmpeq	r0, r2
unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
     f08:	4610      	mov	r0, r2
		uint32_t lo2 = SNVS_HPRTCLR;
     f0a:	4619      	mov	r1, r3
		if (lo1 == lo2 && hi1 == hi2) {
     f0c:	bf0c      	ite	eq
     f0e:	2501      	moveq	r5, #1
     f10:	2500      	movne	r5, #0
     f12:	2d00      	cmp	r5, #0
     f14:	d0f3      	beq.n	efe <rtc_get+0xa>
			return (hi2 << 17) | (lo2 >> 15);
     f16:	0bd9      	lsrs	r1, r3, #15
		}
		hi1 = hi2;
		lo1 = lo2;
	}
}
     f18:	bc30      	pop	{r4, r5}
     f1a:	ea41 4042 	orr.w	r0, r1, r2, lsl #17
     f1e:	4770      	bx	lr
     f20:	400d4000 	.word	0x400d4000

00000f24 <sm_align_pool>:
	if (spool->pool_size % HEADER_SZ) return 0;
	return 1;
}

int sm_align_pool(struct smalloc_pool *spool)
{
     f24:	b508      	push	{r3, lr}

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
     f26:	6803      	ldr	r3, [r0, #0]
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
     f28:	6842      	ldr	r2, [r0, #4]

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
     f2a:	b1bb      	cbz	r3, f5c <sm_align_pool+0x38>
     f2c:	b17a      	cbz	r2, f4e <sm_align_pool+0x2a>
	if (spool->pool_size % HEADER_SZ) return 0;
     f2e:	4b10      	ldr	r3, [pc, #64]	; (f70 <sm_align_pool+0x4c>)
     f30:	fba3 1302 	umull	r1, r3, r3, r2
     f34:	08db      	lsrs	r3, r3, #3
     f36:	eb03 0343 	add.w	r3, r3, r3, lsl #1
     f3a:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
     f3e:	d003      	beq.n	f48 <sm_align_pool+0x24>
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
     f40:	1ad2      	subs	r2, r2, r3
     f42:	6042      	str	r2, [r0, #4]
	if (spool->pool_size <= MIN_POOL_SZ) {
     f44:	2af0      	cmp	r2, #240	; 0xf0
     f46:	d902      	bls.n	f4e <sm_align_pool+0x2a>

int sm_align_pool(struct smalloc_pool *spool)
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;
     f48:	2301      	movs	r3, #1
		errno = ENOSPC;
		return 0;
	}

	return 1;
}
     f4a:	4618      	mov	r0, r3
     f4c:	bd08      	pop	{r3, pc}
	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
	if (spool->pool_size <= MIN_POOL_SZ) {
		errno = ENOSPC;
     f4e:	f001 fc79 	bl	2844 <__errno>
     f52:	221c      	movs	r2, #28
     f54:	2300      	movs	r3, #0
     f56:	6002      	str	r2, [r0, #0]
		return 0;
	}

	return 1;
}
     f58:	4618      	mov	r0, r3
     f5a:	bd08      	pop	{r3, pc}
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
     f5c:	4b04      	ldr	r3, [pc, #16]	; (f70 <sm_align_pool+0x4c>)
     f5e:	fba3 1302 	umull	r1, r3, r3, r2
     f62:	08db      	lsrs	r3, r3, #3
     f64:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	if (x) spool->pool_size -= x;
     f68:	ebb2 0383 	subs.w	r3, r2, r3, lsl #2
     f6c:	d1e8      	bne.n	f40 <sm_align_pool+0x1c>
     f6e:	e7e9      	b.n	f44 <sm_align_pool+0x20>
     f70:	aaaaaaab 	.word	0xaaaaaaab

00000f74 <sm_set_pool>:

	return 1;
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
     f74:	b570      	push	{r4, r5, r6, lr}
	if (!spool) {
     f76:	4604      	mov	r4, r0
     f78:	2800      	cmp	r0, #0
     f7a:	d03a      	beq.n	ff2 <sm_set_pool+0x7e>
		errno = EINVAL;
		return 0;
	}

	if (!new_pool || !new_pool_size) {
     f7c:	b119      	cbz	r1, f86 <sm_set_pool+0x12>
     f7e:	fab2 f582 	clz	r5, r2
     f82:	096d      	lsrs	r5, r5, #5
     f84:	b1fd      	cbz	r5, fc6 <sm_set_pool+0x52>

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
     f86:	6820      	ldr	r0, [r4, #0]
     f88:	b108      	cbz	r0, f8e <sm_set_pool+0x1a>
     f8a:	6862      	ldr	r2, [r4, #4]
     f8c:	b932      	cbnz	r2, f9c <sm_set_pool+0x28>
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
     f8e:	f001 fc59 	bl	2844 <__errno>
     f92:	2316      	movs	r3, #22
		return 0;
     f94:	2200      	movs	r2, #0
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
     f96:	6003      	str	r3, [r0, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
     f98:	4610      	mov	r0, r2
     f9a:	bd70      	pop	{r4, r5, r6, pc}
struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
	if (spool->pool_size % HEADER_SZ) return 0;
     f9c:	4918      	ldr	r1, [pc, #96]	; (1000 <sm_set_pool+0x8c>)
     f9e:	fba1 3102 	umull	r3, r1, r1, r2
     fa2:	08c9      	lsrs	r1, r1, #3
     fa4:	eb01 0141 	add.w	r1, r1, r1, lsl #1
     fa8:	ebb2 0181 	subs.w	r1, r2, r1, lsl #2
     fac:	d1ef      	bne.n	f8e <sm_set_pool+0x1a>
		return 0;
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
     fae:	68a3      	ldr	r3, [r4, #8]
     fb0:	b10b      	cbz	r3, fb6 <sm_set_pool+0x42>
     fb2:	f002 f86b 	bl	308c <memset>
			memset(spool, 0, sizeof(struct smalloc_pool));
     fb6:	2300      	movs	r3, #0
			return 1;
     fb8:	2201      	movs	r2, #1
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
     fba:	6023      	str	r3, [r4, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
     fbc:	4610      	mov	r0, r2
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
     fbe:	6063      	str	r3, [r4, #4]
     fc0:	60a3      	str	r3, [r4, #8]
     fc2:	60e3      	str	r3, [r4, #12]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
     fc4:	bd70      	pop	{r4, r5, r6, pc}
     fc6:	461e      	mov	r6, r3
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
     fc8:	9b04      	ldr	r3, [sp, #16]
		errno = EINVAL;
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
     fca:	e880 0006 	stmia.w	r0, {r1, r2}
	spool->oomfn = oom_handler;
     fce:	60c3      	str	r3, [r0, #12]
	if (!sm_align_pool(spool)) return 0;
     fd0:	f7ff ffa8 	bl	f24 <sm_align_pool>
     fd4:	4602      	mov	r2, r0
     fd6:	2800      	cmp	r0, #0
     fd8:	d0de      	beq.n	f98 <sm_set_pool+0x24>

	if (do_zero) {
     fda:	b916      	cbnz	r6, fe2 <sm_set_pool+0x6e>
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
     fdc:	2201      	movs	r2, #1
}
     fde:	4610      	mov	r0, r2
     fe0:	bd70      	pop	{r4, r5, r6, pc}
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
     fe2:	e894 0005 	ldmia.w	r4, {r0, r2}
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
     fe6:	60a6      	str	r6, [r4, #8]
		memset(spool->pool, 0, spool->pool_size);
     fe8:	4629      	mov	r1, r5
     fea:	f002 f84f 	bl	308c <memset>
	}

	return 1;
     fee:	2201      	movs	r2, #1
     ff0:	e7d2      	b.n	f98 <sm_set_pool+0x24>
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
     ff2:	f001 fc27 	bl	2844 <__errno>
     ff6:	2316      	movs	r3, #22
		return 0;
     ff8:	4622      	mov	r2, r4
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
     ffa:	6003      	str	r3, [r0, #0]
		return 0;
     ffc:	e7cc      	b.n	f98 <sm_set_pool+0x24>
     ffe:	bf00      	nop
    1000:	aaaaaaab 	.word	0xaaaaaaab

00001004 <unused_interrupt_vector>:
	const uint32_t *stack;
	struct arm_fault_info_struct *info;
	const uint32_t *p, *end;

	// disallow any nested interrupts
	__disable_irq();
    1004:	b672      	cpsid	i
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
    1006:	f3ef 8305 	mrs	r3, IPSR
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
    100a:	4d49      	ldr	r5, [pc, #292]	; (1130 <unused_interrupt_vector+0x12c>)
    100c:	606b      	str	r3, [r5, #4]
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
    100e:	f3ef 8308 	mrs	r3, MSP
	info->cfsr = SCB_CFSR;
    1012:	4c48      	ldr	r4, [pc, #288]	; (1134 <unused_interrupt_vector+0x130>)
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
	info->len = sizeof(*info) / 4;
    1014:	462e      	mov	r6, r5
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
    1016:	4848      	ldr	r0, [pc, #288]	; (1138 <unused_interrupt_vector+0x134>)
	info->mmfar = SCB_MMFAR;
    1018:	4948      	ldr	r1, [pc, #288]	; (113c <unused_interrupt_vector+0x138>)
	info->bfar = SCB_BFAR;
    101a:	4a49      	ldr	r2, [pc, #292]	; (1140 <unused_interrupt_vector+0x13c>)
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    101c:	6824      	ldr	r4, [r4, #0]
	info->hfsr = SCB_HFSR;
    101e:	6800      	ldr	r0, [r0, #0]
	info->mmfar = SCB_MMFAR;
    1020:	6809      	ldr	r1, [r1, #0]
	info->bfar = SCB_BFAR;
    1022:	6812      	ldr	r2, [r2, #0]
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
    1024:	6129      	str	r1, [r5, #16]
	// store crash report info
	asm volatile("mrs %0, ipsr\n" : "=r" (ipsr) :: "memory");
	info = (struct arm_fault_info_struct *)0x2027FF80;
	info->ipsr = ipsr;
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
    1026:	60ac      	str	r4, [r5, #8]
	info->hfsr = SCB_HFSR;
    1028:	60e8      	str	r0, [r5, #12]
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
    102a:	616a      	str	r2, [r5, #20]
	info->ret = stack[6];
    102c:	699a      	ldr	r2, [r3, #24]
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    102e:	4c45      	ldr	r4, [pc, #276]	; (1144 <unused_interrupt_vector+0x140>)
	asm volatile("mrs %0, msp\n" : "=r" (stack) :: "memory");
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
    1030:	61aa      	str	r2, [r5, #24]
	info->xpsr = stack[7];
    1032:	69db      	ldr	r3, [r3, #28]
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    1034:	4f44      	ldr	r7, [pc, #272]	; (1148 <unused_interrupt_vector+0x144>)
	info->cfsr = SCB_CFSR;
	info->hfsr = SCB_HFSR;
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
    1036:	61eb      	str	r3, [r5, #28]
	info->temp = tempmonGetTemp();
    1038:	f000 f8c6 	bl	11c8 <tempmonGetTemp>
    103c:	ed85 0a08 	vstr	s0, [r5, #32]
	info->time = rtc_get();
    1040:	f7ff ff58 	bl	ef4 <rtc_get>
	info->len = sizeof(*info) / 4;
    1044:	230b      	movs	r3, #11
	// add CRC to crash report
	crc = 0xFFFFFFFF;
    1046:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	info->mmfar = SCB_MMFAR;
	info->bfar = SCB_BFAR;
	info->ret = stack[6];
	info->xpsr = stack[7];
	info->temp = tempmonGetTemp();
	info->time = rtc_get();
    104a:	6268      	str	r0, [r5, #36]	; 0x24
	info->len = sizeof(*info) / 4;
    104c:	4619      	mov	r1, r3
    104e:	602b      	str	r3, [r5, #0]
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
		crc ^= *p++;
    1050:	404a      	eors	r2, r1
    1052:	2120      	movs	r1, #32
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
    1054:	f002 0301 	and.w	r3, r2, #1
    1058:	3901      	subs	r1, #1
    105a:	fb04 f303 	mul.w	r3, r4, r3
    105e:	ea83 0252 	eor.w	r2, r3, r2, lsr #1
    1062:	d1f7      	bne.n	1054 <unused_interrupt_vector+0x50>
	info->len = sizeof(*info) / 4;
	// add CRC to crash report
	crc = 0xFFFFFFFF;
	p = (uint32_t *)info;
	end = p + (sizeof(*info) / 4 - 1);
	while (p < end) {
    1064:	42be      	cmp	r6, r7
    1066:	d002      	beq.n	106e <unused_interrupt_vector+0x6a>
    1068:	f856 1f04 	ldr.w	r1, [r6, #4]!
    106c:	e7f0      	b.n	1050 <unused_interrupt_vector+0x4c>
		crc ^= *p++;
		for (i=0; i < 32; i++) crc = (crc >> 1) ^ (crc & 1)*0xEDB88320;
	}
	info->crc = crc;
    106e:	4930      	ldr	r1, [pc, #192]	; (1130 <unused_interrupt_vector+0x12c>)
    1070:	628a      	str	r2, [r1, #40]	; 0x28
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    1072:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    1076:	4b35      	ldr	r3, [pc, #212]	; (114c <unused_interrupt_vector+0x148>)
    1078:	4a35      	ldr	r2, [pc, #212]	; (1150 <unused_interrupt_vector+0x14c>)
    107a:	6019      	str	r1, [r3, #0]
    107c:	601a      	str	r2, [r3, #0]
		location += 32;
	} while (location < end_addr);
	asm("dsb");
    107e:	f3bf 8f4f 	dsb	sy
	asm("isb");
    1082:	f3bf 8f6f 	isb	sy
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1086:	4a33      	ldr	r2, [pc, #204]	; (1154 <unused_interrupt_vector+0x150>)
	PIT_MCR = PIT_MCR_MDIS;
    1088:	2502      	movs	r5, #2
    108a:	4c33      	ldr	r4, [pc, #204]	; (1158 <unused_interrupt_vector+0x154>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    108c:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    108e:	4933      	ldr	r1, [pc, #204]	; (115c <unused_interrupt_vector+0x158>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1090:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    1094:	4832      	ldr	r0, [pc, #200]	; (1160 <unused_interrupt_vector+0x15c>)
	//IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
	//IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
	//GPIO7_GDIR |= (1 << 3);

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
    1096:	66d3      	str	r3, [r2, #108]	; 0x6c
	PIT_MCR = PIT_MCR_MDIS;
    1098:	6025      	str	r5, [r4, #0]
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
    109a:	69d3      	ldr	r3, [r2, #28]
    109c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    10a0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    10a4:	61d3      	str	r3, [r2, #28]
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    10a6:	680b      	ldr	r3, [r1, #0]
    10a8:	4283      	cmp	r3, r0
    10aa:	d83e      	bhi.n	112a <unused_interrupt_vector+0x126>
	PIT_MCR = 0;
    10ac:	4a2a      	ldr	r2, [pc, #168]	; (1158 <unused_interrupt_vector+0x154>)
    10ae:	2100      	movs	r1, #0
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    10b0:	2001      	movs	r0, #1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    10b2:	4e2c      	ldr	r6, [pc, #176]	; (1164 <unused_interrupt_vector+0x160>)
	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
    10b4:	6011      	str	r1, [r2, #0]
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    10b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
    10ba:	f8c2 1108 	str.w	r1, [r2, #264]	; 0x108
	NVIC_ICER4 = 0xFFFFFFFF;

	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
    10be:	460c      	mov	r4, r1
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
    10c0:	f8c2 6100 	str.w	r6, [r2, #256]	; 0x100
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    10c4:	4615      	mov	r5, r2
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
    10c6:	f8c2 0108 	str.w	r0, [r2, #264]	; 0x108
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    10ca:	4607      	mov	r7, r0
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    10cc:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 1190 <unused_interrupt_vector+0x18c>
	NVIC_ICER1 = 0xFFFFFFFF;
    10d0:	4e25      	ldr	r6, [pc, #148]	; (1168 <unused_interrupt_vector+0x164>)
	NVIC_ICER2 = 0xFFFFFFFF;
    10d2:	4826      	ldr	r0, [pc, #152]	; (116c <unused_interrupt_vector+0x168>)
	NVIC_ICER3 = 0xFFFFFFFF;
    10d4:	4926      	ldr	r1, [pc, #152]	; (1170 <unused_interrupt_vector+0x16c>)
	NVIC_ICER4 = 0xFFFFFFFF;
    10d6:	4a27      	ldr	r2, [pc, #156]	; (1174 <unused_interrupt_vector+0x170>)
	PIT_MCR = 0;
	PIT_TCTRL0 = 0;
	PIT_LDVAL0 = 2400000; // 2400000 = 100ms
	PIT_TCTRL0 = PIT_TCTRL_TEN;
	// disable all NVIC interrupts, as usb_isr() might use __enable_irq()
	NVIC_ICER0 = 0xFFFFFFFF;
    10d8:	f8ce 3000 	str.w	r3, [lr]
	NVIC_ICER1 = 0xFFFFFFFF;
    10dc:	6033      	str	r3, [r6, #0]
	NVIC_ICER2 = 0xFFFFFFFF;
    10de:	6003      	str	r3, [r0, #0]
	NVIC_ICER3 = 0xFFFFFFFF;
    10e0:	600b      	str	r3, [r1, #0]
	NVIC_ICER4 = 0xFFFFFFFF;
    10e2:	6013      	str	r3, [r2, #0]
    10e4:	e001      	b.n	10ea <unused_interrupt_vector+0xe6>
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
		}
		usb_isr();
    10e6:	f000 f953 	bl	1390 <usb_isr>
	// keep USB running, so any unsent Serial.print() actually arrives in
	// the Arduino Serial Monitor, and we remain responsive to Upload
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
    10ea:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
    10ee:	4b1a      	ldr	r3, [pc, #104]	; (1158 <unused_interrupt_vector+0x154>)
    10f0:	2a00      	cmp	r2, #0
    10f2:	d0f8      	beq.n	10e6 <unused_interrupt_vector+0xe2>
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
			if (++count >= 80) break;  // reboot after 8 seconds
    10f4:	3401      	adds	r4, #1
	// without requiring manual press of Teensy's pushbutton
	count = 0;
	while (1) {
		if (PIT_TFLG0) {
			//GPIO7_DR_TOGGLE = (1 << 3); // blink LED
			PIT_TFLG0 = 1;
    10f6:	f8c5 710c 	str.w	r7, [r5, #268]	; 0x10c
			if (++count >= 80) break;  // reboot after 8 seconds
    10fa:	2c4f      	cmp	r4, #79	; 0x4f
    10fc:	d9f3      	bls.n	10e6 <unused_interrupt_vector+0xe2>
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    10fe:	4a1e      	ldr	r2, [pc, #120]	; (1178 <unused_interrupt_vector+0x174>)
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    1100:	2402      	movs	r4, #2
    1102:	481e      	ldr	r0, [pc, #120]	; (117c <unused_interrupt_vector+0x178>)
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    1104:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
		//   Transmit Serial1 - Serial8 data
		//   Complete writes to SD card
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
    1108:	f8c0 4140 	str.w	r4, [r0, #320]	; 0x140
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
    110c:	6351      	str	r1, [r2, #52]	; 0x34
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    110e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    1112:	b932      	cbnz	r2, 1122 <unused_interrupt_vector+0x11e>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
    1114:	491a      	ldr	r1, [pc, #104]	; (1180 <unused_interrupt_vector+0x17c>)
    1116:	4a1b      	ldr	r2, [pc, #108]	; (1184 <unused_interrupt_vector+0x180>)
    1118:	630a      	str	r2, [r1, #48]	; 0x30
		//   Flush/sync LittleFS
	}
	// turn off USB
	USB1_USBCMD = USB_USBCMD_RST;
	USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST;
	while (PIT_TFLG0 == 0) /* wait 0.1 second for PC to know USB unplugged */
    111a:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    111e:	2800      	cmp	r0, #0
    1120:	d0fa      	beq.n	1118 <unused_interrupt_vector+0x114>
	// reboot
	SRC_GPR5 = 0x0BAD00F1;
	SCB_AIRCR = 0x05FA0004;
    1122:	4b19      	ldr	r3, [pc, #100]	; (1188 <unused_interrupt_vector+0x184>)
    1124:	4a19      	ldr	r2, [pc, #100]	; (118c <unused_interrupt_vector+0x188>)
    1126:	601a      	str	r2, [r3, #0]
    1128:	e7fe      	b.n	1128 <unused_interrupt_vector+0x124>

	// reinitialize PIT timer and CPU clock
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
	PIT_MCR = PIT_MCR_MDIS;
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
  	if (F_CPU_ACTUAL > 198000000) set_arm_clock(198000000);
    112a:	f7ff fb97 	bl	85c <set_arm_clock>
    112e:	e7bd      	b.n	10ac <unused_interrupt_vector+0xa8>
    1130:	2027ff80 	.word	0x2027ff80
    1134:	e000ed28 	.word	0xe000ed28
    1138:	e000ed2c 	.word	0xe000ed2c
    113c:	e000ed34 	.word	0xe000ed34
    1140:	e000ed38 	.word	0xe000ed38
    1144:	edb88320 	.word	0xedb88320
    1148:	2027ffa4 	.word	0x2027ffa4
    114c:	e000ef70 	.word	0xe000ef70
    1150:	2027ffa0 	.word	0x2027ffa0
    1154:	400fc000 	.word	0x400fc000
    1158:	40084000 	.word	0x40084000
    115c:	20000c28 	.word	0x20000c28
    1160:	0bcd3d80 	.word	0x0bcd3d80
    1164:	00249f00 	.word	0x00249f00
    1168:	e000e184 	.word	0xe000e184
    116c:	e000e188 	.word	0xe000e188
    1170:	e000e18c 	.word	0xe000e18c
    1174:	e000e190 	.word	0xe000e190
    1178:	400d9000 	.word	0x400d9000
    117c:	402e0000 	.word	0x402e0000
    1180:	400f8000 	.word	0x400f8000
    1184:	0bad00f1 	.word	0x0bad00f1
    1188:	e000ed0c 	.word	0xe000ed0c
    118c:	05fa0004 	.word	0x05fa0004
    1190:	e000e180 	.word	0xe000e180

00001194 <_sbrk>:

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
        char *prev = __brkval;
    1194:	4a09      	ldr	r2, [pc, #36]	; (11bc <_sbrk+0x28>)
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
    1196:	b508      	push	{r3, lr}
        char *prev = __brkval;
    1198:	6813      	ldr	r3, [r2, #0]
        if (incr != 0) {
    119a:	b120      	cbz	r0, 11a6 <_sbrk+0x12>
                if (prev + incr > (char *)&_heap_end) {
    119c:	4418      	add	r0, r3
    119e:	4908      	ldr	r1, [pc, #32]	; (11c0 <_sbrk+0x2c>)
    11a0:	4288      	cmp	r0, r1
    11a2:	d802      	bhi.n	11aa <_sbrk+0x16>
                        errno = ENOMEM;
                        return (void *)-1;
                }
                __brkval = prev + incr;
    11a4:	6010      	str	r0, [r2, #0]
        }
        return prev;
}
    11a6:	4618      	mov	r0, r3
    11a8:	bd08      	pop	{r3, pc}
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    11aa:	f001 fb4b 	bl	2844 <__errno>
    11ae:	220c      	movs	r2, #12
                        return (void *)-1;
    11b0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    11b4:	6002      	str	r2, [r0, #0]
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    11b6:	4618      	mov	r0, r3
    11b8:	bd08      	pop	{r3, pc}
    11ba:	bf00      	nop
    11bc:	20000c48 	.word	0x20000c48
    11c0:	20280000 	.word	0x20280000

000011c4 <Panic_Temp_isr>:
static float s_hot_ROOM, s_roomC_hotC;

extern void unused_interrupt_vector(void); // startup.c

void Panic_Temp_isr(void) {
  unused_interrupt_vector();
    11c4:	f7ff bf1e 	b.w	1004 <unused_interrupt_vector>

000011c8 <tempmonGetTemp>:
float tempmonGetTemp(void)
{
    uint32_t nmeas;
    float tmeas;

    while (!(TEMPMON_TEMPSENSE0 & 0x4U))
    11c8:	4912      	ldr	r1, [pc, #72]	; (1214 <tempmonGetTemp+0x4c>)
    11ca:	680b      	ldr	r3, [r1, #0]
    11cc:	4a11      	ldr	r2, [pc, #68]	; (1214 <tempmonGetTemp+0x4c>)
    11ce:	075b      	lsls	r3, r3, #29
    11d0:	d5fb      	bpl.n	11ca <tempmonGetTemp+0x2>
    {
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    11d2:	6813      	ldr	r3, [r2, #0]
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    11d4:	4910      	ldr	r1, [pc, #64]	; (1218 <tempmonGetTemp+0x50>)

    return tmeas;
    11d6:	f3c3 230b 	ubfx	r3, r3, #8, #12
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    11da:	4a10      	ldr	r2, [pc, #64]	; (121c <tempmonGetTemp+0x54>)

    return tmeas;
    11dc:	ee07 3a90 	vmov	s15, r3
    11e0:	680b      	ldr	r3, [r1, #0]
    11e2:	ed92 6a00 	vldr	s12, [r2]
    11e6:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    11ea:	ee07 3a90 	vmov	s15, r3
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    11ee:	4a0c      	ldr	r2, [pc, #48]	; (1220 <tempmonGetTemp+0x58>)

    return tmeas;
    11f0:	eef8 7a67 	vcvt.f32.u32	s15, s15
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (((float)nmeas - (float)s_hotCount) * s_hot_ROOM / s_roomC_hotC);
    11f4:	4b0b      	ldr	r3, [pc, #44]	; (1224 <tempmonGetTemp+0x5c>)

    return tmeas;
    11f6:	edd2 6a00 	vldr	s13, [r2]
    11fa:	ee77 7a67 	vsub.f32	s15, s14, s15
    11fe:	ed93 7a00 	vldr	s14, [r3]
    1202:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    1206:	ee67 7a86 	vmul.f32	s15, s15, s12
    120a:	ee87 0aa6 	vdiv.f32	s0, s15, s13
}
    120e:	ee37 0a40 	vsub.f32	s0, s14, s0
    1212:	4770      	bx	lr
    1214:	400d8180 	.word	0x400d8180
    1218:	20001ba8 	.word	0x20001ba8
    121c:	20001bb0 	.word	0x20001bb0
    1220:	20001bb4 	.word	0x20001bb4
    1224:	20001bac 	.word	0x20001bac

00001228 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    1228:	6b83      	ldr	r3, [r0, #56]	; 0x38
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
    122a:	b4f0      	push	{r4, r5, r6, r7}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    122c:	b11b      	cbz	r3, 1236 <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    122e:	6853      	ldr	r3, [r2, #4]
    1230:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    1234:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    1236:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    1238:	6b44      	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    123a:	b35c      	cbz	r4, 1294 <schedule_transfer+0x6c>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    123c:	4b1c      	ldr	r3, [pc, #112]	; (12b0 <schedule_transfer+0x88>)
	__disable_irq();
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
	if (last) {
		last->next = (uint32_t)transfer;
    123e:	6022      	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    1240:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
    1244:	420c      	tst	r4, r1
    1246:	d115      	bne.n	1274 <schedule_transfer+0x4c>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    1248:	4e1a      	ldr	r6, [pc, #104]	; (12b4 <schedule_transfer+0x8c>)
    124a:	6837      	ldr	r7, [r6, #0]
    124c:	e004      	b.n	1258 <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    124e:	6834      	ldr	r4, [r6, #0]
    1250:	1be4      	subs	r4, r4, r7
    1252:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
    1256:	d20b      	bcs.n	1270 <schedule_transfer+0x48>
		if (USB1_ENDPTPRIME & epmask) goto end;
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    1258:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    125c:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    1260:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    1264:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    1268:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    126c:	0464      	lsls	r4, r4, #17
    126e:	d5ee      	bpl.n	124e <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    1270:	400d      	ands	r5, r1
    1272:	d003      	beq.n	127c <schedule_transfer+0x54>
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    1274:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    1276:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1278:	bcf0      	pop	{r4, r5, r6, r7}
    127a:	4770      	bx	lr
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
    127c:	4c0c      	ldr	r4, [pc, #48]	; (12b0 <schedule_transfer+0x88>)
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
		endpoint->next = (uint32_t)transfer;
    127e:	6082      	str	r2, [r0, #8]
		endpoint->status = 0;
    1280:	60c5      	str	r5, [r0, #12]
		USB1_ENDPTPRIME |= epmask;
    1282:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1286:	4319      	orrs	r1, r3
    1288:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
	endpoint->first_transfer = transfer;
end:
	endpoint->last_transfer = transfer;
    128c:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    128e:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    1290:	bcf0      	pop	{r4, r5, r6, r7}
    1292:	4770      	bx	lr
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
	USB1_ENDPTPRIME |= epmask;
    1294:	4d06      	ldr	r5, [pc, #24]	; (12b0 <schedule_transfer+0x88>)
		endpoint->status = 0;
		USB1_ENDPTPRIME |= epmask;
		goto end;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
    1296:	6082      	str	r2, [r0, #8]
	endpoint->status = 0;
    1298:	60c4      	str	r4, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
    129a:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
    129e:	4319      	orrs	r1, r3
    12a0:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    12a4:	6302      	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
    12a6:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    12a8:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    12aa:	bcf0      	pop	{r4, r5, r6, r7}
    12ac:	4770      	bx	lr
    12ae:	bf00      	nop
    12b0:	402e0000 	.word	0x402e0000
    12b4:	e0001004 	.word	0xe0001004

000012b8 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    12b8:	b570      	push	{r4, r5, r6, lr}
    12ba:	4606      	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    12bc:	6b00      	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
    12be:	b190      	cbz	r0, 12e6 <run_callbacks+0x2e>
    12c0:	4602      	mov	r2, r0
    12c2:	2400      	movs	r4, #0
    12c4:	e003      	b.n	12ce <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    12c6:	6812      	ldr	r2, [r2, #0]
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
    12c8:	3401      	adds	r4, #1
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
    12ca:	2a01      	cmp	r2, #1
    12cc:	d00c      	beq.n	12e8 <run_callbacks+0x30>

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
    12ce:	6853      	ldr	r3, [r2, #4]
    12d0:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    12d4:	d0f7      	beq.n	12c6 <run_callbacks+0xe>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
    12d6:	6332      	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    12d8:	b12c      	cbz	r4, 12e6 <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
    12da:	6bb3      	ldr	r3, [r6, #56]	; 0x38
			break;
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
    12dc:	6805      	ldr	r5, [r0, #0]
		ep->callback_function(first);
    12de:	4798      	blx	r3
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    12e0:	3c01      	subs	r4, #1
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
    12e2:	4628      	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    12e4:	d1f9      	bne.n	12da <run_callbacks+0x22>
    12e6:	bd70      	pop	{r4, r5, r6, pc}
		count++;
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
    12e8:	6333      	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
    12ea:	6373      	str	r3, [r6, #52]	; 0x34
			break;
    12ec:	e7f4      	b.n	12d8 <run_callbacks+0x20>
    12ee:	bf00      	nop

000012f0 <endpoint0_transmit.constprop.1>:
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    12f0:	b5f0      	push	{r4, r5, r6, r7, lr}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
    12f2:	b9e1      	cbnz	r1, 132e <endpoint0_transmit.constprop.1+0x3e>
    12f4:	4c21      	ldr	r4, [pc, #132]	; (137c <endpoint0_transmit.constprop.1+0x8c>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    12f6:	4922      	ldr	r1, [pc, #136]	; (1380 <endpoint0_transmit.constprop.1+0x90>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    12f8:	2000      	movs	r0, #0
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    12fa:	4b22      	ldr	r3, [pc, #136]	; (1384 <endpoint0_transmit.constprop.1+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    12fc:	2201      	movs	r2, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    12fe:	f04f 1501 	mov.w	r5, #65537	; 0x10001
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1302:	2680      	movs	r6, #128	; 0x80
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1304:	600a      	str	r2, [r1, #0]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
	while (USB1_ENDPTPRIME) ;
    1306:	461a      	mov	r2, r3
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
    1308:	60a1      	str	r1, [r4, #8]
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    130a:	604e      	str	r6, [r1, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
    130c:	60e0      	str	r0, [r4, #12]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    130e:	f8c3 51bc 	str.w	r5, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    1312:	f8d3 41b0 	ldr.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    1316:	4d1c      	ldr	r5, [pc, #112]	; (1388 <endpoint0_transmit.constprop.1+0x98>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    1318:	f044 0401 	orr.w	r4, r4, #1
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    131c:	6088      	str	r0, [r1, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    131e:	f8c3 41b0 	str.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    1322:	6028      	str	r0, [r5, #0]
	while (USB1_ENDPTPRIME) ;
    1324:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    1328:	2b00      	cmp	r3, #0
    132a:	d1fb      	bne.n	1324 <endpoint0_transmit.constprop.1+0x34>
}
    132c:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    132e:	0409      	lsls	r1, r1, #16
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1330:	4b16      	ldr	r3, [pc, #88]	; (138c <endpoint0_transmit.constprop.1+0x9c>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1332:	4d14      	ldr	r5, [pc, #80]	; (1384 <endpoint0_transmit.constprop.1+0x94>)
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1334:	2601      	movs	r6, #1
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    1336:	4c11      	ldr	r4, [pc, #68]	; (137c <endpoint0_transmit.constprop.1+0x8c>)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1338:	f041 0180 	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    133c:	2200      	movs	r2, #0
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    133e:	601e      	str	r6, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1340:	6059      	str	r1, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1342:	f500 5c80 	add.w	ip, r0, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    1346:	64e2      	str	r2, [r4, #76]	; 0x4c
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1348:	f500 5e00 	add.w	lr, r0, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    134c:	64a3      	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    134e:	f500 5740 	add.w	r7, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    1352:	f8d5 11b0 	ldr.w	r1, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1356:	f500 4680 	add.w	r6, r0, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
    135a:	462a      	mov	r2, r5
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    135c:	6098      	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    135e:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1362:	f8c3 c00c 	str.w	ip, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    1366:	f8c3 e010 	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    136a:	615f      	str	r7, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    136c:	619e      	str	r6, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    136e:	f8c5 11b0 	str.w	r1, [r5, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    1372:	f8d2 31b0 	ldr.w	r3, [r2, #432]	; 0x1b0
    1376:	2b00      	cmp	r3, #0
    1378:	d1fb      	bne.n	1372 <endpoint0_transmit.constprop.1+0x82>
    137a:	e7bc      	b.n	12f6 <endpoint0_transmit.constprop.1+0x6>
    137c:	20000000 	.word	0x20000000
    1380:	20001c40 	.word	0x20001c40
    1384:	402e0000 	.word	0x402e0000
    1388:	20001af0 	.word	0x20001af0
    138c:	20001c20 	.word	0x20001c20

00001390 <usb_isr>:
	__builtin_unreachable();
}


void usb_isr(void)
{
    1390:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    1394:	4cb0      	ldr	r4, [pc, #704]	; (1658 <usb_isr+0x2c8>)
	__builtin_unreachable();
}


void usb_isr(void)
{
    1396:	b083      	sub	sp, #12
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    1398:	f8d4 8144 	ldr.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    139c:	f018 0f01 	tst.w	r8, #1
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
	USB1_USBSTS = status;
    13a0:	f8c4 8144 	str.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    13a4:	d06f      	beq.n	1486 <usb_isr+0xf6>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    13a6:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    13aa:	2b00      	cmp	r3, #0
    13ac:	d066      	beq.n	147c <usb_isr+0xec>
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    13ae:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
    13b2:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 167c <usb_isr+0x2ec>
    13b6:	4fa9      	ldr	r7, [pc, #676]	; (165c <usb_isr+0x2cc>)
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    13b8:	4626      	mov	r6, r4
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    13ba:	46da      	mov	sl, fp
	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
    13bc:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
    13c0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    13c2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    13c4:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    13c8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    13cc:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    13d0:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
    13d4:	049d      	lsls	r5, r3, #18
    13d6:	d5f5      	bpl.n	13c4 <usb_isr+0x34>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    13d8:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
    13dc:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    13e0:	f8c6 3140 	str.w	r3, [r6, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    13e4:	f8c6 a1b4 	str.w	sl, [r6, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    13e8:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
    13ec:	f013 1301 	ands.w	r3, r3, #65537	; 0x10001
    13f0:	d1fa      	bne.n	13e8 <usb_isr+0x58>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    13f2:	b281      	uxth	r1, r0
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
    13f4:	f8c9 3000 	str.w	r3, [r9]
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    13f8:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    13fc:	f000 8148 	beq.w	1690 <usb_isr+0x300>
    1400:	f200 80bb 	bhi.w	157a <usb_isr+0x1ea>
    1404:	2982      	cmp	r1, #130	; 0x82
    1406:	f000 8193 	beq.w	1730 <usb_isr+0x3a0>
    140a:	f240 80cf 	bls.w	15ac <usb_isr+0x21c>
    140e:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    1412:	f000 815d 	beq.w	16d0 <usb_isr+0x340>
    1416:	f240 3302 	movw	r3, #770	; 0x302
    141a:	4299      	cmp	r1, r3
    141c:	f040 80be 	bne.w	159c <usb_isr+0x20c>
			reply_buffer[0] = 1;
		}
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    1420:	b292      	uxth	r2, r2
    1422:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    1426:	2b07      	cmp	r3, #7
    1428:	f200 80b8 	bhi.w	159c <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    142c:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    1430:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1434:	4a8a      	ldr	r2, [pc, #552]	; (1660 <usb_isr+0x2d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1436:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    143a:	f04f 0001 	mov.w	r0, #1
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    143e:	441a      	add	r2, r3
    1440:	6813      	ldr	r3, [r2, #0]
    1442:	bf14      	ite	ne
    1444:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    1448:	f043 0301 	orreq.w	r3, r3, #1
    144c:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    144e:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1450:	4b84      	ldr	r3, [pc, #528]	; (1664 <usb_isr+0x2d4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1452:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1454:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1456:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1458:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    145a:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    145e:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1462:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1464:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    1468:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    146c:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1470:	2b00      	cmp	r3, #0
    1472:	d1fb      	bne.n	146c <usb_isr+0xdc>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1474:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1478:	2b00      	cmp	r3, #0
    147a:	d19f      	bne.n	13bc <usb_isr+0x2c>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    147c:	4a76      	ldr	r2, [pc, #472]	; (1658 <usb_isr+0x2c8>)
    147e:	f8d2 31bc 	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    1482:	2b00      	cmp	r3, #0
    1484:	d147      	bne.n	1516 <usb_isr+0x186>
			}
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
    1486:	f018 0f40 	tst.w	r8, #64	; 0x40
    148a:	d016      	beq.n	14ba <usb_isr+0x12a>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    148c:	4b72      	ldr	r3, [pc, #456]	; (1658 <usb_isr+0x2c8>)
    148e:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    1492:	4619      	mov	r1, r3
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    1494:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    1498:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    149c:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    14a0:	f8d1 31b0 	ldr.w	r3, [r1, #432]	; 0x1b0
    14a4:	4a6c      	ldr	r2, [pc, #432]	; (1658 <usb_isr+0x2c8>)
    14a6:	2b00      	cmp	r3, #0
    14a8:	d1fa      	bne.n	14a0 <usb_isr+0x110>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    14aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    14ae:	496e      	ldr	r1, [pc, #440]	; (1668 <usb_isr+0x2d8>)
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    14b0:	f8c2 01b4 	str.w	r0, [r2, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    14b4:	f8d2 2184 	ldr.w	r2, [r2, #388]	; 0x184
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
    14b8:	600b      	str	r3, [r1, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
    14ba:	f018 7f80 	tst.w	r8, #16777216	; 0x1000000
    14be:	d003      	beq.n	14c8 <usb_isr+0x138>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    14c0:	4b6a      	ldr	r3, [pc, #424]	; (166c <usb_isr+0x2dc>)
    14c2:	681b      	ldr	r3, [r3, #0]
    14c4:	b103      	cbz	r3, 14c8 <usb_isr+0x138>
    14c6:	4798      	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
    14c8:	f018 7f00 	tst.w	r8, #33554432	; 0x2000000
    14cc:	d003      	beq.n	14d6 <usb_isr+0x146>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    14ce:	4b68      	ldr	r3, [pc, #416]	; (1670 <usb_isr+0x2e0>)
    14d0:	681b      	ldr	r3, [r3, #0]
    14d2:	b103      	cbz	r3, 14d6 <usb_isr+0x146>
    14d4:	4798      	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
    14d6:	f018 0f04 	tst.w	r8, #4
    14da:	d008      	beq.n	14ee <usb_isr+0x15e>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    14dc:	4b5e      	ldr	r3, [pc, #376]	; (1658 <usb_isr+0x2c8>)
    14de:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    14e2:	f413 7300 	ands.w	r3, r3, #512	; 0x200
    14e6:	d045      	beq.n	1574 <usb_isr+0x1e4>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
    14e8:	4b62      	ldr	r3, [pc, #392]	; (1674 <usb_isr+0x2e4>)
    14ea:	2201      	movs	r2, #1
    14ec:	701a      	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    14ee:	4b5a      	ldr	r3, [pc, #360]	; (1658 <usb_isr+0x2c8>)
    14f0:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    14f4:	0612      	lsls	r2, r2, #24
    14f6:	d50b      	bpl.n	1510 <usb_isr+0x180>
    14f8:	f018 0f80 	tst.w	r8, #128	; 0x80
    14fc:	d008      	beq.n	1510 <usb_isr+0x180>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
    14fe:	495e      	ldr	r1, [pc, #376]	; (1678 <usb_isr+0x2e8>)
    1500:	780a      	ldrb	r2, [r1, #0]
    1502:	b12a      	cbz	r2, 1510 <usb_isr+0x180>
			if (--usb_reboot_timer == 0) {
    1504:	3a01      	subs	r2, #1
    1506:	b2d2      	uxtb	r2, r2
    1508:	700a      	strb	r2, [r1, #0]
    150a:	2a00      	cmp	r2, #0
    150c:	f000 8217 	beq.w	193e <usb_isr+0x5ae>
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
    1510:	b003      	add	sp, #12
    1512:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    1516:	4959      	ldr	r1, [pc, #356]	; (167c <usb_isr+0x2ec>)
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
    1518:	f8c2 31bc 	str.w	r3, [r2, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    151c:	6808      	ldr	r0, [r1, #0]
    151e:	4203      	tst	r3, r0
    1520:	f040 81b1 	bne.w	1886 <usb_isr+0x4f6>
				endpoint0_notify_mask = 0;
				endpoint0_complete();
			}
			completestatus &= endpointN_notify_mask;
    1524:	4a50      	ldr	r2, [pc, #320]	; (1668 <usb_isr+0x2d8>)
    1526:	6815      	ldr	r5, [r2, #0]
#if 1
			if (completestatus) {
    1528:	401d      	ands	r5, r3
    152a:	d0ac      	beq.n	1486 <usb_isr+0xf6>

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    152c:	0c2e      	lsrs	r6, r5, #16
    152e:	d00f      	beq.n	1550 <usb_isr+0x1c0>
    1530:	4f4a      	ldr	r7, [pc, #296]	; (165c <usb_isr+0x2cc>)
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
    1532:	f04f 0901 	mov.w	r9, #1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
    1536:	fa96 f4a6 	rbit	r4, r6
    153a:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    153e:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					tx &= ~(1<<p);
    1542:	fa09 f404 	lsl.w	r4, r9, r4

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    1546:	3040      	adds	r0, #64	; 0x40
    1548:	f7ff feb6 	bl	12b8 <run_callbacks>
#if 1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    154c:	43a6      	bics	r6, r4
    154e:	d1f2      	bne.n	1536 <usb_isr+0x1a6>
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
    1550:	b2ad      	uxth	r5, r5
				while(rx) {
    1552:	2d00      	cmp	r5, #0
    1554:	d097      	beq.n	1486 <usb_isr+0xf6>
    1556:	4f41      	ldr	r7, [pc, #260]	; (165c <usb_isr+0x2cc>)
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
					rx &= ~(1<<p);
    1558:	2601      	movs	r6, #1
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
    155a:	fa95 f4a5 	rbit	r4, r5
    155e:	fab4 f484 	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2);
    1562:	eb07 10c4 	add.w	r0, r7, r4, lsl #7
					rx &= ~(1<<p);
    1566:	fa06 f404 	lsl.w	r4, r6, r4

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
    156a:	f7ff fea5 	bl	12b8 <run_callbacks>
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
    156e:	43a5      	bics	r5, r4
    1570:	d1f3      	bne.n	155a <usb_isr+0x1ca>
    1572:	e788      	b.n	1486 <usb_isr+0xf6>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
    1574:	4a3f      	ldr	r2, [pc, #252]	; (1674 <usb_isr+0x2e4>)
    1576:	7013      	strb	r3, [r2, #0]
    1578:	e7b9      	b.n	14ee <usb_isr+0x15e>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    157a:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    157e:	f000 80f5 	beq.w	176c <usb_isr+0x3dc>
    1582:	d922      	bls.n	15ca <usb_isr+0x23a>
    1584:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    1588:	f000 80fe 	beq.w	1788 <usb_isr+0x3f8>
    158c:	f640 1521 	movw	r5, #2337	; 0x921
    1590:	42a9      	cmp	r1, r5
    1592:	d103      	bne.n	159c <usb_isr+0x20c>
		endpoint0_receive(endpoint0_buffer, 7, 1);
		return;
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
    1594:	0c11      	lsrs	r1, r2, #16
    1596:	2908      	cmp	r1, #8
    1598:	f240 8126 	bls.w	17e8 <usb_isr+0x458>
		}
		break;
#endif
	}
	printf("endpoint 0 stall\n");
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    159c:	f8c4 b1c0 	str.w	fp, [r4, #448]	; 0x1c0
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    15a0:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    15a4:	2b00      	cmp	r3, #0
    15a6:	f47f af09 	bne.w	13bc <usb_isr+0x2c>
    15aa:	e767      	b.n	147c <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    15ac:	2980      	cmp	r1, #128	; 0x80
    15ae:	d1f5      	bne.n	159c <usb_isr+0x20c>
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    15b0:	4a33      	ldr	r2, [pc, #204]	; (1680 <usb_isr+0x2f0>)
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
    15b2:	2102      	movs	r1, #2
    15b4:	4610      	mov	r0, r2
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    15b6:	7013      	strb	r3, [r2, #0]
		reply_buffer[1] = 0;
    15b8:	7053      	strb	r3, [r2, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
    15ba:	f7ff fe99 	bl	12f0 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    15be:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    15c2:	2b00      	cmp	r3, #0
    15c4:	f47f aefa 	bne.w	13bc <usb_isr+0x2c>
    15c8:	e758      	b.n	147c <usb_isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    15ca:	f5a1 61d0 	sub.w	r1, r1, #1664	; 0x680
    15ce:	2901      	cmp	r1, #1
    15d0:	d8e4      	bhi.n	159c <usb_isr+0x20c>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    15d2:	4b2c      	ldr	r3, [pc, #176]	; (1684 <usb_isr+0x2f4>)
    15d4:	6859      	ldr	r1, [r3, #4]
    15d6:	2900      	cmp	r1, #0
    15d8:	d0e0      	beq.n	159c <usb_isr+0x20c>
    15da:	0c00      	lsrs	r0, r0, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    15dc:	fa1f fe82 	uxth.w	lr, r2
    15e0:	e003      	b.n	15ea <usb_isr+0x25a>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    15e2:	330c      	adds	r3, #12
    15e4:	6859      	ldr	r1, [r3, #4]
    15e6:	2900      	cmp	r1, #0
    15e8:	d0d8      	beq.n	159c <usb_isr+0x20c>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    15ea:	881d      	ldrh	r5, [r3, #0]
    15ec:	4285      	cmp	r5, r0
    15ee:	d1f8      	bne.n	15e2 <usb_isr+0x252>
    15f0:	885d      	ldrh	r5, [r3, #2]
    15f2:	4575      	cmp	r5, lr
    15f4:	d1f5      	bne.n	15e2 <usb_isr+0x252>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
    15f6:	0a05      	lsrs	r5, r0, #8
    15f8:	2d03      	cmp	r5, #3
    15fa:	f000 817b 	beq.w	18f4 <usb_isr+0x564>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
    15fe:	891b      	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    1600:	0c12      	lsrs	r2, r2, #16
    1602:	4293      	cmp	r3, r2
    1604:	bf28      	it	cs
    1606:	4613      	movcs	r3, r2

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
    1608:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    160c:	f000 8163 	beq.w	18d6 <usb_isr+0x546>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
    1610:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
    1614:	f000 814c 	beq.w	18b0 <usb_isr+0x520>
    1618:	4d1b      	ldr	r5, [pc, #108]	; (1688 <usb_isr+0x2f8>)
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
					usb_descriptor_buffer[1] = 7;
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    161a:	461a      	mov	r2, r3
    161c:	9301      	str	r3, [sp, #4]
    161e:	4628      	mov	r0, r5
    1620:	f001 fc36 	bl	2e90 <memcpy>
    1624:	9b01      	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    1626:	f025 021f 	bic.w	r2, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    162a:	441d      	add	r5, r3
	asm volatile("": : :"memory");
	asm("dsb");
    162c:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    1630:	4916      	ldr	r1, [pc, #88]	; (168c <usb_isr+0x2fc>)
    1632:	600a      	str	r2, [r1, #0]
		location += 32;
    1634:	3220      	adds	r2, #32
	} while (location < end_addr);
    1636:	4295      	cmp	r5, r2
    1638:	d8fa      	bhi.n	1630 <usb_isr+0x2a0>
	asm("dsb");
    163a:	f3bf 8f4f 	dsb	sy
	asm("isb");
    163e:	f3bf 8f6f 	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    1642:	4811      	ldr	r0, [pc, #68]	; (1688 <usb_isr+0x2f8>)
    1644:	4619      	mov	r1, r3
    1646:	f7ff fe53 	bl	12f0 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    164a:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    164e:	2b00      	cmp	r3, #0
    1650:	f47f aeb4 	bne.w	13bc <usb_isr+0x2c>
    1654:	e712      	b.n	147c <usb_isr+0xec>
    1656:	bf00      	nop
    1658:	402e0000 	.word	0x402e0000
    165c:	20000000 	.word	0x20000000
    1660:	402e01c0 	.word	0x402e01c0
    1664:	20001c40 	.word	0x20001c40
    1668:	20001af4 	.word	0x20001af4
    166c:	20001bec 	.word	0x20001bec
    1670:	20001bf0 	.word	0x20001bf0
    1674:	20001c05 	.word	0x20001c05
    1678:	20001c06 	.word	0x20001c06
    167c:	20001af0 	.word	0x20001af0
    1680:	20001b78 	.word	0x20001b78
    1684:	20000748 	.word	0x20000748
    1688:	20200000 	.word	0x20200000
    168c:	e000ef70 	.word	0xe000ef70
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1690:	4ab2      	ldr	r2, [pc, #712]	; (195c <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1692:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1694:	2501      	movs	r5, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1696:	64fb      	str	r3, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1698:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    169a:	6015      	str	r5, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    169c:	6051      	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    169e:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    16a2:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    16a6:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    16a8:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
    16ac:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    16b0:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    16b4:	2b00      	cmp	r3, #0
    16b6:	d1fb      	bne.n	16b0 <usb_isr+0x320>

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    16b8:	0c03      	lsrs	r3, r0, #16
    16ba:	065b      	lsls	r3, r3, #25
    16bc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    16c0:	f8c6 3154 	str.w	r3, [r6, #340]	; 0x154
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    16c4:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    16c8:	2b00      	cmp	r3, #0
    16ca:	f47f ae77 	bne.w	13bc <usb_isr+0x2c>
    16ce:	e6d5      	b.n	147c <usb_isr+0xec>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    16d0:	b292      	uxth	r2, r2
    16d2:	f002 037f 	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    16d6:	2b07      	cmp	r3, #7
    16d8:	f63f af60 	bhi.w	159c <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		if (dir) {
    16dc:	f012 0f80 	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    16e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
    16e4:	4a9e      	ldr	r2, [pc, #632]	; (1960 <usb_isr+0x5d0>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    16e6:	f04f 0100 	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    16ea:	f04f 0001 	mov.w	r0, #1
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    16ee:	441a      	add	r2, r3
    16f0:	6813      	ldr	r3, [r2, #0]
    16f2:	bf14      	ite	ne
    16f4:	f423 3380 	bicne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    16f8:	f023 0301 	biceq.w	r3, r3, #1
    16fc:	6013      	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    16fe:	2280      	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1700:	4b96      	ldr	r3, [pc, #600]	; (195c <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1702:	64f9      	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    1704:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1706:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1708:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    170a:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    170e:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    1712:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    1714:	f442 3380 	orr.w	r3, r2, #65536	; 0x10000
    1718:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    171c:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    1720:	2b00      	cmp	r3, #0
    1722:	d1fb      	bne.n	171c <usb_isr+0x38c>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1724:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1728:	2b00      	cmp	r3, #0
    172a:	f47f ae47 	bne.w	13bc <usb_isr+0x2c>
    172e:	e6a5      	b.n	147c <usb_isr+0xec>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
    1730:	b292      	uxth	r2, r2
    1732:	f002 017f 	and.w	r1, r2, #127	; 0x7f
		if (endpoint > 7) break;
    1736:	2907      	cmp	r1, #7
    1738:	f63f af30 	bhi.w	159c <usb_isr+0x20c>
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    173c:	0089      	lsls	r1, r1, #2
    173e:	4888      	ldr	r0, [pc, #544]	; (1960 <usb_isr+0x5d0>)
		reply_buffer[0] = 0;
    1740:	4d88      	ldr	r5, [pc, #544]	; (1964 <usb_isr+0x5d4>)
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    1742:	4408      	add	r0, r1
    1744:	6801      	ldr	r1, [r0, #0]
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    1746:	0610      	lsls	r0, r2, #24
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
    1748:	702b      	strb	r3, [r5, #0]
		reply_buffer[1] = 0;
    174a:	706b      	strb	r3, [r5, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    174c:	f140 8097 	bpl.w	187e <usb_isr+0x4ee>
    1750:	03ca      	lsls	r2, r1, #15
    1752:	d501      	bpl.n	1758 <usb_isr+0x3c8>
			reply_buffer[0] = 1;
    1754:	2301      	movs	r3, #1
    1756:	702b      	strb	r3, [r5, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
    1758:	2102      	movs	r1, #2
    175a:	4882      	ldr	r0, [pc, #520]	; (1964 <usb_isr+0x5d4>)
    175c:	f7ff fdc8 	bl	12f0 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1760:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1764:	2b00      	cmp	r3, #0
    1766:	f47f ae29 	bne.w	13bc <usb_isr+0x2c>
    176a:	e687      	b.n	147c <usb_isr+0xec>
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    176c:	4a7e      	ldr	r2, [pc, #504]	; (1968 <usb_isr+0x5d8>)
		endpoint0_transmit(reply_buffer, 1, 0);
    176e:	2101      	movs	r1, #1
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    1770:	4b7c      	ldr	r3, [pc, #496]	; (1964 <usb_isr+0x5d4>)
    1772:	7812      	ldrb	r2, [r2, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    1774:	4618      	mov	r0, r3
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    1776:	701a      	strb	r2, [r3, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    1778:	f7ff fdba 	bl	12f0 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    177c:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1780:	2b00      	cmp	r3, #0
    1782:	f47f ae1b 	bne.w	13bc <usb_isr+0x2c>
    1786:	e679      	b.n	147c <usb_isr+0xec>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    1788:	f3c0 4007 	ubfx	r0, r0, #16, #8
    178c:	4a76      	ldr	r2, [pc, #472]	; (1968 <usb_isr+0x5d8>)
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    178e:	4977      	ldr	r1, [pc, #476]	; (196c <usb_isr+0x5dc>)
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    1790:	f04f 15cc 	mov.w	r5, #13369548	; 0xcc00cc
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    1794:	7010      	strb	r0, [r2, #0]
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    1796:	4a76      	ldr	r2, [pc, #472]	; (1970 <usb_isr+0x5e0>)
    1798:	9301      	str	r3, [sp, #4]
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    179a:	f8c6 51c8 	str.w	r5, [r6, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    179e:	f8c6 11cc 	str.w	r1, [r6, #460]	; 0x1cc
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    17a2:	f8c6 21d0 	str.w	r2, [r6, #464]	; 0x1d0
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
		#elif defined(SEREMU_INTERFACE)
		usb_seremu_configure();
    17a6:	f000 fab3 	bl	1d10 <usb_seremu_configure>
		#endif
		#if defined(CDC3_STATUS_INTERFACE) && defined(CDC3_DATA_INTERFACE)
		usb_serial3_configure();
		#endif
		#if defined(RAWHID_INTERFACE)
		usb_rawhid_configure();
    17aa:	f000 fa19 	bl	1be0 <usb_rawhid_configure>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    17ae:	4a6b      	ldr	r2, [pc, #428]	; (195c <usb_isr+0x5cc>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    17b0:	9b01      	ldr	r3, [sp, #4]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    17b2:	2180      	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    17b4:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    17b6:	64ba      	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    17b8:	6051      	str	r1, [r2, #4]
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    17ba:	6010      	str	r0, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    17bc:	64fb      	str	r3, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    17be:	f8c6 b1bc 	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    17c2:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    17c6:	6093      	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    17c8:	f441 3280 	orr.w	r2, r1, #65536	; 0x10000
    17cc:	f8c6 21b0 	str.w	r2, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    17d0:	4a68      	ldr	r2, [pc, #416]	; (1974 <usb_isr+0x5e4>)
    17d2:	6013      	str	r3, [r2, #0]
	while (USB1_ENDPTPRIME) ;
    17d4:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    17d8:	2b00      	cmp	r3, #0
    17da:	d1fb      	bne.n	17d4 <usb_isr+0x444>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    17dc:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    17e0:	2b00      	cmp	r3, #0
    17e2:	f47f adeb 	bne.w	13bc <usb_isr+0x2c>
    17e6:	e649      	b.n	147c <usb_isr+0xec>
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    17e8:	f8df e194 	ldr.w	lr, [pc, #404]	; 1980 <usb_isr+0x5f0>
			endpoint0_buffer[0] = 0xE9;
    17ec:	f04f 0ce9 	mov.w	ip, #233	; 0xe9
    17f0:	4d61      	ldr	r5, [pc, #388]	; (1978 <usb_isr+0x5e8>)
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
    17f2:	e88e 0005 	stmia.w	lr, {r0, r2}
			endpoint0_buffer[0] = 0xE9;
    17f6:	f885 c000 	strb.w	ip, [r5]
}

static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
    17fa:	b301      	cbz	r1, 183e <usb_isr+0x4ae>
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    17fc:	0409      	lsls	r1, r1, #16
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    17fe:	4a5f      	ldr	r2, [pc, #380]	; (197c <usb_isr+0x5ec>)
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
    1800:	60fb      	str	r3, [r7, #12]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    1802:	2001      	movs	r0, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1804:	f041 0380 	orr.w	r3, r1, #128	; 0x80
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    1808:	60ba      	str	r2, [r7, #8]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    180a:	6010      	str	r0, [r2, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    180c:	f505 5e00 	add.w	lr, r5, #8192	; 0x2000
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    1810:	6053      	str	r3, [r2, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1812:	f505 5080 	add.w	r0, r5, #4096	; 0x1000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    1816:	f8d6 31b0 	ldr.w	r3, [r6, #432]	; 0x1b0
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    181a:	f505 5140 	add.w	r1, r5, #12288	; 0x3000
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    181e:	6095      	str	r5, [r2, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1820:	f505 4580 	add.w	r5, r5, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    1824:	f043 0301 	orr.w	r3, r3, #1
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    1828:	60d0      	str	r0, [r2, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    182a:	f8c2 e010 	str.w	lr, [r2, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    182e:	6151      	str	r1, [r2, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    1830:	6195      	str	r5, [r2, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    1832:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    1836:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    183a:	2b00      	cmp	r3, #0
    183c:	d1fb      	bne.n	1836 <usb_isr+0x4a6>
	}
	endpoint0_transfer_ack.next = 1;
    183e:	4b47      	ldr	r3, [pc, #284]	; (195c <usb_isr+0x5cc>)
    1840:	2001      	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1842:	f248 0280 	movw	r2, #32896	; 0x8080
	endpoint0_transfer_ack.pointer0 = 0;
    1846:	2100      	movs	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    1848:	6018      	str	r0, [r3, #0]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    184a:	f44f 3080 	mov.w	r0, #65536	; 0x10000
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    184e:	64bb      	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    1850:	605a      	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    1852:	64f9      	str	r1, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    1854:	f8c4 b1bc 	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    1858:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    185c:	6099      	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    185e:	ea42 0300 	orr.w	r3, r2, r0
    1862:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    1866:	f8c9 0000 	str.w	r0, [r9]
	while (USB1_ENDPTPRIME) ;
    186a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    186e:	2b00      	cmp	r3, #0
    1870:	d1fb      	bne.n	186a <usb_isr+0x4da>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    1872:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    1876:	2b00      	cmp	r3, #0
    1878:	f47f ada0 	bne.w	13bc <usb_isr+0x2c>
    187c:	e5fe      	b.n	147c <usb_isr+0xec>
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    187e:	07cb      	lsls	r3, r1, #31
    1880:	f57f af6a 	bpl.w	1758 <usb_isr+0x3c8>
    1884:	e766      	b.n	1754 <usb_isr+0x3c4>

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    1886:	483e      	ldr	r0, [pc, #248]	; (1980 <usb_isr+0x5f0>)
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    1888:	2600      	movs	r6, #0
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    188a:	4c3e      	ldr	r4, [pc, #248]	; (1984 <usb_isr+0x5f4>)

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    188c:	6805      	ldr	r5, [r0, #0]
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    188e:	600e      	str	r6, [r1, #0]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    1890:	42a5      	cmp	r5, r4

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    1892:	6840      	ldr	r0, [r0, #4]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
    1894:	f47f ae46 	bne.w	1524 <usb_isr+0x194>
    1898:	493b      	ldr	r1, [pc, #236]	; (1988 <usb_isr+0x5f8>)
    189a:	4288      	cmp	r0, r1
    189c:	f47f ae42 	bne.w	1524 <usb_isr+0x194>
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    18a0:	4935      	ldr	r1, [pc, #212]	; (1978 <usb_isr+0x5e8>)
    18a2:	7808      	ldrb	r0, [r1, #0]
    18a4:	28a9      	cmp	r0, #169	; 0xa9
    18a6:	d02b      	beq.n	1900 <usb_isr+0x570>
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
		} else {
			// any other feature report means Arduino Serial Monitor is open
			usb_seremu_online = 1;
    18a8:	4a38      	ldr	r2, [pc, #224]	; (198c <usb_isr+0x5fc>)
    18aa:	2101      	movs	r1, #1
    18ac:	7011      	strb	r1, [r2, #0]
    18ae:	e639      	b.n	1524 <usb_isr+0x194>
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    18b0:	4837      	ldr	r0, [pc, #220]	; (1990 <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    18b2:	461a      	mov	r2, r3
    18b4:	4d37      	ldr	r5, [pc, #220]	; (1994 <usb_isr+0x604>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    18b6:	f890 e000 	ldrb.w	lr, [r0]
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
    18ba:	4937      	ldr	r1, [pc, #220]	; (1998 <usb_isr+0x608>)
    18bc:	4837      	ldr	r0, [pc, #220]	; (199c <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
    18be:	9301      	str	r3, [sp, #4]
    18c0:	f1be 0f00 	cmp.w	lr, #0
    18c4:	bf08      	it	eq
    18c6:	4601      	moveq	r1, r0
    18c8:	4628      	mov	r0, r5
    18ca:	f001 fae1 	bl	2e90 <memcpy>
					usb_descriptor_buffer[1] = 7;
    18ce:	2207      	movs	r2, #7
    18d0:	9b01      	ldr	r3, [sp, #4]
    18d2:	706a      	strb	r2, [r5, #1]
    18d4:	e6a7      	b.n	1626 <usb_isr+0x296>

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
    18d6:	482e      	ldr	r0, [pc, #184]	; (1990 <usb_isr+0x600>)
					memcpy(usb_descriptor_buffer, src, datalen);
    18d8:	461a      	mov	r2, r3
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    18da:	4930      	ldr	r1, [pc, #192]	; (199c <usb_isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_480;
    18dc:	7805      	ldrb	r5, [r0, #0]
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    18de:	482e      	ldr	r0, [pc, #184]	; (1998 <usb_isr+0x608>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
    18e0:	9301      	str	r3, [sp, #4]
    18e2:	2d00      	cmp	r5, #0
    18e4:	bf08      	it	eq
    18e6:	4601      	moveq	r1, r0
    18e8:	482a      	ldr	r0, [pc, #168]	; (1994 <usb_isr+0x604>)
    18ea:	f001 fad1 	bl	2e90 <memcpy>
    18ee:	4d29      	ldr	r5, [pc, #164]	; (1994 <usb_isr+0x604>)
    18f0:	9b01      	ldr	r3, [sp, #4]
    18f2:	e698      	b.n	1626 <usb_isr+0x296>
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    18f4:	0c12      	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
    18f6:	780b      	ldrb	r3, [r1, #0]
    18f8:	4293      	cmp	r3, r2
    18fa:	bf28      	it	cs
    18fc:	4613      	movcs	r3, r2
    18fe:	e687      	b.n	1610 <usb_isr+0x280>
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
    1900:	7848      	ldrb	r0, [r1, #1]
    1902:	2845      	cmp	r0, #69	; 0x45
    1904:	d1d0      	bne.n	18a8 <usb_isr+0x518>
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
    1906:	7888      	ldrb	r0, [r1, #2]
    1908:	28c2      	cmp	r0, #194	; 0xc2
    190a:	d1cd      	bne.n	18a8 <usb_isr+0x518>
    190c:	78c9      	ldrb	r1, [r1, #3]
    190e:	296b      	cmp	r1, #107	; 0x6b
    1910:	d1ca      	bne.n	18a8 <usb_isr+0x518>
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
    1912:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    1914:	4822      	ldr	r0, [pc, #136]	; (19a0 <usb_isr+0x610>)
    1916:	7801      	ldrb	r1, [r0, #0]
    1918:	f041 0104 	orr.w	r1, r1, #4
    191c:	7001      	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    191e:	f8d2 1148 	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    1922:	0608      	lsls	r0, r1, #24
    1924:	d406      	bmi.n	1934 <usb_isr+0x5a4>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    1926:	f041 0180 	orr.w	r1, r1, #128	; 0x80
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    192a:	2080      	movs	r0, #128	; 0x80
    192c:	f8c2 0144 	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    1930:	f8c2 1148 	str.w	r1, [r2, #328]	; 0x148
	}
	__enable_irq();
    1934:	b662      	cpsie	i
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)) {
		if (endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
		  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
			printf("seremu reboot request\n");
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    1936:	4a1b      	ldr	r2, [pc, #108]	; (19a4 <usb_isr+0x614>)
    1938:	2150      	movs	r1, #80	; 0x50
    193a:	7011      	strb	r1, [r2, #0]
    193c:	e5f2      	b.n	1524 <usb_isr+0x194>
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
    193e:	4918      	ldr	r1, [pc, #96]	; (19a0 <usb_isr+0x610>)
    1940:	780a      	ldrb	r2, [r1, #0]
    1942:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    1946:	700a      	strb	r2, [r1, #0]
	if (sof_usage == 0) {
    1948:	b92a      	cbnz	r2, 1956 <usb_isr+0x5c6>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    194a:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    194e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    1952:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
			if (--usb_reboot_timer == 0) {
				usb_stop_sof_interrupts(NUM_INTERFACE);
				_reboot_Teensyduino_();
    1956:	f004 fecb 	bl	66f0 <___reboot_Teensyduino__veneer>
    195a:	bf00      	nop
    195c:	20001c40 	.word	0x20001c40
    1960:	402e01c0 	.word	0x402e01c0
    1964:	20001b78 	.word	0x20001b78
    1968:	20001c04 	.word	0x20001c04
    196c:	00cc0002 	.word	0x00cc0002
    1970:	000200cc 	.word	0x000200cc
    1974:	20001af0 	.word	0x20001af0
    1978:	20001ae8 	.word	0x20001ae8
    197c:	20001c20 	.word	0x20001c20
    1980:	20001a60 	.word	0x20001a60
    1984:	03000921 	.word	0x03000921
    1988:	00040001 	.word	0x00040001
    198c:	20001c07 	.word	0x20001c07
    1990:	20001c05 	.word	0x20001c05
    1994:	20200000 	.word	0x20200000
    1998:	60001eb8 	.word	0x60001eb8
    199c:	60001f04 	.word	0x60001f04
    19a0:	20001bff 	.word	0x20001bff
    19a4:	20001c06 	.word	0x20001c06

000019a8 <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    19a8:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    19aa:	f1a0 0202 	sub.w	r2, r0, #2
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    19ae:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    19b2:	bf14      	ite	ne
    19b4:	2700      	movne	r7, #0
    19b6:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    19ba:	2a02      	cmp	r2, #2
    19bc:	d901      	bls.n	19c2 <usb_config_rx+0x1a>
    19be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    19c2:	ea4f 19c0 	mov.w	r9, r0, lsl #7
    19c6:	f8df a040 	ldr.w	sl, [pc, #64]	; 1a08 <usb_config_rx+0x60>
    19ca:	460d      	mov	r5, r1
    19cc:	4604      	mov	r4, r0
    19ce:	eb0a 0609 	add.w	r6, sl, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    19d2:	2100      	movs	r1, #0
    19d4:	2240      	movs	r2, #64	; 0x40
    19d6:	4698      	mov	r8, r3
    19d8:	4630      	mov	r0, r6
    19da:	f001 fb57 	bl	308c <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    19de:	2001      	movs	r0, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    19e0:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
    19e4:	f84a 1009 	str.w	r1, [sl, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    19e8:	f8c6 8038 	str.w	r8, [r6, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    19ec:	60b0      	str	r0, [r6, #8]
void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
    19ee:	f1b8 0f00 	cmp.w	r8, #0
    19f2:	d0e4      	beq.n	19be <usb_config_rx+0x16>
    19f4:	4b03      	ldr	r3, [pc, #12]	; (1a04 <usb_config_rx+0x5c>)
    19f6:	40a0      	lsls	r0, r4
    19f8:	681c      	ldr	r4, [r3, #0]
    19fa:	4320      	orrs	r0, r4
    19fc:	6018      	str	r0, [r3, #0]
    19fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1a02:	bf00      	nop
    1a04:	20001af4 	.word	0x20001af4
    1a08:	20000000 	.word	0x20000000

00001a0c <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    1a0c:	2a00      	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    1a0e:	f1a0 0202 	sub.w	r2, r0, #2
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    1a12:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    1a16:	bf14      	ite	ne
    1a18:	2700      	movne	r7, #0
    1a1a:	f04f 5700 	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    1a1e:	2a02      	cmp	r2, #2
    1a20:	d901      	bls.n	1a26 <usb_config_tx+0x1a>
    1a22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    1a26:	2240      	movs	r2, #64	; 0x40

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    1a28:	01c5      	lsls	r5, r0, #7
    1a2a:	f8df 9044 	ldr.w	r9, [pc, #68]	; 1a70 <usb_config_tx+0x64>
    1a2e:	4688      	mov	r8, r1
    1a30:	4415      	add	r5, r2
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    1a32:	2100      	movs	r1, #0
    1a34:	4604      	mov	r4, r0
    1a36:	461e      	mov	r6, r3

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    1a38:	eb09 0a05 	add.w	sl, r9, r5
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    1a3c:	4650      	mov	r0, sl
    1a3e:	f001 fb25 	bl	308c <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    1a42:	2201      	movs	r2, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    1a44:	ea47 4108 	orr.w	r1, r7, r8, lsl #16
    1a48:	f849 1005 	str.w	r1, [r9, r5]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    1a4c:	f8ca 6038 	str.w	r6, [sl, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    1a50:	f8ca 2008 	str.w	r2, [sl, #8]
void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    1a54:	2e00      	cmp	r6, #0
    1a56:	d0e4      	beq.n	1a22 <usb_config_tx+0x16>
    1a58:	f104 0010 	add.w	r0, r4, #16
    1a5c:	4b03      	ldr	r3, [pc, #12]	; (1a6c <usb_config_tx+0x60>)
    1a5e:	4082      	lsls	r2, r0
    1a60:	6818      	ldr	r0, [r3, #0]
    1a62:	4302      	orrs	r2, r0
    1a64:	601a      	str	r2, [r3, #0]
    1a66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1a6a:	bf00      	nop
    1a6c:	20001af4 	.word	0x20001af4
    1a70:	20000000 	.word	0x20000000

00001a74 <usb_prepare_transfer>:


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    1a74:	0412      	lsls	r2, r2, #16
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
    1a76:	6081      	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
	transfer->pointer2 = addr + 8192;
	transfer->pointer3 = addr + 12288;
	transfer->pointer4 = addr + 16384;
	transfer->callback_param = param;
    1a78:	61c3      	str	r3, [r0, #28]


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    1a7a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
    1a7e:	b4f0      	push	{r4, r5, r6, r7}
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    1a80:	6042      	str	r2, [r0, #4]



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    1a82:	2701      	movs	r7, #1
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    1a84:	f501 5680 	add.w	r6, r1, #4096	; 0x1000
	transfer->pointer2 = addr + 8192;
    1a88:	f501 5500 	add.w	r5, r1, #8192	; 0x2000
	transfer->pointer3 = addr + 12288;
    1a8c:	f501 5440 	add.w	r4, r1, #12288	; 0x3000
	transfer->pointer4 = addr + 16384;
    1a90:	f501 4280 	add.w	r2, r1, #16384	; 0x4000



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    1a94:	6007      	str	r7, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    1a96:	60c6      	str	r6, [r0, #12]
	transfer->pointer2 = addr + 8192;
    1a98:	6105      	str	r5, [r0, #16]
	transfer->pointer3 = addr + 12288;
    1a9a:	6144      	str	r4, [r0, #20]
	transfer->pointer4 = addr + 16384;
    1a9c:	6182      	str	r2, [r0, #24]
	transfer->callback_param = param;
}
    1a9e:	bcf0      	pop	{r4, r5, r6, r7}
    1aa0:	4770      	bx	lr
    1aa2:	bf00      	nop

00001aa4 <usb_transmit>:
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    1aa4:	1e83      	subs	r3, r0, #2
    1aa6:	2b02      	cmp	r3, #2
    1aa8:	d900      	bls.n	1aac <usb_transmit+0x8>
    1aaa:	4770      	bx	lr
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    1aac:	4b06      	ldr	r3, [pc, #24]	; (1ac8 <usb_transmit+0x24>)
    1aae:	460a      	mov	r2, r1
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
    1ab0:	b430      	push	{r4, r5}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    1ab2:	f100 0410 	add.w	r4, r0, #16
    1ab6:	2501      	movs	r5, #1
    1ab8:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    1abc:	fa05 f104 	lsl.w	r1, r5, r4
    1ac0:	3040      	adds	r0, #64	; 0x40
}
    1ac2:	bc30      	pop	{r4, r5}
void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    1ac4:	f7ff bbb0 	b.w	1228 <schedule_transfer>
    1ac8:	20000000 	.word	0x20000000

00001acc <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    1acc:	1e83      	subs	r3, r0, #2
    1ace:	2b02      	cmp	r3, #2
    1ad0:	d900      	bls.n	1ad4 <usb_receive+0x8>
    1ad2:	4770      	bx	lr
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
    1ad4:	b410      	push	{r4}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    1ad6:	4b05      	ldr	r3, [pc, #20]	; (1aec <usb_receive+0x20>)
    1ad8:	2401      	movs	r4, #1
    1ada:	460a      	mov	r2, r1
    1adc:	fa04 f100 	lsl.w	r1, r4, r0
    1ae0:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
}
    1ae4:	f85d 4b04 	ldr.w	r4, [sp], #4
void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    1ae8:	f7ff bb9e 	b.w	1228 <schedule_transfer>
    1aec:	20000000 	.word	0x20000000

00001af0 <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    1af0:	6840      	ldr	r0, [r0, #4]
#endif
}
    1af2:	4770      	bx	lr

00001af4 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    1af4:	4a12      	ldr	r2, [pc, #72]	; (1b40 <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    1af6:	4b13      	ldr	r3, [pc, #76]	; (1b44 <usb_init_serialnumber+0x50>)
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    1af8:	f8d2 0220 	ldr.w	r0, [r2, #544]	; 0x220
    1afc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    1b00:	4298      	cmp	r0, r3
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    1b02:	b510      	push	{r4, lr}
    1b04:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    1b06:	d802      	bhi.n	1b0e <usb_init_serialnumber+0x1a>
    1b08:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    1b0c:	0040      	lsls	r0, r0, #1
    1b0e:	4c0e      	ldr	r4, [pc, #56]	; (1b48 <usb_init_serialnumber+0x54>)
	ultoa(num, buf, 10);
    1b10:	a901      	add	r1, sp, #4
    1b12:	220a      	movs	r2, #10
    1b14:	f7ff f86a 	bl	bec <ultoa>
    1b18:	a901      	add	r1, sp, #4
	for (i=0; i<10; i++) {
    1b1a:	2300      	movs	r3, #0
    1b1c:	4620      	mov	r0, r4
		char c = buf[i];
    1b1e:	f811 2b01 	ldrb.w	r2, [r1], #1
    1b22:	3301      	adds	r3, #1
		if (!c) break;
    1b24:	b13a      	cbz	r2, 1b36 <usb_init_serialnumber+0x42>

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    1b26:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    1b28:	f820 2f02 	strh.w	r2, [r0, #2]!

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    1b2c:	d1f7      	bne.n	1b1e <usb_init_serialnumber+0x2a>
    1b2e:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    1b30:	7023      	strb	r3, [r4, #0]
}
    1b32:	b004      	add	sp, #16
    1b34:	bd10      	pop	{r4, pc}
    1b36:	005b      	lsls	r3, r3, #1
    1b38:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    1b3a:	7023      	strb	r3, [r4, #0]
}
    1b3c:	b004      	add	sp, #16
    1b3e:	bd10      	pop	{r4, pc}
    1b40:	401f4400 	.word	0x401f4400
    1b44:	0098967f 	.word	0x0098967f
    1b48:	20001220 	.word	0x20001220

00001b4c <rx_event>:
static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    1b4c:	4a0a      	ldr	r2, [pc, #40]	; (1b78 <rx_event+0x2c>)
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
    1b4e:	b410      	push	{r4}
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    1b50:	7813      	ldrb	r3, [r2, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
    1b52:	69c4      	ldr	r4, [r0, #28]
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    1b54:	3301      	adds	r3, #1
    1b56:	2b04      	cmp	r3, #4
    1b58:	d907      	bls.n	1b6a <rx_event+0x1e>
    1b5a:	2100      	movs	r1, #0
	rx_list[head] = i;
    1b5c:	4807      	ldr	r0, [pc, #28]	; (1b7c <rx_event+0x30>)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    1b5e:	460b      	mov	r3, r1
	rx_list[head] = i;
	rx_head = head;
    1b60:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    1b62:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    1b64:	f85d 4b04 	ldr.w	r4, [sp], #4
    1b68:	4770      	bx	lr
    1b6a:	b2d9      	uxtb	r1, r3
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    1b6c:	4803      	ldr	r0, [pc, #12]	; (1b7c <rx_event+0x30>)
	rx_head = head;
    1b6e:	7011      	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    1b70:	54c4      	strb	r4, [r0, r3]
	rx_head = head;
}
    1b72:	f85d 4b04 	ldr.w	r4, [sp], #4
    1b76:	4770      	bx	lr
    1b78:	20001bfb 	.word	0x20001bfb
    1b7c:	20001b94 	.word	0x20001b94

00001b80 <rx_queue_transfer>:
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
    1b80:	4912      	ldr	r1, [pc, #72]	; (1bcc <rx_queue_transfer+0x4c>)
    1b82:	eb01 1180 	add.w	r1, r1, r0, lsl #6
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    1b86:	b538      	push	{r3, r4, r5, lr}
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    1b88:	f021 021f 	bic.w	r2, r1, #31
    1b8c:	4603      	mov	r3, r0
	uint32_t end_addr = (uint32_t)addr + size;
    1b8e:	f101 0540 	add.w	r5, r1, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    1b92:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    1b96:	4c0e      	ldr	r4, [pc, #56]	; (1bd0 <rx_queue_transfer+0x50>)
    1b98:	6022      	str	r2, [r4, #0]
		location += 32;
    1b9a:	3220      	adds	r2, #32
	} while (location < end_addr);
    1b9c:	4295      	cmp	r5, r2
    1b9e:	d8fb      	bhi.n	1b98 <rx_queue_transfer+0x18>
	asm("dsb");
    1ba0:	f3bf 8f4f 	dsb	sy
	asm("isb");
    1ba4:	f3bf 8f6f 	isb	sy
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    1ba8:	4c0a      	ldr	r4, [pc, #40]	; (1bd4 <rx_queue_transfer+0x54>)
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    1baa:	f44f 3500 	mov.w	r5, #131072	; 0x20000
    1bae:	4a0a      	ldr	r2, [pc, #40]	; (1bd8 <rx_queue_transfer+0x58>)
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    1bb0:	eb04 1443 	add.w	r4, r4, r3, lsl #5
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * RAWHID_RX_SIZE;
	arm_dcache_delete(buffer, RAWHID_RX_SIZE);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    1bb4:	6015      	str	r5, [r2, #0]
	usb_prepare_transfer(rx_transfer + i, buffer, RAWHID_RX_SIZE, i);
    1bb6:	2240      	movs	r2, #64	; 0x40
    1bb8:	4620      	mov	r0, r4
    1bba:	f7ff ff5b 	bl	1a74 <usb_prepare_transfer>
	usb_receive(RAWHID_RX_ENDPOINT, rx_transfer + i);
    1bbe:	4621      	mov	r1, r4
    1bc0:	2004      	movs	r0, #4
    1bc2:	f7ff ff83 	bl	1acc <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    1bc6:	4b05      	ldr	r3, [pc, #20]	; (1bdc <rx_queue_transfer+0x5c>)
    1bc8:	601d      	str	r5, [r3, #0]
    1bca:	bd38      	pop	{r3, r4, r5, pc}
    1bcc:	20200060 	.word	0x20200060
    1bd0:	e000ef5c 	.word	0xe000ef5c
    1bd4:	200016e0 	.word	0x200016e0
    1bd8:	e000e18c 	.word	0xe000e18c
    1bdc:	e000e10c 	.word	0xe000e10c

00001be0 <usb_rawhid_configure>:


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    1be0:	2100      	movs	r1, #0
    1be2:	4816      	ldr	r0, [pc, #88]	; (1c3c <usb_rawhid_configure+0x5c>)
static void rx_event(transfer_t *t);
extern volatile uint8_t usb_configuration;


void usb_rawhid_configure(void)
{
    1be4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    1be6:	2580      	movs	r5, #128	; 0x80
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    1be8:	460c      	mov	r4, r1
	rx_head = 0;
    1bea:	4f15      	ldr	r7, [pc, #84]	; (1c40 <usb_rawhid_configure+0x60>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    1bec:	462a      	mov	r2, r5
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    1bee:	4e15      	ldr	r6, [pc, #84]	; (1c44 <usb_rawhid_configure+0x64>)


void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    1bf0:	f001 fa4c 	bl	308c <memset>
	memset(rx_transfer, 0, sizeof(rx_transfer));
    1bf4:	462a      	mov	r2, r5
    1bf6:	4621      	mov	r1, r4
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
    1bf8:	4d13      	ldr	r5, [pc, #76]	; (1c48 <usb_rawhid_configure+0x68>)

void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
    1bfa:	4814      	ldr	r0, [pc, #80]	; (1c4c <usb_rawhid_configure+0x6c>)
    1bfc:	f001 fa46 	bl	308c <memset>
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    1c00:	4623      	mov	r3, r4
    1c02:	4622      	mov	r2, r4
    1c04:	2140      	movs	r1, #64	; 0x40
    1c06:	2003      	movs	r0, #3
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
	rx_head = 0;
    1c08:	703c      	strb	r4, [r7, #0]
void usb_rawhid_configure(void)
{
	printf("usb_rawhid_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    1c0a:	7034      	strb	r4, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
    1c0c:	702c      	strb	r4, [r5, #0]
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
    1c0e:	f7ff fefd 	bl	1a0c <usb_config_tx>
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
    1c12:	4622      	mov	r2, r4
    1c14:	4b0e      	ldr	r3, [pc, #56]	; (1c50 <usb_rawhid_configure+0x70>)
    1c16:	2140      	movs	r1, #64	; 0x40
    1c18:	2004      	movs	r0, #4
    1c1a:	f7ff fec5 	bl	19a8 <usb_config_rx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    1c1e:	4620      	mov	r0, r4
    1c20:	f7ff ffae 	bl	1b80 <rx_queue_transfer>
    1c24:	2001      	movs	r0, #1
    1c26:	f7ff ffab 	bl	1b80 <rx_queue_transfer>
    1c2a:	2002      	movs	r0, #2
    1c2c:	f7ff ffa8 	bl	1b80 <rx_queue_transfer>
    1c30:	2003      	movs	r0, #3
}
    1c32:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(RAWHID_TX_ENDPOINT, RAWHID_TX_SIZE, 0, NULL);
	usb_config_rx(RAWHID_RX_ENDPOINT, RAWHID_RX_SIZE, 0, rx_event);
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    1c36:	f7ff bfa3 	b.w	1b80 <rx_queue_transfer>
    1c3a:	bf00      	nop
    1c3c:	20001860 	.word	0x20001860
    1c40:	20001bfb 	.word	0x20001bfb
    1c44:	20001c01 	.word	0x20001c01
    1c48:	20001bfd 	.word	0x20001bfd
    1c4c:	200016e0 	.word	0x200016e0
    1c50:	00001b4d 	.word	0x00001b4d

00001c54 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    1c54:	b570      	push	{r4, r5, r6, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    1c56:	0141      	lsls	r1, r0, #5
    1c58:	4c12      	ldr	r4, [pc, #72]	; (1ca4 <rx_queue_transfer+0x50>)
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    1c5a:	4d13      	ldr	r5, [pc, #76]	; (1ca8 <rx_queue_transfer+0x54>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    1c5c:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
    1c5e:	440c      	add	r4, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    1c60:	f44f 3600 	mov.w	r6, #131072	; 0x20000
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    1c64:	440d      	add	r5, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    1c66:	4811      	ldr	r0, [pc, #68]	; (1cac <rx_queue_transfer+0x58>)
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    1c68:	4621      	mov	r1, r4
    1c6a:	2220      	movs	r2, #32
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    1c6c:	6006      	str	r6, [r0, #0]
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
    1c6e:	4628      	mov	r0, r5
    1c70:	f7ff ff00 	bl	1a74 <usb_prepare_transfer>
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    1c74:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    1c78:	f104 0120 	add.w	r1, r4, #32
	asm volatile("": : :"memory");
	asm("dsb");
    1c7c:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    1c80:	4a0b      	ldr	r2, [pc, #44]	; (1cb0 <rx_queue_transfer+0x5c>)
    1c82:	6013      	str	r3, [r2, #0]
		location += 32;
    1c84:	3320      	adds	r3, #32
	} while (location < end_addr);
    1c86:	4299      	cmp	r1, r3
    1c88:	d8fb      	bhi.n	1c82 <rx_queue_transfer+0x2e>
	asm("dsb");
    1c8a:	f3bf 8f4f 	dsb	sy
	asm("isb");
    1c8e:	f3bf 8f6f 	isb	sy
	arm_dcache_delete(buffer, SEREMU_RX_SIZE);
	usb_receive(SEREMU_RX_ENDPOINT, rx_transfer + i);
    1c92:	2002      	movs	r0, #2
    1c94:	4629      	mov	r1, r5
    1c96:	f7ff ff19 	bl	1acc <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    1c9a:	4b06      	ldr	r3, [pc, #24]	; (1cb4 <rx_queue_transfer+0x60>)
    1c9c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    1ca0:	601a      	str	r2, [r3, #0]
    1ca2:	bd70      	pop	{r4, r5, r6, pc}
    1ca4:	20200260 	.word	0x20200260
    1ca8:	20001760 	.word	0x20001760
    1cac:	e000e18c 	.word	0xe000e18c
    1cb0:	e000ef5c 	.word	0xe000ef5c
    1cb4:	e000e10c 	.word	0xe000e10c

00001cb8 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
    1cb8:	6843      	ldr	r3, [r0, #4]
	int i = t->callback_param;
    1cba:	69c0      	ldr	r0, [r0, #28]
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    1cbc:	f3c3 430e 	ubfx	r3, r3, #16, #15
    1cc0:	b10b      	cbz	r3, 1cc6 <rx_event+0xe>
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
    1cc2:	f7ff bfc7 	b.w	1c54 <rx_queue_transfer>
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
    1cc6:	490d      	ldr	r1, [pc, #52]	; (1cfc <rx_event+0x44>)
    1cc8:	0142      	lsls	r2, r0, #5
    1cca:	5c8a      	ldrb	r2, [r1, r2]
    1ccc:	2a00      	cmp	r2, #0
    1cce:	d0f8      	beq.n	1cc2 <rx_event+0xa>
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
    1cd0:	490b      	ldr	r1, [pc, #44]	; (1d00 <rx_event+0x48>)
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
    1cd2:	b410      	push	{r4}
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    1cd4:	4c0b      	ldr	r4, [pc, #44]	; (1d04 <rx_event+0x4c>)
		rx_index[i] = 0;
    1cd6:	f821 3010 	strh.w	r3, [r1, r0, lsl #1]
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
    1cda:	7822      	ldrb	r2, [r4, #0]
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
    1cdc:	490a      	ldr	r1, [pc, #40]	; (1d08 <rx_event+0x50>)
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    1cde:	3201      	adds	r2, #1
    1ce0:	2a08      	cmp	r2, #8
    1ce2:	bf94      	ite	ls
    1ce4:	b2d3      	uxtbls	r3, r2
    1ce6:	461a      	movhi	r2, r3
		rx_list[head] = i;
		rx_head = head;
    1ce8:	7023      	strb	r3, [r4, #0]
		rx_available += len;
    1cea:	680b      	ldr	r3, [r1, #0]
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    1cec:	4c07      	ldr	r4, [pc, #28]	; (1d0c <rx_event+0x54>)
		rx_head = head;
		rx_available += len;
    1cee:	3320      	adds	r3, #32
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    1cf0:	54a0      	strb	r0, [r4, r2]
		rx_head = head;
		rx_available += len;
    1cf2:	600b      	str	r3, [r1, #0]
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
	}
}
    1cf4:	f85d 4b04 	ldr.w	r4, [sp], #4
    1cf8:	4770      	bx	lr
    1cfa:	bf00      	nop
    1cfc:	20200260 	.word	0x20200260
    1d00:	20001b84 	.word	0x20001b84
    1d04:	20001bfc 	.word	0x20001bfc
    1d08:	20001b80 	.word	0x20001b80
    1d0c:	20001b9c 	.word	0x20001b9c

00001d10 <usb_seremu_configure>:


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    1d10:	2100      	movs	r1, #0
    1d12:	f44f 72c0 	mov.w	r2, #384	; 0x180
    1d16:	481f      	ldr	r0, [pc, #124]	; (1d94 <usb_seremu_configure+0x84>)
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_seremu_configure(void)
{
    1d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    1d1a:	460d      	mov	r5, r1
    1d1c:	4c1e      	ldr	r4, [pc, #120]	; (1d98 <usb_seremu_configure+0x88>)


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
    1d1e:	f001 f9b5 	bl	308c <memset>
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    1d22:	4e1e      	ldr	r6, [pc, #120]	; (1d9c <usb_seremu_configure+0x8c>)
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    1d24:	4b1e      	ldr	r3, [pc, #120]	; (1da0 <usb_seremu_configure+0x90>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    1d26:	4629      	mov	r1, r5
    1d28:	f44f 7280 	mov.w	r2, #256	; 0x100
    1d2c:	481d      	ldr	r0, [pc, #116]	; (1da4 <usb_seremu_configure+0x94>)

void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    1d2e:	7025      	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    1d30:	462c      	mov	r4, r5
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    1d32:	801d      	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    1d34:	f001 f9aa 	bl	308c <memset>
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    1d38:	7035      	strb	r5, [r6, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    1d3a:	462a      	mov	r2, r5
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    1d3c:	4e1a      	ldr	r6, [pc, #104]	; (1da8 <usb_seremu_configure+0x98>)
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    1d3e:	2120      	movs	r1, #32
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    1d40:	4b1a      	ldr	r3, [pc, #104]	; (1dac <usb_seremu_configure+0x9c>)
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    1d42:	2002      	movs	r0, #2
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    1d44:	4f1a      	ldr	r7, [pc, #104]	; (1db0 <usb_seremu_configure+0xa0>)
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    1d46:	701d      	strb	r5, [r3, #0]
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    1d48:	6035      	str	r5, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    1d4a:	4b1a      	ldr	r3, [pc, #104]	; (1db4 <usb_seremu_configure+0xa4>)
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
    1d4c:	6075      	str	r5, [r6, #4]
    1d4e:	60b5      	str	r5, [r6, #8]
    1d50:	60f5      	str	r5, [r6, #12]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    1d52:	603d      	str	r5, [r7, #0]
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
    1d54:	f7ff fe28 	bl	19a8 <usb_config_rx>
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
    1d58:	462b      	mov	r3, r5
    1d5a:	462a      	mov	r2, r5
    1d5c:	2140      	movs	r1, #64	; 0x40
    1d5e:	2002      	movs	r0, #2
    1d60:	f7ff fe54 	bl	1a0c <usb_config_tx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    1d64:	4620      	mov	r0, r4
    1d66:	3401      	adds	r4, #1
    1d68:	f7ff ff74 	bl	1c54 <rx_queue_transfer>
    1d6c:	2c08      	cmp	r4, #8
    1d6e:	d1f9      	bne.n	1d64 <usb_seremu_configure+0x54>
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
	USB1_GPTIMER0CTRL = 0;
    1d70:	4b11      	ldr	r3, [pc, #68]	; (1db8 <usb_seremu_configure+0xa8>)
	USB1_GPTIMER0LD = microseconds - 1;
    1d72:	224a      	movs	r2, #74	; 0x4a
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    1d74:	4811      	ldr	r0, [pc, #68]	; (1dbc <usb_seremu_configure+0xac>)
	USB1_GPTIMER0CTRL = 0;
    1d76:	2100      	movs	r1, #0
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    1d78:	4c11      	ldr	r4, [pc, #68]	; (1dc0 <usb_seremu_configure+0xb0>)
    1d7a:	6004      	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    1d7c:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    1d80:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    1d84:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    1d88:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    1d8c:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    1d90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1d92:	bf00      	nop
    1d94:	200018e0 	.word	0x200018e0
    1d98:	20001c02 	.word	0x20001c02
    1d9c:	20001bfc 	.word	0x20001bfc
    1da0:	20001bf4 	.word	0x20001bf4
    1da4:	20001760 	.word	0x20001760
    1da8:	20001b84 	.word	0x20001b84
    1dac:	20001bfe 	.word	0x20001bfe
    1db0:	20001b80 	.word	0x20001b80
    1db4:	00001cb9 	.word	0x00001cb9
    1db8:	402e0000 	.word	0x402e0000
    1dbc:	20001bec 	.word	0x20001bec
    1dc0:	00001f2d 	.word	0x00001f2d

00001dc4 <usb_seremu_getchar>:
	}
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
    1dc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t tail = rx_tail;
    1dc6:	4d14      	ldr	r5, [pc, #80]	; (1e18 <usb_seremu_getchar+0x54>)

	if (tail == rx_head) return -1;
    1dc8:	4a14      	ldr	r2, [pc, #80]	; (1e1c <usb_seremu_getchar+0x58>)
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    1dca:	782b      	ldrb	r3, [r5, #0]

	if (tail == rx_head) return -1;
    1dcc:	7812      	ldrb	r2, [r2, #0]
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
    1dce:	b2db      	uxtb	r3, r3

	if (tail == rx_head) return -1;
    1dd0:	4293      	cmp	r3, r2
    1dd2:	d01d      	beq.n	1e10 <usb_seremu_getchar+0x4c>
	if (++tail > RX_NUM) tail = 0;
    1dd4:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    1dd6:	4a12      	ldr	r2, [pc, #72]	; (1e20 <usb_seremu_getchar+0x5c>)
	uint32_t index = rx_index[i];
    1dd8:	4e12      	ldr	r6, [pc, #72]	; (1e24 <usb_seremu_getchar+0x60>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    1dda:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    1ddc:	4c12      	ldr	r4, [pc, #72]	; (1e28 <usb_seremu_getchar+0x64>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    1dde:	bf28      	it	cs
    1de0:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    1de2:	5cd0      	ldrb	r0, [r2, r3]
	uint32_t index = rx_index[i];
    1de4:	f836 2010 	ldrh.w	r2, [r6, r0, lsl #1]
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    1de8:	eb02 1140 	add.w	r1, r2, r0, lsl #5
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    1dec:	3201      	adds	r2, #1
    1dee:	2a1f      	cmp	r2, #31

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
    1df0:	eb04 0701 	add.w	r7, r4, r1
	int c = *p;
    1df4:	5c64      	ldrb	r4, [r4, r1]
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
    1df6:	d805      	bhi.n	1e04 <usb_seremu_getchar+0x40>
    1df8:	7879      	ldrb	r1, [r7, #1]
    1dfa:	b119      	cbz	r1, 1e04 <usb_seremu_getchar+0x40>
		rx_tail = tail;
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
    1dfc:	f826 2010 	strh.w	r2, [r6, r0, lsl #1]
	}
	return c;
    1e00:	4620      	mov	r0, r4
    1e02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
    1e04:	b2db      	uxtb	r3, r3
    1e06:	702b      	strb	r3, [r5, #0]
		rx_queue_transfer(i);
    1e08:	f7ff ff24 	bl	1c54 <rx_queue_transfer>
	} else {
		rx_index[i] = index;
	}
	return c;
    1e0c:	4620      	mov	r0, r4
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
		rx_queue_transfer(i);
    1e0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
    1e10:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
	}
	return c;
}
    1e14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1e16:	bf00      	nop
    1e18:	20001bfe 	.word	0x20001bfe
    1e1c:	20001bfc 	.word	0x20001bfc
    1e20:	20001b9c 	.word	0x20001b9c
    1e24:	20001b84 	.word	0x20001b84
    1e28:	20200260 	.word	0x20200260

00001e2c <usb_seremu_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    1e2c:	4b0b      	ldr	r3, [pc, #44]	; (1e5c <usb_seremu_peekchar+0x30>)
	if (tail == rx_head) return -1;
    1e2e:	4a0c      	ldr	r2, [pc, #48]	; (1e60 <usb_seremu_peekchar+0x34>)
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    1e30:	781b      	ldrb	r3, [r3, #0]
	if (tail == rx_head) return -1;
    1e32:	7812      	ldrb	r2, [r2, #0]
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
    1e34:	b2db      	uxtb	r3, r3
	if (tail == rx_head) return -1;
    1e36:	4293      	cmp	r3, r2
    1e38:	d00d      	beq.n	1e56 <usb_seremu_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    1e3a:	3301      	adds	r3, #1
	uint32_t i = rx_list[tail];
    1e3c:	4a09      	ldr	r2, [pc, #36]	; (1e64 <usb_seremu_peekchar+0x38>)
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    1e3e:	480a      	ldr	r0, [pc, #40]	; (1e68 <usb_seremu_peekchar+0x3c>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    1e40:	2b09      	cmp	r3, #9
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    1e42:	490a      	ldr	r1, [pc, #40]	; (1e6c <usb_seremu_peekchar+0x40>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    1e44:	bf28      	it	cs
    1e46:	2300      	movcs	r3, #0
	uint32_t i = rx_list[tail];
    1e48:	5cd2      	ldrb	r2, [r2, r3]
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
    1e4a:	f830 3012 	ldrh.w	r3, [r0, r2, lsl #1]
    1e4e:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    1e52:	5cc8      	ldrb	r0, [r1, r3]
    1e54:	4770      	bx	lr

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
    1e56:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
}
    1e5a:	4770      	bx	lr
    1e5c:	20001bfe 	.word	0x20001bfe
    1e60:	20001bfc 	.word	0x20001bfc
    1e64:	20001b9c 	.word	0x20001b9c
    1e68:	20001b84 	.word	0x20001b84
    1e6c:	20200260 	.word	0x20200260

00001e70 <usb_seremu_available>:

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
    1e70:	b508      	push	{r3, lr}
	uint32_t tail = rx_tail;
    1e72:	4a06      	ldr	r2, [pc, #24]	; (1e8c <usb_seremu_available+0x1c>)
	if (tail == rx_head) {
    1e74:	4b06      	ldr	r3, [pc, #24]	; (1e90 <usb_seremu_available+0x20>)
}

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
    1e76:	7812      	ldrb	r2, [r2, #0]
	if (tail == rx_head) {
    1e78:	781b      	ldrb	r3, [r3, #0]
    1e7a:	429a      	cmp	r2, r3
    1e7c:	d001      	beq.n	1e82 <usb_seremu_available+0x12>
		yield();
		return 0;
	}
	// TODO: how much is actually available?
	return 1;
    1e7e:	2001      	movs	r0, #1
}
    1e80:	bd08      	pop	{r3, pc}
// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) {
		yield();
    1e82:	f000 facf 	bl	2424 <yield>
		return 0;
    1e86:	2000      	movs	r0, #0
    1e88:	bd08      	pop	{r3, pc}
    1e8a:	bf00      	nop
    1e8c:	20001bfe 	.word	0x20001bfe
    1e90:	20001bfc 	.word	0x20001bfc

00001e94 <tx_zero_pad>:
	USB1_GPTIMER0CTRL = 0;
}


void tx_zero_pad(void)
{
    1e94:	b538      	push	{r3, r4, r5, lr}
	if (!tx_available) return;
    1e96:	4c08      	ldr	r4, [pc, #32]	; (1eb8 <tx_zero_pad+0x24>)
    1e98:	8822      	ldrh	r2, [r4, #0]
    1e9a:	b162      	cbz	r2, 1eb6 <tx_zero_pad+0x22>
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    1e9c:	4907      	ldr	r1, [pc, #28]	; (1ebc <tx_zero_pad+0x28>)
	memset(txdata, 0, tx_available);
    1e9e:	f1c2 0340 	rsb	r3, r2, #64	; 0x40
    1ea2:	4807      	ldr	r0, [pc, #28]	; (1ec0 <tx_zero_pad+0x2c>)


void tx_zero_pad(void)
{
	if (!tx_available) return;
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    1ea4:	780d      	ldrb	r5, [r1, #0]
	memset(txdata, 0, tx_available);
    1ea6:	2100      	movs	r1, #0
    1ea8:	eb03 1385 	add.w	r3, r3, r5, lsl #6
    1eac:	4418      	add	r0, r3
    1eae:	f001 f8ed 	bl	308c <memset>
	tx_available = 0;
    1eb2:	2300      	movs	r3, #0
    1eb4:	8023      	strh	r3, [r4, #0]
    1eb6:	bd38      	pop	{r3, r4, r5, pc}
    1eb8:	20001bf4 	.word	0x20001bf4
    1ebc:	20001c02 	.word	0x20001c02
    1ec0:	20200360 	.word	0x20200360

00001ec4 <tx_queue_transfer>:
}

void tx_queue_transfer(void)
{
    1ec4:	b570      	push	{r4, r5, r6, lr}
	transfer_t *xfer = tx_transfer + tx_head;
    1ec6:	4e15      	ldr	r6, [pc, #84]	; (1f1c <tx_queue_transfer+0x58>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    1ec8:	2300      	movs	r3, #0
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    1eca:	4d15      	ldr	r5, [pc, #84]	; (1f20 <tx_queue_transfer+0x5c>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    1ecc:	2240      	movs	r2, #64	; 0x40
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    1ece:	7831      	ldrb	r1, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    1ed0:	4c14      	ldr	r4, [pc, #80]	; (1f24 <tx_queue_transfer+0x60>)
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
    1ed2:	eb05 1541 	add.w	r5, r5, r1, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
    1ed6:	eb04 1481 	add.w	r4, r4, r1, lsl #6
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
    1eda:	4628      	mov	r0, r5
    1edc:	4621      	mov	r1, r4
    1ede:	f7ff fdc9 	bl	1a74 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    1ee2:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    1ee6:	f104 0140 	add.w	r1, r4, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
    1eea:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    1eee:	4a0e      	ldr	r2, [pc, #56]	; (1f28 <tx_queue_transfer+0x64>)
    1ef0:	6013      	str	r3, [r2, #0]
		location += 32;
    1ef2:	3320      	adds	r3, #32
	} while (location < end_addr);
    1ef4:	4299      	cmp	r1, r3
    1ef6:	d8fb      	bhi.n	1ef0 <tx_queue_transfer+0x2c>
	asm("dsb");
    1ef8:	f3bf 8f4f 	dsb	sy
	asm("isb");
    1efc:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
    1f00:	2002      	movs	r0, #2
    1f02:	4629      	mov	r1, r5
    1f04:	f7ff fdce 	bl	1aa4 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    1f08:	7833      	ldrb	r3, [r6, #0]
    1f0a:	4a04      	ldr	r2, [pc, #16]	; (1f1c <tx_queue_transfer+0x58>)
    1f0c:	3301      	adds	r3, #1
    1f0e:	b2db      	uxtb	r3, r3
    1f10:	2b0b      	cmp	r3, #11
    1f12:	bf88      	it	hi
    1f14:	2300      	movhi	r3, #0
    1f16:	7013      	strb	r3, [r2, #0]
    1f18:	bd70      	pop	{r4, r5, r6, pc}
    1f1a:	bf00      	nop
    1f1c:	20001c02 	.word	0x20001c02
    1f20:	200018e0 	.word	0x200018e0
    1f24:	20200360 	.word	0x20200360
    1f28:	e000ef70 	.word	0xe000ef70

00001f2c <usb_seremu_flush_callback>:
	timer_stop();
	tx_noautoflush = 0;
}

static void usb_seremu_flush_callback(void)
{
    1f2c:	b508      	push	{r3, lr}
	if (tx_noautoflush) return;
    1f2e:	4b08      	ldr	r3, [pc, #32]	; (1f50 <usb_seremu_flush_callback+0x24>)
    1f30:	781b      	ldrb	r3, [r3, #0]
    1f32:	b92b      	cbnz	r3, 1f40 <usb_seremu_flush_callback+0x14>
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
    1f34:	4b07      	ldr	r3, [pc, #28]	; (1f54 <usb_seremu_flush_callback+0x28>)
    1f36:	881b      	ldrh	r3, [r3, #0]
    1f38:	3b01      	subs	r3, #1
    1f3a:	b29b      	uxth	r3, r3
    1f3c:	2b3e      	cmp	r3, #62	; 0x3e
    1f3e:	d900      	bls.n	1f42 <usb_seremu_flush_callback+0x16>
    1f40:	bd08      	pop	{r3, pc}
	tx_zero_pad();
    1f42:	f7ff ffa7 	bl	1e94 <tx_zero_pad>
	tx_queue_transfer();
}
    1f46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
static void usb_seremu_flush_callback(void)
{
	if (tx_noautoflush) return;
	if (tx_available == 0 || tx_available >= SEREMU_TX_SIZE) return;
	tx_zero_pad();
	tx_queue_transfer();
    1f4a:	f7ff bfbb 	b.w	1ec4 <tx_queue_transfer>
    1f4e:	bf00      	nop
    1f50:	20001c03 	.word	0x20001c03
    1f54:	20001bf4 	.word	0x20001bf4

00001f58 <usb_seremu_write.part.1>:
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
	if (++tx_head >= TX_NUM) tx_head = 0;
}

int usb_seremu_write(const void *buffer, uint32_t size)
    1f58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1f5c:	b085      	sub	sp, #20
    1f5e:	9002      	str	r0, [sp, #8]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    1f60:	9100      	str	r1, [sp, #0]
    1f62:	2900      	cmp	r1, #0
    1f64:	f000 8084 	beq.w	2070 <usb_seremu_write.part.1+0x118>
    1f68:	2300      	movs	r3, #0
    1f6a:	4f42      	ldr	r7, [pc, #264]	; (2074 <usb_seremu_write.part.1+0x11c>)
    1f6c:	f8df 8120 	ldr.w	r8, [pc, #288]	; 2090 <usb_seremu_write.part.1+0x138>
    1f70:	f8df a110 	ldr.w	sl, [pc, #272]	; 2084 <usb_seremu_write.part.1+0x12c>
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
    1f74:	4e40      	ldr	r6, [pc, #256]	; (2078 <usb_seremu_write.part.1+0x120>)
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    1f76:	f8df b11c 	ldr.w	fp, [pc, #284]	; 2094 <usb_seremu_write.part.1+0x13c>
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    1f7a:	9301      	str	r3, [sp, #4]
		tx_noautoflush = 1;
    1f7c:	2101      	movs	r1, #1
		transfer_t *xfer = tx_transfer + tx_head;
    1f7e:	4b3f      	ldr	r3, [pc, #252]	; (207c <usb_seremu_write.part.1+0x124>)
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
    1f80:	7039      	strb	r1, [r7, #0]
		transfer_t *xfer = tx_transfer + tx_head;
    1f82:	781a      	ldrb	r2, [r3, #0]
    1f84:	493e      	ldr	r1, [pc, #248]	; (2080 <usb_seremu_write.part.1+0x128>)
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    1f86:	f8b8 3000 	ldrh.w	r3, [r8]
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
    1f8a:	eb01 1942 	add.w	r9, r1, r2, lsl #5
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    1f8e:	bb0b      	cbnz	r3, 1fd4 <usb_seremu_write.part.1+0x7c>
    1f90:	461d      	mov	r5, r3
    1f92:	461c      	mov	r4, r3
			uint32_t status = usb_transfer_status(xfer);
    1f94:	4648      	mov	r0, r9
    1f96:	f7ff fdab 	bl	1af0 <usb_transfer_status>
			if (!(status & 0x80)) {
    1f9a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    1f9e:	f04f 0300 	mov.w	r3, #0
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    1fa2:	4938      	ldr	r1, [pc, #224]	; (2084 <usb_seremu_write.part.1+0x12c>)
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
			uint32_t status = usb_transfer_status(xfer);
			if (!(status & 0x80)) {
    1fa4:	d056      	beq.n	2054 <usb_seremu_write.part.1+0xfc>
			tx_noautoflush = 0;
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    1fa6:	f89a 2000 	ldrb.w	r2, [sl]
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			tx_noautoflush = 0;
    1faa:	703b      	strb	r3, [r7, #0]
			if (!waiting) {
    1fac:	b904      	cbnz	r4, 1fb0 <usb_seremu_write.part.1+0x58>
				wait_begin_at = systick_millis_count;
    1fae:	6835      	ldr	r5, [r6, #0]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    1fb0:	2a00      	cmp	r2, #0
    1fb2:	d134      	bne.n	201e <usb_seremu_write.part.1+0xc6>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    1fb4:	6833      	ldr	r3, [r6, #0]
    1fb6:	2401      	movs	r4, #1
    1fb8:	1b5b      	subs	r3, r3, r5
    1fba:	2b32      	cmp	r3, #50	; 0x32
    1fbc:	d853      	bhi.n	2066 <usb_seremu_write.part.1+0x10e>
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
    1fbe:	f89b 3000 	ldrb.w	r3, [fp]
    1fc2:	b363      	cbz	r3, 201e <usb_seremu_write.part.1+0xc6>
			yield();
    1fc4:	f000 fa2e 	bl	2424 <yield>
	while (size > 0) {
		tx_noautoflush = 1;
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    1fc8:	f8b8 3000 	ldrh.w	r3, [r8]
    1fcc:	2b00      	cmp	r3, #0
    1fce:	d0e1      	beq.n	1f94 <usb_seremu_write.part.1+0x3c>
    1fd0:	4a2a      	ldr	r2, [pc, #168]	; (207c <usb_seremu_write.part.1+0x124>)
    1fd2:	7812      	ldrb	r2, [r2, #0]
    1fd4:	461c      	mov	r4, r3
    1fd6:	f1c3 0040 	rsb	r0, r3, #64	; 0x40
				return sent;
			}
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
    1fda:	eb00 1082 	add.w	r0, r0, r2, lsl #6
    1fde:	4a2a      	ldr	r2, [pc, #168]	; (2088 <usb_seremu_write.part.1+0x130>)
    1fe0:	4410      	add	r0, r2
		if (size >= tx_available) {
    1fe2:	9a00      	ldr	r2, [sp, #0]
    1fe4:	42a2      	cmp	r2, r4
    1fe6:	d31e      	bcc.n	2026 <usb_seremu_write.part.1+0xce>
			memcpy(txdata, data, tx_available);
			size -= tx_available;
    1fe8:	9b00      	ldr	r3, [sp, #0]
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    1fea:	2500      	movs	r5, #0
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    1fec:	f8dd 9008 	ldr.w	r9, [sp, #8]
    1ff0:	4622      	mov	r2, r4
			size -= tx_available;
    1ff2:	1b1b      	subs	r3, r3, r4
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    1ff4:	4649      	mov	r1, r9
			size -= tx_available;
    1ff6:	9300      	str	r3, [sp, #0]
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    1ff8:	f000 ff4a 	bl	2e90 <memcpy>
			size -= tx_available;
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    1ffc:	f8a8 5000 	strh.w	r5, [r8]
			tx_queue_transfer();
    2000:	f7ff ff60 	bl	1ec4 <tx_queue_transfer>
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    2004:	9a01      	ldr	r2, [sp, #4]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    2006:	4b21      	ldr	r3, [pc, #132]	; (208c <usb_seremu_write.part.1+0x134>)
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
    2008:	4422      	add	r2, r4
    200a:	9201      	str	r2, [sp, #4]
			data += tx_available;
    200c:	464a      	mov	r2, r9
    200e:	4422      	add	r2, r4
    2010:	9202      	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    2012:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2016:	9b00      	ldr	r3, [sp, #0]
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    2018:	703d      	strb	r5, [r7, #0]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    201a:	2b00      	cmp	r3, #0
    201c:	d1ae      	bne.n	1f7c <usb_seremu_write.part.1+0x24>
    201e:	9801      	ldr	r0, [sp, #4]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    2020:	b005      	add	sp, #20
    2022:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    2026:	9d00      	ldr	r5, [sp, #0]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2028:	f04f 4440 	mov.w	r4, #3221225472	; 0xc0000000
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    202c:	9902      	ldr	r1, [sp, #8]
    202e:	462a      	mov	r2, r5
    2030:	9303      	str	r3, [sp, #12]
    2032:	f000 ff2d 	bl	2e90 <memcpy>
			tx_available -= size;
    2036:	9b03      	ldr	r3, [sp, #12]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2038:	4914      	ldr	r1, [pc, #80]	; (208c <usb_seremu_write.part.1+0x134>)
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    203a:	2200      	movs	r2, #0
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
			tx_available -= size;
    203c:	1b5b      	subs	r3, r3, r5
    203e:	f8a8 3000 	strh.w	r3, [r8]
    2042:	9b01      	ldr	r3, [sp, #4]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    2044:	f8c1 4084 	str.w	r4, [r1, #132]	; 0x84
    2048:	4618      	mov	r0, r3
			tx_available -= size;
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
    204a:	703a      	strb	r2, [r7, #0]
    204c:	4428      	add	r0, r5
	}
	return sent;
}
    204e:	b005      	add	sp, #20
    2050:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    2054:	2340      	movs	r3, #64	; 0x40
    2056:	4a09      	ldr	r2, [pc, #36]	; (207c <usb_seremu_write.part.1+0x124>)
				transmit_previous_timeout = 0;
    2058:	f88a 0000 	strb.w	r0, [sl]
    205c:	7812      	ldrb	r2, [r2, #0]
    205e:	461c      	mov	r4, r3
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
    2060:	f8a8 3000 	strh.w	r3, [r8]
    2064:	e7b9      	b.n	1fda <usb_seremu_write.part.1+0x82>
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
    2066:	9801      	ldr	r0, [sp, #4]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    2068:	700c      	strb	r4, [r1, #0]
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    206a:	b005      	add	sp, #20
    206c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    2070:	9800      	ldr	r0, [sp, #0]
    2072:	e7d5      	b.n	2020 <usb_seremu_write.part.1+0xc8>
    2074:	20001c03 	.word	0x20001c03
    2078:	20001bc0 	.word	0x20001bc0
    207c:	20001c02 	.word	0x20001c02
    2080:	200018e0 	.word	0x200018e0
    2084:	20001c00 	.word	0x20001c00
    2088:	20200360 	.word	0x20200360
    208c:	402e0000 	.word	0x402e0000
    2090:	20001bf4 	.word	0x20001bf4
    2094:	20001c04 	.word	0x20001c04

00002098 <usb_seremu_putchar>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    2098:	4b09      	ldr	r3, [pc, #36]	; (20c0 <usb_seremu_putchar+0x28>)
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    209a:	b500      	push	{lr}
    209c:	b083      	sub	sp, #12
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    209e:	781b      	ldrb	r3, [r3, #0]
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
    20a0:	f88d 0007 	strb.w	r0, [sp, #7]
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    20a4:	b923      	cbnz	r3, 20b0 <usb_seremu_putchar+0x18>
    20a6:	f003 00ff 	and.w	r0, r3, #255	; 0xff

// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
	return usb_seremu_write(&c, 1);
}
    20aa:	b003      	add	sp, #12
    20ac:	f85d fb04 	ldr.w	pc, [sp], #4
    20b0:	2101      	movs	r1, #1
    20b2:	f10d 0007 	add.w	r0, sp, #7
    20b6:	f7ff ff4f 	bl	1f58 <usb_seremu_write.part.1>
    20ba:	b003      	add	sp, #12
    20bc:	f85d fb04 	ldr.w	pc, [sp], #4
    20c0:	20001c04 	.word	0x20001c04

000020c4 <usb_seremu_write>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    20c4:	4b04      	ldr	r3, [pc, #16]	; (20d8 <usb_seremu_write+0x14>)
    20c6:	781b      	ldrb	r3, [r3, #0]
    20c8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    20cc:	b10b      	cbz	r3, 20d2 <usb_seremu_write+0xe>
    20ce:	f7ff bf43 	b.w	1f58 <usb_seremu_write.part.1>
			timer_start_oneshot();
		}
		tx_noautoflush = 0;
	}
	return sent;
}
    20d2:	4610      	mov	r0, r2
    20d4:	4770      	bx	lr
    20d6:	bf00      	nop
    20d8:	20001c04 	.word	0x20001c04

000020dc <usb_seremu_write_buffer_free>:

int usb_seremu_write_buffer_free(void)
{
	return 1;
}
    20dc:	2001      	movs	r0, #1
    20de:	4770      	bx	lr

000020e0 <usb_seremu_flush_output>:

void usb_seremu_flush_output(void)
{
	if (!usb_configuration) return;
    20e0:	4b0a      	ldr	r3, [pc, #40]	; (210c <usb_seremu_flush_output+0x2c>)
    20e2:	781b      	ldrb	r3, [r3, #0]
    20e4:	b113      	cbz	r3, 20ec <usb_seremu_flush_output+0xc>
	if (tx_available == 0) return;
    20e6:	4b0a      	ldr	r3, [pc, #40]	; (2110 <usb_seremu_flush_output+0x30>)
    20e8:	881b      	ldrh	r3, [r3, #0]
    20ea:	b903      	cbnz	r3, 20ee <usb_seremu_flush_output+0xe>
    20ec:	4770      	bx	lr
{
	return 1;
}

void usb_seremu_flush_output(void)
{
    20ee:	b510      	push	{r4, lr}
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    20f0:	2301      	movs	r3, #1
    20f2:	4c08      	ldr	r4, [pc, #32]	; (2114 <usb_seremu_flush_output+0x34>)
    20f4:	7023      	strb	r3, [r4, #0]
	tx_zero_pad();
    20f6:	f7ff fecd 	bl	1e94 <tx_zero_pad>
	tx_queue_transfer();
    20fa:	f7ff fee3 	bl	1ec4 <tx_queue_transfer>
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    20fe:	2300      	movs	r3, #0
    2100:	4a05      	ldr	r2, [pc, #20]	; (2118 <usb_seremu_flush_output+0x38>)
    2102:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	tx_zero_pad();
	tx_queue_transfer();
	timer_stop();
	tx_noautoflush = 0;
    2106:	7023      	strb	r3, [r4, #0]
    2108:	bd10      	pop	{r4, pc}
    210a:	bf00      	nop
    210c:	20001c04 	.word	0x20001c04
    2110:	20001bf4 	.word	0x20001bf4
    2114:	20001c03 	.word	0x20001c03
    2118:	402e0000 	.word	0x402e0000

0000211c <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    211c:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    211e:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    2122:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2124:	4c0c      	ldr	r4, [pc, #48]	; (2158 <EventResponder::runFromInterrupt()+0x3c>)
    2126:	6823      	ldr	r3, [r4, #0]
		if (first) {
    2128:	b18b      	cbz	r3, 214e <EventResponder::runFromInterrupt()+0x32>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    212a:	4e0c      	ldr	r6, [pc, #48]	; (215c <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    212c:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    212e:	695a      	ldr	r2, [r3, #20]
    2130:	6022      	str	r2, [r4, #0]
			if (firstInterrupt) {
    2132:	b17a      	cbz	r2, 2154 <EventResponder::runFromInterrupt()+0x38>
				firstInterrupt->_prev = nullptr;
    2134:	6195      	str	r5, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    2136:	b901      	cbnz	r1, 213a <EventResponder::runFromInterrupt()+0x1e>
    2138:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    213a:	775d      	strb	r5, [r3, #29]
			(*(first->_function))(*first);
    213c:	4618      	mov	r0, r3
    213e:	689b      	ldr	r3, [r3, #8]
    2140:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2142:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    2146:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    2148:	6823      	ldr	r3, [r4, #0]
		if (first) {
    214a:	2b00      	cmp	r3, #0
    214c:	d1ef      	bne.n	212e <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    214e:	b901      	cbnz	r1, 2152 <EventResponder::runFromInterrupt()+0x36>
    2150:	b662      	cpsie	i
    2152:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    2154:	6032      	str	r2, [r6, #0]
    2156:	e7ee      	b.n	2136 <EventResponder::runFromInterrupt()+0x1a>
    2158:	20001a8c 	.word	0x20001a8c
    215c:	20001a88 	.word	0x20001a88

00002160 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    2160:	f7ff bfdc 	b.w	211c <EventResponder::runFromInterrupt()>

00002164 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    2164:	4a04      	ldr	r2, [pc, #16]	; (2178 <systick_isr+0x14>)
    2166:	4b05      	ldr	r3, [pc, #20]	; (217c <systick_isr+0x18>)
    2168:	6811      	ldr	r1, [r2, #0]
	systick_millis_count++;
    216a:	4a05      	ldr	r2, [pc, #20]	; (2180 <systick_isr+0x1c>)
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    216c:	6019      	str	r1, [r3, #0]
	systick_millis_count++;
    216e:	6813      	ldr	r3, [r2, #0]
    2170:	3301      	adds	r3, #1
    2172:	6013      	str	r3, [r2, #0]
    2174:	4770      	bx	lr
    2176:	bf00      	nop
    2178:	e0001004 	.word	0xe0001004
    217c:	20001bbc 	.word	0x20001bbc
    2180:	20001bc0 	.word	0x20001bc0

00002184 <IntervalTimer::end()>:
}


void IntervalTimer::end() {
#if 1
	if (channel) {
    2184:	6802      	ldr	r2, [r0, #0]
    2186:	b30a      	cbz	r2, 21cc <IntervalTimer::end()+0x48>
		int index = channel - IMXRT_PIT_CHANNELS;
    2188:	4b11      	ldr	r3, [pc, #68]	; (21d0 <IntervalTimer::end()+0x4c>)
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    218a:	4912      	ldr	r1, [pc, #72]	; (21d4 <IntervalTimer::end()+0x50>)


void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    218c:	4413      	add	r3, r2
	NVIC_ENABLE_IRQ(IRQ_PIT);
	return true;
}


void IntervalTimer::end() {
    218e:	b5f0      	push	{r4, r5, r6, r7, lr}
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
    2190:	111b      	asrs	r3, r3, #4
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    2192:	25ff      	movs	r5, #255	; 0xff
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    2194:	2400      	movs	r4, #0
    2196:	f8df e044 	ldr.w	lr, [pc, #68]	; 21dc <IntervalTimer::end()+0x58>
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
    219a:	54cd      	strb	r5, [r1, r3]
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    219c:	780e      	ldrb	r6, [r1, #0]
    219e:	784d      	ldrb	r5, [r1, #1]
    21a0:	2eff      	cmp	r6, #255	; 0xff
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
    21a2:	6094      	str	r4, [r2, #8]
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
    21a4:	f84e 4023 	str.w	r4, [lr, r3, lsl #2]
    21a8:	bf28      	it	cs
    21aa:	26ff      	movcs	r6, #255	; 0xff
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
    21ac:	788a      	ldrb	r2, [r1, #2]
    21ae:	78c9      	ldrb	r1, [r1, #3]
    21b0:	42ae      	cmp	r6, r5
    21b2:	4633      	mov	r3, r6
		}
		NVIC_SET_PRIORITY(IRQ_PIT, top_priority);
    21b4:	4f08      	ldr	r7, [pc, #32]	; (21d8 <IntervalTimer::end()+0x54>)
    21b6:	bf28      	it	cs
    21b8:	462b      	movcs	r3, r5
    21ba:	4293      	cmp	r3, r2
    21bc:	bf28      	it	cs
    21be:	4613      	movcs	r3, r2
    21c0:	428b      	cmp	r3, r1
    21c2:	bf28      	it	cs
    21c4:	460b      	movcs	r3, r1
    21c6:	703b      	strb	r3, [r7, #0]
		channel = 0;
    21c8:	6004      	str	r4, [r0, #0]
    21ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    21cc:	4770      	bx	lr
    21ce:	bf00      	nop
    21d0:	bff7bf00 	.word	0xbff7bf00
    21d4:	20000c44 	.word	0x20000c44
    21d8:	e000e47a 	.word	0xe000e47a
    21dc:	200016c0 	.word	0x200016c0

000021e0 <Print::println()>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    21e0:	b510      	push	{r4, lr}
	uint8_t buf[2]={'\r', '\n'};
    21e2:	4c06      	ldr	r4, [pc, #24]	; (21fc <Print::println()+0x1c>)
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    21e4:	b082      	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    21e6:	6803      	ldr	r3, [r0, #0]
    21e8:	2202      	movs	r2, #2
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    21ea:	8824      	ldrh	r4, [r4, #0]
	return write(buf, 2);
    21ec:	a901      	add	r1, sp, #4
    21ee:	685b      	ldr	r3, [r3, #4]
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    21f0:	f8ad 4004 	strh.w	r4, [sp, #4]
	return write(buf, 2);
    21f4:	4798      	blx	r3
}
    21f6:	b002      	add	sp, #8
    21f8:	bd10      	pop	{r4, pc}
    21fa:	bf00      	nop
    21fc:	20000370 	.word	0x20000370

00002200 <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
	((class Print *)file)->write((uint8_t *)ptr, len);
    2200:	6803      	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    2202:	b510      	push	{r4, lr}
    2204:	4614      	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    2206:	685b      	ldr	r3, [r3, #4]
    2208:	4798      	blx	r3
	return len;
}
    220a:	4620      	mov	r0, r4
    220c:	bd10      	pop	{r4, pc}
    220e:	bf00      	nop

00002210 <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    2210:	b40e      	push	{r1, r2, r3}
    2212:	b500      	push	{lr}
    2214:	b082      	sub	sp, #8
    2216:	ab03      	add	r3, sp, #12
    2218:	f853 1b04 	ldr.w	r1, [r3], #4
	va_start(ap, format);
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    221c:	461a      	mov	r2, r3
}

int Print::printf(const char *format, ...)
{
	va_list ap;
	va_start(ap, format);
    221e:	9301      	str	r3, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    2220:	f001 fac2 	bl	37a8 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    2224:	b002      	add	sp, #8
    2226:	f85d eb04 	ldr.w	lr, [sp], #4
    222a:	b003      	add	sp, #12
    222c:	4770      	bx	lr
    222e:	bf00      	nop

00002230 <IntervalTimer::~IntervalTimer()>:
private:
	static const uint32_t MAX_PERIOD = UINT32_MAX / (24000000 / 1000000);
public:
	constexpr IntervalTimer() {
	}
	~IntervalTimer() {
    2230:	b510      	push	{r4, lr}
    2232:	4604      	mov	r4, r0
		end();
    2234:	f7ff ffa6 	bl	2184 <IntervalTimer::end()>
	}
    2238:	4620      	mov	r0, r4
    223a:	bd10      	pop	{r4, pc}

0000223c <_GLOBAL__sub_I__Z4tonehtm>:
static uint32_t tone_toggle_count;
static volatile uint32_t *tone_reg;
static uint32_t tone_mask;
static float tone_usec=0.0;
static uint32_t tone_new_count=0;
static IntervalTimer tone_timer;
    223c:	4a02      	ldr	r2, [pc, #8]	; (2248 <_GLOBAL__sub_I__Z4tonehtm+0xc>)
    223e:	4903      	ldr	r1, [pc, #12]	; (224c <_GLOBAL__sub_I__Z4tonehtm+0x10>)
    2240:	4803      	ldr	r0, [pc, #12]	; (2250 <_GLOBAL__sub_I__Z4tonehtm+0x14>)
    2242:	f000 b967 	b.w	2514 <__aeabi_atexit>
    2246:	bf00      	nop
    2248:	20000c20 	.word	0x20000c20
    224c:	00002231 	.word	0x00002231
    2250:	20000c3c 	.word	0x20000c3c

00002254 <String::~String()>:
	init();
	char buf[40];
	*this = dtostrf(num, digits + 2, digits, buf);
}

String::~String()
    2254:	b510      	push	{r4, lr}
    2256:	4604      	mov	r4, r0
{
	free(buffer);
    2258:	6800      	ldr	r0, [r0, #0]
    225a:	f000 fb43 	bl	28e4 <free>
}
    225e:	4620      	mov	r0, r4
    2260:	bd10      	pop	{r4, pc}
    2262:	bf00      	nop

00002264 <String::reserve(unsigned int)>:
	len = 0;
	flags = 0;
}

unsigned char String::reserve(unsigned int size)
{
    2264:	b538      	push	{r3, r4, r5, lr}
	if (capacity >= size) return 1;
    2266:	6843      	ldr	r3, [r0, #4]
    2268:	428b      	cmp	r3, r1
    226a:	d301      	bcc.n	2270 <String::reserve(unsigned int)+0xc>
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    226c:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
    226e:	bd38      	pop	{r3, r4, r5, pc}
    2270:	460d      	mov	r5, r1
    2272:	4604      	mov	r4, r0

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    2274:	3101      	adds	r1, #1
    2276:	6800      	ldr	r0, [r0, #0]
    2278:	f000 ff5a 	bl	3130 <realloc>
	if (newbuffer) {
    227c:	2800      	cmp	r0, #0
    227e:	d0f6      	beq.n	226e <String::reserve(unsigned int)+0xa>

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2280:	68a3      	ldr	r3, [r4, #8]
unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
	if (newbuffer) {
		buffer = newbuffer;
		capacity = maxStrLen;
    2282:	e884 0021 	stmia.w	r4, {r0, r5}

unsigned char String::reserve(unsigned int size)
{
	if (capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    2286:	2b00      	cmp	r3, #0
    2288:	d1f0      	bne.n	226c <String::reserve(unsigned int)+0x8>
    228a:	7003      	strb	r3, [r0, #0]
    228c:	e7ee      	b.n	226c <String::reserve(unsigned int)+0x8>
    228e:	bf00      	nop

00002290 <String::copy(char const*, unsigned int)>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    2290:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2292:	4604      	mov	r4, r0
	if (length == 0) {
    2294:	4615      	mov	r5, r2
    2296:	b932      	cbnz	r2, 22a6 <String::copy(char const*, unsigned int)+0x16>
		if (buffer) buffer[0] = 0;
    2298:	6803      	ldr	r3, [r0, #0]
    229a:	b103      	cbz	r3, 229e <String::copy(char const*, unsigned int)+0xe>
    229c:	701a      	strb	r2, [r3, #0]
		len = 0;
    229e:	2300      	movs	r3, #0
    22a0:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    22a2:	4620      	mov	r0, r4
    22a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    22a6:	460e      	mov	r6, r1
	if (length == 0) {
		if (buffer) buffer[0] = 0;
		len = 0;
		return *this;
	}
	if (!reserve(length)) {
    22a8:	4611      	mov	r1, r2
    22aa:	f7ff ffdb 	bl	2264 <String::reserve(unsigned int)>
    22ae:	4607      	mov	r7, r0
    22b0:	b948      	cbnz	r0, 22c6 <String::copy(char const*, unsigned int)+0x36>
		if (buffer) {
    22b2:	6820      	ldr	r0, [r4, #0]
    22b4:	b110      	cbz	r0, 22bc <String::copy(char const*, unsigned int)+0x2c>
			free(buffer);
    22b6:	f000 fb15 	bl	28e4 <free>
			buffer = NULL;
    22ba:	6027      	str	r7, [r4, #0]
		}
		len = capacity = 0;
    22bc:	2300      	movs	r3, #0
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    22be:	4620      	mov	r0, r4
	if (!reserve(length)) {
		if (buffer) {
			free(buffer);
			buffer = NULL;
		}
		len = capacity = 0;
    22c0:	6063      	str	r3, [r4, #4]
    22c2:	60a3      	str	r3, [r4, #8]
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    22c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			buffer = NULL;
		}
		len = capacity = 0;
		return *this;
	}
	len = length;
    22c6:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
    22c8:	4631      	mov	r1, r6
    22ca:	6820      	ldr	r0, [r4, #0]
    22cc:	f001 f93a 	bl	3544 <strcpy>
	return *this;
    22d0:	e7e7      	b.n	22a2 <String::copy(char const*, unsigned int)+0x12>
    22d2:	bf00      	nop

000022d4 <String::String(char const*)>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    22d4:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    22d6:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
    22d8:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    22da:	6003      	str	r3, [r0, #0]
	capacity = 0;
    22dc:	6043      	str	r3, [r0, #4]
	len = 0;
    22de:	6083      	str	r3, [r0, #8]
	flags = 0;
    22e0:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    22e2:	b141      	cbz	r1, 22f6 <String::String(char const*)+0x22>
    22e4:	460d      	mov	r5, r1
    22e6:	4608      	mov	r0, r1
    22e8:	f001 f98a 	bl	3600 <strlen>
    22ec:	4602      	mov	r2, r0
    22ee:	4629      	mov	r1, r5
    22f0:	4620      	mov	r0, r4
    22f2:	f7ff ffcd 	bl	2290 <String::copy(char const*, unsigned int)>
}
    22f6:	4620      	mov	r0, r4
    22f8:	bd38      	pop	{r3, r4, r5, pc}
    22fa:	bf00      	nop

000022fc <String::String(String const&)>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    22fc:	2300      	movs	r3, #0
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    22fe:	4288      	cmp	r0, r1
{
	init();
	*this = pgmstr;
}

String::String(const String &value)
    2300:	b510      	push	{r4, lr}
    2302:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2304:	6003      	str	r3, [r0, #0]
	capacity = 0;
    2306:	6043      	str	r3, [r0, #4]
	len = 0;
    2308:	6083      	str	r3, [r0, #8]
	flags = 0;
    230a:	7303      	strb	r3, [r0, #12]
	rhs.len = 0;
}

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
    230c:	d003      	beq.n	2316 <String::String(String const&)+0x1a>
	return copy(rhs.buffer, rhs.len);
    230e:	688a      	ldr	r2, [r1, #8]
    2310:	6809      	ldr	r1, [r1, #0]
    2312:	f7ff ffbd 	bl	2290 <String::copy(char const*, unsigned int)>

String::String(const String &value)
{
	init();
	*this = value;
}
    2316:	4620      	mov	r0, r4
    2318:	bd10      	pop	{r4, pc}
    231a:	bf00      	nop

0000231c <String::operator=(char const*) [clone .part.2]>:
	if (this != &rval) move(rval);
	return *this;
}
#endif

String & String::operator = (const char *cstr)
    231c:	b538      	push	{r3, r4, r5, lr}
    231e:	460c      	mov	r4, r1
    2320:	4605      	mov	r5, r0
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    2322:	4608      	mov	r0, r1
    2324:	f001 f96c 	bl	3600 <strlen>
    2328:	4621      	mov	r1, r4
    232a:	4602      	mov	r2, r0
    232c:	4628      	mov	r0, r5
	} else {
		len = 0;
	}
	return *this;
}
    232e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) {
		copy(cstr, strlen(cstr));
    2332:	f7ff bfad 	b.w	2290 <String::copy(char const*, unsigned int)>
    2336:	bf00      	nop

00002338 <String::String(int, unsigned char)>:
	char buf[4];
	utoa(c, buf, 10);
	*this = buf;
}

String::String(const int value, unsigned char base)
    2338:	b510      	push	{r4, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    233a:	2300      	movs	r3, #0
	char buf[4];
	utoa(c, buf, 10);
	*this = buf;
}

String::String(const int value, unsigned char base)
    233c:	4604      	mov	r4, r0
    233e:	b086      	sub	sp, #24
{
	init();
	char buf[18];
	itoa(value, buf, base);
    2340:	4608      	mov	r0, r1
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    2342:	6023      	str	r3, [r4, #0]

String::String(const int value, unsigned char base)
{
	init();
	char buf[18];
	itoa(value, buf, base);
    2344:	a901      	add	r1, sp, #4
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
	capacity = 0;
    2346:	6063      	str	r3, [r4, #4]
	len = 0;
    2348:	60a3      	str	r3, [r4, #8]
	flags = 0;
    234a:	7323      	strb	r3, [r4, #12]

String::String(const int value, unsigned char base)
{
	init();
	char buf[18];
	itoa(value, buf, base);
    234c:	f000 fac0 	bl	28d0 <itoa>
    2350:	a901      	add	r1, sp, #4
    2352:	4620      	mov	r0, r4
    2354:	f7ff ffe2 	bl	231c <String::operator=(char const*) [clone .part.2]>
	*this = buf;
}
    2358:	4620      	mov	r0, r4
    235a:	b006      	add	sp, #24
    235c:	bd10      	pop	{r4, pc}
    235e:	bf00      	nop

00002360 <String::append(char const*, unsigned int)>:
{
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
    2360:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2364:	460f      	mov	r7, r1
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    2366:	6803      	ldr	r3, [r0, #0]
{
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
    2368:	4604      	mov	r4, r0
    236a:	4615      	mov	r5, r2
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    236c:	42bb      	cmp	r3, r7
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
    236e:	6881      	ldr	r1, [r0, #8]
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
    2370:	d80a      	bhi.n	2388 <String::append(char const*, unsigned int)+0x28>
    2372:	185a      	adds	r2, r3, r1
    2374:	4297      	cmp	r7, r2
    2376:	d207      	bcs.n	2388 <String::append(char const*, unsigned int)+0x28>
		self = true;
		buffer_offset = (unsigned int)(cstr-buffer);
    2378:	ebc3 0907 	rsb	r9, r3, r7
{
	unsigned int newlen = len + length;
	bool self = false;
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
		self = true;
    237c:	f04f 0801 	mov.w	r8, #1
		buffer_offset = (unsigned int)(cstr-buffer);
	}
	if (length == 0 || !reserve(newlen)) return *this;
    2380:	b935      	cbnz	r5, 2390 <String::append(char const*, unsigned int)+0x30>
		}
	else
		strcpy(buffer + len, cstr);
	len = newlen;
	return *this;
}
    2382:	4620      	mov	r0, r4
    2384:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}

String & String::append(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	bool self = false;
    2388:	f04f 0800 	mov.w	r8, #0
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
		self = true;
		buffer_offset = (unsigned int)(cstr-buffer);
	}
	if (length == 0 || !reserve(newlen)) return *this;
    238c:	2d00      	cmp	r5, #0
    238e:	d0f8      	beq.n	2382 <String::append(char const*, unsigned int)+0x22>
	return append(s.buffer, s.len);
}

String & String::append(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
    2390:	194e      	adds	r6, r1, r5
	unsigned int buffer_offset; 
	if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
		self = true;
		buffer_offset = (unsigned int)(cstr-buffer);
	}
	if (length == 0 || !reserve(newlen)) return *this;
    2392:	4620      	mov	r0, r4
    2394:	4631      	mov	r1, r6
    2396:	f7ff ff65 	bl	2264 <String::reserve(unsigned int)>
    239a:	2800      	cmp	r0, #0
    239c:	d0f1      	beq.n	2382 <String::append(char const*, unsigned int)+0x22>
	if ( self ) {
    239e:	f1b8 0f00 	cmp.w	r8, #0
    23a2:	d00e      	beq.n	23c2 <String::append(char const*, unsigned int)+0x62>
		memcpy(buffer + len, buffer+buffer_offset, length);
    23a4:	6823      	ldr	r3, [r4, #0]
    23a6:	462a      	mov	r2, r5
    23a8:	68a0      	ldr	r0, [r4, #8]
    23aa:	eb03 0109 	add.w	r1, r3, r9
    23ae:	4418      	add	r0, r3
    23b0:	f000 fd6e 	bl	2e90 <memcpy>
		buffer[newlen] = 0;
    23b4:	6823      	ldr	r3, [r4, #0]
    23b6:	2200      	movs	r2, #0
    23b8:	559a      	strb	r2, [r3, r6]
		}
	else
		strcpy(buffer + len, cstr);
	len = newlen;
    23ba:	60a6      	str	r6, [r4, #8]
	return *this;
}
    23bc:	4620      	mov	r0, r4
    23be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ( self ) {
		memcpy(buffer + len, buffer+buffer_offset, length);
		buffer[newlen] = 0;
		}
	else
		strcpy(buffer + len, cstr);
    23c2:	6820      	ldr	r0, [r4, #0]
    23c4:	4639      	mov	r1, r7
    23c6:	68a3      	ldr	r3, [r4, #8]
    23c8:	4418      	add	r0, r3
    23ca:	f001 f8bb 	bl	3544 <strcpy>
    23ce:	e7f4      	b.n	23ba <String::append(char const*, unsigned int)+0x5a>

000023d0 <operator+(StringSumHelper const&, String const&)>:
/*  Concatenate                              */
/*********************************************/


StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
    23d0:	b510      	push	{r4, lr}
    23d2:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	a.append(rhs.buffer, rhs.len);
    23d4:	688a      	ldr	r2, [r1, #8]
    23d6:	6809      	ldr	r1, [r1, #0]
    23d8:	f7ff ffc2 	bl	2360 <String::append(char const*, unsigned int)>
	return a;
}
    23dc:	4620      	mov	r0, r4
    23de:	bd10      	pop	{r4, pc}

000023e0 <operator+(StringSumHelper const&, char const*)>:

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
    23e0:	b538      	push	{r3, r4, r5, lr}
    23e2:	4605      	mov	r5, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (cstr) a.append(cstr, strlen(cstr));
    23e4:	b141      	cbz	r1, 23f8 <operator+(StringSumHelper const&, char const*)+0x18>
    23e6:	460c      	mov	r4, r1
    23e8:	4608      	mov	r0, r1
    23ea:	f001 f909 	bl	3600 <strlen>
    23ee:	4602      	mov	r2, r0
    23f0:	4621      	mov	r1, r4
    23f2:	4628      	mov	r0, r5
    23f4:	f7ff ffb4 	bl	2360 <String::append(char const*, unsigned int)>
	return a;
}
    23f8:	4628      	mov	r0, r5
    23fa:	bd38      	pop	{r3, r4, r5, pc}

000023fc <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    23fc:	4770      	bx	lr
    23fe:	bf00      	nop

00002400 <usb_seremu_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
    2400:	f7ff bd14 	b.w	1e2c <usb_seremu_peekchar>

00002404 <usb_seremu_class::read()>:
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
    2404:	f7ff bcde 	b.w	1dc4 <usb_seremu_getchar>

00002408 <usb_seremu_class::available()>:
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    2408:	f7ff bd32 	b.w	1e70 <usb_seremu_available>

0000240c <usb_seremu_class::flush()>:
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
    240c:	f7ff be68 	b.w	20e0 <usb_seremu_flush_output>

00002410 <usb_seremu_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
        size_t write(unsigned long n) { return write((uint8_t)n); }
        size_t write(long n) { return write((uint8_t)n); }
        size_t write(unsigned int n) { return write((uint8_t)n); }
        size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_seremu_write_buffer_free(); }
    2410:	f7ff be64 	b.w	20dc <usb_seremu_write_buffer_free>

00002414 <usb_seremu_class::write(unsigned char const*, unsigned int)>:
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
    2414:	4608      	mov	r0, r1
    2416:	4611      	mov	r1, r2
    2418:	f7ff be54 	b.w	20c4 <usb_seremu_write>

0000241c <usb_seremu_class::write(unsigned char)>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
    241c:	4608      	mov	r0, r1
    241e:	f7ff be3b 	b.w	2098 <usb_seremu_putchar>
    2422:	bf00      	nop

00002424 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    2424:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    2428:	4e32      	ldr	r6, [pc, #200]	; (24f4 <yield+0xd0>)
    242a:	7833      	ldrb	r3, [r6, #0]
    242c:	b193      	cbz	r3, 2454 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
    242e:	4f32      	ldr	r7, [pc, #200]	; (24f8 <yield+0xd4>)
    2430:	783a      	ldrb	r2, [r7, #0]
    2432:	b97a      	cbnz	r2, 2454 <yield+0x30>
	running = 1;
    2434:	2201      	movs	r2, #1


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    2436:	07d9      	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    2438:	703a      	strb	r2, [r7, #0]


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    243a:	d437      	bmi.n	24ac <yield+0x88>
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
    243c:	079a      	lsls	r2, r3, #30
    243e:	d419      	bmi.n	2474 <yield+0x50>

	running = 0;
    2440:	2200      	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    2442:	075b      	lsls	r3, r3, #29
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();

	running = 0;
    2444:	703a      	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    2446:	d505      	bpl.n	2454 <yield+0x30>
	// Wait for event(s) to occur.  These are most likely to be useful when
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);
	static void runFromYield() {
		if (!firstYield) return;  
    2448:	4b2c      	ldr	r3, [pc, #176]	; (24fc <yield+0xd8>)
    244a:	681a      	ldr	r2, [r3, #0]
    244c:	b112      	cbz	r2, 2454 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    244e:	f3ef 8205 	mrs	r2, IPSR
		if (ipsr != 0) return;
    2452:	b10a      	cbz	r2, 2458 <yield+0x34>
    2454:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    2458:	f3ef 8010 	mrs	r0, PRIMASK
		__disable_irq();
    245c:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    245e:	681a      	ldr	r2, [r3, #0]
		if (first == nullptr) {
    2460:	b11a      	cbz	r2, 246a <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    2462:	4c27      	ldr	r4, [pc, #156]	; (2500 <yield+0xdc>)
    2464:	7821      	ldrb	r1, [r4, #0]
    2466:	2900      	cmp	r1, #0
    2468:	d02f      	beq.n	24ca <yield+0xa6>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    246a:	2800      	cmp	r0, #0
    246c:	d1f2      	bne.n	2454 <yield+0x30>
    246e:	b662      	cpsie	i
    2470:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    2474:	f8df 8094 	ldr.w	r8, [pc, #148]	; 250c <yield+0xe8>
    2478:	f898 2000 	ldrb.w	r2, [r8]
    247c:	2a00      	cmp	r2, #0
    247e:	d0df      	beq.n	2440 <yield+0x1c>
    2480:	2400      	movs	r4, #0
    2482:	f8df 908c 	ldr.w	r9, [pc, #140]	; 2510 <yield+0xec>
    2486:	e005      	b.n	2494 <yield+0x70>
    2488:	3401      	adds	r4, #1
    248a:	f898 3000 	ldrb.w	r3, [r8]
    248e:	b2e4      	uxtb	r4, r4
    2490:	42a3      	cmp	r3, r4
    2492:	d913      	bls.n	24bc <yield+0x98>
			s_serials_with_serial_events[i]->doYieldCode();
    2494:	f859 5024 	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    2498:	682b      	ldr	r3, [r5, #0]
    249a:	4628      	mov	r0, r5
    249c:	691b      	ldr	r3, [r3, #16]
    249e:	4798      	blx	r3
    24a0:	2800      	cmp	r0, #0
    24a2:	d0f1      	beq.n	2488 <yield+0x64>
    24a4:	696b      	ldr	r3, [r5, #20]
    24a6:	689b      	ldr	r3, [r3, #8]
    24a8:	4798      	blx	r3
    24aa:	e7ed      	b.n	2488 <yield+0x64>
			}
			yield();
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
    24ac:	f7ff fce0 	bl	1e70 <usb_seremu_available>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    24b0:	b9d0      	cbnz	r0, 24e8 <yield+0xc4>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    24b2:	4b14      	ldr	r3, [pc, #80]	; (2504 <yield+0xe0>)
    24b4:	781b      	ldrb	r3, [r3, #0]
    24b6:	b91b      	cbnz	r3, 24c0 <yield+0x9c>
    24b8:	7833      	ldrb	r3, [r6, #0]
    24ba:	e7bf      	b.n	243c <yield+0x18>
    24bc:	7833      	ldrb	r3, [r6, #0]
    24be:	e7bf      	b.n	2440 <yield+0x1c>
    24c0:	7833      	ldrb	r3, [r6, #0]
    24c2:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    24c6:	7033      	strb	r3, [r6, #0]
    24c8:	e7b8      	b.n	243c <yield+0x18>
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    24ca:	2601      	movs	r6, #1
		firstYield = first->_next;
    24cc:	6955      	ldr	r5, [r2, #20]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    24ce:	7026      	strb	r6, [r4, #0]
		firstYield = first->_next;
    24d0:	601d      	str	r5, [r3, #0]
		if (firstYield) {
    24d2:	b165      	cbz	r5, 24ee <yield+0xca>
			firstYield->_prev = nullptr;
    24d4:	61a9      	str	r1, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    24d6:	b900      	cbnz	r0, 24da <yield+0xb6>
    24d8:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    24da:	2500      	movs	r5, #0
		(*(first->_function))(*first);
    24dc:	6893      	ldr	r3, [r2, #8]
    24de:	4610      	mov	r0, r2
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    24e0:	7755      	strb	r5, [r2, #29]
		(*(first->_function))(*first);
    24e2:	4798      	blx	r3
		runningFromYield = false;
    24e4:	7025      	strb	r5, [r4, #0]
    24e6:	e7b5      	b.n	2454 <yield+0x30>
	running = 1;


	// USB Serial - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
    24e8:	f7ff ff88 	bl	23fc <serialEvent()>
    24ec:	e7e1      	b.n	24b2 <yield+0x8e>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    24ee:	4b06      	ldr	r3, [pc, #24]	; (2508 <yield+0xe4>)
    24f0:	601d      	str	r5, [r3, #0]
    24f2:	e7f0      	b.n	24d6 <yield+0xb2>
    24f4:	20001236 	.word	0x20001236
    24f8:	20001bf8 	.word	0x20001bf8
    24fc:	20001a84 	.word	0x20001a84
    2500:	20001bf6 	.word	0x20001bf6
    2504:	60001f5a 	.word	0x60001f5a
    2508:	20001a90 	.word	0x20001a90
    250c:	20001bf7 	.word	0x20001bf7
    2510:	20001a94 	.word	0x20001a94

00002514 <__aeabi_atexit>:
    2514:	460b      	mov	r3, r1
    2516:	4601      	mov	r1, r0
    2518:	4618      	mov	r0, r3
    251a:	f000 b98d 	b.w	2838 <__cxa_atexit>
    251e:	bf00      	nop

00002520 <__aeabi_uldivmod>:
    2520:	b953      	cbnz	r3, 2538 <__aeabi_uldivmod+0x18>
    2522:	b94a      	cbnz	r2, 2538 <__aeabi_uldivmod+0x18>
    2524:	2900      	cmp	r1, #0
    2526:	bf08      	it	eq
    2528:	2800      	cmpeq	r0, #0
    252a:	bf1c      	itt	ne
    252c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    2530:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    2534:	f000 b97e 	b.w	2834 <__aeabi_idiv0>
    2538:	f1ad 0c08 	sub.w	ip, sp, #8
    253c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    2540:	f000 f806 	bl	2550 <__udivmoddi4>
    2544:	f8dd e004 	ldr.w	lr, [sp, #4]
    2548:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    254c:	b004      	add	sp, #16
    254e:	4770      	bx	lr

00002550 <__udivmoddi4>:
    2550:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2554:	468c      	mov	ip, r1
    2556:	460e      	mov	r6, r1
    2558:	4604      	mov	r4, r0
    255a:	9d08      	ldr	r5, [sp, #32]
    255c:	2b00      	cmp	r3, #0
    255e:	d150      	bne.n	2602 <__udivmoddi4+0xb2>
    2560:	428a      	cmp	r2, r1
    2562:	4617      	mov	r7, r2
    2564:	d96c      	bls.n	2640 <__udivmoddi4+0xf0>
    2566:	fab2 fe82 	clz	lr, r2
    256a:	f1be 0f00 	cmp.w	lr, #0
    256e:	d00b      	beq.n	2588 <__udivmoddi4+0x38>
    2570:	f1ce 0420 	rsb	r4, lr, #32
    2574:	fa20 f404 	lsr.w	r4, r0, r4
    2578:	fa01 f60e 	lsl.w	r6, r1, lr
    257c:	ea44 0c06 	orr.w	ip, r4, r6
    2580:	fa02 f70e 	lsl.w	r7, r2, lr
    2584:	fa00 f40e 	lsl.w	r4, r0, lr
    2588:	ea4f 4917 	mov.w	r9, r7, lsr #16
    258c:	0c22      	lsrs	r2, r4, #16
    258e:	fbbc f0f9 	udiv	r0, ip, r9
    2592:	fa1f f887 	uxth.w	r8, r7
    2596:	fb09 c610 	mls	r6, r9, r0, ip
    259a:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    259e:	fb00 f308 	mul.w	r3, r0, r8
    25a2:	42b3      	cmp	r3, r6
    25a4:	d909      	bls.n	25ba <__udivmoddi4+0x6a>
    25a6:	19f6      	adds	r6, r6, r7
    25a8:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    25ac:	f080 8122 	bcs.w	27f4 <__udivmoddi4+0x2a4>
    25b0:	42b3      	cmp	r3, r6
    25b2:	f240 811f 	bls.w	27f4 <__udivmoddi4+0x2a4>
    25b6:	3802      	subs	r0, #2
    25b8:	443e      	add	r6, r7
    25ba:	1af6      	subs	r6, r6, r3
    25bc:	b2a2      	uxth	r2, r4
    25be:	fbb6 f3f9 	udiv	r3, r6, r9
    25c2:	fb09 6613 	mls	r6, r9, r3, r6
    25c6:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    25ca:	fb03 f808 	mul.w	r8, r3, r8
    25ce:	45a0      	cmp	r8, r4
    25d0:	d909      	bls.n	25e6 <__udivmoddi4+0x96>
    25d2:	19e4      	adds	r4, r4, r7
    25d4:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    25d8:	f080 810a 	bcs.w	27f0 <__udivmoddi4+0x2a0>
    25dc:	45a0      	cmp	r8, r4
    25de:	f240 8107 	bls.w	27f0 <__udivmoddi4+0x2a0>
    25e2:	3b02      	subs	r3, #2
    25e4:	443c      	add	r4, r7
    25e6:	ebc8 0404 	rsb	r4, r8, r4
    25ea:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    25ee:	2100      	movs	r1, #0
    25f0:	2d00      	cmp	r5, #0
    25f2:	d062      	beq.n	26ba <__udivmoddi4+0x16a>
    25f4:	fa24 f40e 	lsr.w	r4, r4, lr
    25f8:	2300      	movs	r3, #0
    25fa:	602c      	str	r4, [r5, #0]
    25fc:	606b      	str	r3, [r5, #4]
    25fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2602:	428b      	cmp	r3, r1
    2604:	d907      	bls.n	2616 <__udivmoddi4+0xc6>
    2606:	2d00      	cmp	r5, #0
    2608:	d055      	beq.n	26b6 <__udivmoddi4+0x166>
    260a:	2100      	movs	r1, #0
    260c:	e885 0041 	stmia.w	r5, {r0, r6}
    2610:	4608      	mov	r0, r1
    2612:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2616:	fab3 f183 	clz	r1, r3
    261a:	2900      	cmp	r1, #0
    261c:	f040 8090 	bne.w	2740 <__udivmoddi4+0x1f0>
    2620:	42b3      	cmp	r3, r6
    2622:	d302      	bcc.n	262a <__udivmoddi4+0xda>
    2624:	4282      	cmp	r2, r0
    2626:	f200 80f8 	bhi.w	281a <__udivmoddi4+0x2ca>
    262a:	1a84      	subs	r4, r0, r2
    262c:	eb66 0603 	sbc.w	r6, r6, r3
    2630:	2001      	movs	r0, #1
    2632:	46b4      	mov	ip, r6
    2634:	2d00      	cmp	r5, #0
    2636:	d040      	beq.n	26ba <__udivmoddi4+0x16a>
    2638:	e885 1010 	stmia.w	r5, {r4, ip}
    263c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2640:	b912      	cbnz	r2, 2648 <__udivmoddi4+0xf8>
    2642:	2701      	movs	r7, #1
    2644:	fbb7 f7f2 	udiv	r7, r7, r2
    2648:	fab7 fe87 	clz	lr, r7
    264c:	f1be 0f00 	cmp.w	lr, #0
    2650:	d135      	bne.n	26be <__udivmoddi4+0x16e>
    2652:	1bf3      	subs	r3, r6, r7
    2654:	ea4f 4817 	mov.w	r8, r7, lsr #16
    2658:	fa1f fc87 	uxth.w	ip, r7
    265c:	2101      	movs	r1, #1
    265e:	fbb3 f0f8 	udiv	r0, r3, r8
    2662:	0c22      	lsrs	r2, r4, #16
    2664:	fb08 3610 	mls	r6, r8, r0, r3
    2668:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    266c:	fb0c f300 	mul.w	r3, ip, r0
    2670:	42b3      	cmp	r3, r6
    2672:	d907      	bls.n	2684 <__udivmoddi4+0x134>
    2674:	19f6      	adds	r6, r6, r7
    2676:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
    267a:	d202      	bcs.n	2682 <__udivmoddi4+0x132>
    267c:	42b3      	cmp	r3, r6
    267e:	f200 80ce 	bhi.w	281e <__udivmoddi4+0x2ce>
    2682:	4610      	mov	r0, r2
    2684:	1af6      	subs	r6, r6, r3
    2686:	b2a2      	uxth	r2, r4
    2688:	fbb6 f3f8 	udiv	r3, r6, r8
    268c:	fb08 6613 	mls	r6, r8, r3, r6
    2690:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
    2694:	fb0c fc03 	mul.w	ip, ip, r3
    2698:	45a4      	cmp	ip, r4
    269a:	d907      	bls.n	26ac <__udivmoddi4+0x15c>
    269c:	19e4      	adds	r4, r4, r7
    269e:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
    26a2:	d202      	bcs.n	26aa <__udivmoddi4+0x15a>
    26a4:	45a4      	cmp	ip, r4
    26a6:	f200 80b5 	bhi.w	2814 <__udivmoddi4+0x2c4>
    26aa:	4613      	mov	r3, r2
    26ac:	ebcc 0404 	rsb	r4, ip, r4
    26b0:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    26b4:	e79c      	b.n	25f0 <__udivmoddi4+0xa0>
    26b6:	4629      	mov	r1, r5
    26b8:	4628      	mov	r0, r5
    26ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    26be:	f1ce 0120 	rsb	r1, lr, #32
    26c2:	fa06 f30e 	lsl.w	r3, r6, lr
    26c6:	fa07 f70e 	lsl.w	r7, r7, lr
    26ca:	fa20 f901 	lsr.w	r9, r0, r1
    26ce:	ea4f 4817 	mov.w	r8, r7, lsr #16
    26d2:	40ce      	lsrs	r6, r1
    26d4:	ea49 0903 	orr.w	r9, r9, r3
    26d8:	fbb6 faf8 	udiv	sl, r6, r8
    26dc:	ea4f 4419 	mov.w	r4, r9, lsr #16
    26e0:	fb08 661a 	mls	r6, r8, sl, r6
    26e4:	fa1f fc87 	uxth.w	ip, r7
    26e8:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
    26ec:	fb0a f20c 	mul.w	r2, sl, ip
    26f0:	429a      	cmp	r2, r3
    26f2:	fa00 f40e 	lsl.w	r4, r0, lr
    26f6:	d90a      	bls.n	270e <__udivmoddi4+0x1be>
    26f8:	19db      	adds	r3, r3, r7
    26fa:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
    26fe:	f080 8087 	bcs.w	2810 <__udivmoddi4+0x2c0>
    2702:	429a      	cmp	r2, r3
    2704:	f240 8084 	bls.w	2810 <__udivmoddi4+0x2c0>
    2708:	f1aa 0a02 	sub.w	sl, sl, #2
    270c:	443b      	add	r3, r7
    270e:	1a9b      	subs	r3, r3, r2
    2710:	fa1f f989 	uxth.w	r9, r9
    2714:	fbb3 f1f8 	udiv	r1, r3, r8
    2718:	fb08 3311 	mls	r3, r8, r1, r3
    271c:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
    2720:	fb01 f60c 	mul.w	r6, r1, ip
    2724:	429e      	cmp	r6, r3
    2726:	d907      	bls.n	2738 <__udivmoddi4+0x1e8>
    2728:	19db      	adds	r3, r3, r7
    272a:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    272e:	d26b      	bcs.n	2808 <__udivmoddi4+0x2b8>
    2730:	429e      	cmp	r6, r3
    2732:	d969      	bls.n	2808 <__udivmoddi4+0x2b8>
    2734:	3902      	subs	r1, #2
    2736:	443b      	add	r3, r7
    2738:	1b9b      	subs	r3, r3, r6
    273a:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
    273e:	e78e      	b.n	265e <__udivmoddi4+0x10e>
    2740:	f1c1 0e20 	rsb	lr, r1, #32
    2744:	fa22 f40e 	lsr.w	r4, r2, lr
    2748:	408b      	lsls	r3, r1
    274a:	4323      	orrs	r3, r4
    274c:	fa20 f70e 	lsr.w	r7, r0, lr
    2750:	fa06 f401 	lsl.w	r4, r6, r1
    2754:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    2758:	fa26 f60e 	lsr.w	r6, r6, lr
    275c:	433c      	orrs	r4, r7
    275e:	fbb6 f9fc 	udiv	r9, r6, ip
    2762:	0c27      	lsrs	r7, r4, #16
    2764:	fb0c 6619 	mls	r6, ip, r9, r6
    2768:	fa1f f883 	uxth.w	r8, r3
    276c:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
    2770:	fb09 f708 	mul.w	r7, r9, r8
    2774:	42b7      	cmp	r7, r6
    2776:	fa02 f201 	lsl.w	r2, r2, r1
    277a:	fa00 fa01 	lsl.w	sl, r0, r1
    277e:	d908      	bls.n	2792 <__udivmoddi4+0x242>
    2780:	18f6      	adds	r6, r6, r3
    2782:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    2786:	d241      	bcs.n	280c <__udivmoddi4+0x2bc>
    2788:	42b7      	cmp	r7, r6
    278a:	d93f      	bls.n	280c <__udivmoddi4+0x2bc>
    278c:	f1a9 0902 	sub.w	r9, r9, #2
    2790:	441e      	add	r6, r3
    2792:	1bf6      	subs	r6, r6, r7
    2794:	b2a0      	uxth	r0, r4
    2796:	fbb6 f4fc 	udiv	r4, r6, ip
    279a:	fb0c 6614 	mls	r6, ip, r4, r6
    279e:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
    27a2:	fb04 f808 	mul.w	r8, r4, r8
    27a6:	45b8      	cmp	r8, r7
    27a8:	d907      	bls.n	27ba <__udivmoddi4+0x26a>
    27aa:	18ff      	adds	r7, r7, r3
    27ac:	f104 30ff 	add.w	r0, r4, #4294967295	; 0xffffffff
    27b0:	d228      	bcs.n	2804 <__udivmoddi4+0x2b4>
    27b2:	45b8      	cmp	r8, r7
    27b4:	d926      	bls.n	2804 <__udivmoddi4+0x2b4>
    27b6:	3c02      	subs	r4, #2
    27b8:	441f      	add	r7, r3
    27ba:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
    27be:	ebc8 0707 	rsb	r7, r8, r7
    27c2:	fba0 8902 	umull	r8, r9, r0, r2
    27c6:	454f      	cmp	r7, r9
    27c8:	4644      	mov	r4, r8
    27ca:	464e      	mov	r6, r9
    27cc:	d314      	bcc.n	27f8 <__udivmoddi4+0x2a8>
    27ce:	d029      	beq.n	2824 <__udivmoddi4+0x2d4>
    27d0:	b365      	cbz	r5, 282c <__udivmoddi4+0x2dc>
    27d2:	ebba 0304 	subs.w	r3, sl, r4
    27d6:	eb67 0706 	sbc.w	r7, r7, r6
    27da:	fa07 fe0e 	lsl.w	lr, r7, lr
    27de:	40cb      	lsrs	r3, r1
    27e0:	40cf      	lsrs	r7, r1
    27e2:	ea4e 0303 	orr.w	r3, lr, r3
    27e6:	e885 0088 	stmia.w	r5, {r3, r7}
    27ea:	2100      	movs	r1, #0
    27ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    27f0:	4613      	mov	r3, r2
    27f2:	e6f8      	b.n	25e6 <__udivmoddi4+0x96>
    27f4:	4610      	mov	r0, r2
    27f6:	e6e0      	b.n	25ba <__udivmoddi4+0x6a>
    27f8:	ebb8 0402 	subs.w	r4, r8, r2
    27fc:	eb69 0603 	sbc.w	r6, r9, r3
    2800:	3801      	subs	r0, #1
    2802:	e7e5      	b.n	27d0 <__udivmoddi4+0x280>
    2804:	4604      	mov	r4, r0
    2806:	e7d8      	b.n	27ba <__udivmoddi4+0x26a>
    2808:	4611      	mov	r1, r2
    280a:	e795      	b.n	2738 <__udivmoddi4+0x1e8>
    280c:	4681      	mov	r9, r0
    280e:	e7c0      	b.n	2792 <__udivmoddi4+0x242>
    2810:	468a      	mov	sl, r1
    2812:	e77c      	b.n	270e <__udivmoddi4+0x1be>
    2814:	3b02      	subs	r3, #2
    2816:	443c      	add	r4, r7
    2818:	e748      	b.n	26ac <__udivmoddi4+0x15c>
    281a:	4608      	mov	r0, r1
    281c:	e70a      	b.n	2634 <__udivmoddi4+0xe4>
    281e:	3802      	subs	r0, #2
    2820:	443e      	add	r6, r7
    2822:	e72f      	b.n	2684 <__udivmoddi4+0x134>
    2824:	45c2      	cmp	sl, r8
    2826:	d3e7      	bcc.n	27f8 <__udivmoddi4+0x2a8>
    2828:	463e      	mov	r6, r7
    282a:	e7d1      	b.n	27d0 <__udivmoddi4+0x280>
    282c:	4629      	mov	r1, r5
    282e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2832:	bf00      	nop

00002834 <__aeabi_idiv0>:
    2834:	4770      	bx	lr
    2836:	bf00      	nop

00002838 <__cxa_atexit>:
    2838:	4613      	mov	r3, r2
    283a:	460a      	mov	r2, r1
    283c:	4601      	mov	r1, r0
    283e:	2002      	movs	r0, #2
    2840:	f000 bfe2 	b.w	3808 <__register_exitproc>

00002844 <__errno>:
    2844:	4b01      	ldr	r3, [pc, #4]	; (284c <__errno+0x8>)
    2846:	6818      	ldr	r0, [r3, #0]
    2848:	4770      	bx	lr
    284a:	bf00      	nop
    284c:	200011c8 	.word	0x200011c8

00002850 <__libc_init_array>:
    2850:	b570      	push	{r4, r5, r6, lr}
    2852:	4e0f      	ldr	r6, [pc, #60]	; (2890 <__libc_init_array+0x40>)
    2854:	4d0f      	ldr	r5, [pc, #60]	; (2894 <__libc_init_array+0x44>)
    2856:	1b76      	subs	r6, r6, r5
    2858:	10b6      	asrs	r6, r6, #2
    285a:	bf18      	it	ne
    285c:	2400      	movne	r4, #0
    285e:	d005      	beq.n	286c <__libc_init_array+0x1c>
    2860:	3401      	adds	r4, #1
    2862:	f855 3b04 	ldr.w	r3, [r5], #4
    2866:	4798      	blx	r3
    2868:	42a6      	cmp	r6, r4
    286a:	d1f9      	bne.n	2860 <__libc_init_array+0x10>
    286c:	4e0a      	ldr	r6, [pc, #40]	; (2898 <__libc_init_array+0x48>)
    286e:	4d0b      	ldr	r5, [pc, #44]	; (289c <__libc_init_array+0x4c>)
    2870:	1b76      	subs	r6, r6, r5
    2872:	f003 ff39 	bl	66e8 <___init_veneer>
    2876:	10b6      	asrs	r6, r6, #2
    2878:	bf18      	it	ne
    287a:	2400      	movne	r4, #0
    287c:	d006      	beq.n	288c <__libc_init_array+0x3c>
    287e:	3401      	adds	r4, #1
    2880:	f855 3b04 	ldr.w	r3, [r5], #4
    2884:	4798      	blx	r3
    2886:	42a6      	cmp	r6, r4
    2888:	d1f9      	bne.n	287e <__libc_init_array+0x2e>
    288a:	bd70      	pop	{r4, r5, r6, pc}
    288c:	bd70      	pop	{r4, r5, r6, pc}
    288e:	bf00      	nop
    2890:	60001e68 	.word	0x60001e68
    2894:	60001e68 	.word	0x60001e68
    2898:	60001e74 	.word	0x60001e74
    289c:	60001e68 	.word	0x60001e68

000028a0 <__itoa>:
    28a0:	1e93      	subs	r3, r2, #2
    28a2:	2b22      	cmp	r3, #34	; 0x22
    28a4:	d810      	bhi.n	28c8 <__itoa+0x28>
    28a6:	2a0a      	cmp	r2, #10
    28a8:	b510      	push	{r4, lr}
    28aa:	d006      	beq.n	28ba <__itoa+0x1a>
    28ac:	2300      	movs	r3, #0
    28ae:	460c      	mov	r4, r1
    28b0:	4419      	add	r1, r3
    28b2:	f000 ff13 	bl	36dc <__utoa>
    28b6:	4620      	mov	r0, r4
    28b8:	bd10      	pop	{r4, pc}
    28ba:	2800      	cmp	r0, #0
    28bc:	daf6      	bge.n	28ac <__itoa+0xc>
    28be:	232d      	movs	r3, #45	; 0x2d
    28c0:	700b      	strb	r3, [r1, #0]
    28c2:	4240      	negs	r0, r0
    28c4:	2301      	movs	r3, #1
    28c6:	e7f2      	b.n	28ae <__itoa+0xe>
    28c8:	2000      	movs	r0, #0
    28ca:	7008      	strb	r0, [r1, #0]
    28cc:	4770      	bx	lr
    28ce:	bf00      	nop

000028d0 <itoa>:
    28d0:	f7ff bfe6 	b.w	28a0 <__itoa>

000028d4 <malloc>:
    28d4:	4b02      	ldr	r3, [pc, #8]	; (28e0 <malloc+0xc>)
    28d6:	4601      	mov	r1, r0
    28d8:	6818      	ldr	r0, [r3, #0]
    28da:	f000 b80b 	b.w	28f4 <_malloc_r>
    28de:	bf00      	nop
    28e0:	200011c8 	.word	0x200011c8

000028e4 <free>:
    28e4:	4b02      	ldr	r3, [pc, #8]	; (28f0 <free+0xc>)
    28e6:	4601      	mov	r1, r0
    28e8:	6818      	ldr	r0, [r3, #0]
    28ea:	f001 b82d 	b.w	3948 <_free_r>
    28ee:	bf00      	nop
    28f0:	200011c8 	.word	0x200011c8

000028f4 <_malloc_r>:
    28f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    28f8:	f101 050b 	add.w	r5, r1, #11
    28fc:	2d16      	cmp	r5, #22
    28fe:	b083      	sub	sp, #12
    2900:	4606      	mov	r6, r0
    2902:	f240 809f 	bls.w	2a44 <_malloc_r+0x150>
    2906:	f035 0507 	bics.w	r5, r5, #7
    290a:	f100 80bf 	bmi.w	2a8c <_malloc_r+0x198>
    290e:	42a9      	cmp	r1, r5
    2910:	f200 80bc 	bhi.w	2a8c <_malloc_r+0x198>
    2914:	f000 fc08 	bl	3128 <__malloc_lock>
    2918:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    291c:	f0c0 829c 	bcc.w	2e58 <_malloc_r+0x564>
    2920:	0a6b      	lsrs	r3, r5, #9
    2922:	f000 80ba 	beq.w	2a9a <_malloc_r+0x1a6>
    2926:	2b04      	cmp	r3, #4
    2928:	f200 8183 	bhi.w	2c32 <_malloc_r+0x33e>
    292c:	09a8      	lsrs	r0, r5, #6
    292e:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    2932:	ea4f 034e 	mov.w	r3, lr, lsl #1
    2936:	3038      	adds	r0, #56	; 0x38
    2938:	4fc4      	ldr	r7, [pc, #784]	; (2c4c <_malloc_r+0x358>)
    293a:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    293e:	f1a3 0108 	sub.w	r1, r3, #8
    2942:	685c      	ldr	r4, [r3, #4]
    2944:	42a1      	cmp	r1, r4
    2946:	d107      	bne.n	2958 <_malloc_r+0x64>
    2948:	e0ac      	b.n	2aa4 <_malloc_r+0x1b0>
    294a:	2a00      	cmp	r2, #0
    294c:	f280 80ac 	bge.w	2aa8 <_malloc_r+0x1b4>
    2950:	68e4      	ldr	r4, [r4, #12]
    2952:	42a1      	cmp	r1, r4
    2954:	f000 80a6 	beq.w	2aa4 <_malloc_r+0x1b0>
    2958:	6863      	ldr	r3, [r4, #4]
    295a:	f023 0303 	bic.w	r3, r3, #3
    295e:	1b5a      	subs	r2, r3, r5
    2960:	2a0f      	cmp	r2, #15
    2962:	ddf2      	ble.n	294a <_malloc_r+0x56>
    2964:	49b9      	ldr	r1, [pc, #740]	; (2c4c <_malloc_r+0x358>)
    2966:	693c      	ldr	r4, [r7, #16]
    2968:	f101 0e08 	add.w	lr, r1, #8
    296c:	4574      	cmp	r4, lr
    296e:	f000 81b3 	beq.w	2cd8 <_malloc_r+0x3e4>
    2972:	6863      	ldr	r3, [r4, #4]
    2974:	f023 0303 	bic.w	r3, r3, #3
    2978:	1b5a      	subs	r2, r3, r5
    297a:	2a0f      	cmp	r2, #15
    297c:	f300 8199 	bgt.w	2cb2 <_malloc_r+0x3be>
    2980:	2a00      	cmp	r2, #0
    2982:	f8c1 e014 	str.w	lr, [r1, #20]
    2986:	f8c1 e010 	str.w	lr, [r1, #16]
    298a:	f280 809e 	bge.w	2aca <_malloc_r+0x1d6>
    298e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    2992:	f080 8167 	bcs.w	2c64 <_malloc_r+0x370>
    2996:	08db      	lsrs	r3, r3, #3
    2998:	f103 0c01 	add.w	ip, r3, #1
    299c:	2201      	movs	r2, #1
    299e:	109b      	asrs	r3, r3, #2
    29a0:	fa02 f303 	lsl.w	r3, r2, r3
    29a4:	684a      	ldr	r2, [r1, #4]
    29a6:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    29aa:	f8c4 8008 	str.w	r8, [r4, #8]
    29ae:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    29b2:	431a      	orrs	r2, r3
    29b4:	f1a9 0308 	sub.w	r3, r9, #8
    29b8:	60e3      	str	r3, [r4, #12]
    29ba:	604a      	str	r2, [r1, #4]
    29bc:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    29c0:	f8c8 400c 	str.w	r4, [r8, #12]
    29c4:	1083      	asrs	r3, r0, #2
    29c6:	2401      	movs	r4, #1
    29c8:	409c      	lsls	r4, r3
    29ca:	4294      	cmp	r4, r2
    29cc:	f200 808a 	bhi.w	2ae4 <_malloc_r+0x1f0>
    29d0:	4214      	tst	r4, r2
    29d2:	d106      	bne.n	29e2 <_malloc_r+0xee>
    29d4:	f020 0003 	bic.w	r0, r0, #3
    29d8:	0064      	lsls	r4, r4, #1
    29da:	4214      	tst	r4, r2
    29dc:	f100 0004 	add.w	r0, r0, #4
    29e0:	d0fa      	beq.n	29d8 <_malloc_r+0xe4>
    29e2:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    29e6:	46cc      	mov	ip, r9
    29e8:	4680      	mov	r8, r0
    29ea:	f8dc 100c 	ldr.w	r1, [ip, #12]
    29ee:	458c      	cmp	ip, r1
    29f0:	d107      	bne.n	2a02 <_malloc_r+0x10e>
    29f2:	e173      	b.n	2cdc <_malloc_r+0x3e8>
    29f4:	2a00      	cmp	r2, #0
    29f6:	f280 8181 	bge.w	2cfc <_malloc_r+0x408>
    29fa:	68c9      	ldr	r1, [r1, #12]
    29fc:	458c      	cmp	ip, r1
    29fe:	f000 816d 	beq.w	2cdc <_malloc_r+0x3e8>
    2a02:	684b      	ldr	r3, [r1, #4]
    2a04:	f023 0303 	bic.w	r3, r3, #3
    2a08:	1b5a      	subs	r2, r3, r5
    2a0a:	2a0f      	cmp	r2, #15
    2a0c:	ddf2      	ble.n	29f4 <_malloc_r+0x100>
    2a0e:	460c      	mov	r4, r1
    2a10:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    2a14:	f854 8f08 	ldr.w	r8, [r4, #8]!
    2a18:	194b      	adds	r3, r1, r5
    2a1a:	f045 0501 	orr.w	r5, r5, #1
    2a1e:	604d      	str	r5, [r1, #4]
    2a20:	f042 0101 	orr.w	r1, r2, #1
    2a24:	f8c8 c00c 	str.w	ip, [r8, #12]
    2a28:	4630      	mov	r0, r6
    2a2a:	f8cc 8008 	str.w	r8, [ip, #8]
    2a2e:	617b      	str	r3, [r7, #20]
    2a30:	613b      	str	r3, [r7, #16]
    2a32:	f8c3 e00c 	str.w	lr, [r3, #12]
    2a36:	f8c3 e008 	str.w	lr, [r3, #8]
    2a3a:	6059      	str	r1, [r3, #4]
    2a3c:	509a      	str	r2, [r3, r2]
    2a3e:	f000 fb75 	bl	312c <__malloc_unlock>
    2a42:	e01f      	b.n	2a84 <_malloc_r+0x190>
    2a44:	2910      	cmp	r1, #16
    2a46:	d821      	bhi.n	2a8c <_malloc_r+0x198>
    2a48:	f000 fb6e 	bl	3128 <__malloc_lock>
    2a4c:	2510      	movs	r5, #16
    2a4e:	2306      	movs	r3, #6
    2a50:	2002      	movs	r0, #2
    2a52:	4f7e      	ldr	r7, [pc, #504]	; (2c4c <_malloc_r+0x358>)
    2a54:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    2a58:	f1a3 0208 	sub.w	r2, r3, #8
    2a5c:	685c      	ldr	r4, [r3, #4]
    2a5e:	4294      	cmp	r4, r2
    2a60:	f000 8145 	beq.w	2cee <_malloc_r+0x3fa>
    2a64:	6863      	ldr	r3, [r4, #4]
    2a66:	68e1      	ldr	r1, [r4, #12]
    2a68:	68a5      	ldr	r5, [r4, #8]
    2a6a:	f023 0303 	bic.w	r3, r3, #3
    2a6e:	4423      	add	r3, r4
    2a70:	4630      	mov	r0, r6
    2a72:	685a      	ldr	r2, [r3, #4]
    2a74:	60e9      	str	r1, [r5, #12]
    2a76:	f042 0201 	orr.w	r2, r2, #1
    2a7a:	608d      	str	r5, [r1, #8]
    2a7c:	605a      	str	r2, [r3, #4]
    2a7e:	f000 fb55 	bl	312c <__malloc_unlock>
    2a82:	3408      	adds	r4, #8
    2a84:	4620      	mov	r0, r4
    2a86:	b003      	add	sp, #12
    2a88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2a8c:	2400      	movs	r4, #0
    2a8e:	230c      	movs	r3, #12
    2a90:	4620      	mov	r0, r4
    2a92:	6033      	str	r3, [r6, #0]
    2a94:	b003      	add	sp, #12
    2a96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2a9a:	2380      	movs	r3, #128	; 0x80
    2a9c:	f04f 0e40 	mov.w	lr, #64	; 0x40
    2aa0:	203f      	movs	r0, #63	; 0x3f
    2aa2:	e749      	b.n	2938 <_malloc_r+0x44>
    2aa4:	4670      	mov	r0, lr
    2aa6:	e75d      	b.n	2964 <_malloc_r+0x70>
    2aa8:	4423      	add	r3, r4
    2aaa:	68e1      	ldr	r1, [r4, #12]
    2aac:	685a      	ldr	r2, [r3, #4]
    2aae:	68a5      	ldr	r5, [r4, #8]
    2ab0:	f042 0201 	orr.w	r2, r2, #1
    2ab4:	60e9      	str	r1, [r5, #12]
    2ab6:	4630      	mov	r0, r6
    2ab8:	608d      	str	r5, [r1, #8]
    2aba:	605a      	str	r2, [r3, #4]
    2abc:	f000 fb36 	bl	312c <__malloc_unlock>
    2ac0:	3408      	adds	r4, #8
    2ac2:	4620      	mov	r0, r4
    2ac4:	b003      	add	sp, #12
    2ac6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2aca:	4423      	add	r3, r4
    2acc:	4630      	mov	r0, r6
    2ace:	685a      	ldr	r2, [r3, #4]
    2ad0:	f042 0201 	orr.w	r2, r2, #1
    2ad4:	605a      	str	r2, [r3, #4]
    2ad6:	f000 fb29 	bl	312c <__malloc_unlock>
    2ada:	3408      	adds	r4, #8
    2adc:	4620      	mov	r0, r4
    2ade:	b003      	add	sp, #12
    2ae0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2ae4:	68bc      	ldr	r4, [r7, #8]
    2ae6:	6863      	ldr	r3, [r4, #4]
    2ae8:	f023 0803 	bic.w	r8, r3, #3
    2aec:	45a8      	cmp	r8, r5
    2aee:	d304      	bcc.n	2afa <_malloc_r+0x206>
    2af0:	ebc5 0308 	rsb	r3, r5, r8
    2af4:	2b0f      	cmp	r3, #15
    2af6:	f300 808c 	bgt.w	2c12 <_malloc_r+0x31e>
    2afa:	4b55      	ldr	r3, [pc, #340]	; (2c50 <_malloc_r+0x35c>)
    2afc:	f8df 9160 	ldr.w	r9, [pc, #352]	; 2c60 <_malloc_r+0x36c>
    2b00:	681a      	ldr	r2, [r3, #0]
    2b02:	f8d9 3000 	ldr.w	r3, [r9]
    2b06:	3301      	adds	r3, #1
    2b08:	442a      	add	r2, r5
    2b0a:	eb04 0a08 	add.w	sl, r4, r8
    2b0e:	f000 8160 	beq.w	2dd2 <_malloc_r+0x4de>
    2b12:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    2b16:	320f      	adds	r2, #15
    2b18:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    2b1c:	f022 020f 	bic.w	r2, r2, #15
    2b20:	4611      	mov	r1, r2
    2b22:	4630      	mov	r0, r6
    2b24:	9201      	str	r2, [sp, #4]
    2b26:	f000 fcfb 	bl	3520 <_sbrk_r>
    2b2a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    2b2e:	4683      	mov	fp, r0
    2b30:	9a01      	ldr	r2, [sp, #4]
    2b32:	f000 8158 	beq.w	2de6 <_malloc_r+0x4f2>
    2b36:	4582      	cmp	sl, r0
    2b38:	f200 80fc 	bhi.w	2d34 <_malloc_r+0x440>
    2b3c:	4b45      	ldr	r3, [pc, #276]	; (2c54 <_malloc_r+0x360>)
    2b3e:	6819      	ldr	r1, [r3, #0]
    2b40:	45da      	cmp	sl, fp
    2b42:	4411      	add	r1, r2
    2b44:	6019      	str	r1, [r3, #0]
    2b46:	f000 8153 	beq.w	2df0 <_malloc_r+0x4fc>
    2b4a:	f8d9 0000 	ldr.w	r0, [r9]
    2b4e:	f8df e110 	ldr.w	lr, [pc, #272]	; 2c60 <_malloc_r+0x36c>
    2b52:	3001      	adds	r0, #1
    2b54:	bf1b      	ittet	ne
    2b56:	ebca 0a0b 	rsbne	sl, sl, fp
    2b5a:	4451      	addne	r1, sl
    2b5c:	f8ce b000 	streq.w	fp, [lr]
    2b60:	6019      	strne	r1, [r3, #0]
    2b62:	f01b 0107 	ands.w	r1, fp, #7
    2b66:	f000 8117 	beq.w	2d98 <_malloc_r+0x4a4>
    2b6a:	f1c1 0008 	rsb	r0, r1, #8
    2b6e:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    2b72:	4483      	add	fp, r0
    2b74:	3108      	adds	r1, #8
    2b76:	445a      	add	r2, fp
    2b78:	f3c2 020b 	ubfx	r2, r2, #0, #12
    2b7c:	ebc2 0901 	rsb	r9, r2, r1
    2b80:	4649      	mov	r1, r9
    2b82:	4630      	mov	r0, r6
    2b84:	9301      	str	r3, [sp, #4]
    2b86:	f000 fccb 	bl	3520 <_sbrk_r>
    2b8a:	1c43      	adds	r3, r0, #1
    2b8c:	9b01      	ldr	r3, [sp, #4]
    2b8e:	f000 813f 	beq.w	2e10 <_malloc_r+0x51c>
    2b92:	ebcb 0200 	rsb	r2, fp, r0
    2b96:	444a      	add	r2, r9
    2b98:	f042 0201 	orr.w	r2, r2, #1
    2b9c:	6819      	ldr	r1, [r3, #0]
    2b9e:	f8c7 b008 	str.w	fp, [r7, #8]
    2ba2:	4449      	add	r1, r9
    2ba4:	42bc      	cmp	r4, r7
    2ba6:	f8cb 2004 	str.w	r2, [fp, #4]
    2baa:	6019      	str	r1, [r3, #0]
    2bac:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 2c54 <_malloc_r+0x360>
    2bb0:	d016      	beq.n	2be0 <_malloc_r+0x2ec>
    2bb2:	f1b8 0f0f 	cmp.w	r8, #15
    2bb6:	f240 80fd 	bls.w	2db4 <_malloc_r+0x4c0>
    2bba:	6862      	ldr	r2, [r4, #4]
    2bbc:	f1a8 030c 	sub.w	r3, r8, #12
    2bc0:	f023 0307 	bic.w	r3, r3, #7
    2bc4:	18e0      	adds	r0, r4, r3
    2bc6:	f002 0201 	and.w	r2, r2, #1
    2bca:	f04f 0e05 	mov.w	lr, #5
    2bce:	431a      	orrs	r2, r3
    2bd0:	2b0f      	cmp	r3, #15
    2bd2:	6062      	str	r2, [r4, #4]
    2bd4:	f8c0 e004 	str.w	lr, [r0, #4]
    2bd8:	f8c0 e008 	str.w	lr, [r0, #8]
    2bdc:	f200 811c 	bhi.w	2e18 <_malloc_r+0x524>
    2be0:	4b1d      	ldr	r3, [pc, #116]	; (2c58 <_malloc_r+0x364>)
    2be2:	68bc      	ldr	r4, [r7, #8]
    2be4:	681a      	ldr	r2, [r3, #0]
    2be6:	4291      	cmp	r1, r2
    2be8:	bf88      	it	hi
    2bea:	6019      	strhi	r1, [r3, #0]
    2bec:	4b1b      	ldr	r3, [pc, #108]	; (2c5c <_malloc_r+0x368>)
    2bee:	681a      	ldr	r2, [r3, #0]
    2bf0:	4291      	cmp	r1, r2
    2bf2:	6862      	ldr	r2, [r4, #4]
    2bf4:	bf88      	it	hi
    2bf6:	6019      	strhi	r1, [r3, #0]
    2bf8:	f022 0203 	bic.w	r2, r2, #3
    2bfc:	4295      	cmp	r5, r2
    2bfe:	eba2 0305 	sub.w	r3, r2, r5
    2c02:	d801      	bhi.n	2c08 <_malloc_r+0x314>
    2c04:	2b0f      	cmp	r3, #15
    2c06:	dc04      	bgt.n	2c12 <_malloc_r+0x31e>
    2c08:	4630      	mov	r0, r6
    2c0a:	f000 fa8f 	bl	312c <__malloc_unlock>
    2c0e:	2400      	movs	r4, #0
    2c10:	e738      	b.n	2a84 <_malloc_r+0x190>
    2c12:	1962      	adds	r2, r4, r5
    2c14:	f043 0301 	orr.w	r3, r3, #1
    2c18:	f045 0501 	orr.w	r5, r5, #1
    2c1c:	6065      	str	r5, [r4, #4]
    2c1e:	4630      	mov	r0, r6
    2c20:	60ba      	str	r2, [r7, #8]
    2c22:	6053      	str	r3, [r2, #4]
    2c24:	f000 fa82 	bl	312c <__malloc_unlock>
    2c28:	3408      	adds	r4, #8
    2c2a:	4620      	mov	r0, r4
    2c2c:	b003      	add	sp, #12
    2c2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2c32:	2b14      	cmp	r3, #20
    2c34:	d971      	bls.n	2d1a <_malloc_r+0x426>
    2c36:	2b54      	cmp	r3, #84	; 0x54
    2c38:	f200 80a4 	bhi.w	2d84 <_malloc_r+0x490>
    2c3c:	0b28      	lsrs	r0, r5, #12
    2c3e:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    2c42:	ea4f 034e 	mov.w	r3, lr, lsl #1
    2c46:	306e      	adds	r0, #110	; 0x6e
    2c48:	e676      	b.n	2938 <_malloc_r+0x44>
    2c4a:	bf00      	nop
    2c4c:	20000db8 	.word	0x20000db8
    2c50:	20001ae4 	.word	0x20001ae4
    2c54:	20001ab4 	.word	0x20001ab4
    2c58:	20001adc 	.word	0x20001adc
    2c5c:	20001ae0 	.word	0x20001ae0
    2c60:	200011c0 	.word	0x200011c0
    2c64:	0a5a      	lsrs	r2, r3, #9
    2c66:	2a04      	cmp	r2, #4
    2c68:	d95e      	bls.n	2d28 <_malloc_r+0x434>
    2c6a:	2a14      	cmp	r2, #20
    2c6c:	f200 80b3 	bhi.w	2dd6 <_malloc_r+0x4e2>
    2c70:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    2c74:	0049      	lsls	r1, r1, #1
    2c76:	325b      	adds	r2, #91	; 0x5b
    2c78:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    2c7c:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    2c80:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 2e60 <_malloc_r+0x56c>
    2c84:	f1ac 0c08 	sub.w	ip, ip, #8
    2c88:	458c      	cmp	ip, r1
    2c8a:	f000 8088 	beq.w	2d9e <_malloc_r+0x4aa>
    2c8e:	684a      	ldr	r2, [r1, #4]
    2c90:	f022 0203 	bic.w	r2, r2, #3
    2c94:	4293      	cmp	r3, r2
    2c96:	d202      	bcs.n	2c9e <_malloc_r+0x3aa>
    2c98:	6889      	ldr	r1, [r1, #8]
    2c9a:	458c      	cmp	ip, r1
    2c9c:	d1f7      	bne.n	2c8e <_malloc_r+0x39a>
    2c9e:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    2ca2:	687a      	ldr	r2, [r7, #4]
    2ca4:	f8c4 c00c 	str.w	ip, [r4, #12]
    2ca8:	60a1      	str	r1, [r4, #8]
    2caa:	f8cc 4008 	str.w	r4, [ip, #8]
    2cae:	60cc      	str	r4, [r1, #12]
    2cb0:	e688      	b.n	29c4 <_malloc_r+0xd0>
    2cb2:	1963      	adds	r3, r4, r5
    2cb4:	f042 0701 	orr.w	r7, r2, #1
    2cb8:	f045 0501 	orr.w	r5, r5, #1
    2cbc:	6065      	str	r5, [r4, #4]
    2cbe:	4630      	mov	r0, r6
    2cc0:	614b      	str	r3, [r1, #20]
    2cc2:	610b      	str	r3, [r1, #16]
    2cc4:	f8c3 e00c 	str.w	lr, [r3, #12]
    2cc8:	f8c3 e008 	str.w	lr, [r3, #8]
    2ccc:	605f      	str	r7, [r3, #4]
    2cce:	509a      	str	r2, [r3, r2]
    2cd0:	3408      	adds	r4, #8
    2cd2:	f000 fa2b 	bl	312c <__malloc_unlock>
    2cd6:	e6d5      	b.n	2a84 <_malloc_r+0x190>
    2cd8:	684a      	ldr	r2, [r1, #4]
    2cda:	e673      	b.n	29c4 <_malloc_r+0xd0>
    2cdc:	f108 0801 	add.w	r8, r8, #1
    2ce0:	f018 0f03 	tst.w	r8, #3
    2ce4:	f10c 0c08 	add.w	ip, ip, #8
    2ce8:	f47f ae7f 	bne.w	29ea <_malloc_r+0xf6>
    2cec:	e030      	b.n	2d50 <_malloc_r+0x45c>
    2cee:	68dc      	ldr	r4, [r3, #12]
    2cf0:	42a3      	cmp	r3, r4
    2cf2:	bf08      	it	eq
    2cf4:	3002      	addeq	r0, #2
    2cf6:	f43f ae35 	beq.w	2964 <_malloc_r+0x70>
    2cfa:	e6b3      	b.n	2a64 <_malloc_r+0x170>
    2cfc:	440b      	add	r3, r1
    2cfe:	460c      	mov	r4, r1
    2d00:	685a      	ldr	r2, [r3, #4]
    2d02:	68c9      	ldr	r1, [r1, #12]
    2d04:	f854 5f08 	ldr.w	r5, [r4, #8]!
    2d08:	f042 0201 	orr.w	r2, r2, #1
    2d0c:	605a      	str	r2, [r3, #4]
    2d0e:	4630      	mov	r0, r6
    2d10:	60e9      	str	r1, [r5, #12]
    2d12:	608d      	str	r5, [r1, #8]
    2d14:	f000 fa0a 	bl	312c <__malloc_unlock>
    2d18:	e6b4      	b.n	2a84 <_malloc_r+0x190>
    2d1a:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    2d1e:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    2d22:	ea4f 034e 	mov.w	r3, lr, lsl #1
    2d26:	e607      	b.n	2938 <_malloc_r+0x44>
    2d28:	099a      	lsrs	r2, r3, #6
    2d2a:	f102 0139 	add.w	r1, r2, #57	; 0x39
    2d2e:	0049      	lsls	r1, r1, #1
    2d30:	3238      	adds	r2, #56	; 0x38
    2d32:	e7a1      	b.n	2c78 <_malloc_r+0x384>
    2d34:	42bc      	cmp	r4, r7
    2d36:	4b4a      	ldr	r3, [pc, #296]	; (2e60 <_malloc_r+0x56c>)
    2d38:	f43f af00 	beq.w	2b3c <_malloc_r+0x248>
    2d3c:	689c      	ldr	r4, [r3, #8]
    2d3e:	6862      	ldr	r2, [r4, #4]
    2d40:	f022 0203 	bic.w	r2, r2, #3
    2d44:	e75a      	b.n	2bfc <_malloc_r+0x308>
    2d46:	f859 3908 	ldr.w	r3, [r9], #-8
    2d4a:	4599      	cmp	r9, r3
    2d4c:	f040 8082 	bne.w	2e54 <_malloc_r+0x560>
    2d50:	f010 0f03 	tst.w	r0, #3
    2d54:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    2d58:	d1f5      	bne.n	2d46 <_malloc_r+0x452>
    2d5a:	687b      	ldr	r3, [r7, #4]
    2d5c:	ea23 0304 	bic.w	r3, r3, r4
    2d60:	607b      	str	r3, [r7, #4]
    2d62:	0064      	lsls	r4, r4, #1
    2d64:	429c      	cmp	r4, r3
    2d66:	f63f aebd 	bhi.w	2ae4 <_malloc_r+0x1f0>
    2d6a:	2c00      	cmp	r4, #0
    2d6c:	f43f aeba 	beq.w	2ae4 <_malloc_r+0x1f0>
    2d70:	421c      	tst	r4, r3
    2d72:	4640      	mov	r0, r8
    2d74:	f47f ae35 	bne.w	29e2 <_malloc_r+0xee>
    2d78:	0064      	lsls	r4, r4, #1
    2d7a:	421c      	tst	r4, r3
    2d7c:	f100 0004 	add.w	r0, r0, #4
    2d80:	d0fa      	beq.n	2d78 <_malloc_r+0x484>
    2d82:	e62e      	b.n	29e2 <_malloc_r+0xee>
    2d84:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    2d88:	d818      	bhi.n	2dbc <_malloc_r+0x4c8>
    2d8a:	0be8      	lsrs	r0, r5, #15
    2d8c:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    2d90:	ea4f 034e 	mov.w	r3, lr, lsl #1
    2d94:	3077      	adds	r0, #119	; 0x77
    2d96:	e5cf      	b.n	2938 <_malloc_r+0x44>
    2d98:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    2d9c:	e6eb      	b.n	2b76 <_malloc_r+0x282>
    2d9e:	2101      	movs	r1, #1
    2da0:	f8d8 3004 	ldr.w	r3, [r8, #4]
    2da4:	1092      	asrs	r2, r2, #2
    2da6:	fa01 f202 	lsl.w	r2, r1, r2
    2daa:	431a      	orrs	r2, r3
    2dac:	f8c8 2004 	str.w	r2, [r8, #4]
    2db0:	4661      	mov	r1, ip
    2db2:	e777      	b.n	2ca4 <_malloc_r+0x3b0>
    2db4:	2301      	movs	r3, #1
    2db6:	f8cb 3004 	str.w	r3, [fp, #4]
    2dba:	e725      	b.n	2c08 <_malloc_r+0x314>
    2dbc:	f240 5254 	movw	r2, #1364	; 0x554
    2dc0:	4293      	cmp	r3, r2
    2dc2:	d820      	bhi.n	2e06 <_malloc_r+0x512>
    2dc4:	0ca8      	lsrs	r0, r5, #18
    2dc6:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    2dca:	ea4f 034e 	mov.w	r3, lr, lsl #1
    2dce:	307c      	adds	r0, #124	; 0x7c
    2dd0:	e5b2      	b.n	2938 <_malloc_r+0x44>
    2dd2:	3210      	adds	r2, #16
    2dd4:	e6a4      	b.n	2b20 <_malloc_r+0x22c>
    2dd6:	2a54      	cmp	r2, #84	; 0x54
    2dd8:	d826      	bhi.n	2e28 <_malloc_r+0x534>
    2dda:	0b1a      	lsrs	r2, r3, #12
    2ddc:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    2de0:	0049      	lsls	r1, r1, #1
    2de2:	326e      	adds	r2, #110	; 0x6e
    2de4:	e748      	b.n	2c78 <_malloc_r+0x384>
    2de6:	68bc      	ldr	r4, [r7, #8]
    2de8:	6862      	ldr	r2, [r4, #4]
    2dea:	f022 0203 	bic.w	r2, r2, #3
    2dee:	e705      	b.n	2bfc <_malloc_r+0x308>
    2df0:	f3ca 000b 	ubfx	r0, sl, #0, #12
    2df4:	2800      	cmp	r0, #0
    2df6:	f47f aea8 	bne.w	2b4a <_malloc_r+0x256>
    2dfa:	4442      	add	r2, r8
    2dfc:	68bb      	ldr	r3, [r7, #8]
    2dfe:	f042 0201 	orr.w	r2, r2, #1
    2e02:	605a      	str	r2, [r3, #4]
    2e04:	e6ec      	b.n	2be0 <_malloc_r+0x2ec>
    2e06:	23fe      	movs	r3, #254	; 0xfe
    2e08:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    2e0c:	207e      	movs	r0, #126	; 0x7e
    2e0e:	e593      	b.n	2938 <_malloc_r+0x44>
    2e10:	2201      	movs	r2, #1
    2e12:	f04f 0900 	mov.w	r9, #0
    2e16:	e6c1      	b.n	2b9c <_malloc_r+0x2a8>
    2e18:	f104 0108 	add.w	r1, r4, #8
    2e1c:	4630      	mov	r0, r6
    2e1e:	f000 fd93 	bl	3948 <_free_r>
    2e22:	f8d9 1000 	ldr.w	r1, [r9]
    2e26:	e6db      	b.n	2be0 <_malloc_r+0x2ec>
    2e28:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    2e2c:	d805      	bhi.n	2e3a <_malloc_r+0x546>
    2e2e:	0bda      	lsrs	r2, r3, #15
    2e30:	f102 0178 	add.w	r1, r2, #120	; 0x78
    2e34:	0049      	lsls	r1, r1, #1
    2e36:	3277      	adds	r2, #119	; 0x77
    2e38:	e71e      	b.n	2c78 <_malloc_r+0x384>
    2e3a:	f240 5154 	movw	r1, #1364	; 0x554
    2e3e:	428a      	cmp	r2, r1
    2e40:	d805      	bhi.n	2e4e <_malloc_r+0x55a>
    2e42:	0c9a      	lsrs	r2, r3, #18
    2e44:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    2e48:	0049      	lsls	r1, r1, #1
    2e4a:	327c      	adds	r2, #124	; 0x7c
    2e4c:	e714      	b.n	2c78 <_malloc_r+0x384>
    2e4e:	21fe      	movs	r1, #254	; 0xfe
    2e50:	227e      	movs	r2, #126	; 0x7e
    2e52:	e711      	b.n	2c78 <_malloc_r+0x384>
    2e54:	687b      	ldr	r3, [r7, #4]
    2e56:	e784      	b.n	2d62 <_malloc_r+0x46e>
    2e58:	08e8      	lsrs	r0, r5, #3
    2e5a:	1c43      	adds	r3, r0, #1
    2e5c:	005b      	lsls	r3, r3, #1
    2e5e:	e5f8      	b.n	2a52 <_malloc_r+0x15e>
    2e60:	20000db8 	.word	0x20000db8

00002e64 <__ascii_mbtowc>:
    2e64:	b082      	sub	sp, #8
    2e66:	b149      	cbz	r1, 2e7c <__ascii_mbtowc+0x18>
    2e68:	b15a      	cbz	r2, 2e82 <__ascii_mbtowc+0x1e>
    2e6a:	b16b      	cbz	r3, 2e88 <__ascii_mbtowc+0x24>
    2e6c:	7813      	ldrb	r3, [r2, #0]
    2e6e:	600b      	str	r3, [r1, #0]
    2e70:	7812      	ldrb	r2, [r2, #0]
    2e72:	1c10      	adds	r0, r2, #0
    2e74:	bf18      	it	ne
    2e76:	2001      	movne	r0, #1
    2e78:	b002      	add	sp, #8
    2e7a:	4770      	bx	lr
    2e7c:	a901      	add	r1, sp, #4
    2e7e:	2a00      	cmp	r2, #0
    2e80:	d1f3      	bne.n	2e6a <__ascii_mbtowc+0x6>
    2e82:	4610      	mov	r0, r2
    2e84:	b002      	add	sp, #8
    2e86:	4770      	bx	lr
    2e88:	f06f 0001 	mvn.w	r0, #1
    2e8c:	e7f4      	b.n	2e78 <__ascii_mbtowc+0x14>
    2e8e:	bf00      	nop

00002e90 <memcpy>:
    2e90:	4684      	mov	ip, r0
    2e92:	ea41 0300 	orr.w	r3, r1, r0
    2e96:	f013 0303 	ands.w	r3, r3, #3
    2e9a:	d16d      	bne.n	2f78 <memcpy+0xe8>
    2e9c:	3a40      	subs	r2, #64	; 0x40
    2e9e:	d341      	bcc.n	2f24 <memcpy+0x94>
    2ea0:	f851 3b04 	ldr.w	r3, [r1], #4
    2ea4:	f840 3b04 	str.w	r3, [r0], #4
    2ea8:	f851 3b04 	ldr.w	r3, [r1], #4
    2eac:	f840 3b04 	str.w	r3, [r0], #4
    2eb0:	f851 3b04 	ldr.w	r3, [r1], #4
    2eb4:	f840 3b04 	str.w	r3, [r0], #4
    2eb8:	f851 3b04 	ldr.w	r3, [r1], #4
    2ebc:	f840 3b04 	str.w	r3, [r0], #4
    2ec0:	f851 3b04 	ldr.w	r3, [r1], #4
    2ec4:	f840 3b04 	str.w	r3, [r0], #4
    2ec8:	f851 3b04 	ldr.w	r3, [r1], #4
    2ecc:	f840 3b04 	str.w	r3, [r0], #4
    2ed0:	f851 3b04 	ldr.w	r3, [r1], #4
    2ed4:	f840 3b04 	str.w	r3, [r0], #4
    2ed8:	f851 3b04 	ldr.w	r3, [r1], #4
    2edc:	f840 3b04 	str.w	r3, [r0], #4
    2ee0:	f851 3b04 	ldr.w	r3, [r1], #4
    2ee4:	f840 3b04 	str.w	r3, [r0], #4
    2ee8:	f851 3b04 	ldr.w	r3, [r1], #4
    2eec:	f840 3b04 	str.w	r3, [r0], #4
    2ef0:	f851 3b04 	ldr.w	r3, [r1], #4
    2ef4:	f840 3b04 	str.w	r3, [r0], #4
    2ef8:	f851 3b04 	ldr.w	r3, [r1], #4
    2efc:	f840 3b04 	str.w	r3, [r0], #4
    2f00:	f851 3b04 	ldr.w	r3, [r1], #4
    2f04:	f840 3b04 	str.w	r3, [r0], #4
    2f08:	f851 3b04 	ldr.w	r3, [r1], #4
    2f0c:	f840 3b04 	str.w	r3, [r0], #4
    2f10:	f851 3b04 	ldr.w	r3, [r1], #4
    2f14:	f840 3b04 	str.w	r3, [r0], #4
    2f18:	f851 3b04 	ldr.w	r3, [r1], #4
    2f1c:	f840 3b04 	str.w	r3, [r0], #4
    2f20:	3a40      	subs	r2, #64	; 0x40
    2f22:	d2bd      	bcs.n	2ea0 <memcpy+0x10>
    2f24:	3230      	adds	r2, #48	; 0x30
    2f26:	d311      	bcc.n	2f4c <memcpy+0xbc>
    2f28:	f851 3b04 	ldr.w	r3, [r1], #4
    2f2c:	f840 3b04 	str.w	r3, [r0], #4
    2f30:	f851 3b04 	ldr.w	r3, [r1], #4
    2f34:	f840 3b04 	str.w	r3, [r0], #4
    2f38:	f851 3b04 	ldr.w	r3, [r1], #4
    2f3c:	f840 3b04 	str.w	r3, [r0], #4
    2f40:	f851 3b04 	ldr.w	r3, [r1], #4
    2f44:	f840 3b04 	str.w	r3, [r0], #4
    2f48:	3a10      	subs	r2, #16
    2f4a:	d2ed      	bcs.n	2f28 <memcpy+0x98>
    2f4c:	320c      	adds	r2, #12
    2f4e:	d305      	bcc.n	2f5c <memcpy+0xcc>
    2f50:	f851 3b04 	ldr.w	r3, [r1], #4
    2f54:	f840 3b04 	str.w	r3, [r0], #4
    2f58:	3a04      	subs	r2, #4
    2f5a:	d2f9      	bcs.n	2f50 <memcpy+0xc0>
    2f5c:	3204      	adds	r2, #4
    2f5e:	d008      	beq.n	2f72 <memcpy+0xe2>
    2f60:	07d2      	lsls	r2, r2, #31
    2f62:	bf1c      	itt	ne
    2f64:	f811 3b01 	ldrbne.w	r3, [r1], #1
    2f68:	f800 3b01 	strbne.w	r3, [r0], #1
    2f6c:	d301      	bcc.n	2f72 <memcpy+0xe2>
    2f6e:	880b      	ldrh	r3, [r1, #0]
    2f70:	8003      	strh	r3, [r0, #0]
    2f72:	4660      	mov	r0, ip
    2f74:	4770      	bx	lr
    2f76:	bf00      	nop
    2f78:	2a08      	cmp	r2, #8
    2f7a:	d313      	bcc.n	2fa4 <memcpy+0x114>
    2f7c:	078b      	lsls	r3, r1, #30
    2f7e:	d08d      	beq.n	2e9c <memcpy+0xc>
    2f80:	f010 0303 	ands.w	r3, r0, #3
    2f84:	d08a      	beq.n	2e9c <memcpy+0xc>
    2f86:	f1c3 0304 	rsb	r3, r3, #4
    2f8a:	1ad2      	subs	r2, r2, r3
    2f8c:	07db      	lsls	r3, r3, #31
    2f8e:	bf1c      	itt	ne
    2f90:	f811 3b01 	ldrbne.w	r3, [r1], #1
    2f94:	f800 3b01 	strbne.w	r3, [r0], #1
    2f98:	d380      	bcc.n	2e9c <memcpy+0xc>
    2f9a:	f831 3b02 	ldrh.w	r3, [r1], #2
    2f9e:	f820 3b02 	strh.w	r3, [r0], #2
    2fa2:	e77b      	b.n	2e9c <memcpy+0xc>
    2fa4:	3a04      	subs	r2, #4
    2fa6:	d3d9      	bcc.n	2f5c <memcpy+0xcc>
    2fa8:	3a01      	subs	r2, #1
    2faa:	f811 3b01 	ldrb.w	r3, [r1], #1
    2fae:	f800 3b01 	strb.w	r3, [r0], #1
    2fb2:	d2f9      	bcs.n	2fa8 <memcpy+0x118>
    2fb4:	780b      	ldrb	r3, [r1, #0]
    2fb6:	7003      	strb	r3, [r0, #0]
    2fb8:	784b      	ldrb	r3, [r1, #1]
    2fba:	7043      	strb	r3, [r0, #1]
    2fbc:	788b      	ldrb	r3, [r1, #2]
    2fbe:	7083      	strb	r3, [r0, #2]
    2fc0:	4660      	mov	r0, ip
    2fc2:	4770      	bx	lr

00002fc4 <memmove>:
    2fc4:	4288      	cmp	r0, r1
    2fc6:	b5f0      	push	{r4, r5, r6, r7, lr}
    2fc8:	d90d      	bls.n	2fe6 <memmove+0x22>
    2fca:	188b      	adds	r3, r1, r2
    2fcc:	4298      	cmp	r0, r3
    2fce:	d20a      	bcs.n	2fe6 <memmove+0x22>
    2fd0:	1881      	adds	r1, r0, r2
    2fd2:	2a00      	cmp	r2, #0
    2fd4:	d051      	beq.n	307a <memmove+0xb6>
    2fd6:	1a9a      	subs	r2, r3, r2
    2fd8:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    2fdc:	f801 4d01 	strb.w	r4, [r1, #-1]!
    2fe0:	4293      	cmp	r3, r2
    2fe2:	d1f9      	bne.n	2fd8 <memmove+0x14>
    2fe4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2fe6:	2a0f      	cmp	r2, #15
    2fe8:	d948      	bls.n	307c <memmove+0xb8>
    2fea:	ea41 0300 	orr.w	r3, r1, r0
    2fee:	079b      	lsls	r3, r3, #30
    2ff0:	d146      	bne.n	3080 <memmove+0xbc>
    2ff2:	f100 0410 	add.w	r4, r0, #16
    2ff6:	f101 0310 	add.w	r3, r1, #16
    2ffa:	4615      	mov	r5, r2
    2ffc:	f853 6c10 	ldr.w	r6, [r3, #-16]
    3000:	f844 6c10 	str.w	r6, [r4, #-16]
    3004:	f853 6c0c 	ldr.w	r6, [r3, #-12]
    3008:	f844 6c0c 	str.w	r6, [r4, #-12]
    300c:	f853 6c08 	ldr.w	r6, [r3, #-8]
    3010:	f844 6c08 	str.w	r6, [r4, #-8]
    3014:	3d10      	subs	r5, #16
    3016:	f853 6c04 	ldr.w	r6, [r3, #-4]
    301a:	f844 6c04 	str.w	r6, [r4, #-4]
    301e:	2d0f      	cmp	r5, #15
    3020:	f103 0310 	add.w	r3, r3, #16
    3024:	f104 0410 	add.w	r4, r4, #16
    3028:	d8e8      	bhi.n	2ffc <memmove+0x38>
    302a:	f1a2 0310 	sub.w	r3, r2, #16
    302e:	f023 030f 	bic.w	r3, r3, #15
    3032:	f002 0e0f 	and.w	lr, r2, #15
    3036:	3310      	adds	r3, #16
    3038:	f1be 0f03 	cmp.w	lr, #3
    303c:	4419      	add	r1, r3
    303e:	4403      	add	r3, r0
    3040:	d921      	bls.n	3086 <memmove+0xc2>
    3042:	1f1e      	subs	r6, r3, #4
    3044:	460d      	mov	r5, r1
    3046:	4674      	mov	r4, lr
    3048:	3c04      	subs	r4, #4
    304a:	f855 7b04 	ldr.w	r7, [r5], #4
    304e:	f846 7f04 	str.w	r7, [r6, #4]!
    3052:	2c03      	cmp	r4, #3
    3054:	d8f8      	bhi.n	3048 <memmove+0x84>
    3056:	f1ae 0404 	sub.w	r4, lr, #4
    305a:	f024 0403 	bic.w	r4, r4, #3
    305e:	3404      	adds	r4, #4
    3060:	4423      	add	r3, r4
    3062:	4421      	add	r1, r4
    3064:	f002 0203 	and.w	r2, r2, #3
    3068:	b162      	cbz	r2, 3084 <memmove+0xc0>
    306a:	3b01      	subs	r3, #1
    306c:	440a      	add	r2, r1
    306e:	f811 4b01 	ldrb.w	r4, [r1], #1
    3072:	f803 4f01 	strb.w	r4, [r3, #1]!
    3076:	428a      	cmp	r2, r1
    3078:	d1f9      	bne.n	306e <memmove+0xaa>
    307a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    307c:	4603      	mov	r3, r0
    307e:	e7f3      	b.n	3068 <memmove+0xa4>
    3080:	4603      	mov	r3, r0
    3082:	e7f2      	b.n	306a <memmove+0xa6>
    3084:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3086:	4672      	mov	r2, lr
    3088:	e7ee      	b.n	3068 <memmove+0xa4>
    308a:	bf00      	nop

0000308c <memset>:
    308c:	b470      	push	{r4, r5, r6}
    308e:	0784      	lsls	r4, r0, #30
    3090:	d046      	beq.n	3120 <memset+0x94>
    3092:	1e54      	subs	r4, r2, #1
    3094:	2a00      	cmp	r2, #0
    3096:	d041      	beq.n	311c <memset+0x90>
    3098:	b2cd      	uxtb	r5, r1
    309a:	4603      	mov	r3, r0
    309c:	e002      	b.n	30a4 <memset+0x18>
    309e:	1e62      	subs	r2, r4, #1
    30a0:	b3e4      	cbz	r4, 311c <memset+0x90>
    30a2:	4614      	mov	r4, r2
    30a4:	f803 5b01 	strb.w	r5, [r3], #1
    30a8:	079a      	lsls	r2, r3, #30
    30aa:	d1f8      	bne.n	309e <memset+0x12>
    30ac:	2c03      	cmp	r4, #3
    30ae:	d92e      	bls.n	310e <memset+0x82>
    30b0:	b2cd      	uxtb	r5, r1
    30b2:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    30b6:	2c0f      	cmp	r4, #15
    30b8:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    30bc:	d919      	bls.n	30f2 <memset+0x66>
    30be:	f103 0210 	add.w	r2, r3, #16
    30c2:	4626      	mov	r6, r4
    30c4:	3e10      	subs	r6, #16
    30c6:	2e0f      	cmp	r6, #15
    30c8:	f842 5c10 	str.w	r5, [r2, #-16]
    30cc:	f842 5c0c 	str.w	r5, [r2, #-12]
    30d0:	f842 5c08 	str.w	r5, [r2, #-8]
    30d4:	f842 5c04 	str.w	r5, [r2, #-4]
    30d8:	f102 0210 	add.w	r2, r2, #16
    30dc:	d8f2      	bhi.n	30c4 <memset+0x38>
    30de:	f1a4 0210 	sub.w	r2, r4, #16
    30e2:	f022 020f 	bic.w	r2, r2, #15
    30e6:	f004 040f 	and.w	r4, r4, #15
    30ea:	3210      	adds	r2, #16
    30ec:	2c03      	cmp	r4, #3
    30ee:	4413      	add	r3, r2
    30f0:	d90d      	bls.n	310e <memset+0x82>
    30f2:	461e      	mov	r6, r3
    30f4:	4622      	mov	r2, r4
    30f6:	3a04      	subs	r2, #4
    30f8:	2a03      	cmp	r2, #3
    30fa:	f846 5b04 	str.w	r5, [r6], #4
    30fe:	d8fa      	bhi.n	30f6 <memset+0x6a>
    3100:	1f22      	subs	r2, r4, #4
    3102:	f022 0203 	bic.w	r2, r2, #3
    3106:	3204      	adds	r2, #4
    3108:	4413      	add	r3, r2
    310a:	f004 0403 	and.w	r4, r4, #3
    310e:	b12c      	cbz	r4, 311c <memset+0x90>
    3110:	b2c9      	uxtb	r1, r1
    3112:	441c      	add	r4, r3
    3114:	f803 1b01 	strb.w	r1, [r3], #1
    3118:	42a3      	cmp	r3, r4
    311a:	d1fb      	bne.n	3114 <memset+0x88>
    311c:	bc70      	pop	{r4, r5, r6}
    311e:	4770      	bx	lr
    3120:	4614      	mov	r4, r2
    3122:	4603      	mov	r3, r0
    3124:	e7c2      	b.n	30ac <memset+0x20>
    3126:	bf00      	nop

00003128 <__malloc_lock>:
    3128:	4770      	bx	lr
    312a:	bf00      	nop

0000312c <__malloc_unlock>:
    312c:	4770      	bx	lr
    312e:	bf00      	nop

00003130 <realloc>:
    3130:	4b02      	ldr	r3, [pc, #8]	; (313c <realloc+0xc>)
    3132:	460a      	mov	r2, r1
    3134:	4601      	mov	r1, r0
    3136:	6818      	ldr	r0, [r3, #0]
    3138:	f000 b802 	b.w	3140 <_realloc_r>
    313c:	200011c8 	.word	0x200011c8

00003140 <_realloc_r>:
    3140:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3144:	4617      	mov	r7, r2
    3146:	b083      	sub	sp, #12
    3148:	2900      	cmp	r1, #0
    314a:	f000 80c1 	beq.w	32d0 <_realloc_r+0x190>
    314e:	460e      	mov	r6, r1
    3150:	4681      	mov	r9, r0
    3152:	f107 050b 	add.w	r5, r7, #11
    3156:	f7ff ffe7 	bl	3128 <__malloc_lock>
    315a:	f856 ec04 	ldr.w	lr, [r6, #-4]
    315e:	2d16      	cmp	r5, #22
    3160:	f02e 0403 	bic.w	r4, lr, #3
    3164:	f1a6 0808 	sub.w	r8, r6, #8
    3168:	d840      	bhi.n	31ec <_realloc_r+0xac>
    316a:	2210      	movs	r2, #16
    316c:	4615      	mov	r5, r2
    316e:	42af      	cmp	r7, r5
    3170:	d841      	bhi.n	31f6 <_realloc_r+0xb6>
    3172:	4294      	cmp	r4, r2
    3174:	da75      	bge.n	3262 <_realloc_r+0x122>
    3176:	4bc9      	ldr	r3, [pc, #804]	; (349c <_realloc_r+0x35c>)
    3178:	6899      	ldr	r1, [r3, #8]
    317a:	eb08 0004 	add.w	r0, r8, r4
    317e:	4288      	cmp	r0, r1
    3180:	6841      	ldr	r1, [r0, #4]
    3182:	f000 80d9 	beq.w	3338 <_realloc_r+0x1f8>
    3186:	f021 0301 	bic.w	r3, r1, #1
    318a:	4403      	add	r3, r0
    318c:	685b      	ldr	r3, [r3, #4]
    318e:	07db      	lsls	r3, r3, #31
    3190:	d57d      	bpl.n	328e <_realloc_r+0x14e>
    3192:	f01e 0f01 	tst.w	lr, #1
    3196:	d035      	beq.n	3204 <_realloc_r+0xc4>
    3198:	4639      	mov	r1, r7
    319a:	4648      	mov	r0, r9
    319c:	f7ff fbaa 	bl	28f4 <_malloc_r>
    31a0:	4607      	mov	r7, r0
    31a2:	b1e0      	cbz	r0, 31de <_realloc_r+0x9e>
    31a4:	f856 3c04 	ldr.w	r3, [r6, #-4]
    31a8:	f023 0301 	bic.w	r3, r3, #1
    31ac:	4443      	add	r3, r8
    31ae:	f1a0 0208 	sub.w	r2, r0, #8
    31b2:	429a      	cmp	r2, r3
    31b4:	f000 8144 	beq.w	3440 <_realloc_r+0x300>
    31b8:	1f22      	subs	r2, r4, #4
    31ba:	2a24      	cmp	r2, #36	; 0x24
    31bc:	f200 8131 	bhi.w	3422 <_realloc_r+0x2e2>
    31c0:	2a13      	cmp	r2, #19
    31c2:	f200 8104 	bhi.w	33ce <_realloc_r+0x28e>
    31c6:	4603      	mov	r3, r0
    31c8:	4632      	mov	r2, r6
    31ca:	6811      	ldr	r1, [r2, #0]
    31cc:	6019      	str	r1, [r3, #0]
    31ce:	6851      	ldr	r1, [r2, #4]
    31d0:	6059      	str	r1, [r3, #4]
    31d2:	6892      	ldr	r2, [r2, #8]
    31d4:	609a      	str	r2, [r3, #8]
    31d6:	4631      	mov	r1, r6
    31d8:	4648      	mov	r0, r9
    31da:	f000 fbb5 	bl	3948 <_free_r>
    31de:	4648      	mov	r0, r9
    31e0:	f7ff ffa4 	bl	312c <__malloc_unlock>
    31e4:	4638      	mov	r0, r7
    31e6:	b003      	add	sp, #12
    31e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    31ec:	f025 0507 	bic.w	r5, r5, #7
    31f0:	2d00      	cmp	r5, #0
    31f2:	462a      	mov	r2, r5
    31f4:	dabb      	bge.n	316e <_realloc_r+0x2e>
    31f6:	230c      	movs	r3, #12
    31f8:	2000      	movs	r0, #0
    31fa:	f8c9 3000 	str.w	r3, [r9]
    31fe:	b003      	add	sp, #12
    3200:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3204:	f856 3c08 	ldr.w	r3, [r6, #-8]
    3208:	ebc3 0a08 	rsb	sl, r3, r8
    320c:	f8da 3004 	ldr.w	r3, [sl, #4]
    3210:	f023 0c03 	bic.w	ip, r3, #3
    3214:	eb04 030c 	add.w	r3, r4, ip
    3218:	4293      	cmp	r3, r2
    321a:	dbbd      	blt.n	3198 <_realloc_r+0x58>
    321c:	4657      	mov	r7, sl
    321e:	f8da 100c 	ldr.w	r1, [sl, #12]
    3222:	f857 0f08 	ldr.w	r0, [r7, #8]!
    3226:	1f22      	subs	r2, r4, #4
    3228:	2a24      	cmp	r2, #36	; 0x24
    322a:	60c1      	str	r1, [r0, #12]
    322c:	6088      	str	r0, [r1, #8]
    322e:	f200 8117 	bhi.w	3460 <_realloc_r+0x320>
    3232:	2a13      	cmp	r2, #19
    3234:	f240 8112 	bls.w	345c <_realloc_r+0x31c>
    3238:	6831      	ldr	r1, [r6, #0]
    323a:	f8ca 1008 	str.w	r1, [sl, #8]
    323e:	6871      	ldr	r1, [r6, #4]
    3240:	f8ca 100c 	str.w	r1, [sl, #12]
    3244:	2a1b      	cmp	r2, #27
    3246:	f200 812b 	bhi.w	34a0 <_realloc_r+0x360>
    324a:	3608      	adds	r6, #8
    324c:	f10a 0210 	add.w	r2, sl, #16
    3250:	6831      	ldr	r1, [r6, #0]
    3252:	6011      	str	r1, [r2, #0]
    3254:	6871      	ldr	r1, [r6, #4]
    3256:	6051      	str	r1, [r2, #4]
    3258:	68b1      	ldr	r1, [r6, #8]
    325a:	6091      	str	r1, [r2, #8]
    325c:	463e      	mov	r6, r7
    325e:	461c      	mov	r4, r3
    3260:	46d0      	mov	r8, sl
    3262:	1b63      	subs	r3, r4, r5
    3264:	2b0f      	cmp	r3, #15
    3266:	d81d      	bhi.n	32a4 <_realloc_r+0x164>
    3268:	f8d8 3004 	ldr.w	r3, [r8, #4]
    326c:	f003 0301 	and.w	r3, r3, #1
    3270:	4323      	orrs	r3, r4
    3272:	4444      	add	r4, r8
    3274:	f8c8 3004 	str.w	r3, [r8, #4]
    3278:	6863      	ldr	r3, [r4, #4]
    327a:	f043 0301 	orr.w	r3, r3, #1
    327e:	6063      	str	r3, [r4, #4]
    3280:	4648      	mov	r0, r9
    3282:	f7ff ff53 	bl	312c <__malloc_unlock>
    3286:	4630      	mov	r0, r6
    3288:	b003      	add	sp, #12
    328a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    328e:	f021 0103 	bic.w	r1, r1, #3
    3292:	4421      	add	r1, r4
    3294:	4291      	cmp	r1, r2
    3296:	db21      	blt.n	32dc <_realloc_r+0x19c>
    3298:	68c3      	ldr	r3, [r0, #12]
    329a:	6882      	ldr	r2, [r0, #8]
    329c:	460c      	mov	r4, r1
    329e:	60d3      	str	r3, [r2, #12]
    32a0:	609a      	str	r2, [r3, #8]
    32a2:	e7de      	b.n	3262 <_realloc_r+0x122>
    32a4:	f8d8 2004 	ldr.w	r2, [r8, #4]
    32a8:	eb08 0105 	add.w	r1, r8, r5
    32ac:	f002 0201 	and.w	r2, r2, #1
    32b0:	4315      	orrs	r5, r2
    32b2:	f043 0201 	orr.w	r2, r3, #1
    32b6:	440b      	add	r3, r1
    32b8:	f8c8 5004 	str.w	r5, [r8, #4]
    32bc:	604a      	str	r2, [r1, #4]
    32be:	685a      	ldr	r2, [r3, #4]
    32c0:	f042 0201 	orr.w	r2, r2, #1
    32c4:	3108      	adds	r1, #8
    32c6:	605a      	str	r2, [r3, #4]
    32c8:	4648      	mov	r0, r9
    32ca:	f000 fb3d 	bl	3948 <_free_r>
    32ce:	e7d7      	b.n	3280 <_realloc_r+0x140>
    32d0:	4611      	mov	r1, r2
    32d2:	b003      	add	sp, #12
    32d4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    32d8:	f7ff bb0c 	b.w	28f4 <_malloc_r>
    32dc:	f01e 0f01 	tst.w	lr, #1
    32e0:	f47f af5a 	bne.w	3198 <_realloc_r+0x58>
    32e4:	f856 3c08 	ldr.w	r3, [r6, #-8]
    32e8:	ebc3 0a08 	rsb	sl, r3, r8
    32ec:	f8da 3004 	ldr.w	r3, [sl, #4]
    32f0:	f023 0c03 	bic.w	ip, r3, #3
    32f4:	eb01 0e0c 	add.w	lr, r1, ip
    32f8:	4596      	cmp	lr, r2
    32fa:	db8b      	blt.n	3214 <_realloc_r+0xd4>
    32fc:	68c3      	ldr	r3, [r0, #12]
    32fe:	6882      	ldr	r2, [r0, #8]
    3300:	4657      	mov	r7, sl
    3302:	60d3      	str	r3, [r2, #12]
    3304:	609a      	str	r2, [r3, #8]
    3306:	f857 1f08 	ldr.w	r1, [r7, #8]!
    330a:	f8da 300c 	ldr.w	r3, [sl, #12]
    330e:	60cb      	str	r3, [r1, #12]
    3310:	1f22      	subs	r2, r4, #4
    3312:	2a24      	cmp	r2, #36	; 0x24
    3314:	6099      	str	r1, [r3, #8]
    3316:	f200 8099 	bhi.w	344c <_realloc_r+0x30c>
    331a:	2a13      	cmp	r2, #19
    331c:	d962      	bls.n	33e4 <_realloc_r+0x2a4>
    331e:	6833      	ldr	r3, [r6, #0]
    3320:	f8ca 3008 	str.w	r3, [sl, #8]
    3324:	6873      	ldr	r3, [r6, #4]
    3326:	f8ca 300c 	str.w	r3, [sl, #12]
    332a:	2a1b      	cmp	r2, #27
    332c:	f200 80a0 	bhi.w	3470 <_realloc_r+0x330>
    3330:	3608      	adds	r6, #8
    3332:	f10a 0310 	add.w	r3, sl, #16
    3336:	e056      	b.n	33e6 <_realloc_r+0x2a6>
    3338:	f021 0b03 	bic.w	fp, r1, #3
    333c:	44a3      	add	fp, r4
    333e:	f105 0010 	add.w	r0, r5, #16
    3342:	4583      	cmp	fp, r0
    3344:	da59      	bge.n	33fa <_realloc_r+0x2ba>
    3346:	f01e 0f01 	tst.w	lr, #1
    334a:	f47f af25 	bne.w	3198 <_realloc_r+0x58>
    334e:	f856 1c08 	ldr.w	r1, [r6, #-8]
    3352:	ebc1 0a08 	rsb	sl, r1, r8
    3356:	f8da 1004 	ldr.w	r1, [sl, #4]
    335a:	f021 0c03 	bic.w	ip, r1, #3
    335e:	44e3      	add	fp, ip
    3360:	4558      	cmp	r0, fp
    3362:	f73f af57 	bgt.w	3214 <_realloc_r+0xd4>
    3366:	4657      	mov	r7, sl
    3368:	f8da 100c 	ldr.w	r1, [sl, #12]
    336c:	f857 0f08 	ldr.w	r0, [r7, #8]!
    3370:	1f22      	subs	r2, r4, #4
    3372:	2a24      	cmp	r2, #36	; 0x24
    3374:	60c1      	str	r1, [r0, #12]
    3376:	6088      	str	r0, [r1, #8]
    3378:	f200 80b4 	bhi.w	34e4 <_realloc_r+0x3a4>
    337c:	2a13      	cmp	r2, #19
    337e:	f240 80a5 	bls.w	34cc <_realloc_r+0x38c>
    3382:	6831      	ldr	r1, [r6, #0]
    3384:	f8ca 1008 	str.w	r1, [sl, #8]
    3388:	6871      	ldr	r1, [r6, #4]
    338a:	f8ca 100c 	str.w	r1, [sl, #12]
    338e:	2a1b      	cmp	r2, #27
    3390:	f200 80af 	bhi.w	34f2 <_realloc_r+0x3b2>
    3394:	3608      	adds	r6, #8
    3396:	f10a 0210 	add.w	r2, sl, #16
    339a:	6831      	ldr	r1, [r6, #0]
    339c:	6011      	str	r1, [r2, #0]
    339e:	6871      	ldr	r1, [r6, #4]
    33a0:	6051      	str	r1, [r2, #4]
    33a2:	68b1      	ldr	r1, [r6, #8]
    33a4:	6091      	str	r1, [r2, #8]
    33a6:	eb0a 0105 	add.w	r1, sl, r5
    33aa:	ebc5 020b 	rsb	r2, r5, fp
    33ae:	f042 0201 	orr.w	r2, r2, #1
    33b2:	6099      	str	r1, [r3, #8]
    33b4:	604a      	str	r2, [r1, #4]
    33b6:	f8da 3004 	ldr.w	r3, [sl, #4]
    33ba:	f003 0301 	and.w	r3, r3, #1
    33be:	431d      	orrs	r5, r3
    33c0:	4648      	mov	r0, r9
    33c2:	f8ca 5004 	str.w	r5, [sl, #4]
    33c6:	f7ff feb1 	bl	312c <__malloc_unlock>
    33ca:	4638      	mov	r0, r7
    33cc:	e75c      	b.n	3288 <_realloc_r+0x148>
    33ce:	6833      	ldr	r3, [r6, #0]
    33d0:	6003      	str	r3, [r0, #0]
    33d2:	6873      	ldr	r3, [r6, #4]
    33d4:	6043      	str	r3, [r0, #4]
    33d6:	2a1b      	cmp	r2, #27
    33d8:	d827      	bhi.n	342a <_realloc_r+0x2ea>
    33da:	f100 0308 	add.w	r3, r0, #8
    33de:	f106 0208 	add.w	r2, r6, #8
    33e2:	e6f2      	b.n	31ca <_realloc_r+0x8a>
    33e4:	463b      	mov	r3, r7
    33e6:	6832      	ldr	r2, [r6, #0]
    33e8:	601a      	str	r2, [r3, #0]
    33ea:	6872      	ldr	r2, [r6, #4]
    33ec:	605a      	str	r2, [r3, #4]
    33ee:	68b2      	ldr	r2, [r6, #8]
    33f0:	609a      	str	r2, [r3, #8]
    33f2:	463e      	mov	r6, r7
    33f4:	4674      	mov	r4, lr
    33f6:	46d0      	mov	r8, sl
    33f8:	e733      	b.n	3262 <_realloc_r+0x122>
    33fa:	eb08 0105 	add.w	r1, r8, r5
    33fe:	ebc5 0b0b 	rsb	fp, r5, fp
    3402:	f04b 0201 	orr.w	r2, fp, #1
    3406:	6099      	str	r1, [r3, #8]
    3408:	604a      	str	r2, [r1, #4]
    340a:	f856 3c04 	ldr.w	r3, [r6, #-4]
    340e:	f003 0301 	and.w	r3, r3, #1
    3412:	431d      	orrs	r5, r3
    3414:	4648      	mov	r0, r9
    3416:	f846 5c04 	str.w	r5, [r6, #-4]
    341a:	f7ff fe87 	bl	312c <__malloc_unlock>
    341e:	4630      	mov	r0, r6
    3420:	e732      	b.n	3288 <_realloc_r+0x148>
    3422:	4631      	mov	r1, r6
    3424:	f7ff fdce 	bl	2fc4 <memmove>
    3428:	e6d5      	b.n	31d6 <_realloc_r+0x96>
    342a:	68b3      	ldr	r3, [r6, #8]
    342c:	6083      	str	r3, [r0, #8]
    342e:	68f3      	ldr	r3, [r6, #12]
    3430:	60c3      	str	r3, [r0, #12]
    3432:	2a24      	cmp	r2, #36	; 0x24
    3434:	d028      	beq.n	3488 <_realloc_r+0x348>
    3436:	f100 0310 	add.w	r3, r0, #16
    343a:	f106 0210 	add.w	r2, r6, #16
    343e:	e6c4      	b.n	31ca <_realloc_r+0x8a>
    3440:	f850 3c04 	ldr.w	r3, [r0, #-4]
    3444:	f023 0303 	bic.w	r3, r3, #3
    3448:	441c      	add	r4, r3
    344a:	e70a      	b.n	3262 <_realloc_r+0x122>
    344c:	4631      	mov	r1, r6
    344e:	4638      	mov	r0, r7
    3450:	4674      	mov	r4, lr
    3452:	46d0      	mov	r8, sl
    3454:	f7ff fdb6 	bl	2fc4 <memmove>
    3458:	463e      	mov	r6, r7
    345a:	e702      	b.n	3262 <_realloc_r+0x122>
    345c:	463a      	mov	r2, r7
    345e:	e6f7      	b.n	3250 <_realloc_r+0x110>
    3460:	4631      	mov	r1, r6
    3462:	4638      	mov	r0, r7
    3464:	461c      	mov	r4, r3
    3466:	46d0      	mov	r8, sl
    3468:	f7ff fdac 	bl	2fc4 <memmove>
    346c:	463e      	mov	r6, r7
    346e:	e6f8      	b.n	3262 <_realloc_r+0x122>
    3470:	68b3      	ldr	r3, [r6, #8]
    3472:	f8ca 3010 	str.w	r3, [sl, #16]
    3476:	68f3      	ldr	r3, [r6, #12]
    3478:	f8ca 3014 	str.w	r3, [sl, #20]
    347c:	2a24      	cmp	r2, #36	; 0x24
    347e:	d01b      	beq.n	34b8 <_realloc_r+0x378>
    3480:	3610      	adds	r6, #16
    3482:	f10a 0318 	add.w	r3, sl, #24
    3486:	e7ae      	b.n	33e6 <_realloc_r+0x2a6>
    3488:	6933      	ldr	r3, [r6, #16]
    348a:	6103      	str	r3, [r0, #16]
    348c:	6973      	ldr	r3, [r6, #20]
    348e:	6143      	str	r3, [r0, #20]
    3490:	f106 0218 	add.w	r2, r6, #24
    3494:	f100 0318 	add.w	r3, r0, #24
    3498:	e697      	b.n	31ca <_realloc_r+0x8a>
    349a:	bf00      	nop
    349c:	20000db8 	.word	0x20000db8
    34a0:	68b1      	ldr	r1, [r6, #8]
    34a2:	f8ca 1010 	str.w	r1, [sl, #16]
    34a6:	68f1      	ldr	r1, [r6, #12]
    34a8:	f8ca 1014 	str.w	r1, [sl, #20]
    34ac:	2a24      	cmp	r2, #36	; 0x24
    34ae:	d00f      	beq.n	34d0 <_realloc_r+0x390>
    34b0:	3610      	adds	r6, #16
    34b2:	f10a 0218 	add.w	r2, sl, #24
    34b6:	e6cb      	b.n	3250 <_realloc_r+0x110>
    34b8:	6933      	ldr	r3, [r6, #16]
    34ba:	f8ca 3018 	str.w	r3, [sl, #24]
    34be:	6973      	ldr	r3, [r6, #20]
    34c0:	f8ca 301c 	str.w	r3, [sl, #28]
    34c4:	3618      	adds	r6, #24
    34c6:	f10a 0320 	add.w	r3, sl, #32
    34ca:	e78c      	b.n	33e6 <_realloc_r+0x2a6>
    34cc:	463a      	mov	r2, r7
    34ce:	e764      	b.n	339a <_realloc_r+0x25a>
    34d0:	6932      	ldr	r2, [r6, #16]
    34d2:	f8ca 2018 	str.w	r2, [sl, #24]
    34d6:	6972      	ldr	r2, [r6, #20]
    34d8:	f8ca 201c 	str.w	r2, [sl, #28]
    34dc:	3618      	adds	r6, #24
    34de:	f10a 0220 	add.w	r2, sl, #32
    34e2:	e6b5      	b.n	3250 <_realloc_r+0x110>
    34e4:	4631      	mov	r1, r6
    34e6:	4638      	mov	r0, r7
    34e8:	9301      	str	r3, [sp, #4]
    34ea:	f7ff fd6b 	bl	2fc4 <memmove>
    34ee:	9b01      	ldr	r3, [sp, #4]
    34f0:	e759      	b.n	33a6 <_realloc_r+0x266>
    34f2:	68b1      	ldr	r1, [r6, #8]
    34f4:	f8ca 1010 	str.w	r1, [sl, #16]
    34f8:	68f1      	ldr	r1, [r6, #12]
    34fa:	f8ca 1014 	str.w	r1, [sl, #20]
    34fe:	2a24      	cmp	r2, #36	; 0x24
    3500:	d003      	beq.n	350a <_realloc_r+0x3ca>
    3502:	3610      	adds	r6, #16
    3504:	f10a 0218 	add.w	r2, sl, #24
    3508:	e747      	b.n	339a <_realloc_r+0x25a>
    350a:	6932      	ldr	r2, [r6, #16]
    350c:	f8ca 2018 	str.w	r2, [sl, #24]
    3510:	6972      	ldr	r2, [r6, #20]
    3512:	f8ca 201c 	str.w	r2, [sl, #28]
    3516:	3618      	adds	r6, #24
    3518:	f10a 0220 	add.w	r2, sl, #32
    351c:	e73d      	b.n	339a <_realloc_r+0x25a>
    351e:	bf00      	nop

00003520 <_sbrk_r>:
    3520:	b538      	push	{r3, r4, r5, lr}
    3522:	4c07      	ldr	r4, [pc, #28]	; (3540 <_sbrk_r+0x20>)
    3524:	2300      	movs	r3, #0
    3526:	4605      	mov	r5, r0
    3528:	4608      	mov	r0, r1
    352a:	6023      	str	r3, [r4, #0]
    352c:	f7fd fe32 	bl	1194 <_sbrk>
    3530:	1c43      	adds	r3, r0, #1
    3532:	d000      	beq.n	3536 <_sbrk_r+0x16>
    3534:	bd38      	pop	{r3, r4, r5, pc}
    3536:	6823      	ldr	r3, [r4, #0]
    3538:	2b00      	cmp	r3, #0
    353a:	d0fb      	beq.n	3534 <_sbrk_r+0x14>
    353c:	602b      	str	r3, [r5, #0]
    353e:	bd38      	pop	{r3, r4, r5, pc}
    3540:	20001c74 	.word	0x20001c74

00003544 <strcpy>:
    3544:	ea80 0201 	eor.w	r2, r0, r1
    3548:	4684      	mov	ip, r0
    354a:	f012 0f03 	tst.w	r2, #3
    354e:	d14f      	bne.n	35f0 <strcpy+0xac>
    3550:	f011 0f03 	tst.w	r1, #3
    3554:	d132      	bne.n	35bc <strcpy+0x78>
    3556:	f84d 4d04 	str.w	r4, [sp, #-4]!
    355a:	f011 0f04 	tst.w	r1, #4
    355e:	f851 3b04 	ldr.w	r3, [r1], #4
    3562:	d00b      	beq.n	357c <strcpy+0x38>
    3564:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    3568:	439a      	bics	r2, r3
    356a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    356e:	bf04      	itt	eq
    3570:	f84c 3b04 	streq.w	r3, [ip], #4
    3574:	f851 3b04 	ldreq.w	r3, [r1], #4
    3578:	d116      	bne.n	35a8 <strcpy+0x64>
    357a:	bf00      	nop
    357c:	f851 4b04 	ldr.w	r4, [r1], #4
    3580:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
    3584:	439a      	bics	r2, r3
    3586:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    358a:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
    358e:	d10b      	bne.n	35a8 <strcpy+0x64>
    3590:	f84c 3b04 	str.w	r3, [ip], #4
    3594:	43a2      	bics	r2, r4
    3596:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
    359a:	bf04      	itt	eq
    359c:	f851 3b04 	ldreq.w	r3, [r1], #4
    35a0:	f84c 4b04 	streq.w	r4, [ip], #4
    35a4:	d0ea      	beq.n	357c <strcpy+0x38>
    35a6:	4623      	mov	r3, r4
    35a8:	f80c 3b01 	strb.w	r3, [ip], #1
    35ac:	f013 0fff 	tst.w	r3, #255	; 0xff
    35b0:	ea4f 2333 	mov.w	r3, r3, ror #8
    35b4:	d1f8      	bne.n	35a8 <strcpy+0x64>
    35b6:	f85d 4b04 	ldr.w	r4, [sp], #4
    35ba:	4770      	bx	lr
    35bc:	f011 0f01 	tst.w	r1, #1
    35c0:	d006      	beq.n	35d0 <strcpy+0x8c>
    35c2:	f811 2b01 	ldrb.w	r2, [r1], #1
    35c6:	f80c 2b01 	strb.w	r2, [ip], #1
    35ca:	2a00      	cmp	r2, #0
    35cc:	bf08      	it	eq
    35ce:	4770      	bxeq	lr
    35d0:	f011 0f02 	tst.w	r1, #2
    35d4:	d0bf      	beq.n	3556 <strcpy+0x12>
    35d6:	f831 2b02 	ldrh.w	r2, [r1], #2
    35da:	f012 0fff 	tst.w	r2, #255	; 0xff
    35de:	bf16      	itet	ne
    35e0:	f82c 2b02 	strhne.w	r2, [ip], #2
    35e4:	f88c 2000 	strbeq.w	r2, [ip]
    35e8:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
    35ec:	d1b3      	bne.n	3556 <strcpy+0x12>
    35ee:	4770      	bx	lr
    35f0:	f811 2b01 	ldrb.w	r2, [r1], #1
    35f4:	f80c 2b01 	strb.w	r2, [ip], #1
    35f8:	2a00      	cmp	r2, #0
    35fa:	d1f9      	bne.n	35f0 <strcpy+0xac>
    35fc:	4770      	bx	lr
    35fe:	bf00      	nop

00003600 <strlen>:
    3600:	f890 f000 	pld	[r0]
    3604:	e96d 4502 	strd	r4, r5, [sp, #-8]!
    3608:	f020 0107 	bic.w	r1, r0, #7
    360c:	f06f 0c00 	mvn.w	ip, #0
    3610:	f010 0407 	ands.w	r4, r0, #7
    3614:	f891 f020 	pld	[r1, #32]
    3618:	f040 8049 	bne.w	36ae <strlen+0xae>
    361c:	f04f 0400 	mov.w	r4, #0
    3620:	f06f 0007 	mvn.w	r0, #7
    3624:	e9d1 2300 	ldrd	r2, r3, [r1]
    3628:	f891 f040 	pld	[r1, #64]	; 0x40
    362c:	f100 0008 	add.w	r0, r0, #8
    3630:	fa82 f24c 	uadd8	r2, r2, ip
    3634:	faa4 f28c 	sel	r2, r4, ip
    3638:	fa83 f34c 	uadd8	r3, r3, ip
    363c:	faa2 f38c 	sel	r3, r2, ip
    3640:	bb4b      	cbnz	r3, 3696 <strlen+0x96>
    3642:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
    3646:	fa82 f24c 	uadd8	r2, r2, ip
    364a:	f100 0008 	add.w	r0, r0, #8
    364e:	faa4 f28c 	sel	r2, r4, ip
    3652:	fa83 f34c 	uadd8	r3, r3, ip
    3656:	faa2 f38c 	sel	r3, r2, ip
    365a:	b9e3      	cbnz	r3, 3696 <strlen+0x96>
    365c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
    3660:	fa82 f24c 	uadd8	r2, r2, ip
    3664:	f100 0008 	add.w	r0, r0, #8
    3668:	faa4 f28c 	sel	r2, r4, ip
    366c:	fa83 f34c 	uadd8	r3, r3, ip
    3670:	faa2 f38c 	sel	r3, r2, ip
    3674:	b97b      	cbnz	r3, 3696 <strlen+0x96>
    3676:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
    367a:	f101 0120 	add.w	r1, r1, #32
    367e:	fa82 f24c 	uadd8	r2, r2, ip
    3682:	f100 0008 	add.w	r0, r0, #8
    3686:	faa4 f28c 	sel	r2, r4, ip
    368a:	fa83 f34c 	uadd8	r3, r3, ip
    368e:	faa2 f38c 	sel	r3, r2, ip
    3692:	2b00      	cmp	r3, #0
    3694:	d0c6      	beq.n	3624 <strlen+0x24>
    3696:	2a00      	cmp	r2, #0
    3698:	bf04      	itt	eq
    369a:	3004      	addeq	r0, #4
    369c:	461a      	moveq	r2, r3
    369e:	ba12      	rev	r2, r2
    36a0:	fab2 f282 	clz	r2, r2
    36a4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
    36a8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
    36ac:	4770      	bx	lr
    36ae:	e9d1 2300 	ldrd	r2, r3, [r1]
    36b2:	f004 0503 	and.w	r5, r4, #3
    36b6:	f1c4 0000 	rsb	r0, r4, #0
    36ba:	ea4f 05c5 	mov.w	r5, r5, lsl #3
    36be:	f014 0f04 	tst.w	r4, #4
    36c2:	f891 f040 	pld	[r1, #64]	; 0x40
    36c6:	fa0c f505 	lsl.w	r5, ip, r5
    36ca:	ea62 0205 	orn	r2, r2, r5
    36ce:	bf1c      	itt	ne
    36d0:	ea63 0305 	ornne	r3, r3, r5
    36d4:	4662      	movne	r2, ip
    36d6:	f04f 0400 	mov.w	r4, #0
    36da:	e7a9      	b.n	3630 <strlen+0x30>

000036dc <__utoa>:
    36dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    36de:	f8df e078 	ldr.w	lr, [pc, #120]	; 3758 <__utoa+0x7c>
    36e2:	4616      	mov	r6, r2
    36e4:	4604      	mov	r4, r0
    36e6:	460f      	mov	r7, r1
    36e8:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    36ec:	b08b      	sub	sp, #44	; 0x2c
    36ee:	466d      	mov	r5, sp
    36f0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    36f2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    36f6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    36f8:	e89e 0003 	ldmia.w	lr, {r0, r1}
    36fc:	1eb3      	subs	r3, r6, #2
    36fe:	f845 0b04 	str.w	r0, [r5], #4
    3702:	2b22      	cmp	r3, #34	; 0x22
    3704:	7029      	strb	r1, [r5, #0]
    3706:	d822      	bhi.n	374e <__utoa+0x72>
    3708:	1e7d      	subs	r5, r7, #1
    370a:	4628      	mov	r0, r5
    370c:	2200      	movs	r2, #0
    370e:	e000      	b.n	3712 <__utoa+0x36>
    3710:	461a      	mov	r2, r3
    3712:	fbb4 f1f6 	udiv	r1, r4, r6
    3716:	ab0a      	add	r3, sp, #40	; 0x28
    3718:	fb06 4411 	mls	r4, r6, r1, r4
    371c:	4423      	add	r3, r4
    371e:	460c      	mov	r4, r1
    3720:	f813 3c28 	ldrb.w	r3, [r3, #-40]
    3724:	f800 3f01 	strb.w	r3, [r0, #1]!
    3728:	1c53      	adds	r3, r2, #1
    372a:	2900      	cmp	r1, #0
    372c:	d1f0      	bne.n	3710 <__utoa+0x34>
    372e:	54f9      	strb	r1, [r7, r3]
    3730:	18bb      	adds	r3, r7, r2
    3732:	b14a      	cbz	r2, 3748 <__utoa+0x6c>
    3734:	7819      	ldrb	r1, [r3, #0]
    3736:	f815 0f01 	ldrb.w	r0, [r5, #1]!
    373a:	7029      	strb	r1, [r5, #0]
    373c:	3401      	adds	r4, #1
    373e:	1b11      	subs	r1, r2, r4
    3740:	428c      	cmp	r4, r1
    3742:	f803 0901 	strb.w	r0, [r3], #-1
    3746:	dbf5      	blt.n	3734 <__utoa+0x58>
    3748:	4638      	mov	r0, r7
    374a:	b00b      	add	sp, #44	; 0x2c
    374c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    374e:	2000      	movs	r0, #0
    3750:	7038      	strb	r0, [r7, #0]
    3752:	b00b      	add	sp, #44	; 0x2c
    3754:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3756:	bf00      	nop
    3758:	200006cc 	.word	0x200006cc

0000375c <_vdprintf_r>:
    375c:	b5f0      	push	{r4, r5, r6, r7, lr}
    375e:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
    3762:	ad04      	add	r5, sp, #16
    3764:	9300      	str	r3, [sp, #0]
    3766:	460f      	mov	r7, r1
    3768:	4613      	mov	r3, r2
    376a:	f44f 7400 	mov.w	r4, #512	; 0x200
    376e:	aa03      	add	r2, sp, #12
    3770:	4629      	mov	r1, r5
    3772:	9403      	str	r4, [sp, #12]
    3774:	4606      	mov	r6, r0
    3776:	f000 fd45 	bl	4204 <_vasnprintf_r>
    377a:	b188      	cbz	r0, 37a0 <_vdprintf_r+0x44>
    377c:	4604      	mov	r4, r0
    377e:	4602      	mov	r2, r0
    3780:	4639      	mov	r1, r7
    3782:	9b03      	ldr	r3, [sp, #12]
    3784:	4630      	mov	r0, r6
    3786:	f000 f829 	bl	37dc <_write_r>
    378a:	42ac      	cmp	r4, r5
    378c:	9003      	str	r0, [sp, #12]
    378e:	d004      	beq.n	379a <_vdprintf_r+0x3e>
    3790:	4630      	mov	r0, r6
    3792:	4621      	mov	r1, r4
    3794:	f000 f8d8 	bl	3948 <_free_r>
    3798:	9803      	ldr	r0, [sp, #12]
    379a:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
    379e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    37a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    37a4:	e7f9      	b.n	379a <_vdprintf_r+0x3e>
    37a6:	bf00      	nop

000037a8 <vdprintf>:
    37a8:	b410      	push	{r4}
    37aa:	4c04      	ldr	r4, [pc, #16]	; (37bc <vdprintf+0x14>)
    37ac:	4613      	mov	r3, r2
    37ae:	460a      	mov	r2, r1
    37b0:	4601      	mov	r1, r0
    37b2:	6820      	ldr	r0, [r4, #0]
    37b4:	f85d 4b04 	ldr.w	r4, [sp], #4
    37b8:	f7ff bfd0 	b.w	375c <_vdprintf_r>
    37bc:	200011c8 	.word	0x200011c8

000037c0 <__ascii_wctomb>:
    37c0:	b121      	cbz	r1, 37cc <__ascii_wctomb+0xc>
    37c2:	2aff      	cmp	r2, #255	; 0xff
    37c4:	d804      	bhi.n	37d0 <__ascii_wctomb+0x10>
    37c6:	700a      	strb	r2, [r1, #0]
    37c8:	2001      	movs	r0, #1
    37ca:	4770      	bx	lr
    37cc:	4608      	mov	r0, r1
    37ce:	4770      	bx	lr
    37d0:	238a      	movs	r3, #138	; 0x8a
    37d2:	6003      	str	r3, [r0, #0]
    37d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    37d8:	4770      	bx	lr
    37da:	bf00      	nop

000037dc <_write_r>:
    37dc:	b570      	push	{r4, r5, r6, lr}
    37de:	460d      	mov	r5, r1
    37e0:	4c08      	ldr	r4, [pc, #32]	; (3804 <_write_r+0x28>)
    37e2:	4611      	mov	r1, r2
    37e4:	4606      	mov	r6, r0
    37e6:	461a      	mov	r2, r3
    37e8:	4628      	mov	r0, r5
    37ea:	2300      	movs	r3, #0
    37ec:	6023      	str	r3, [r4, #0]
    37ee:	f7fe fd07 	bl	2200 <_write>
    37f2:	1c43      	adds	r3, r0, #1
    37f4:	d000      	beq.n	37f8 <_write_r+0x1c>
    37f6:	bd70      	pop	{r4, r5, r6, pc}
    37f8:	6823      	ldr	r3, [r4, #0]
    37fa:	2b00      	cmp	r3, #0
    37fc:	d0fb      	beq.n	37f6 <_write_r+0x1a>
    37fe:	6033      	str	r3, [r6, #0]
    3800:	bd70      	pop	{r4, r5, r6, pc}
    3802:	bf00      	nop
    3804:	20001c74 	.word	0x20001c74

00003808 <__register_exitproc>:
    3808:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    380c:	4c25      	ldr	r4, [pc, #148]	; (38a4 <__register_exitproc+0x9c>)
    380e:	6825      	ldr	r5, [r4, #0]
    3810:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    3814:	4606      	mov	r6, r0
    3816:	4688      	mov	r8, r1
    3818:	4692      	mov	sl, r2
    381a:	4699      	mov	r9, r3
    381c:	b3c4      	cbz	r4, 3890 <__register_exitproc+0x88>
    381e:	6860      	ldr	r0, [r4, #4]
    3820:	281f      	cmp	r0, #31
    3822:	dc17      	bgt.n	3854 <__register_exitproc+0x4c>
    3824:	1c43      	adds	r3, r0, #1
    3826:	b176      	cbz	r6, 3846 <__register_exitproc+0x3e>
    3828:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    382c:	2201      	movs	r2, #1
    382e:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    3832:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    3836:	4082      	lsls	r2, r0
    3838:	4311      	orrs	r1, r2
    383a:	2e02      	cmp	r6, #2
    383c:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    3840:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    3844:	d01e      	beq.n	3884 <__register_exitproc+0x7c>
    3846:	3002      	adds	r0, #2
    3848:	6063      	str	r3, [r4, #4]
    384a:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    384e:	2000      	movs	r0, #0
    3850:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3854:	4b14      	ldr	r3, [pc, #80]	; (38a8 <__register_exitproc+0xa0>)
    3856:	b303      	cbz	r3, 389a <__register_exitproc+0x92>
    3858:	f44f 70c8 	mov.w	r0, #400	; 0x190
    385c:	f7ff f83a 	bl	28d4 <malloc>
    3860:	4604      	mov	r4, r0
    3862:	b1d0      	cbz	r0, 389a <__register_exitproc+0x92>
    3864:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    3868:	2700      	movs	r7, #0
    386a:	e880 0088 	stmia.w	r0, {r3, r7}
    386e:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    3872:	4638      	mov	r0, r7
    3874:	2301      	movs	r3, #1
    3876:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    387a:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    387e:	2e00      	cmp	r6, #0
    3880:	d0e1      	beq.n	3846 <__register_exitproc+0x3e>
    3882:	e7d1      	b.n	3828 <__register_exitproc+0x20>
    3884:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    3888:	430a      	orrs	r2, r1
    388a:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    388e:	e7da      	b.n	3846 <__register_exitproc+0x3e>
    3890:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    3894:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    3898:	e7c1      	b.n	381e <__register_exitproc+0x16>
    389a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    389e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    38a2:	bf00      	nop
    38a4:	2000049c 	.word	0x2000049c
    38a8:	000028d5 	.word	0x000028d5

000038ac <_malloc_trim_r>:
    38ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    38ae:	4f23      	ldr	r7, [pc, #140]	; (393c <_malloc_trim_r+0x90>)
    38b0:	460c      	mov	r4, r1
    38b2:	4606      	mov	r6, r0
    38b4:	f7ff fc38 	bl	3128 <__malloc_lock>
    38b8:	68bb      	ldr	r3, [r7, #8]
    38ba:	685d      	ldr	r5, [r3, #4]
    38bc:	f025 0503 	bic.w	r5, r5, #3
    38c0:	1b29      	subs	r1, r5, r4
    38c2:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    38c6:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    38ca:	f021 010f 	bic.w	r1, r1, #15
    38ce:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    38d2:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    38d6:	db07      	blt.n	38e8 <_malloc_trim_r+0x3c>
    38d8:	2100      	movs	r1, #0
    38da:	4630      	mov	r0, r6
    38dc:	f7ff fe20 	bl	3520 <_sbrk_r>
    38e0:	68bb      	ldr	r3, [r7, #8]
    38e2:	442b      	add	r3, r5
    38e4:	4298      	cmp	r0, r3
    38e6:	d004      	beq.n	38f2 <_malloc_trim_r+0x46>
    38e8:	4630      	mov	r0, r6
    38ea:	f7ff fc1f 	bl	312c <__malloc_unlock>
    38ee:	2000      	movs	r0, #0
    38f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    38f2:	4261      	negs	r1, r4
    38f4:	4630      	mov	r0, r6
    38f6:	f7ff fe13 	bl	3520 <_sbrk_r>
    38fa:	3001      	adds	r0, #1
    38fc:	d00d      	beq.n	391a <_malloc_trim_r+0x6e>
    38fe:	4b10      	ldr	r3, [pc, #64]	; (3940 <_malloc_trim_r+0x94>)
    3900:	68ba      	ldr	r2, [r7, #8]
    3902:	6819      	ldr	r1, [r3, #0]
    3904:	1b2d      	subs	r5, r5, r4
    3906:	f045 0501 	orr.w	r5, r5, #1
    390a:	4630      	mov	r0, r6
    390c:	1b09      	subs	r1, r1, r4
    390e:	6055      	str	r5, [r2, #4]
    3910:	6019      	str	r1, [r3, #0]
    3912:	f7ff fc0b 	bl	312c <__malloc_unlock>
    3916:	2001      	movs	r0, #1
    3918:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    391a:	2100      	movs	r1, #0
    391c:	4630      	mov	r0, r6
    391e:	f7ff fdff 	bl	3520 <_sbrk_r>
    3922:	68ba      	ldr	r2, [r7, #8]
    3924:	1a83      	subs	r3, r0, r2
    3926:	2b0f      	cmp	r3, #15
    3928:	ddde      	ble.n	38e8 <_malloc_trim_r+0x3c>
    392a:	4c06      	ldr	r4, [pc, #24]	; (3944 <_malloc_trim_r+0x98>)
    392c:	4904      	ldr	r1, [pc, #16]	; (3940 <_malloc_trim_r+0x94>)
    392e:	6824      	ldr	r4, [r4, #0]
    3930:	f043 0301 	orr.w	r3, r3, #1
    3934:	1b00      	subs	r0, r0, r4
    3936:	6053      	str	r3, [r2, #4]
    3938:	6008      	str	r0, [r1, #0]
    393a:	e7d5      	b.n	38e8 <_malloc_trim_r+0x3c>
    393c:	20000db8 	.word	0x20000db8
    3940:	20001ab4 	.word	0x20001ab4
    3944:	200011c0 	.word	0x200011c0

00003948 <_free_r>:
    3948:	2900      	cmp	r1, #0
    394a:	d045      	beq.n	39d8 <_free_r+0x90>
    394c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3950:	460d      	mov	r5, r1
    3952:	4680      	mov	r8, r0
    3954:	f7ff fbe8 	bl	3128 <__malloc_lock>
    3958:	f855 7c04 	ldr.w	r7, [r5, #-4]
    395c:	496a      	ldr	r1, [pc, #424]	; (3b08 <_free_r+0x1c0>)
    395e:	f027 0301 	bic.w	r3, r7, #1
    3962:	f1a5 0408 	sub.w	r4, r5, #8
    3966:	18e2      	adds	r2, r4, r3
    3968:	688e      	ldr	r6, [r1, #8]
    396a:	6850      	ldr	r0, [r2, #4]
    396c:	42b2      	cmp	r2, r6
    396e:	f020 0003 	bic.w	r0, r0, #3
    3972:	d062      	beq.n	3a3a <_free_r+0xf2>
    3974:	07fe      	lsls	r6, r7, #31
    3976:	6050      	str	r0, [r2, #4]
    3978:	d40b      	bmi.n	3992 <_free_r+0x4a>
    397a:	f855 7c08 	ldr.w	r7, [r5, #-8]
    397e:	1be4      	subs	r4, r4, r7
    3980:	f101 0e08 	add.w	lr, r1, #8
    3984:	68a5      	ldr	r5, [r4, #8]
    3986:	4575      	cmp	r5, lr
    3988:	443b      	add	r3, r7
    398a:	d06f      	beq.n	3a6c <_free_r+0x124>
    398c:	68e7      	ldr	r7, [r4, #12]
    398e:	60ef      	str	r7, [r5, #12]
    3990:	60bd      	str	r5, [r7, #8]
    3992:	1815      	adds	r5, r2, r0
    3994:	686d      	ldr	r5, [r5, #4]
    3996:	07ed      	lsls	r5, r5, #31
    3998:	d542      	bpl.n	3a20 <_free_r+0xd8>
    399a:	f043 0201 	orr.w	r2, r3, #1
    399e:	6062      	str	r2, [r4, #4]
    39a0:	50e3      	str	r3, [r4, r3]
    39a2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    39a6:	d218      	bcs.n	39da <_free_r+0x92>
    39a8:	08db      	lsrs	r3, r3, #3
    39aa:	1c5a      	adds	r2, r3, #1
    39ac:	684d      	ldr	r5, [r1, #4]
    39ae:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    39b2:	60a7      	str	r7, [r4, #8]
    39b4:	2001      	movs	r0, #1
    39b6:	109b      	asrs	r3, r3, #2
    39b8:	fa00 f303 	lsl.w	r3, r0, r3
    39bc:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    39c0:	431d      	orrs	r5, r3
    39c2:	3808      	subs	r0, #8
    39c4:	60e0      	str	r0, [r4, #12]
    39c6:	604d      	str	r5, [r1, #4]
    39c8:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    39cc:	60fc      	str	r4, [r7, #12]
    39ce:	4640      	mov	r0, r8
    39d0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    39d4:	f7ff bbaa 	b.w	312c <__malloc_unlock>
    39d8:	4770      	bx	lr
    39da:	0a5a      	lsrs	r2, r3, #9
    39dc:	2a04      	cmp	r2, #4
    39de:	d853      	bhi.n	3a88 <_free_r+0x140>
    39e0:	099a      	lsrs	r2, r3, #6
    39e2:	f102 0739 	add.w	r7, r2, #57	; 0x39
    39e6:	007f      	lsls	r7, r7, #1
    39e8:	f102 0538 	add.w	r5, r2, #56	; 0x38
    39ec:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    39f0:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    39f4:	4944      	ldr	r1, [pc, #272]	; (3b08 <_free_r+0x1c0>)
    39f6:	3808      	subs	r0, #8
    39f8:	4290      	cmp	r0, r2
    39fa:	d04d      	beq.n	3a98 <_free_r+0x150>
    39fc:	6851      	ldr	r1, [r2, #4]
    39fe:	f021 0103 	bic.w	r1, r1, #3
    3a02:	428b      	cmp	r3, r1
    3a04:	d202      	bcs.n	3a0c <_free_r+0xc4>
    3a06:	6892      	ldr	r2, [r2, #8]
    3a08:	4290      	cmp	r0, r2
    3a0a:	d1f7      	bne.n	39fc <_free_r+0xb4>
    3a0c:	68d0      	ldr	r0, [r2, #12]
    3a0e:	60e0      	str	r0, [r4, #12]
    3a10:	60a2      	str	r2, [r4, #8]
    3a12:	6084      	str	r4, [r0, #8]
    3a14:	60d4      	str	r4, [r2, #12]
    3a16:	4640      	mov	r0, r8
    3a18:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    3a1c:	f7ff bb86 	b.w	312c <__malloc_unlock>
    3a20:	6895      	ldr	r5, [r2, #8]
    3a22:	4f3a      	ldr	r7, [pc, #232]	; (3b0c <_free_r+0x1c4>)
    3a24:	42bd      	cmp	r5, r7
    3a26:	4403      	add	r3, r0
    3a28:	d03f      	beq.n	3aaa <_free_r+0x162>
    3a2a:	68d0      	ldr	r0, [r2, #12]
    3a2c:	60e8      	str	r0, [r5, #12]
    3a2e:	f043 0201 	orr.w	r2, r3, #1
    3a32:	6085      	str	r5, [r0, #8]
    3a34:	6062      	str	r2, [r4, #4]
    3a36:	50e3      	str	r3, [r4, r3]
    3a38:	e7b3      	b.n	39a2 <_free_r+0x5a>
    3a3a:	07ff      	lsls	r7, r7, #31
    3a3c:	4403      	add	r3, r0
    3a3e:	d407      	bmi.n	3a50 <_free_r+0x108>
    3a40:	f855 2c08 	ldr.w	r2, [r5, #-8]
    3a44:	1aa4      	subs	r4, r4, r2
    3a46:	4413      	add	r3, r2
    3a48:	68a0      	ldr	r0, [r4, #8]
    3a4a:	68e2      	ldr	r2, [r4, #12]
    3a4c:	60c2      	str	r2, [r0, #12]
    3a4e:	6090      	str	r0, [r2, #8]
    3a50:	4a2f      	ldr	r2, [pc, #188]	; (3b10 <_free_r+0x1c8>)
    3a52:	6812      	ldr	r2, [r2, #0]
    3a54:	f043 0001 	orr.w	r0, r3, #1
    3a58:	4293      	cmp	r3, r2
    3a5a:	6060      	str	r0, [r4, #4]
    3a5c:	608c      	str	r4, [r1, #8]
    3a5e:	d3b6      	bcc.n	39ce <_free_r+0x86>
    3a60:	4b2c      	ldr	r3, [pc, #176]	; (3b14 <_free_r+0x1cc>)
    3a62:	4640      	mov	r0, r8
    3a64:	6819      	ldr	r1, [r3, #0]
    3a66:	f7ff ff21 	bl	38ac <_malloc_trim_r>
    3a6a:	e7b0      	b.n	39ce <_free_r+0x86>
    3a6c:	1811      	adds	r1, r2, r0
    3a6e:	6849      	ldr	r1, [r1, #4]
    3a70:	07c9      	lsls	r1, r1, #31
    3a72:	d444      	bmi.n	3afe <_free_r+0x1b6>
    3a74:	6891      	ldr	r1, [r2, #8]
    3a76:	68d2      	ldr	r2, [r2, #12]
    3a78:	60ca      	str	r2, [r1, #12]
    3a7a:	4403      	add	r3, r0
    3a7c:	f043 0001 	orr.w	r0, r3, #1
    3a80:	6091      	str	r1, [r2, #8]
    3a82:	6060      	str	r0, [r4, #4]
    3a84:	50e3      	str	r3, [r4, r3]
    3a86:	e7a2      	b.n	39ce <_free_r+0x86>
    3a88:	2a14      	cmp	r2, #20
    3a8a:	d817      	bhi.n	3abc <_free_r+0x174>
    3a8c:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    3a90:	007f      	lsls	r7, r7, #1
    3a92:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    3a96:	e7a9      	b.n	39ec <_free_r+0xa4>
    3a98:	10aa      	asrs	r2, r5, #2
    3a9a:	684b      	ldr	r3, [r1, #4]
    3a9c:	2501      	movs	r5, #1
    3a9e:	fa05 f202 	lsl.w	r2, r5, r2
    3aa2:	4313      	orrs	r3, r2
    3aa4:	604b      	str	r3, [r1, #4]
    3aa6:	4602      	mov	r2, r0
    3aa8:	e7b1      	b.n	3a0e <_free_r+0xc6>
    3aaa:	f043 0201 	orr.w	r2, r3, #1
    3aae:	614c      	str	r4, [r1, #20]
    3ab0:	610c      	str	r4, [r1, #16]
    3ab2:	60e5      	str	r5, [r4, #12]
    3ab4:	60a5      	str	r5, [r4, #8]
    3ab6:	6062      	str	r2, [r4, #4]
    3ab8:	50e3      	str	r3, [r4, r3]
    3aba:	e788      	b.n	39ce <_free_r+0x86>
    3abc:	2a54      	cmp	r2, #84	; 0x54
    3abe:	d806      	bhi.n	3ace <_free_r+0x186>
    3ac0:	0b1a      	lsrs	r2, r3, #12
    3ac2:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    3ac6:	007f      	lsls	r7, r7, #1
    3ac8:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    3acc:	e78e      	b.n	39ec <_free_r+0xa4>
    3ace:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    3ad2:	d806      	bhi.n	3ae2 <_free_r+0x19a>
    3ad4:	0bda      	lsrs	r2, r3, #15
    3ad6:	f102 0778 	add.w	r7, r2, #120	; 0x78
    3ada:	007f      	lsls	r7, r7, #1
    3adc:	f102 0577 	add.w	r5, r2, #119	; 0x77
    3ae0:	e784      	b.n	39ec <_free_r+0xa4>
    3ae2:	f240 5054 	movw	r0, #1364	; 0x554
    3ae6:	4282      	cmp	r2, r0
    3ae8:	d806      	bhi.n	3af8 <_free_r+0x1b0>
    3aea:	0c9a      	lsrs	r2, r3, #18
    3aec:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    3af0:	007f      	lsls	r7, r7, #1
    3af2:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    3af6:	e779      	b.n	39ec <_free_r+0xa4>
    3af8:	27fe      	movs	r7, #254	; 0xfe
    3afa:	257e      	movs	r5, #126	; 0x7e
    3afc:	e776      	b.n	39ec <_free_r+0xa4>
    3afe:	f043 0201 	orr.w	r2, r3, #1
    3b02:	6062      	str	r2, [r4, #4]
    3b04:	50e3      	str	r3, [r4, r3]
    3b06:	e762      	b.n	39ce <_free_r+0x86>
    3b08:	20000db8 	.word	0x20000db8
    3b0c:	20000dc0 	.word	0x20000dc0
    3b10:	200011c4 	.word	0x200011c4
    3b14:	20001ae4 	.word	0x20001ae4

00003b18 <_localeconv_r>:
    3b18:	4a04      	ldr	r2, [pc, #16]	; (3b2c <_localeconv_r+0x14>)
    3b1a:	4b05      	ldr	r3, [pc, #20]	; (3b30 <_localeconv_r+0x18>)
    3b1c:	6812      	ldr	r2, [r2, #0]
    3b1e:	6b50      	ldr	r0, [r2, #52]	; 0x34
    3b20:	2800      	cmp	r0, #0
    3b22:	bf08      	it	eq
    3b24:	4618      	moveq	r0, r3
    3b26:	30f0      	adds	r0, #240	; 0xf0
    3b28:	4770      	bx	lr
    3b2a:	bf00      	nop
    3b2c:	200011c8 	.word	0x200011c8
    3b30:	20000c4c 	.word	0x20000c4c
	...

00003b40 <memchr>:
    3b40:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    3b44:	2a10      	cmp	r2, #16
    3b46:	db2b      	blt.n	3ba0 <memchr+0x60>
    3b48:	f010 0f07 	tst.w	r0, #7
    3b4c:	d008      	beq.n	3b60 <memchr+0x20>
    3b4e:	f810 3b01 	ldrb.w	r3, [r0], #1
    3b52:	3a01      	subs	r2, #1
    3b54:	428b      	cmp	r3, r1
    3b56:	d02d      	beq.n	3bb4 <memchr+0x74>
    3b58:	f010 0f07 	tst.w	r0, #7
    3b5c:	b342      	cbz	r2, 3bb0 <memchr+0x70>
    3b5e:	d1f6      	bne.n	3b4e <memchr+0xe>
    3b60:	b4f0      	push	{r4, r5, r6, r7}
    3b62:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    3b66:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    3b6a:	f022 0407 	bic.w	r4, r2, #7
    3b6e:	f07f 0700 	mvns.w	r7, #0
    3b72:	2300      	movs	r3, #0
    3b74:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    3b78:	3c08      	subs	r4, #8
    3b7a:	ea85 0501 	eor.w	r5, r5, r1
    3b7e:	ea86 0601 	eor.w	r6, r6, r1
    3b82:	fa85 f547 	uadd8	r5, r5, r7
    3b86:	faa3 f587 	sel	r5, r3, r7
    3b8a:	fa86 f647 	uadd8	r6, r6, r7
    3b8e:	faa5 f687 	sel	r6, r5, r7
    3b92:	b98e      	cbnz	r6, 3bb8 <memchr+0x78>
    3b94:	d1ee      	bne.n	3b74 <memchr+0x34>
    3b96:	bcf0      	pop	{r4, r5, r6, r7}
    3b98:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    3b9c:	f002 0207 	and.w	r2, r2, #7
    3ba0:	b132      	cbz	r2, 3bb0 <memchr+0x70>
    3ba2:	f810 3b01 	ldrb.w	r3, [r0], #1
    3ba6:	3a01      	subs	r2, #1
    3ba8:	ea83 0301 	eor.w	r3, r3, r1
    3bac:	b113      	cbz	r3, 3bb4 <memchr+0x74>
    3bae:	d1f8      	bne.n	3ba2 <memchr+0x62>
    3bb0:	2000      	movs	r0, #0
    3bb2:	4770      	bx	lr
    3bb4:	3801      	subs	r0, #1
    3bb6:	4770      	bx	lr
    3bb8:	2d00      	cmp	r5, #0
    3bba:	bf06      	itte	eq
    3bbc:	4635      	moveq	r5, r6
    3bbe:	3803      	subeq	r0, #3
    3bc0:	3807      	subne	r0, #7
    3bc2:	f015 0f01 	tst.w	r5, #1
    3bc6:	d107      	bne.n	3bd8 <memchr+0x98>
    3bc8:	3001      	adds	r0, #1
    3bca:	f415 7f80 	tst.w	r5, #256	; 0x100
    3bce:	bf02      	ittt	eq
    3bd0:	3001      	addeq	r0, #1
    3bd2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    3bd6:	3001      	addeq	r0, #1
    3bd8:	bcf0      	pop	{r4, r5, r6, r7}
    3bda:	3801      	subs	r0, #1
    3bdc:	4770      	bx	lr
    3bde:	bf00      	nop

00003be0 <_Balloc>:
    3be0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    3be2:	b570      	push	{r4, r5, r6, lr}
    3be4:	4605      	mov	r5, r0
    3be6:	460c      	mov	r4, r1
    3be8:	b14b      	cbz	r3, 3bfe <_Balloc+0x1e>
    3bea:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    3bee:	b180      	cbz	r0, 3c12 <_Balloc+0x32>
    3bf0:	6802      	ldr	r2, [r0, #0]
    3bf2:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    3bf6:	2300      	movs	r3, #0
    3bf8:	6103      	str	r3, [r0, #16]
    3bfa:	60c3      	str	r3, [r0, #12]
    3bfc:	bd70      	pop	{r4, r5, r6, pc}
    3bfe:	2221      	movs	r2, #33	; 0x21
    3c00:	2104      	movs	r1, #4
    3c02:	f000 fb2f 	bl	4264 <_calloc_r>
    3c06:	64e8      	str	r0, [r5, #76]	; 0x4c
    3c08:	4603      	mov	r3, r0
    3c0a:	2800      	cmp	r0, #0
    3c0c:	d1ed      	bne.n	3bea <_Balloc+0xa>
    3c0e:	2000      	movs	r0, #0
    3c10:	bd70      	pop	{r4, r5, r6, pc}
    3c12:	2101      	movs	r1, #1
    3c14:	fa01 f604 	lsl.w	r6, r1, r4
    3c18:	1d72      	adds	r2, r6, #5
    3c1a:	4628      	mov	r0, r5
    3c1c:	0092      	lsls	r2, r2, #2
    3c1e:	f000 fb21 	bl	4264 <_calloc_r>
    3c22:	2800      	cmp	r0, #0
    3c24:	d0f3      	beq.n	3c0e <_Balloc+0x2e>
    3c26:	6044      	str	r4, [r0, #4]
    3c28:	6086      	str	r6, [r0, #8]
    3c2a:	e7e4      	b.n	3bf6 <_Balloc+0x16>

00003c2c <_Bfree>:
    3c2c:	b131      	cbz	r1, 3c3c <_Bfree+0x10>
    3c2e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    3c30:	684a      	ldr	r2, [r1, #4]
    3c32:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    3c36:	6008      	str	r0, [r1, #0]
    3c38:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    3c3c:	4770      	bx	lr
    3c3e:	bf00      	nop

00003c40 <__multadd>:
    3c40:	b5f0      	push	{r4, r5, r6, r7, lr}
    3c42:	690c      	ldr	r4, [r1, #16]
    3c44:	b083      	sub	sp, #12
    3c46:	460d      	mov	r5, r1
    3c48:	4606      	mov	r6, r0
    3c4a:	f101 0e14 	add.w	lr, r1, #20
    3c4e:	2700      	movs	r7, #0
    3c50:	f8de 0000 	ldr.w	r0, [lr]
    3c54:	b281      	uxth	r1, r0
    3c56:	fb02 3101 	mla	r1, r2, r1, r3
    3c5a:	0c0b      	lsrs	r3, r1, #16
    3c5c:	0c00      	lsrs	r0, r0, #16
    3c5e:	fb02 3300 	mla	r3, r2, r0, r3
    3c62:	b289      	uxth	r1, r1
    3c64:	3701      	adds	r7, #1
    3c66:	eb01 4103 	add.w	r1, r1, r3, lsl #16
    3c6a:	42bc      	cmp	r4, r7
    3c6c:	f84e 1b04 	str.w	r1, [lr], #4
    3c70:	ea4f 4313 	mov.w	r3, r3, lsr #16
    3c74:	dcec      	bgt.n	3c50 <__multadd+0x10>
    3c76:	b13b      	cbz	r3, 3c88 <__multadd+0x48>
    3c78:	68aa      	ldr	r2, [r5, #8]
    3c7a:	4294      	cmp	r4, r2
    3c7c:	da07      	bge.n	3c8e <__multadd+0x4e>
    3c7e:	eb05 0284 	add.w	r2, r5, r4, lsl #2
    3c82:	3401      	adds	r4, #1
    3c84:	6153      	str	r3, [r2, #20]
    3c86:	612c      	str	r4, [r5, #16]
    3c88:	4628      	mov	r0, r5
    3c8a:	b003      	add	sp, #12
    3c8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3c8e:	6869      	ldr	r1, [r5, #4]
    3c90:	9301      	str	r3, [sp, #4]
    3c92:	3101      	adds	r1, #1
    3c94:	4630      	mov	r0, r6
    3c96:	f7ff ffa3 	bl	3be0 <_Balloc>
    3c9a:	692a      	ldr	r2, [r5, #16]
    3c9c:	3202      	adds	r2, #2
    3c9e:	f105 010c 	add.w	r1, r5, #12
    3ca2:	4607      	mov	r7, r0
    3ca4:	0092      	lsls	r2, r2, #2
    3ca6:	300c      	adds	r0, #12
    3ca8:	f7ff f8f2 	bl	2e90 <memcpy>
    3cac:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
    3cae:	6869      	ldr	r1, [r5, #4]
    3cb0:	9b01      	ldr	r3, [sp, #4]
    3cb2:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
    3cb6:	6028      	str	r0, [r5, #0]
    3cb8:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
    3cbc:	463d      	mov	r5, r7
    3cbe:	e7de      	b.n	3c7e <__multadd+0x3e>

00003cc0 <__hi0bits>:
    3cc0:	0c03      	lsrs	r3, r0, #16
    3cc2:	041b      	lsls	r3, r3, #16
    3cc4:	b9b3      	cbnz	r3, 3cf4 <__hi0bits+0x34>
    3cc6:	0400      	lsls	r0, r0, #16
    3cc8:	2310      	movs	r3, #16
    3cca:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
    3cce:	bf04      	itt	eq
    3cd0:	0200      	lsleq	r0, r0, #8
    3cd2:	3308      	addeq	r3, #8
    3cd4:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
    3cd8:	bf04      	itt	eq
    3cda:	0100      	lsleq	r0, r0, #4
    3cdc:	3304      	addeq	r3, #4
    3cde:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
    3ce2:	bf04      	itt	eq
    3ce4:	0080      	lsleq	r0, r0, #2
    3ce6:	3302      	addeq	r3, #2
    3ce8:	2800      	cmp	r0, #0
    3cea:	db07      	blt.n	3cfc <__hi0bits+0x3c>
    3cec:	0042      	lsls	r2, r0, #1
    3cee:	d403      	bmi.n	3cf8 <__hi0bits+0x38>
    3cf0:	2020      	movs	r0, #32
    3cf2:	4770      	bx	lr
    3cf4:	2300      	movs	r3, #0
    3cf6:	e7e8      	b.n	3cca <__hi0bits+0xa>
    3cf8:	1c58      	adds	r0, r3, #1
    3cfa:	4770      	bx	lr
    3cfc:	4618      	mov	r0, r3
    3cfe:	4770      	bx	lr

00003d00 <__lo0bits>:
    3d00:	6803      	ldr	r3, [r0, #0]
    3d02:	f013 0207 	ands.w	r2, r3, #7
    3d06:	d007      	beq.n	3d18 <__lo0bits+0x18>
    3d08:	07d9      	lsls	r1, r3, #31
    3d0a:	d420      	bmi.n	3d4e <__lo0bits+0x4e>
    3d0c:	079a      	lsls	r2, r3, #30
    3d0e:	d420      	bmi.n	3d52 <__lo0bits+0x52>
    3d10:	089b      	lsrs	r3, r3, #2
    3d12:	6003      	str	r3, [r0, #0]
    3d14:	2002      	movs	r0, #2
    3d16:	4770      	bx	lr
    3d18:	b299      	uxth	r1, r3
    3d1a:	b909      	cbnz	r1, 3d20 <__lo0bits+0x20>
    3d1c:	0c1b      	lsrs	r3, r3, #16
    3d1e:	2210      	movs	r2, #16
    3d20:	f013 0fff 	tst.w	r3, #255	; 0xff
    3d24:	bf04      	itt	eq
    3d26:	0a1b      	lsreq	r3, r3, #8
    3d28:	3208      	addeq	r2, #8
    3d2a:	0719      	lsls	r1, r3, #28
    3d2c:	bf04      	itt	eq
    3d2e:	091b      	lsreq	r3, r3, #4
    3d30:	3204      	addeq	r2, #4
    3d32:	0799      	lsls	r1, r3, #30
    3d34:	bf04      	itt	eq
    3d36:	089b      	lsreq	r3, r3, #2
    3d38:	3202      	addeq	r2, #2
    3d3a:	07d9      	lsls	r1, r3, #31
    3d3c:	d404      	bmi.n	3d48 <__lo0bits+0x48>
    3d3e:	085b      	lsrs	r3, r3, #1
    3d40:	d101      	bne.n	3d46 <__lo0bits+0x46>
    3d42:	2020      	movs	r0, #32
    3d44:	4770      	bx	lr
    3d46:	3201      	adds	r2, #1
    3d48:	6003      	str	r3, [r0, #0]
    3d4a:	4610      	mov	r0, r2
    3d4c:	4770      	bx	lr
    3d4e:	2000      	movs	r0, #0
    3d50:	4770      	bx	lr
    3d52:	085b      	lsrs	r3, r3, #1
    3d54:	6003      	str	r3, [r0, #0]
    3d56:	2001      	movs	r0, #1
    3d58:	4770      	bx	lr
    3d5a:	bf00      	nop

00003d5c <__i2b>:
    3d5c:	b510      	push	{r4, lr}
    3d5e:	460c      	mov	r4, r1
    3d60:	2101      	movs	r1, #1
    3d62:	f7ff ff3d 	bl	3be0 <_Balloc>
    3d66:	2201      	movs	r2, #1
    3d68:	6144      	str	r4, [r0, #20]
    3d6a:	6102      	str	r2, [r0, #16]
    3d6c:	bd10      	pop	{r4, pc}
    3d6e:	bf00      	nop

00003d70 <__multiply>:
    3d70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3d74:	690d      	ldr	r5, [r1, #16]
    3d76:	6917      	ldr	r7, [r2, #16]
    3d78:	42bd      	cmp	r5, r7
    3d7a:	b083      	sub	sp, #12
    3d7c:	460c      	mov	r4, r1
    3d7e:	4616      	mov	r6, r2
    3d80:	da04      	bge.n	3d8c <__multiply+0x1c>
    3d82:	462a      	mov	r2, r5
    3d84:	4634      	mov	r4, r6
    3d86:	463d      	mov	r5, r7
    3d88:	460e      	mov	r6, r1
    3d8a:	4617      	mov	r7, r2
    3d8c:	68a3      	ldr	r3, [r4, #8]
    3d8e:	6861      	ldr	r1, [r4, #4]
    3d90:	eb05 0807 	add.w	r8, r5, r7
    3d94:	4598      	cmp	r8, r3
    3d96:	bfc8      	it	gt
    3d98:	3101      	addgt	r1, #1
    3d9a:	f7ff ff21 	bl	3be0 <_Balloc>
    3d9e:	f100 0c14 	add.w	ip, r0, #20
    3da2:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
    3da6:	45cc      	cmp	ip, r9
    3da8:	9000      	str	r0, [sp, #0]
    3daa:	d205      	bcs.n	3db8 <__multiply+0x48>
    3dac:	4663      	mov	r3, ip
    3dae:	2100      	movs	r1, #0
    3db0:	f843 1b04 	str.w	r1, [r3], #4
    3db4:	4599      	cmp	r9, r3
    3db6:	d8fb      	bhi.n	3db0 <__multiply+0x40>
    3db8:	f106 0214 	add.w	r2, r6, #20
    3dbc:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
    3dc0:	f104 0314 	add.w	r3, r4, #20
    3dc4:	4552      	cmp	r2, sl
    3dc6:	eb03 0e85 	add.w	lr, r3, r5, lsl #2
    3dca:	d254      	bcs.n	3e76 <__multiply+0x106>
    3dcc:	f8cd 9004 	str.w	r9, [sp, #4]
    3dd0:	4699      	mov	r9, r3
    3dd2:	f852 3b04 	ldr.w	r3, [r2], #4
    3dd6:	fa1f fb83 	uxth.w	fp, r3
    3dda:	f1bb 0f00 	cmp.w	fp, #0
    3dde:	d020      	beq.n	3e22 <__multiply+0xb2>
    3de0:	2000      	movs	r0, #0
    3de2:	464f      	mov	r7, r9
    3de4:	4666      	mov	r6, ip
    3de6:	4605      	mov	r5, r0
    3de8:	e000      	b.n	3dec <__multiply+0x7c>
    3dea:	461e      	mov	r6, r3
    3dec:	f857 4b04 	ldr.w	r4, [r7], #4
    3df0:	6830      	ldr	r0, [r6, #0]
    3df2:	b2a1      	uxth	r1, r4
    3df4:	b283      	uxth	r3, r0
    3df6:	fb0b 3101 	mla	r1, fp, r1, r3
    3dfa:	0c24      	lsrs	r4, r4, #16
    3dfc:	0c00      	lsrs	r0, r0, #16
    3dfe:	194b      	adds	r3, r1, r5
    3e00:	fb0b 0004 	mla	r0, fp, r4, r0
    3e04:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    3e08:	b299      	uxth	r1, r3
    3e0a:	4633      	mov	r3, r6
    3e0c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    3e10:	45be      	cmp	lr, r7
    3e12:	ea4f 4510 	mov.w	r5, r0, lsr #16
    3e16:	f843 1b04 	str.w	r1, [r3], #4
    3e1a:	d8e6      	bhi.n	3dea <__multiply+0x7a>
    3e1c:	6075      	str	r5, [r6, #4]
    3e1e:	f852 3c04 	ldr.w	r3, [r2, #-4]
    3e22:	ea5f 4b13 	movs.w	fp, r3, lsr #16
    3e26:	d020      	beq.n	3e6a <__multiply+0xfa>
    3e28:	f8dc 3000 	ldr.w	r3, [ip]
    3e2c:	4667      	mov	r7, ip
    3e2e:	4618      	mov	r0, r3
    3e30:	464d      	mov	r5, r9
    3e32:	2100      	movs	r1, #0
    3e34:	e000      	b.n	3e38 <__multiply+0xc8>
    3e36:	4637      	mov	r7, r6
    3e38:	882c      	ldrh	r4, [r5, #0]
    3e3a:	0c00      	lsrs	r0, r0, #16
    3e3c:	fb0b 0004 	mla	r0, fp, r4, r0
    3e40:	4401      	add	r1, r0
    3e42:	b29c      	uxth	r4, r3
    3e44:	463e      	mov	r6, r7
    3e46:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
    3e4a:	f846 3b04 	str.w	r3, [r6], #4
    3e4e:	6878      	ldr	r0, [r7, #4]
    3e50:	f855 4b04 	ldr.w	r4, [r5], #4
    3e54:	b283      	uxth	r3, r0
    3e56:	0c24      	lsrs	r4, r4, #16
    3e58:	fb0b 3404 	mla	r4, fp, r4, r3
    3e5c:	eb04 4311 	add.w	r3, r4, r1, lsr #16
    3e60:	45ae      	cmp	lr, r5
    3e62:	ea4f 4113 	mov.w	r1, r3, lsr #16
    3e66:	d8e6      	bhi.n	3e36 <__multiply+0xc6>
    3e68:	607b      	str	r3, [r7, #4]
    3e6a:	4592      	cmp	sl, r2
    3e6c:	f10c 0c04 	add.w	ip, ip, #4
    3e70:	d8af      	bhi.n	3dd2 <__multiply+0x62>
    3e72:	f8dd 9004 	ldr.w	r9, [sp, #4]
    3e76:	f1b8 0f00 	cmp.w	r8, #0
    3e7a:	dd0b      	ble.n	3e94 <__multiply+0x124>
    3e7c:	f859 3c04 	ldr.w	r3, [r9, #-4]
    3e80:	f1a9 0904 	sub.w	r9, r9, #4
    3e84:	b11b      	cbz	r3, 3e8e <__multiply+0x11e>
    3e86:	e005      	b.n	3e94 <__multiply+0x124>
    3e88:	f859 3d04 	ldr.w	r3, [r9, #-4]!
    3e8c:	b913      	cbnz	r3, 3e94 <__multiply+0x124>
    3e8e:	f1b8 0801 	subs.w	r8, r8, #1
    3e92:	d1f9      	bne.n	3e88 <__multiply+0x118>
    3e94:	9800      	ldr	r0, [sp, #0]
    3e96:	f8c0 8010 	str.w	r8, [r0, #16]
    3e9a:	b003      	add	sp, #12
    3e9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00003ea0 <__pow5mult>:
    3ea0:	f012 0303 	ands.w	r3, r2, #3
    3ea4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3ea8:	4614      	mov	r4, r2
    3eaa:	4607      	mov	r7, r0
    3eac:	d12e      	bne.n	3f0c <__pow5mult+0x6c>
    3eae:	460e      	mov	r6, r1
    3eb0:	10a4      	asrs	r4, r4, #2
    3eb2:	d01c      	beq.n	3eee <__pow5mult+0x4e>
    3eb4:	6cbd      	ldr	r5, [r7, #72]	; 0x48
    3eb6:	b395      	cbz	r5, 3f1e <__pow5mult+0x7e>
    3eb8:	07e3      	lsls	r3, r4, #31
    3eba:	f04f 0800 	mov.w	r8, #0
    3ebe:	d406      	bmi.n	3ece <__pow5mult+0x2e>
    3ec0:	1064      	asrs	r4, r4, #1
    3ec2:	d014      	beq.n	3eee <__pow5mult+0x4e>
    3ec4:	6828      	ldr	r0, [r5, #0]
    3ec6:	b1a8      	cbz	r0, 3ef4 <__pow5mult+0x54>
    3ec8:	4605      	mov	r5, r0
    3eca:	07e3      	lsls	r3, r4, #31
    3ecc:	d5f8      	bpl.n	3ec0 <__pow5mult+0x20>
    3ece:	462a      	mov	r2, r5
    3ed0:	4631      	mov	r1, r6
    3ed2:	4638      	mov	r0, r7
    3ed4:	f7ff ff4c 	bl	3d70 <__multiply>
    3ed8:	b1b6      	cbz	r6, 3f08 <__pow5mult+0x68>
    3eda:	6872      	ldr	r2, [r6, #4]
    3edc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    3ede:	1064      	asrs	r4, r4, #1
    3ee0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    3ee4:	6031      	str	r1, [r6, #0]
    3ee6:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    3eea:	4606      	mov	r6, r0
    3eec:	d1ea      	bne.n	3ec4 <__pow5mult+0x24>
    3eee:	4630      	mov	r0, r6
    3ef0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3ef4:	462a      	mov	r2, r5
    3ef6:	4629      	mov	r1, r5
    3ef8:	4638      	mov	r0, r7
    3efa:	f7ff ff39 	bl	3d70 <__multiply>
    3efe:	6028      	str	r0, [r5, #0]
    3f00:	f8c0 8000 	str.w	r8, [r0]
    3f04:	4605      	mov	r5, r0
    3f06:	e7e0      	b.n	3eca <__pow5mult+0x2a>
    3f08:	4606      	mov	r6, r0
    3f0a:	e7d9      	b.n	3ec0 <__pow5mult+0x20>
    3f0c:	1e5a      	subs	r2, r3, #1
    3f0e:	4d0b      	ldr	r5, [pc, #44]	; (3f3c <__pow5mult+0x9c>)
    3f10:	2300      	movs	r3, #0
    3f12:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
    3f16:	f7ff fe93 	bl	3c40 <__multadd>
    3f1a:	4606      	mov	r6, r0
    3f1c:	e7c8      	b.n	3eb0 <__pow5mult+0x10>
    3f1e:	2101      	movs	r1, #1
    3f20:	4638      	mov	r0, r7
    3f22:	f7ff fe5d 	bl	3be0 <_Balloc>
    3f26:	f240 2171 	movw	r1, #625	; 0x271
    3f2a:	2201      	movs	r2, #1
    3f2c:	2300      	movs	r3, #0
    3f2e:	6141      	str	r1, [r0, #20]
    3f30:	6102      	str	r2, [r0, #16]
    3f32:	4605      	mov	r5, r0
    3f34:	64b8      	str	r0, [r7, #72]	; 0x48
    3f36:	6003      	str	r3, [r0, #0]
    3f38:	e7be      	b.n	3eb8 <__pow5mult+0x18>
    3f3a:	bf00      	nop
    3f3c:	200004b0 	.word	0x200004b0

00003f40 <__lshift>:
    3f40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3f44:	4691      	mov	r9, r2
    3f46:	690a      	ldr	r2, [r1, #16]
    3f48:	688b      	ldr	r3, [r1, #8]
    3f4a:	ea4f 1469 	mov.w	r4, r9, asr #5
    3f4e:	eb04 0802 	add.w	r8, r4, r2
    3f52:	f108 0501 	add.w	r5, r8, #1
    3f56:	429d      	cmp	r5, r3
    3f58:	460e      	mov	r6, r1
    3f5a:	4682      	mov	sl, r0
    3f5c:	6849      	ldr	r1, [r1, #4]
    3f5e:	dd04      	ble.n	3f6a <__lshift+0x2a>
    3f60:	005b      	lsls	r3, r3, #1
    3f62:	429d      	cmp	r5, r3
    3f64:	f101 0101 	add.w	r1, r1, #1
    3f68:	dcfa      	bgt.n	3f60 <__lshift+0x20>
    3f6a:	4650      	mov	r0, sl
    3f6c:	f7ff fe38 	bl	3be0 <_Balloc>
    3f70:	2c00      	cmp	r4, #0
    3f72:	f100 0214 	add.w	r2, r0, #20
    3f76:	dd38      	ble.n	3fea <__lshift+0xaa>
    3f78:	eb02 0384 	add.w	r3, r2, r4, lsl #2
    3f7c:	2100      	movs	r1, #0
    3f7e:	f842 1b04 	str.w	r1, [r2], #4
    3f82:	4293      	cmp	r3, r2
    3f84:	d1fb      	bne.n	3f7e <__lshift+0x3e>
    3f86:	6934      	ldr	r4, [r6, #16]
    3f88:	f106 0114 	add.w	r1, r6, #20
    3f8c:	f019 091f 	ands.w	r9, r9, #31
    3f90:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
    3f94:	d021      	beq.n	3fda <__lshift+0x9a>
    3f96:	f1c9 0220 	rsb	r2, r9, #32
    3f9a:	2400      	movs	r4, #0
    3f9c:	680f      	ldr	r7, [r1, #0]
    3f9e:	fa07 fc09 	lsl.w	ip, r7, r9
    3fa2:	ea4c 0404 	orr.w	r4, ip, r4
    3fa6:	469c      	mov	ip, r3
    3fa8:	f843 4b04 	str.w	r4, [r3], #4
    3fac:	f851 4b04 	ldr.w	r4, [r1], #4
    3fb0:	458e      	cmp	lr, r1
    3fb2:	fa24 f402 	lsr.w	r4, r4, r2
    3fb6:	d8f1      	bhi.n	3f9c <__lshift+0x5c>
    3fb8:	f8cc 4004 	str.w	r4, [ip, #4]
    3fbc:	b10c      	cbz	r4, 3fc2 <__lshift+0x82>
    3fbe:	f108 0502 	add.w	r5, r8, #2
    3fc2:	f8da 304c 	ldr.w	r3, [sl, #76]	; 0x4c
    3fc6:	6872      	ldr	r2, [r6, #4]
    3fc8:	3d01      	subs	r5, #1
    3fca:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    3fce:	6105      	str	r5, [r0, #16]
    3fd0:	6031      	str	r1, [r6, #0]
    3fd2:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
    3fd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3fda:	3b04      	subs	r3, #4
    3fdc:	f851 2b04 	ldr.w	r2, [r1], #4
    3fe0:	f843 2f04 	str.w	r2, [r3, #4]!
    3fe4:	458e      	cmp	lr, r1
    3fe6:	d8f9      	bhi.n	3fdc <__lshift+0x9c>
    3fe8:	e7eb      	b.n	3fc2 <__lshift+0x82>
    3fea:	4613      	mov	r3, r2
    3fec:	e7cb      	b.n	3f86 <__lshift+0x46>
    3fee:	bf00      	nop

00003ff0 <__mcmp>:
    3ff0:	6902      	ldr	r2, [r0, #16]
    3ff2:	690b      	ldr	r3, [r1, #16]
    3ff4:	1ad2      	subs	r2, r2, r3
    3ff6:	d113      	bne.n	4020 <__mcmp+0x30>
    3ff8:	009b      	lsls	r3, r3, #2
    3ffa:	3014      	adds	r0, #20
    3ffc:	3114      	adds	r1, #20
    3ffe:	4419      	add	r1, r3
    4000:	b410      	push	{r4}
    4002:	4403      	add	r3, r0
    4004:	e001      	b.n	400a <__mcmp+0x1a>
    4006:	4298      	cmp	r0, r3
    4008:	d20c      	bcs.n	4024 <__mcmp+0x34>
    400a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
    400e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
    4012:	4294      	cmp	r4, r2
    4014:	d0f7      	beq.n	4006 <__mcmp+0x16>
    4016:	d309      	bcc.n	402c <__mcmp+0x3c>
    4018:	2001      	movs	r0, #1
    401a:	f85d 4b04 	ldr.w	r4, [sp], #4
    401e:	4770      	bx	lr
    4020:	4610      	mov	r0, r2
    4022:	4770      	bx	lr
    4024:	2000      	movs	r0, #0
    4026:	f85d 4b04 	ldr.w	r4, [sp], #4
    402a:	4770      	bx	lr
    402c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    4030:	e7f3      	b.n	401a <__mcmp+0x2a>
    4032:	bf00      	nop

00004034 <__mdiff>:
    4034:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4038:	690b      	ldr	r3, [r1, #16]
    403a:	460f      	mov	r7, r1
    403c:	6911      	ldr	r1, [r2, #16]
    403e:	1a5b      	subs	r3, r3, r1
    4040:	2b00      	cmp	r3, #0
    4042:	4690      	mov	r8, r2
    4044:	d117      	bne.n	4076 <__mdiff+0x42>
    4046:	0089      	lsls	r1, r1, #2
    4048:	f107 0214 	add.w	r2, r7, #20
    404c:	f108 0514 	add.w	r5, r8, #20
    4050:	1853      	adds	r3, r2, r1
    4052:	4429      	add	r1, r5
    4054:	e001      	b.n	405a <__mdiff+0x26>
    4056:	429a      	cmp	r2, r3
    4058:	d25e      	bcs.n	4118 <__mdiff+0xe4>
    405a:	f853 6d04 	ldr.w	r6, [r3, #-4]!
    405e:	f851 4d04 	ldr.w	r4, [r1, #-4]!
    4062:	42a6      	cmp	r6, r4
    4064:	d0f7      	beq.n	4056 <__mdiff+0x22>
    4066:	d260      	bcs.n	412a <__mdiff+0xf6>
    4068:	463b      	mov	r3, r7
    406a:	4614      	mov	r4, r2
    406c:	4647      	mov	r7, r8
    406e:	f04f 0901 	mov.w	r9, #1
    4072:	4698      	mov	r8, r3
    4074:	e006      	b.n	4084 <__mdiff+0x50>
    4076:	db5d      	blt.n	4134 <__mdiff+0x100>
    4078:	f107 0514 	add.w	r5, r7, #20
    407c:	f102 0414 	add.w	r4, r2, #20
    4080:	f04f 0900 	mov.w	r9, #0
    4084:	6879      	ldr	r1, [r7, #4]
    4086:	f7ff fdab 	bl	3be0 <_Balloc>
    408a:	f8d8 3010 	ldr.w	r3, [r8, #16]
    408e:	693e      	ldr	r6, [r7, #16]
    4090:	f8c0 900c 	str.w	r9, [r0, #12]
    4094:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
    4098:	46a6      	mov	lr, r4
    409a:	eb05 0786 	add.w	r7, r5, r6, lsl #2
    409e:	f100 0414 	add.w	r4, r0, #20
    40a2:	2300      	movs	r3, #0
    40a4:	f85e 1b04 	ldr.w	r1, [lr], #4
    40a8:	f855 8b04 	ldr.w	r8, [r5], #4
    40ac:	b28a      	uxth	r2, r1
    40ae:	fa13 f388 	uxtah	r3, r3, r8
    40b2:	0c09      	lsrs	r1, r1, #16
    40b4:	1a9a      	subs	r2, r3, r2
    40b6:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
    40ba:	eb03 4322 	add.w	r3, r3, r2, asr #16
    40be:	b292      	uxth	r2, r2
    40c0:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    40c4:	45f4      	cmp	ip, lr
    40c6:	f844 2b04 	str.w	r2, [r4], #4
    40ca:	ea4f 4323 	mov.w	r3, r3, asr #16
    40ce:	d8e9      	bhi.n	40a4 <__mdiff+0x70>
    40d0:	42af      	cmp	r7, r5
    40d2:	d917      	bls.n	4104 <__mdiff+0xd0>
    40d4:	46a4      	mov	ip, r4
    40d6:	4629      	mov	r1, r5
    40d8:	f851 eb04 	ldr.w	lr, [r1], #4
    40dc:	fa13 f28e 	uxtah	r2, r3, lr
    40e0:	1413      	asrs	r3, r2, #16
    40e2:	eb03 431e 	add.w	r3, r3, lr, lsr #16
    40e6:	b292      	uxth	r2, r2
    40e8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    40ec:	428f      	cmp	r7, r1
    40ee:	f84c 2b04 	str.w	r2, [ip], #4
    40f2:	ea4f 4323 	mov.w	r3, r3, asr #16
    40f6:	d8ef      	bhi.n	40d8 <__mdiff+0xa4>
    40f8:	43ed      	mvns	r5, r5
    40fa:	443d      	add	r5, r7
    40fc:	f025 0503 	bic.w	r5, r5, #3
    4100:	3504      	adds	r5, #4
    4102:	442c      	add	r4, r5
    4104:	3c04      	subs	r4, #4
    4106:	b922      	cbnz	r2, 4112 <__mdiff+0xde>
    4108:	f854 3d04 	ldr.w	r3, [r4, #-4]!
    410c:	3e01      	subs	r6, #1
    410e:	2b00      	cmp	r3, #0
    4110:	d0fa      	beq.n	4108 <__mdiff+0xd4>
    4112:	6106      	str	r6, [r0, #16]
    4114:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4118:	2100      	movs	r1, #0
    411a:	f7ff fd61 	bl	3be0 <_Balloc>
    411e:	2201      	movs	r2, #1
    4120:	2300      	movs	r3, #0
    4122:	6102      	str	r2, [r0, #16]
    4124:	6143      	str	r3, [r0, #20]
    4126:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    412a:	462c      	mov	r4, r5
    412c:	f04f 0900 	mov.w	r9, #0
    4130:	4615      	mov	r5, r2
    4132:	e7a7      	b.n	4084 <__mdiff+0x50>
    4134:	463b      	mov	r3, r7
    4136:	f107 0414 	add.w	r4, r7, #20
    413a:	f108 0514 	add.w	r5, r8, #20
    413e:	4647      	mov	r7, r8
    4140:	f04f 0901 	mov.w	r9, #1
    4144:	4698      	mov	r8, r3
    4146:	e79d      	b.n	4084 <__mdiff+0x50>

00004148 <__d2b>:
    4148:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    414c:	ec57 6b10 	vmov	r6, r7, d0
    4150:	b083      	sub	sp, #12
    4152:	4688      	mov	r8, r1
    4154:	2101      	movs	r1, #1
    4156:	463c      	mov	r4, r7
    4158:	f3c7 550a 	ubfx	r5, r7, #20, #11
    415c:	4617      	mov	r7, r2
    415e:	f7ff fd3f 	bl	3be0 <_Balloc>
    4162:	f3c4 0413 	ubfx	r4, r4, #0, #20
    4166:	4681      	mov	r9, r0
    4168:	b10d      	cbz	r5, 416e <__d2b+0x26>
    416a:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
    416e:	9401      	str	r4, [sp, #4]
    4170:	b31e      	cbz	r6, 41ba <__d2b+0x72>
    4172:	a802      	add	r0, sp, #8
    4174:	f840 6d08 	str.w	r6, [r0, #-8]!
    4178:	f7ff fdc2 	bl	3d00 <__lo0bits>
    417c:	2800      	cmp	r0, #0
    417e:	d134      	bne.n	41ea <__d2b+0xa2>
    4180:	e89d 000c 	ldmia.w	sp, {r2, r3}
    4184:	f8c9 2014 	str.w	r2, [r9, #20]
    4188:	2b00      	cmp	r3, #0
    418a:	bf0c      	ite	eq
    418c:	2101      	moveq	r1, #1
    418e:	2102      	movne	r1, #2
    4190:	f8c9 3018 	str.w	r3, [r9, #24]
    4194:	f8c9 1010 	str.w	r1, [r9, #16]
    4198:	b9dd      	cbnz	r5, 41d2 <__d2b+0x8a>
    419a:	eb09 0381 	add.w	r3, r9, r1, lsl #2
    419e:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
    41a2:	f8c8 0000 	str.w	r0, [r8]
    41a6:	6918      	ldr	r0, [r3, #16]
    41a8:	f7ff fd8a 	bl	3cc0 <__hi0bits>
    41ac:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
    41b0:	6038      	str	r0, [r7, #0]
    41b2:	4648      	mov	r0, r9
    41b4:	b003      	add	sp, #12
    41b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    41ba:	a801      	add	r0, sp, #4
    41bc:	f7ff fda0 	bl	3d00 <__lo0bits>
    41c0:	9b01      	ldr	r3, [sp, #4]
    41c2:	f8c9 3014 	str.w	r3, [r9, #20]
    41c6:	2101      	movs	r1, #1
    41c8:	3020      	adds	r0, #32
    41ca:	f8c9 1010 	str.w	r1, [r9, #16]
    41ce:	2d00      	cmp	r5, #0
    41d0:	d0e3      	beq.n	419a <__d2b+0x52>
    41d2:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
    41d6:	4405      	add	r5, r0
    41d8:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
    41dc:	f8c8 5000 	str.w	r5, [r8]
    41e0:	6038      	str	r0, [r7, #0]
    41e2:	4648      	mov	r0, r9
    41e4:	b003      	add	sp, #12
    41e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    41ea:	e89d 000c 	ldmia.w	sp, {r2, r3}
    41ee:	f1c0 0120 	rsb	r1, r0, #32
    41f2:	fa03 f101 	lsl.w	r1, r3, r1
    41f6:	430a      	orrs	r2, r1
    41f8:	40c3      	lsrs	r3, r0
    41fa:	9301      	str	r3, [sp, #4]
    41fc:	f8c9 2014 	str.w	r2, [r9, #20]
    4200:	e7c2      	b.n	4188 <__d2b+0x40>
    4202:	bf00      	nop

00004204 <_vasnprintf_r>:
    4204:	b570      	push	{r4, r5, r6, lr}
    4206:	4615      	mov	r5, r2
    4208:	b09a      	sub	sp, #104	; 0x68
    420a:	6814      	ldr	r4, [r2, #0]
    420c:	b109      	cbz	r1, 4212 <_vasnprintf_r+0xe>
    420e:	2c00      	cmp	r4, #0
    4210:	d11a      	bne.n	4248 <_vasnprintf_r+0x44>
    4212:	2400      	movs	r4, #0
    4214:	f44f 7222 	mov.w	r2, #648	; 0x288
    4218:	f8ad 200c 	strh.w	r2, [sp, #12]
    421c:	9400      	str	r4, [sp, #0]
    421e:	9404      	str	r4, [sp, #16]
    4220:	461a      	mov	r2, r3
    4222:	f64f 76ff 	movw	r6, #65535	; 0xffff
    4226:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    4228:	9402      	str	r4, [sp, #8]
    422a:	4669      	mov	r1, sp
    422c:	9405      	str	r4, [sp, #20]
    422e:	f8ad 600e 	strh.w	r6, [sp, #14]
    4232:	f000 ff21 	bl	5078 <_svfprintf_r>
    4236:	2800      	cmp	r0, #0
    4238:	db11      	blt.n	425e <_vasnprintf_r+0x5a>
    423a:	9b00      	ldr	r3, [sp, #0]
    423c:	6028      	str	r0, [r5, #0]
    423e:	2200      	movs	r2, #0
    4240:	701a      	strb	r2, [r3, #0]
    4242:	9804      	ldr	r0, [sp, #16]
    4244:	b01a      	add	sp, #104	; 0x68
    4246:	bd70      	pop	{r4, r5, r6, pc}
    4248:	f44f 62c1 	mov.w	r2, #1544	; 0x608
    424c:	9100      	str	r1, [sp, #0]
    424e:	9104      	str	r1, [sp, #16]
    4250:	f8ad 200c 	strh.w	r2, [sp, #12]
    4254:	dae4      	bge.n	4220 <_vasnprintf_r+0x1c>
    4256:	238b      	movs	r3, #139	; 0x8b
    4258:	6003      	str	r3, [r0, #0]
    425a:	2000      	movs	r0, #0
    425c:	e7f2      	b.n	4244 <_vasnprintf_r+0x40>
    425e:	2000      	movs	r0, #0
    4260:	e7f0      	b.n	4244 <_vasnprintf_r+0x40>
    4262:	bf00      	nop

00004264 <_calloc_r>:
    4264:	b510      	push	{r4, lr}
    4266:	fb02 f101 	mul.w	r1, r2, r1
    426a:	f7fe fb43 	bl	28f4 <_malloc_r>
    426e:	4604      	mov	r4, r0
    4270:	b1d8      	cbz	r0, 42aa <_calloc_r+0x46>
    4272:	f850 2c04 	ldr.w	r2, [r0, #-4]
    4276:	f022 0203 	bic.w	r2, r2, #3
    427a:	3a04      	subs	r2, #4
    427c:	2a24      	cmp	r2, #36	; 0x24
    427e:	d818      	bhi.n	42b2 <_calloc_r+0x4e>
    4280:	2a13      	cmp	r2, #19
    4282:	d914      	bls.n	42ae <_calloc_r+0x4a>
    4284:	2300      	movs	r3, #0
    4286:	2a1b      	cmp	r2, #27
    4288:	6003      	str	r3, [r0, #0]
    428a:	6043      	str	r3, [r0, #4]
    428c:	d916      	bls.n	42bc <_calloc_r+0x58>
    428e:	2a24      	cmp	r2, #36	; 0x24
    4290:	6083      	str	r3, [r0, #8]
    4292:	60c3      	str	r3, [r0, #12]
    4294:	bf11      	iteee	ne
    4296:	f100 0210 	addne.w	r2, r0, #16
    429a:	6103      	streq	r3, [r0, #16]
    429c:	6143      	streq	r3, [r0, #20]
    429e:	f100 0218 	addeq.w	r2, r0, #24
    42a2:	2300      	movs	r3, #0
    42a4:	6013      	str	r3, [r2, #0]
    42a6:	6053      	str	r3, [r2, #4]
    42a8:	6093      	str	r3, [r2, #8]
    42aa:	4620      	mov	r0, r4
    42ac:	bd10      	pop	{r4, pc}
    42ae:	4602      	mov	r2, r0
    42b0:	e7f7      	b.n	42a2 <_calloc_r+0x3e>
    42b2:	2100      	movs	r1, #0
    42b4:	f7fe feea 	bl	308c <memset>
    42b8:	4620      	mov	r0, r4
    42ba:	bd10      	pop	{r4, pc}
    42bc:	f100 0208 	add.w	r2, r0, #8
    42c0:	e7ef      	b.n	42a2 <_calloc_r+0x3e>
    42c2:	bf00      	nop

000042c4 <quorem>:
    42c4:	6902      	ldr	r2, [r0, #16]
    42c6:	690b      	ldr	r3, [r1, #16]
    42c8:	4293      	cmp	r3, r2
    42ca:	f300 808d 	bgt.w	43e8 <quorem+0x124>
    42ce:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    42d2:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    42d6:	f101 0714 	add.w	r7, r1, #20
    42da:	f100 0b14 	add.w	fp, r0, #20
    42de:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
    42e2:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
    42e6:	ea4f 0488 	mov.w	r4, r8, lsl #2
    42ea:	b083      	sub	sp, #12
    42ec:	3201      	adds	r2, #1
    42ee:	fbb3 f9f2 	udiv	r9, r3, r2
    42f2:	eb0b 0304 	add.w	r3, fp, r4
    42f6:	9400      	str	r4, [sp, #0]
    42f8:	eb07 0a04 	add.w	sl, r7, r4
    42fc:	9301      	str	r3, [sp, #4]
    42fe:	f1b9 0f00 	cmp.w	r9, #0
    4302:	d039      	beq.n	4378 <quorem+0xb4>
    4304:	2500      	movs	r5, #0
    4306:	46bc      	mov	ip, r7
    4308:	46de      	mov	lr, fp
    430a:	462b      	mov	r3, r5
    430c:	f85c 6b04 	ldr.w	r6, [ip], #4
    4310:	f8de 2000 	ldr.w	r2, [lr]
    4314:	b2b4      	uxth	r4, r6
    4316:	fb09 5504 	mla	r5, r9, r4, r5
    431a:	0c36      	lsrs	r6, r6, #16
    431c:	0c2c      	lsrs	r4, r5, #16
    431e:	fb09 4406 	mla	r4, r9, r6, r4
    4322:	b2ad      	uxth	r5, r5
    4324:	1b5b      	subs	r3, r3, r5
    4326:	b2a6      	uxth	r6, r4
    4328:	fa13 f382 	uxtah	r3, r3, r2
    432c:	ebc6 4612 	rsb	r6, r6, r2, lsr #16
    4330:	eb06 4623 	add.w	r6, r6, r3, asr #16
    4334:	b29b      	uxth	r3, r3
    4336:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
    433a:	45e2      	cmp	sl, ip
    433c:	f84e 3b04 	str.w	r3, [lr], #4
    4340:	ea4f 4514 	mov.w	r5, r4, lsr #16
    4344:	ea4f 4326 	mov.w	r3, r6, asr #16
    4348:	d2e0      	bcs.n	430c <quorem+0x48>
    434a:	9b00      	ldr	r3, [sp, #0]
    434c:	f85b 3003 	ldr.w	r3, [fp, r3]
    4350:	b993      	cbnz	r3, 4378 <quorem+0xb4>
    4352:	9c01      	ldr	r4, [sp, #4]
    4354:	1f23      	subs	r3, r4, #4
    4356:	459b      	cmp	fp, r3
    4358:	d20c      	bcs.n	4374 <quorem+0xb0>
    435a:	f854 3c04 	ldr.w	r3, [r4, #-4]
    435e:	b94b      	cbnz	r3, 4374 <quorem+0xb0>
    4360:	f1a4 0308 	sub.w	r3, r4, #8
    4364:	e002      	b.n	436c <quorem+0xa8>
    4366:	681a      	ldr	r2, [r3, #0]
    4368:	3b04      	subs	r3, #4
    436a:	b91a      	cbnz	r2, 4374 <quorem+0xb0>
    436c:	459b      	cmp	fp, r3
    436e:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    4372:	d3f8      	bcc.n	4366 <quorem+0xa2>
    4374:	f8c0 8010 	str.w	r8, [r0, #16]
    4378:	4604      	mov	r4, r0
    437a:	f7ff fe39 	bl	3ff0 <__mcmp>
    437e:	2800      	cmp	r0, #0
    4380:	db2e      	blt.n	43e0 <quorem+0x11c>
    4382:	f109 0901 	add.w	r9, r9, #1
    4386:	465d      	mov	r5, fp
    4388:	2300      	movs	r3, #0
    438a:	f857 1b04 	ldr.w	r1, [r7], #4
    438e:	6828      	ldr	r0, [r5, #0]
    4390:	b28a      	uxth	r2, r1
    4392:	1a9a      	subs	r2, r3, r2
    4394:	0c09      	lsrs	r1, r1, #16
    4396:	fa12 f280 	uxtah	r2, r2, r0
    439a:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
    439e:	eb03 4322 	add.w	r3, r3, r2, asr #16
    43a2:	b291      	uxth	r1, r2
    43a4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    43a8:	45ba      	cmp	sl, r7
    43aa:	f845 1b04 	str.w	r1, [r5], #4
    43ae:	ea4f 4323 	mov.w	r3, r3, asr #16
    43b2:	d2ea      	bcs.n	438a <quorem+0xc6>
    43b4:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
    43b8:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
    43bc:	b982      	cbnz	r2, 43e0 <quorem+0x11c>
    43be:	1f1a      	subs	r2, r3, #4
    43c0:	4593      	cmp	fp, r2
    43c2:	d20b      	bcs.n	43dc <quorem+0x118>
    43c4:	f853 2c04 	ldr.w	r2, [r3, #-4]
    43c8:	b942      	cbnz	r2, 43dc <quorem+0x118>
    43ca:	3b08      	subs	r3, #8
    43cc:	e002      	b.n	43d4 <quorem+0x110>
    43ce:	681a      	ldr	r2, [r3, #0]
    43d0:	3b04      	subs	r3, #4
    43d2:	b91a      	cbnz	r2, 43dc <quorem+0x118>
    43d4:	459b      	cmp	fp, r3
    43d6:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    43da:	d3f8      	bcc.n	43ce <quorem+0x10a>
    43dc:	f8c4 8010 	str.w	r8, [r4, #16]
    43e0:	4648      	mov	r0, r9
    43e2:	b003      	add	sp, #12
    43e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    43e8:	2000      	movs	r0, #0
    43ea:	4770      	bx	lr
    43ec:	0000      	movs	r0, r0
	...

000043f0 <_dtoa_r>:
    43f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    43f4:	ec57 6b10 	vmov	r6, r7, d0
    43f8:	b093      	sub	sp, #76	; 0x4c
    43fa:	6c05      	ldr	r5, [r0, #64]	; 0x40
    43fc:	9101      	str	r1, [sp, #4]
    43fe:	4604      	mov	r4, r0
    4400:	4690      	mov	r8, r2
    4402:	9304      	str	r3, [sp, #16]
    4404:	ee10 aa10 	vmov	sl, s0
    4408:	46bb      	mov	fp, r7
    440a:	b14d      	cbz	r5, 4420 <_dtoa_r+0x30>
    440c:	6c42      	ldr	r2, [r0, #68]	; 0x44
    440e:	606a      	str	r2, [r5, #4]
    4410:	2301      	movs	r3, #1
    4412:	4093      	lsls	r3, r2
    4414:	60ab      	str	r3, [r5, #8]
    4416:	4629      	mov	r1, r5
    4418:	f7ff fc08 	bl	3c2c <_Bfree>
    441c:	2300      	movs	r3, #0
    441e:	6423      	str	r3, [r4, #64]	; 0x40
    4420:	f1bb 0f00 	cmp.w	fp, #0
    4424:	465e      	mov	r6, fp
    4426:	db34      	blt.n	4492 <_dtoa_r+0xa2>
    4428:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    442a:	2300      	movs	r3, #0
    442c:	6013      	str	r3, [r2, #0]
    442e:	4bc4      	ldr	r3, [pc, #784]	; (4740 <_dtoa_r+0x350>)
    4430:	461a      	mov	r2, r3
    4432:	4033      	ands	r3, r6
    4434:	4293      	cmp	r3, r2
    4436:	d015      	beq.n	4464 <_dtoa_r+0x74>
    4438:	ec4b ab17 	vmov	d7, sl, fp
    443c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    4440:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4444:	e9cd ab02 	strd	sl, fp, [sp, #8]
    4448:	d12a      	bne.n	44a0 <_dtoa_r+0xb0>
    444a:	9a04      	ldr	r2, [sp, #16]
    444c:	2301      	movs	r3, #1
    444e:	6013      	str	r3, [r2, #0]
    4450:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    4452:	2b00      	cmp	r3, #0
    4454:	f000 80b7 	beq.w	45c6 <_dtoa_r+0x1d6>
    4458:	48ba      	ldr	r0, [pc, #744]	; (4744 <_dtoa_r+0x354>)
    445a:	6018      	str	r0, [r3, #0]
    445c:	3801      	subs	r0, #1
    445e:	b013      	add	sp, #76	; 0x4c
    4460:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4464:	9a04      	ldr	r2, [sp, #16]
    4466:	f242 730f 	movw	r3, #9999	; 0x270f
    446a:	6013      	str	r3, [r2, #0]
    446c:	f1ba 0f00 	cmp.w	sl, #0
    4470:	f000 8092 	beq.w	4598 <_dtoa_r+0x1a8>
    4474:	48b4      	ldr	r0, [pc, #720]	; (4748 <_dtoa_r+0x358>)
    4476:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    4478:	2b00      	cmp	r3, #0
    447a:	d0f0      	beq.n	445e <_dtoa_r+0x6e>
    447c:	78c3      	ldrb	r3, [r0, #3]
    447e:	2b00      	cmp	r3, #0
    4480:	f000 80a3 	beq.w	45ca <_dtoa_r+0x1da>
    4484:	f100 0308 	add.w	r3, r0, #8
    4488:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    448a:	6013      	str	r3, [r2, #0]
    448c:	b013      	add	sp, #76	; 0x4c
    448e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4492:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    4494:	2301      	movs	r3, #1
    4496:	f02b 4600 	bic.w	r6, fp, #2147483648	; 0x80000000
    449a:	6013      	str	r3, [r2, #0]
    449c:	46b3      	mov	fp, r6
    449e:	e7c6      	b.n	442e <_dtoa_r+0x3e>
    44a0:	a911      	add	r1, sp, #68	; 0x44
    44a2:	aa10      	add	r2, sp, #64	; 0x40
    44a4:	ed9d 0b02 	vldr	d0, [sp, #8]
    44a8:	4620      	mov	r0, r4
    44aa:	f7ff fe4d 	bl	4148 <__d2b>
    44ae:	0d31      	lsrs	r1, r6, #20
    44b0:	9007      	str	r0, [sp, #28]
    44b2:	d17a      	bne.n	45aa <_dtoa_r+0x1ba>
    44b4:	9810      	ldr	r0, [sp, #64]	; 0x40
    44b6:	9911      	ldr	r1, [sp, #68]	; 0x44
    44b8:	4401      	add	r1, r0
    44ba:	f201 4332 	addw	r3, r1, #1074	; 0x432
    44be:	2b20      	cmp	r3, #32
    44c0:	f340 8241 	ble.w	4946 <_dtoa_r+0x556>
    44c4:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
    44c8:	f201 4212 	addw	r2, r1, #1042	; 0x412
    44cc:	409e      	lsls	r6, r3
    44ce:	fa2a f302 	lsr.w	r3, sl, r2
    44d2:	4333      	orrs	r3, r6
    44d4:	ee07 3a90 	vmov	s15, r3
    44d8:	eeb8 7b67 	vcvt.f64.u32	d7, s15
    44dc:	2501      	movs	r5, #1
    44de:	ec53 2b17 	vmov	r2, r3, d7
    44e2:	3901      	subs	r1, #1
    44e4:	f1a3 73f8 	sub.w	r3, r3, #32505856	; 0x1f00000
    44e8:	950a      	str	r5, [sp, #40]	; 0x28
    44ea:	ec43 2b17 	vmov	d7, r2, r3
    44ee:	eeb7 6b08 	vmov.f64	d6, #120	; 0x3fc00000  1.5
    44f2:	ed9f 4b8d 	vldr	d4, [pc, #564]	; 4728 <_dtoa_r+0x338>
    44f6:	ee37 6b46 	vsub.f64	d6, d7, d6
    44fa:	ed9f 7b8d 	vldr	d7, [pc, #564]	; 4730 <_dtoa_r+0x340>
    44fe:	ed9f 5b8e 	vldr	d5, [pc, #568]	; 4738 <_dtoa_r+0x348>
    4502:	eea6 7b04 	vfma.f64	d7, d6, d4
    4506:	ee06 1a90 	vmov	s13, r1
    450a:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    450e:	eea6 7b05 	vfma.f64	d7, d6, d5
    4512:	eefd 6bc7 	vcvt.s32.f64	s13, d7
    4516:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
    451a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    451e:	edcd 6a02 	vstr	s13, [sp, #8]
    4522:	f100 811c 	bmi.w	475e <_dtoa_r+0x36e>
    4526:	9d02      	ldr	r5, [sp, #8]
    4528:	2d16      	cmp	r5, #22
    452a:	f200 8115 	bhi.w	4758 <_dtoa_r+0x368>
    452e:	4b87      	ldr	r3, [pc, #540]	; (474c <_dtoa_r+0x35c>)
    4530:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    4534:	ed93 7b00 	vldr	d7, [r3]
    4538:	ec4b ab16 	vmov	d6, sl, fp
    453c:	eeb4 7bc6 	vcmpe.f64	d7, d6
    4540:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4544:	f340 8206 	ble.w	4954 <_dtoa_r+0x564>
    4548:	1e6b      	subs	r3, r5, #1
    454a:	9302      	str	r3, [sp, #8]
    454c:	2300      	movs	r3, #0
    454e:	930c      	str	r3, [sp, #48]	; 0x30
    4550:	1a41      	subs	r1, r0, r1
    4552:	f1b1 0901 	subs.w	r9, r1, #1
    4556:	f100 8117 	bmi.w	4788 <_dtoa_r+0x398>
    455a:	2300      	movs	r3, #0
    455c:	9306      	str	r3, [sp, #24]
    455e:	9b02      	ldr	r3, [sp, #8]
    4560:	2b00      	cmp	r3, #0
    4562:	f2c0 8108 	blt.w	4776 <_dtoa_r+0x386>
    4566:	4499      	add	r9, r3
    4568:	930b      	str	r3, [sp, #44]	; 0x2c
    456a:	2300      	movs	r3, #0
    456c:	9305      	str	r3, [sp, #20]
    456e:	9b01      	ldr	r3, [sp, #4]
    4570:	2b09      	cmp	r3, #9
    4572:	d82c      	bhi.n	45ce <_dtoa_r+0x1de>
    4574:	2b05      	cmp	r3, #5
    4576:	f340 855f 	ble.w	5038 <_dtoa_r+0xc48>
    457a:	3b04      	subs	r3, #4
    457c:	9301      	str	r3, [sp, #4]
    457e:	2300      	movs	r3, #0
    4580:	930e      	str	r3, [sp, #56]	; 0x38
    4582:	9b01      	ldr	r3, [sp, #4]
    4584:	3b02      	subs	r3, #2
    4586:	2b03      	cmp	r3, #3
    4588:	f200 855f 	bhi.w	504a <_dtoa_r+0xc5a>
    458c:	e8df f013 	tbh	[pc, r3, lsl #1]
    4590:	01e502a9 	.word	0x01e502a9
    4594:	03c802b5 	.word	0x03c802b5
    4598:	4b6b      	ldr	r3, [pc, #428]	; (4748 <_dtoa_r+0x358>)
    459a:	4a6d      	ldr	r2, [pc, #436]	; (4750 <_dtoa_r+0x360>)
    459c:	f3c6 0013 	ubfx	r0, r6, #0, #20
    45a0:	2800      	cmp	r0, #0
    45a2:	bf14      	ite	ne
    45a4:	4618      	movne	r0, r3
    45a6:	4610      	moveq	r0, r2
    45a8:	e765      	b.n	4476 <_dtoa_r+0x86>
    45aa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    45ae:	f3c3 0013 	ubfx	r0, r3, #0, #20
    45b2:	f040 537f 	orr.w	r3, r0, #1069547520	; 0x3fc00000
    45b6:	2500      	movs	r5, #0
    45b8:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
    45bc:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
    45c0:	9810      	ldr	r0, [sp, #64]	; 0x40
    45c2:	950a      	str	r5, [sp, #40]	; 0x28
    45c4:	e791      	b.n	44ea <_dtoa_r+0xfa>
    45c6:	4863      	ldr	r0, [pc, #396]	; (4754 <_dtoa_r+0x364>)
    45c8:	e749      	b.n	445e <_dtoa_r+0x6e>
    45ca:	1cc3      	adds	r3, r0, #3
    45cc:	e75c      	b.n	4488 <_dtoa_r+0x98>
    45ce:	2100      	movs	r1, #0
    45d0:	6461      	str	r1, [r4, #68]	; 0x44
    45d2:	4620      	mov	r0, r4
    45d4:	4688      	mov	r8, r1
    45d6:	9101      	str	r1, [sp, #4]
    45d8:	f7ff fb02 	bl	3be0 <_Balloc>
    45dc:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    45e0:	2301      	movs	r3, #1
    45e2:	9008      	str	r0, [sp, #32]
    45e4:	6420      	str	r0, [r4, #64]	; 0x40
    45e6:	970d      	str	r7, [sp, #52]	; 0x34
    45e8:	9309      	str	r3, [sp, #36]	; 0x24
    45ea:	9b11      	ldr	r3, [sp, #68]	; 0x44
    45ec:	2b00      	cmp	r3, #0
    45ee:	db7a      	blt.n	46e6 <_dtoa_r+0x2f6>
    45f0:	9a02      	ldr	r2, [sp, #8]
    45f2:	2a0e      	cmp	r2, #14
    45f4:	dc77      	bgt.n	46e6 <_dtoa_r+0x2f6>
    45f6:	4b55      	ldr	r3, [pc, #340]	; (474c <_dtoa_r+0x35c>)
    45f8:	f1b8 0f00 	cmp.w	r8, #0
    45fc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    4600:	ed93 4b00 	vldr	d4, [r3]
    4604:	f2c0 8284 	blt.w	4b10 <_dtoa_r+0x720>
    4608:	eeb1 2b44 	vneg.f64	d2, d4
    460c:	ec4b ab17 	vmov	d7, sl, fp
    4610:	ee87 6b04 	vdiv.f64	d6, d7, d4
    4614:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    4618:	9a08      	ldr	r2, [sp, #32]
    461a:	ee16 3a10 	vmov	r3, s12
    461e:	2f01      	cmp	r7, #1
    4620:	f103 0330 	add.w	r3, r3, #48	; 0x30
    4624:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    4628:	f102 0b01 	add.w	fp, r2, #1
    462c:	7013      	strb	r3, [r2, #0]
    462e:	eea2 7b05 	vfma.f64	d7, d2, d5
    4632:	d022      	beq.n	467a <_dtoa_r+0x28a>
    4634:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
    4638:	ee27 7b03 	vmul.f64	d7, d7, d3
    463c:	eeb5 7b40 	vcmp.f64	d7, #0.0
    4640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4644:	d03a      	beq.n	46bc <_dtoa_r+0x2cc>
    4646:	9a08      	ldr	r2, [sp, #32]
    4648:	e006      	b.n	4658 <_dtoa_r+0x268>
    464a:	ee27 7b03 	vmul.f64	d7, d7, d3
    464e:	eeb5 7b40 	vcmp.f64	d7, #0.0
    4652:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4656:	d031      	beq.n	46bc <_dtoa_r+0x2cc>
    4658:	ee87 6b04 	vdiv.f64	d6, d7, d4
    465c:	eebd 6bc6 	vcvt.s32.f64	s12, d6
    4660:	ee16 3a10 	vmov	r3, s12
    4664:	3330      	adds	r3, #48	; 0x30
    4666:	f80b 3b01 	strb.w	r3, [fp], #1
    466a:	ebc2 030b 	rsb	r3, r2, fp
    466e:	42bb      	cmp	r3, r7
    4670:	eeb8 5bc6 	vcvt.f64.s32	d5, s12
    4674:	eea2 7b05 	vfma.f64	d7, d2, d5
    4678:	d1e7      	bne.n	464a <_dtoa_r+0x25a>
    467a:	ee37 7b07 	vadd.f64	d7, d7, d7
    467e:	eeb4 4bc7 	vcmpe.f64	d4, d7
    4682:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4686:	d408      	bmi.n	469a <_dtoa_r+0x2aa>
    4688:	eeb4 4b47 	vcmp.f64	d4, d7
    468c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4690:	d114      	bne.n	46bc <_dtoa_r+0x2cc>
    4692:	ee16 3a10 	vmov	r3, s12
    4696:	07db      	lsls	r3, r3, #31
    4698:	d510      	bpl.n	46bc <_dtoa_r+0x2cc>
    469a:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    469e:	9a08      	ldr	r2, [sp, #32]
    46a0:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    46a4:	e004      	b.n	46b0 <_dtoa_r+0x2c0>
    46a6:	429a      	cmp	r2, r3
    46a8:	f000 83e5 	beq.w	4e76 <_dtoa_r+0xa86>
    46ac:	f813 0d01 	ldrb.w	r0, [r3, #-1]!
    46b0:	2839      	cmp	r0, #57	; 0x39
    46b2:	f103 0b01 	add.w	fp, r3, #1
    46b6:	d0f6      	beq.n	46a6 <_dtoa_r+0x2b6>
    46b8:	3001      	adds	r0, #1
    46ba:	7018      	strb	r0, [r3, #0]
    46bc:	9907      	ldr	r1, [sp, #28]
    46be:	4620      	mov	r0, r4
    46c0:	f7ff fab4 	bl	3c2c <_Bfree>
    46c4:	2200      	movs	r2, #0
    46c6:	9b02      	ldr	r3, [sp, #8]
    46c8:	f88b 2000 	strb.w	r2, [fp]
    46cc:	9a04      	ldr	r2, [sp, #16]
    46ce:	3301      	adds	r3, #1
    46d0:	6013      	str	r3, [r2, #0]
    46d2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    46d4:	2b00      	cmp	r3, #0
    46d6:	f000 8366 	beq.w	4da6 <_dtoa_r+0x9b6>
    46da:	9808      	ldr	r0, [sp, #32]
    46dc:	f8c3 b000 	str.w	fp, [r3]
    46e0:	b013      	add	sp, #76	; 0x4c
    46e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    46e6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    46e8:	2a00      	cmp	r2, #0
    46ea:	d053      	beq.n	4794 <_dtoa_r+0x3a4>
    46ec:	9a01      	ldr	r2, [sp, #4]
    46ee:	2a01      	cmp	r2, #1
    46f0:	f340 822e 	ble.w	4b50 <_dtoa_r+0x760>
    46f4:	9905      	ldr	r1, [sp, #20]
    46f6:	1e7a      	subs	r2, r7, #1
    46f8:	4291      	cmp	r1, r2
    46fa:	f2c0 8357 	blt.w	4dac <_dtoa_r+0x9bc>
    46fe:	1a8b      	subs	r3, r1, r2
    4700:	930e      	str	r3, [sp, #56]	; 0x38
    4702:	2f00      	cmp	r7, #0
    4704:	9b06      	ldr	r3, [sp, #24]
    4706:	f2c0 8424 	blt.w	4f52 <_dtoa_r+0xb62>
    470a:	930a      	str	r3, [sp, #40]	; 0x28
    470c:	463b      	mov	r3, r7
    470e:	9a06      	ldr	r2, [sp, #24]
    4710:	2101      	movs	r1, #1
    4712:	441a      	add	r2, r3
    4714:	4620      	mov	r0, r4
    4716:	9206      	str	r2, [sp, #24]
    4718:	4499      	add	r9, r3
    471a:	f7ff fb1f 	bl	3d5c <__i2b>
    471e:	4606      	mov	r6, r0
    4720:	e03d      	b.n	479e <_dtoa_r+0x3ae>
    4722:	bf00      	nop
    4724:	f3af 8000 	nop.w
    4728:	636f4361 	.word	0x636f4361
    472c:	3fd287a7 	.word	0x3fd287a7
    4730:	8b60c8b3 	.word	0x8b60c8b3
    4734:	3fc68a28 	.word	0x3fc68a28
    4738:	509f79fb 	.word	0x509f79fb
    473c:	3fd34413 	.word	0x3fd34413
    4740:	7ff00000 	.word	0x7ff00000
    4744:	20000705 	.word	0x20000705
    4748:	20000700 	.word	0x20000700
    474c:	200002a8 	.word	0x200002a8
    4750:	200006f4 	.word	0x200006f4
    4754:	20000704 	.word	0x20000704
    4758:	2301      	movs	r3, #1
    475a:	930c      	str	r3, [sp, #48]	; 0x30
    475c:	e6f8      	b.n	4550 <_dtoa_r+0x160>
    475e:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    4762:	eeb4 7b46 	vcmp.f64	d7, d6
    4766:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    476a:	f43f aedc 	beq.w	4526 <_dtoa_r+0x136>
    476e:	9b02      	ldr	r3, [sp, #8]
    4770:	3b01      	subs	r3, #1
    4772:	9302      	str	r3, [sp, #8]
    4774:	e6d7      	b.n	4526 <_dtoa_r+0x136>
    4776:	9a06      	ldr	r2, [sp, #24]
    4778:	9b02      	ldr	r3, [sp, #8]
    477a:	1ad2      	subs	r2, r2, r3
    477c:	425b      	negs	r3, r3
    477e:	9305      	str	r3, [sp, #20]
    4780:	2300      	movs	r3, #0
    4782:	9206      	str	r2, [sp, #24]
    4784:	930b      	str	r3, [sp, #44]	; 0x2c
    4786:	e6f2      	b.n	456e <_dtoa_r+0x17e>
    4788:	f1c9 0300 	rsb	r3, r9, #0
    478c:	9306      	str	r3, [sp, #24]
    478e:	f04f 0900 	mov.w	r9, #0
    4792:	e6e4      	b.n	455e <_dtoa_r+0x16e>
    4794:	9b05      	ldr	r3, [sp, #20]
    4796:	930e      	str	r3, [sp, #56]	; 0x38
    4798:	9e09      	ldr	r6, [sp, #36]	; 0x24
    479a:	9b06      	ldr	r3, [sp, #24]
    479c:	930a      	str	r3, [sp, #40]	; 0x28
    479e:	990a      	ldr	r1, [sp, #40]	; 0x28
    47a0:	460b      	mov	r3, r1
    47a2:	b161      	cbz	r1, 47be <_dtoa_r+0x3ce>
    47a4:	f1b9 0f00 	cmp.w	r9, #0
    47a8:	dd09      	ble.n	47be <_dtoa_r+0x3ce>
    47aa:	4549      	cmp	r1, r9
    47ac:	9a06      	ldr	r2, [sp, #24]
    47ae:	bfa8      	it	ge
    47b0:	464b      	movge	r3, r9
    47b2:	1ad2      	subs	r2, r2, r3
    47b4:	9206      	str	r2, [sp, #24]
    47b6:	1aca      	subs	r2, r1, r3
    47b8:	920a      	str	r2, [sp, #40]	; 0x28
    47ba:	ebc3 0909 	rsb	r9, r3, r9
    47be:	9b05      	ldr	r3, [sp, #20]
    47c0:	2b00      	cmp	r3, #0
    47c2:	f340 8280 	ble.w	4cc6 <_dtoa_r+0x8d6>
    47c6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    47c8:	2a00      	cmp	r2, #0
    47ca:	f000 819a 	beq.w	4b02 <_dtoa_r+0x712>
    47ce:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    47d0:	2a00      	cmp	r2, #0
    47d2:	f000 8196 	beq.w	4b02 <_dtoa_r+0x712>
    47d6:	4631      	mov	r1, r6
    47d8:	4620      	mov	r0, r4
    47da:	f7ff fb61 	bl	3ea0 <__pow5mult>
    47de:	9a07      	ldr	r2, [sp, #28]
    47e0:	4601      	mov	r1, r0
    47e2:	4606      	mov	r6, r0
    47e4:	4620      	mov	r0, r4
    47e6:	f7ff fac3 	bl	3d70 <__multiply>
    47ea:	9907      	ldr	r1, [sp, #28]
    47ec:	4605      	mov	r5, r0
    47ee:	4620      	mov	r0, r4
    47f0:	f7ff fa1c 	bl	3c2c <_Bfree>
    47f4:	9b05      	ldr	r3, [sp, #20]
    47f6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    47f8:	1a9b      	subs	r3, r3, r2
    47fa:	9305      	str	r3, [sp, #20]
    47fc:	f040 8180 	bne.w	4b00 <_dtoa_r+0x710>
    4800:	2101      	movs	r1, #1
    4802:	4620      	mov	r0, r4
    4804:	f7ff faaa 	bl	3d5c <__i2b>
    4808:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    480a:	9005      	str	r0, [sp, #20]
    480c:	2b00      	cmp	r3, #0
    480e:	f000 81ac 	beq.w	4b6a <_dtoa_r+0x77a>
    4812:	4601      	mov	r1, r0
    4814:	461a      	mov	r2, r3
    4816:	4620      	mov	r0, r4
    4818:	f7ff fb42 	bl	3ea0 <__pow5mult>
    481c:	9b01      	ldr	r3, [sp, #4]
    481e:	9005      	str	r0, [sp, #20]
    4820:	2b01      	cmp	r3, #1
    4822:	f340 8280 	ble.w	4d26 <_dtoa_r+0x936>
    4826:	2300      	movs	r3, #0
    4828:	9307      	str	r3, [sp, #28]
    482a:	9a05      	ldr	r2, [sp, #20]
    482c:	6913      	ldr	r3, [r2, #16]
    482e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    4832:	6918      	ldr	r0, [r3, #16]
    4834:	f7ff fa44 	bl	3cc0 <__hi0bits>
    4838:	f1c0 0020 	rsb	r0, r0, #32
    483c:	4448      	add	r0, r9
    483e:	f010 001f 	ands.w	r0, r0, #31
    4842:	f000 8190 	beq.w	4b66 <_dtoa_r+0x776>
    4846:	f1c0 0320 	rsb	r3, r0, #32
    484a:	2b04      	cmp	r3, #4
    484c:	f340 83f8 	ble.w	5040 <_dtoa_r+0xc50>
    4850:	f1c0 001c 	rsb	r0, r0, #28
    4854:	9b06      	ldr	r3, [sp, #24]
    4856:	4403      	add	r3, r0
    4858:	9306      	str	r3, [sp, #24]
    485a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    485c:	4403      	add	r3, r0
    485e:	930a      	str	r3, [sp, #40]	; 0x28
    4860:	4481      	add	r9, r0
    4862:	9b06      	ldr	r3, [sp, #24]
    4864:	2b00      	cmp	r3, #0
    4866:	dd05      	ble.n	4874 <_dtoa_r+0x484>
    4868:	4629      	mov	r1, r5
    486a:	461a      	mov	r2, r3
    486c:	4620      	mov	r0, r4
    486e:	f7ff fb67 	bl	3f40 <__lshift>
    4872:	4605      	mov	r5, r0
    4874:	f1b9 0f00 	cmp.w	r9, #0
    4878:	dd05      	ble.n	4886 <_dtoa_r+0x496>
    487a:	464a      	mov	r2, r9
    487c:	9905      	ldr	r1, [sp, #20]
    487e:	4620      	mov	r0, r4
    4880:	f7ff fb5e 	bl	3f40 <__lshift>
    4884:	9005      	str	r0, [sp, #20]
    4886:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4888:	2b00      	cmp	r3, #0
    488a:	f040 8201 	bne.w	4c90 <_dtoa_r+0x8a0>
    488e:	2f00      	cmp	r7, #0
    4890:	f340 8220 	ble.w	4cd4 <_dtoa_r+0x8e4>
    4894:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4896:	2b00      	cmp	r3, #0
    4898:	f040 817b 	bne.w	4b92 <_dtoa_r+0x7a2>
    489c:	f8dd b020 	ldr.w	fp, [sp, #32]
    48a0:	f8dd a014 	ldr.w	sl, [sp, #20]
    48a4:	46d8      	mov	r8, fp
    48a6:	e002      	b.n	48ae <_dtoa_r+0x4be>
    48a8:	f7ff f9ca 	bl	3c40 <__multadd>
    48ac:	4605      	mov	r5, r0
    48ae:	4651      	mov	r1, sl
    48b0:	4628      	mov	r0, r5
    48b2:	f7ff fd07 	bl	42c4 <quorem>
    48b6:	f100 0930 	add.w	r9, r0, #48	; 0x30
    48ba:	f808 9b01 	strb.w	r9, [r8], #1
    48be:	ebcb 0308 	rsb	r3, fp, r8
    48c2:	42bb      	cmp	r3, r7
    48c4:	f04f 020a 	mov.w	r2, #10
    48c8:	f04f 0300 	mov.w	r3, #0
    48cc:	4629      	mov	r1, r5
    48ce:	4620      	mov	r0, r4
    48d0:	dbea      	blt.n	48a8 <_dtoa_r+0x4b8>
    48d2:	9b08      	ldr	r3, [sp, #32]
    48d4:	2f01      	cmp	r7, #1
    48d6:	bfac      	ite	ge
    48d8:	19db      	addge	r3, r3, r7
    48da:	3301      	addlt	r3, #1
    48dc:	469b      	mov	fp, r3
    48de:	f04f 0a00 	mov.w	sl, #0
    48e2:	4629      	mov	r1, r5
    48e4:	2201      	movs	r2, #1
    48e6:	4620      	mov	r0, r4
    48e8:	f7ff fb2a 	bl	3f40 <__lshift>
    48ec:	9905      	ldr	r1, [sp, #20]
    48ee:	9007      	str	r0, [sp, #28]
    48f0:	f7ff fb7e 	bl	3ff0 <__mcmp>
    48f4:	2800      	cmp	r0, #0
    48f6:	f340 828c 	ble.w	4e12 <_dtoa_r+0xa22>
    48fa:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
    48fe:	9908      	ldr	r1, [sp, #32]
    4900:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
    4904:	e004      	b.n	4910 <_dtoa_r+0x520>
    4906:	428b      	cmp	r3, r1
    4908:	f000 8203 	beq.w	4d12 <_dtoa_r+0x922>
    490c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    4910:	2a39      	cmp	r2, #57	; 0x39
    4912:	f103 0b01 	add.w	fp, r3, #1
    4916:	d0f6      	beq.n	4906 <_dtoa_r+0x516>
    4918:	3201      	adds	r2, #1
    491a:	701a      	strb	r2, [r3, #0]
    491c:	9905      	ldr	r1, [sp, #20]
    491e:	4620      	mov	r0, r4
    4920:	f7ff f984 	bl	3c2c <_Bfree>
    4924:	2e00      	cmp	r6, #0
    4926:	f43f aec9 	beq.w	46bc <_dtoa_r+0x2cc>
    492a:	f1ba 0f00 	cmp.w	sl, #0
    492e:	d005      	beq.n	493c <_dtoa_r+0x54c>
    4930:	45b2      	cmp	sl, r6
    4932:	d003      	beq.n	493c <_dtoa_r+0x54c>
    4934:	4651      	mov	r1, sl
    4936:	4620      	mov	r0, r4
    4938:	f7ff f978 	bl	3c2c <_Bfree>
    493c:	4631      	mov	r1, r6
    493e:	4620      	mov	r0, r4
    4940:	f7ff f974 	bl	3c2c <_Bfree>
    4944:	e6ba      	b.n	46bc <_dtoa_r+0x2cc>
    4946:	f1c3 0320 	rsb	r3, r3, #32
    494a:	fa0a f303 	lsl.w	r3, sl, r3
    494e:	ee07 3a90 	vmov	s15, r3
    4952:	e5c1      	b.n	44d8 <_dtoa_r+0xe8>
    4954:	2300      	movs	r3, #0
    4956:	930c      	str	r3, [sp, #48]	; 0x30
    4958:	e5fa      	b.n	4550 <_dtoa_r+0x160>
    495a:	2300      	movs	r3, #0
    495c:	9309      	str	r3, [sp, #36]	; 0x24
    495e:	9b02      	ldr	r3, [sp, #8]
    4960:	4443      	add	r3, r8
    4962:	1c5f      	adds	r7, r3, #1
    4964:	2f00      	cmp	r7, #0
    4966:	930d      	str	r3, [sp, #52]	; 0x34
    4968:	f340 822d 	ble.w	4dc6 <_dtoa_r+0x9d6>
    496c:	463e      	mov	r6, r7
    496e:	463d      	mov	r5, r7
    4970:	2100      	movs	r1, #0
    4972:	2e17      	cmp	r6, #23
    4974:	6461      	str	r1, [r4, #68]	; 0x44
    4976:	d90a      	bls.n	498e <_dtoa_r+0x59e>
    4978:	2201      	movs	r2, #1
    497a:	2304      	movs	r3, #4
    497c:	005b      	lsls	r3, r3, #1
    497e:	f103 0014 	add.w	r0, r3, #20
    4982:	42b0      	cmp	r0, r6
    4984:	4611      	mov	r1, r2
    4986:	f102 0201 	add.w	r2, r2, #1
    498a:	d9f7      	bls.n	497c <_dtoa_r+0x58c>
    498c:	6461      	str	r1, [r4, #68]	; 0x44
    498e:	4620      	mov	r0, r4
    4990:	f7ff f926 	bl	3be0 <_Balloc>
    4994:	2d0e      	cmp	r5, #14
    4996:	9008      	str	r0, [sp, #32]
    4998:	6420      	str	r0, [r4, #64]	; 0x40
    499a:	f63f ae26 	bhi.w	45ea <_dtoa_r+0x1fa>
    499e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    49a0:	2b00      	cmp	r3, #0
    49a2:	f43f ae22 	beq.w	45ea <_dtoa_r+0x1fa>
    49a6:	9902      	ldr	r1, [sp, #8]
    49a8:	2900      	cmp	r1, #0
    49aa:	e9cd ab0e 	strd	sl, fp, [sp, #56]	; 0x38
    49ae:	f340 8241 	ble.w	4e34 <_dtoa_r+0xa44>
    49b2:	4bc6      	ldr	r3, [pc, #792]	; (4ccc <_dtoa_r+0x8dc>)
    49b4:	f001 020f 	and.w	r2, r1, #15
    49b8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    49bc:	110b      	asrs	r3, r1, #4
    49be:	06de      	lsls	r6, r3, #27
    49c0:	ed92 6b00 	vldr	d6, [r2]
    49c4:	f140 81fb 	bpl.w	4dbe <_dtoa_r+0x9ce>
    49c8:	4ac1      	ldr	r2, [pc, #772]	; (4cd0 <_dtoa_r+0x8e0>)
    49ca:	ed92 7b08 	vldr	d7, [r2, #32]
    49ce:	ec4b ab14 	vmov	d4, sl, fp
    49d2:	f003 030f 	and.w	r3, r3, #15
    49d6:	2103      	movs	r1, #3
    49d8:	ee84 5b07 	vdiv.f64	d5, d4, d7
    49dc:	b15b      	cbz	r3, 49f6 <_dtoa_r+0x606>
    49de:	4abc      	ldr	r2, [pc, #752]	; (4cd0 <_dtoa_r+0x8e0>)
    49e0:	07dd      	lsls	r5, r3, #31
    49e2:	d504      	bpl.n	49ee <_dtoa_r+0x5fe>
    49e4:	ed92 7b00 	vldr	d7, [r2]
    49e8:	3101      	adds	r1, #1
    49ea:	ee26 6b07 	vmul.f64	d6, d6, d7
    49ee:	105b      	asrs	r3, r3, #1
    49f0:	f102 0208 	add.w	r2, r2, #8
    49f4:	d1f4      	bne.n	49e0 <_dtoa_r+0x5f0>
    49f6:	ee85 4b06 	vdiv.f64	d4, d5, d6
    49fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    49fc:	b13b      	cbz	r3, 4a0e <_dtoa_r+0x61e>
    49fe:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
    4a02:	eeb4 4bc7 	vcmpe.f64	d4, d7
    4a06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4a0a:	f100 82b7 	bmi.w	4f7c <_dtoa_r+0xb8c>
    4a0e:	ee07 1a90 	vmov	s15, r1
    4a12:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    4a16:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    4a1a:	eea6 7b04 	vfma.f64	d7, d6, d4
    4a1e:	ec53 2b17 	vmov	r2, r3, d7
    4a22:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    4a26:	2f00      	cmp	r7, #0
    4a28:	f000 81a6 	beq.w	4d78 <_dtoa_r+0x988>
    4a2c:	9e02      	ldr	r6, [sp, #8]
    4a2e:	4639      	mov	r1, r7
    4a30:	9809      	ldr	r0, [sp, #36]	; 0x24
    4a32:	2800      	cmp	r0, #0
    4a34:	f000 824d 	beq.w	4ed2 <_dtoa_r+0xae2>
    4a38:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
    4a3c:	48a3      	ldr	r0, [pc, #652]	; (4ccc <_dtoa_r+0x8dc>)
    4a3e:	9d08      	ldr	r5, [sp, #32]
    4a40:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
    4a44:	ed10 6b02 	vldr	d6, [r0, #-8]
    4a48:	eebd 7bc4 	vcvt.s32.f64	s14, d4
    4a4c:	ee83 5b06 	vdiv.f64	d5, d3, d6
    4a50:	ee17 0a10 	vmov	r0, s14
    4a54:	ec43 2b16 	vmov	d6, r2, r3
    4a58:	3030      	adds	r0, #48	; 0x30
    4a5a:	b2c0      	uxtb	r0, r0
    4a5c:	ee35 5b46 	vsub.f64	d5, d5, d6
    4a60:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
    4a64:	ee34 7b47 	vsub.f64	d7, d4, d7
    4a68:	eeb4 5bc7 	vcmpe.f64	d5, d7
    4a6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4a70:	7028      	strb	r0, [r5, #0]
    4a72:	f105 0b01 	add.w	fp, r5, #1
    4a76:	dc32      	bgt.n	4ade <_dtoa_r+0x6ee>
    4a78:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
    4a7c:	ee33 6b47 	vsub.f64	d6, d3, d7
    4a80:	eeb4 5bc6 	vcmpe.f64	d5, d6
    4a84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4a88:	f300 82ae 	bgt.w	4fe8 <_dtoa_r+0xbf8>
    4a8c:	2901      	cmp	r1, #1
    4a8e:	f340 81cd 	ble.w	4e2c <_dtoa_r+0xa3c>
    4a92:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
    4a96:	9b08      	ldr	r3, [sp, #32]
    4a98:	4419      	add	r1, r3
    4a9a:	e00a      	b.n	4ab2 <_dtoa_r+0x6c2>
    4a9c:	ee33 6b47 	vsub.f64	d6, d3, d7
    4aa0:	eeb4 6bc5 	vcmpe.f64	d6, d5
    4aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4aa8:	f100 829e 	bmi.w	4fe8 <_dtoa_r+0xbf8>
    4aac:	458b      	cmp	fp, r1
    4aae:	f000 81bd 	beq.w	4e2c <_dtoa_r+0xa3c>
    4ab2:	ee27 7b04 	vmul.f64	d7, d7, d4
    4ab6:	ee25 5b04 	vmul.f64	d5, d5, d4
    4aba:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    4abe:	ee16 3a10 	vmov	r3, s12
    4ac2:	f103 0030 	add.w	r0, r3, #48	; 0x30
    4ac6:	b2c0      	uxtb	r0, r0
    4ac8:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    4acc:	ee37 7b46 	vsub.f64	d7, d7, d6
    4ad0:	eeb4 7bc5 	vcmpe.f64	d7, d5
    4ad4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4ad8:	f80b 0b01 	strb.w	r0, [fp], #1
    4adc:	d5de      	bpl.n	4a9c <_dtoa_r+0x6ac>
    4ade:	9602      	str	r6, [sp, #8]
    4ae0:	e5ec      	b.n	46bc <_dtoa_r+0x2cc>
    4ae2:	2300      	movs	r3, #0
    4ae4:	9309      	str	r3, [sp, #36]	; 0x24
    4ae6:	f1b8 0f00 	cmp.w	r8, #0
    4aea:	f340 8170 	ble.w	4dce <_dtoa_r+0x9de>
    4aee:	4646      	mov	r6, r8
    4af0:	4645      	mov	r5, r8
    4af2:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    4af6:	4647      	mov	r7, r8
    4af8:	e73a      	b.n	4970 <_dtoa_r+0x580>
    4afa:	2301      	movs	r3, #1
    4afc:	9309      	str	r3, [sp, #36]	; 0x24
    4afe:	e7f2      	b.n	4ae6 <_dtoa_r+0x6f6>
    4b00:	9507      	str	r5, [sp, #28]
    4b02:	9a05      	ldr	r2, [sp, #20]
    4b04:	9907      	ldr	r1, [sp, #28]
    4b06:	4620      	mov	r0, r4
    4b08:	f7ff f9ca 	bl	3ea0 <__pow5mult>
    4b0c:	4605      	mov	r5, r0
    4b0e:	e677      	b.n	4800 <_dtoa_r+0x410>
    4b10:	2f00      	cmp	r7, #0
    4b12:	f73f ad79 	bgt.w	4608 <_dtoa_r+0x218>
    4b16:	f040 8142 	bne.w	4d9e <_dtoa_r+0x9ae>
    4b1a:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    4b1e:	ee24 4b07 	vmul.f64	d4, d4, d7
    4b22:	ec4b ab17 	vmov	d7, sl, fp
    4b26:	eeb4 4bc7 	vcmpe.f64	d4, d7
    4b2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4b2e:	463e      	mov	r6, r7
    4b30:	9705      	str	r7, [sp, #20]
    4b32:	f2c0 80e5 	blt.w	4d00 <_dtoa_r+0x910>
    4b36:	ea6f 0308 	mvn.w	r3, r8
    4b3a:	f8dd b020 	ldr.w	fp, [sp, #32]
    4b3e:	9302      	str	r3, [sp, #8]
    4b40:	9905      	ldr	r1, [sp, #20]
    4b42:	4620      	mov	r0, r4
    4b44:	f7ff f872 	bl	3c2c <_Bfree>
    4b48:	2e00      	cmp	r6, #0
    4b4a:	f43f adb7 	beq.w	46bc <_dtoa_r+0x2cc>
    4b4e:	e6f5      	b.n	493c <_dtoa_r+0x54c>
    4b50:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    4b52:	2a00      	cmp	r2, #0
    4b54:	f000 8202 	beq.w	4f5c <_dtoa_r+0xb6c>
    4b58:	9a05      	ldr	r2, [sp, #20]
    4b5a:	920e      	str	r2, [sp, #56]	; 0x38
    4b5c:	9a06      	ldr	r2, [sp, #24]
    4b5e:	920a      	str	r2, [sp, #40]	; 0x28
    4b60:	f203 4333 	addw	r3, r3, #1075	; 0x433
    4b64:	e5d3      	b.n	470e <_dtoa_r+0x31e>
    4b66:	201c      	movs	r0, #28
    4b68:	e674      	b.n	4854 <_dtoa_r+0x464>
    4b6a:	9b01      	ldr	r3, [sp, #4]
    4b6c:	2b01      	cmp	r3, #1
    4b6e:	f340 8240 	ble.w	4ff2 <_dtoa_r+0xc02>
    4b72:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4b74:	9307      	str	r3, [sp, #28]
    4b76:	2001      	movs	r0, #1
    4b78:	e660      	b.n	483c <_dtoa_r+0x44c>
    4b7a:	4631      	mov	r1, r6
    4b7c:	2300      	movs	r3, #0
    4b7e:	220a      	movs	r2, #10
    4b80:	4620      	mov	r0, r4
    4b82:	f7ff f85d 	bl	3c40 <__multadd>
    4b86:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4b88:	2b00      	cmp	r3, #0
    4b8a:	4606      	mov	r6, r0
    4b8c:	f340 824d 	ble.w	502a <_dtoa_r+0xc3a>
    4b90:	461f      	mov	r7, r3
    4b92:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    4b94:	2b00      	cmp	r3, #0
    4b96:	dd05      	ble.n	4ba4 <_dtoa_r+0x7b4>
    4b98:	4631      	mov	r1, r6
    4b9a:	461a      	mov	r2, r3
    4b9c:	4620      	mov	r0, r4
    4b9e:	f7ff f9cf 	bl	3f40 <__lshift>
    4ba2:	4606      	mov	r6, r0
    4ba4:	9b07      	ldr	r3, [sp, #28]
    4ba6:	2b00      	cmp	r3, #0
    4ba8:	f040 816e 	bne.w	4e88 <_dtoa_r+0xa98>
    4bac:	46b0      	mov	r8, r6
    4bae:	9b08      	ldr	r3, [sp, #32]
    4bb0:	3f01      	subs	r7, #1
    4bb2:	19da      	adds	r2, r3, r7
    4bb4:	9209      	str	r2, [sp, #36]	; 0x24
    4bb6:	f00a 0201 	and.w	r2, sl, #1
    4bba:	920a      	str	r2, [sp, #40]	; 0x28
    4bbc:	461f      	mov	r7, r3
    4bbe:	f8dd b014 	ldr.w	fp, [sp, #20]
    4bc2:	4628      	mov	r0, r5
    4bc4:	4659      	mov	r1, fp
    4bc6:	f7ff fb7d 	bl	42c4 <quorem>
    4bca:	4631      	mov	r1, r6
    4bcc:	4682      	mov	sl, r0
    4bce:	4628      	mov	r0, r5
    4bd0:	f7ff fa0e 	bl	3ff0 <__mcmp>
    4bd4:	4642      	mov	r2, r8
    4bd6:	4659      	mov	r1, fp
    4bd8:	4681      	mov	r9, r0
    4bda:	4620      	mov	r0, r4
    4bdc:	f7ff fa2a 	bl	4034 <__mdiff>
    4be0:	68c3      	ldr	r3, [r0, #12]
    4be2:	4683      	mov	fp, r0
    4be4:	f10a 0230 	add.w	r2, sl, #48	; 0x30
    4be8:	2b00      	cmp	r3, #0
    4bea:	d149      	bne.n	4c80 <_dtoa_r+0x890>
    4bec:	4601      	mov	r1, r0
    4bee:	4628      	mov	r0, r5
    4bf0:	9207      	str	r2, [sp, #28]
    4bf2:	f7ff f9fd 	bl	3ff0 <__mcmp>
    4bf6:	4659      	mov	r1, fp
    4bf8:	9006      	str	r0, [sp, #24]
    4bfa:	4620      	mov	r0, r4
    4bfc:	f7ff f816 	bl	3c2c <_Bfree>
    4c00:	9b06      	ldr	r3, [sp, #24]
    4c02:	9a07      	ldr	r2, [sp, #28]
    4c04:	b92b      	cbnz	r3, 4c12 <_dtoa_r+0x822>
    4c06:	9901      	ldr	r1, [sp, #4]
    4c08:	b919      	cbnz	r1, 4c12 <_dtoa_r+0x822>
    4c0a:	990a      	ldr	r1, [sp, #40]	; 0x28
    4c0c:	2900      	cmp	r1, #0
    4c0e:	f000 81f5 	beq.w	4ffc <_dtoa_r+0xc0c>
    4c12:	f1b9 0f00 	cmp.w	r9, #0
    4c16:	f2c0 80df 	blt.w	4dd8 <_dtoa_r+0x9e8>
    4c1a:	d105      	bne.n	4c28 <_dtoa_r+0x838>
    4c1c:	9901      	ldr	r1, [sp, #4]
    4c1e:	b919      	cbnz	r1, 4c28 <_dtoa_r+0x838>
    4c20:	990a      	ldr	r1, [sp, #40]	; 0x28
    4c22:	2900      	cmp	r1, #0
    4c24:	f000 80d8 	beq.w	4dd8 <_dtoa_r+0x9e8>
    4c28:	2b00      	cmp	r3, #0
    4c2a:	f300 8141 	bgt.w	4eb0 <_dtoa_r+0xac0>
    4c2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4c30:	703a      	strb	r2, [r7, #0]
    4c32:	f107 0901 	add.w	r9, r7, #1
    4c36:	429f      	cmp	r7, r3
    4c38:	46cb      	mov	fp, r9
    4c3a:	f000 8146 	beq.w	4eca <_dtoa_r+0xada>
    4c3e:	4629      	mov	r1, r5
    4c40:	2300      	movs	r3, #0
    4c42:	220a      	movs	r2, #10
    4c44:	4620      	mov	r0, r4
    4c46:	f7fe fffb 	bl	3c40 <__multadd>
    4c4a:	4546      	cmp	r6, r8
    4c4c:	4605      	mov	r5, r0
    4c4e:	4631      	mov	r1, r6
    4c50:	f04f 0300 	mov.w	r3, #0
    4c54:	f04f 020a 	mov.w	r2, #10
    4c58:	4620      	mov	r0, r4
    4c5a:	d00b      	beq.n	4c74 <_dtoa_r+0x884>
    4c5c:	f7fe fff0 	bl	3c40 <__multadd>
    4c60:	4641      	mov	r1, r8
    4c62:	4606      	mov	r6, r0
    4c64:	2300      	movs	r3, #0
    4c66:	220a      	movs	r2, #10
    4c68:	4620      	mov	r0, r4
    4c6a:	f7fe ffe9 	bl	3c40 <__multadd>
    4c6e:	464f      	mov	r7, r9
    4c70:	4680      	mov	r8, r0
    4c72:	e7a4      	b.n	4bbe <_dtoa_r+0x7ce>
    4c74:	f7fe ffe4 	bl	3c40 <__multadd>
    4c78:	464f      	mov	r7, r9
    4c7a:	4606      	mov	r6, r0
    4c7c:	4680      	mov	r8, r0
    4c7e:	e79e      	b.n	4bbe <_dtoa_r+0x7ce>
    4c80:	4601      	mov	r1, r0
    4c82:	4620      	mov	r0, r4
    4c84:	9206      	str	r2, [sp, #24]
    4c86:	f7fe ffd1 	bl	3c2c <_Bfree>
    4c8a:	2301      	movs	r3, #1
    4c8c:	9a06      	ldr	r2, [sp, #24]
    4c8e:	e7c0      	b.n	4c12 <_dtoa_r+0x822>
    4c90:	9905      	ldr	r1, [sp, #20]
    4c92:	4628      	mov	r0, r5
    4c94:	f7ff f9ac 	bl	3ff0 <__mcmp>
    4c98:	2800      	cmp	r0, #0
    4c9a:	f6bf adf8 	bge.w	488e <_dtoa_r+0x49e>
    4c9e:	4629      	mov	r1, r5
    4ca0:	9d02      	ldr	r5, [sp, #8]
    4ca2:	2300      	movs	r3, #0
    4ca4:	3d01      	subs	r5, #1
    4ca6:	220a      	movs	r2, #10
    4ca8:	4620      	mov	r0, r4
    4caa:	9502      	str	r5, [sp, #8]
    4cac:	f7fe ffc8 	bl	3c40 <__multadd>
    4cb0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4cb2:	4605      	mov	r5, r0
    4cb4:	2b00      	cmp	r3, #0
    4cb6:	f47f af60 	bne.w	4b7a <_dtoa_r+0x78a>
    4cba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4cbc:	2b00      	cmp	r3, #0
    4cbe:	f340 81ad 	ble.w	501c <_dtoa_r+0xc2c>
    4cc2:	461f      	mov	r7, r3
    4cc4:	e5ea      	b.n	489c <_dtoa_r+0x4ac>
    4cc6:	9d07      	ldr	r5, [sp, #28]
    4cc8:	e59a      	b.n	4800 <_dtoa_r+0x410>
    4cca:	bf00      	nop
    4ccc:	200002a8 	.word	0x200002a8
    4cd0:	20000280 	.word	0x20000280
    4cd4:	9b01      	ldr	r3, [sp, #4]
    4cd6:	2b02      	cmp	r3, #2
    4cd8:	f77f addc 	ble.w	4894 <_dtoa_r+0x4a4>
    4cdc:	2f00      	cmp	r7, #0
    4cde:	f040 8169 	bne.w	4fb4 <_dtoa_r+0xbc4>
    4ce2:	463b      	mov	r3, r7
    4ce4:	9905      	ldr	r1, [sp, #20]
    4ce6:	2205      	movs	r2, #5
    4ce8:	4620      	mov	r0, r4
    4cea:	f7fe ffa9 	bl	3c40 <__multadd>
    4cee:	4601      	mov	r1, r0
    4cf0:	9005      	str	r0, [sp, #20]
    4cf2:	4628      	mov	r0, r5
    4cf4:	f7ff f97c 	bl	3ff0 <__mcmp>
    4cf8:	2800      	cmp	r0, #0
    4cfa:	9507      	str	r5, [sp, #28]
    4cfc:	f77f af1b 	ble.w	4b36 <_dtoa_r+0x746>
    4d00:	9a02      	ldr	r2, [sp, #8]
    4d02:	9908      	ldr	r1, [sp, #32]
    4d04:	2331      	movs	r3, #49	; 0x31
    4d06:	3201      	adds	r2, #1
    4d08:	9202      	str	r2, [sp, #8]
    4d0a:	700b      	strb	r3, [r1, #0]
    4d0c:	f101 0b01 	add.w	fp, r1, #1
    4d10:	e716      	b.n	4b40 <_dtoa_r+0x750>
    4d12:	9a02      	ldr	r2, [sp, #8]
    4d14:	3201      	adds	r2, #1
    4d16:	9202      	str	r2, [sp, #8]
    4d18:	9a08      	ldr	r2, [sp, #32]
    4d1a:	2331      	movs	r3, #49	; 0x31
    4d1c:	7013      	strb	r3, [r2, #0]
    4d1e:	e5fd      	b.n	491c <_dtoa_r+0x52c>
    4d20:	2301      	movs	r3, #1
    4d22:	9309      	str	r3, [sp, #36]	; 0x24
    4d24:	e61b      	b.n	495e <_dtoa_r+0x56e>
    4d26:	f1ba 0f00 	cmp.w	sl, #0
    4d2a:	f47f ad7c 	bne.w	4826 <_dtoa_r+0x436>
    4d2e:	f3cb 0313 	ubfx	r3, fp, #0, #20
    4d32:	2b00      	cmp	r3, #0
    4d34:	f040 811b 	bne.w	4f6e <_dtoa_r+0xb7e>
    4d38:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
    4d3c:	0d1b      	lsrs	r3, r3, #20
    4d3e:	051b      	lsls	r3, r3, #20
    4d40:	2b00      	cmp	r3, #0
    4d42:	f000 8154 	beq.w	4fee <_dtoa_r+0xbfe>
    4d46:	9b06      	ldr	r3, [sp, #24]
    4d48:	3301      	adds	r3, #1
    4d4a:	9306      	str	r3, [sp, #24]
    4d4c:	2301      	movs	r3, #1
    4d4e:	f109 0901 	add.w	r9, r9, #1
    4d52:	9307      	str	r3, [sp, #28]
    4d54:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4d56:	2001      	movs	r0, #1
    4d58:	2b00      	cmp	r3, #0
    4d5a:	f43f ad6f 	beq.w	483c <_dtoa_r+0x44c>
    4d5e:	e564      	b.n	482a <_dtoa_r+0x43a>
    4d60:	ee07 1a90 	vmov	s15, r1
    4d64:	eeb8 6be7 	vcvt.f64.s32	d6, s15
    4d68:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    4d6c:	eea4 7b06 	vfma.f64	d7, d4, d6
    4d70:	ec53 2b17 	vmov	r2, r3, d7
    4d74:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    4d78:	ec43 2b16 	vmov	d6, r2, r3
    4d7c:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
    4d80:	ee34 7b47 	vsub.f64	d7, d4, d7
    4d84:	eeb4 7bc6 	vcmpe.f64	d7, d6
    4d88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4d8c:	f300 80dd 	bgt.w	4f4a <_dtoa_r+0xb5a>
    4d90:	eeb1 6b46 	vneg.f64	d6, d6
    4d94:	eeb4 7bc6 	vcmpe.f64	d7, d6
    4d98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4d9c:	d546      	bpl.n	4e2c <_dtoa_r+0xa3c>
    4d9e:	2300      	movs	r3, #0
    4da0:	9305      	str	r3, [sp, #20]
    4da2:	461e      	mov	r6, r3
    4da4:	e6c7      	b.n	4b36 <_dtoa_r+0x746>
    4da6:	9808      	ldr	r0, [sp, #32]
    4da8:	f7ff bb59 	b.w	445e <_dtoa_r+0x6e>
    4dac:	9b05      	ldr	r3, [sp, #20]
    4dae:	990b      	ldr	r1, [sp, #44]	; 0x2c
    4db0:	9205      	str	r2, [sp, #20]
    4db2:	1ad3      	subs	r3, r2, r3
    4db4:	4419      	add	r1, r3
    4db6:	2300      	movs	r3, #0
    4db8:	910b      	str	r1, [sp, #44]	; 0x2c
    4dba:	930e      	str	r3, [sp, #56]	; 0x38
    4dbc:	e4a1      	b.n	4702 <_dtoa_r+0x312>
    4dbe:	ed9d 5b0e 	vldr	d5, [sp, #56]	; 0x38
    4dc2:	2102      	movs	r1, #2
    4dc4:	e60a      	b.n	49dc <_dtoa_r+0x5ec>
    4dc6:	463d      	mov	r5, r7
    4dc8:	2100      	movs	r1, #0
    4dca:	6461      	str	r1, [r4, #68]	; 0x44
    4dcc:	e5df      	b.n	498e <_dtoa_r+0x59e>
    4dce:	2501      	movs	r5, #1
    4dd0:	950d      	str	r5, [sp, #52]	; 0x34
    4dd2:	462f      	mov	r7, r5
    4dd4:	46a8      	mov	r8, r5
    4dd6:	e7f7      	b.n	4dc8 <_dtoa_r+0x9d8>
    4dd8:	2b00      	cmp	r3, #0
    4dda:	4691      	mov	r9, r2
    4ddc:	dd11      	ble.n	4e02 <_dtoa_r+0xa12>
    4dde:	4629      	mov	r1, r5
    4de0:	2201      	movs	r2, #1
    4de2:	4620      	mov	r0, r4
    4de4:	f7ff f8ac 	bl	3f40 <__lshift>
    4de8:	9905      	ldr	r1, [sp, #20]
    4dea:	4605      	mov	r5, r0
    4dec:	f7ff f900 	bl	3ff0 <__mcmp>
    4df0:	2800      	cmp	r0, #0
    4df2:	f340 810c 	ble.w	500e <_dtoa_r+0xc1e>
    4df6:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
    4dfa:	f000 80dd 	beq.w	4fb8 <_dtoa_r+0xbc8>
    4dfe:	f10a 0931 	add.w	r9, sl, #49	; 0x31
    4e02:	46b2      	mov	sl, r6
    4e04:	f887 9000 	strb.w	r9, [r7]
    4e08:	f107 0b01 	add.w	fp, r7, #1
    4e0c:	4646      	mov	r6, r8
    4e0e:	9507      	str	r5, [sp, #28]
    4e10:	e584      	b.n	491c <_dtoa_r+0x52c>
    4e12:	d104      	bne.n	4e1e <_dtoa_r+0xa2e>
    4e14:	f019 0f01 	tst.w	r9, #1
    4e18:	d001      	beq.n	4e1e <_dtoa_r+0xa2e>
    4e1a:	e56e      	b.n	48fa <_dtoa_r+0x50a>
    4e1c:	4693      	mov	fp, r2
    4e1e:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    4e22:	2b30      	cmp	r3, #48	; 0x30
    4e24:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    4e28:	d0f8      	beq.n	4e1c <_dtoa_r+0xa2c>
    4e2a:	e577      	b.n	491c <_dtoa_r+0x52c>
    4e2c:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
    4e30:	f7ff bbdb 	b.w	45ea <_dtoa_r+0x1fa>
    4e34:	9b02      	ldr	r3, [sp, #8]
    4e36:	425b      	negs	r3, r3
    4e38:	2b00      	cmp	r3, #0
    4e3a:	f000 809b 	beq.w	4f74 <_dtoa_r+0xb84>
    4e3e:	4a8b      	ldr	r2, [pc, #556]	; (506c <_dtoa_r+0xc7c>)
    4e40:	f003 010f 	and.w	r1, r3, #15
    4e44:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
    4e48:	ed92 7b00 	vldr	d7, [r2]
    4e4c:	ed9d 6b0e 	vldr	d6, [sp, #56]	; 0x38
    4e50:	111b      	asrs	r3, r3, #4
    4e52:	ee26 4b07 	vmul.f64	d4, d6, d7
    4e56:	f000 80e6 	beq.w	5026 <_dtoa_r+0xc36>
    4e5a:	4a85      	ldr	r2, [pc, #532]	; (5070 <_dtoa_r+0xc80>)
    4e5c:	2102      	movs	r1, #2
    4e5e:	07d8      	lsls	r0, r3, #31
    4e60:	d504      	bpl.n	4e6c <_dtoa_r+0xa7c>
    4e62:	ed92 7b00 	vldr	d7, [r2]
    4e66:	3101      	adds	r1, #1
    4e68:	ee24 4b07 	vmul.f64	d4, d4, d7
    4e6c:	105b      	asrs	r3, r3, #1
    4e6e:	f102 0208 	add.w	r2, r2, #8
    4e72:	d1f4      	bne.n	4e5e <_dtoa_r+0xa6e>
    4e74:	e5c1      	b.n	49fa <_dtoa_r+0x60a>
    4e76:	9908      	ldr	r1, [sp, #32]
    4e78:	2230      	movs	r2, #48	; 0x30
    4e7a:	700a      	strb	r2, [r1, #0]
    4e7c:	9a02      	ldr	r2, [sp, #8]
    4e7e:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    4e82:	3201      	adds	r2, #1
    4e84:	9202      	str	r2, [sp, #8]
    4e86:	e417      	b.n	46b8 <_dtoa_r+0x2c8>
    4e88:	6871      	ldr	r1, [r6, #4]
    4e8a:	4620      	mov	r0, r4
    4e8c:	f7fe fea8 	bl	3be0 <_Balloc>
    4e90:	6933      	ldr	r3, [r6, #16]
    4e92:	1c9a      	adds	r2, r3, #2
    4e94:	4680      	mov	r8, r0
    4e96:	0092      	lsls	r2, r2, #2
    4e98:	f106 010c 	add.w	r1, r6, #12
    4e9c:	300c      	adds	r0, #12
    4e9e:	f7fd fff7 	bl	2e90 <memcpy>
    4ea2:	4641      	mov	r1, r8
    4ea4:	2201      	movs	r2, #1
    4ea6:	4620      	mov	r0, r4
    4ea8:	f7ff f84a 	bl	3f40 <__lshift>
    4eac:	4680      	mov	r8, r0
    4eae:	e67e      	b.n	4bae <_dtoa_r+0x7be>
    4eb0:	2a39      	cmp	r2, #57	; 0x39
    4eb2:	f000 8081 	beq.w	4fb8 <_dtoa_r+0xbc8>
    4eb6:	f102 0901 	add.w	r9, r2, #1
    4eba:	46b2      	mov	sl, r6
    4ebc:	f887 9000 	strb.w	r9, [r7]
    4ec0:	f107 0b01 	add.w	fp, r7, #1
    4ec4:	4646      	mov	r6, r8
    4ec6:	9507      	str	r5, [sp, #28]
    4ec8:	e528      	b.n	491c <_dtoa_r+0x52c>
    4eca:	46b2      	mov	sl, r6
    4ecc:	4691      	mov	r9, r2
    4ece:	4646      	mov	r6, r8
    4ed0:	e507      	b.n	48e2 <_dtoa_r+0x4f2>
    4ed2:	4866      	ldr	r0, [pc, #408]	; (506c <_dtoa_r+0xc7c>)
    4ed4:	eebd 6bc4 	vcvt.s32.f64	s12, d4
    4ed8:	1e4d      	subs	r5, r1, #1
    4eda:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
    4ede:	ec43 2b17 	vmov	d7, r2, r3
    4ee2:	ed90 3b00 	vldr	d3, [r0]
    4ee6:	ee16 3a10 	vmov	r3, s12
    4eea:	ee23 3b07 	vmul.f64	d3, d3, d7
    4eee:	9808      	ldr	r0, [sp, #32]
    4ef0:	3330      	adds	r3, #48	; 0x30
    4ef2:	2901      	cmp	r1, #1
    4ef4:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    4ef8:	7003      	strb	r3, [r0, #0]
    4efa:	f100 0b01 	add.w	fp, r0, #1
    4efe:	ee34 7b46 	vsub.f64	d7, d4, d6
    4f02:	d014      	beq.n	4f2e <_dtoa_r+0xb3e>
    4f04:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    4f08:	9b08      	ldr	r3, [sp, #32]
    4f0a:	4419      	add	r1, r3
    4f0c:	465b      	mov	r3, fp
    4f0e:	ee27 7b05 	vmul.f64	d7, d7, d5
    4f12:	eebd 6bc7 	vcvt.s32.f64	s12, d7
    4f16:	ee16 2a10 	vmov	r2, s12
    4f1a:	3230      	adds	r2, #48	; 0x30
    4f1c:	f803 2b01 	strb.w	r2, [r3], #1
    4f20:	4299      	cmp	r1, r3
    4f22:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    4f26:	ee37 7b46 	vsub.f64	d7, d7, d6
    4f2a:	d1f0      	bne.n	4f0e <_dtoa_r+0xb1e>
    4f2c:	44ab      	add	fp, r5
    4f2e:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
    4f32:	ee33 5b06 	vadd.f64	d5, d3, d6
    4f36:	eeb4 5bc7 	vcmpe.f64	d5, d7
    4f3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4f3e:	d543      	bpl.n	4fc8 <_dtoa_r+0xbd8>
    4f40:	9602      	str	r6, [sp, #8]
    4f42:	f81b 0c01 	ldrb.w	r0, [fp, #-1]
    4f46:	f7ff bbaa 	b.w	469e <_dtoa_r+0x2ae>
    4f4a:	2300      	movs	r3, #0
    4f4c:	9305      	str	r3, [sp, #20]
    4f4e:	461e      	mov	r6, r3
    4f50:	e6d6      	b.n	4d00 <_dtoa_r+0x910>
    4f52:	1bdb      	subs	r3, r3, r7
    4f54:	930a      	str	r3, [sp, #40]	; 0x28
    4f56:	2300      	movs	r3, #0
    4f58:	f7ff bbd9 	b.w	470e <_dtoa_r+0x31e>
    4f5c:	9a05      	ldr	r2, [sp, #20]
    4f5e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    4f60:	920e      	str	r2, [sp, #56]	; 0x38
    4f62:	9a06      	ldr	r2, [sp, #24]
    4f64:	920a      	str	r2, [sp, #40]	; 0x28
    4f66:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    4f6a:	f7ff bbd0 	b.w	470e <_dtoa_r+0x31e>
    4f6e:	2300      	movs	r3, #0
    4f70:	9307      	str	r3, [sp, #28]
    4f72:	e6ef      	b.n	4d54 <_dtoa_r+0x964>
    4f74:	ed9d 4b0e 	vldr	d4, [sp, #56]	; 0x38
    4f78:	2102      	movs	r1, #2
    4f7a:	e53e      	b.n	49fa <_dtoa_r+0x60a>
    4f7c:	2f00      	cmp	r7, #0
    4f7e:	f43f aeef 	beq.w	4d60 <_dtoa_r+0x970>
    4f82:	980d      	ldr	r0, [sp, #52]	; 0x34
    4f84:	2800      	cmp	r0, #0
    4f86:	f77f af51 	ble.w	4e2c <_dtoa_r+0xa3c>
    4f8a:	eeb2 5b04 	vmov.f64	d5, #36	; 0x41200000  10.0
    4f8e:	eeb1 7b0c 	vmov.f64	d7, #28	; 0x40e00000  7.0
    4f92:	3101      	adds	r1, #1
    4f94:	ee06 1a90 	vmov	s13, r1
    4f98:	ee24 4b05 	vmul.f64	d4, d4, d5
    4f9c:	9b02      	ldr	r3, [sp, #8]
    4f9e:	eeb8 6be6 	vcvt.f64.s32	d6, s13
    4fa2:	1e5e      	subs	r6, r3, #1
    4fa4:	eea4 7b06 	vfma.f64	d7, d4, d6
    4fa8:	ec53 2b17 	vmov	r2, r3, d7
    4fac:	4601      	mov	r1, r0
    4fae:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
    4fb2:	e53d      	b.n	4a30 <_dtoa_r+0x640>
    4fb4:	9507      	str	r5, [sp, #28]
    4fb6:	e5be      	b.n	4b36 <_dtoa_r+0x746>
    4fb8:	2239      	movs	r2, #57	; 0x39
    4fba:	46b2      	mov	sl, r6
    4fbc:	9507      	str	r5, [sp, #28]
    4fbe:	4646      	mov	r6, r8
    4fc0:	703a      	strb	r2, [r7, #0]
    4fc2:	f107 0b01 	add.w	fp, r7, #1
    4fc6:	e49a      	b.n	48fe <_dtoa_r+0x50e>
    4fc8:	ee36 6b43 	vsub.f64	d6, d6, d3
    4fcc:	eeb4 6bc7 	vcmpe.f64	d6, d7
    4fd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4fd4:	dc01      	bgt.n	4fda <_dtoa_r+0xbea>
    4fd6:	e729      	b.n	4e2c <_dtoa_r+0xa3c>
    4fd8:	4693      	mov	fp, r2
    4fda:	f81b 3c01 	ldrb.w	r3, [fp, #-1]
    4fde:	2b30      	cmp	r3, #48	; 0x30
    4fe0:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
    4fe4:	d0f8      	beq.n	4fd8 <_dtoa_r+0xbe8>
    4fe6:	e57a      	b.n	4ade <_dtoa_r+0x6ee>
    4fe8:	9602      	str	r6, [sp, #8]
    4fea:	f7ff bb58 	b.w	469e <_dtoa_r+0x2ae>
    4fee:	9307      	str	r3, [sp, #28]
    4ff0:	e6b0      	b.n	4d54 <_dtoa_r+0x964>
    4ff2:	f1ba 0f00 	cmp.w	sl, #0
    4ff6:	f47f adbc 	bne.w	4b72 <_dtoa_r+0x782>
    4ffa:	e698      	b.n	4d2e <_dtoa_r+0x93e>
    4ffc:	2a39      	cmp	r2, #57	; 0x39
    4ffe:	46cb      	mov	fp, r9
    5000:	4691      	mov	r9, r2
    5002:	d0d9      	beq.n	4fb8 <_dtoa_r+0xbc8>
    5004:	f1bb 0f00 	cmp.w	fp, #0
    5008:	f73f aef9 	bgt.w	4dfe <_dtoa_r+0xa0e>
    500c:	e6f9      	b.n	4e02 <_dtoa_r+0xa12>
    500e:	f47f aef8 	bne.w	4e02 <_dtoa_r+0xa12>
    5012:	f019 0f01 	tst.w	r9, #1
    5016:	f43f aef4 	beq.w	4e02 <_dtoa_r+0xa12>
    501a:	e6ec      	b.n	4df6 <_dtoa_r+0xa06>
    501c:	9b01      	ldr	r3, [sp, #4]
    501e:	2b02      	cmp	r3, #2
    5020:	dc08      	bgt.n	5034 <_dtoa_r+0xc44>
    5022:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    5024:	e43a      	b.n	489c <_dtoa_r+0x4ac>
    5026:	2102      	movs	r1, #2
    5028:	e4e7      	b.n	49fa <_dtoa_r+0x60a>
    502a:	9b01      	ldr	r3, [sp, #4]
    502c:	2b02      	cmp	r3, #2
    502e:	dc01      	bgt.n	5034 <_dtoa_r+0xc44>
    5030:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    5032:	e5ae      	b.n	4b92 <_dtoa_r+0x7a2>
    5034:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    5036:	e651      	b.n	4cdc <_dtoa_r+0x8ec>
    5038:	2301      	movs	r3, #1
    503a:	930e      	str	r3, [sp, #56]	; 0x38
    503c:	f7ff baa1 	b.w	4582 <_dtoa_r+0x192>
    5040:	f43f ac0f 	beq.w	4862 <_dtoa_r+0x472>
    5044:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
    5048:	e404      	b.n	4854 <_dtoa_r+0x464>
    504a:	2500      	movs	r5, #0
    504c:	6465      	str	r5, [r4, #68]	; 0x44
    504e:	4629      	mov	r1, r5
    5050:	4620      	mov	r0, r4
    5052:	f7fe fdc5 	bl	3be0 <_Balloc>
    5056:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    505a:	2301      	movs	r3, #1
    505c:	9008      	str	r0, [sp, #32]
    505e:	46a8      	mov	r8, r5
    5060:	6420      	str	r0, [r4, #64]	; 0x40
    5062:	970d      	str	r7, [sp, #52]	; 0x34
    5064:	9309      	str	r3, [sp, #36]	; 0x24
    5066:	f7ff bac0 	b.w	45ea <_dtoa_r+0x1fa>
    506a:	bf00      	nop
    506c:	200002a8 	.word	0x200002a8
    5070:	20000280 	.word	0x20000280
    5074:	00000000 	.word	0x00000000

00005078 <_svfprintf_r>:
    5078:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    507c:	ed2d 8b06 	vpush	{d8-d10}
    5080:	b0b9      	sub	sp, #228	; 0xe4
    5082:	460c      	mov	r4, r1
    5084:	9103      	str	r1, [sp, #12]
    5086:	4692      	mov	sl, r2
    5088:	9309      	str	r3, [sp, #36]	; 0x24
    508a:	9005      	str	r0, [sp, #20]
    508c:	f7fe fd44 	bl	3b18 <_localeconv_r>
    5090:	6803      	ldr	r3, [r0, #0]
    5092:	9310      	str	r3, [sp, #64]	; 0x40
    5094:	4618      	mov	r0, r3
    5096:	f7fe fab3 	bl	3600 <strlen>
    509a:	89a3      	ldrh	r3, [r4, #12]
    509c:	900f      	str	r0, [sp, #60]	; 0x3c
    509e:	0619      	lsls	r1, r3, #24
    50a0:	d503      	bpl.n	50aa <_svfprintf_r+0x32>
    50a2:	6923      	ldr	r3, [r4, #16]
    50a4:	2b00      	cmp	r3, #0
    50a6:	f001 807d 	beq.w	61a4 <_svfprintf_r+0x112c>
    50aa:	2300      	movs	r3, #0
    50ac:	ed9f 8ba4 	vldr	d8, [pc, #656]	; 5340 <_svfprintf_r+0x2c8>
    50b0:	ed9f 9ba5 	vldr	d9, [pc, #660]	; 5348 <_svfprintf_r+0x2d0>
    50b4:	930d      	str	r3, [sp, #52]	; 0x34
    50b6:	931d      	str	r3, [sp, #116]	; 0x74
    50b8:	931c      	str	r3, [sp, #112]	; 0x70
    50ba:	9311      	str	r3, [sp, #68]	; 0x44
    50bc:	9306      	str	r3, [sp, #24]
    50be:	ab28      	add	r3, sp, #160	; 0xa0
    50c0:	931b      	str	r3, [sp, #108]	; 0x6c
    50c2:	4699      	mov	r9, r3
    50c4:	f89a 3000 	ldrb.w	r3, [sl]
    50c8:	4654      	mov	r4, sl
    50ca:	b1eb      	cbz	r3, 5108 <_svfprintf_r+0x90>
    50cc:	2b25      	cmp	r3, #37	; 0x25
    50ce:	d102      	bne.n	50d6 <_svfprintf_r+0x5e>
    50d0:	e01a      	b.n	5108 <_svfprintf_r+0x90>
    50d2:	2b25      	cmp	r3, #37	; 0x25
    50d4:	d003      	beq.n	50de <_svfprintf_r+0x66>
    50d6:	f814 3f01 	ldrb.w	r3, [r4, #1]!
    50da:	2b00      	cmp	r3, #0
    50dc:	d1f9      	bne.n	50d2 <_svfprintf_r+0x5a>
    50de:	ebca 0504 	rsb	r5, sl, r4
    50e2:	b18d      	cbz	r5, 5108 <_svfprintf_r+0x90>
    50e4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    50e6:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    50e8:	f8c9 a000 	str.w	sl, [r9]
    50ec:	3301      	adds	r3, #1
    50ee:	442a      	add	r2, r5
    50f0:	2b07      	cmp	r3, #7
    50f2:	f8c9 5004 	str.w	r5, [r9, #4]
    50f6:	921d      	str	r2, [sp, #116]	; 0x74
    50f8:	931c      	str	r3, [sp, #112]	; 0x70
    50fa:	f300 80a3 	bgt.w	5244 <_svfprintf_r+0x1cc>
    50fe:	f109 0908 	add.w	r9, r9, #8
    5102:	9b06      	ldr	r3, [sp, #24]
    5104:	442b      	add	r3, r5
    5106:	9306      	str	r3, [sp, #24]
    5108:	7823      	ldrb	r3, [r4, #0]
    510a:	2b00      	cmp	r3, #0
    510c:	f000 80a3 	beq.w	5256 <_svfprintf_r+0x1de>
    5110:	2300      	movs	r3, #0
    5112:	461a      	mov	r2, r3
    5114:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    5118:	4619      	mov	r1, r3
    511a:	9307      	str	r3, [sp, #28]
    511c:	469b      	mov	fp, r3
    511e:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    5122:	7863      	ldrb	r3, [r4, #1]
    5124:	f104 0a01 	add.w	sl, r4, #1
    5128:	4645      	mov	r5, r8
    512a:	f10a 0a01 	add.w	sl, sl, #1
    512e:	f1a3 0020 	sub.w	r0, r3, #32
    5132:	2858      	cmp	r0, #88	; 0x58
    5134:	f200 83f8 	bhi.w	5928 <_svfprintf_r+0x8b0>
    5138:	e8df f010 	tbh	[pc, r0, lsl #1]
    513c:	03f60363 	.word	0x03f60363
    5140:	036b03f6 	.word	0x036b03f6
    5144:	03f603f6 	.word	0x03f603f6
    5148:	03f603f6 	.word	0x03f603f6
    514c:	03f603f6 	.word	0x03f603f6
    5150:	037e0370 	.word	0x037e0370
    5154:	005d03f6 	.word	0x005d03f6
    5158:	03f600df 	.word	0x03f600df
    515c:	010c00fb 	.word	0x010c00fb
    5160:	010c010c 	.word	0x010c010c
    5164:	010c010c 	.word	0x010c010c
    5168:	010c010c 	.word	0x010c010c
    516c:	010c010c 	.word	0x010c010c
    5170:	03f603f6 	.word	0x03f603f6
    5174:	03f603f6 	.word	0x03f603f6
    5178:	03f603f6 	.word	0x03f603f6
    517c:	03f603f6 	.word	0x03f603f6
    5180:	03f603f6 	.word	0x03f603f6
    5184:	015e011c 	.word	0x015e011c
    5188:	015e03f6 	.word	0x015e03f6
    518c:	03f603f6 	.word	0x03f603f6
    5190:	03f603f6 	.word	0x03f603f6
    5194:	03f602a1 	.word	0x03f602a1
    5198:	02a603f6 	.word	0x02a603f6
    519c:	03f603f6 	.word	0x03f603f6
    51a0:	03f603f6 	.word	0x03f603f6
    51a4:	02d803f6 	.word	0x02d803f6
    51a8:	03f603f6 	.word	0x03f603f6
    51ac:	03f60305 	.word	0x03f60305
    51b0:	03f603f6 	.word	0x03f603f6
    51b4:	03f603f6 	.word	0x03f603f6
    51b8:	03f603f6 	.word	0x03f603f6
    51bc:	03f603f6 	.word	0x03f603f6
    51c0:	034303f6 	.word	0x034303f6
    51c4:	015e0356 	.word	0x015e0356
    51c8:	015e015e 	.word	0x015e015e
    51cc:	0356035e 	.word	0x0356035e
    51d0:	03f603f6 	.word	0x03f603f6
    51d4:	03f603a4 	.word	0x03f603a4
    51d8:	00a203b1 	.word	0x00a203b1
    51dc:	03c30062 	.word	0x03c30062
    51e0:	03c803f6 	.word	0x03c803f6
    51e4:	038303f6 	.word	0x038303f6
    51e8:	03f603f6 	.word	0x03f603f6
    51ec:	038b      	.short	0x038b
    51ee:	9807      	ldr	r0, [sp, #28]
    51f0:	9309      	str	r3, [sp, #36]	; 0x24
    51f2:	4240      	negs	r0, r0
    51f4:	9007      	str	r0, [sp, #28]
    51f6:	f04b 0b04 	orr.w	fp, fp, #4
    51fa:	f89a 3000 	ldrb.w	r3, [sl]
    51fe:	e794      	b.n	512a <_svfprintf_r+0xb2>
    5200:	46a8      	mov	r8, r5
    5202:	9809      	ldr	r0, [sp, #36]	; 0x24
    5204:	2100      	movs	r1, #0
    5206:	2330      	movs	r3, #48	; 0x30
    5208:	2278      	movs	r2, #120	; 0x78
    520a:	4588      	cmp	r8, r1
    520c:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    5210:	6804      	ldr	r4, [r0, #0]
    5212:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    5216:	f100 0704 	add.w	r7, r0, #4
    521a:	f04f 0500 	mov.w	r5, #0
    521e:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    5222:	f04b 0302 	orr.w	r3, fp, #2
    5226:	f2c0 839c 	blt.w	5962 <_svfprintf_r+0x8ea>
    522a:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    522e:	f043 0b02 	orr.w	fp, r3, #2
    5232:	ea54 0305 	orrs.w	r3, r4, r5
    5236:	9709      	str	r7, [sp, #36]	; 0x24
    5238:	f000 8369 	beq.w	590e <_svfprintf_r+0x896>
    523c:	460f      	mov	r7, r1
    523e:	920c      	str	r2, [sp, #48]	; 0x30
    5240:	4843      	ldr	r0, [pc, #268]	; (5350 <_svfprintf_r+0x2d8>)
    5242:	e2ae      	b.n	57a2 <_svfprintf_r+0x72a>
    5244:	aa1b      	add	r2, sp, #108	; 0x6c
    5246:	9903      	ldr	r1, [sp, #12]
    5248:	9805      	ldr	r0, [sp, #20]
    524a:	f001 f9cd 	bl	65e8 <__ssprint_r>
    524e:	b948      	cbnz	r0, 5264 <_svfprintf_r+0x1ec>
    5250:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5254:	e755      	b.n	5102 <_svfprintf_r+0x8a>
    5256:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5258:	b123      	cbz	r3, 5264 <_svfprintf_r+0x1ec>
    525a:	9805      	ldr	r0, [sp, #20]
    525c:	9903      	ldr	r1, [sp, #12]
    525e:	aa1b      	add	r2, sp, #108	; 0x6c
    5260:	f001 f9c2 	bl	65e8 <__ssprint_r>
    5264:	9b03      	ldr	r3, [sp, #12]
    5266:	899b      	ldrh	r3, [r3, #12]
    5268:	f013 0f40 	tst.w	r3, #64	; 0x40
    526c:	9b06      	ldr	r3, [sp, #24]
    526e:	bf18      	it	ne
    5270:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    5274:	4618      	mov	r0, r3
    5276:	b039      	add	sp, #228	; 0xe4
    5278:	ecbd 8b06 	vpop	{d8-d10}
    527c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5280:	930c      	str	r3, [sp, #48]	; 0x30
    5282:	46a8      	mov	r8, r5
    5284:	2a00      	cmp	r2, #0
    5286:	f041 819a 	bne.w	65be <_svfprintf_r+0x1546>
    528a:	f01b 0320 	ands.w	r3, fp, #32
    528e:	f000 8206 	beq.w	569e <_svfprintf_r+0x626>
    5292:	9f09      	ldr	r7, [sp, #36]	; 0x24
    5294:	3707      	adds	r7, #7
    5296:	f027 0307 	bic.w	r3, r7, #7
    529a:	2700      	movs	r7, #0
    529c:	f103 0208 	add.w	r2, r3, #8
    52a0:	45b8      	cmp	r8, r7
    52a2:	9209      	str	r2, [sp, #36]	; 0x24
    52a4:	e9d3 4500 	ldrd	r4, r5, [r3]
    52a8:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    52ac:	f2c0 865e 	blt.w	5f6c <_svfprintf_r+0xef4>
    52b0:	ea54 0305 	orrs.w	r3, r4, r5
    52b4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    52b8:	f000 834b 	beq.w	5952 <_svfprintf_r+0x8da>
    52bc:	ae28      	add	r6, sp, #160	; 0xa0
    52be:	08e2      	lsrs	r2, r4, #3
    52c0:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
    52c4:	08e9      	lsrs	r1, r5, #3
    52c6:	f004 0307 	and.w	r3, r4, #7
    52ca:	460d      	mov	r5, r1
    52cc:	4614      	mov	r4, r2
    52ce:	3330      	adds	r3, #48	; 0x30
    52d0:	ea54 0205 	orrs.w	r2, r4, r5
    52d4:	f806 3d01 	strb.w	r3, [r6, #-1]!
    52d8:	d1f1      	bne.n	52be <_svfprintf_r+0x246>
    52da:	f01b 0f01 	tst.w	fp, #1
    52de:	f000 8227 	beq.w	5730 <_svfprintf_r+0x6b8>
    52e2:	2b30      	cmp	r3, #48	; 0x30
    52e4:	f000 8224 	beq.w	5730 <_svfprintf_r+0x6b8>
    52e8:	2230      	movs	r2, #48	; 0x30
    52ea:	1e73      	subs	r3, r6, #1
    52ec:	f806 2c01 	strb.w	r2, [r6, #-1]
    52f0:	aa28      	add	r2, sp, #160	; 0xa0
    52f2:	1ad2      	subs	r2, r2, r3
    52f4:	9208      	str	r2, [sp, #32]
    52f6:	461e      	mov	r6, r3
    52f8:	e21d      	b.n	5736 <_svfprintf_r+0x6be>
    52fa:	f89a 3000 	ldrb.w	r3, [sl]
    52fe:	2b2a      	cmp	r3, #42	; 0x2a
    5300:	f10a 0401 	add.w	r4, sl, #1
    5304:	f001 812f 	beq.w	6566 <_svfprintf_r+0x14ee>
    5308:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    530c:	2809      	cmp	r0, #9
    530e:	bf98      	it	ls
    5310:	2500      	movls	r5, #0
    5312:	f201 80d5 	bhi.w	64c0 <_svfprintf_r+0x1448>
    5316:	f814 3b01 	ldrb.w	r3, [r4], #1
    531a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    531e:	eb00 0545 	add.w	r5, r0, r5, lsl #1
    5322:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    5326:	2809      	cmp	r0, #9
    5328:	d9f5      	bls.n	5316 <_svfprintf_r+0x29e>
    532a:	ea45 75e5 	orr.w	r5, r5, r5, asr #31
    532e:	46a2      	mov	sl, r4
    5330:	e6fd      	b.n	512e <_svfprintf_r+0xb6>
    5332:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
    5336:	f89a 3000 	ldrb.w	r3, [sl]
    533a:	e6f6      	b.n	512a <_svfprintf_r+0xb2>
    533c:	f3af 8000 	nop.w
	...
    5348:	ffffffff 	.word	0xffffffff
    534c:	7fefffff 	.word	0x7fefffff
    5350:	2000072c 	.word	0x2000072c
    5354:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    5358:	2300      	movs	r3, #0
    535a:	461c      	mov	r4, r3
    535c:	f81a 3b01 	ldrb.w	r3, [sl], #1
    5360:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    5364:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    5368:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    536c:	2809      	cmp	r0, #9
    536e:	d9f5      	bls.n	535c <_svfprintf_r+0x2e4>
    5370:	9407      	str	r4, [sp, #28]
    5372:	e6dc      	b.n	512e <_svfprintf_r+0xb6>
    5374:	930c      	str	r3, [sp, #48]	; 0x30
    5376:	46a8      	mov	r8, r5
    5378:	2a00      	cmp	r2, #0
    537a:	f041 812c 	bne.w	65d6 <_svfprintf_r+0x155e>
    537e:	f04b 0b10 	orr.w	fp, fp, #16
    5382:	f01b 0f20 	tst.w	fp, #32
    5386:	f000 8503 	beq.w	5d90 <_svfprintf_r+0xd18>
    538a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    538c:	3707      	adds	r7, #7
    538e:	f027 0707 	bic.w	r7, r7, #7
    5392:	e9d7 2300 	ldrd	r2, r3, [r7]
    5396:	f107 0108 	add.w	r1, r7, #8
    539a:	9109      	str	r1, [sp, #36]	; 0x24
    539c:	4614      	mov	r4, r2
    539e:	461d      	mov	r5, r3
    53a0:	2a00      	cmp	r2, #0
    53a2:	f173 0300 	sbcs.w	r3, r3, #0
    53a6:	f2c0 8537 	blt.w	5e18 <_svfprintf_r+0xda0>
    53aa:	f1b8 0f00 	cmp.w	r8, #0
    53ae:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    53b2:	f2c0 81b5 	blt.w	5720 <_svfprintf_r+0x6a8>
    53b6:	ea54 0305 	orrs.w	r3, r4, r5
    53ba:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    53be:	f000 83f6 	beq.w	5bae <_svfprintf_r+0xb36>
    53c2:	2d00      	cmp	r5, #0
    53c4:	bf08      	it	eq
    53c6:	2c0a      	cmpeq	r4, #10
    53c8:	f0c0 81ae 	bcc.w	5728 <_svfprintf_r+0x6b0>
    53cc:	ae28      	add	r6, sp, #160	; 0xa0
    53ce:	4620      	mov	r0, r4
    53d0:	4629      	mov	r1, r5
    53d2:	220a      	movs	r2, #10
    53d4:	2300      	movs	r3, #0
    53d6:	f7fd f8a3 	bl	2520 <__aeabi_uldivmod>
    53da:	3230      	adds	r2, #48	; 0x30
    53dc:	f806 2d01 	strb.w	r2, [r6, #-1]!
    53e0:	4620      	mov	r0, r4
    53e2:	4629      	mov	r1, r5
    53e4:	2300      	movs	r3, #0
    53e6:	220a      	movs	r2, #10
    53e8:	f7fd f89a 	bl	2520 <__aeabi_uldivmod>
    53ec:	4604      	mov	r4, r0
    53ee:	460d      	mov	r5, r1
    53f0:	ea54 0305 	orrs.w	r3, r4, r5
    53f4:	d1eb      	bne.n	53ce <_svfprintf_r+0x356>
    53f6:	e19b      	b.n	5730 <_svfprintf_r+0x6b8>
    53f8:	930c      	str	r3, [sp, #48]	; 0x30
    53fa:	46a8      	mov	r8, r5
    53fc:	2a00      	cmp	r2, #0
    53fe:	f041 80e6 	bne.w	65ce <_svfprintf_r+0x1556>
    5402:	9f09      	ldr	r7, [sp, #36]	; 0x24
    5404:	f01b 0f08 	tst.w	fp, #8
    5408:	f107 0707 	add.w	r7, r7, #7
    540c:	f000 8640 	beq.w	6090 <_svfprintf_r+0x1018>
    5410:	f027 0307 	bic.w	r3, r7, #7
    5414:	ed93 8b00 	vldr	d8, [r3]
    5418:	f103 0208 	add.w	r2, r3, #8
    541c:	9209      	str	r2, [sp, #36]	; 0x24
    541e:	eeb0 7bc8 	vabs.f64	d7, d8
    5422:	eeb4 7b49 	vcmp.f64	d7, d9
    5426:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    542a:	f340 85bc 	ble.w	5fa6 <_svfprintf_r+0xf2e>
    542e:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
    5432:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5436:	f100 87ca 	bmi.w	63ce <_svfprintf_r+0x1356>
    543a:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    543e:	4ea7      	ldr	r6, [pc, #668]	; (56dc <_svfprintf_r+0x664>)
    5440:	4ba7      	ldr	r3, [pc, #668]	; (56e0 <_svfprintf_r+0x668>)
    5442:	990c      	ldr	r1, [sp, #48]	; 0x30
    5444:	2203      	movs	r2, #3
    5446:	f04f 0800 	mov.w	r8, #0
    544a:	9204      	str	r2, [sp, #16]
    544c:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    5450:	2947      	cmp	r1, #71	; 0x47
    5452:	bfd8      	it	le
    5454:	461e      	movle	r6, r3
    5456:	9208      	str	r2, [sp, #32]
    5458:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    545c:	b117      	cbz	r7, 5464 <_svfprintf_r+0x3ec>
    545e:	9b04      	ldr	r3, [sp, #16]
    5460:	3301      	adds	r3, #1
    5462:	9304      	str	r3, [sp, #16]
    5464:	f01b 0302 	ands.w	r3, fp, #2
    5468:	930a      	str	r3, [sp, #40]	; 0x28
    546a:	d002      	beq.n	5472 <_svfprintf_r+0x3fa>
    546c:	9b04      	ldr	r3, [sp, #16]
    546e:	3302      	adds	r3, #2
    5470:	9304      	str	r3, [sp, #16]
    5472:	f01b 0384 	ands.w	r3, fp, #132	; 0x84
    5476:	930b      	str	r3, [sp, #44]	; 0x2c
    5478:	f040 8280 	bne.w	597c <_svfprintf_r+0x904>
    547c:	9b07      	ldr	r3, [sp, #28]
    547e:	9a04      	ldr	r2, [sp, #16]
    5480:	1a9c      	subs	r4, r3, r2
    5482:	2c00      	cmp	r4, #0
    5484:	f340 827a 	ble.w	597c <_svfprintf_r+0x904>
    5488:	2c10      	cmp	r4, #16
    548a:	991d      	ldr	r1, [sp, #116]	; 0x74
    548c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    548e:	4f95      	ldr	r7, [pc, #596]	; (56e4 <_svfprintf_r+0x66c>)
    5490:	dd23      	ble.n	54da <_svfprintf_r+0x462>
    5492:	4648      	mov	r0, r9
    5494:	2510      	movs	r5, #16
    5496:	46c1      	mov	r9, r8
    5498:	46b0      	mov	r8, r6
    549a:	9e05      	ldr	r6, [sp, #20]
    549c:	e004      	b.n	54a8 <_svfprintf_r+0x430>
    549e:	3c10      	subs	r4, #16
    54a0:	2c10      	cmp	r4, #16
    54a2:	f100 0008 	add.w	r0, r0, #8
    54a6:	dd15      	ble.n	54d4 <_svfprintf_r+0x45c>
    54a8:	3201      	adds	r2, #1
    54aa:	3110      	adds	r1, #16
    54ac:	2a07      	cmp	r2, #7
    54ae:	911d      	str	r1, [sp, #116]	; 0x74
    54b0:	921c      	str	r2, [sp, #112]	; 0x70
    54b2:	6007      	str	r7, [r0, #0]
    54b4:	6045      	str	r5, [r0, #4]
    54b6:	ddf2      	ble.n	549e <_svfprintf_r+0x426>
    54b8:	aa1b      	add	r2, sp, #108	; 0x6c
    54ba:	9903      	ldr	r1, [sp, #12]
    54bc:	4630      	mov	r0, r6
    54be:	f001 f893 	bl	65e8 <__ssprint_r>
    54c2:	2800      	cmp	r0, #0
    54c4:	f47f aece 	bne.w	5264 <_svfprintf_r+0x1ec>
    54c8:	3c10      	subs	r4, #16
    54ca:	2c10      	cmp	r4, #16
    54cc:	991d      	ldr	r1, [sp, #116]	; 0x74
    54ce:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    54d0:	a828      	add	r0, sp, #160	; 0xa0
    54d2:	dce9      	bgt.n	54a8 <_svfprintf_r+0x430>
    54d4:	4646      	mov	r6, r8
    54d6:	46c8      	mov	r8, r9
    54d8:	4681      	mov	r9, r0
    54da:	3201      	adds	r2, #1
    54dc:	1863      	adds	r3, r4, r1
    54de:	2a07      	cmp	r2, #7
    54e0:	931d      	str	r3, [sp, #116]	; 0x74
    54e2:	921c      	str	r2, [sp, #112]	; 0x70
    54e4:	f8c9 7000 	str.w	r7, [r9]
    54e8:	f8c9 4004 	str.w	r4, [r9, #4]
    54ec:	f300 83e2 	bgt.w	5cb4 <_svfprintf_r+0xc3c>
    54f0:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    54f4:	f109 0908 	add.w	r9, r9, #8
    54f8:	b177      	cbz	r7, 5518 <_svfprintf_r+0x4a0>
    54fa:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    54fc:	3201      	adds	r2, #1
    54fe:	3301      	adds	r3, #1
    5500:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
    5504:	2101      	movs	r1, #1
    5506:	2a07      	cmp	r2, #7
    5508:	931d      	str	r3, [sp, #116]	; 0x74
    550a:	921c      	str	r2, [sp, #112]	; 0x70
    550c:	e889 0003 	stmia.w	r9, {r0, r1}
    5510:	f300 835f 	bgt.w	5bd2 <_svfprintf_r+0xb5a>
    5514:	f109 0908 	add.w	r9, r9, #8
    5518:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    551a:	b16a      	cbz	r2, 5538 <_svfprintf_r+0x4c0>
    551c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    551e:	3201      	adds	r2, #1
    5520:	3302      	adds	r3, #2
    5522:	a814      	add	r0, sp, #80	; 0x50
    5524:	2102      	movs	r1, #2
    5526:	2a07      	cmp	r2, #7
    5528:	931d      	str	r3, [sp, #116]	; 0x74
    552a:	921c      	str	r2, [sp, #112]	; 0x70
    552c:	e889 0003 	stmia.w	r9, {r0, r1}
    5530:	f300 835b 	bgt.w	5bea <_svfprintf_r+0xb72>
    5534:	f109 0908 	add.w	r9, r9, #8
    5538:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    553a:	2a80      	cmp	r2, #128	; 0x80
    553c:	f000 827e 	beq.w	5a3c <_svfprintf_r+0x9c4>
    5540:	9a08      	ldr	r2, [sp, #32]
    5542:	ebc2 0408 	rsb	r4, r2, r8
    5546:	2c00      	cmp	r4, #0
    5548:	dd34      	ble.n	55b4 <_svfprintf_r+0x53c>
    554a:	2c10      	cmp	r4, #16
    554c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    554e:	4f66      	ldr	r7, [pc, #408]	; (56e8 <_svfprintf_r+0x670>)
    5550:	dd23      	ble.n	559a <_svfprintf_r+0x522>
    5552:	4649      	mov	r1, r9
    5554:	f04f 0810 	mov.w	r8, #16
    5558:	46b1      	mov	r9, r6
    555a:	9d05      	ldr	r5, [sp, #20]
    555c:	9e03      	ldr	r6, [sp, #12]
    555e:	e004      	b.n	556a <_svfprintf_r+0x4f2>
    5560:	3c10      	subs	r4, #16
    5562:	2c10      	cmp	r4, #16
    5564:	f101 0108 	add.w	r1, r1, #8
    5568:	dd15      	ble.n	5596 <_svfprintf_r+0x51e>
    556a:	3201      	adds	r2, #1
    556c:	3310      	adds	r3, #16
    556e:	2a07      	cmp	r2, #7
    5570:	931d      	str	r3, [sp, #116]	; 0x74
    5572:	921c      	str	r2, [sp, #112]	; 0x70
    5574:	e881 0180 	stmia.w	r1, {r7, r8}
    5578:	ddf2      	ble.n	5560 <_svfprintf_r+0x4e8>
    557a:	aa1b      	add	r2, sp, #108	; 0x6c
    557c:	4631      	mov	r1, r6
    557e:	4628      	mov	r0, r5
    5580:	f001 f832 	bl	65e8 <__ssprint_r>
    5584:	2800      	cmp	r0, #0
    5586:	f47f ae6d 	bne.w	5264 <_svfprintf_r+0x1ec>
    558a:	3c10      	subs	r4, #16
    558c:	2c10      	cmp	r4, #16
    558e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5590:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5592:	a928      	add	r1, sp, #160	; 0xa0
    5594:	dce9      	bgt.n	556a <_svfprintf_r+0x4f2>
    5596:	464e      	mov	r6, r9
    5598:	4689      	mov	r9, r1
    559a:	3201      	adds	r2, #1
    559c:	4423      	add	r3, r4
    559e:	2a07      	cmp	r2, #7
    55a0:	931d      	str	r3, [sp, #116]	; 0x74
    55a2:	921c      	str	r2, [sp, #112]	; 0x70
    55a4:	f8c9 7000 	str.w	r7, [r9]
    55a8:	f8c9 4004 	str.w	r4, [r9, #4]
    55ac:	f300 8305 	bgt.w	5bba <_svfprintf_r+0xb42>
    55b0:	f109 0908 	add.w	r9, r9, #8
    55b4:	f41b 7f80 	tst.w	fp, #256	; 0x100
    55b8:	f040 81e2 	bne.w	5980 <_svfprintf_r+0x908>
    55bc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    55be:	9808      	ldr	r0, [sp, #32]
    55c0:	f8c9 6000 	str.w	r6, [r9]
    55c4:	3201      	adds	r2, #1
    55c6:	4403      	add	r3, r0
    55c8:	2a07      	cmp	r2, #7
    55ca:	931d      	str	r3, [sp, #116]	; 0x74
    55cc:	f8c9 0004 	str.w	r0, [r9, #4]
    55d0:	921c      	str	r2, [sp, #112]	; 0x70
    55d2:	f300 82c2 	bgt.w	5b5a <_svfprintf_r+0xae2>
    55d6:	f109 0908 	add.w	r9, r9, #8
    55da:	f01b 0f04 	tst.w	fp, #4
    55de:	d03e      	beq.n	565e <_svfprintf_r+0x5e6>
    55e0:	9a07      	ldr	r2, [sp, #28]
    55e2:	9904      	ldr	r1, [sp, #16]
    55e4:	1a54      	subs	r4, r2, r1
    55e6:	2c00      	cmp	r4, #0
    55e8:	dd39      	ble.n	565e <_svfprintf_r+0x5e6>
    55ea:	2c10      	cmp	r4, #16
    55ec:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    55ee:	4f3d      	ldr	r7, [pc, #244]	; (56e4 <_svfprintf_r+0x66c>)
    55f0:	dd22      	ble.n	5638 <_svfprintf_r+0x5c0>
    55f2:	2510      	movs	r5, #16
    55f4:	9e05      	ldr	r6, [sp, #20]
    55f6:	f8dd 800c 	ldr.w	r8, [sp, #12]
    55fa:	e004      	b.n	5606 <_svfprintf_r+0x58e>
    55fc:	3c10      	subs	r4, #16
    55fe:	2c10      	cmp	r4, #16
    5600:	f109 0908 	add.w	r9, r9, #8
    5604:	dd18      	ble.n	5638 <_svfprintf_r+0x5c0>
    5606:	3201      	adds	r2, #1
    5608:	3310      	adds	r3, #16
    560a:	2a07      	cmp	r2, #7
    560c:	931d      	str	r3, [sp, #116]	; 0x74
    560e:	921c      	str	r2, [sp, #112]	; 0x70
    5610:	f8c9 7000 	str.w	r7, [r9]
    5614:	f8c9 5004 	str.w	r5, [r9, #4]
    5618:	ddf0      	ble.n	55fc <_svfprintf_r+0x584>
    561a:	aa1b      	add	r2, sp, #108	; 0x6c
    561c:	4641      	mov	r1, r8
    561e:	4630      	mov	r0, r6
    5620:	f000 ffe2 	bl	65e8 <__ssprint_r>
    5624:	2800      	cmp	r0, #0
    5626:	f47f ae1d 	bne.w	5264 <_svfprintf_r+0x1ec>
    562a:	3c10      	subs	r4, #16
    562c:	2c10      	cmp	r4, #16
    562e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5630:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5632:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5636:	dce6      	bgt.n	5606 <_svfprintf_r+0x58e>
    5638:	3201      	adds	r2, #1
    563a:	4423      	add	r3, r4
    563c:	2a07      	cmp	r2, #7
    563e:	931d      	str	r3, [sp, #116]	; 0x74
    5640:	921c      	str	r2, [sp, #112]	; 0x70
    5642:	f8c9 7000 	str.w	r7, [r9]
    5646:	f8c9 4004 	str.w	r4, [r9, #4]
    564a:	dd08      	ble.n	565e <_svfprintf_r+0x5e6>
    564c:	aa1b      	add	r2, sp, #108	; 0x6c
    564e:	9903      	ldr	r1, [sp, #12]
    5650:	9805      	ldr	r0, [sp, #20]
    5652:	f000 ffc9 	bl	65e8 <__ssprint_r>
    5656:	2800      	cmp	r0, #0
    5658:	f47f ae04 	bne.w	5264 <_svfprintf_r+0x1ec>
    565c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    565e:	9a06      	ldr	r2, [sp, #24]
    5660:	9907      	ldr	r1, [sp, #28]
    5662:	9804      	ldr	r0, [sp, #16]
    5664:	4281      	cmp	r1, r0
    5666:	bfac      	ite	ge
    5668:	1852      	addge	r2, r2, r1
    566a:	1812      	addlt	r2, r2, r0
    566c:	9206      	str	r2, [sp, #24]
    566e:	2b00      	cmp	r3, #0
    5670:	f040 827f 	bne.w	5b72 <_svfprintf_r+0xafa>
    5674:	2300      	movs	r3, #0
    5676:	931c      	str	r3, [sp, #112]	; 0x70
    5678:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    567c:	e522      	b.n	50c4 <_svfprintf_r+0x4c>
    567e:	f04b 0b08 	orr.w	fp, fp, #8
    5682:	f89a 3000 	ldrb.w	r3, [sl]
    5686:	e550      	b.n	512a <_svfprintf_r+0xb2>
    5688:	930c      	str	r3, [sp, #48]	; 0x30
    568a:	46a8      	mov	r8, r5
    568c:	2a00      	cmp	r2, #0
    568e:	f040 879a 	bne.w	65c6 <_svfprintf_r+0x154e>
    5692:	f04b 0b10 	orr.w	fp, fp, #16
    5696:	f01b 0320 	ands.w	r3, fp, #32
    569a:	f47f adfa 	bne.w	5292 <_svfprintf_r+0x21a>
    569e:	f01b 0210 	ands.w	r2, fp, #16
    56a2:	f040 8391 	bne.w	5dc8 <_svfprintf_r+0xd50>
    56a6:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    56aa:	f000 838d 	beq.w	5dc8 <_svfprintf_r+0xd50>
    56ae:	9909      	ldr	r1, [sp, #36]	; 0x24
    56b0:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    56b4:	460b      	mov	r3, r1
    56b6:	f1b8 0f00 	cmp.w	r8, #0
    56ba:	f103 0304 	add.w	r3, r3, #4
    56be:	880c      	ldrh	r4, [r1, #0]
    56c0:	f04f 0500 	mov.w	r5, #0
    56c4:	f2c0 85ab 	blt.w	621e <_svfprintf_r+0x11a6>
    56c8:	ea54 0105 	orrs.w	r1, r4, r5
    56cc:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    56d0:	9309      	str	r3, [sp, #36]	; 0x24
    56d2:	f000 813e 	beq.w	5952 <_svfprintf_r+0x8da>
    56d6:	4617      	mov	r7, r2
    56d8:	e5f0      	b.n	52bc <_svfprintf_r+0x244>
    56da:	bf00      	nop
    56dc:	2000070c 	.word	0x2000070c
    56e0:	20000708 	.word	0x20000708
    56e4:	200004a0 	.word	0x200004a0
    56e8:	200007e4 	.word	0x200007e4
    56ec:	930c      	str	r3, [sp, #48]	; 0x30
    56ee:	46a8      	mov	r8, r5
    56f0:	2a00      	cmp	r2, #0
    56f2:	f040 8759 	bne.w	65a8 <_svfprintf_r+0x1530>
    56f6:	f04b 0b10 	orr.w	fp, fp, #16
    56fa:	f01b 0320 	ands.w	r3, fp, #32
    56fe:	f000 82e7 	beq.w	5cd0 <_svfprintf_r+0xc58>
    5702:	9f09      	ldr	r7, [sp, #36]	; 0x24
    5704:	3707      	adds	r7, #7
    5706:	f027 0307 	bic.w	r3, r7, #7
    570a:	2700      	movs	r7, #0
    570c:	f103 0208 	add.w	r2, r3, #8
    5710:	45b8      	cmp	r8, r7
    5712:	9209      	str	r2, [sp, #36]	; 0x24
    5714:	e9d3 4500 	ldrd	r4, r5, [r3]
    5718:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    571c:	f6bf ae4b 	bge.w	53b6 <_svfprintf_r+0x33e>
    5720:	ea54 0305 	orrs.w	r3, r4, r5
    5724:	f47f ae4d 	bne.w	53c2 <_svfprintf_r+0x34a>
    5728:	ae38      	add	r6, sp, #224	; 0xe0
    572a:	3430      	adds	r4, #48	; 0x30
    572c:	f806 4d41 	strb.w	r4, [r6, #-65]!
    5730:	ab28      	add	r3, sp, #160	; 0xa0
    5732:	1b9b      	subs	r3, r3, r6
    5734:	9308      	str	r3, [sp, #32]
    5736:	9b08      	ldr	r3, [sp, #32]
    5738:	4543      	cmp	r3, r8
    573a:	bfb8      	it	lt
    573c:	4643      	movlt	r3, r8
    573e:	9304      	str	r3, [sp, #16]
    5740:	2300      	movs	r3, #0
    5742:	930e      	str	r3, [sp, #56]	; 0x38
    5744:	e68a      	b.n	545c <_svfprintf_r+0x3e4>
    5746:	930c      	str	r3, [sp, #48]	; 0x30
    5748:	46a8      	mov	r8, r5
    574a:	2a00      	cmp	r2, #0
    574c:	f040 8728 	bne.w	65a0 <_svfprintf_r+0x1528>
    5750:	f01b 0f20 	tst.w	fp, #32
    5754:	48c2      	ldr	r0, [pc, #776]	; (5a60 <_svfprintf_r+0x9e8>)
    5756:	f000 8086 	beq.w	5866 <_svfprintf_r+0x7ee>
    575a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    575c:	3707      	adds	r7, #7
    575e:	f027 0307 	bic.w	r3, r7, #7
    5762:	e9d3 4500 	ldrd	r4, r5, [r3]
    5766:	f103 0208 	add.w	r2, r3, #8
    576a:	9209      	str	r2, [sp, #36]	; 0x24
    576c:	f01b 0701 	ands.w	r7, fp, #1
    5770:	f000 8247 	beq.w	5c02 <_svfprintf_r+0xb8a>
    5774:	ea54 0305 	orrs.w	r3, r4, r5
    5778:	f000 84a3 	beq.w	60c2 <_svfprintf_r+0x104a>
    577c:	2700      	movs	r7, #0
    577e:	2330      	movs	r3, #48	; 0x30
    5780:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    5784:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
    5788:	45b8      	cmp	r8, r7
    578a:	f88d 2051 	strb.w	r2, [sp, #81]	; 0x51
    578e:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    5792:	f04b 0302 	orr.w	r3, fp, #2
    5796:	f2c0 8617 	blt.w	63c8 <_svfprintf_r+0x1350>
    579a:	f02b 0380 	bic.w	r3, fp, #128	; 0x80
    579e:	f043 0b02 	orr.w	fp, r3, #2
    57a2:	ae28      	add	r6, sp, #160	; 0xa0
    57a4:	0923      	lsrs	r3, r4, #4
    57a6:	f004 010f 	and.w	r1, r4, #15
    57aa:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
    57ae:	092a      	lsrs	r2, r5, #4
    57b0:	461c      	mov	r4, r3
    57b2:	4615      	mov	r5, r2
    57b4:	5c43      	ldrb	r3, [r0, r1]
    57b6:	f806 3d01 	strb.w	r3, [r6, #-1]!
    57ba:	ea54 0305 	orrs.w	r3, r4, r5
    57be:	d1f1      	bne.n	57a4 <_svfprintf_r+0x72c>
    57c0:	e7b6      	b.n	5730 <_svfprintf_r+0x6b8>
    57c2:	9909      	ldr	r1, [sp, #36]	; 0x24
    57c4:	930c      	str	r3, [sp, #48]	; 0x30
    57c6:	680a      	ldr	r2, [r1, #0]
    57c8:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    57cc:	2300      	movs	r3, #0
    57ce:	460a      	mov	r2, r1
    57d0:	461f      	mov	r7, r3
    57d2:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    57d6:	3204      	adds	r2, #4
    57d8:	2301      	movs	r3, #1
    57da:	9304      	str	r3, [sp, #16]
    57dc:	46b8      	mov	r8, r7
    57de:	970e      	str	r7, [sp, #56]	; 0x38
    57e0:	9209      	str	r2, [sp, #36]	; 0x24
    57e2:	9308      	str	r3, [sp, #32]
    57e4:	ae1e      	add	r6, sp, #120	; 0x78
    57e6:	e63d      	b.n	5464 <_svfprintf_r+0x3ec>
    57e8:	930c      	str	r3, [sp, #48]	; 0x30
    57ea:	46a8      	mov	r8, r5
    57ec:	2a00      	cmp	r2, #0
    57ee:	f43f adc8 	beq.w	5382 <_svfprintf_r+0x30a>
    57f2:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    57f6:	e5c4      	b.n	5382 <_svfprintf_r+0x30a>
    57f8:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
    57fc:	f89a 3000 	ldrb.w	r3, [sl]
    5800:	e493      	b.n	512a <_svfprintf_r+0xb2>
    5802:	f89a 3000 	ldrb.w	r3, [sl]
    5806:	2900      	cmp	r1, #0
    5808:	f47f ac8f 	bne.w	512a <_svfprintf_r+0xb2>
    580c:	2201      	movs	r2, #1
    580e:	2120      	movs	r1, #32
    5810:	e48b      	b.n	512a <_svfprintf_r+0xb2>
    5812:	f04b 0b01 	orr.w	fp, fp, #1
    5816:	f89a 3000 	ldrb.w	r3, [sl]
    581a:	e486      	b.n	512a <_svfprintf_r+0xb2>
    581c:	9c09      	ldr	r4, [sp, #36]	; 0x24
    581e:	6823      	ldr	r3, [r4, #0]
    5820:	9307      	str	r3, [sp, #28]
    5822:	4618      	mov	r0, r3
    5824:	2800      	cmp	r0, #0
    5826:	4623      	mov	r3, r4
    5828:	f103 0304 	add.w	r3, r3, #4
    582c:	f6ff acdf 	blt.w	51ee <_svfprintf_r+0x176>
    5830:	9309      	str	r3, [sp, #36]	; 0x24
    5832:	f89a 3000 	ldrb.w	r3, [sl]
    5836:	e478      	b.n	512a <_svfprintf_r+0xb2>
    5838:	f89a 3000 	ldrb.w	r3, [sl]
    583c:	2201      	movs	r2, #1
    583e:	212b      	movs	r1, #43	; 0x2b
    5840:	e473      	b.n	512a <_svfprintf_r+0xb2>
    5842:	930c      	str	r3, [sp, #48]	; 0x30
    5844:	46a8      	mov	r8, r5
    5846:	2a00      	cmp	r2, #0
    5848:	f43f af57 	beq.w	56fa <_svfprintf_r+0x682>
    584c:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    5850:	e753      	b.n	56fa <_svfprintf_r+0x682>
    5852:	930c      	str	r3, [sp, #48]	; 0x30
    5854:	46a8      	mov	r8, r5
    5856:	2a00      	cmp	r2, #0
    5858:	f040 86aa 	bne.w	65b0 <_svfprintf_r+0x1538>
    585c:	f01b 0f20 	tst.w	fp, #32
    5860:	4880      	ldr	r0, [pc, #512]	; (5a64 <_svfprintf_r+0x9ec>)
    5862:	f47f af7a 	bne.w	575a <_svfprintf_r+0x6e2>
    5866:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5868:	f01b 0f10 	tst.w	fp, #16
    586c:	4613      	mov	r3, r2
    586e:	f040 82c1 	bne.w	5df4 <_svfprintf_r+0xd7c>
    5872:	f01b 0f40 	tst.w	fp, #64	; 0x40
    5876:	f000 82bd 	beq.w	5df4 <_svfprintf_r+0xd7c>
    587a:	3304      	adds	r3, #4
    587c:	8814      	ldrh	r4, [r2, #0]
    587e:	9309      	str	r3, [sp, #36]	; 0x24
    5880:	2500      	movs	r5, #0
    5882:	e773      	b.n	576c <_svfprintf_r+0x6f4>
    5884:	f89a 3000 	ldrb.w	r3, [sl]
    5888:	2b6c      	cmp	r3, #108	; 0x6c
    588a:	bf03      	ittte	eq
    588c:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
    5890:	f04b 0b20 	orreq.w	fp, fp, #32
    5894:	f10a 0a01 	addeq.w	sl, sl, #1
    5898:	f04b 0b10 	orrne.w	fp, fp, #16
    589c:	e445      	b.n	512a <_svfprintf_r+0xb2>
    589e:	2a00      	cmp	r2, #0
    58a0:	f040 866f 	bne.w	6582 <_svfprintf_r+0x150a>
    58a4:	f01b 0f20 	tst.w	fp, #32
    58a8:	f000 8366 	beq.w	5f78 <_svfprintf_r+0xf00>
    58ac:	9a09      	ldr	r2, [sp, #36]	; 0x24
    58ae:	9906      	ldr	r1, [sp, #24]
    58b0:	6813      	ldr	r3, [r2, #0]
    58b2:	17cd      	asrs	r5, r1, #31
    58b4:	4608      	mov	r0, r1
    58b6:	3204      	adds	r2, #4
    58b8:	4629      	mov	r1, r5
    58ba:	9209      	str	r2, [sp, #36]	; 0x24
    58bc:	e9c3 0100 	strd	r0, r1, [r3]
    58c0:	e400      	b.n	50c4 <_svfprintf_r+0x4c>
    58c2:	f04b 0b20 	orr.w	fp, fp, #32
    58c6:	f89a 3000 	ldrb.w	r3, [sl]
    58ca:	e42e      	b.n	512a <_svfprintf_r+0xb2>
    58cc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    58ce:	930c      	str	r3, [sp, #48]	; 0x30
    58d0:	6816      	ldr	r6, [r2, #0]
    58d2:	2400      	movs	r4, #0
    58d4:	f88d 404f 	strb.w	r4, [sp, #79]	; 0x4f
    58d8:	1d17      	adds	r7, r2, #4
    58da:	2e00      	cmp	r6, #0
    58dc:	f000 8565 	beq.w	63aa <_svfprintf_r+0x1332>
    58e0:	2d00      	cmp	r5, #0
    58e2:	f2c0 84a2 	blt.w	622a <_svfprintf_r+0x11b2>
    58e6:	462a      	mov	r2, r5
    58e8:	4621      	mov	r1, r4
    58ea:	4630      	mov	r0, r6
    58ec:	f7fe f928 	bl	3b40 <memchr>
    58f0:	2800      	cmp	r0, #0
    58f2:	f000 85cc 	beq.w	648e <_svfprintf_r+0x1416>
    58f6:	1b83      	subs	r3, r0, r6
    58f8:	9308      	str	r3, [sp, #32]
    58fa:	46a0      	mov	r8, r4
    58fc:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    5900:	9709      	str	r7, [sp, #36]	; 0x24
    5902:	9304      	str	r3, [sp, #16]
    5904:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5908:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    590c:	e5a6      	b.n	545c <_svfprintf_r+0x3e4>
    590e:	4855      	ldr	r0, [pc, #340]	; (5a64 <_svfprintf_r+0x9ec>)
    5910:	920c      	str	r2, [sp, #48]	; 0x30
    5912:	f1b8 0f00 	cmp.w	r8, #0
    5916:	f040 8184 	bne.w	5c22 <_svfprintf_r+0xbaa>
    591a:	4647      	mov	r7, r8
    591c:	f04f 0800 	mov.w	r8, #0
    5920:	f8cd 8020 	str.w	r8, [sp, #32]
    5924:	ae28      	add	r6, sp, #160	; 0xa0
    5926:	e706      	b.n	5736 <_svfprintf_r+0x6be>
    5928:	930c      	str	r3, [sp, #48]	; 0x30
    592a:	2a00      	cmp	r2, #0
    592c:	f040 862d 	bne.w	658a <_svfprintf_r+0x1512>
    5930:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    5932:	2a00      	cmp	r2, #0
    5934:	f43f ac8f 	beq.w	5256 <_svfprintf_r+0x1de>
    5938:	2300      	movs	r3, #0
    593a:	2101      	movs	r1, #1
    593c:	461f      	mov	r7, r3
    593e:	9104      	str	r1, [sp, #16]
    5940:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
    5944:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    5948:	4698      	mov	r8, r3
    594a:	930e      	str	r3, [sp, #56]	; 0x38
    594c:	9108      	str	r1, [sp, #32]
    594e:	ae1e      	add	r6, sp, #120	; 0x78
    5950:	e588      	b.n	5464 <_svfprintf_r+0x3ec>
    5952:	f1b8 0f00 	cmp.w	r8, #0
    5956:	f000 858b 	beq.w	6470 <_svfprintf_r+0x13f8>
    595a:	2700      	movs	r7, #0
    595c:	2400      	movs	r4, #0
    595e:	2500      	movs	r5, #0
    5960:	e4ac      	b.n	52bc <_svfprintf_r+0x244>
    5962:	4840      	ldr	r0, [pc, #256]	; (5a64 <_svfprintf_r+0x9ec>)
    5964:	920c      	str	r2, [sp, #48]	; 0x30
    5966:	469b      	mov	fp, r3
    5968:	ea54 0305 	orrs.w	r3, r4, r5
    596c:	9709      	str	r7, [sp, #36]	; 0x24
    596e:	f04f 0700 	mov.w	r7, #0
    5972:	f47f af16 	bne.w	57a2 <_svfprintf_r+0x72a>
    5976:	2400      	movs	r4, #0
    5978:	2500      	movs	r5, #0
    597a:	e712      	b.n	57a2 <_svfprintf_r+0x72a>
    597c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    597e:	e5bb      	b.n	54f8 <_svfprintf_r+0x480>
    5980:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    5982:	2a65      	cmp	r2, #101	; 0x65
    5984:	f340 80a1 	ble.w	5aca <_svfprintf_r+0xa52>
    5988:	eeb5 8b40 	vcmp.f64	d8, #0.0
    598c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5990:	f040 8149 	bne.w	5c26 <_svfprintf_r+0xbae>
    5994:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5996:	4934      	ldr	r1, [pc, #208]	; (5a68 <_svfprintf_r+0x9f0>)
    5998:	f8c9 1000 	str.w	r1, [r9]
    599c:	3201      	adds	r2, #1
    599e:	3301      	adds	r3, #1
    59a0:	2101      	movs	r1, #1
    59a2:	2a07      	cmp	r2, #7
    59a4:	931d      	str	r3, [sp, #116]	; 0x74
    59a6:	921c      	str	r2, [sp, #112]	; 0x70
    59a8:	f8c9 1004 	str.w	r1, [r9, #4]
    59ac:	f300 8392 	bgt.w	60d4 <_svfprintf_r+0x105c>
    59b0:	f109 0908 	add.w	r9, r9, #8
    59b4:	9a15      	ldr	r2, [sp, #84]	; 0x54
    59b6:	990d      	ldr	r1, [sp, #52]	; 0x34
    59b8:	428a      	cmp	r2, r1
    59ba:	db03      	blt.n	59c4 <_svfprintf_r+0x94c>
    59bc:	f01b 0f01 	tst.w	fp, #1
    59c0:	f43f ae0b 	beq.w	55da <_svfprintf_r+0x562>
    59c4:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    59c6:	980f      	ldr	r0, [sp, #60]	; 0x3c
    59c8:	9910      	ldr	r1, [sp, #64]	; 0x40
    59ca:	f8c9 1000 	str.w	r1, [r9]
    59ce:	3201      	adds	r2, #1
    59d0:	4403      	add	r3, r0
    59d2:	2a07      	cmp	r2, #7
    59d4:	931d      	str	r3, [sp, #116]	; 0x74
    59d6:	f8c9 0004 	str.w	r0, [r9, #4]
    59da:	921c      	str	r2, [sp, #112]	; 0x70
    59dc:	f300 83d6 	bgt.w	618c <_svfprintf_r+0x1114>
    59e0:	f109 0908 	add.w	r9, r9, #8
    59e4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    59e6:	1e54      	subs	r4, r2, #1
    59e8:	2c00      	cmp	r4, #0
    59ea:	f77f adf6 	ble.w	55da <_svfprintf_r+0x562>
    59ee:	2c10      	cmp	r4, #16
    59f0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    59f2:	4f1e      	ldr	r7, [pc, #120]	; (5a6c <_svfprintf_r+0x9f4>)
    59f4:	f340 81dc 	ble.w	5db0 <_svfprintf_r+0xd38>
    59f8:	2510      	movs	r5, #16
    59fa:	9e05      	ldr	r6, [sp, #20]
    59fc:	f8dd 800c 	ldr.w	r8, [sp, #12]
    5a00:	e005      	b.n	5a0e <_svfprintf_r+0x996>
    5a02:	f109 0908 	add.w	r9, r9, #8
    5a06:	3c10      	subs	r4, #16
    5a08:	2c10      	cmp	r4, #16
    5a0a:	f340 81d1 	ble.w	5db0 <_svfprintf_r+0xd38>
    5a0e:	3201      	adds	r2, #1
    5a10:	3310      	adds	r3, #16
    5a12:	2a07      	cmp	r2, #7
    5a14:	931d      	str	r3, [sp, #116]	; 0x74
    5a16:	921c      	str	r2, [sp, #112]	; 0x70
    5a18:	f8c9 7000 	str.w	r7, [r9]
    5a1c:	f8c9 5004 	str.w	r5, [r9, #4]
    5a20:	ddef      	ble.n	5a02 <_svfprintf_r+0x98a>
    5a22:	aa1b      	add	r2, sp, #108	; 0x6c
    5a24:	4641      	mov	r1, r8
    5a26:	4630      	mov	r0, r6
    5a28:	f000 fdde 	bl	65e8 <__ssprint_r>
    5a2c:	2800      	cmp	r0, #0
    5a2e:	f47f ac19 	bne.w	5264 <_svfprintf_r+0x1ec>
    5a32:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5a34:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5a36:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5a3a:	e7e4      	b.n	5a06 <_svfprintf_r+0x98e>
    5a3c:	9a07      	ldr	r2, [sp, #28]
    5a3e:	9904      	ldr	r1, [sp, #16]
    5a40:	1a54      	subs	r4, r2, r1
    5a42:	2c00      	cmp	r4, #0
    5a44:	f77f ad7c 	ble.w	5540 <_svfprintf_r+0x4c8>
    5a48:	2c10      	cmp	r4, #16
    5a4a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5a4c:	4f07      	ldr	r7, [pc, #28]	; (5a6c <_svfprintf_r+0x9f4>)
    5a4e:	dd2e      	ble.n	5aae <_svfprintf_r+0xa36>
    5a50:	4649      	mov	r1, r9
    5a52:	2510      	movs	r5, #16
    5a54:	46c1      	mov	r9, r8
    5a56:	4618      	mov	r0, r3
    5a58:	46b0      	mov	r8, r6
    5a5a:	9e05      	ldr	r6, [sp, #20]
    5a5c:	e00d      	b.n	5a7a <_svfprintf_r+0xa02>
    5a5e:	bf00      	nop
    5a60:	20000718 	.word	0x20000718
    5a64:	2000072c 	.word	0x2000072c
    5a68:	20000704 	.word	0x20000704
    5a6c:	200007e4 	.word	0x200007e4
    5a70:	3c10      	subs	r4, #16
    5a72:	2c10      	cmp	r4, #16
    5a74:	f101 0108 	add.w	r1, r1, #8
    5a78:	dd15      	ble.n	5aa6 <_svfprintf_r+0xa2e>
    5a7a:	3201      	adds	r2, #1
    5a7c:	3010      	adds	r0, #16
    5a7e:	2a07      	cmp	r2, #7
    5a80:	901d      	str	r0, [sp, #116]	; 0x74
    5a82:	921c      	str	r2, [sp, #112]	; 0x70
    5a84:	600f      	str	r7, [r1, #0]
    5a86:	604d      	str	r5, [r1, #4]
    5a88:	ddf2      	ble.n	5a70 <_svfprintf_r+0x9f8>
    5a8a:	aa1b      	add	r2, sp, #108	; 0x6c
    5a8c:	9903      	ldr	r1, [sp, #12]
    5a8e:	4630      	mov	r0, r6
    5a90:	f000 fdaa 	bl	65e8 <__ssprint_r>
    5a94:	2800      	cmp	r0, #0
    5a96:	f47f abe5 	bne.w	5264 <_svfprintf_r+0x1ec>
    5a9a:	3c10      	subs	r4, #16
    5a9c:	2c10      	cmp	r4, #16
    5a9e:	981d      	ldr	r0, [sp, #116]	; 0x74
    5aa0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5aa2:	a928      	add	r1, sp, #160	; 0xa0
    5aa4:	dce9      	bgt.n	5a7a <_svfprintf_r+0xa02>
    5aa6:	4646      	mov	r6, r8
    5aa8:	4603      	mov	r3, r0
    5aaa:	46c8      	mov	r8, r9
    5aac:	4689      	mov	r9, r1
    5aae:	3201      	adds	r2, #1
    5ab0:	4423      	add	r3, r4
    5ab2:	2a07      	cmp	r2, #7
    5ab4:	931d      	str	r3, [sp, #116]	; 0x74
    5ab6:	921c      	str	r2, [sp, #112]	; 0x70
    5ab8:	f8c9 7000 	str.w	r7, [r9]
    5abc:	f8c9 4004 	str.w	r4, [r9, #4]
    5ac0:	f300 8246 	bgt.w	5f50 <_svfprintf_r+0xed8>
    5ac4:	f109 0908 	add.w	r9, r9, #8
    5ac8:	e53a      	b.n	5540 <_svfprintf_r+0x4c8>
    5aca:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    5acc:	f8c9 6000 	str.w	r6, [r9]
    5ad0:	2a01      	cmp	r2, #1
    5ad2:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5ad4:	f103 0301 	add.w	r3, r3, #1
    5ad8:	f102 0201 	add.w	r2, r2, #1
    5adc:	f04f 0101 	mov.w	r1, #1
    5ae0:	931d      	str	r3, [sp, #116]	; 0x74
    5ae2:	921c      	str	r2, [sp, #112]	; 0x70
    5ae4:	f8c9 1004 	str.w	r1, [r9, #4]
    5ae8:	f340 8210 	ble.w	5f0c <_svfprintf_r+0xe94>
    5aec:	2a07      	cmp	r2, #7
    5aee:	f300 8215 	bgt.w	5f1c <_svfprintf_r+0xea4>
    5af2:	f109 0908 	add.w	r9, r9, #8
    5af6:	980f      	ldr	r0, [sp, #60]	; 0x3c
    5af8:	9910      	ldr	r1, [sp, #64]	; 0x40
    5afa:	f8c9 1000 	str.w	r1, [r9]
    5afe:	3201      	adds	r2, #1
    5b00:	4403      	add	r3, r0
    5b02:	2a07      	cmp	r2, #7
    5b04:	931d      	str	r3, [sp, #116]	; 0x74
    5b06:	921c      	str	r2, [sp, #112]	; 0x70
    5b08:	f8c9 0004 	str.w	r0, [r9, #4]
    5b0c:	f300 8213 	bgt.w	5f36 <_svfprintf_r+0xebe>
    5b10:	f109 0908 	add.w	r9, r9, #8
    5b14:	eeb5 8b40 	vcmp.f64	d8, #0.0
    5b18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5b1c:	990d      	ldr	r1, [sp, #52]	; 0x34
    5b1e:	f000 80f5 	beq.w	5d0c <_svfprintf_r+0xc94>
    5b22:	3901      	subs	r1, #1
    5b24:	3201      	adds	r2, #1
    5b26:	3601      	adds	r6, #1
    5b28:	440b      	add	r3, r1
    5b2a:	2a07      	cmp	r2, #7
    5b2c:	f8c9 6000 	str.w	r6, [r9]
    5b30:	921c      	str	r2, [sp, #112]	; 0x70
    5b32:	931d      	str	r3, [sp, #116]	; 0x74
    5b34:	f8c9 1004 	str.w	r1, [r9, #4]
    5b38:	f300 811d 	bgt.w	5d76 <_svfprintf_r+0xcfe>
    5b3c:	f109 0908 	add.w	r9, r9, #8
    5b40:	9811      	ldr	r0, [sp, #68]	; 0x44
    5b42:	f8c9 0004 	str.w	r0, [r9, #4]
    5b46:	3201      	adds	r2, #1
    5b48:	4403      	add	r3, r0
    5b4a:	a917      	add	r1, sp, #92	; 0x5c
    5b4c:	2a07      	cmp	r2, #7
    5b4e:	931d      	str	r3, [sp, #116]	; 0x74
    5b50:	921c      	str	r2, [sp, #112]	; 0x70
    5b52:	f8c9 1000 	str.w	r1, [r9]
    5b56:	f77f ad3e 	ble.w	55d6 <_svfprintf_r+0x55e>
    5b5a:	aa1b      	add	r2, sp, #108	; 0x6c
    5b5c:	9903      	ldr	r1, [sp, #12]
    5b5e:	9805      	ldr	r0, [sp, #20]
    5b60:	f000 fd42 	bl	65e8 <__ssprint_r>
    5b64:	2800      	cmp	r0, #0
    5b66:	f47f ab7d 	bne.w	5264 <_svfprintf_r+0x1ec>
    5b6a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5b6c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5b70:	e533      	b.n	55da <_svfprintf_r+0x562>
    5b72:	aa1b      	add	r2, sp, #108	; 0x6c
    5b74:	9903      	ldr	r1, [sp, #12]
    5b76:	9805      	ldr	r0, [sp, #20]
    5b78:	f000 fd36 	bl	65e8 <__ssprint_r>
    5b7c:	2800      	cmp	r0, #0
    5b7e:	f43f ad79 	beq.w	5674 <_svfprintf_r+0x5fc>
    5b82:	f7ff bb6f 	b.w	5264 <_svfprintf_r+0x1ec>
    5b86:	9909      	ldr	r1, [sp, #36]	; 0x24
    5b88:	f1b8 0f00 	cmp.w	r8, #0
    5b8c:	680c      	ldr	r4, [r1, #0]
    5b8e:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    5b92:	f101 0704 	add.w	r7, r1, #4
    5b96:	f04f 0500 	mov.w	r5, #0
    5b9a:	f2c0 8371 	blt.w	6280 <_svfprintf_r+0x1208>
    5b9e:	ea54 0205 	orrs.w	r2, r4, r5
    5ba2:	9709      	str	r7, [sp, #36]	; 0x24
    5ba4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    5ba8:	461f      	mov	r7, r3
    5baa:	f47f ac0a 	bne.w	53c2 <_svfprintf_r+0x34a>
    5bae:	f1b8 0f00 	cmp.w	r8, #0
    5bb2:	f43f aeb3 	beq.w	591c <_svfprintf_r+0x8a4>
    5bb6:	2400      	movs	r4, #0
    5bb8:	e5b6      	b.n	5728 <_svfprintf_r+0x6b0>
    5bba:	aa1b      	add	r2, sp, #108	; 0x6c
    5bbc:	9903      	ldr	r1, [sp, #12]
    5bbe:	9805      	ldr	r0, [sp, #20]
    5bc0:	f000 fd12 	bl	65e8 <__ssprint_r>
    5bc4:	2800      	cmp	r0, #0
    5bc6:	f47f ab4d 	bne.w	5264 <_svfprintf_r+0x1ec>
    5bca:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5bcc:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5bd0:	e4f0      	b.n	55b4 <_svfprintf_r+0x53c>
    5bd2:	aa1b      	add	r2, sp, #108	; 0x6c
    5bd4:	9903      	ldr	r1, [sp, #12]
    5bd6:	9805      	ldr	r0, [sp, #20]
    5bd8:	f000 fd06 	bl	65e8 <__ssprint_r>
    5bdc:	2800      	cmp	r0, #0
    5bde:	f47f ab41 	bne.w	5264 <_svfprintf_r+0x1ec>
    5be2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5be4:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5be8:	e496      	b.n	5518 <_svfprintf_r+0x4a0>
    5bea:	aa1b      	add	r2, sp, #108	; 0x6c
    5bec:	9903      	ldr	r1, [sp, #12]
    5bee:	9805      	ldr	r0, [sp, #20]
    5bf0:	f000 fcfa 	bl	65e8 <__ssprint_r>
    5bf4:	2800      	cmp	r0, #0
    5bf6:	f47f ab35 	bne.w	5264 <_svfprintf_r+0x1ec>
    5bfa:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5bfc:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5c00:	e49a      	b.n	5538 <_svfprintf_r+0x4c0>
    5c02:	f1b8 0f00 	cmp.w	r8, #0
    5c06:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    5c0a:	f2c0 826f 	blt.w	60ec <_svfprintf_r+0x1074>
    5c0e:	ea54 0305 	orrs.w	r3, r4, r5
    5c12:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    5c16:	f47f adc4 	bne.w	57a2 <_svfprintf_r+0x72a>
    5c1a:	f1b8 0f00 	cmp.w	r8, #0
    5c1e:	f43f ae7c 	beq.w	591a <_svfprintf_r+0x8a2>
    5c22:	2700      	movs	r7, #0
    5c24:	e6a7      	b.n	5976 <_svfprintf_r+0x8fe>
    5c26:	9c15      	ldr	r4, [sp, #84]	; 0x54
    5c28:	2c00      	cmp	r4, #0
    5c2a:	f340 8261 	ble.w	60f0 <_svfprintf_r+0x1078>
    5c2e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    5c30:	990d      	ldr	r1, [sp, #52]	; 0x34
    5c32:	428a      	cmp	r2, r1
    5c34:	bfa8      	it	ge
    5c36:	460a      	movge	r2, r1
    5c38:	2a00      	cmp	r2, #0
    5c3a:	4614      	mov	r4, r2
    5c3c:	dd0d      	ble.n	5c5a <_svfprintf_r+0xbe2>
    5c3e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5c40:	f8c9 6000 	str.w	r6, [r9]
    5c44:	3201      	adds	r2, #1
    5c46:	4423      	add	r3, r4
    5c48:	2a07      	cmp	r2, #7
    5c4a:	931d      	str	r3, [sp, #116]	; 0x74
    5c4c:	f8c9 4004 	str.w	r4, [r9, #4]
    5c50:	921c      	str	r2, [sp, #112]	; 0x70
    5c52:	f300 8372 	bgt.w	633a <_svfprintf_r+0x12c2>
    5c56:	f109 0908 	add.w	r9, r9, #8
    5c5a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    5c5c:	2c00      	cmp	r4, #0
    5c5e:	bfa8      	it	ge
    5c60:	1b12      	subge	r2, r2, r4
    5c62:	2a00      	cmp	r2, #0
    5c64:	4614      	mov	r4, r2
    5c66:	f340 80f1 	ble.w	5e4c <_svfprintf_r+0xdd4>
    5c6a:	2c10      	cmp	r4, #16
    5c6c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5c6e:	4fc1      	ldr	r7, [pc, #772]	; (5f74 <_svfprintf_r+0xefc>)
    5c70:	f340 8219 	ble.w	60a6 <_svfprintf_r+0x102e>
    5c74:	4649      	mov	r1, r9
    5c76:	2510      	movs	r5, #16
    5c78:	46b1      	mov	r9, r6
    5c7a:	f8dd 8014 	ldr.w	r8, [sp, #20]
    5c7e:	9e03      	ldr	r6, [sp, #12]
    5c80:	e004      	b.n	5c8c <_svfprintf_r+0xc14>
    5c82:	3108      	adds	r1, #8
    5c84:	3c10      	subs	r4, #16
    5c86:	2c10      	cmp	r4, #16
    5c88:	f340 820b 	ble.w	60a2 <_svfprintf_r+0x102a>
    5c8c:	3201      	adds	r2, #1
    5c8e:	3310      	adds	r3, #16
    5c90:	2a07      	cmp	r2, #7
    5c92:	931d      	str	r3, [sp, #116]	; 0x74
    5c94:	921c      	str	r2, [sp, #112]	; 0x70
    5c96:	600f      	str	r7, [r1, #0]
    5c98:	604d      	str	r5, [r1, #4]
    5c9a:	ddf2      	ble.n	5c82 <_svfprintf_r+0xc0a>
    5c9c:	aa1b      	add	r2, sp, #108	; 0x6c
    5c9e:	4631      	mov	r1, r6
    5ca0:	4640      	mov	r0, r8
    5ca2:	f000 fca1 	bl	65e8 <__ssprint_r>
    5ca6:	2800      	cmp	r0, #0
    5ca8:	f47f aadc 	bne.w	5264 <_svfprintf_r+0x1ec>
    5cac:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5cae:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5cb0:	a928      	add	r1, sp, #160	; 0xa0
    5cb2:	e7e7      	b.n	5c84 <_svfprintf_r+0xc0c>
    5cb4:	aa1b      	add	r2, sp, #108	; 0x6c
    5cb6:	9903      	ldr	r1, [sp, #12]
    5cb8:	9805      	ldr	r0, [sp, #20]
    5cba:	f000 fc95 	bl	65e8 <__ssprint_r>
    5cbe:	2800      	cmp	r0, #0
    5cc0:	f47f aad0 	bne.w	5264 <_svfprintf_r+0x1ec>
    5cc4:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    5cc8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5cca:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5cce:	e413      	b.n	54f8 <_svfprintf_r+0x480>
    5cd0:	f01b 0210 	ands.w	r2, fp, #16
    5cd4:	f47f af57 	bne.w	5b86 <_svfprintf_r+0xb0e>
    5cd8:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
    5cdc:	f43f af53 	beq.w	5b86 <_svfprintf_r+0xb0e>
    5ce0:	9909      	ldr	r1, [sp, #36]	; 0x24
    5ce2:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
    5ce6:	460b      	mov	r3, r1
    5ce8:	f1b8 0f00 	cmp.w	r8, #0
    5cec:	f103 0304 	add.w	r3, r3, #4
    5cf0:	880c      	ldrh	r4, [r1, #0]
    5cf2:	f04f 0500 	mov.w	r5, #0
    5cf6:	f2c0 8294 	blt.w	6222 <_svfprintf_r+0x11aa>
    5cfa:	ea54 0105 	orrs.w	r1, r4, r5
    5cfe:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    5d02:	9309      	str	r3, [sp, #36]	; 0x24
    5d04:	4617      	mov	r7, r2
    5d06:	f47f ab5c 	bne.w	53c2 <_svfprintf_r+0x34a>
    5d0a:	e750      	b.n	5bae <_svfprintf_r+0xb36>
    5d0c:	1e4c      	subs	r4, r1, #1
    5d0e:	2c00      	cmp	r4, #0
    5d10:	f77f af16 	ble.w	5b40 <_svfprintf_r+0xac8>
    5d14:	2c10      	cmp	r4, #16
    5d16:	4f97      	ldr	r7, [pc, #604]	; (5f74 <_svfprintf_r+0xefc>)
    5d18:	dd22      	ble.n	5d60 <_svfprintf_r+0xce8>
    5d1a:	2510      	movs	r5, #16
    5d1c:	9e05      	ldr	r6, [sp, #20]
    5d1e:	f8dd 800c 	ldr.w	r8, [sp, #12]
    5d22:	e004      	b.n	5d2e <_svfprintf_r+0xcb6>
    5d24:	3c10      	subs	r4, #16
    5d26:	2c10      	cmp	r4, #16
    5d28:	f109 0908 	add.w	r9, r9, #8
    5d2c:	dd18      	ble.n	5d60 <_svfprintf_r+0xce8>
    5d2e:	3201      	adds	r2, #1
    5d30:	3310      	adds	r3, #16
    5d32:	2a07      	cmp	r2, #7
    5d34:	931d      	str	r3, [sp, #116]	; 0x74
    5d36:	921c      	str	r2, [sp, #112]	; 0x70
    5d38:	f8c9 7000 	str.w	r7, [r9]
    5d3c:	f8c9 5004 	str.w	r5, [r9, #4]
    5d40:	ddf0      	ble.n	5d24 <_svfprintf_r+0xcac>
    5d42:	aa1b      	add	r2, sp, #108	; 0x6c
    5d44:	4641      	mov	r1, r8
    5d46:	4630      	mov	r0, r6
    5d48:	f000 fc4e 	bl	65e8 <__ssprint_r>
    5d4c:	2800      	cmp	r0, #0
    5d4e:	f47f aa89 	bne.w	5264 <_svfprintf_r+0x1ec>
    5d52:	3c10      	subs	r4, #16
    5d54:	2c10      	cmp	r4, #16
    5d56:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5d58:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5d5a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5d5e:	dce6      	bgt.n	5d2e <_svfprintf_r+0xcb6>
    5d60:	3201      	adds	r2, #1
    5d62:	4423      	add	r3, r4
    5d64:	2a07      	cmp	r2, #7
    5d66:	931d      	str	r3, [sp, #116]	; 0x74
    5d68:	921c      	str	r2, [sp, #112]	; 0x70
    5d6a:	f8c9 7000 	str.w	r7, [r9]
    5d6e:	f8c9 4004 	str.w	r4, [r9, #4]
    5d72:	f77f aee3 	ble.w	5b3c <_svfprintf_r+0xac4>
    5d76:	aa1b      	add	r2, sp, #108	; 0x6c
    5d78:	9903      	ldr	r1, [sp, #12]
    5d7a:	9805      	ldr	r0, [sp, #20]
    5d7c:	f000 fc34 	bl	65e8 <__ssprint_r>
    5d80:	2800      	cmp	r0, #0
    5d82:	f47f aa6f 	bne.w	5264 <_svfprintf_r+0x1ec>
    5d86:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5d88:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5d8a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5d8e:	e6d7      	b.n	5b40 <_svfprintf_r+0xac8>
    5d90:	f01b 0f10 	tst.w	fp, #16
    5d94:	d133      	bne.n	5dfe <_svfprintf_r+0xd86>
    5d96:	f01b 0f40 	tst.w	fp, #64	; 0x40
    5d9a:	d030      	beq.n	5dfe <_svfprintf_r+0xd86>
    5d9c:	9909      	ldr	r1, [sp, #36]	; 0x24
    5d9e:	f9b1 4000 	ldrsh.w	r4, [r1]
    5da2:	3104      	adds	r1, #4
    5da4:	17e5      	asrs	r5, r4, #31
    5da6:	4622      	mov	r2, r4
    5da8:	462b      	mov	r3, r5
    5daa:	9109      	str	r1, [sp, #36]	; 0x24
    5dac:	f7ff baf8 	b.w	53a0 <_svfprintf_r+0x328>
    5db0:	3201      	adds	r2, #1
    5db2:	4423      	add	r3, r4
    5db4:	2a07      	cmp	r2, #7
    5db6:	931d      	str	r3, [sp, #116]	; 0x74
    5db8:	921c      	str	r2, [sp, #112]	; 0x70
    5dba:	f8c9 7000 	str.w	r7, [r9]
    5dbe:	f8c9 4004 	str.w	r4, [r9, #4]
    5dc2:	f77f ac08 	ble.w	55d6 <_svfprintf_r+0x55e>
    5dc6:	e6c8      	b.n	5b5a <_svfprintf_r+0xae2>
    5dc8:	9909      	ldr	r1, [sp, #36]	; 0x24
    5dca:	f1b8 0f00 	cmp.w	r8, #0
    5dce:	680c      	ldr	r4, [r1, #0]
    5dd0:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
    5dd4:	f101 0704 	add.w	r7, r1, #4
    5dd8:	f04f 0500 	mov.w	r5, #0
    5ddc:	f2c0 80c5 	blt.w	5f6a <_svfprintf_r+0xef2>
    5de0:	ea54 0205 	orrs.w	r2, r4, r5
    5de4:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    5de8:	9709      	str	r7, [sp, #36]	; 0x24
    5dea:	f43f adb2 	beq.w	5952 <_svfprintf_r+0x8da>
    5dee:	461f      	mov	r7, r3
    5df0:	f7ff ba64 	b.w	52bc <_svfprintf_r+0x244>
    5df4:	681c      	ldr	r4, [r3, #0]
    5df6:	3304      	adds	r3, #4
    5df8:	9309      	str	r3, [sp, #36]	; 0x24
    5dfa:	2500      	movs	r5, #0
    5dfc:	e4b6      	b.n	576c <_svfprintf_r+0x6f4>
    5dfe:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5e00:	6814      	ldr	r4, [r2, #0]
    5e02:	4613      	mov	r3, r2
    5e04:	3304      	adds	r3, #4
    5e06:	17e5      	asrs	r5, r4, #31
    5e08:	4622      	mov	r2, r4
    5e0a:	9309      	str	r3, [sp, #36]	; 0x24
    5e0c:	2a00      	cmp	r2, #0
    5e0e:	462b      	mov	r3, r5
    5e10:	f173 0300 	sbcs.w	r3, r3, #0
    5e14:	f6bf aac9 	bge.w	53aa <_svfprintf_r+0x332>
    5e18:	4264      	negs	r4, r4
    5e1a:	f04f 072d 	mov.w	r7, #45	; 0x2d
    5e1e:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
    5e22:	f1b8 0f00 	cmp.w	r8, #0
    5e26:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    5e2a:	f6ff aaca 	blt.w	53c2 <_svfprintf_r+0x34a>
    5e2e:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    5e32:	f7ff bac6 	b.w	53c2 <_svfprintf_r+0x34a>
    5e36:	aa1b      	add	r2, sp, #108	; 0x6c
    5e38:	9903      	ldr	r1, [sp, #12]
    5e3a:	9805      	ldr	r0, [sp, #20]
    5e3c:	f000 fbd4 	bl	65e8 <__ssprint_r>
    5e40:	2800      	cmp	r0, #0
    5e42:	f47f aa0f 	bne.w	5264 <_svfprintf_r+0x1ec>
    5e46:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5e48:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5e4c:	990e      	ldr	r1, [sp, #56]	; 0x38
    5e4e:	9a15      	ldr	r2, [sp, #84]	; 0x54
    5e50:	4431      	add	r1, r6
    5e52:	460d      	mov	r5, r1
    5e54:	990d      	ldr	r1, [sp, #52]	; 0x34
    5e56:	428a      	cmp	r2, r1
    5e58:	db47      	blt.n	5eea <_svfprintf_r+0xe72>
    5e5a:	f01b 0f01 	tst.w	fp, #1
    5e5e:	d144      	bne.n	5eea <_svfprintf_r+0xe72>
    5e60:	980d      	ldr	r0, [sp, #52]	; 0x34
    5e62:	4406      	add	r6, r0
    5e64:	1b74      	subs	r4, r6, r5
    5e66:	1a82      	subs	r2, r0, r2
    5e68:	4294      	cmp	r4, r2
    5e6a:	bfa8      	it	ge
    5e6c:	4614      	movge	r4, r2
    5e6e:	2c00      	cmp	r4, #0
    5e70:	4626      	mov	r6, r4
    5e72:	dd0d      	ble.n	5e90 <_svfprintf_r+0xe18>
    5e74:	991c      	ldr	r1, [sp, #112]	; 0x70
    5e76:	f8c9 5000 	str.w	r5, [r9]
    5e7a:	3101      	adds	r1, #1
    5e7c:	4423      	add	r3, r4
    5e7e:	2907      	cmp	r1, #7
    5e80:	931d      	str	r3, [sp, #116]	; 0x74
    5e82:	f8c9 4004 	str.w	r4, [r9, #4]
    5e86:	911c      	str	r1, [sp, #112]	; 0x70
    5e88:	f300 8280 	bgt.w	638c <_svfprintf_r+0x1314>
    5e8c:	f109 0908 	add.w	r9, r9, #8
    5e90:	2e00      	cmp	r6, #0
    5e92:	bfac      	ite	ge
    5e94:	1b94      	subge	r4, r2, r6
    5e96:	4614      	movlt	r4, r2
    5e98:	2c00      	cmp	r4, #0
    5e9a:	f77f ab9e 	ble.w	55da <_svfprintf_r+0x562>
    5e9e:	2c10      	cmp	r4, #16
    5ea0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5ea2:	4f34      	ldr	r7, [pc, #208]	; (5f74 <_svfprintf_r+0xefc>)
    5ea4:	dd84      	ble.n	5db0 <_svfprintf_r+0xd38>
    5ea6:	2510      	movs	r5, #16
    5ea8:	9e05      	ldr	r6, [sp, #20]
    5eaa:	f8dd 800c 	ldr.w	r8, [sp, #12]
    5eae:	e005      	b.n	5ebc <_svfprintf_r+0xe44>
    5eb0:	f109 0908 	add.w	r9, r9, #8
    5eb4:	3c10      	subs	r4, #16
    5eb6:	2c10      	cmp	r4, #16
    5eb8:	f77f af7a 	ble.w	5db0 <_svfprintf_r+0xd38>
    5ebc:	3201      	adds	r2, #1
    5ebe:	3310      	adds	r3, #16
    5ec0:	2a07      	cmp	r2, #7
    5ec2:	931d      	str	r3, [sp, #116]	; 0x74
    5ec4:	921c      	str	r2, [sp, #112]	; 0x70
    5ec6:	f8c9 7000 	str.w	r7, [r9]
    5eca:	f8c9 5004 	str.w	r5, [r9, #4]
    5ece:	ddef      	ble.n	5eb0 <_svfprintf_r+0xe38>
    5ed0:	aa1b      	add	r2, sp, #108	; 0x6c
    5ed2:	4641      	mov	r1, r8
    5ed4:	4630      	mov	r0, r6
    5ed6:	f000 fb87 	bl	65e8 <__ssprint_r>
    5eda:	2800      	cmp	r0, #0
    5edc:	f47f a9c2 	bne.w	5264 <_svfprintf_r+0x1ec>
    5ee0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5ee2:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5ee4:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5ee8:	e7e4      	b.n	5eb4 <_svfprintf_r+0xe3c>
    5eea:	991c      	ldr	r1, [sp, #112]	; 0x70
    5eec:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    5eee:	9810      	ldr	r0, [sp, #64]	; 0x40
    5ef0:	f8c9 0000 	str.w	r0, [r9]
    5ef4:	3101      	adds	r1, #1
    5ef6:	4423      	add	r3, r4
    5ef8:	2907      	cmp	r1, #7
    5efa:	931d      	str	r3, [sp, #116]	; 0x74
    5efc:	f8c9 4004 	str.w	r4, [r9, #4]
    5f00:	911c      	str	r1, [sp, #112]	; 0x70
    5f02:	f300 8226 	bgt.w	6352 <_svfprintf_r+0x12da>
    5f06:	f109 0908 	add.w	r9, r9, #8
    5f0a:	e7a9      	b.n	5e60 <_svfprintf_r+0xde8>
    5f0c:	f01b 0f01 	tst.w	fp, #1
    5f10:	f47f adec 	bne.w	5aec <_svfprintf_r+0xa74>
    5f14:	2a07      	cmp	r2, #7
    5f16:	f77f ae11 	ble.w	5b3c <_svfprintf_r+0xac4>
    5f1a:	e72c      	b.n	5d76 <_svfprintf_r+0xcfe>
    5f1c:	aa1b      	add	r2, sp, #108	; 0x6c
    5f1e:	9903      	ldr	r1, [sp, #12]
    5f20:	9805      	ldr	r0, [sp, #20]
    5f22:	f000 fb61 	bl	65e8 <__ssprint_r>
    5f26:	2800      	cmp	r0, #0
    5f28:	f47f a99c 	bne.w	5264 <_svfprintf_r+0x1ec>
    5f2c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5f2e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5f30:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5f34:	e5df      	b.n	5af6 <_svfprintf_r+0xa7e>
    5f36:	aa1b      	add	r2, sp, #108	; 0x6c
    5f38:	9903      	ldr	r1, [sp, #12]
    5f3a:	9805      	ldr	r0, [sp, #20]
    5f3c:	f000 fb54 	bl	65e8 <__ssprint_r>
    5f40:	2800      	cmp	r0, #0
    5f42:	f47f a98f 	bne.w	5264 <_svfprintf_r+0x1ec>
    5f46:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5f48:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    5f4a:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5f4e:	e5e1      	b.n	5b14 <_svfprintf_r+0xa9c>
    5f50:	aa1b      	add	r2, sp, #108	; 0x6c
    5f52:	9903      	ldr	r1, [sp, #12]
    5f54:	9805      	ldr	r0, [sp, #20]
    5f56:	f000 fb47 	bl	65e8 <__ssprint_r>
    5f5a:	2800      	cmp	r0, #0
    5f5c:	f47f a982 	bne.w	5264 <_svfprintf_r+0x1ec>
    5f60:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    5f62:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    5f66:	f7ff baeb 	b.w	5540 <_svfprintf_r+0x4c8>
    5f6a:	9709      	str	r7, [sp, #36]	; 0x24
    5f6c:	2700      	movs	r7, #0
    5f6e:	f7ff b9a5 	b.w	52bc <_svfprintf_r+0x244>
    5f72:	bf00      	nop
    5f74:	200007e4 	.word	0x200007e4
    5f78:	f01b 0f10 	tst.w	fp, #16
    5f7c:	d10b      	bne.n	5f96 <_svfprintf_r+0xf1e>
    5f7e:	f01b 0f40 	tst.w	fp, #64	; 0x40
    5f82:	d008      	beq.n	5f96 <_svfprintf_r+0xf1e>
    5f84:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5f86:	6813      	ldr	r3, [r2, #0]
    5f88:	3204      	adds	r2, #4
    5f8a:	9209      	str	r2, [sp, #36]	; 0x24
    5f8c:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    5f90:	801a      	strh	r2, [r3, #0]
    5f92:	f7ff b897 	b.w	50c4 <_svfprintf_r+0x4c>
    5f96:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5f98:	6813      	ldr	r3, [r2, #0]
    5f9a:	3204      	adds	r2, #4
    5f9c:	9209      	str	r2, [sp, #36]	; 0x24
    5f9e:	9a06      	ldr	r2, [sp, #24]
    5fa0:	601a      	str	r2, [r3, #0]
    5fa2:	f7ff b88f 	b.w	50c4 <_svfprintf_r+0x4c>
    5fa6:	eeb4 8b48 	vcmp.f64	d8, d8
    5faa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5fae:	f180 829e 	bvs.w	64ee <_svfprintf_r+0x1476>
    5fb2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5fb4:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
    5fb8:	f023 0520 	bic.w	r5, r3, #32
    5fbc:	f000 8225 	beq.w	640a <_svfprintf_r+0x1392>
    5fc0:	2d47      	cmp	r5, #71	; 0x47
    5fc2:	f000 8126 	beq.w	6212 <_svfprintf_r+0x119a>
    5fc6:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
    5fca:	930a      	str	r3, [sp, #40]	; 0x28
    5fcc:	ee18 3a90 	vmov	r3, s17
    5fd0:	2b00      	cmp	r3, #0
    5fd2:	f2c0 821d 	blt.w	6410 <_svfprintf_r+0x1398>
    5fd6:	eeb0 ab48 	vmov.f64	d10, d8
    5fda:	2700      	movs	r7, #0
    5fdc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5fde:	2b66      	cmp	r3, #102	; 0x66
    5fe0:	f000 8202 	beq.w	63e8 <_svfprintf_r+0x1370>
    5fe4:	2b46      	cmp	r3, #70	; 0x46
    5fe6:	f000 80ec 	beq.w	61c2 <_svfprintf_r+0x114a>
    5fea:	eeb0 0b4a 	vmov.f64	d0, d10
    5fee:	2d45      	cmp	r5, #69	; 0x45
    5ff0:	bf0c      	ite	eq
    5ff2:	f108 0401 	addeq.w	r4, r8, #1
    5ff6:	4644      	movne	r4, r8
    5ff8:	aa19      	add	r2, sp, #100	; 0x64
    5ffa:	ab16      	add	r3, sp, #88	; 0x58
    5ffc:	9201      	str	r2, [sp, #4]
    5ffe:	9300      	str	r3, [sp, #0]
    6000:	4622      	mov	r2, r4
    6002:	ab15      	add	r3, sp, #84	; 0x54
    6004:	2102      	movs	r1, #2
    6006:	9805      	ldr	r0, [sp, #20]
    6008:	f7fe f9f2 	bl	43f0 <_dtoa_r>
    600c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    600e:	2b67      	cmp	r3, #103	; 0x67
    6010:	4606      	mov	r6, r0
    6012:	f040 820e 	bne.w	6432 <_svfprintf_r+0x13ba>
    6016:	f01b 0f01 	tst.w	fp, #1
    601a:	f000 8266 	beq.w	64ea <_svfprintf_r+0x1472>
    601e:	1931      	adds	r1, r6, r4
    6020:	eeb5 ab40 	vcmp.f64	d10, #0.0
    6024:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    6028:	f000 8185 	beq.w	6336 <_svfprintf_r+0x12be>
    602c:	9b19      	ldr	r3, [sp, #100]	; 0x64
    602e:	4299      	cmp	r1, r3
    6030:	d906      	bls.n	6040 <_svfprintf_r+0xfc8>
    6032:	2030      	movs	r0, #48	; 0x30
    6034:	1c5a      	adds	r2, r3, #1
    6036:	9219      	str	r2, [sp, #100]	; 0x64
    6038:	7018      	strb	r0, [r3, #0]
    603a:	9b19      	ldr	r3, [sp, #100]	; 0x64
    603c:	4299      	cmp	r1, r3
    603e:	d8f9      	bhi.n	6034 <_svfprintf_r+0xfbc>
    6040:	1b9b      	subs	r3, r3, r6
    6042:	2d47      	cmp	r5, #71	; 0x47
    6044:	930d      	str	r3, [sp, #52]	; 0x34
    6046:	f000 811f 	beq.w	6288 <_svfprintf_r+0x1210>
    604a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    604c:	2b65      	cmp	r3, #101	; 0x65
    604e:	f340 81ff 	ble.w	6450 <_svfprintf_r+0x13d8>
    6052:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    6054:	2b66      	cmp	r3, #102	; 0x66
    6056:	9b15      	ldr	r3, [sp, #84]	; 0x54
    6058:	f000 81fc 	beq.w	6454 <_svfprintf_r+0x13dc>
    605c:	930e      	str	r3, [sp, #56]	; 0x38
    605e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    6060:	990d      	ldr	r1, [sp, #52]	; 0x34
    6062:	428a      	cmp	r2, r1
    6064:	f2c0 81d8 	blt.w	6418 <_svfprintf_r+0x13a0>
    6068:	f01b 0f01 	tst.w	fp, #1
    606c:	f040 8234 	bne.w	64d8 <_svfprintf_r+0x1460>
    6070:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
    6074:	9208      	str	r2, [sp, #32]
    6076:	2267      	movs	r2, #103	; 0x67
    6078:	920c      	str	r2, [sp, #48]	; 0x30
    607a:	2f00      	cmp	r7, #0
    607c:	f040 80f6 	bne.w	626c <_svfprintf_r+0x11f4>
    6080:	46b8      	mov	r8, r7
    6082:	9304      	str	r3, [sp, #16]
    6084:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    6088:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    608c:	f7ff b9e6 	b.w	545c <_svfprintf_r+0x3e4>
    6090:	f027 0707 	bic.w	r7, r7, #7
    6094:	f107 0308 	add.w	r3, r7, #8
    6098:	ed97 8b00 	vldr	d8, [r7]
    609c:	9309      	str	r3, [sp, #36]	; 0x24
    609e:	f7ff b9be 	b.w	541e <_svfprintf_r+0x3a6>
    60a2:	464e      	mov	r6, r9
    60a4:	4689      	mov	r9, r1
    60a6:	3201      	adds	r2, #1
    60a8:	4423      	add	r3, r4
    60aa:	2a07      	cmp	r2, #7
    60ac:	931d      	str	r3, [sp, #116]	; 0x74
    60ae:	921c      	str	r2, [sp, #112]	; 0x70
    60b0:	f8c9 7000 	str.w	r7, [r9]
    60b4:	f8c9 4004 	str.w	r4, [r9, #4]
    60b8:	f73f aebd 	bgt.w	5e36 <_svfprintf_r+0xdbe>
    60bc:	f109 0908 	add.w	r9, r9, #8
    60c0:	e6c4      	b.n	5e4c <_svfprintf_r+0xdd4>
    60c2:	2700      	movs	r7, #0
    60c4:	45b8      	cmp	r8, r7
    60c6:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    60ca:	f6ff ac54 	blt.w	5976 <_svfprintf_r+0x8fe>
    60ce:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
    60d2:	e41e      	b.n	5912 <_svfprintf_r+0x89a>
    60d4:	aa1b      	add	r2, sp, #108	; 0x6c
    60d6:	9903      	ldr	r1, [sp, #12]
    60d8:	9805      	ldr	r0, [sp, #20]
    60da:	f000 fa85 	bl	65e8 <__ssprint_r>
    60de:	2800      	cmp	r0, #0
    60e0:	f47f a8c0 	bne.w	5264 <_svfprintf_r+0x1ec>
    60e4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    60e6:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    60ea:	e463      	b.n	59b4 <_svfprintf_r+0x93c>
    60ec:	9f09      	ldr	r7, [sp, #36]	; 0x24
    60ee:	e43b      	b.n	5968 <_svfprintf_r+0x8f0>
    60f0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    60f2:	49b9      	ldr	r1, [pc, #740]	; (63d8 <_svfprintf_r+0x1360>)
    60f4:	f8c9 1000 	str.w	r1, [r9]
    60f8:	3201      	adds	r2, #1
    60fa:	3301      	adds	r3, #1
    60fc:	2101      	movs	r1, #1
    60fe:	2a07      	cmp	r2, #7
    6100:	931d      	str	r3, [sp, #116]	; 0x74
    6102:	921c      	str	r2, [sp, #112]	; 0x70
    6104:	f8c9 1004 	str.w	r1, [r9, #4]
    6108:	dc76      	bgt.n	61f8 <_svfprintf_r+0x1180>
    610a:	f109 0908 	add.w	r9, r9, #8
    610e:	b92c      	cbnz	r4, 611c <_svfprintf_r+0x10a4>
    6110:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    6112:	b91a      	cbnz	r2, 611c <_svfprintf_r+0x10a4>
    6114:	f01b 0f01 	tst.w	fp, #1
    6118:	f43f aa5f 	beq.w	55da <_svfprintf_r+0x562>
    611c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    611e:	980f      	ldr	r0, [sp, #60]	; 0x3c
    6120:	9910      	ldr	r1, [sp, #64]	; 0x40
    6122:	f8c9 1000 	str.w	r1, [r9]
    6126:	3201      	adds	r2, #1
    6128:	4403      	add	r3, r0
    612a:	2a07      	cmp	r2, #7
    612c:	931d      	str	r3, [sp, #116]	; 0x74
    612e:	f8c9 0004 	str.w	r0, [r9, #4]
    6132:	921c      	str	r2, [sp, #112]	; 0x70
    6134:	f300 81b6 	bgt.w	64a4 <_svfprintf_r+0x142c>
    6138:	f109 0908 	add.w	r9, r9, #8
    613c:	4264      	negs	r4, r4
    613e:	2c00      	cmp	r4, #0
    6140:	f340 8087 	ble.w	6252 <_svfprintf_r+0x11da>
    6144:	2c10      	cmp	r4, #16
    6146:	4fa5      	ldr	r7, [pc, #660]	; (63dc <_svfprintf_r+0x1364>)
    6148:	f340 8112 	ble.w	6370 <_svfprintf_r+0x12f8>
    614c:	4649      	mov	r1, r9
    614e:	2510      	movs	r5, #16
    6150:	46b1      	mov	r9, r6
    6152:	f8dd 8014 	ldr.w	r8, [sp, #20]
    6156:	9e03      	ldr	r6, [sp, #12]
    6158:	e004      	b.n	6164 <_svfprintf_r+0x10ec>
    615a:	3108      	adds	r1, #8
    615c:	3c10      	subs	r4, #16
    615e:	2c10      	cmp	r4, #16
    6160:	f340 8104 	ble.w	636c <_svfprintf_r+0x12f4>
    6164:	3201      	adds	r2, #1
    6166:	3310      	adds	r3, #16
    6168:	2a07      	cmp	r2, #7
    616a:	931d      	str	r3, [sp, #116]	; 0x74
    616c:	921c      	str	r2, [sp, #112]	; 0x70
    616e:	600f      	str	r7, [r1, #0]
    6170:	604d      	str	r5, [r1, #4]
    6172:	ddf2      	ble.n	615a <_svfprintf_r+0x10e2>
    6174:	aa1b      	add	r2, sp, #108	; 0x6c
    6176:	4631      	mov	r1, r6
    6178:	4640      	mov	r0, r8
    617a:	f000 fa35 	bl	65e8 <__ssprint_r>
    617e:	2800      	cmp	r0, #0
    6180:	f47f a870 	bne.w	5264 <_svfprintf_r+0x1ec>
    6184:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    6186:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    6188:	a928      	add	r1, sp, #160	; 0xa0
    618a:	e7e7      	b.n	615c <_svfprintf_r+0x10e4>
    618c:	aa1b      	add	r2, sp, #108	; 0x6c
    618e:	9903      	ldr	r1, [sp, #12]
    6190:	9805      	ldr	r0, [sp, #20]
    6192:	f000 fa29 	bl	65e8 <__ssprint_r>
    6196:	2800      	cmp	r0, #0
    6198:	f47f a864 	bne.w	5264 <_svfprintf_r+0x1ec>
    619c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    619e:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    61a2:	e41f      	b.n	59e4 <_svfprintf_r+0x96c>
    61a4:	2140      	movs	r1, #64	; 0x40
    61a6:	9805      	ldr	r0, [sp, #20]
    61a8:	f7fc fba4 	bl	28f4 <_malloc_r>
    61ac:	9a03      	ldr	r2, [sp, #12]
    61ae:	6010      	str	r0, [r2, #0]
    61b0:	6110      	str	r0, [r2, #16]
    61b2:	2800      	cmp	r0, #0
    61b4:	f000 81ed 	beq.w	6592 <_svfprintf_r+0x151a>
    61b8:	9a03      	ldr	r2, [sp, #12]
    61ba:	2340      	movs	r3, #64	; 0x40
    61bc:	6153      	str	r3, [r2, #20]
    61be:	f7fe bf74 	b.w	50aa <_svfprintf_r+0x32>
    61c2:	aa19      	add	r2, sp, #100	; 0x64
    61c4:	ab16      	add	r3, sp, #88	; 0x58
    61c6:	9201      	str	r2, [sp, #4]
    61c8:	9300      	str	r3, [sp, #0]
    61ca:	4642      	mov	r2, r8
    61cc:	ab15      	add	r3, sp, #84	; 0x54
    61ce:	2103      	movs	r1, #3
    61d0:	eeb0 0b4a 	vmov.f64	d0, d10
    61d4:	9805      	ldr	r0, [sp, #20]
    61d6:	f7fe f90b 	bl	43f0 <_dtoa_r>
    61da:	4644      	mov	r4, r8
    61dc:	4606      	mov	r6, r0
    61de:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    61e0:	2b46      	cmp	r3, #70	; 0x46
    61e2:	eb06 0104 	add.w	r1, r6, r4
    61e6:	f47f af1b 	bne.w	6020 <_svfprintf_r+0xfa8>
    61ea:	7833      	ldrb	r3, [r6, #0]
    61ec:	2b30      	cmp	r3, #48	; 0x30
    61ee:	f000 818d 	beq.w	650c <_svfprintf_r+0x1494>
    61f2:	9c15      	ldr	r4, [sp, #84]	; 0x54
    61f4:	4421      	add	r1, r4
    61f6:	e713      	b.n	6020 <_svfprintf_r+0xfa8>
    61f8:	aa1b      	add	r2, sp, #108	; 0x6c
    61fa:	9903      	ldr	r1, [sp, #12]
    61fc:	9805      	ldr	r0, [sp, #20]
    61fe:	f000 f9f3 	bl	65e8 <__ssprint_r>
    6202:	2800      	cmp	r0, #0
    6204:	f47f a82e 	bne.w	5264 <_svfprintf_r+0x1ec>
    6208:	9c15      	ldr	r4, [sp, #84]	; 0x54
    620a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    620c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    6210:	e77d      	b.n	610e <_svfprintf_r+0x1096>
    6212:	f1b8 0f00 	cmp.w	r8, #0
    6216:	bf08      	it	eq
    6218:	f04f 0801 	moveq.w	r8, #1
    621c:	e6d3      	b.n	5fc6 <_svfprintf_r+0xf4e>
    621e:	9309      	str	r3, [sp, #36]	; 0x24
    6220:	e6a4      	b.n	5f6c <_svfprintf_r+0xef4>
    6222:	9309      	str	r3, [sp, #36]	; 0x24
    6224:	4617      	mov	r7, r2
    6226:	f7ff ba7b 	b.w	5720 <_svfprintf_r+0x6a8>
    622a:	4630      	mov	r0, r6
    622c:	f7fd f9e8 	bl	3600 <strlen>
    6230:	46a0      	mov	r8, r4
    6232:	4603      	mov	r3, r0
    6234:	9008      	str	r0, [sp, #32]
    6236:	f7ff bb61 	b.w	58fc <_svfprintf_r+0x884>
    623a:	aa1b      	add	r2, sp, #108	; 0x6c
    623c:	9903      	ldr	r1, [sp, #12]
    623e:	9805      	ldr	r0, [sp, #20]
    6240:	f000 f9d2 	bl	65e8 <__ssprint_r>
    6244:	2800      	cmp	r0, #0
    6246:	f47f a80d 	bne.w	5264 <_svfprintf_r+0x1ec>
    624a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    624c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    624e:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    6252:	980d      	ldr	r0, [sp, #52]	; 0x34
    6254:	f8c9 6000 	str.w	r6, [r9]
    6258:	3201      	adds	r2, #1
    625a:	4403      	add	r3, r0
    625c:	2a07      	cmp	r2, #7
    625e:	931d      	str	r3, [sp, #116]	; 0x74
    6260:	921c      	str	r2, [sp, #112]	; 0x70
    6262:	f8c9 0004 	str.w	r0, [r9, #4]
    6266:	f77f a9b6 	ble.w	55d6 <_svfprintf_r+0x55e>
    626a:	e476      	b.n	5b5a <_svfprintf_r+0xae2>
    626c:	272d      	movs	r7, #45	; 0x2d
    626e:	9304      	str	r3, [sp, #16]
    6270:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    6274:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    6278:	f04f 0800 	mov.w	r8, #0
    627c:	f7ff b8ef 	b.w	545e <_svfprintf_r+0x3e6>
    6280:	9709      	str	r7, [sp, #36]	; 0x24
    6282:	461f      	mov	r7, r3
    6284:	f7ff ba4c 	b.w	5720 <_svfprintf_r+0x6a8>
    6288:	9b15      	ldr	r3, [sp, #84]	; 0x54
    628a:	1cda      	adds	r2, r3, #3
    628c:	db02      	blt.n	6294 <_svfprintf_r+0x121c>
    628e:	4598      	cmp	r8, r3
    6290:	f6bf aee4 	bge.w	605c <_svfprintf_r+0xfe4>
    6294:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    6296:	3a02      	subs	r2, #2
    6298:	920c      	str	r2, [sp, #48]	; 0x30
    629a:	3b01      	subs	r3, #1
    629c:	2b00      	cmp	r3, #0
    629e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    62a2:	9315      	str	r3, [sp, #84]	; 0x54
    62a4:	bfb8      	it	lt
    62a6:	425b      	neglt	r3, r3
    62a8:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
    62ac:	bfb4      	ite	lt
    62ae:	222d      	movlt	r2, #45	; 0x2d
    62b0:	222b      	movge	r2, #43	; 0x2b
    62b2:	2b09      	cmp	r3, #9
    62b4:	f88d 205d 	strb.w	r2, [sp, #93]	; 0x5d
    62b8:	f340 8106 	ble.w	64c8 <_svfprintf_r+0x1450>
    62bc:	f10d 006b 	add.w	r0, sp, #107	; 0x6b
    62c0:	4604      	mov	r4, r0
    62c2:	4a47      	ldr	r2, [pc, #284]	; (63e0 <_svfprintf_r+0x1368>)
    62c4:	fb82 2103 	smull	r2, r1, r2, r3
    62c8:	17da      	asrs	r2, r3, #31
    62ca:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
    62ce:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    62d2:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
    62d6:	f103 0130 	add.w	r1, r3, #48	; 0x30
    62da:	2a09      	cmp	r2, #9
    62dc:	4613      	mov	r3, r2
    62de:	f804 1d01 	strb.w	r1, [r4, #-1]!
    62e2:	dcee      	bgt.n	62c2 <_svfprintf_r+0x124a>
    62e4:	4621      	mov	r1, r4
    62e6:	3330      	adds	r3, #48	; 0x30
    62e8:	b2da      	uxtb	r2, r3
    62ea:	f801 2d01 	strb.w	r2, [r1, #-1]!
    62ee:	4288      	cmp	r0, r1
    62f0:	f240 8162 	bls.w	65b8 <_svfprintf_r+0x1540>
    62f4:	f10d 015e 	add.w	r1, sp, #94	; 0x5e
    62f8:	4623      	mov	r3, r4
    62fa:	e001      	b.n	6300 <_svfprintf_r+0x1288>
    62fc:	f813 2b01 	ldrb.w	r2, [r3], #1
    6300:	f801 2b01 	strb.w	r2, [r1], #1
    6304:	4298      	cmp	r0, r3
    6306:	d1f9      	bne.n	62fc <_svfprintf_r+0x1284>
    6308:	1c43      	adds	r3, r0, #1
    630a:	1b1b      	subs	r3, r3, r4
    630c:	f10d 025e 	add.w	r2, sp, #94	; 0x5e
    6310:	4413      	add	r3, r2
    6312:	aa17      	add	r2, sp, #92	; 0x5c
    6314:	1a9b      	subs	r3, r3, r2
    6316:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    6318:	9311      	str	r3, [sp, #68]	; 0x44
    631a:	2a01      	cmp	r2, #1
    631c:	4413      	add	r3, r2
    631e:	9308      	str	r3, [sp, #32]
    6320:	f340 80ff 	ble.w	6522 <_svfprintf_r+0x14aa>
    6324:	9b08      	ldr	r3, [sp, #32]
    6326:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    6328:	4413      	add	r3, r2
    632a:	2200      	movs	r2, #0
    632c:	9308      	str	r3, [sp, #32]
    632e:	920e      	str	r2, [sp, #56]	; 0x38
    6330:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    6334:	e6a1      	b.n	607a <_svfprintf_r+0x1002>
    6336:	460b      	mov	r3, r1
    6338:	e682      	b.n	6040 <_svfprintf_r+0xfc8>
    633a:	aa1b      	add	r2, sp, #108	; 0x6c
    633c:	9903      	ldr	r1, [sp, #12]
    633e:	9805      	ldr	r0, [sp, #20]
    6340:	f000 f952 	bl	65e8 <__ssprint_r>
    6344:	2800      	cmp	r0, #0
    6346:	f47e af8d 	bne.w	5264 <_svfprintf_r+0x1ec>
    634a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    634c:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    6350:	e483      	b.n	5c5a <_svfprintf_r+0xbe2>
    6352:	aa1b      	add	r2, sp, #108	; 0x6c
    6354:	9903      	ldr	r1, [sp, #12]
    6356:	9805      	ldr	r0, [sp, #20]
    6358:	f000 f946 	bl	65e8 <__ssprint_r>
    635c:	2800      	cmp	r0, #0
    635e:	f47e af81 	bne.w	5264 <_svfprintf_r+0x1ec>
    6362:	9a15      	ldr	r2, [sp, #84]	; 0x54
    6364:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    6366:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    636a:	e579      	b.n	5e60 <_svfprintf_r+0xde8>
    636c:	464e      	mov	r6, r9
    636e:	4689      	mov	r9, r1
    6370:	3201      	adds	r2, #1
    6372:	4423      	add	r3, r4
    6374:	2a07      	cmp	r2, #7
    6376:	931d      	str	r3, [sp, #116]	; 0x74
    6378:	921c      	str	r2, [sp, #112]	; 0x70
    637a:	f8c9 7000 	str.w	r7, [r9]
    637e:	f8c9 4004 	str.w	r4, [r9, #4]
    6382:	f73f af5a 	bgt.w	623a <_svfprintf_r+0x11c2>
    6386:	f109 0908 	add.w	r9, r9, #8
    638a:	e762      	b.n	6252 <_svfprintf_r+0x11da>
    638c:	aa1b      	add	r2, sp, #108	; 0x6c
    638e:	9903      	ldr	r1, [sp, #12]
    6390:	9805      	ldr	r0, [sp, #20]
    6392:	f000 f929 	bl	65e8 <__ssprint_r>
    6396:	2800      	cmp	r0, #0
    6398:	f47e af64 	bne.w	5264 <_svfprintf_r+0x1ec>
    639c:	9a15      	ldr	r2, [sp, #84]	; 0x54
    639e:	990d      	ldr	r1, [sp, #52]	; 0x34
    63a0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    63a2:	1a8a      	subs	r2, r1, r2
    63a4:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    63a8:	e572      	b.n	5e90 <_svfprintf_r+0xe18>
    63aa:	2d06      	cmp	r5, #6
    63ac:	462b      	mov	r3, r5
    63ae:	bf28      	it	cs
    63b0:	2306      	movcs	r3, #6
    63b2:	9308      	str	r3, [sp, #32]
    63b4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    63b8:	46b0      	mov	r8, r6
    63ba:	9709      	str	r7, [sp, #36]	; 0x24
    63bc:	960e      	str	r6, [sp, #56]	; 0x38
    63be:	4637      	mov	r7, r6
    63c0:	9304      	str	r3, [sp, #16]
    63c2:	4e08      	ldr	r6, [pc, #32]	; (63e4 <_svfprintf_r+0x136c>)
    63c4:	f7ff b84a 	b.w	545c <_svfprintf_r+0x3e4>
    63c8:	469b      	mov	fp, r3
    63ca:	f7ff b9ea 	b.w	57a2 <_svfprintf_r+0x72a>
    63ce:	272d      	movs	r7, #45	; 0x2d
    63d0:	f88d 704f 	strb.w	r7, [sp, #79]	; 0x4f
    63d4:	f7ff b833 	b.w	543e <_svfprintf_r+0x3c6>
    63d8:	20000704 	.word	0x20000704
    63dc:	200007e4 	.word	0x200007e4
    63e0:	66666667 	.word	0x66666667
    63e4:	20000740 	.word	0x20000740
    63e8:	aa19      	add	r2, sp, #100	; 0x64
    63ea:	ab16      	add	r3, sp, #88	; 0x58
    63ec:	9201      	str	r2, [sp, #4]
    63ee:	9300      	str	r3, [sp, #0]
    63f0:	2103      	movs	r1, #3
    63f2:	ab15      	add	r3, sp, #84	; 0x54
    63f4:	4642      	mov	r2, r8
    63f6:	eeb0 0b4a 	vmov.f64	d0, d10
    63fa:	9805      	ldr	r0, [sp, #20]
    63fc:	f7fd fff8 	bl	43f0 <_dtoa_r>
    6400:	4644      	mov	r4, r8
    6402:	4606      	mov	r6, r0
    6404:	eb00 0108 	add.w	r1, r0, r8
    6408:	e6ef      	b.n	61ea <_svfprintf_r+0x1172>
    640a:	f04f 0806 	mov.w	r8, #6
    640e:	e5da      	b.n	5fc6 <_svfprintf_r+0xf4e>
    6410:	eeb1 ab48 	vneg.f64	d10, d8
    6414:	272d      	movs	r7, #45	; 0x2d
    6416:	e5e1      	b.n	5fdc <_svfprintf_r+0xf64>
    6418:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    641a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    641c:	4413      	add	r3, r2
    641e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    6420:	9308      	str	r3, [sp, #32]
    6422:	2a00      	cmp	r2, #0
    6424:	f340 8086 	ble.w	6534 <_svfprintf_r+0x14bc>
    6428:	2267      	movs	r2, #103	; 0x67
    642a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    642e:	920c      	str	r2, [sp, #48]	; 0x30
    6430:	e623      	b.n	607a <_svfprintf_r+0x1002>
    6432:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    6434:	2b47      	cmp	r3, #71	; 0x47
    6436:	f47f adf2 	bne.w	601e <_svfprintf_r+0xfa6>
    643a:	f01b 0f01 	tst.w	fp, #1
    643e:	f47f aece 	bne.w	61de <_svfprintf_r+0x1166>
    6442:	9b19      	ldr	r3, [sp, #100]	; 0x64
    6444:	2d47      	cmp	r5, #71	; 0x47
    6446:	eba3 0306 	sub.w	r3, r3, r6
    644a:	930d      	str	r3, [sp, #52]	; 0x34
    644c:	f43f af1c 	beq.w	6288 <_svfprintf_r+0x1210>
    6450:	9b15      	ldr	r3, [sp, #84]	; 0x54
    6452:	e722      	b.n	629a <_svfprintf_r+0x1222>
    6454:	2b00      	cmp	r3, #0
    6456:	461a      	mov	r2, r3
    6458:	930e      	str	r3, [sp, #56]	; 0x38
    645a:	dd73      	ble.n	6544 <_svfprintf_r+0x14cc>
    645c:	f1b8 0f00 	cmp.w	r8, #0
    6460:	d14b      	bne.n	64fa <_svfprintf_r+0x1482>
    6462:	f01b 0f01 	tst.w	fp, #1
    6466:	d148      	bne.n	64fa <_svfprintf_r+0x1482>
    6468:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    646c:	9208      	str	r2, [sp, #32]
    646e:	e604      	b.n	607a <_svfprintf_r+0x1002>
    6470:	f01b 0f01 	tst.w	fp, #1
    6474:	4647      	mov	r7, r8
    6476:	d005      	beq.n	6484 <_svfprintf_r+0x140c>
    6478:	ae38      	add	r6, sp, #224	; 0xe0
    647a:	2330      	movs	r3, #48	; 0x30
    647c:	f806 3d41 	strb.w	r3, [r6, #-65]!
    6480:	f7ff b956 	b.w	5730 <_svfprintf_r+0x6b8>
    6484:	f8cd 8020 	str.w	r8, [sp, #32]
    6488:	ae28      	add	r6, sp, #160	; 0xa0
    648a:	f7ff b954 	b.w	5736 <_svfprintf_r+0x6be>
    648e:	ea25 73e5 	bic.w	r3, r5, r5, asr #31
    6492:	9709      	str	r7, [sp, #36]	; 0x24
    6494:	9304      	str	r3, [sp, #16]
    6496:	9508      	str	r5, [sp, #32]
    6498:	4680      	mov	r8, r0
    649a:	900e      	str	r0, [sp, #56]	; 0x38
    649c:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    64a0:	f7fe bfdc 	b.w	545c <_svfprintf_r+0x3e4>
    64a4:	aa1b      	add	r2, sp, #108	; 0x6c
    64a6:	9903      	ldr	r1, [sp, #12]
    64a8:	9805      	ldr	r0, [sp, #20]
    64aa:	f000 f89d 	bl	65e8 <__ssprint_r>
    64ae:	2800      	cmp	r0, #0
    64b0:	f47e aed8 	bne.w	5264 <_svfprintf_r+0x1ec>
    64b4:	9c15      	ldr	r4, [sp, #84]	; 0x54
    64b6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    64b8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    64ba:	f10d 09a0 	add.w	r9, sp, #160	; 0xa0
    64be:	e63d      	b.n	613c <_svfprintf_r+0x10c4>
    64c0:	46a2      	mov	sl, r4
    64c2:	2500      	movs	r5, #0
    64c4:	f7fe be33 	b.w	512e <_svfprintf_r+0xb6>
    64c8:	3330      	adds	r3, #48	; 0x30
    64ca:	2230      	movs	r2, #48	; 0x30
    64cc:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f
    64d0:	f88d 205e 	strb.w	r2, [sp, #94]	; 0x5e
    64d4:	ab18      	add	r3, sp, #96	; 0x60
    64d6:	e71c      	b.n	6312 <_svfprintf_r+0x129a>
    64d8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    64da:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    64dc:	4413      	add	r3, r2
    64de:	2267      	movs	r2, #103	; 0x67
    64e0:	9308      	str	r3, [sp, #32]
    64e2:	920c      	str	r2, [sp, #48]	; 0x30
    64e4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    64e8:	e5c7      	b.n	607a <_svfprintf_r+0x1002>
    64ea:	9b19      	ldr	r3, [sp, #100]	; 0x64
    64ec:	e5a8      	b.n	6040 <_svfprintf_r+0xfc8>
    64ee:	4e3c      	ldr	r6, [pc, #240]	; (65e0 <_svfprintf_r+0x1568>)
    64f0:	4b3c      	ldr	r3, [pc, #240]	; (65e4 <_svfprintf_r+0x156c>)
    64f2:	f89d 704f 	ldrb.w	r7, [sp, #79]	; 0x4f
    64f6:	f7fe bfa4 	b.w	5442 <_svfprintf_r+0x3ca>
    64fa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    64fc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    64fe:	189d      	adds	r5, r3, r2
    6500:	eb05 0308 	add.w	r3, r5, r8
    6504:	9308      	str	r3, [sp, #32]
    6506:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    650a:	e5b6      	b.n	607a <_svfprintf_r+0x1002>
    650c:	eeb5 ab40 	vcmp.f64	d10, #0.0
    6510:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    6514:	f43f ae6d 	beq.w	61f2 <_svfprintf_r+0x117a>
    6518:	f1c4 0401 	rsb	r4, r4, #1
    651c:	9415      	str	r4, [sp, #84]	; 0x54
    651e:	4421      	add	r1, r4
    6520:	e57e      	b.n	6020 <_svfprintf_r+0xfa8>
    6522:	f01b 0301 	ands.w	r3, fp, #1
    6526:	f47f aefd 	bne.w	6324 <_svfprintf_r+0x12ac>
    652a:	930e      	str	r3, [sp, #56]	; 0x38
    652c:	9b08      	ldr	r3, [sp, #32]
    652e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    6532:	e5a2      	b.n	607a <_svfprintf_r+0x1002>
    6534:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    6536:	9a08      	ldr	r2, [sp, #32]
    6538:	f1c3 0301 	rsb	r3, r3, #1
    653c:	441a      	add	r2, r3
    653e:	4613      	mov	r3, r2
    6540:	9208      	str	r2, [sp, #32]
    6542:	e771      	b.n	6428 <_svfprintf_r+0x13b0>
    6544:	f1b8 0f00 	cmp.w	r8, #0
    6548:	d102      	bne.n	6550 <_svfprintf_r+0x14d8>
    654a:	f01b 0f01 	tst.w	fp, #1
    654e:	d007      	beq.n	6560 <_svfprintf_r+0x14e8>
    6550:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    6552:	1c5d      	adds	r5, r3, #1
    6554:	eb05 0308 	add.w	r3, r5, r8
    6558:	9308      	str	r3, [sp, #32]
    655a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    655e:	e58c      	b.n	607a <_svfprintf_r+0x1002>
    6560:	2301      	movs	r3, #1
    6562:	9308      	str	r3, [sp, #32]
    6564:	e589      	b.n	607a <_svfprintf_r+0x1002>
    6566:	9809      	ldr	r0, [sp, #36]	; 0x24
    6568:	f89a 3001 	ldrb.w	r3, [sl, #1]
    656c:	6805      	ldr	r5, [r0, #0]
    656e:	3004      	adds	r0, #4
    6570:	2d00      	cmp	r5, #0
    6572:	9009      	str	r0, [sp, #36]	; 0x24
    6574:	46a2      	mov	sl, r4
    6576:	f6be add8 	bge.w	512a <_svfprintf_r+0xb2>
    657a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    657e:	f7fe bdd4 	b.w	512a <_svfprintf_r+0xb2>
    6582:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    6586:	f7ff b98d 	b.w	58a4 <_svfprintf_r+0x82c>
    658a:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    658e:	f7ff b9cf 	b.w	5930 <_svfprintf_r+0x8b8>
    6592:	9a05      	ldr	r2, [sp, #20]
    6594:	230c      	movs	r3, #12
    6596:	6013      	str	r3, [r2, #0]
    6598:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    659c:	f7fe be6b 	b.w	5276 <_svfprintf_r+0x1fe>
    65a0:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    65a4:	f7ff b8d4 	b.w	5750 <_svfprintf_r+0x6d8>
    65a8:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    65ac:	f7ff b8a3 	b.w	56f6 <_svfprintf_r+0x67e>
    65b0:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    65b4:	f7ff b952 	b.w	585c <_svfprintf_r+0x7e4>
    65b8:	f10d 035e 	add.w	r3, sp, #94	; 0x5e
    65bc:	e6a9      	b.n	6312 <_svfprintf_r+0x129a>
    65be:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    65c2:	f7fe be62 	b.w	528a <_svfprintf_r+0x212>
    65c6:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    65ca:	f7ff b862 	b.w	5692 <_svfprintf_r+0x61a>
    65ce:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    65d2:	f7fe bf16 	b.w	5402 <_svfprintf_r+0x38a>
    65d6:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    65da:	f7fe bed0 	b.w	537e <_svfprintf_r+0x306>
    65de:	bf00      	nop
    65e0:	20000714 	.word	0x20000714
    65e4:	20000710 	.word	0x20000710

000065e8 <__ssprint_r>:
    65e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    65ec:	6893      	ldr	r3, [r2, #8]
    65ee:	b083      	sub	sp, #12
    65f0:	4690      	mov	r8, r2
    65f2:	2b00      	cmp	r3, #0
    65f4:	d072      	beq.n	66dc <__ssprint_r+0xf4>
    65f6:	4683      	mov	fp, r0
    65f8:	f04f 0900 	mov.w	r9, #0
    65fc:	6816      	ldr	r6, [r2, #0]
    65fe:	6808      	ldr	r0, [r1, #0]
    6600:	688b      	ldr	r3, [r1, #8]
    6602:	460d      	mov	r5, r1
    6604:	464c      	mov	r4, r9
    6606:	2c00      	cmp	r4, #0
    6608:	d045      	beq.n	6696 <__ssprint_r+0xae>
    660a:	429c      	cmp	r4, r3
    660c:	461f      	mov	r7, r3
    660e:	469a      	mov	sl, r3
    6610:	d346      	bcc.n	66a0 <__ssprint_r+0xb8>
    6612:	89ab      	ldrh	r3, [r5, #12]
    6614:	f413 6f90 	tst.w	r3, #1152	; 0x480
    6618:	d02d      	beq.n	6676 <__ssprint_r+0x8e>
    661a:	696f      	ldr	r7, [r5, #20]
    661c:	6929      	ldr	r1, [r5, #16]
    661e:	eb07 0747 	add.w	r7, r7, r7, lsl #1
    6622:	ebc1 0a00 	rsb	sl, r1, r0
    6626:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
    662a:	1c60      	adds	r0, r4, #1
    662c:	107f      	asrs	r7, r7, #1
    662e:	4450      	add	r0, sl
    6630:	42b8      	cmp	r0, r7
    6632:	463a      	mov	r2, r7
    6634:	bf84      	itt	hi
    6636:	4607      	movhi	r7, r0
    6638:	463a      	movhi	r2, r7
    663a:	055b      	lsls	r3, r3, #21
    663c:	d533      	bpl.n	66a6 <__ssprint_r+0xbe>
    663e:	4611      	mov	r1, r2
    6640:	4658      	mov	r0, fp
    6642:	f7fc f957 	bl	28f4 <_malloc_r>
    6646:	2800      	cmp	r0, #0
    6648:	d037      	beq.n	66ba <__ssprint_r+0xd2>
    664a:	4652      	mov	r2, sl
    664c:	6929      	ldr	r1, [r5, #16]
    664e:	9001      	str	r0, [sp, #4]
    6650:	f7fc fc1e 	bl	2e90 <memcpy>
    6654:	89aa      	ldrh	r2, [r5, #12]
    6656:	9b01      	ldr	r3, [sp, #4]
    6658:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
    665c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    6660:	81aa      	strh	r2, [r5, #12]
    6662:	ebca 0207 	rsb	r2, sl, r7
    6666:	eb03 000a 	add.w	r0, r3, sl
    666a:	616f      	str	r7, [r5, #20]
    666c:	612b      	str	r3, [r5, #16]
    666e:	6028      	str	r0, [r5, #0]
    6670:	60aa      	str	r2, [r5, #8]
    6672:	4627      	mov	r7, r4
    6674:	46a2      	mov	sl, r4
    6676:	4652      	mov	r2, sl
    6678:	4649      	mov	r1, r9
    667a:	f7fc fca3 	bl	2fc4 <memmove>
    667e:	f8d8 2008 	ldr.w	r2, [r8, #8]
    6682:	68ab      	ldr	r3, [r5, #8]
    6684:	6828      	ldr	r0, [r5, #0]
    6686:	1bdb      	subs	r3, r3, r7
    6688:	4450      	add	r0, sl
    668a:	1b14      	subs	r4, r2, r4
    668c:	60ab      	str	r3, [r5, #8]
    668e:	6028      	str	r0, [r5, #0]
    6690:	f8c8 4008 	str.w	r4, [r8, #8]
    6694:	b314      	cbz	r4, 66dc <__ssprint_r+0xf4>
    6696:	f8d6 9000 	ldr.w	r9, [r6]
    669a:	6874      	ldr	r4, [r6, #4]
    669c:	3608      	adds	r6, #8
    669e:	e7b2      	b.n	6606 <__ssprint_r+0x1e>
    66a0:	4627      	mov	r7, r4
    66a2:	46a2      	mov	sl, r4
    66a4:	e7e7      	b.n	6676 <__ssprint_r+0x8e>
    66a6:	4658      	mov	r0, fp
    66a8:	f7fc fd4a 	bl	3140 <_realloc_r>
    66ac:	4603      	mov	r3, r0
    66ae:	2800      	cmp	r0, #0
    66b0:	d1d7      	bne.n	6662 <__ssprint_r+0x7a>
    66b2:	6929      	ldr	r1, [r5, #16]
    66b4:	4658      	mov	r0, fp
    66b6:	f7fd f947 	bl	3948 <_free_r>
    66ba:	230c      	movs	r3, #12
    66bc:	f8cb 3000 	str.w	r3, [fp]
    66c0:	89ab      	ldrh	r3, [r5, #12]
    66c2:	2200      	movs	r2, #0
    66c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    66c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    66cc:	81ab      	strh	r3, [r5, #12]
    66ce:	f8c8 2008 	str.w	r2, [r8, #8]
    66d2:	f8c8 2004 	str.w	r2, [r8, #4]
    66d6:	b003      	add	sp, #12
    66d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    66dc:	2000      	movs	r0, #0
    66de:	f8c8 0004 	str.w	r0, [r8, #4]
    66e2:	b003      	add	sp, #12
    66e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000066e8 <___init_veneer>:
    66e8:	f85f f000 	ldr.w	pc, [pc]	; 66ec <___init_veneer+0x4>
    66ec:	60001e19 	.word	0x60001e19

000066f0 <___reboot_Teensyduino__veneer>:
    66f0:	f85f f000 	ldr.w	pc, [pc]	; 66f4 <___reboot_Teensyduino__veneer+0x4>
    66f4:	60001dc5 	.word	0x60001dc5
	...

Disassembly of section .fini:

00006700 <_fini>:
    6700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6702:	bf00      	nop

Disassembly of section .text.csf:

60009d28 <_heap_end+0x3fd89d28>:
60009d28:	ffffffff 	.word	0xffffffff
60009d2c:	ffffffff 	.word	0xffffffff
60009d30:	ffffffff 	.word	0xffffffff
60009d34:	ffffffff 	.word	0xffffffff
60009d38:	ffffffff 	.word	0xffffffff
60009d3c:	ffffffff 	.word	0xffffffff
60009d40:	ffffffff 	.word	0xffffffff
60009d44:	ffffffff 	.word	0xffffffff
60009d48:	ffffffff 	.word	0xffffffff
60009d4c:	ffffffff 	.word	0xffffffff
60009d50:	ffffffff 	.word	0xffffffff
60009d54:	ffffffff 	.word	0xffffffff
60009d58:	ffffffff 	.word	0xffffffff
60009d5c:	ffffffff 	.word	0xffffffff
60009d60:	ffffffff 	.word	0xffffffff
60009d64:	ffffffff 	.word	0xffffffff
60009d68:	ffffffff 	.word	0xffffffff
60009d6c:	ffffffff 	.word	0xffffffff
60009d70:	ffffffff 	.word	0xffffffff
60009d74:	ffffffff 	.word	0xffffffff
60009d78:	ffffffff 	.word	0xffffffff
60009d7c:	ffffffff 	.word	0xffffffff
60009d80:	ffffffff 	.word	0xffffffff
60009d84:	ffffffff 	.word	0xffffffff
60009d88:	ffffffff 	.word	0xffffffff
60009d8c:	ffffffff 	.word	0xffffffff
60009d90:	ffffffff 	.word	0xffffffff
60009d94:	ffffffff 	.word	0xffffffff
60009d98:	ffffffff 	.word	0xffffffff
60009d9c:	ffffffff 	.word	0xffffffff
60009da0:	ffffffff 	.word	0xffffffff
60009da4:	ffffffff 	.word	0xffffffff
60009da8:	ffffffff 	.word	0xffffffff
60009dac:	ffffffff 	.word	0xffffffff
60009db0:	ffffffff 	.word	0xffffffff
60009db4:	ffffffff 	.word	0xffffffff
60009db8:	ffffffff 	.word	0xffffffff
60009dbc:	ffffffff 	.word	0xffffffff
60009dc0:	ffffffff 	.word	0xffffffff
60009dc4:	ffffffff 	.word	0xffffffff
60009dc8:	ffffffff 	.word	0xffffffff
60009dcc:	ffffffff 	.word	0xffffffff
60009dd0:	ffffffff 	.word	0xffffffff
60009dd4:	ffffffff 	.word	0xffffffff
60009dd8:	ffffffff 	.word	0xffffffff
60009ddc:	ffffffff 	.word	0xffffffff
60009de0:	ffffffff 	.word	0xffffffff
60009de4:	ffffffff 	.word	0xffffffff
60009de8:	ffffffff 	.word	0xffffffff
60009dec:	ffffffff 	.word	0xffffffff
60009df0:	ffffffff 	.word	0xffffffff
60009df4:	ffffffff 	.word	0xffffffff
60009df8:	ffffffff 	.word	0xffffffff
60009dfc:	ffffffff 	.word	0xffffffff
60009e00:	ffffffff 	.word	0xffffffff
60009e04:	ffffffff 	.word	0xffffffff
60009e08:	ffffffff 	.word	0xffffffff
60009e0c:	ffffffff 	.word	0xffffffff
60009e10:	ffffffff 	.word	0xffffffff
60009e14:	ffffffff 	.word	0xffffffff
60009e18:	ffffffff 	.word	0xffffffff
60009e1c:	ffffffff 	.word	0xffffffff
60009e20:	ffffffff 	.word	0xffffffff
60009e24:	ffffffff 	.word	0xffffffff
60009e28:	ffffffff 	.word	0xffffffff
60009e2c:	ffffffff 	.word	0xffffffff
60009e30:	ffffffff 	.word	0xffffffff
60009e34:	ffffffff 	.word	0xffffffff
60009e38:	ffffffff 	.word	0xffffffff
60009e3c:	ffffffff 	.word	0xffffffff
60009e40:	ffffffff 	.word	0xffffffff
60009e44:	ffffffff 	.word	0xffffffff
60009e48:	ffffffff 	.word	0xffffffff
60009e4c:	ffffffff 	.word	0xffffffff
60009e50:	ffffffff 	.word	0xffffffff
60009e54:	ffffffff 	.word	0xffffffff
60009e58:	ffffffff 	.word	0xffffffff
60009e5c:	ffffffff 	.word	0xffffffff
60009e60:	ffffffff 	.word	0xffffffff
60009e64:	ffffffff 	.word	0xffffffff
60009e68:	ffffffff 	.word	0xffffffff
60009e6c:	ffffffff 	.word	0xffffffff
60009e70:	ffffffff 	.word	0xffffffff
60009e74:	ffffffff 	.word	0xffffffff
60009e78:	ffffffff 	.word	0xffffffff
60009e7c:	ffffffff 	.word	0xffffffff
60009e80:	ffffffff 	.word	0xffffffff
60009e84:	ffffffff 	.word	0xffffffff
60009e88:	ffffffff 	.word	0xffffffff
60009e8c:	ffffffff 	.word	0xffffffff
60009e90:	ffffffff 	.word	0xffffffff
60009e94:	ffffffff 	.word	0xffffffff
60009e98:	ffffffff 	.word	0xffffffff
60009e9c:	ffffffff 	.word	0xffffffff
60009ea0:	ffffffff 	.word	0xffffffff
60009ea4:	ffffffff 	.word	0xffffffff
60009ea8:	ffffffff 	.word	0xffffffff
60009eac:	ffffffff 	.word	0xffffffff
60009eb0:	ffffffff 	.word	0xffffffff
60009eb4:	ffffffff 	.word	0xffffffff
60009eb8:	ffffffff 	.word	0xffffffff
60009ebc:	ffffffff 	.word	0xffffffff
60009ec0:	ffffffff 	.word	0xffffffff
60009ec4:	ffffffff 	.word	0xffffffff
60009ec8:	ffffffff 	.word	0xffffffff
60009ecc:	ffffffff 	.word	0xffffffff
60009ed0:	ffffffff 	.word	0xffffffff
60009ed4:	ffffffff 	.word	0xffffffff
60009ed8:	ffffffff 	.word	0xffffffff
60009edc:	ffffffff 	.word	0xffffffff
60009ee0:	ffffffff 	.word	0xffffffff
60009ee4:	ffffffff 	.word	0xffffffff
60009ee8:	ffffffff 	.word	0xffffffff
60009eec:	ffffffff 	.word	0xffffffff
60009ef0:	ffffffff 	.word	0xffffffff
60009ef4:	ffffffff 	.word	0xffffffff
60009ef8:	ffffffff 	.word	0xffffffff
60009efc:	ffffffff 	.word	0xffffffff
60009f00:	ffffffff 	.word	0xffffffff
60009f04:	ffffffff 	.word	0xffffffff
60009f08:	ffffffff 	.word	0xffffffff
60009f0c:	ffffffff 	.word	0xffffffff
60009f10:	ffffffff 	.word	0xffffffff
60009f14:	ffffffff 	.word	0xffffffff
60009f18:	ffffffff 	.word	0xffffffff
60009f1c:	ffffffff 	.word	0xffffffff
60009f20:	ffffffff 	.word	0xffffffff
60009f24:	ffffffff 	.word	0xffffffff
60009f28:	ffffffff 	.word	0xffffffff
60009f2c:	ffffffff 	.word	0xffffffff
60009f30:	ffffffff 	.word	0xffffffff
60009f34:	ffffffff 	.word	0xffffffff
60009f38:	ffffffff 	.word	0xffffffff
60009f3c:	ffffffff 	.word	0xffffffff
60009f40:	ffffffff 	.word	0xffffffff
60009f44:	ffffffff 	.word	0xffffffff
60009f48:	ffffffff 	.word	0xffffffff
60009f4c:	ffffffff 	.word	0xffffffff
60009f50:	ffffffff 	.word	0xffffffff
60009f54:	ffffffff 	.word	0xffffffff
60009f58:	ffffffff 	.word	0xffffffff
60009f5c:	ffffffff 	.word	0xffffffff
60009f60:	ffffffff 	.word	0xffffffff
60009f64:	ffffffff 	.word	0xffffffff
60009f68:	ffffffff 	.word	0xffffffff
60009f6c:	ffffffff 	.word	0xffffffff
60009f70:	ffffffff 	.word	0xffffffff
60009f74:	ffffffff 	.word	0xffffffff
60009f78:	ffffffff 	.word	0xffffffff
60009f7c:	ffffffff 	.word	0xffffffff
60009f80:	ffffffff 	.word	0xffffffff
60009f84:	ffffffff 	.word	0xffffffff
60009f88:	ffffffff 	.word	0xffffffff
60009f8c:	ffffffff 	.word	0xffffffff
60009f90:	ffffffff 	.word	0xffffffff
60009f94:	ffffffff 	.word	0xffffffff
60009f98:	ffffffff 	.word	0xffffffff
60009f9c:	ffffffff 	.word	0xffffffff
60009fa0:	ffffffff 	.word	0xffffffff
60009fa4:	ffffffff 	.word	0xffffffff
60009fa8:	ffffffff 	.word	0xffffffff
60009fac:	ffffffff 	.word	0xffffffff
60009fb0:	ffffffff 	.word	0xffffffff
60009fb4:	ffffffff 	.word	0xffffffff
60009fb8:	ffffffff 	.word	0xffffffff
60009fbc:	ffffffff 	.word	0xffffffff
60009fc0:	ffffffff 	.word	0xffffffff
60009fc4:	ffffffff 	.word	0xffffffff
60009fc8:	ffffffff 	.word	0xffffffff
60009fcc:	ffffffff 	.word	0xffffffff
60009fd0:	ffffffff 	.word	0xffffffff
60009fd4:	ffffffff 	.word	0xffffffff
60009fd8:	ffffffff 	.word	0xffffffff
60009fdc:	ffffffff 	.word	0xffffffff
60009fe0:	ffffffff 	.word	0xffffffff
60009fe4:	ffffffff 	.word	0xffffffff
60009fe8:	ffffffff 	.word	0xffffffff
60009fec:	ffffffff 	.word	0xffffffff
60009ff0:	ffffffff 	.word	0xffffffff
60009ff4:	ffffffff 	.word	0xffffffff
60009ff8:	ffffffff 	.word	0xffffffff
60009ffc:	ffffffff 	.word	0xffffffff

6000a000 <hab_csf>:
	...
